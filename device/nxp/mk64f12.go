// Automatically generated file. DO NOT EDIT.
// Generated by gen-device-svd.go from MK64F12.svd, see https://github.com/posborne/cmsis-svd/tree/master/data/NXP

//go:build nxp && mk64f12

/*
// MK64F12 NXP Microcontroller
*/
//     Copyright 2016-2018 NXP SPDX-License-Identifier: BSD-3-Clause
package nxp

import (
	"runtime/volatile"
	"unsafe"
)

// Some information about this device.
const (
	Device       = "MK64F12"
	CPU          = "CM4"
	FPUPresent   = true
	NVICPrioBits = 4
)

// Interrupt numbers.
const (
	// Enhanced direct memory access controller
	IRQ_DMA0 = 0

	// Enhanced direct memory access controller
	IRQ_DMA1 = 1

	// Enhanced direct memory access controller
	IRQ_DMA2 = 2

	// Enhanced direct memory access controller
	IRQ_DMA3 = 3

	// Enhanced direct memory access controller
	IRQ_DMA4 = 4

	// Enhanced direct memory access controller
	IRQ_DMA5 = 5

	// Enhanced direct memory access controller
	IRQ_DMA6 = 6

	// Enhanced direct memory access controller
	IRQ_DMA7 = 7

	// Enhanced direct memory access controller
	IRQ_DMA8 = 8

	// Enhanced direct memory access controller
	IRQ_DMA9 = 9

	// Enhanced direct memory access controller
	IRQ_DMA10 = 10

	// Enhanced direct memory access controller
	IRQ_DMA11 = 11

	// Enhanced direct memory access controller
	IRQ_DMA12 = 12

	// Enhanced direct memory access controller
	IRQ_DMA13 = 13

	// Enhanced direct memory access controller
	IRQ_DMA14 = 14

	// Enhanced direct memory access controller
	IRQ_DMA15 = 15

	// Enhanced direct memory access controller
	IRQ_DMA_Error = 16

	// Core Platform Miscellaneous Control Module
	IRQ_MCM = 17

	// Flash Memory Interface
	IRQ_FTFE = 18

	// Flash Memory Interface
	IRQ_Read_Collision = 19

	// Power Management Controller
	IRQ_LVD_LVW = 20

	// Low leakage wakeup unit
	IRQ_LLWU = 21

	// Generation 2008 Watchdog Timer // External Watchdog Monitor
	IRQ_WDOG_EWM = 22

	// Random Number Generator Accelerator
	IRQ_RNG = 23

	// Inter-Integrated Circuit
	IRQ_I2C0 = 24

	// Inter-Integrated Circuit
	IRQ_I2C1 = 25

	// Serial Peripheral Interface
	IRQ_SPI0 = 26

	// Serial Peripheral Interface
	IRQ_SPI1 = 27

	// Inter-IC Sound / Synchronous Audio Interface
	IRQ_I2S0_Tx = 28

	// Inter-IC Sound / Synchronous Audio Interface
	IRQ_I2S0_Rx = 29

	// Serial Communication Interface
	IRQ_UART0_LON = 30

	// Serial Communication Interface
	IRQ_UART0_RX_TX = 31

	// Serial Communication Interface
	IRQ_UART0_ERR = 32

	// Serial Communication Interface
	IRQ_UART1_RX_TX = 33

	// Serial Communication Interface
	IRQ_UART1_ERR = 34

	// Serial Communication Interface
	IRQ_UART2_RX_TX = 35

	// Serial Communication Interface
	IRQ_UART2_ERR = 36

	// Serial Communication Interface
	IRQ_UART3_RX_TX = 37

	// Serial Communication Interface
	IRQ_UART3_ERR = 38

	// Analog-to-Digital Converter
	IRQ_ADC0 = 39

	// High-Speed Comparator (CMP), Voltage Reference (VREF) Digital-to-Analog Converter (DAC), and Analog Mux (ANMUX)
	IRQ_CMP0 = 40

	// High-Speed Comparator (CMP), Voltage Reference (VREF) Digital-to-Analog Converter (DAC), and Analog Mux (ANMUX)
	IRQ_CMP1 = 41

	// FlexTimer Module
	IRQ_FTM0 = 42

	// FlexTimer Module
	IRQ_FTM1 = 43

	// FlexTimer Module
	IRQ_FTM2 = 44

	// Carrier Modulator Transmitter
	IRQ_CMT = 45

	// Secure Real Time Clock
	IRQ_RTC = 46

	// Secure Real Time Clock
	IRQ_RTC_Seconds = 47

	// Periodic Interrupt Timer
	IRQ_PIT0 = 48

	// Periodic Interrupt Timer
	IRQ_PIT1 = 49

	// Periodic Interrupt Timer
	IRQ_PIT2 = 50

	// Periodic Interrupt Timer
	IRQ_PIT3 = 51

	// Programmable Delay Block
	IRQ_PDB0 = 52

	// Universal Serial Bus, OTG Capable Controller
	IRQ_USB0 = 53

	// USB Device Charger Detection module
	IRQ_USBDCD = 54

	// 12-Bit Digital-to-Analog Converter
	IRQ_DAC0 = 56

	// Low Power Timer
	IRQ_LPTMR0 = 58

	// Pin Control and Interrupts // General Purpose Input/Output
	IRQ_PORTA = 59

	// Pin Control and Interrupts // General Purpose Input/Output
	IRQ_PORTB = 60

	// Pin Control and Interrupts // General Purpose Input/Output
	IRQ_PORTC = 61

	// Pin Control and Interrupts // General Purpose Input/Output
	IRQ_PORTD = 62

	// Pin Control and Interrupts // General Purpose Input/Output
	IRQ_PORTE = 63

	// Serial Peripheral Interface
	IRQ_SPI2 = 65

	// Serial Communication Interface
	IRQ_UART4_RX_TX = 66

	// Serial Communication Interface
	IRQ_UART4_ERR = 67

	// Serial Communication Interface
	IRQ_UART5_RX_TX = 68

	// Serial Communication Interface
	IRQ_UART5_ERR = 69

	// High-Speed Comparator (CMP), Voltage Reference (VREF) Digital-to-Analog Converter (DAC), and Analog Mux (ANMUX)
	IRQ_CMP2 = 70

	// FlexTimer Module
	IRQ_FTM3 = 71

	// 12-Bit Digital-to-Analog Converter
	IRQ_DAC1 = 72

	// Analog-to-Digital Converter
	IRQ_ADC1 = 73

	// Inter-Integrated Circuit
	IRQ_I2C2 = 74

	// Flex Controller Area Network module
	IRQ_CAN0_ORed_Message_buffer = 75

	// Flex Controller Area Network module
	IRQ_CAN0_Bus_Off = 76

	// Flex Controller Area Network module
	IRQ_CAN0_Error = 77

	// Flex Controller Area Network module
	IRQ_CAN0_Tx_Warning = 78

	// Flex Controller Area Network module
	IRQ_CAN0_Rx_Warning = 79

	// Flex Controller Area Network module
	IRQ_CAN0_Wake_Up = 80

	// Secured Digital Host Controller
	IRQ_SDHC = 81

	// Ethernet MAC-NET Core
	IRQ_ENET_1588_Timer = 82

	// Ethernet MAC-NET Core
	IRQ_ENET_Transmit = 83

	// Ethernet MAC-NET Core
	IRQ_ENET_Receive = 84

	// Ethernet MAC-NET Core
	IRQ_ENET_Error = 85

	// Highest interrupt number on this device.
	IRQ_max = 85
)

// Pseudo function call that is replaced by the compiler with the actual
// functions registered through interrupt.New.
//
//go:linkname callHandlers runtime/interrupt.callHandlers
func callHandlers(num int)

//export DMA0_IRQHandler
func interruptDMA0() {
	callHandlers(IRQ_DMA0)
}

//export DMA1_IRQHandler
func interruptDMA1() {
	callHandlers(IRQ_DMA1)
}

//export DMA2_IRQHandler
func interruptDMA2() {
	callHandlers(IRQ_DMA2)
}

//export DMA3_IRQHandler
func interruptDMA3() {
	callHandlers(IRQ_DMA3)
}

//export DMA4_IRQHandler
func interruptDMA4() {
	callHandlers(IRQ_DMA4)
}

//export DMA5_IRQHandler
func interruptDMA5() {
	callHandlers(IRQ_DMA5)
}

//export DMA6_IRQHandler
func interruptDMA6() {
	callHandlers(IRQ_DMA6)
}

//export DMA7_IRQHandler
func interruptDMA7() {
	callHandlers(IRQ_DMA7)
}

//export DMA8_IRQHandler
func interruptDMA8() {
	callHandlers(IRQ_DMA8)
}

//export DMA9_IRQHandler
func interruptDMA9() {
	callHandlers(IRQ_DMA9)
}

//export DMA10_IRQHandler
func interruptDMA10() {
	callHandlers(IRQ_DMA10)
}

//export DMA11_IRQHandler
func interruptDMA11() {
	callHandlers(IRQ_DMA11)
}

//export DMA12_IRQHandler
func interruptDMA12() {
	callHandlers(IRQ_DMA12)
}

//export DMA13_IRQHandler
func interruptDMA13() {
	callHandlers(IRQ_DMA13)
}

//export DMA14_IRQHandler
func interruptDMA14() {
	callHandlers(IRQ_DMA14)
}

//export DMA15_IRQHandler
func interruptDMA15() {
	callHandlers(IRQ_DMA15)
}

//export DMA_Error_IRQHandler
func interruptDMA_Error() {
	callHandlers(IRQ_DMA_Error)
}

//export MCM_IRQHandler
func interruptMCM() {
	callHandlers(IRQ_MCM)
}

//export FTFE_IRQHandler
func interruptFTFE() {
	callHandlers(IRQ_FTFE)
}

//export Read_Collision_IRQHandler
func interruptRead_Collision() {
	callHandlers(IRQ_Read_Collision)
}

//export LVD_LVW_IRQHandler
func interruptLVD_LVW() {
	callHandlers(IRQ_LVD_LVW)
}

//export LLWU_IRQHandler
func interruptLLWU() {
	callHandlers(IRQ_LLWU)
}

//export WDOG_EWM_IRQHandler
func interruptWDOG_EWM() {
	callHandlers(IRQ_WDOG_EWM)
}

//export RNG_IRQHandler
func interruptRNG() {
	callHandlers(IRQ_RNG)
}

//export I2C0_IRQHandler
func interruptI2C0() {
	callHandlers(IRQ_I2C0)
}

//export I2C1_IRQHandler
func interruptI2C1() {
	callHandlers(IRQ_I2C1)
}

//export SPI0_IRQHandler
func interruptSPI0() {
	callHandlers(IRQ_SPI0)
}

//export SPI1_IRQHandler
func interruptSPI1() {
	callHandlers(IRQ_SPI1)
}

//export I2S0_Tx_IRQHandler
func interruptI2S0_Tx() {
	callHandlers(IRQ_I2S0_Tx)
}

//export I2S0_Rx_IRQHandler
func interruptI2S0_Rx() {
	callHandlers(IRQ_I2S0_Rx)
}

//export UART0_LON_IRQHandler
func interruptUART0_LON() {
	callHandlers(IRQ_UART0_LON)
}

//export UART0_RX_TX_IRQHandler
func interruptUART0_RX_TX() {
	callHandlers(IRQ_UART0_RX_TX)
}

//export UART0_ERR_IRQHandler
func interruptUART0_ERR() {
	callHandlers(IRQ_UART0_ERR)
}

//export UART1_RX_TX_IRQHandler
func interruptUART1_RX_TX() {
	callHandlers(IRQ_UART1_RX_TX)
}

//export UART1_ERR_IRQHandler
func interruptUART1_ERR() {
	callHandlers(IRQ_UART1_ERR)
}

//export UART2_RX_TX_IRQHandler
func interruptUART2_RX_TX() {
	callHandlers(IRQ_UART2_RX_TX)
}

//export UART2_ERR_IRQHandler
func interruptUART2_ERR() {
	callHandlers(IRQ_UART2_ERR)
}

//export UART3_RX_TX_IRQHandler
func interruptUART3_RX_TX() {
	callHandlers(IRQ_UART3_RX_TX)
}

//export UART3_ERR_IRQHandler
func interruptUART3_ERR() {
	callHandlers(IRQ_UART3_ERR)
}

//export ADC0_IRQHandler
func interruptADC0() {
	callHandlers(IRQ_ADC0)
}

//export CMP0_IRQHandler
func interruptCMP0() {
	callHandlers(IRQ_CMP0)
}

//export CMP1_IRQHandler
func interruptCMP1() {
	callHandlers(IRQ_CMP1)
}

//export FTM0_IRQHandler
func interruptFTM0() {
	callHandlers(IRQ_FTM0)
}

//export FTM1_IRQHandler
func interruptFTM1() {
	callHandlers(IRQ_FTM1)
}

//export FTM2_IRQHandler
func interruptFTM2() {
	callHandlers(IRQ_FTM2)
}

//export CMT_IRQHandler
func interruptCMT() {
	callHandlers(IRQ_CMT)
}

//export RTC_IRQHandler
func interruptRTC() {
	callHandlers(IRQ_RTC)
}

//export RTC_Seconds_IRQHandler
func interruptRTC_Seconds() {
	callHandlers(IRQ_RTC_Seconds)
}

//export PIT0_IRQHandler
func interruptPIT0() {
	callHandlers(IRQ_PIT0)
}

//export PIT1_IRQHandler
func interruptPIT1() {
	callHandlers(IRQ_PIT1)
}

//export PIT2_IRQHandler
func interruptPIT2() {
	callHandlers(IRQ_PIT2)
}

//export PIT3_IRQHandler
func interruptPIT3() {
	callHandlers(IRQ_PIT3)
}

//export PDB0_IRQHandler
func interruptPDB0() {
	callHandlers(IRQ_PDB0)
}

//export USB0_IRQHandler
func interruptUSB0() {
	callHandlers(IRQ_USB0)
}

//export USBDCD_IRQHandler
func interruptUSBDCD() {
	callHandlers(IRQ_USBDCD)
}

//export DAC0_IRQHandler
func interruptDAC0() {
	callHandlers(IRQ_DAC0)
}

//export LPTMR0_IRQHandler
func interruptLPTMR0() {
	callHandlers(IRQ_LPTMR0)
}

//export PORTA_IRQHandler
func interruptPORTA() {
	callHandlers(IRQ_PORTA)
}

//export PORTB_IRQHandler
func interruptPORTB() {
	callHandlers(IRQ_PORTB)
}

//export PORTC_IRQHandler
func interruptPORTC() {
	callHandlers(IRQ_PORTC)
}

//export PORTD_IRQHandler
func interruptPORTD() {
	callHandlers(IRQ_PORTD)
}

//export PORTE_IRQHandler
func interruptPORTE() {
	callHandlers(IRQ_PORTE)
}

//export SPI2_IRQHandler
func interruptSPI2() {
	callHandlers(IRQ_SPI2)
}

//export UART4_RX_TX_IRQHandler
func interruptUART4_RX_TX() {
	callHandlers(IRQ_UART4_RX_TX)
}

//export UART4_ERR_IRQHandler
func interruptUART4_ERR() {
	callHandlers(IRQ_UART4_ERR)
}

//export UART5_RX_TX_IRQHandler
func interruptUART5_RX_TX() {
	callHandlers(IRQ_UART5_RX_TX)
}

//export UART5_ERR_IRQHandler
func interruptUART5_ERR() {
	callHandlers(IRQ_UART5_ERR)
}

//export CMP2_IRQHandler
func interruptCMP2() {
	callHandlers(IRQ_CMP2)
}

//export FTM3_IRQHandler
func interruptFTM3() {
	callHandlers(IRQ_FTM3)
}

//export DAC1_IRQHandler
func interruptDAC1() {
	callHandlers(IRQ_DAC1)
}

//export ADC1_IRQHandler
func interruptADC1() {
	callHandlers(IRQ_ADC1)
}

//export I2C2_IRQHandler
func interruptI2C2() {
	callHandlers(IRQ_I2C2)
}

//export CAN0_ORed_Message_buffer_IRQHandler
func interruptCAN0_ORed_Message_buffer() {
	callHandlers(IRQ_CAN0_ORed_Message_buffer)
}

//export CAN0_Bus_Off_IRQHandler
func interruptCAN0_Bus_Off() {
	callHandlers(IRQ_CAN0_Bus_Off)
}

//export CAN0_Error_IRQHandler
func interruptCAN0_Error() {
	callHandlers(IRQ_CAN0_Error)
}

//export CAN0_Tx_Warning_IRQHandler
func interruptCAN0_Tx_Warning() {
	callHandlers(IRQ_CAN0_Tx_Warning)
}

//export CAN0_Rx_Warning_IRQHandler
func interruptCAN0_Rx_Warning() {
	callHandlers(IRQ_CAN0_Rx_Warning)
}

//export CAN0_Wake_Up_IRQHandler
func interruptCAN0_Wake_Up() {
	callHandlers(IRQ_CAN0_Wake_Up)
}

//export SDHC_IRQHandler
func interruptSDHC() {
	callHandlers(IRQ_SDHC)
}

//export ENET_1588_Timer_IRQHandler
func interruptENET_1588_Timer() {
	callHandlers(IRQ_ENET_1588_Timer)
}

//export ENET_Transmit_IRQHandler
func interruptENET_Transmit() {
	callHandlers(IRQ_ENET_Transmit)
}

//export ENET_Receive_IRQHandler
func interruptENET_Receive() {
	callHandlers(IRQ_ENET_Receive)
}

//export ENET_Error_IRQHandler
func interruptENET_Error() {
	callHandlers(IRQ_ENET_Error)
}

// Peripherals.
var (
	// Flash configuration field
	FTFE_FlashConfig = (*FTFE_FlashConfig_Type)(unsafe.Pointer(uintptr(0x400)))

	// AIPS-Lite Bridge
	AIPS0 = (*AIPS_Type)(unsafe.Pointer(uintptr(0x40000000)))

	// AIPS-Lite Bridge
	AIPS1 = (*AIPS_Type)(unsafe.Pointer(uintptr(0x40080000)))

	// Crossbar switch
	AXBS = (*AXBS_Type)(unsafe.Pointer(uintptr(0x40004000)))

	// Enhanced direct memory access controller
	DMA = (*DMA_Type)(unsafe.Pointer(uintptr(0x40008000)))

	// FlexBus external bus interface
	FB = (*FB_Type)(unsafe.Pointer(uintptr(0x4000c000)))

	// Memory protection unit
	SYSMPU = (*SYSMPU_Type)(unsafe.Pointer(uintptr(0x4000d000)))

	// Flash Memory Controller
	FMC = (*FMC_Type)(unsafe.Pointer(uintptr(0x4001f000)))

	// Flash Memory Interface
	FTFE = (*FTFE_Type)(unsafe.Pointer(uintptr(0x40020000)))

	// DMA channel multiplexor
	DMAMUX = (*DMAMUX_Type)(unsafe.Pointer(uintptr(0x40021000)))

	// Flex Controller Area Network module
	CAN0 = (*CAN0_Type)(unsafe.Pointer(uintptr(0x40024000)))

	// Random Number Generator Accelerator
	RNG = (*RNG_Type)(unsafe.Pointer(uintptr(0x40029000)))

	// Serial Peripheral Interface
	SPI0 = (*SPI_Type)(unsafe.Pointer(uintptr(0x4002c000)))

	// Serial Peripheral Interface
	SPI1 = (*SPI_Type)(unsafe.Pointer(uintptr(0x4002d000)))

	// Serial Peripheral Interface
	SPI2 = (*SPI_Type)(unsafe.Pointer(uintptr(0x400ac000)))

	// Inter-IC Sound / Synchronous Audio Interface
	I2S0 = (*I2S0_Type)(unsafe.Pointer(uintptr(0x4002f000)))

	// Cyclic Redundancy Check
	CRC = (*CRC_Type)(unsafe.Pointer(uintptr(0x40032000)))

	// USB Device Charger Detection module
	USBDCD = (*USBDCD_Type)(unsafe.Pointer(uintptr(0x40035000)))

	// Programmable Delay Block
	PDB0 = (*PDB0_Type)(unsafe.Pointer(uintptr(0x40036000)))

	// Periodic Interrupt Timer
	PIT = (*PIT_Type)(unsafe.Pointer(uintptr(0x40037000)))

	// FlexTimer Module
	FTM0 = (*FTM_Type)(unsafe.Pointer(uintptr(0x40038000)))

	// FlexTimer Module
	FTM1 = (*FTM_Type)(unsafe.Pointer(uintptr(0x40039000)))

	// FlexTimer Module
	FTM2 = (*FTM_Type)(unsafe.Pointer(uintptr(0x4003a000)))

	// FlexTimer Module
	FTM3 = (*FTM_Type)(unsafe.Pointer(uintptr(0x400b9000)))

	// Analog-to-Digital Converter
	ADC0 = (*ADC_Type)(unsafe.Pointer(uintptr(0x4003b000)))

	// Analog-to-Digital Converter
	ADC1 = (*ADC_Type)(unsafe.Pointer(uintptr(0x400bb000)))

	// Secure Real Time Clock
	RTC = (*RTC_Type)(unsafe.Pointer(uintptr(0x4003d000)))

	// VBAT register file
	RFVBAT = (*RFVBAT_Type)(unsafe.Pointer(uintptr(0x4003e000)))

	// Low Power Timer
	LPTMR0 = (*LPTMR0_Type)(unsafe.Pointer(uintptr(0x40040000)))

	// System register file
	RFSYS = (*RFSYS_Type)(unsafe.Pointer(uintptr(0x40041000)))

	// System Integration Module
	SIM = (*SIM_Type)(unsafe.Pointer(uintptr(0x40047000)))

	// Pin Control and Interrupts
	PORTA = (*PORT_Type)(unsafe.Pointer(uintptr(0x40049000)))

	// Pin Control and Interrupts
	PORTB = (*PORT_Type)(unsafe.Pointer(uintptr(0x4004a000)))

	// Pin Control and Interrupts
	PORTC = (*PORT_Type)(unsafe.Pointer(uintptr(0x4004b000)))

	// Pin Control and Interrupts
	PORTD = (*PORT_Type)(unsafe.Pointer(uintptr(0x4004c000)))

	// Pin Control and Interrupts
	PORTE = (*PORT_Type)(unsafe.Pointer(uintptr(0x4004d000)))

	// Generation 2008 Watchdog Timer
	WDOG = (*WDOG_Type)(unsafe.Pointer(uintptr(0x40052000)))

	// External Watchdog Monitor
	EWM = (*EWM_Type)(unsafe.Pointer(uintptr(0x40061000)))

	// Carrier Modulator Transmitter
	CMT = (*CMT_Type)(unsafe.Pointer(uintptr(0x40062000)))

	// Multipurpose Clock Generator module
	MCG = (*MCG_Type)(unsafe.Pointer(uintptr(0x40064000)))

	// Oscillator
	OSC = (*OSC_Type)(unsafe.Pointer(uintptr(0x40065000)))

	// Inter-Integrated Circuit
	I2C0 = (*I2C_Type)(unsafe.Pointer(uintptr(0x40066000)))

	// Inter-Integrated Circuit
	I2C1 = (*I2C_Type)(unsafe.Pointer(uintptr(0x40067000)))

	// Inter-Integrated Circuit
	I2C2 = (*I2C_Type)(unsafe.Pointer(uintptr(0x400e6000)))

	// Serial Communication Interface
	UART0 = (*UART_Type)(unsafe.Pointer(uintptr(0x4006a000)))

	// Serial Communication Interface
	UART1 = (*UART_Type)(unsafe.Pointer(uintptr(0x4006b000)))

	// Serial Communication Interface
	UART2 = (*UART_Type)(unsafe.Pointer(uintptr(0x4006c000)))

	// Serial Communication Interface
	UART3 = (*UART_Type)(unsafe.Pointer(uintptr(0x4006d000)))

	// Serial Communication Interface
	UART4 = (*UART_Type)(unsafe.Pointer(uintptr(0x400ea000)))

	// Serial Communication Interface
	UART5 = (*UART_Type)(unsafe.Pointer(uintptr(0x400eb000)))

	// Universal Serial Bus, OTG Capable Controller
	USB0 = (*USB0_Type)(unsafe.Pointer(uintptr(0x40072000)))

	// High-Speed Comparator (CMP), Voltage Reference (VREF) Digital-to-Analog Converter (DAC), and Analog Mux (ANMUX)
	CMP0 = (*CMP_Type)(unsafe.Pointer(uintptr(0x40073000)))

	// High-Speed Comparator (CMP), Voltage Reference (VREF) Digital-to-Analog Converter (DAC), and Analog Mux (ANMUX)
	CMP1 = (*CMP_Type)(unsafe.Pointer(uintptr(0x40073008)))

	// High-Speed Comparator (CMP), Voltage Reference (VREF) Digital-to-Analog Converter (DAC), and Analog Mux (ANMUX)
	CMP2 = (*CMP_Type)(unsafe.Pointer(uintptr(0x40073010)))

	// Voltage Reference
	VREF = (*VREF_Type)(unsafe.Pointer(uintptr(0x40074000)))

	// Low leakage wakeup unit
	LLWU = (*LLWU_Type)(unsafe.Pointer(uintptr(0x4007c000)))

	// Power Management Controller
	PMC = (*PMC_Type)(unsafe.Pointer(uintptr(0x4007d000)))

	// System Mode Controller
	SMC = (*SMC_Type)(unsafe.Pointer(uintptr(0x4007e000)))

	// Reset Control Module
	RCM = (*RCM_Type)(unsafe.Pointer(uintptr(0x4007f000)))

	// Secured Digital Host Controller
	SDHC = (*SDHC_Type)(unsafe.Pointer(uintptr(0x400b1000)))

	// Ethernet MAC-NET Core
	ENET = (*ENET_Type)(unsafe.Pointer(uintptr(0x400c0000)))

	// 12-Bit Digital-to-Analog Converter
	DAC0 = (*DAC_Type)(unsafe.Pointer(uintptr(0x400cc000)))

	// 12-Bit Digital-to-Analog Converter
	DAC1 = (*DAC_Type)(unsafe.Pointer(uintptr(0x400cd000)))

	// General Purpose Input/Output
	GPIOA = (*GPIO_Type)(unsafe.Pointer(uintptr(0x400ff000)))

	// General Purpose Input/Output
	GPIOB = (*GPIO_Type)(unsafe.Pointer(uintptr(0x400ff040)))

	// General Purpose Input/Output
	GPIOC = (*GPIO_Type)(unsafe.Pointer(uintptr(0x400ff080)))

	// General Purpose Input/Output
	GPIOD = (*GPIO_Type)(unsafe.Pointer(uintptr(0x400ff0c0)))

	// General Purpose Input/Output
	GPIOE = (*GPIO_Type)(unsafe.Pointer(uintptr(0x400ff100)))

	// System Control Block
	SystemControl = (*SystemControl_Type)(unsafe.Pointer(uintptr(0xe000e000)))

	// System timer
	SysTick = (*SysTick_Type)(unsafe.Pointer(uintptr(0xe000e010)))

	// Nested Vectored Interrupt Controller
	NVIC = (*NVIC_Type)(unsafe.Pointer(uintptr(0xe000e100)))

	// Core Platform Miscellaneous Control Module
	MCM = (*MCM_Type)(unsafe.Pointer(uintptr(0xe0080000)))

	// Memory Mapped Cryptographic Acceleration Unit (MMCAU)
	CAU = (*CAU_Type)(unsafe.Pointer(uintptr(0xe0081000)))
)

// Flash configuration field
type FTFE_FlashConfig_Type struct {
	BACKKEY3 volatile.Register8 // 0x0
	BACKKEY2 volatile.Register8 // 0x1
	BACKKEY1 volatile.Register8 // 0x2
	BACKKEY0 volatile.Register8 // 0x3
	BACKKEY7 volatile.Register8 // 0x4
	BACKKEY6 volatile.Register8 // 0x5
	BACKKEY5 volatile.Register8 // 0x6
	BACKKEY4 volatile.Register8 // 0x7
	FPROT3   volatile.Register8 // 0x8
	FPROT2   volatile.Register8 // 0x9
	FPROT1   volatile.Register8 // 0xA
	FPROT0   volatile.Register8 // 0xB
	FSEC     volatile.Register8 // 0xC
	FOPT     volatile.Register8 // 0xD
	FEPROT   volatile.Register8 // 0xE
	FDPROT   volatile.Register8 // 0xF
}

// FTFE_FlashConfig.BACKKEY3: Backdoor Comparison Key 3.
func (o *FTFE_FlashConfig_Type) SetBACKKEY3(value uint8) {
	volatile.StoreUint8(&o.BACKKEY3.Reg, value)
}
func (o *FTFE_FlashConfig_Type) GetBACKKEY3() uint8 {
	return volatile.LoadUint8(&o.BACKKEY3.Reg)
}

// FTFE_FlashConfig.BACKKEY2: Backdoor Comparison Key 2.
func (o *FTFE_FlashConfig_Type) SetBACKKEY2(value uint8) {
	volatile.StoreUint8(&o.BACKKEY2.Reg, value)
}
func (o *FTFE_FlashConfig_Type) GetBACKKEY2() uint8 {
	return volatile.LoadUint8(&o.BACKKEY2.Reg)
}

// FTFE_FlashConfig.BACKKEY1: Backdoor Comparison Key 1.
func (o *FTFE_FlashConfig_Type) SetBACKKEY1(value uint8) {
	volatile.StoreUint8(&o.BACKKEY1.Reg, value)
}
func (o *FTFE_FlashConfig_Type) GetBACKKEY1() uint8 {
	return volatile.LoadUint8(&o.BACKKEY1.Reg)
}

// FTFE_FlashConfig.BACKKEY0: Backdoor Comparison Key 0.
func (o *FTFE_FlashConfig_Type) SetBACKKEY0(value uint8) {
	volatile.StoreUint8(&o.BACKKEY0.Reg, value)
}
func (o *FTFE_FlashConfig_Type) GetBACKKEY0() uint8 {
	return volatile.LoadUint8(&o.BACKKEY0.Reg)
}

// FTFE_FlashConfig.BACKKEY7: Backdoor Comparison Key 7.
func (o *FTFE_FlashConfig_Type) SetBACKKEY7(value uint8) {
	volatile.StoreUint8(&o.BACKKEY7.Reg, value)
}
func (o *FTFE_FlashConfig_Type) GetBACKKEY7() uint8 {
	return volatile.LoadUint8(&o.BACKKEY7.Reg)
}

// FTFE_FlashConfig.BACKKEY6: Backdoor Comparison Key 6.
func (o *FTFE_FlashConfig_Type) SetBACKKEY6(value uint8) {
	volatile.StoreUint8(&o.BACKKEY6.Reg, value)
}
func (o *FTFE_FlashConfig_Type) GetBACKKEY6() uint8 {
	return volatile.LoadUint8(&o.BACKKEY6.Reg)
}

// FTFE_FlashConfig.BACKKEY5: Backdoor Comparison Key 5.
func (o *FTFE_FlashConfig_Type) SetBACKKEY5(value uint8) {
	volatile.StoreUint8(&o.BACKKEY5.Reg, value)
}
func (o *FTFE_FlashConfig_Type) GetBACKKEY5() uint8 {
	return volatile.LoadUint8(&o.BACKKEY5.Reg)
}

// FTFE_FlashConfig.BACKKEY4: Backdoor Comparison Key 4.
func (o *FTFE_FlashConfig_Type) SetBACKKEY4(value uint8) {
	volatile.StoreUint8(&o.BACKKEY4.Reg, value)
}
func (o *FTFE_FlashConfig_Type) GetBACKKEY4() uint8 {
	return volatile.LoadUint8(&o.BACKKEY4.Reg)
}

// FTFE_FlashConfig.FPROT3: Non-volatile P-Flash Protection 1 - Low Register
func (o *FTFE_FlashConfig_Type) SetFPROT3(value uint8) {
	volatile.StoreUint8(&o.FPROT3.Reg, value)
}
func (o *FTFE_FlashConfig_Type) GetFPROT3() uint8 {
	return volatile.LoadUint8(&o.FPROT3.Reg)
}

// FTFE_FlashConfig.FPROT2: Non-volatile P-Flash Protection 1 - High Register
func (o *FTFE_FlashConfig_Type) SetFPROT2(value uint8) {
	volatile.StoreUint8(&o.FPROT2.Reg, value)
}
func (o *FTFE_FlashConfig_Type) GetFPROT2() uint8 {
	return volatile.LoadUint8(&o.FPROT2.Reg)
}

// FTFE_FlashConfig.FPROT1: Non-volatile P-Flash Protection 0 - Low Register
func (o *FTFE_FlashConfig_Type) SetFPROT1(value uint8) {
	volatile.StoreUint8(&o.FPROT1.Reg, value)
}
func (o *FTFE_FlashConfig_Type) GetFPROT1() uint8 {
	return volatile.LoadUint8(&o.FPROT1.Reg)
}

// FTFE_FlashConfig.FPROT0: Non-volatile P-Flash Protection 0 - High Register
func (o *FTFE_FlashConfig_Type) SetFPROT0(value uint8) {
	volatile.StoreUint8(&o.FPROT0.Reg, value)
}
func (o *FTFE_FlashConfig_Type) GetFPROT0() uint8 {
	return volatile.LoadUint8(&o.FPROT0.Reg)
}

// FTFE_FlashConfig.FSEC: Non-volatile Flash Security Register
func (o *FTFE_FlashConfig_Type) SetFSEC_SEC(value uint8) {
	volatile.StoreUint8(&o.FSEC.Reg, volatile.LoadUint8(&o.FSEC.Reg)&^(0x3)|value)
}
func (o *FTFE_FlashConfig_Type) GetFSEC_SEC() uint8 {
	return volatile.LoadUint8(&o.FSEC.Reg) & 0x3
}
func (o *FTFE_FlashConfig_Type) SetFSEC_FSLACC(value uint8) {
	volatile.StoreUint8(&o.FSEC.Reg, volatile.LoadUint8(&o.FSEC.Reg)&^(0xc)|value<<2)
}
func (o *FTFE_FlashConfig_Type) GetFSEC_FSLACC() uint8 {
	return (volatile.LoadUint8(&o.FSEC.Reg) & 0xc) >> 2
}
func (o *FTFE_FlashConfig_Type) SetFSEC_MEEN(value uint8) {
	volatile.StoreUint8(&o.FSEC.Reg, volatile.LoadUint8(&o.FSEC.Reg)&^(0x30)|value<<4)
}
func (o *FTFE_FlashConfig_Type) GetFSEC_MEEN() uint8 {
	return (volatile.LoadUint8(&o.FSEC.Reg) & 0x30) >> 4
}
func (o *FTFE_FlashConfig_Type) SetFSEC_KEYEN(value uint8) {
	volatile.StoreUint8(&o.FSEC.Reg, volatile.LoadUint8(&o.FSEC.Reg)&^(0xc0)|value<<6)
}
func (o *FTFE_FlashConfig_Type) GetFSEC_KEYEN() uint8 {
	return (volatile.LoadUint8(&o.FSEC.Reg) & 0xc0) >> 6
}

// FTFE_FlashConfig.FOPT: Non-volatile Flash Option Register
func (o *FTFE_FlashConfig_Type) SetFOPT_LPBOOT(value uint8) {
	volatile.StoreUint8(&o.FOPT.Reg, volatile.LoadUint8(&o.FOPT.Reg)&^(0x1)|value)
}
func (o *FTFE_FlashConfig_Type) GetFOPT_LPBOOT() uint8 {
	return volatile.LoadUint8(&o.FOPT.Reg) & 0x1
}
func (o *FTFE_FlashConfig_Type) SetFOPT_EZPORT_DIS(value uint8) {
	volatile.StoreUint8(&o.FOPT.Reg, volatile.LoadUint8(&o.FOPT.Reg)&^(0x2)|value<<1)
}
func (o *FTFE_FlashConfig_Type) GetFOPT_EZPORT_DIS() uint8 {
	return (volatile.LoadUint8(&o.FOPT.Reg) & 0x2) >> 1
}

// FTFE_FlashConfig.FEPROT: Non-volatile EERAM Protection Register
func (o *FTFE_FlashConfig_Type) SetFEPROT(value uint8) {
	volatile.StoreUint8(&o.FEPROT.Reg, value)
}
func (o *FTFE_FlashConfig_Type) GetFEPROT() uint8 {
	return volatile.LoadUint8(&o.FEPROT.Reg)
}

// FTFE_FlashConfig.FDPROT: Non-volatile D-Flash Protection Register
func (o *FTFE_FlashConfig_Type) SetFDPROT(value uint8) {
	volatile.StoreUint8(&o.FDPROT.Reg, value)
}
func (o *FTFE_FlashConfig_Type) GetFDPROT() uint8 {
	return volatile.LoadUint8(&o.FDPROT.Reg)
}

// AIPS-Lite Bridge
type AIPS_Type struct {
	MPRA  volatile.Register32 // 0x0
	_     [28]byte
	PACRA volatile.Register32 // 0x20
	PACRB volatile.Register32 // 0x24
	PACRC volatile.Register32 // 0x28
	PACRD volatile.Register32 // 0x2C
	_     [16]byte
	PACRE volatile.Register32 // 0x40
	PACRF volatile.Register32 // 0x44
	PACRG volatile.Register32 // 0x48
	PACRH volatile.Register32 // 0x4C
	PACRI volatile.Register32 // 0x50
	PACRJ volatile.Register32 // 0x54
	PACRK volatile.Register32 // 0x58
	PACRL volatile.Register32 // 0x5C
	PACRM volatile.Register32 // 0x60
	PACRN volatile.Register32 // 0x64
	PACRO volatile.Register32 // 0x68
	PACRP volatile.Register32 // 0x6C
	_     [16]byte
	PACRU volatile.Register32 // 0x80
}

// AIPS.MPRA: Master Privilege Register A
func (o *AIPS_Type) SetMPRA_MPL5(value uint32) {
	volatile.StoreUint32(&o.MPRA.Reg, volatile.LoadUint32(&o.MPRA.Reg)&^(0x100)|value<<8)
}
func (o *AIPS_Type) GetMPRA_MPL5() uint32 {
	return (volatile.LoadUint32(&o.MPRA.Reg) & 0x100) >> 8
}
func (o *AIPS_Type) SetMPRA_MTW5(value uint32) {
	volatile.StoreUint32(&o.MPRA.Reg, volatile.LoadUint32(&o.MPRA.Reg)&^(0x200)|value<<9)
}
func (o *AIPS_Type) GetMPRA_MTW5() uint32 {
	return (volatile.LoadUint32(&o.MPRA.Reg) & 0x200) >> 9
}
func (o *AIPS_Type) SetMPRA_MTR5(value uint32) {
	volatile.StoreUint32(&o.MPRA.Reg, volatile.LoadUint32(&o.MPRA.Reg)&^(0x400)|value<<10)
}
func (o *AIPS_Type) GetMPRA_MTR5() uint32 {
	return (volatile.LoadUint32(&o.MPRA.Reg) & 0x400) >> 10
}
func (o *AIPS_Type) SetMPRA_MPL4(value uint32) {
	volatile.StoreUint32(&o.MPRA.Reg, volatile.LoadUint32(&o.MPRA.Reg)&^(0x1000)|value<<12)
}
func (o *AIPS_Type) GetMPRA_MPL4() uint32 {
	return (volatile.LoadUint32(&o.MPRA.Reg) & 0x1000) >> 12
}
func (o *AIPS_Type) SetMPRA_MTW4(value uint32) {
	volatile.StoreUint32(&o.MPRA.Reg, volatile.LoadUint32(&o.MPRA.Reg)&^(0x2000)|value<<13)
}
func (o *AIPS_Type) GetMPRA_MTW4() uint32 {
	return (volatile.LoadUint32(&o.MPRA.Reg) & 0x2000) >> 13
}
func (o *AIPS_Type) SetMPRA_MTR4(value uint32) {
	volatile.StoreUint32(&o.MPRA.Reg, volatile.LoadUint32(&o.MPRA.Reg)&^(0x4000)|value<<14)
}
func (o *AIPS_Type) GetMPRA_MTR4() uint32 {
	return (volatile.LoadUint32(&o.MPRA.Reg) & 0x4000) >> 14
}
func (o *AIPS_Type) SetMPRA_MPL3(value uint32) {
	volatile.StoreUint32(&o.MPRA.Reg, volatile.LoadUint32(&o.MPRA.Reg)&^(0x10000)|value<<16)
}
func (o *AIPS_Type) GetMPRA_MPL3() uint32 {
	return (volatile.LoadUint32(&o.MPRA.Reg) & 0x10000) >> 16
}
func (o *AIPS_Type) SetMPRA_MTW3(value uint32) {
	volatile.StoreUint32(&o.MPRA.Reg, volatile.LoadUint32(&o.MPRA.Reg)&^(0x20000)|value<<17)
}
func (o *AIPS_Type) GetMPRA_MTW3() uint32 {
	return (volatile.LoadUint32(&o.MPRA.Reg) & 0x20000) >> 17
}
func (o *AIPS_Type) SetMPRA_MTR3(value uint32) {
	volatile.StoreUint32(&o.MPRA.Reg, volatile.LoadUint32(&o.MPRA.Reg)&^(0x40000)|value<<18)
}
func (o *AIPS_Type) GetMPRA_MTR3() uint32 {
	return (volatile.LoadUint32(&o.MPRA.Reg) & 0x40000) >> 18
}
func (o *AIPS_Type) SetMPRA_MPL2(value uint32) {
	volatile.StoreUint32(&o.MPRA.Reg, volatile.LoadUint32(&o.MPRA.Reg)&^(0x100000)|value<<20)
}
func (o *AIPS_Type) GetMPRA_MPL2() uint32 {
	return (volatile.LoadUint32(&o.MPRA.Reg) & 0x100000) >> 20
}
func (o *AIPS_Type) SetMPRA_MTW2(value uint32) {
	volatile.StoreUint32(&o.MPRA.Reg, volatile.LoadUint32(&o.MPRA.Reg)&^(0x200000)|value<<21)
}
func (o *AIPS_Type) GetMPRA_MTW2() uint32 {
	return (volatile.LoadUint32(&o.MPRA.Reg) & 0x200000) >> 21
}
func (o *AIPS_Type) SetMPRA_MTR2(value uint32) {
	volatile.StoreUint32(&o.MPRA.Reg, volatile.LoadUint32(&o.MPRA.Reg)&^(0x400000)|value<<22)
}
func (o *AIPS_Type) GetMPRA_MTR2() uint32 {
	return (volatile.LoadUint32(&o.MPRA.Reg) & 0x400000) >> 22
}
func (o *AIPS_Type) SetMPRA_MPL1(value uint32) {
	volatile.StoreUint32(&o.MPRA.Reg, volatile.LoadUint32(&o.MPRA.Reg)&^(0x1000000)|value<<24)
}
func (o *AIPS_Type) GetMPRA_MPL1() uint32 {
	return (volatile.LoadUint32(&o.MPRA.Reg) & 0x1000000) >> 24
}
func (o *AIPS_Type) SetMPRA_MTW1(value uint32) {
	volatile.StoreUint32(&o.MPRA.Reg, volatile.LoadUint32(&o.MPRA.Reg)&^(0x2000000)|value<<25)
}
func (o *AIPS_Type) GetMPRA_MTW1() uint32 {
	return (volatile.LoadUint32(&o.MPRA.Reg) & 0x2000000) >> 25
}
func (o *AIPS_Type) SetMPRA_MTR1(value uint32) {
	volatile.StoreUint32(&o.MPRA.Reg, volatile.LoadUint32(&o.MPRA.Reg)&^(0x4000000)|value<<26)
}
func (o *AIPS_Type) GetMPRA_MTR1() uint32 {
	return (volatile.LoadUint32(&o.MPRA.Reg) & 0x4000000) >> 26
}
func (o *AIPS_Type) SetMPRA_MPL0(value uint32) {
	volatile.StoreUint32(&o.MPRA.Reg, volatile.LoadUint32(&o.MPRA.Reg)&^(0x10000000)|value<<28)
}
func (o *AIPS_Type) GetMPRA_MPL0() uint32 {
	return (volatile.LoadUint32(&o.MPRA.Reg) & 0x10000000) >> 28
}
func (o *AIPS_Type) SetMPRA_MTW0(value uint32) {
	volatile.StoreUint32(&o.MPRA.Reg, volatile.LoadUint32(&o.MPRA.Reg)&^(0x20000000)|value<<29)
}
func (o *AIPS_Type) GetMPRA_MTW0() uint32 {
	return (volatile.LoadUint32(&o.MPRA.Reg) & 0x20000000) >> 29
}
func (o *AIPS_Type) SetMPRA_MTR0(value uint32) {
	volatile.StoreUint32(&o.MPRA.Reg, volatile.LoadUint32(&o.MPRA.Reg)&^(0x40000000)|value<<30)
}
func (o *AIPS_Type) GetMPRA_MTR0() uint32 {
	return (volatile.LoadUint32(&o.MPRA.Reg) & 0x40000000) >> 30
}

// AIPS.PACRA: Peripheral Access Control Register
func (o *AIPS_Type) SetPACRA_TP7(value uint32) {
	volatile.StoreUint32(&o.PACRA.Reg, volatile.LoadUint32(&o.PACRA.Reg)&^(0x1)|value)
}
func (o *AIPS_Type) GetPACRA_TP7() uint32 {
	return volatile.LoadUint32(&o.PACRA.Reg) & 0x1
}
func (o *AIPS_Type) SetPACRA_WP7(value uint32) {
	volatile.StoreUint32(&o.PACRA.Reg, volatile.LoadUint32(&o.PACRA.Reg)&^(0x2)|value<<1)
}
func (o *AIPS_Type) GetPACRA_WP7() uint32 {
	return (volatile.LoadUint32(&o.PACRA.Reg) & 0x2) >> 1
}
func (o *AIPS_Type) SetPACRA_SP7(value uint32) {
	volatile.StoreUint32(&o.PACRA.Reg, volatile.LoadUint32(&o.PACRA.Reg)&^(0x4)|value<<2)
}
func (o *AIPS_Type) GetPACRA_SP7() uint32 {
	return (volatile.LoadUint32(&o.PACRA.Reg) & 0x4) >> 2
}
func (o *AIPS_Type) SetPACRA_TP6(value uint32) {
	volatile.StoreUint32(&o.PACRA.Reg, volatile.LoadUint32(&o.PACRA.Reg)&^(0x10)|value<<4)
}
func (o *AIPS_Type) GetPACRA_TP6() uint32 {
	return (volatile.LoadUint32(&o.PACRA.Reg) & 0x10) >> 4
}
func (o *AIPS_Type) SetPACRA_WP6(value uint32) {
	volatile.StoreUint32(&o.PACRA.Reg, volatile.LoadUint32(&o.PACRA.Reg)&^(0x20)|value<<5)
}
func (o *AIPS_Type) GetPACRA_WP6() uint32 {
	return (volatile.LoadUint32(&o.PACRA.Reg) & 0x20) >> 5
}
func (o *AIPS_Type) SetPACRA_SP6(value uint32) {
	volatile.StoreUint32(&o.PACRA.Reg, volatile.LoadUint32(&o.PACRA.Reg)&^(0x40)|value<<6)
}
func (o *AIPS_Type) GetPACRA_SP6() uint32 {
	return (volatile.LoadUint32(&o.PACRA.Reg) & 0x40) >> 6
}
func (o *AIPS_Type) SetPACRA_TP5(value uint32) {
	volatile.StoreUint32(&o.PACRA.Reg, volatile.LoadUint32(&o.PACRA.Reg)&^(0x100)|value<<8)
}
func (o *AIPS_Type) GetPACRA_TP5() uint32 {
	return (volatile.LoadUint32(&o.PACRA.Reg) & 0x100) >> 8
}
func (o *AIPS_Type) SetPACRA_WP5(value uint32) {
	volatile.StoreUint32(&o.PACRA.Reg, volatile.LoadUint32(&o.PACRA.Reg)&^(0x200)|value<<9)
}
func (o *AIPS_Type) GetPACRA_WP5() uint32 {
	return (volatile.LoadUint32(&o.PACRA.Reg) & 0x200) >> 9
}
func (o *AIPS_Type) SetPACRA_SP5(value uint32) {
	volatile.StoreUint32(&o.PACRA.Reg, volatile.LoadUint32(&o.PACRA.Reg)&^(0x400)|value<<10)
}
func (o *AIPS_Type) GetPACRA_SP5() uint32 {
	return (volatile.LoadUint32(&o.PACRA.Reg) & 0x400) >> 10
}
func (o *AIPS_Type) SetPACRA_TP4(value uint32) {
	volatile.StoreUint32(&o.PACRA.Reg, volatile.LoadUint32(&o.PACRA.Reg)&^(0x1000)|value<<12)
}
func (o *AIPS_Type) GetPACRA_TP4() uint32 {
	return (volatile.LoadUint32(&o.PACRA.Reg) & 0x1000) >> 12
}
func (o *AIPS_Type) SetPACRA_WP4(value uint32) {
	volatile.StoreUint32(&o.PACRA.Reg, volatile.LoadUint32(&o.PACRA.Reg)&^(0x2000)|value<<13)
}
func (o *AIPS_Type) GetPACRA_WP4() uint32 {
	return (volatile.LoadUint32(&o.PACRA.Reg) & 0x2000) >> 13
}
func (o *AIPS_Type) SetPACRA_SP4(value uint32) {
	volatile.StoreUint32(&o.PACRA.Reg, volatile.LoadUint32(&o.PACRA.Reg)&^(0x4000)|value<<14)
}
func (o *AIPS_Type) GetPACRA_SP4() uint32 {
	return (volatile.LoadUint32(&o.PACRA.Reg) & 0x4000) >> 14
}
func (o *AIPS_Type) SetPACRA_TP3(value uint32) {
	volatile.StoreUint32(&o.PACRA.Reg, volatile.LoadUint32(&o.PACRA.Reg)&^(0x10000)|value<<16)
}
func (o *AIPS_Type) GetPACRA_TP3() uint32 {
	return (volatile.LoadUint32(&o.PACRA.Reg) & 0x10000) >> 16
}
func (o *AIPS_Type) SetPACRA_WP3(value uint32) {
	volatile.StoreUint32(&o.PACRA.Reg, volatile.LoadUint32(&o.PACRA.Reg)&^(0x20000)|value<<17)
}
func (o *AIPS_Type) GetPACRA_WP3() uint32 {
	return (volatile.LoadUint32(&o.PACRA.Reg) & 0x20000) >> 17
}
func (o *AIPS_Type) SetPACRA_SP3(value uint32) {
	volatile.StoreUint32(&o.PACRA.Reg, volatile.LoadUint32(&o.PACRA.Reg)&^(0x40000)|value<<18)
}
func (o *AIPS_Type) GetPACRA_SP3() uint32 {
	return (volatile.LoadUint32(&o.PACRA.Reg) & 0x40000) >> 18
}
func (o *AIPS_Type) SetPACRA_TP2(value uint32) {
	volatile.StoreUint32(&o.PACRA.Reg, volatile.LoadUint32(&o.PACRA.Reg)&^(0x100000)|value<<20)
}
func (o *AIPS_Type) GetPACRA_TP2() uint32 {
	return (volatile.LoadUint32(&o.PACRA.Reg) & 0x100000) >> 20
}
func (o *AIPS_Type) SetPACRA_WP2(value uint32) {
	volatile.StoreUint32(&o.PACRA.Reg, volatile.LoadUint32(&o.PACRA.Reg)&^(0x200000)|value<<21)
}
func (o *AIPS_Type) GetPACRA_WP2() uint32 {
	return (volatile.LoadUint32(&o.PACRA.Reg) & 0x200000) >> 21
}
func (o *AIPS_Type) SetPACRA_SP2(value uint32) {
	volatile.StoreUint32(&o.PACRA.Reg, volatile.LoadUint32(&o.PACRA.Reg)&^(0x400000)|value<<22)
}
func (o *AIPS_Type) GetPACRA_SP2() uint32 {
	return (volatile.LoadUint32(&o.PACRA.Reg) & 0x400000) >> 22
}
func (o *AIPS_Type) SetPACRA_TP1(value uint32) {
	volatile.StoreUint32(&o.PACRA.Reg, volatile.LoadUint32(&o.PACRA.Reg)&^(0x1000000)|value<<24)
}
func (o *AIPS_Type) GetPACRA_TP1() uint32 {
	return (volatile.LoadUint32(&o.PACRA.Reg) & 0x1000000) >> 24
}
func (o *AIPS_Type) SetPACRA_WP1(value uint32) {
	volatile.StoreUint32(&o.PACRA.Reg, volatile.LoadUint32(&o.PACRA.Reg)&^(0x2000000)|value<<25)
}
func (o *AIPS_Type) GetPACRA_WP1() uint32 {
	return (volatile.LoadUint32(&o.PACRA.Reg) & 0x2000000) >> 25
}
func (o *AIPS_Type) SetPACRA_SP1(value uint32) {
	volatile.StoreUint32(&o.PACRA.Reg, volatile.LoadUint32(&o.PACRA.Reg)&^(0x4000000)|value<<26)
}
func (o *AIPS_Type) GetPACRA_SP1() uint32 {
	return (volatile.LoadUint32(&o.PACRA.Reg) & 0x4000000) >> 26
}
func (o *AIPS_Type) SetPACRA_TP0(value uint32) {
	volatile.StoreUint32(&o.PACRA.Reg, volatile.LoadUint32(&o.PACRA.Reg)&^(0x10000000)|value<<28)
}
func (o *AIPS_Type) GetPACRA_TP0() uint32 {
	return (volatile.LoadUint32(&o.PACRA.Reg) & 0x10000000) >> 28
}
func (o *AIPS_Type) SetPACRA_WP0(value uint32) {
	volatile.StoreUint32(&o.PACRA.Reg, volatile.LoadUint32(&o.PACRA.Reg)&^(0x20000000)|value<<29)
}
func (o *AIPS_Type) GetPACRA_WP0() uint32 {
	return (volatile.LoadUint32(&o.PACRA.Reg) & 0x20000000) >> 29
}
func (o *AIPS_Type) SetPACRA_SP0(value uint32) {
	volatile.StoreUint32(&o.PACRA.Reg, volatile.LoadUint32(&o.PACRA.Reg)&^(0x40000000)|value<<30)
}
func (o *AIPS_Type) GetPACRA_SP0() uint32 {
	return (volatile.LoadUint32(&o.PACRA.Reg) & 0x40000000) >> 30
}

// AIPS.PACRB: Peripheral Access Control Register
func (o *AIPS_Type) SetPACRB_TP7(value uint32) {
	volatile.StoreUint32(&o.PACRB.Reg, volatile.LoadUint32(&o.PACRB.Reg)&^(0x1)|value)
}
func (o *AIPS_Type) GetPACRB_TP7() uint32 {
	return volatile.LoadUint32(&o.PACRB.Reg) & 0x1
}
func (o *AIPS_Type) SetPACRB_WP7(value uint32) {
	volatile.StoreUint32(&o.PACRB.Reg, volatile.LoadUint32(&o.PACRB.Reg)&^(0x2)|value<<1)
}
func (o *AIPS_Type) GetPACRB_WP7() uint32 {
	return (volatile.LoadUint32(&o.PACRB.Reg) & 0x2) >> 1
}
func (o *AIPS_Type) SetPACRB_SP7(value uint32) {
	volatile.StoreUint32(&o.PACRB.Reg, volatile.LoadUint32(&o.PACRB.Reg)&^(0x4)|value<<2)
}
func (o *AIPS_Type) GetPACRB_SP7() uint32 {
	return (volatile.LoadUint32(&o.PACRB.Reg) & 0x4) >> 2
}
func (o *AIPS_Type) SetPACRB_TP6(value uint32) {
	volatile.StoreUint32(&o.PACRB.Reg, volatile.LoadUint32(&o.PACRB.Reg)&^(0x10)|value<<4)
}
func (o *AIPS_Type) GetPACRB_TP6() uint32 {
	return (volatile.LoadUint32(&o.PACRB.Reg) & 0x10) >> 4
}
func (o *AIPS_Type) SetPACRB_WP6(value uint32) {
	volatile.StoreUint32(&o.PACRB.Reg, volatile.LoadUint32(&o.PACRB.Reg)&^(0x20)|value<<5)
}
func (o *AIPS_Type) GetPACRB_WP6() uint32 {
	return (volatile.LoadUint32(&o.PACRB.Reg) & 0x20) >> 5
}
func (o *AIPS_Type) SetPACRB_SP6(value uint32) {
	volatile.StoreUint32(&o.PACRB.Reg, volatile.LoadUint32(&o.PACRB.Reg)&^(0x40)|value<<6)
}
func (o *AIPS_Type) GetPACRB_SP6() uint32 {
	return (volatile.LoadUint32(&o.PACRB.Reg) & 0x40) >> 6
}
func (o *AIPS_Type) SetPACRB_TP5(value uint32) {
	volatile.StoreUint32(&o.PACRB.Reg, volatile.LoadUint32(&o.PACRB.Reg)&^(0x100)|value<<8)
}
func (o *AIPS_Type) GetPACRB_TP5() uint32 {
	return (volatile.LoadUint32(&o.PACRB.Reg) & 0x100) >> 8
}
func (o *AIPS_Type) SetPACRB_WP5(value uint32) {
	volatile.StoreUint32(&o.PACRB.Reg, volatile.LoadUint32(&o.PACRB.Reg)&^(0x200)|value<<9)
}
func (o *AIPS_Type) GetPACRB_WP5() uint32 {
	return (volatile.LoadUint32(&o.PACRB.Reg) & 0x200) >> 9
}
func (o *AIPS_Type) SetPACRB_SP5(value uint32) {
	volatile.StoreUint32(&o.PACRB.Reg, volatile.LoadUint32(&o.PACRB.Reg)&^(0x400)|value<<10)
}
func (o *AIPS_Type) GetPACRB_SP5() uint32 {
	return (volatile.LoadUint32(&o.PACRB.Reg) & 0x400) >> 10
}
func (o *AIPS_Type) SetPACRB_TP4(value uint32) {
	volatile.StoreUint32(&o.PACRB.Reg, volatile.LoadUint32(&o.PACRB.Reg)&^(0x1000)|value<<12)
}
func (o *AIPS_Type) GetPACRB_TP4() uint32 {
	return (volatile.LoadUint32(&o.PACRB.Reg) & 0x1000) >> 12
}
func (o *AIPS_Type) SetPACRB_WP4(value uint32) {
	volatile.StoreUint32(&o.PACRB.Reg, volatile.LoadUint32(&o.PACRB.Reg)&^(0x2000)|value<<13)
}
func (o *AIPS_Type) GetPACRB_WP4() uint32 {
	return (volatile.LoadUint32(&o.PACRB.Reg) & 0x2000) >> 13
}
func (o *AIPS_Type) SetPACRB_SP4(value uint32) {
	volatile.StoreUint32(&o.PACRB.Reg, volatile.LoadUint32(&o.PACRB.Reg)&^(0x4000)|value<<14)
}
func (o *AIPS_Type) GetPACRB_SP4() uint32 {
	return (volatile.LoadUint32(&o.PACRB.Reg) & 0x4000) >> 14
}
func (o *AIPS_Type) SetPACRB_TP3(value uint32) {
	volatile.StoreUint32(&o.PACRB.Reg, volatile.LoadUint32(&o.PACRB.Reg)&^(0x10000)|value<<16)
}
func (o *AIPS_Type) GetPACRB_TP3() uint32 {
	return (volatile.LoadUint32(&o.PACRB.Reg) & 0x10000) >> 16
}
func (o *AIPS_Type) SetPACRB_WP3(value uint32) {
	volatile.StoreUint32(&o.PACRB.Reg, volatile.LoadUint32(&o.PACRB.Reg)&^(0x20000)|value<<17)
}
func (o *AIPS_Type) GetPACRB_WP3() uint32 {
	return (volatile.LoadUint32(&o.PACRB.Reg) & 0x20000) >> 17
}
func (o *AIPS_Type) SetPACRB_SP3(value uint32) {
	volatile.StoreUint32(&o.PACRB.Reg, volatile.LoadUint32(&o.PACRB.Reg)&^(0x40000)|value<<18)
}
func (o *AIPS_Type) GetPACRB_SP3() uint32 {
	return (volatile.LoadUint32(&o.PACRB.Reg) & 0x40000) >> 18
}
func (o *AIPS_Type) SetPACRB_TP2(value uint32) {
	volatile.StoreUint32(&o.PACRB.Reg, volatile.LoadUint32(&o.PACRB.Reg)&^(0x100000)|value<<20)
}
func (o *AIPS_Type) GetPACRB_TP2() uint32 {
	return (volatile.LoadUint32(&o.PACRB.Reg) & 0x100000) >> 20
}
func (o *AIPS_Type) SetPACRB_WP2(value uint32) {
	volatile.StoreUint32(&o.PACRB.Reg, volatile.LoadUint32(&o.PACRB.Reg)&^(0x200000)|value<<21)
}
func (o *AIPS_Type) GetPACRB_WP2() uint32 {
	return (volatile.LoadUint32(&o.PACRB.Reg) & 0x200000) >> 21
}
func (o *AIPS_Type) SetPACRB_SP2(value uint32) {
	volatile.StoreUint32(&o.PACRB.Reg, volatile.LoadUint32(&o.PACRB.Reg)&^(0x400000)|value<<22)
}
func (o *AIPS_Type) GetPACRB_SP2() uint32 {
	return (volatile.LoadUint32(&o.PACRB.Reg) & 0x400000) >> 22
}
func (o *AIPS_Type) SetPACRB_TP1(value uint32) {
	volatile.StoreUint32(&o.PACRB.Reg, volatile.LoadUint32(&o.PACRB.Reg)&^(0x1000000)|value<<24)
}
func (o *AIPS_Type) GetPACRB_TP1() uint32 {
	return (volatile.LoadUint32(&o.PACRB.Reg) & 0x1000000) >> 24
}
func (o *AIPS_Type) SetPACRB_WP1(value uint32) {
	volatile.StoreUint32(&o.PACRB.Reg, volatile.LoadUint32(&o.PACRB.Reg)&^(0x2000000)|value<<25)
}
func (o *AIPS_Type) GetPACRB_WP1() uint32 {
	return (volatile.LoadUint32(&o.PACRB.Reg) & 0x2000000) >> 25
}
func (o *AIPS_Type) SetPACRB_SP1(value uint32) {
	volatile.StoreUint32(&o.PACRB.Reg, volatile.LoadUint32(&o.PACRB.Reg)&^(0x4000000)|value<<26)
}
func (o *AIPS_Type) GetPACRB_SP1() uint32 {
	return (volatile.LoadUint32(&o.PACRB.Reg) & 0x4000000) >> 26
}
func (o *AIPS_Type) SetPACRB_TP0(value uint32) {
	volatile.StoreUint32(&o.PACRB.Reg, volatile.LoadUint32(&o.PACRB.Reg)&^(0x10000000)|value<<28)
}
func (o *AIPS_Type) GetPACRB_TP0() uint32 {
	return (volatile.LoadUint32(&o.PACRB.Reg) & 0x10000000) >> 28
}
func (o *AIPS_Type) SetPACRB_WP0(value uint32) {
	volatile.StoreUint32(&o.PACRB.Reg, volatile.LoadUint32(&o.PACRB.Reg)&^(0x20000000)|value<<29)
}
func (o *AIPS_Type) GetPACRB_WP0() uint32 {
	return (volatile.LoadUint32(&o.PACRB.Reg) & 0x20000000) >> 29
}
func (o *AIPS_Type) SetPACRB_SP0(value uint32) {
	volatile.StoreUint32(&o.PACRB.Reg, volatile.LoadUint32(&o.PACRB.Reg)&^(0x40000000)|value<<30)
}
func (o *AIPS_Type) GetPACRB_SP0() uint32 {
	return (volatile.LoadUint32(&o.PACRB.Reg) & 0x40000000) >> 30
}

// AIPS.PACRC: Peripheral Access Control Register
func (o *AIPS_Type) SetPACRC_TP7(value uint32) {
	volatile.StoreUint32(&o.PACRC.Reg, volatile.LoadUint32(&o.PACRC.Reg)&^(0x1)|value)
}
func (o *AIPS_Type) GetPACRC_TP7() uint32 {
	return volatile.LoadUint32(&o.PACRC.Reg) & 0x1
}
func (o *AIPS_Type) SetPACRC_WP7(value uint32) {
	volatile.StoreUint32(&o.PACRC.Reg, volatile.LoadUint32(&o.PACRC.Reg)&^(0x2)|value<<1)
}
func (o *AIPS_Type) GetPACRC_WP7() uint32 {
	return (volatile.LoadUint32(&o.PACRC.Reg) & 0x2) >> 1
}
func (o *AIPS_Type) SetPACRC_SP7(value uint32) {
	volatile.StoreUint32(&o.PACRC.Reg, volatile.LoadUint32(&o.PACRC.Reg)&^(0x4)|value<<2)
}
func (o *AIPS_Type) GetPACRC_SP7() uint32 {
	return (volatile.LoadUint32(&o.PACRC.Reg) & 0x4) >> 2
}
func (o *AIPS_Type) SetPACRC_TP6(value uint32) {
	volatile.StoreUint32(&o.PACRC.Reg, volatile.LoadUint32(&o.PACRC.Reg)&^(0x10)|value<<4)
}
func (o *AIPS_Type) GetPACRC_TP6() uint32 {
	return (volatile.LoadUint32(&o.PACRC.Reg) & 0x10) >> 4
}
func (o *AIPS_Type) SetPACRC_WP6(value uint32) {
	volatile.StoreUint32(&o.PACRC.Reg, volatile.LoadUint32(&o.PACRC.Reg)&^(0x20)|value<<5)
}
func (o *AIPS_Type) GetPACRC_WP6() uint32 {
	return (volatile.LoadUint32(&o.PACRC.Reg) & 0x20) >> 5
}
func (o *AIPS_Type) SetPACRC_SP6(value uint32) {
	volatile.StoreUint32(&o.PACRC.Reg, volatile.LoadUint32(&o.PACRC.Reg)&^(0x40)|value<<6)
}
func (o *AIPS_Type) GetPACRC_SP6() uint32 {
	return (volatile.LoadUint32(&o.PACRC.Reg) & 0x40) >> 6
}
func (o *AIPS_Type) SetPACRC_TP5(value uint32) {
	volatile.StoreUint32(&o.PACRC.Reg, volatile.LoadUint32(&o.PACRC.Reg)&^(0x100)|value<<8)
}
func (o *AIPS_Type) GetPACRC_TP5() uint32 {
	return (volatile.LoadUint32(&o.PACRC.Reg) & 0x100) >> 8
}
func (o *AIPS_Type) SetPACRC_WP5(value uint32) {
	volatile.StoreUint32(&o.PACRC.Reg, volatile.LoadUint32(&o.PACRC.Reg)&^(0x200)|value<<9)
}
func (o *AIPS_Type) GetPACRC_WP5() uint32 {
	return (volatile.LoadUint32(&o.PACRC.Reg) & 0x200) >> 9
}
func (o *AIPS_Type) SetPACRC_SP5(value uint32) {
	volatile.StoreUint32(&o.PACRC.Reg, volatile.LoadUint32(&o.PACRC.Reg)&^(0x400)|value<<10)
}
func (o *AIPS_Type) GetPACRC_SP5() uint32 {
	return (volatile.LoadUint32(&o.PACRC.Reg) & 0x400) >> 10
}
func (o *AIPS_Type) SetPACRC_TP4(value uint32) {
	volatile.StoreUint32(&o.PACRC.Reg, volatile.LoadUint32(&o.PACRC.Reg)&^(0x1000)|value<<12)
}
func (o *AIPS_Type) GetPACRC_TP4() uint32 {
	return (volatile.LoadUint32(&o.PACRC.Reg) & 0x1000) >> 12
}
func (o *AIPS_Type) SetPACRC_WP4(value uint32) {
	volatile.StoreUint32(&o.PACRC.Reg, volatile.LoadUint32(&o.PACRC.Reg)&^(0x2000)|value<<13)
}
func (o *AIPS_Type) GetPACRC_WP4() uint32 {
	return (volatile.LoadUint32(&o.PACRC.Reg) & 0x2000) >> 13
}
func (o *AIPS_Type) SetPACRC_SP4(value uint32) {
	volatile.StoreUint32(&o.PACRC.Reg, volatile.LoadUint32(&o.PACRC.Reg)&^(0x4000)|value<<14)
}
func (o *AIPS_Type) GetPACRC_SP4() uint32 {
	return (volatile.LoadUint32(&o.PACRC.Reg) & 0x4000) >> 14
}
func (o *AIPS_Type) SetPACRC_TP3(value uint32) {
	volatile.StoreUint32(&o.PACRC.Reg, volatile.LoadUint32(&o.PACRC.Reg)&^(0x10000)|value<<16)
}
func (o *AIPS_Type) GetPACRC_TP3() uint32 {
	return (volatile.LoadUint32(&o.PACRC.Reg) & 0x10000) >> 16
}
func (o *AIPS_Type) SetPACRC_WP3(value uint32) {
	volatile.StoreUint32(&o.PACRC.Reg, volatile.LoadUint32(&o.PACRC.Reg)&^(0x20000)|value<<17)
}
func (o *AIPS_Type) GetPACRC_WP3() uint32 {
	return (volatile.LoadUint32(&o.PACRC.Reg) & 0x20000) >> 17
}
func (o *AIPS_Type) SetPACRC_SP3(value uint32) {
	volatile.StoreUint32(&o.PACRC.Reg, volatile.LoadUint32(&o.PACRC.Reg)&^(0x40000)|value<<18)
}
func (o *AIPS_Type) GetPACRC_SP3() uint32 {
	return (volatile.LoadUint32(&o.PACRC.Reg) & 0x40000) >> 18
}
func (o *AIPS_Type) SetPACRC_TP2(value uint32) {
	volatile.StoreUint32(&o.PACRC.Reg, volatile.LoadUint32(&o.PACRC.Reg)&^(0x100000)|value<<20)
}
func (o *AIPS_Type) GetPACRC_TP2() uint32 {
	return (volatile.LoadUint32(&o.PACRC.Reg) & 0x100000) >> 20
}
func (o *AIPS_Type) SetPACRC_WP2(value uint32) {
	volatile.StoreUint32(&o.PACRC.Reg, volatile.LoadUint32(&o.PACRC.Reg)&^(0x200000)|value<<21)
}
func (o *AIPS_Type) GetPACRC_WP2() uint32 {
	return (volatile.LoadUint32(&o.PACRC.Reg) & 0x200000) >> 21
}
func (o *AIPS_Type) SetPACRC_SP2(value uint32) {
	volatile.StoreUint32(&o.PACRC.Reg, volatile.LoadUint32(&o.PACRC.Reg)&^(0x400000)|value<<22)
}
func (o *AIPS_Type) GetPACRC_SP2() uint32 {
	return (volatile.LoadUint32(&o.PACRC.Reg) & 0x400000) >> 22
}
func (o *AIPS_Type) SetPACRC_TP1(value uint32) {
	volatile.StoreUint32(&o.PACRC.Reg, volatile.LoadUint32(&o.PACRC.Reg)&^(0x1000000)|value<<24)
}
func (o *AIPS_Type) GetPACRC_TP1() uint32 {
	return (volatile.LoadUint32(&o.PACRC.Reg) & 0x1000000) >> 24
}
func (o *AIPS_Type) SetPACRC_WP1(value uint32) {
	volatile.StoreUint32(&o.PACRC.Reg, volatile.LoadUint32(&o.PACRC.Reg)&^(0x2000000)|value<<25)
}
func (o *AIPS_Type) GetPACRC_WP1() uint32 {
	return (volatile.LoadUint32(&o.PACRC.Reg) & 0x2000000) >> 25
}
func (o *AIPS_Type) SetPACRC_SP1(value uint32) {
	volatile.StoreUint32(&o.PACRC.Reg, volatile.LoadUint32(&o.PACRC.Reg)&^(0x4000000)|value<<26)
}
func (o *AIPS_Type) GetPACRC_SP1() uint32 {
	return (volatile.LoadUint32(&o.PACRC.Reg) & 0x4000000) >> 26
}
func (o *AIPS_Type) SetPACRC_TP0(value uint32) {
	volatile.StoreUint32(&o.PACRC.Reg, volatile.LoadUint32(&o.PACRC.Reg)&^(0x10000000)|value<<28)
}
func (o *AIPS_Type) GetPACRC_TP0() uint32 {
	return (volatile.LoadUint32(&o.PACRC.Reg) & 0x10000000) >> 28
}
func (o *AIPS_Type) SetPACRC_WP0(value uint32) {
	volatile.StoreUint32(&o.PACRC.Reg, volatile.LoadUint32(&o.PACRC.Reg)&^(0x20000000)|value<<29)
}
func (o *AIPS_Type) GetPACRC_WP0() uint32 {
	return (volatile.LoadUint32(&o.PACRC.Reg) & 0x20000000) >> 29
}
func (o *AIPS_Type) SetPACRC_SP0(value uint32) {
	volatile.StoreUint32(&o.PACRC.Reg, volatile.LoadUint32(&o.PACRC.Reg)&^(0x40000000)|value<<30)
}
func (o *AIPS_Type) GetPACRC_SP0() uint32 {
	return (volatile.LoadUint32(&o.PACRC.Reg) & 0x40000000) >> 30
}

// AIPS.PACRD: Peripheral Access Control Register
func (o *AIPS_Type) SetPACRD_TP7(value uint32) {
	volatile.StoreUint32(&o.PACRD.Reg, volatile.LoadUint32(&o.PACRD.Reg)&^(0x1)|value)
}
func (o *AIPS_Type) GetPACRD_TP7() uint32 {
	return volatile.LoadUint32(&o.PACRD.Reg) & 0x1
}
func (o *AIPS_Type) SetPACRD_WP7(value uint32) {
	volatile.StoreUint32(&o.PACRD.Reg, volatile.LoadUint32(&o.PACRD.Reg)&^(0x2)|value<<1)
}
func (o *AIPS_Type) GetPACRD_WP7() uint32 {
	return (volatile.LoadUint32(&o.PACRD.Reg) & 0x2) >> 1
}
func (o *AIPS_Type) SetPACRD_SP7(value uint32) {
	volatile.StoreUint32(&o.PACRD.Reg, volatile.LoadUint32(&o.PACRD.Reg)&^(0x4)|value<<2)
}
func (o *AIPS_Type) GetPACRD_SP7() uint32 {
	return (volatile.LoadUint32(&o.PACRD.Reg) & 0x4) >> 2
}
func (o *AIPS_Type) SetPACRD_TP6(value uint32) {
	volatile.StoreUint32(&o.PACRD.Reg, volatile.LoadUint32(&o.PACRD.Reg)&^(0x10)|value<<4)
}
func (o *AIPS_Type) GetPACRD_TP6() uint32 {
	return (volatile.LoadUint32(&o.PACRD.Reg) & 0x10) >> 4
}
func (o *AIPS_Type) SetPACRD_WP6(value uint32) {
	volatile.StoreUint32(&o.PACRD.Reg, volatile.LoadUint32(&o.PACRD.Reg)&^(0x20)|value<<5)
}
func (o *AIPS_Type) GetPACRD_WP6() uint32 {
	return (volatile.LoadUint32(&o.PACRD.Reg) & 0x20) >> 5
}
func (o *AIPS_Type) SetPACRD_SP6(value uint32) {
	volatile.StoreUint32(&o.PACRD.Reg, volatile.LoadUint32(&o.PACRD.Reg)&^(0x40)|value<<6)
}
func (o *AIPS_Type) GetPACRD_SP6() uint32 {
	return (volatile.LoadUint32(&o.PACRD.Reg) & 0x40) >> 6
}
func (o *AIPS_Type) SetPACRD_TP5(value uint32) {
	volatile.StoreUint32(&o.PACRD.Reg, volatile.LoadUint32(&o.PACRD.Reg)&^(0x100)|value<<8)
}
func (o *AIPS_Type) GetPACRD_TP5() uint32 {
	return (volatile.LoadUint32(&o.PACRD.Reg) & 0x100) >> 8
}
func (o *AIPS_Type) SetPACRD_WP5(value uint32) {
	volatile.StoreUint32(&o.PACRD.Reg, volatile.LoadUint32(&o.PACRD.Reg)&^(0x200)|value<<9)
}
func (o *AIPS_Type) GetPACRD_WP5() uint32 {
	return (volatile.LoadUint32(&o.PACRD.Reg) & 0x200) >> 9
}
func (o *AIPS_Type) SetPACRD_SP5(value uint32) {
	volatile.StoreUint32(&o.PACRD.Reg, volatile.LoadUint32(&o.PACRD.Reg)&^(0x400)|value<<10)
}
func (o *AIPS_Type) GetPACRD_SP5() uint32 {
	return (volatile.LoadUint32(&o.PACRD.Reg) & 0x400) >> 10
}
func (o *AIPS_Type) SetPACRD_TP4(value uint32) {
	volatile.StoreUint32(&o.PACRD.Reg, volatile.LoadUint32(&o.PACRD.Reg)&^(0x1000)|value<<12)
}
func (o *AIPS_Type) GetPACRD_TP4() uint32 {
	return (volatile.LoadUint32(&o.PACRD.Reg) & 0x1000) >> 12
}
func (o *AIPS_Type) SetPACRD_WP4(value uint32) {
	volatile.StoreUint32(&o.PACRD.Reg, volatile.LoadUint32(&o.PACRD.Reg)&^(0x2000)|value<<13)
}
func (o *AIPS_Type) GetPACRD_WP4() uint32 {
	return (volatile.LoadUint32(&o.PACRD.Reg) & 0x2000) >> 13
}
func (o *AIPS_Type) SetPACRD_SP4(value uint32) {
	volatile.StoreUint32(&o.PACRD.Reg, volatile.LoadUint32(&o.PACRD.Reg)&^(0x4000)|value<<14)
}
func (o *AIPS_Type) GetPACRD_SP4() uint32 {
	return (volatile.LoadUint32(&o.PACRD.Reg) & 0x4000) >> 14
}
func (o *AIPS_Type) SetPACRD_TP3(value uint32) {
	volatile.StoreUint32(&o.PACRD.Reg, volatile.LoadUint32(&o.PACRD.Reg)&^(0x10000)|value<<16)
}
func (o *AIPS_Type) GetPACRD_TP3() uint32 {
	return (volatile.LoadUint32(&o.PACRD.Reg) & 0x10000) >> 16
}
func (o *AIPS_Type) SetPACRD_WP3(value uint32) {
	volatile.StoreUint32(&o.PACRD.Reg, volatile.LoadUint32(&o.PACRD.Reg)&^(0x20000)|value<<17)
}
func (o *AIPS_Type) GetPACRD_WP3() uint32 {
	return (volatile.LoadUint32(&o.PACRD.Reg) & 0x20000) >> 17
}
func (o *AIPS_Type) SetPACRD_SP3(value uint32) {
	volatile.StoreUint32(&o.PACRD.Reg, volatile.LoadUint32(&o.PACRD.Reg)&^(0x40000)|value<<18)
}
func (o *AIPS_Type) GetPACRD_SP3() uint32 {
	return (volatile.LoadUint32(&o.PACRD.Reg) & 0x40000) >> 18
}
func (o *AIPS_Type) SetPACRD_TP2(value uint32) {
	volatile.StoreUint32(&o.PACRD.Reg, volatile.LoadUint32(&o.PACRD.Reg)&^(0x100000)|value<<20)
}
func (o *AIPS_Type) GetPACRD_TP2() uint32 {
	return (volatile.LoadUint32(&o.PACRD.Reg) & 0x100000) >> 20
}
func (o *AIPS_Type) SetPACRD_WP2(value uint32) {
	volatile.StoreUint32(&o.PACRD.Reg, volatile.LoadUint32(&o.PACRD.Reg)&^(0x200000)|value<<21)
}
func (o *AIPS_Type) GetPACRD_WP2() uint32 {
	return (volatile.LoadUint32(&o.PACRD.Reg) & 0x200000) >> 21
}
func (o *AIPS_Type) SetPACRD_SP2(value uint32) {
	volatile.StoreUint32(&o.PACRD.Reg, volatile.LoadUint32(&o.PACRD.Reg)&^(0x400000)|value<<22)
}
func (o *AIPS_Type) GetPACRD_SP2() uint32 {
	return (volatile.LoadUint32(&o.PACRD.Reg) & 0x400000) >> 22
}
func (o *AIPS_Type) SetPACRD_TP1(value uint32) {
	volatile.StoreUint32(&o.PACRD.Reg, volatile.LoadUint32(&o.PACRD.Reg)&^(0x1000000)|value<<24)
}
func (o *AIPS_Type) GetPACRD_TP1() uint32 {
	return (volatile.LoadUint32(&o.PACRD.Reg) & 0x1000000) >> 24
}
func (o *AIPS_Type) SetPACRD_WP1(value uint32) {
	volatile.StoreUint32(&o.PACRD.Reg, volatile.LoadUint32(&o.PACRD.Reg)&^(0x2000000)|value<<25)
}
func (o *AIPS_Type) GetPACRD_WP1() uint32 {
	return (volatile.LoadUint32(&o.PACRD.Reg) & 0x2000000) >> 25
}
func (o *AIPS_Type) SetPACRD_SP1(value uint32) {
	volatile.StoreUint32(&o.PACRD.Reg, volatile.LoadUint32(&o.PACRD.Reg)&^(0x4000000)|value<<26)
}
func (o *AIPS_Type) GetPACRD_SP1() uint32 {
	return (volatile.LoadUint32(&o.PACRD.Reg) & 0x4000000) >> 26
}
func (o *AIPS_Type) SetPACRD_TP0(value uint32) {
	volatile.StoreUint32(&o.PACRD.Reg, volatile.LoadUint32(&o.PACRD.Reg)&^(0x10000000)|value<<28)
}
func (o *AIPS_Type) GetPACRD_TP0() uint32 {
	return (volatile.LoadUint32(&o.PACRD.Reg) & 0x10000000) >> 28
}
func (o *AIPS_Type) SetPACRD_WP0(value uint32) {
	volatile.StoreUint32(&o.PACRD.Reg, volatile.LoadUint32(&o.PACRD.Reg)&^(0x20000000)|value<<29)
}
func (o *AIPS_Type) GetPACRD_WP0() uint32 {
	return (volatile.LoadUint32(&o.PACRD.Reg) & 0x20000000) >> 29
}
func (o *AIPS_Type) SetPACRD_SP0(value uint32) {
	volatile.StoreUint32(&o.PACRD.Reg, volatile.LoadUint32(&o.PACRD.Reg)&^(0x40000000)|value<<30)
}
func (o *AIPS_Type) GetPACRD_SP0() uint32 {
	return (volatile.LoadUint32(&o.PACRD.Reg) & 0x40000000) >> 30
}

// AIPS.PACRE: Peripheral Access Control Register
func (o *AIPS_Type) SetPACRE_TP7(value uint32) {
	volatile.StoreUint32(&o.PACRE.Reg, volatile.LoadUint32(&o.PACRE.Reg)&^(0x1)|value)
}
func (o *AIPS_Type) GetPACRE_TP7() uint32 {
	return volatile.LoadUint32(&o.PACRE.Reg) & 0x1
}
func (o *AIPS_Type) SetPACRE_WP7(value uint32) {
	volatile.StoreUint32(&o.PACRE.Reg, volatile.LoadUint32(&o.PACRE.Reg)&^(0x2)|value<<1)
}
func (o *AIPS_Type) GetPACRE_WP7() uint32 {
	return (volatile.LoadUint32(&o.PACRE.Reg) & 0x2) >> 1
}
func (o *AIPS_Type) SetPACRE_SP7(value uint32) {
	volatile.StoreUint32(&o.PACRE.Reg, volatile.LoadUint32(&o.PACRE.Reg)&^(0x4)|value<<2)
}
func (o *AIPS_Type) GetPACRE_SP7() uint32 {
	return (volatile.LoadUint32(&o.PACRE.Reg) & 0x4) >> 2
}
func (o *AIPS_Type) SetPACRE_TP6(value uint32) {
	volatile.StoreUint32(&o.PACRE.Reg, volatile.LoadUint32(&o.PACRE.Reg)&^(0x10)|value<<4)
}
func (o *AIPS_Type) GetPACRE_TP6() uint32 {
	return (volatile.LoadUint32(&o.PACRE.Reg) & 0x10) >> 4
}
func (o *AIPS_Type) SetPACRE_WP6(value uint32) {
	volatile.StoreUint32(&o.PACRE.Reg, volatile.LoadUint32(&o.PACRE.Reg)&^(0x20)|value<<5)
}
func (o *AIPS_Type) GetPACRE_WP6() uint32 {
	return (volatile.LoadUint32(&o.PACRE.Reg) & 0x20) >> 5
}
func (o *AIPS_Type) SetPACRE_SP6(value uint32) {
	volatile.StoreUint32(&o.PACRE.Reg, volatile.LoadUint32(&o.PACRE.Reg)&^(0x40)|value<<6)
}
func (o *AIPS_Type) GetPACRE_SP6() uint32 {
	return (volatile.LoadUint32(&o.PACRE.Reg) & 0x40) >> 6
}
func (o *AIPS_Type) SetPACRE_TP5(value uint32) {
	volatile.StoreUint32(&o.PACRE.Reg, volatile.LoadUint32(&o.PACRE.Reg)&^(0x100)|value<<8)
}
func (o *AIPS_Type) GetPACRE_TP5() uint32 {
	return (volatile.LoadUint32(&o.PACRE.Reg) & 0x100) >> 8
}
func (o *AIPS_Type) SetPACRE_WP5(value uint32) {
	volatile.StoreUint32(&o.PACRE.Reg, volatile.LoadUint32(&o.PACRE.Reg)&^(0x200)|value<<9)
}
func (o *AIPS_Type) GetPACRE_WP5() uint32 {
	return (volatile.LoadUint32(&o.PACRE.Reg) & 0x200) >> 9
}
func (o *AIPS_Type) SetPACRE_SP5(value uint32) {
	volatile.StoreUint32(&o.PACRE.Reg, volatile.LoadUint32(&o.PACRE.Reg)&^(0x400)|value<<10)
}
func (o *AIPS_Type) GetPACRE_SP5() uint32 {
	return (volatile.LoadUint32(&o.PACRE.Reg) & 0x400) >> 10
}
func (o *AIPS_Type) SetPACRE_TP4(value uint32) {
	volatile.StoreUint32(&o.PACRE.Reg, volatile.LoadUint32(&o.PACRE.Reg)&^(0x1000)|value<<12)
}
func (o *AIPS_Type) GetPACRE_TP4() uint32 {
	return (volatile.LoadUint32(&o.PACRE.Reg) & 0x1000) >> 12
}
func (o *AIPS_Type) SetPACRE_WP4(value uint32) {
	volatile.StoreUint32(&o.PACRE.Reg, volatile.LoadUint32(&o.PACRE.Reg)&^(0x2000)|value<<13)
}
func (o *AIPS_Type) GetPACRE_WP4() uint32 {
	return (volatile.LoadUint32(&o.PACRE.Reg) & 0x2000) >> 13
}
func (o *AIPS_Type) SetPACRE_SP4(value uint32) {
	volatile.StoreUint32(&o.PACRE.Reg, volatile.LoadUint32(&o.PACRE.Reg)&^(0x4000)|value<<14)
}
func (o *AIPS_Type) GetPACRE_SP4() uint32 {
	return (volatile.LoadUint32(&o.PACRE.Reg) & 0x4000) >> 14
}
func (o *AIPS_Type) SetPACRE_TP3(value uint32) {
	volatile.StoreUint32(&o.PACRE.Reg, volatile.LoadUint32(&o.PACRE.Reg)&^(0x10000)|value<<16)
}
func (o *AIPS_Type) GetPACRE_TP3() uint32 {
	return (volatile.LoadUint32(&o.PACRE.Reg) & 0x10000) >> 16
}
func (o *AIPS_Type) SetPACRE_WP3(value uint32) {
	volatile.StoreUint32(&o.PACRE.Reg, volatile.LoadUint32(&o.PACRE.Reg)&^(0x20000)|value<<17)
}
func (o *AIPS_Type) GetPACRE_WP3() uint32 {
	return (volatile.LoadUint32(&o.PACRE.Reg) & 0x20000) >> 17
}
func (o *AIPS_Type) SetPACRE_SP3(value uint32) {
	volatile.StoreUint32(&o.PACRE.Reg, volatile.LoadUint32(&o.PACRE.Reg)&^(0x40000)|value<<18)
}
func (o *AIPS_Type) GetPACRE_SP3() uint32 {
	return (volatile.LoadUint32(&o.PACRE.Reg) & 0x40000) >> 18
}
func (o *AIPS_Type) SetPACRE_TP2(value uint32) {
	volatile.StoreUint32(&o.PACRE.Reg, volatile.LoadUint32(&o.PACRE.Reg)&^(0x100000)|value<<20)
}
func (o *AIPS_Type) GetPACRE_TP2() uint32 {
	return (volatile.LoadUint32(&o.PACRE.Reg) & 0x100000) >> 20
}
func (o *AIPS_Type) SetPACRE_WP2(value uint32) {
	volatile.StoreUint32(&o.PACRE.Reg, volatile.LoadUint32(&o.PACRE.Reg)&^(0x200000)|value<<21)
}
func (o *AIPS_Type) GetPACRE_WP2() uint32 {
	return (volatile.LoadUint32(&o.PACRE.Reg) & 0x200000) >> 21
}
func (o *AIPS_Type) SetPACRE_SP2(value uint32) {
	volatile.StoreUint32(&o.PACRE.Reg, volatile.LoadUint32(&o.PACRE.Reg)&^(0x400000)|value<<22)
}
func (o *AIPS_Type) GetPACRE_SP2() uint32 {
	return (volatile.LoadUint32(&o.PACRE.Reg) & 0x400000) >> 22
}
func (o *AIPS_Type) SetPACRE_TP1(value uint32) {
	volatile.StoreUint32(&o.PACRE.Reg, volatile.LoadUint32(&o.PACRE.Reg)&^(0x1000000)|value<<24)
}
func (o *AIPS_Type) GetPACRE_TP1() uint32 {
	return (volatile.LoadUint32(&o.PACRE.Reg) & 0x1000000) >> 24
}
func (o *AIPS_Type) SetPACRE_WP1(value uint32) {
	volatile.StoreUint32(&o.PACRE.Reg, volatile.LoadUint32(&o.PACRE.Reg)&^(0x2000000)|value<<25)
}
func (o *AIPS_Type) GetPACRE_WP1() uint32 {
	return (volatile.LoadUint32(&o.PACRE.Reg) & 0x2000000) >> 25
}
func (o *AIPS_Type) SetPACRE_SP1(value uint32) {
	volatile.StoreUint32(&o.PACRE.Reg, volatile.LoadUint32(&o.PACRE.Reg)&^(0x4000000)|value<<26)
}
func (o *AIPS_Type) GetPACRE_SP1() uint32 {
	return (volatile.LoadUint32(&o.PACRE.Reg) & 0x4000000) >> 26
}
func (o *AIPS_Type) SetPACRE_TP0(value uint32) {
	volatile.StoreUint32(&o.PACRE.Reg, volatile.LoadUint32(&o.PACRE.Reg)&^(0x10000000)|value<<28)
}
func (o *AIPS_Type) GetPACRE_TP0() uint32 {
	return (volatile.LoadUint32(&o.PACRE.Reg) & 0x10000000) >> 28
}
func (o *AIPS_Type) SetPACRE_WP0(value uint32) {
	volatile.StoreUint32(&o.PACRE.Reg, volatile.LoadUint32(&o.PACRE.Reg)&^(0x20000000)|value<<29)
}
func (o *AIPS_Type) GetPACRE_WP0() uint32 {
	return (volatile.LoadUint32(&o.PACRE.Reg) & 0x20000000) >> 29
}
func (o *AIPS_Type) SetPACRE_SP0(value uint32) {
	volatile.StoreUint32(&o.PACRE.Reg, volatile.LoadUint32(&o.PACRE.Reg)&^(0x40000000)|value<<30)
}
func (o *AIPS_Type) GetPACRE_SP0() uint32 {
	return (volatile.LoadUint32(&o.PACRE.Reg) & 0x40000000) >> 30
}

// AIPS.PACRF: Peripheral Access Control Register
func (o *AIPS_Type) SetPACRF_TP7(value uint32) {
	volatile.StoreUint32(&o.PACRF.Reg, volatile.LoadUint32(&o.PACRF.Reg)&^(0x1)|value)
}
func (o *AIPS_Type) GetPACRF_TP7() uint32 {
	return volatile.LoadUint32(&o.PACRF.Reg) & 0x1
}
func (o *AIPS_Type) SetPACRF_WP7(value uint32) {
	volatile.StoreUint32(&o.PACRF.Reg, volatile.LoadUint32(&o.PACRF.Reg)&^(0x2)|value<<1)
}
func (o *AIPS_Type) GetPACRF_WP7() uint32 {
	return (volatile.LoadUint32(&o.PACRF.Reg) & 0x2) >> 1
}
func (o *AIPS_Type) SetPACRF_SP7(value uint32) {
	volatile.StoreUint32(&o.PACRF.Reg, volatile.LoadUint32(&o.PACRF.Reg)&^(0x4)|value<<2)
}
func (o *AIPS_Type) GetPACRF_SP7() uint32 {
	return (volatile.LoadUint32(&o.PACRF.Reg) & 0x4) >> 2
}
func (o *AIPS_Type) SetPACRF_TP6(value uint32) {
	volatile.StoreUint32(&o.PACRF.Reg, volatile.LoadUint32(&o.PACRF.Reg)&^(0x10)|value<<4)
}
func (o *AIPS_Type) GetPACRF_TP6() uint32 {
	return (volatile.LoadUint32(&o.PACRF.Reg) & 0x10) >> 4
}
func (o *AIPS_Type) SetPACRF_WP6(value uint32) {
	volatile.StoreUint32(&o.PACRF.Reg, volatile.LoadUint32(&o.PACRF.Reg)&^(0x20)|value<<5)
}
func (o *AIPS_Type) GetPACRF_WP6() uint32 {
	return (volatile.LoadUint32(&o.PACRF.Reg) & 0x20) >> 5
}
func (o *AIPS_Type) SetPACRF_SP6(value uint32) {
	volatile.StoreUint32(&o.PACRF.Reg, volatile.LoadUint32(&o.PACRF.Reg)&^(0x40)|value<<6)
}
func (o *AIPS_Type) GetPACRF_SP6() uint32 {
	return (volatile.LoadUint32(&o.PACRF.Reg) & 0x40) >> 6
}
func (o *AIPS_Type) SetPACRF_TP5(value uint32) {
	volatile.StoreUint32(&o.PACRF.Reg, volatile.LoadUint32(&o.PACRF.Reg)&^(0x100)|value<<8)
}
func (o *AIPS_Type) GetPACRF_TP5() uint32 {
	return (volatile.LoadUint32(&o.PACRF.Reg) & 0x100) >> 8
}
func (o *AIPS_Type) SetPACRF_WP5(value uint32) {
	volatile.StoreUint32(&o.PACRF.Reg, volatile.LoadUint32(&o.PACRF.Reg)&^(0x200)|value<<9)
}
func (o *AIPS_Type) GetPACRF_WP5() uint32 {
	return (volatile.LoadUint32(&o.PACRF.Reg) & 0x200) >> 9
}
func (o *AIPS_Type) SetPACRF_SP5(value uint32) {
	volatile.StoreUint32(&o.PACRF.Reg, volatile.LoadUint32(&o.PACRF.Reg)&^(0x400)|value<<10)
}
func (o *AIPS_Type) GetPACRF_SP5() uint32 {
	return (volatile.LoadUint32(&o.PACRF.Reg) & 0x400) >> 10
}
func (o *AIPS_Type) SetPACRF_TP4(value uint32) {
	volatile.StoreUint32(&o.PACRF.Reg, volatile.LoadUint32(&o.PACRF.Reg)&^(0x1000)|value<<12)
}
func (o *AIPS_Type) GetPACRF_TP4() uint32 {
	return (volatile.LoadUint32(&o.PACRF.Reg) & 0x1000) >> 12
}
func (o *AIPS_Type) SetPACRF_WP4(value uint32) {
	volatile.StoreUint32(&o.PACRF.Reg, volatile.LoadUint32(&o.PACRF.Reg)&^(0x2000)|value<<13)
}
func (o *AIPS_Type) GetPACRF_WP4() uint32 {
	return (volatile.LoadUint32(&o.PACRF.Reg) & 0x2000) >> 13
}
func (o *AIPS_Type) SetPACRF_SP4(value uint32) {
	volatile.StoreUint32(&o.PACRF.Reg, volatile.LoadUint32(&o.PACRF.Reg)&^(0x4000)|value<<14)
}
func (o *AIPS_Type) GetPACRF_SP4() uint32 {
	return (volatile.LoadUint32(&o.PACRF.Reg) & 0x4000) >> 14
}
func (o *AIPS_Type) SetPACRF_TP3(value uint32) {
	volatile.StoreUint32(&o.PACRF.Reg, volatile.LoadUint32(&o.PACRF.Reg)&^(0x10000)|value<<16)
}
func (o *AIPS_Type) GetPACRF_TP3() uint32 {
	return (volatile.LoadUint32(&o.PACRF.Reg) & 0x10000) >> 16
}
func (o *AIPS_Type) SetPACRF_WP3(value uint32) {
	volatile.StoreUint32(&o.PACRF.Reg, volatile.LoadUint32(&o.PACRF.Reg)&^(0x20000)|value<<17)
}
func (o *AIPS_Type) GetPACRF_WP3() uint32 {
	return (volatile.LoadUint32(&o.PACRF.Reg) & 0x20000) >> 17
}
func (o *AIPS_Type) SetPACRF_SP3(value uint32) {
	volatile.StoreUint32(&o.PACRF.Reg, volatile.LoadUint32(&o.PACRF.Reg)&^(0x40000)|value<<18)
}
func (o *AIPS_Type) GetPACRF_SP3() uint32 {
	return (volatile.LoadUint32(&o.PACRF.Reg) & 0x40000) >> 18
}
func (o *AIPS_Type) SetPACRF_TP2(value uint32) {
	volatile.StoreUint32(&o.PACRF.Reg, volatile.LoadUint32(&o.PACRF.Reg)&^(0x100000)|value<<20)
}
func (o *AIPS_Type) GetPACRF_TP2() uint32 {
	return (volatile.LoadUint32(&o.PACRF.Reg) & 0x100000) >> 20
}
func (o *AIPS_Type) SetPACRF_WP2(value uint32) {
	volatile.StoreUint32(&o.PACRF.Reg, volatile.LoadUint32(&o.PACRF.Reg)&^(0x200000)|value<<21)
}
func (o *AIPS_Type) GetPACRF_WP2() uint32 {
	return (volatile.LoadUint32(&o.PACRF.Reg) & 0x200000) >> 21
}
func (o *AIPS_Type) SetPACRF_SP2(value uint32) {
	volatile.StoreUint32(&o.PACRF.Reg, volatile.LoadUint32(&o.PACRF.Reg)&^(0x400000)|value<<22)
}
func (o *AIPS_Type) GetPACRF_SP2() uint32 {
	return (volatile.LoadUint32(&o.PACRF.Reg) & 0x400000) >> 22
}
func (o *AIPS_Type) SetPACRF_TP1(value uint32) {
	volatile.StoreUint32(&o.PACRF.Reg, volatile.LoadUint32(&o.PACRF.Reg)&^(0x1000000)|value<<24)
}
func (o *AIPS_Type) GetPACRF_TP1() uint32 {
	return (volatile.LoadUint32(&o.PACRF.Reg) & 0x1000000) >> 24
}
func (o *AIPS_Type) SetPACRF_WP1(value uint32) {
	volatile.StoreUint32(&o.PACRF.Reg, volatile.LoadUint32(&o.PACRF.Reg)&^(0x2000000)|value<<25)
}
func (o *AIPS_Type) GetPACRF_WP1() uint32 {
	return (volatile.LoadUint32(&o.PACRF.Reg) & 0x2000000) >> 25
}
func (o *AIPS_Type) SetPACRF_SP1(value uint32) {
	volatile.StoreUint32(&o.PACRF.Reg, volatile.LoadUint32(&o.PACRF.Reg)&^(0x4000000)|value<<26)
}
func (o *AIPS_Type) GetPACRF_SP1() uint32 {
	return (volatile.LoadUint32(&o.PACRF.Reg) & 0x4000000) >> 26
}
func (o *AIPS_Type) SetPACRF_TP0(value uint32) {
	volatile.StoreUint32(&o.PACRF.Reg, volatile.LoadUint32(&o.PACRF.Reg)&^(0x10000000)|value<<28)
}
func (o *AIPS_Type) GetPACRF_TP0() uint32 {
	return (volatile.LoadUint32(&o.PACRF.Reg) & 0x10000000) >> 28
}
func (o *AIPS_Type) SetPACRF_WP0(value uint32) {
	volatile.StoreUint32(&o.PACRF.Reg, volatile.LoadUint32(&o.PACRF.Reg)&^(0x20000000)|value<<29)
}
func (o *AIPS_Type) GetPACRF_WP0() uint32 {
	return (volatile.LoadUint32(&o.PACRF.Reg) & 0x20000000) >> 29
}
func (o *AIPS_Type) SetPACRF_SP0(value uint32) {
	volatile.StoreUint32(&o.PACRF.Reg, volatile.LoadUint32(&o.PACRF.Reg)&^(0x40000000)|value<<30)
}
func (o *AIPS_Type) GetPACRF_SP0() uint32 {
	return (volatile.LoadUint32(&o.PACRF.Reg) & 0x40000000) >> 30
}

// AIPS.PACRG: Peripheral Access Control Register
func (o *AIPS_Type) SetPACRG_TP7(value uint32) {
	volatile.StoreUint32(&o.PACRG.Reg, volatile.LoadUint32(&o.PACRG.Reg)&^(0x1)|value)
}
func (o *AIPS_Type) GetPACRG_TP7() uint32 {
	return volatile.LoadUint32(&o.PACRG.Reg) & 0x1
}
func (o *AIPS_Type) SetPACRG_WP7(value uint32) {
	volatile.StoreUint32(&o.PACRG.Reg, volatile.LoadUint32(&o.PACRG.Reg)&^(0x2)|value<<1)
}
func (o *AIPS_Type) GetPACRG_WP7() uint32 {
	return (volatile.LoadUint32(&o.PACRG.Reg) & 0x2) >> 1
}
func (o *AIPS_Type) SetPACRG_SP7(value uint32) {
	volatile.StoreUint32(&o.PACRG.Reg, volatile.LoadUint32(&o.PACRG.Reg)&^(0x4)|value<<2)
}
func (o *AIPS_Type) GetPACRG_SP7() uint32 {
	return (volatile.LoadUint32(&o.PACRG.Reg) & 0x4) >> 2
}
func (o *AIPS_Type) SetPACRG_TP6(value uint32) {
	volatile.StoreUint32(&o.PACRG.Reg, volatile.LoadUint32(&o.PACRG.Reg)&^(0x10)|value<<4)
}
func (o *AIPS_Type) GetPACRG_TP6() uint32 {
	return (volatile.LoadUint32(&o.PACRG.Reg) & 0x10) >> 4
}
func (o *AIPS_Type) SetPACRG_WP6(value uint32) {
	volatile.StoreUint32(&o.PACRG.Reg, volatile.LoadUint32(&o.PACRG.Reg)&^(0x20)|value<<5)
}
func (o *AIPS_Type) GetPACRG_WP6() uint32 {
	return (volatile.LoadUint32(&o.PACRG.Reg) & 0x20) >> 5
}
func (o *AIPS_Type) SetPACRG_SP6(value uint32) {
	volatile.StoreUint32(&o.PACRG.Reg, volatile.LoadUint32(&o.PACRG.Reg)&^(0x40)|value<<6)
}
func (o *AIPS_Type) GetPACRG_SP6() uint32 {
	return (volatile.LoadUint32(&o.PACRG.Reg) & 0x40) >> 6
}
func (o *AIPS_Type) SetPACRG_TP5(value uint32) {
	volatile.StoreUint32(&o.PACRG.Reg, volatile.LoadUint32(&o.PACRG.Reg)&^(0x100)|value<<8)
}
func (o *AIPS_Type) GetPACRG_TP5() uint32 {
	return (volatile.LoadUint32(&o.PACRG.Reg) & 0x100) >> 8
}
func (o *AIPS_Type) SetPACRG_WP5(value uint32) {
	volatile.StoreUint32(&o.PACRG.Reg, volatile.LoadUint32(&o.PACRG.Reg)&^(0x200)|value<<9)
}
func (o *AIPS_Type) GetPACRG_WP5() uint32 {
	return (volatile.LoadUint32(&o.PACRG.Reg) & 0x200) >> 9
}
func (o *AIPS_Type) SetPACRG_SP5(value uint32) {
	volatile.StoreUint32(&o.PACRG.Reg, volatile.LoadUint32(&o.PACRG.Reg)&^(0x400)|value<<10)
}
func (o *AIPS_Type) GetPACRG_SP5() uint32 {
	return (volatile.LoadUint32(&o.PACRG.Reg) & 0x400) >> 10
}
func (o *AIPS_Type) SetPACRG_TP4(value uint32) {
	volatile.StoreUint32(&o.PACRG.Reg, volatile.LoadUint32(&o.PACRG.Reg)&^(0x1000)|value<<12)
}
func (o *AIPS_Type) GetPACRG_TP4() uint32 {
	return (volatile.LoadUint32(&o.PACRG.Reg) & 0x1000) >> 12
}
func (o *AIPS_Type) SetPACRG_WP4(value uint32) {
	volatile.StoreUint32(&o.PACRG.Reg, volatile.LoadUint32(&o.PACRG.Reg)&^(0x2000)|value<<13)
}
func (o *AIPS_Type) GetPACRG_WP4() uint32 {
	return (volatile.LoadUint32(&o.PACRG.Reg) & 0x2000) >> 13
}
func (o *AIPS_Type) SetPACRG_SP4(value uint32) {
	volatile.StoreUint32(&o.PACRG.Reg, volatile.LoadUint32(&o.PACRG.Reg)&^(0x4000)|value<<14)
}
func (o *AIPS_Type) GetPACRG_SP4() uint32 {
	return (volatile.LoadUint32(&o.PACRG.Reg) & 0x4000) >> 14
}
func (o *AIPS_Type) SetPACRG_TP3(value uint32) {
	volatile.StoreUint32(&o.PACRG.Reg, volatile.LoadUint32(&o.PACRG.Reg)&^(0x10000)|value<<16)
}
func (o *AIPS_Type) GetPACRG_TP3() uint32 {
	return (volatile.LoadUint32(&o.PACRG.Reg) & 0x10000) >> 16
}
func (o *AIPS_Type) SetPACRG_WP3(value uint32) {
	volatile.StoreUint32(&o.PACRG.Reg, volatile.LoadUint32(&o.PACRG.Reg)&^(0x20000)|value<<17)
}
func (o *AIPS_Type) GetPACRG_WP3() uint32 {
	return (volatile.LoadUint32(&o.PACRG.Reg) & 0x20000) >> 17
}
func (o *AIPS_Type) SetPACRG_SP3(value uint32) {
	volatile.StoreUint32(&o.PACRG.Reg, volatile.LoadUint32(&o.PACRG.Reg)&^(0x40000)|value<<18)
}
func (o *AIPS_Type) GetPACRG_SP3() uint32 {
	return (volatile.LoadUint32(&o.PACRG.Reg) & 0x40000) >> 18
}
func (o *AIPS_Type) SetPACRG_TP2(value uint32) {
	volatile.StoreUint32(&o.PACRG.Reg, volatile.LoadUint32(&o.PACRG.Reg)&^(0x100000)|value<<20)
}
func (o *AIPS_Type) GetPACRG_TP2() uint32 {
	return (volatile.LoadUint32(&o.PACRG.Reg) & 0x100000) >> 20
}
func (o *AIPS_Type) SetPACRG_WP2(value uint32) {
	volatile.StoreUint32(&o.PACRG.Reg, volatile.LoadUint32(&o.PACRG.Reg)&^(0x200000)|value<<21)
}
func (o *AIPS_Type) GetPACRG_WP2() uint32 {
	return (volatile.LoadUint32(&o.PACRG.Reg) & 0x200000) >> 21
}
func (o *AIPS_Type) SetPACRG_SP2(value uint32) {
	volatile.StoreUint32(&o.PACRG.Reg, volatile.LoadUint32(&o.PACRG.Reg)&^(0x400000)|value<<22)
}
func (o *AIPS_Type) GetPACRG_SP2() uint32 {
	return (volatile.LoadUint32(&o.PACRG.Reg) & 0x400000) >> 22
}
func (o *AIPS_Type) SetPACRG_TP1(value uint32) {
	volatile.StoreUint32(&o.PACRG.Reg, volatile.LoadUint32(&o.PACRG.Reg)&^(0x1000000)|value<<24)
}
func (o *AIPS_Type) GetPACRG_TP1() uint32 {
	return (volatile.LoadUint32(&o.PACRG.Reg) & 0x1000000) >> 24
}
func (o *AIPS_Type) SetPACRG_WP1(value uint32) {
	volatile.StoreUint32(&o.PACRG.Reg, volatile.LoadUint32(&o.PACRG.Reg)&^(0x2000000)|value<<25)
}
func (o *AIPS_Type) GetPACRG_WP1() uint32 {
	return (volatile.LoadUint32(&o.PACRG.Reg) & 0x2000000) >> 25
}
func (o *AIPS_Type) SetPACRG_SP1(value uint32) {
	volatile.StoreUint32(&o.PACRG.Reg, volatile.LoadUint32(&o.PACRG.Reg)&^(0x4000000)|value<<26)
}
func (o *AIPS_Type) GetPACRG_SP1() uint32 {
	return (volatile.LoadUint32(&o.PACRG.Reg) & 0x4000000) >> 26
}
func (o *AIPS_Type) SetPACRG_TP0(value uint32) {
	volatile.StoreUint32(&o.PACRG.Reg, volatile.LoadUint32(&o.PACRG.Reg)&^(0x10000000)|value<<28)
}
func (o *AIPS_Type) GetPACRG_TP0() uint32 {
	return (volatile.LoadUint32(&o.PACRG.Reg) & 0x10000000) >> 28
}
func (o *AIPS_Type) SetPACRG_WP0(value uint32) {
	volatile.StoreUint32(&o.PACRG.Reg, volatile.LoadUint32(&o.PACRG.Reg)&^(0x20000000)|value<<29)
}
func (o *AIPS_Type) GetPACRG_WP0() uint32 {
	return (volatile.LoadUint32(&o.PACRG.Reg) & 0x20000000) >> 29
}
func (o *AIPS_Type) SetPACRG_SP0(value uint32) {
	volatile.StoreUint32(&o.PACRG.Reg, volatile.LoadUint32(&o.PACRG.Reg)&^(0x40000000)|value<<30)
}
func (o *AIPS_Type) GetPACRG_SP0() uint32 {
	return (volatile.LoadUint32(&o.PACRG.Reg) & 0x40000000) >> 30
}

// AIPS.PACRH: Peripheral Access Control Register
func (o *AIPS_Type) SetPACRH_TP7(value uint32) {
	volatile.StoreUint32(&o.PACRH.Reg, volatile.LoadUint32(&o.PACRH.Reg)&^(0x1)|value)
}
func (o *AIPS_Type) GetPACRH_TP7() uint32 {
	return volatile.LoadUint32(&o.PACRH.Reg) & 0x1
}
func (o *AIPS_Type) SetPACRH_WP7(value uint32) {
	volatile.StoreUint32(&o.PACRH.Reg, volatile.LoadUint32(&o.PACRH.Reg)&^(0x2)|value<<1)
}
func (o *AIPS_Type) GetPACRH_WP7() uint32 {
	return (volatile.LoadUint32(&o.PACRH.Reg) & 0x2) >> 1
}
func (o *AIPS_Type) SetPACRH_SP7(value uint32) {
	volatile.StoreUint32(&o.PACRH.Reg, volatile.LoadUint32(&o.PACRH.Reg)&^(0x4)|value<<2)
}
func (o *AIPS_Type) GetPACRH_SP7() uint32 {
	return (volatile.LoadUint32(&o.PACRH.Reg) & 0x4) >> 2
}
func (o *AIPS_Type) SetPACRH_TP6(value uint32) {
	volatile.StoreUint32(&o.PACRH.Reg, volatile.LoadUint32(&o.PACRH.Reg)&^(0x10)|value<<4)
}
func (o *AIPS_Type) GetPACRH_TP6() uint32 {
	return (volatile.LoadUint32(&o.PACRH.Reg) & 0x10) >> 4
}
func (o *AIPS_Type) SetPACRH_WP6(value uint32) {
	volatile.StoreUint32(&o.PACRH.Reg, volatile.LoadUint32(&o.PACRH.Reg)&^(0x20)|value<<5)
}
func (o *AIPS_Type) GetPACRH_WP6() uint32 {
	return (volatile.LoadUint32(&o.PACRH.Reg) & 0x20) >> 5
}
func (o *AIPS_Type) SetPACRH_SP6(value uint32) {
	volatile.StoreUint32(&o.PACRH.Reg, volatile.LoadUint32(&o.PACRH.Reg)&^(0x40)|value<<6)
}
func (o *AIPS_Type) GetPACRH_SP6() uint32 {
	return (volatile.LoadUint32(&o.PACRH.Reg) & 0x40) >> 6
}
func (o *AIPS_Type) SetPACRH_TP5(value uint32) {
	volatile.StoreUint32(&o.PACRH.Reg, volatile.LoadUint32(&o.PACRH.Reg)&^(0x100)|value<<8)
}
func (o *AIPS_Type) GetPACRH_TP5() uint32 {
	return (volatile.LoadUint32(&o.PACRH.Reg) & 0x100) >> 8
}
func (o *AIPS_Type) SetPACRH_WP5(value uint32) {
	volatile.StoreUint32(&o.PACRH.Reg, volatile.LoadUint32(&o.PACRH.Reg)&^(0x200)|value<<9)
}
func (o *AIPS_Type) GetPACRH_WP5() uint32 {
	return (volatile.LoadUint32(&o.PACRH.Reg) & 0x200) >> 9
}
func (o *AIPS_Type) SetPACRH_SP5(value uint32) {
	volatile.StoreUint32(&o.PACRH.Reg, volatile.LoadUint32(&o.PACRH.Reg)&^(0x400)|value<<10)
}
func (o *AIPS_Type) GetPACRH_SP5() uint32 {
	return (volatile.LoadUint32(&o.PACRH.Reg) & 0x400) >> 10
}
func (o *AIPS_Type) SetPACRH_TP4(value uint32) {
	volatile.StoreUint32(&o.PACRH.Reg, volatile.LoadUint32(&o.PACRH.Reg)&^(0x1000)|value<<12)
}
func (o *AIPS_Type) GetPACRH_TP4() uint32 {
	return (volatile.LoadUint32(&o.PACRH.Reg) & 0x1000) >> 12
}
func (o *AIPS_Type) SetPACRH_WP4(value uint32) {
	volatile.StoreUint32(&o.PACRH.Reg, volatile.LoadUint32(&o.PACRH.Reg)&^(0x2000)|value<<13)
}
func (o *AIPS_Type) GetPACRH_WP4() uint32 {
	return (volatile.LoadUint32(&o.PACRH.Reg) & 0x2000) >> 13
}
func (o *AIPS_Type) SetPACRH_SP4(value uint32) {
	volatile.StoreUint32(&o.PACRH.Reg, volatile.LoadUint32(&o.PACRH.Reg)&^(0x4000)|value<<14)
}
func (o *AIPS_Type) GetPACRH_SP4() uint32 {
	return (volatile.LoadUint32(&o.PACRH.Reg) & 0x4000) >> 14
}
func (o *AIPS_Type) SetPACRH_TP3(value uint32) {
	volatile.StoreUint32(&o.PACRH.Reg, volatile.LoadUint32(&o.PACRH.Reg)&^(0x10000)|value<<16)
}
func (o *AIPS_Type) GetPACRH_TP3() uint32 {
	return (volatile.LoadUint32(&o.PACRH.Reg) & 0x10000) >> 16
}
func (o *AIPS_Type) SetPACRH_WP3(value uint32) {
	volatile.StoreUint32(&o.PACRH.Reg, volatile.LoadUint32(&o.PACRH.Reg)&^(0x20000)|value<<17)
}
func (o *AIPS_Type) GetPACRH_WP3() uint32 {
	return (volatile.LoadUint32(&o.PACRH.Reg) & 0x20000) >> 17
}
func (o *AIPS_Type) SetPACRH_SP3(value uint32) {
	volatile.StoreUint32(&o.PACRH.Reg, volatile.LoadUint32(&o.PACRH.Reg)&^(0x40000)|value<<18)
}
func (o *AIPS_Type) GetPACRH_SP3() uint32 {
	return (volatile.LoadUint32(&o.PACRH.Reg) & 0x40000) >> 18
}
func (o *AIPS_Type) SetPACRH_TP2(value uint32) {
	volatile.StoreUint32(&o.PACRH.Reg, volatile.LoadUint32(&o.PACRH.Reg)&^(0x100000)|value<<20)
}
func (o *AIPS_Type) GetPACRH_TP2() uint32 {
	return (volatile.LoadUint32(&o.PACRH.Reg) & 0x100000) >> 20
}
func (o *AIPS_Type) SetPACRH_WP2(value uint32) {
	volatile.StoreUint32(&o.PACRH.Reg, volatile.LoadUint32(&o.PACRH.Reg)&^(0x200000)|value<<21)
}
func (o *AIPS_Type) GetPACRH_WP2() uint32 {
	return (volatile.LoadUint32(&o.PACRH.Reg) & 0x200000) >> 21
}
func (o *AIPS_Type) SetPACRH_SP2(value uint32) {
	volatile.StoreUint32(&o.PACRH.Reg, volatile.LoadUint32(&o.PACRH.Reg)&^(0x400000)|value<<22)
}
func (o *AIPS_Type) GetPACRH_SP2() uint32 {
	return (volatile.LoadUint32(&o.PACRH.Reg) & 0x400000) >> 22
}
func (o *AIPS_Type) SetPACRH_TP1(value uint32) {
	volatile.StoreUint32(&o.PACRH.Reg, volatile.LoadUint32(&o.PACRH.Reg)&^(0x1000000)|value<<24)
}
func (o *AIPS_Type) GetPACRH_TP1() uint32 {
	return (volatile.LoadUint32(&o.PACRH.Reg) & 0x1000000) >> 24
}
func (o *AIPS_Type) SetPACRH_WP1(value uint32) {
	volatile.StoreUint32(&o.PACRH.Reg, volatile.LoadUint32(&o.PACRH.Reg)&^(0x2000000)|value<<25)
}
func (o *AIPS_Type) GetPACRH_WP1() uint32 {
	return (volatile.LoadUint32(&o.PACRH.Reg) & 0x2000000) >> 25
}
func (o *AIPS_Type) SetPACRH_SP1(value uint32) {
	volatile.StoreUint32(&o.PACRH.Reg, volatile.LoadUint32(&o.PACRH.Reg)&^(0x4000000)|value<<26)
}
func (o *AIPS_Type) GetPACRH_SP1() uint32 {
	return (volatile.LoadUint32(&o.PACRH.Reg) & 0x4000000) >> 26
}
func (o *AIPS_Type) SetPACRH_TP0(value uint32) {
	volatile.StoreUint32(&o.PACRH.Reg, volatile.LoadUint32(&o.PACRH.Reg)&^(0x10000000)|value<<28)
}
func (o *AIPS_Type) GetPACRH_TP0() uint32 {
	return (volatile.LoadUint32(&o.PACRH.Reg) & 0x10000000) >> 28
}
func (o *AIPS_Type) SetPACRH_WP0(value uint32) {
	volatile.StoreUint32(&o.PACRH.Reg, volatile.LoadUint32(&o.PACRH.Reg)&^(0x20000000)|value<<29)
}
func (o *AIPS_Type) GetPACRH_WP0() uint32 {
	return (volatile.LoadUint32(&o.PACRH.Reg) & 0x20000000) >> 29
}
func (o *AIPS_Type) SetPACRH_SP0(value uint32) {
	volatile.StoreUint32(&o.PACRH.Reg, volatile.LoadUint32(&o.PACRH.Reg)&^(0x40000000)|value<<30)
}
func (o *AIPS_Type) GetPACRH_SP0() uint32 {
	return (volatile.LoadUint32(&o.PACRH.Reg) & 0x40000000) >> 30
}

// AIPS.PACRI: Peripheral Access Control Register
func (o *AIPS_Type) SetPACRI_TP7(value uint32) {
	volatile.StoreUint32(&o.PACRI.Reg, volatile.LoadUint32(&o.PACRI.Reg)&^(0x1)|value)
}
func (o *AIPS_Type) GetPACRI_TP7() uint32 {
	return volatile.LoadUint32(&o.PACRI.Reg) & 0x1
}
func (o *AIPS_Type) SetPACRI_WP7(value uint32) {
	volatile.StoreUint32(&o.PACRI.Reg, volatile.LoadUint32(&o.PACRI.Reg)&^(0x2)|value<<1)
}
func (o *AIPS_Type) GetPACRI_WP7() uint32 {
	return (volatile.LoadUint32(&o.PACRI.Reg) & 0x2) >> 1
}
func (o *AIPS_Type) SetPACRI_SP7(value uint32) {
	volatile.StoreUint32(&o.PACRI.Reg, volatile.LoadUint32(&o.PACRI.Reg)&^(0x4)|value<<2)
}
func (o *AIPS_Type) GetPACRI_SP7() uint32 {
	return (volatile.LoadUint32(&o.PACRI.Reg) & 0x4) >> 2
}
func (o *AIPS_Type) SetPACRI_TP6(value uint32) {
	volatile.StoreUint32(&o.PACRI.Reg, volatile.LoadUint32(&o.PACRI.Reg)&^(0x10)|value<<4)
}
func (o *AIPS_Type) GetPACRI_TP6() uint32 {
	return (volatile.LoadUint32(&o.PACRI.Reg) & 0x10) >> 4
}
func (o *AIPS_Type) SetPACRI_WP6(value uint32) {
	volatile.StoreUint32(&o.PACRI.Reg, volatile.LoadUint32(&o.PACRI.Reg)&^(0x20)|value<<5)
}
func (o *AIPS_Type) GetPACRI_WP6() uint32 {
	return (volatile.LoadUint32(&o.PACRI.Reg) & 0x20) >> 5
}
func (o *AIPS_Type) SetPACRI_SP6(value uint32) {
	volatile.StoreUint32(&o.PACRI.Reg, volatile.LoadUint32(&o.PACRI.Reg)&^(0x40)|value<<6)
}
func (o *AIPS_Type) GetPACRI_SP6() uint32 {
	return (volatile.LoadUint32(&o.PACRI.Reg) & 0x40) >> 6
}
func (o *AIPS_Type) SetPACRI_TP5(value uint32) {
	volatile.StoreUint32(&o.PACRI.Reg, volatile.LoadUint32(&o.PACRI.Reg)&^(0x100)|value<<8)
}
func (o *AIPS_Type) GetPACRI_TP5() uint32 {
	return (volatile.LoadUint32(&o.PACRI.Reg) & 0x100) >> 8
}
func (o *AIPS_Type) SetPACRI_WP5(value uint32) {
	volatile.StoreUint32(&o.PACRI.Reg, volatile.LoadUint32(&o.PACRI.Reg)&^(0x200)|value<<9)
}
func (o *AIPS_Type) GetPACRI_WP5() uint32 {
	return (volatile.LoadUint32(&o.PACRI.Reg) & 0x200) >> 9
}
func (o *AIPS_Type) SetPACRI_SP5(value uint32) {
	volatile.StoreUint32(&o.PACRI.Reg, volatile.LoadUint32(&o.PACRI.Reg)&^(0x400)|value<<10)
}
func (o *AIPS_Type) GetPACRI_SP5() uint32 {
	return (volatile.LoadUint32(&o.PACRI.Reg) & 0x400) >> 10
}
func (o *AIPS_Type) SetPACRI_TP4(value uint32) {
	volatile.StoreUint32(&o.PACRI.Reg, volatile.LoadUint32(&o.PACRI.Reg)&^(0x1000)|value<<12)
}
func (o *AIPS_Type) GetPACRI_TP4() uint32 {
	return (volatile.LoadUint32(&o.PACRI.Reg) & 0x1000) >> 12
}
func (o *AIPS_Type) SetPACRI_WP4(value uint32) {
	volatile.StoreUint32(&o.PACRI.Reg, volatile.LoadUint32(&o.PACRI.Reg)&^(0x2000)|value<<13)
}
func (o *AIPS_Type) GetPACRI_WP4() uint32 {
	return (volatile.LoadUint32(&o.PACRI.Reg) & 0x2000) >> 13
}
func (o *AIPS_Type) SetPACRI_SP4(value uint32) {
	volatile.StoreUint32(&o.PACRI.Reg, volatile.LoadUint32(&o.PACRI.Reg)&^(0x4000)|value<<14)
}
func (o *AIPS_Type) GetPACRI_SP4() uint32 {
	return (volatile.LoadUint32(&o.PACRI.Reg) & 0x4000) >> 14
}
func (o *AIPS_Type) SetPACRI_TP3(value uint32) {
	volatile.StoreUint32(&o.PACRI.Reg, volatile.LoadUint32(&o.PACRI.Reg)&^(0x10000)|value<<16)
}
func (o *AIPS_Type) GetPACRI_TP3() uint32 {
	return (volatile.LoadUint32(&o.PACRI.Reg) & 0x10000) >> 16
}
func (o *AIPS_Type) SetPACRI_WP3(value uint32) {
	volatile.StoreUint32(&o.PACRI.Reg, volatile.LoadUint32(&o.PACRI.Reg)&^(0x20000)|value<<17)
}
func (o *AIPS_Type) GetPACRI_WP3() uint32 {
	return (volatile.LoadUint32(&o.PACRI.Reg) & 0x20000) >> 17
}
func (o *AIPS_Type) SetPACRI_SP3(value uint32) {
	volatile.StoreUint32(&o.PACRI.Reg, volatile.LoadUint32(&o.PACRI.Reg)&^(0x40000)|value<<18)
}
func (o *AIPS_Type) GetPACRI_SP3() uint32 {
	return (volatile.LoadUint32(&o.PACRI.Reg) & 0x40000) >> 18
}
func (o *AIPS_Type) SetPACRI_TP2(value uint32) {
	volatile.StoreUint32(&o.PACRI.Reg, volatile.LoadUint32(&o.PACRI.Reg)&^(0x100000)|value<<20)
}
func (o *AIPS_Type) GetPACRI_TP2() uint32 {
	return (volatile.LoadUint32(&o.PACRI.Reg) & 0x100000) >> 20
}
func (o *AIPS_Type) SetPACRI_WP2(value uint32) {
	volatile.StoreUint32(&o.PACRI.Reg, volatile.LoadUint32(&o.PACRI.Reg)&^(0x200000)|value<<21)
}
func (o *AIPS_Type) GetPACRI_WP2() uint32 {
	return (volatile.LoadUint32(&o.PACRI.Reg) & 0x200000) >> 21
}
func (o *AIPS_Type) SetPACRI_SP2(value uint32) {
	volatile.StoreUint32(&o.PACRI.Reg, volatile.LoadUint32(&o.PACRI.Reg)&^(0x400000)|value<<22)
}
func (o *AIPS_Type) GetPACRI_SP2() uint32 {
	return (volatile.LoadUint32(&o.PACRI.Reg) & 0x400000) >> 22
}
func (o *AIPS_Type) SetPACRI_TP1(value uint32) {
	volatile.StoreUint32(&o.PACRI.Reg, volatile.LoadUint32(&o.PACRI.Reg)&^(0x1000000)|value<<24)
}
func (o *AIPS_Type) GetPACRI_TP1() uint32 {
	return (volatile.LoadUint32(&o.PACRI.Reg) & 0x1000000) >> 24
}
func (o *AIPS_Type) SetPACRI_WP1(value uint32) {
	volatile.StoreUint32(&o.PACRI.Reg, volatile.LoadUint32(&o.PACRI.Reg)&^(0x2000000)|value<<25)
}
func (o *AIPS_Type) GetPACRI_WP1() uint32 {
	return (volatile.LoadUint32(&o.PACRI.Reg) & 0x2000000) >> 25
}
func (o *AIPS_Type) SetPACRI_SP1(value uint32) {
	volatile.StoreUint32(&o.PACRI.Reg, volatile.LoadUint32(&o.PACRI.Reg)&^(0x4000000)|value<<26)
}
func (o *AIPS_Type) GetPACRI_SP1() uint32 {
	return (volatile.LoadUint32(&o.PACRI.Reg) & 0x4000000) >> 26
}
func (o *AIPS_Type) SetPACRI_TP0(value uint32) {
	volatile.StoreUint32(&o.PACRI.Reg, volatile.LoadUint32(&o.PACRI.Reg)&^(0x10000000)|value<<28)
}
func (o *AIPS_Type) GetPACRI_TP0() uint32 {
	return (volatile.LoadUint32(&o.PACRI.Reg) & 0x10000000) >> 28
}
func (o *AIPS_Type) SetPACRI_WP0(value uint32) {
	volatile.StoreUint32(&o.PACRI.Reg, volatile.LoadUint32(&o.PACRI.Reg)&^(0x20000000)|value<<29)
}
func (o *AIPS_Type) GetPACRI_WP0() uint32 {
	return (volatile.LoadUint32(&o.PACRI.Reg) & 0x20000000) >> 29
}
func (o *AIPS_Type) SetPACRI_SP0(value uint32) {
	volatile.StoreUint32(&o.PACRI.Reg, volatile.LoadUint32(&o.PACRI.Reg)&^(0x40000000)|value<<30)
}
func (o *AIPS_Type) GetPACRI_SP0() uint32 {
	return (volatile.LoadUint32(&o.PACRI.Reg) & 0x40000000) >> 30
}

// AIPS.PACRJ: Peripheral Access Control Register
func (o *AIPS_Type) SetPACRJ_TP7(value uint32) {
	volatile.StoreUint32(&o.PACRJ.Reg, volatile.LoadUint32(&o.PACRJ.Reg)&^(0x1)|value)
}
func (o *AIPS_Type) GetPACRJ_TP7() uint32 {
	return volatile.LoadUint32(&o.PACRJ.Reg) & 0x1
}
func (o *AIPS_Type) SetPACRJ_WP7(value uint32) {
	volatile.StoreUint32(&o.PACRJ.Reg, volatile.LoadUint32(&o.PACRJ.Reg)&^(0x2)|value<<1)
}
func (o *AIPS_Type) GetPACRJ_WP7() uint32 {
	return (volatile.LoadUint32(&o.PACRJ.Reg) & 0x2) >> 1
}
func (o *AIPS_Type) SetPACRJ_SP7(value uint32) {
	volatile.StoreUint32(&o.PACRJ.Reg, volatile.LoadUint32(&o.PACRJ.Reg)&^(0x4)|value<<2)
}
func (o *AIPS_Type) GetPACRJ_SP7() uint32 {
	return (volatile.LoadUint32(&o.PACRJ.Reg) & 0x4) >> 2
}
func (o *AIPS_Type) SetPACRJ_TP6(value uint32) {
	volatile.StoreUint32(&o.PACRJ.Reg, volatile.LoadUint32(&o.PACRJ.Reg)&^(0x10)|value<<4)
}
func (o *AIPS_Type) GetPACRJ_TP6() uint32 {
	return (volatile.LoadUint32(&o.PACRJ.Reg) & 0x10) >> 4
}
func (o *AIPS_Type) SetPACRJ_WP6(value uint32) {
	volatile.StoreUint32(&o.PACRJ.Reg, volatile.LoadUint32(&o.PACRJ.Reg)&^(0x20)|value<<5)
}
func (o *AIPS_Type) GetPACRJ_WP6() uint32 {
	return (volatile.LoadUint32(&o.PACRJ.Reg) & 0x20) >> 5
}
func (o *AIPS_Type) SetPACRJ_SP6(value uint32) {
	volatile.StoreUint32(&o.PACRJ.Reg, volatile.LoadUint32(&o.PACRJ.Reg)&^(0x40)|value<<6)
}
func (o *AIPS_Type) GetPACRJ_SP6() uint32 {
	return (volatile.LoadUint32(&o.PACRJ.Reg) & 0x40) >> 6
}
func (o *AIPS_Type) SetPACRJ_TP5(value uint32) {
	volatile.StoreUint32(&o.PACRJ.Reg, volatile.LoadUint32(&o.PACRJ.Reg)&^(0x100)|value<<8)
}
func (o *AIPS_Type) GetPACRJ_TP5() uint32 {
	return (volatile.LoadUint32(&o.PACRJ.Reg) & 0x100) >> 8
}
func (o *AIPS_Type) SetPACRJ_WP5(value uint32) {
	volatile.StoreUint32(&o.PACRJ.Reg, volatile.LoadUint32(&o.PACRJ.Reg)&^(0x200)|value<<9)
}
func (o *AIPS_Type) GetPACRJ_WP5() uint32 {
	return (volatile.LoadUint32(&o.PACRJ.Reg) & 0x200) >> 9
}
func (o *AIPS_Type) SetPACRJ_SP5(value uint32) {
	volatile.StoreUint32(&o.PACRJ.Reg, volatile.LoadUint32(&o.PACRJ.Reg)&^(0x400)|value<<10)
}
func (o *AIPS_Type) GetPACRJ_SP5() uint32 {
	return (volatile.LoadUint32(&o.PACRJ.Reg) & 0x400) >> 10
}
func (o *AIPS_Type) SetPACRJ_TP4(value uint32) {
	volatile.StoreUint32(&o.PACRJ.Reg, volatile.LoadUint32(&o.PACRJ.Reg)&^(0x1000)|value<<12)
}
func (o *AIPS_Type) GetPACRJ_TP4() uint32 {
	return (volatile.LoadUint32(&o.PACRJ.Reg) & 0x1000) >> 12
}
func (o *AIPS_Type) SetPACRJ_WP4(value uint32) {
	volatile.StoreUint32(&o.PACRJ.Reg, volatile.LoadUint32(&o.PACRJ.Reg)&^(0x2000)|value<<13)
}
func (o *AIPS_Type) GetPACRJ_WP4() uint32 {
	return (volatile.LoadUint32(&o.PACRJ.Reg) & 0x2000) >> 13
}
func (o *AIPS_Type) SetPACRJ_SP4(value uint32) {
	volatile.StoreUint32(&o.PACRJ.Reg, volatile.LoadUint32(&o.PACRJ.Reg)&^(0x4000)|value<<14)
}
func (o *AIPS_Type) GetPACRJ_SP4() uint32 {
	return (volatile.LoadUint32(&o.PACRJ.Reg) & 0x4000) >> 14
}
func (o *AIPS_Type) SetPACRJ_TP3(value uint32) {
	volatile.StoreUint32(&o.PACRJ.Reg, volatile.LoadUint32(&o.PACRJ.Reg)&^(0x10000)|value<<16)
}
func (o *AIPS_Type) GetPACRJ_TP3() uint32 {
	return (volatile.LoadUint32(&o.PACRJ.Reg) & 0x10000) >> 16
}
func (o *AIPS_Type) SetPACRJ_WP3(value uint32) {
	volatile.StoreUint32(&o.PACRJ.Reg, volatile.LoadUint32(&o.PACRJ.Reg)&^(0x20000)|value<<17)
}
func (o *AIPS_Type) GetPACRJ_WP3() uint32 {
	return (volatile.LoadUint32(&o.PACRJ.Reg) & 0x20000) >> 17
}
func (o *AIPS_Type) SetPACRJ_SP3(value uint32) {
	volatile.StoreUint32(&o.PACRJ.Reg, volatile.LoadUint32(&o.PACRJ.Reg)&^(0x40000)|value<<18)
}
func (o *AIPS_Type) GetPACRJ_SP3() uint32 {
	return (volatile.LoadUint32(&o.PACRJ.Reg) & 0x40000) >> 18
}
func (o *AIPS_Type) SetPACRJ_TP2(value uint32) {
	volatile.StoreUint32(&o.PACRJ.Reg, volatile.LoadUint32(&o.PACRJ.Reg)&^(0x100000)|value<<20)
}
func (o *AIPS_Type) GetPACRJ_TP2() uint32 {
	return (volatile.LoadUint32(&o.PACRJ.Reg) & 0x100000) >> 20
}
func (o *AIPS_Type) SetPACRJ_WP2(value uint32) {
	volatile.StoreUint32(&o.PACRJ.Reg, volatile.LoadUint32(&o.PACRJ.Reg)&^(0x200000)|value<<21)
}
func (o *AIPS_Type) GetPACRJ_WP2() uint32 {
	return (volatile.LoadUint32(&o.PACRJ.Reg) & 0x200000) >> 21
}
func (o *AIPS_Type) SetPACRJ_SP2(value uint32) {
	volatile.StoreUint32(&o.PACRJ.Reg, volatile.LoadUint32(&o.PACRJ.Reg)&^(0x400000)|value<<22)
}
func (o *AIPS_Type) GetPACRJ_SP2() uint32 {
	return (volatile.LoadUint32(&o.PACRJ.Reg) & 0x400000) >> 22
}
func (o *AIPS_Type) SetPACRJ_TP1(value uint32) {
	volatile.StoreUint32(&o.PACRJ.Reg, volatile.LoadUint32(&o.PACRJ.Reg)&^(0x1000000)|value<<24)
}
func (o *AIPS_Type) GetPACRJ_TP1() uint32 {
	return (volatile.LoadUint32(&o.PACRJ.Reg) & 0x1000000) >> 24
}
func (o *AIPS_Type) SetPACRJ_WP1(value uint32) {
	volatile.StoreUint32(&o.PACRJ.Reg, volatile.LoadUint32(&o.PACRJ.Reg)&^(0x2000000)|value<<25)
}
func (o *AIPS_Type) GetPACRJ_WP1() uint32 {
	return (volatile.LoadUint32(&o.PACRJ.Reg) & 0x2000000) >> 25
}
func (o *AIPS_Type) SetPACRJ_SP1(value uint32) {
	volatile.StoreUint32(&o.PACRJ.Reg, volatile.LoadUint32(&o.PACRJ.Reg)&^(0x4000000)|value<<26)
}
func (o *AIPS_Type) GetPACRJ_SP1() uint32 {
	return (volatile.LoadUint32(&o.PACRJ.Reg) & 0x4000000) >> 26
}
func (o *AIPS_Type) SetPACRJ_TP0(value uint32) {
	volatile.StoreUint32(&o.PACRJ.Reg, volatile.LoadUint32(&o.PACRJ.Reg)&^(0x10000000)|value<<28)
}
func (o *AIPS_Type) GetPACRJ_TP0() uint32 {
	return (volatile.LoadUint32(&o.PACRJ.Reg) & 0x10000000) >> 28
}
func (o *AIPS_Type) SetPACRJ_WP0(value uint32) {
	volatile.StoreUint32(&o.PACRJ.Reg, volatile.LoadUint32(&o.PACRJ.Reg)&^(0x20000000)|value<<29)
}
func (o *AIPS_Type) GetPACRJ_WP0() uint32 {
	return (volatile.LoadUint32(&o.PACRJ.Reg) & 0x20000000) >> 29
}
func (o *AIPS_Type) SetPACRJ_SP0(value uint32) {
	volatile.StoreUint32(&o.PACRJ.Reg, volatile.LoadUint32(&o.PACRJ.Reg)&^(0x40000000)|value<<30)
}
func (o *AIPS_Type) GetPACRJ_SP0() uint32 {
	return (volatile.LoadUint32(&o.PACRJ.Reg) & 0x40000000) >> 30
}

// AIPS.PACRK: Peripheral Access Control Register
func (o *AIPS_Type) SetPACRK_TP7(value uint32) {
	volatile.StoreUint32(&o.PACRK.Reg, volatile.LoadUint32(&o.PACRK.Reg)&^(0x1)|value)
}
func (o *AIPS_Type) GetPACRK_TP7() uint32 {
	return volatile.LoadUint32(&o.PACRK.Reg) & 0x1
}
func (o *AIPS_Type) SetPACRK_WP7(value uint32) {
	volatile.StoreUint32(&o.PACRK.Reg, volatile.LoadUint32(&o.PACRK.Reg)&^(0x2)|value<<1)
}
func (o *AIPS_Type) GetPACRK_WP7() uint32 {
	return (volatile.LoadUint32(&o.PACRK.Reg) & 0x2) >> 1
}
func (o *AIPS_Type) SetPACRK_SP7(value uint32) {
	volatile.StoreUint32(&o.PACRK.Reg, volatile.LoadUint32(&o.PACRK.Reg)&^(0x4)|value<<2)
}
func (o *AIPS_Type) GetPACRK_SP7() uint32 {
	return (volatile.LoadUint32(&o.PACRK.Reg) & 0x4) >> 2
}
func (o *AIPS_Type) SetPACRK_TP6(value uint32) {
	volatile.StoreUint32(&o.PACRK.Reg, volatile.LoadUint32(&o.PACRK.Reg)&^(0x10)|value<<4)
}
func (o *AIPS_Type) GetPACRK_TP6() uint32 {
	return (volatile.LoadUint32(&o.PACRK.Reg) & 0x10) >> 4
}
func (o *AIPS_Type) SetPACRK_WP6(value uint32) {
	volatile.StoreUint32(&o.PACRK.Reg, volatile.LoadUint32(&o.PACRK.Reg)&^(0x20)|value<<5)
}
func (o *AIPS_Type) GetPACRK_WP6() uint32 {
	return (volatile.LoadUint32(&o.PACRK.Reg) & 0x20) >> 5
}
func (o *AIPS_Type) SetPACRK_SP6(value uint32) {
	volatile.StoreUint32(&o.PACRK.Reg, volatile.LoadUint32(&o.PACRK.Reg)&^(0x40)|value<<6)
}
func (o *AIPS_Type) GetPACRK_SP6() uint32 {
	return (volatile.LoadUint32(&o.PACRK.Reg) & 0x40) >> 6
}
func (o *AIPS_Type) SetPACRK_TP5(value uint32) {
	volatile.StoreUint32(&o.PACRK.Reg, volatile.LoadUint32(&o.PACRK.Reg)&^(0x100)|value<<8)
}
func (o *AIPS_Type) GetPACRK_TP5() uint32 {
	return (volatile.LoadUint32(&o.PACRK.Reg) & 0x100) >> 8
}
func (o *AIPS_Type) SetPACRK_WP5(value uint32) {
	volatile.StoreUint32(&o.PACRK.Reg, volatile.LoadUint32(&o.PACRK.Reg)&^(0x200)|value<<9)
}
func (o *AIPS_Type) GetPACRK_WP5() uint32 {
	return (volatile.LoadUint32(&o.PACRK.Reg) & 0x200) >> 9
}
func (o *AIPS_Type) SetPACRK_SP5(value uint32) {
	volatile.StoreUint32(&o.PACRK.Reg, volatile.LoadUint32(&o.PACRK.Reg)&^(0x400)|value<<10)
}
func (o *AIPS_Type) GetPACRK_SP5() uint32 {
	return (volatile.LoadUint32(&o.PACRK.Reg) & 0x400) >> 10
}
func (o *AIPS_Type) SetPACRK_TP4(value uint32) {
	volatile.StoreUint32(&o.PACRK.Reg, volatile.LoadUint32(&o.PACRK.Reg)&^(0x1000)|value<<12)
}
func (o *AIPS_Type) GetPACRK_TP4() uint32 {
	return (volatile.LoadUint32(&o.PACRK.Reg) & 0x1000) >> 12
}
func (o *AIPS_Type) SetPACRK_WP4(value uint32) {
	volatile.StoreUint32(&o.PACRK.Reg, volatile.LoadUint32(&o.PACRK.Reg)&^(0x2000)|value<<13)
}
func (o *AIPS_Type) GetPACRK_WP4() uint32 {
	return (volatile.LoadUint32(&o.PACRK.Reg) & 0x2000) >> 13
}
func (o *AIPS_Type) SetPACRK_SP4(value uint32) {
	volatile.StoreUint32(&o.PACRK.Reg, volatile.LoadUint32(&o.PACRK.Reg)&^(0x4000)|value<<14)
}
func (o *AIPS_Type) GetPACRK_SP4() uint32 {
	return (volatile.LoadUint32(&o.PACRK.Reg) & 0x4000) >> 14
}
func (o *AIPS_Type) SetPACRK_TP3(value uint32) {
	volatile.StoreUint32(&o.PACRK.Reg, volatile.LoadUint32(&o.PACRK.Reg)&^(0x10000)|value<<16)
}
func (o *AIPS_Type) GetPACRK_TP3() uint32 {
	return (volatile.LoadUint32(&o.PACRK.Reg) & 0x10000) >> 16
}
func (o *AIPS_Type) SetPACRK_WP3(value uint32) {
	volatile.StoreUint32(&o.PACRK.Reg, volatile.LoadUint32(&o.PACRK.Reg)&^(0x20000)|value<<17)
}
func (o *AIPS_Type) GetPACRK_WP3() uint32 {
	return (volatile.LoadUint32(&o.PACRK.Reg) & 0x20000) >> 17
}
func (o *AIPS_Type) SetPACRK_SP3(value uint32) {
	volatile.StoreUint32(&o.PACRK.Reg, volatile.LoadUint32(&o.PACRK.Reg)&^(0x40000)|value<<18)
}
func (o *AIPS_Type) GetPACRK_SP3() uint32 {
	return (volatile.LoadUint32(&o.PACRK.Reg) & 0x40000) >> 18
}
func (o *AIPS_Type) SetPACRK_TP2(value uint32) {
	volatile.StoreUint32(&o.PACRK.Reg, volatile.LoadUint32(&o.PACRK.Reg)&^(0x100000)|value<<20)
}
func (o *AIPS_Type) GetPACRK_TP2() uint32 {
	return (volatile.LoadUint32(&o.PACRK.Reg) & 0x100000) >> 20
}
func (o *AIPS_Type) SetPACRK_WP2(value uint32) {
	volatile.StoreUint32(&o.PACRK.Reg, volatile.LoadUint32(&o.PACRK.Reg)&^(0x200000)|value<<21)
}
func (o *AIPS_Type) GetPACRK_WP2() uint32 {
	return (volatile.LoadUint32(&o.PACRK.Reg) & 0x200000) >> 21
}
func (o *AIPS_Type) SetPACRK_SP2(value uint32) {
	volatile.StoreUint32(&o.PACRK.Reg, volatile.LoadUint32(&o.PACRK.Reg)&^(0x400000)|value<<22)
}
func (o *AIPS_Type) GetPACRK_SP2() uint32 {
	return (volatile.LoadUint32(&o.PACRK.Reg) & 0x400000) >> 22
}
func (o *AIPS_Type) SetPACRK_TP1(value uint32) {
	volatile.StoreUint32(&o.PACRK.Reg, volatile.LoadUint32(&o.PACRK.Reg)&^(0x1000000)|value<<24)
}
func (o *AIPS_Type) GetPACRK_TP1() uint32 {
	return (volatile.LoadUint32(&o.PACRK.Reg) & 0x1000000) >> 24
}
func (o *AIPS_Type) SetPACRK_WP1(value uint32) {
	volatile.StoreUint32(&o.PACRK.Reg, volatile.LoadUint32(&o.PACRK.Reg)&^(0x2000000)|value<<25)
}
func (o *AIPS_Type) GetPACRK_WP1() uint32 {
	return (volatile.LoadUint32(&o.PACRK.Reg) & 0x2000000) >> 25
}
func (o *AIPS_Type) SetPACRK_SP1(value uint32) {
	volatile.StoreUint32(&o.PACRK.Reg, volatile.LoadUint32(&o.PACRK.Reg)&^(0x4000000)|value<<26)
}
func (o *AIPS_Type) GetPACRK_SP1() uint32 {
	return (volatile.LoadUint32(&o.PACRK.Reg) & 0x4000000) >> 26
}
func (o *AIPS_Type) SetPACRK_TP0(value uint32) {
	volatile.StoreUint32(&o.PACRK.Reg, volatile.LoadUint32(&o.PACRK.Reg)&^(0x10000000)|value<<28)
}
func (o *AIPS_Type) GetPACRK_TP0() uint32 {
	return (volatile.LoadUint32(&o.PACRK.Reg) & 0x10000000) >> 28
}
func (o *AIPS_Type) SetPACRK_WP0(value uint32) {
	volatile.StoreUint32(&o.PACRK.Reg, volatile.LoadUint32(&o.PACRK.Reg)&^(0x20000000)|value<<29)
}
func (o *AIPS_Type) GetPACRK_WP0() uint32 {
	return (volatile.LoadUint32(&o.PACRK.Reg) & 0x20000000) >> 29
}
func (o *AIPS_Type) SetPACRK_SP0(value uint32) {
	volatile.StoreUint32(&o.PACRK.Reg, volatile.LoadUint32(&o.PACRK.Reg)&^(0x40000000)|value<<30)
}
func (o *AIPS_Type) GetPACRK_SP0() uint32 {
	return (volatile.LoadUint32(&o.PACRK.Reg) & 0x40000000) >> 30
}

// AIPS.PACRL: Peripheral Access Control Register
func (o *AIPS_Type) SetPACRL_TP7(value uint32) {
	volatile.StoreUint32(&o.PACRL.Reg, volatile.LoadUint32(&o.PACRL.Reg)&^(0x1)|value)
}
func (o *AIPS_Type) GetPACRL_TP7() uint32 {
	return volatile.LoadUint32(&o.PACRL.Reg) & 0x1
}
func (o *AIPS_Type) SetPACRL_WP7(value uint32) {
	volatile.StoreUint32(&o.PACRL.Reg, volatile.LoadUint32(&o.PACRL.Reg)&^(0x2)|value<<1)
}
func (o *AIPS_Type) GetPACRL_WP7() uint32 {
	return (volatile.LoadUint32(&o.PACRL.Reg) & 0x2) >> 1
}
func (o *AIPS_Type) SetPACRL_SP7(value uint32) {
	volatile.StoreUint32(&o.PACRL.Reg, volatile.LoadUint32(&o.PACRL.Reg)&^(0x4)|value<<2)
}
func (o *AIPS_Type) GetPACRL_SP7() uint32 {
	return (volatile.LoadUint32(&o.PACRL.Reg) & 0x4) >> 2
}
func (o *AIPS_Type) SetPACRL_TP6(value uint32) {
	volatile.StoreUint32(&o.PACRL.Reg, volatile.LoadUint32(&o.PACRL.Reg)&^(0x10)|value<<4)
}
func (o *AIPS_Type) GetPACRL_TP6() uint32 {
	return (volatile.LoadUint32(&o.PACRL.Reg) & 0x10) >> 4
}
func (o *AIPS_Type) SetPACRL_WP6(value uint32) {
	volatile.StoreUint32(&o.PACRL.Reg, volatile.LoadUint32(&o.PACRL.Reg)&^(0x20)|value<<5)
}
func (o *AIPS_Type) GetPACRL_WP6() uint32 {
	return (volatile.LoadUint32(&o.PACRL.Reg) & 0x20) >> 5
}
func (o *AIPS_Type) SetPACRL_SP6(value uint32) {
	volatile.StoreUint32(&o.PACRL.Reg, volatile.LoadUint32(&o.PACRL.Reg)&^(0x40)|value<<6)
}
func (o *AIPS_Type) GetPACRL_SP6() uint32 {
	return (volatile.LoadUint32(&o.PACRL.Reg) & 0x40) >> 6
}
func (o *AIPS_Type) SetPACRL_TP5(value uint32) {
	volatile.StoreUint32(&o.PACRL.Reg, volatile.LoadUint32(&o.PACRL.Reg)&^(0x100)|value<<8)
}
func (o *AIPS_Type) GetPACRL_TP5() uint32 {
	return (volatile.LoadUint32(&o.PACRL.Reg) & 0x100) >> 8
}
func (o *AIPS_Type) SetPACRL_WP5(value uint32) {
	volatile.StoreUint32(&o.PACRL.Reg, volatile.LoadUint32(&o.PACRL.Reg)&^(0x200)|value<<9)
}
func (o *AIPS_Type) GetPACRL_WP5() uint32 {
	return (volatile.LoadUint32(&o.PACRL.Reg) & 0x200) >> 9
}
func (o *AIPS_Type) SetPACRL_SP5(value uint32) {
	volatile.StoreUint32(&o.PACRL.Reg, volatile.LoadUint32(&o.PACRL.Reg)&^(0x400)|value<<10)
}
func (o *AIPS_Type) GetPACRL_SP5() uint32 {
	return (volatile.LoadUint32(&o.PACRL.Reg) & 0x400) >> 10
}
func (o *AIPS_Type) SetPACRL_TP4(value uint32) {
	volatile.StoreUint32(&o.PACRL.Reg, volatile.LoadUint32(&o.PACRL.Reg)&^(0x1000)|value<<12)
}
func (o *AIPS_Type) GetPACRL_TP4() uint32 {
	return (volatile.LoadUint32(&o.PACRL.Reg) & 0x1000) >> 12
}
func (o *AIPS_Type) SetPACRL_WP4(value uint32) {
	volatile.StoreUint32(&o.PACRL.Reg, volatile.LoadUint32(&o.PACRL.Reg)&^(0x2000)|value<<13)
}
func (o *AIPS_Type) GetPACRL_WP4() uint32 {
	return (volatile.LoadUint32(&o.PACRL.Reg) & 0x2000) >> 13
}
func (o *AIPS_Type) SetPACRL_SP4(value uint32) {
	volatile.StoreUint32(&o.PACRL.Reg, volatile.LoadUint32(&o.PACRL.Reg)&^(0x4000)|value<<14)
}
func (o *AIPS_Type) GetPACRL_SP4() uint32 {
	return (volatile.LoadUint32(&o.PACRL.Reg) & 0x4000) >> 14
}
func (o *AIPS_Type) SetPACRL_TP3(value uint32) {
	volatile.StoreUint32(&o.PACRL.Reg, volatile.LoadUint32(&o.PACRL.Reg)&^(0x10000)|value<<16)
}
func (o *AIPS_Type) GetPACRL_TP3() uint32 {
	return (volatile.LoadUint32(&o.PACRL.Reg) & 0x10000) >> 16
}
func (o *AIPS_Type) SetPACRL_WP3(value uint32) {
	volatile.StoreUint32(&o.PACRL.Reg, volatile.LoadUint32(&o.PACRL.Reg)&^(0x20000)|value<<17)
}
func (o *AIPS_Type) GetPACRL_WP3() uint32 {
	return (volatile.LoadUint32(&o.PACRL.Reg) & 0x20000) >> 17
}
func (o *AIPS_Type) SetPACRL_SP3(value uint32) {
	volatile.StoreUint32(&o.PACRL.Reg, volatile.LoadUint32(&o.PACRL.Reg)&^(0x40000)|value<<18)
}
func (o *AIPS_Type) GetPACRL_SP3() uint32 {
	return (volatile.LoadUint32(&o.PACRL.Reg) & 0x40000) >> 18
}
func (o *AIPS_Type) SetPACRL_TP2(value uint32) {
	volatile.StoreUint32(&o.PACRL.Reg, volatile.LoadUint32(&o.PACRL.Reg)&^(0x100000)|value<<20)
}
func (o *AIPS_Type) GetPACRL_TP2() uint32 {
	return (volatile.LoadUint32(&o.PACRL.Reg) & 0x100000) >> 20
}
func (o *AIPS_Type) SetPACRL_WP2(value uint32) {
	volatile.StoreUint32(&o.PACRL.Reg, volatile.LoadUint32(&o.PACRL.Reg)&^(0x200000)|value<<21)
}
func (o *AIPS_Type) GetPACRL_WP2() uint32 {
	return (volatile.LoadUint32(&o.PACRL.Reg) & 0x200000) >> 21
}
func (o *AIPS_Type) SetPACRL_SP2(value uint32) {
	volatile.StoreUint32(&o.PACRL.Reg, volatile.LoadUint32(&o.PACRL.Reg)&^(0x400000)|value<<22)
}
func (o *AIPS_Type) GetPACRL_SP2() uint32 {
	return (volatile.LoadUint32(&o.PACRL.Reg) & 0x400000) >> 22
}
func (o *AIPS_Type) SetPACRL_TP1(value uint32) {
	volatile.StoreUint32(&o.PACRL.Reg, volatile.LoadUint32(&o.PACRL.Reg)&^(0x1000000)|value<<24)
}
func (o *AIPS_Type) GetPACRL_TP1() uint32 {
	return (volatile.LoadUint32(&o.PACRL.Reg) & 0x1000000) >> 24
}
func (o *AIPS_Type) SetPACRL_WP1(value uint32) {
	volatile.StoreUint32(&o.PACRL.Reg, volatile.LoadUint32(&o.PACRL.Reg)&^(0x2000000)|value<<25)
}
func (o *AIPS_Type) GetPACRL_WP1() uint32 {
	return (volatile.LoadUint32(&o.PACRL.Reg) & 0x2000000) >> 25
}
func (o *AIPS_Type) SetPACRL_SP1(value uint32) {
	volatile.StoreUint32(&o.PACRL.Reg, volatile.LoadUint32(&o.PACRL.Reg)&^(0x4000000)|value<<26)
}
func (o *AIPS_Type) GetPACRL_SP1() uint32 {
	return (volatile.LoadUint32(&o.PACRL.Reg) & 0x4000000) >> 26
}
func (o *AIPS_Type) SetPACRL_TP0(value uint32) {
	volatile.StoreUint32(&o.PACRL.Reg, volatile.LoadUint32(&o.PACRL.Reg)&^(0x10000000)|value<<28)
}
func (o *AIPS_Type) GetPACRL_TP0() uint32 {
	return (volatile.LoadUint32(&o.PACRL.Reg) & 0x10000000) >> 28
}
func (o *AIPS_Type) SetPACRL_WP0(value uint32) {
	volatile.StoreUint32(&o.PACRL.Reg, volatile.LoadUint32(&o.PACRL.Reg)&^(0x20000000)|value<<29)
}
func (o *AIPS_Type) GetPACRL_WP0() uint32 {
	return (volatile.LoadUint32(&o.PACRL.Reg) & 0x20000000) >> 29
}
func (o *AIPS_Type) SetPACRL_SP0(value uint32) {
	volatile.StoreUint32(&o.PACRL.Reg, volatile.LoadUint32(&o.PACRL.Reg)&^(0x40000000)|value<<30)
}
func (o *AIPS_Type) GetPACRL_SP0() uint32 {
	return (volatile.LoadUint32(&o.PACRL.Reg) & 0x40000000) >> 30
}

// AIPS.PACRM: Peripheral Access Control Register
func (o *AIPS_Type) SetPACRM_TP7(value uint32) {
	volatile.StoreUint32(&o.PACRM.Reg, volatile.LoadUint32(&o.PACRM.Reg)&^(0x1)|value)
}
func (o *AIPS_Type) GetPACRM_TP7() uint32 {
	return volatile.LoadUint32(&o.PACRM.Reg) & 0x1
}
func (o *AIPS_Type) SetPACRM_WP7(value uint32) {
	volatile.StoreUint32(&o.PACRM.Reg, volatile.LoadUint32(&o.PACRM.Reg)&^(0x2)|value<<1)
}
func (o *AIPS_Type) GetPACRM_WP7() uint32 {
	return (volatile.LoadUint32(&o.PACRM.Reg) & 0x2) >> 1
}
func (o *AIPS_Type) SetPACRM_SP7(value uint32) {
	volatile.StoreUint32(&o.PACRM.Reg, volatile.LoadUint32(&o.PACRM.Reg)&^(0x4)|value<<2)
}
func (o *AIPS_Type) GetPACRM_SP7() uint32 {
	return (volatile.LoadUint32(&o.PACRM.Reg) & 0x4) >> 2
}
func (o *AIPS_Type) SetPACRM_TP6(value uint32) {
	volatile.StoreUint32(&o.PACRM.Reg, volatile.LoadUint32(&o.PACRM.Reg)&^(0x10)|value<<4)
}
func (o *AIPS_Type) GetPACRM_TP6() uint32 {
	return (volatile.LoadUint32(&o.PACRM.Reg) & 0x10) >> 4
}
func (o *AIPS_Type) SetPACRM_WP6(value uint32) {
	volatile.StoreUint32(&o.PACRM.Reg, volatile.LoadUint32(&o.PACRM.Reg)&^(0x20)|value<<5)
}
func (o *AIPS_Type) GetPACRM_WP6() uint32 {
	return (volatile.LoadUint32(&o.PACRM.Reg) & 0x20) >> 5
}
func (o *AIPS_Type) SetPACRM_SP6(value uint32) {
	volatile.StoreUint32(&o.PACRM.Reg, volatile.LoadUint32(&o.PACRM.Reg)&^(0x40)|value<<6)
}
func (o *AIPS_Type) GetPACRM_SP6() uint32 {
	return (volatile.LoadUint32(&o.PACRM.Reg) & 0x40) >> 6
}
func (o *AIPS_Type) SetPACRM_TP5(value uint32) {
	volatile.StoreUint32(&o.PACRM.Reg, volatile.LoadUint32(&o.PACRM.Reg)&^(0x100)|value<<8)
}
func (o *AIPS_Type) GetPACRM_TP5() uint32 {
	return (volatile.LoadUint32(&o.PACRM.Reg) & 0x100) >> 8
}
func (o *AIPS_Type) SetPACRM_WP5(value uint32) {
	volatile.StoreUint32(&o.PACRM.Reg, volatile.LoadUint32(&o.PACRM.Reg)&^(0x200)|value<<9)
}
func (o *AIPS_Type) GetPACRM_WP5() uint32 {
	return (volatile.LoadUint32(&o.PACRM.Reg) & 0x200) >> 9
}
func (o *AIPS_Type) SetPACRM_SP5(value uint32) {
	volatile.StoreUint32(&o.PACRM.Reg, volatile.LoadUint32(&o.PACRM.Reg)&^(0x400)|value<<10)
}
func (o *AIPS_Type) GetPACRM_SP5() uint32 {
	return (volatile.LoadUint32(&o.PACRM.Reg) & 0x400) >> 10
}
func (o *AIPS_Type) SetPACRM_TP4(value uint32) {
	volatile.StoreUint32(&o.PACRM.Reg, volatile.LoadUint32(&o.PACRM.Reg)&^(0x1000)|value<<12)
}
func (o *AIPS_Type) GetPACRM_TP4() uint32 {
	return (volatile.LoadUint32(&o.PACRM.Reg) & 0x1000) >> 12
}
func (o *AIPS_Type) SetPACRM_WP4(value uint32) {
	volatile.StoreUint32(&o.PACRM.Reg, volatile.LoadUint32(&o.PACRM.Reg)&^(0x2000)|value<<13)
}
func (o *AIPS_Type) GetPACRM_WP4() uint32 {
	return (volatile.LoadUint32(&o.PACRM.Reg) & 0x2000) >> 13
}
func (o *AIPS_Type) SetPACRM_SP4(value uint32) {
	volatile.StoreUint32(&o.PACRM.Reg, volatile.LoadUint32(&o.PACRM.Reg)&^(0x4000)|value<<14)
}
func (o *AIPS_Type) GetPACRM_SP4() uint32 {
	return (volatile.LoadUint32(&o.PACRM.Reg) & 0x4000) >> 14
}
func (o *AIPS_Type) SetPACRM_TP3(value uint32) {
	volatile.StoreUint32(&o.PACRM.Reg, volatile.LoadUint32(&o.PACRM.Reg)&^(0x10000)|value<<16)
}
func (o *AIPS_Type) GetPACRM_TP3() uint32 {
	return (volatile.LoadUint32(&o.PACRM.Reg) & 0x10000) >> 16
}
func (o *AIPS_Type) SetPACRM_WP3(value uint32) {
	volatile.StoreUint32(&o.PACRM.Reg, volatile.LoadUint32(&o.PACRM.Reg)&^(0x20000)|value<<17)
}
func (o *AIPS_Type) GetPACRM_WP3() uint32 {
	return (volatile.LoadUint32(&o.PACRM.Reg) & 0x20000) >> 17
}
func (o *AIPS_Type) SetPACRM_SP3(value uint32) {
	volatile.StoreUint32(&o.PACRM.Reg, volatile.LoadUint32(&o.PACRM.Reg)&^(0x40000)|value<<18)
}
func (o *AIPS_Type) GetPACRM_SP3() uint32 {
	return (volatile.LoadUint32(&o.PACRM.Reg) & 0x40000) >> 18
}
func (o *AIPS_Type) SetPACRM_TP2(value uint32) {
	volatile.StoreUint32(&o.PACRM.Reg, volatile.LoadUint32(&o.PACRM.Reg)&^(0x100000)|value<<20)
}
func (o *AIPS_Type) GetPACRM_TP2() uint32 {
	return (volatile.LoadUint32(&o.PACRM.Reg) & 0x100000) >> 20
}
func (o *AIPS_Type) SetPACRM_WP2(value uint32) {
	volatile.StoreUint32(&o.PACRM.Reg, volatile.LoadUint32(&o.PACRM.Reg)&^(0x200000)|value<<21)
}
func (o *AIPS_Type) GetPACRM_WP2() uint32 {
	return (volatile.LoadUint32(&o.PACRM.Reg) & 0x200000) >> 21
}
func (o *AIPS_Type) SetPACRM_SP2(value uint32) {
	volatile.StoreUint32(&o.PACRM.Reg, volatile.LoadUint32(&o.PACRM.Reg)&^(0x400000)|value<<22)
}
func (o *AIPS_Type) GetPACRM_SP2() uint32 {
	return (volatile.LoadUint32(&o.PACRM.Reg) & 0x400000) >> 22
}
func (o *AIPS_Type) SetPACRM_TP1(value uint32) {
	volatile.StoreUint32(&o.PACRM.Reg, volatile.LoadUint32(&o.PACRM.Reg)&^(0x1000000)|value<<24)
}
func (o *AIPS_Type) GetPACRM_TP1() uint32 {
	return (volatile.LoadUint32(&o.PACRM.Reg) & 0x1000000) >> 24
}
func (o *AIPS_Type) SetPACRM_WP1(value uint32) {
	volatile.StoreUint32(&o.PACRM.Reg, volatile.LoadUint32(&o.PACRM.Reg)&^(0x2000000)|value<<25)
}
func (o *AIPS_Type) GetPACRM_WP1() uint32 {
	return (volatile.LoadUint32(&o.PACRM.Reg) & 0x2000000) >> 25
}
func (o *AIPS_Type) SetPACRM_SP1(value uint32) {
	volatile.StoreUint32(&o.PACRM.Reg, volatile.LoadUint32(&o.PACRM.Reg)&^(0x4000000)|value<<26)
}
func (o *AIPS_Type) GetPACRM_SP1() uint32 {
	return (volatile.LoadUint32(&o.PACRM.Reg) & 0x4000000) >> 26
}
func (o *AIPS_Type) SetPACRM_TP0(value uint32) {
	volatile.StoreUint32(&o.PACRM.Reg, volatile.LoadUint32(&o.PACRM.Reg)&^(0x10000000)|value<<28)
}
func (o *AIPS_Type) GetPACRM_TP0() uint32 {
	return (volatile.LoadUint32(&o.PACRM.Reg) & 0x10000000) >> 28
}
func (o *AIPS_Type) SetPACRM_WP0(value uint32) {
	volatile.StoreUint32(&o.PACRM.Reg, volatile.LoadUint32(&o.PACRM.Reg)&^(0x20000000)|value<<29)
}
func (o *AIPS_Type) GetPACRM_WP0() uint32 {
	return (volatile.LoadUint32(&o.PACRM.Reg) & 0x20000000) >> 29
}
func (o *AIPS_Type) SetPACRM_SP0(value uint32) {
	volatile.StoreUint32(&o.PACRM.Reg, volatile.LoadUint32(&o.PACRM.Reg)&^(0x40000000)|value<<30)
}
func (o *AIPS_Type) GetPACRM_SP0() uint32 {
	return (volatile.LoadUint32(&o.PACRM.Reg) & 0x40000000) >> 30
}

// AIPS.PACRN: Peripheral Access Control Register
func (o *AIPS_Type) SetPACRN_TP7(value uint32) {
	volatile.StoreUint32(&o.PACRN.Reg, volatile.LoadUint32(&o.PACRN.Reg)&^(0x1)|value)
}
func (o *AIPS_Type) GetPACRN_TP7() uint32 {
	return volatile.LoadUint32(&o.PACRN.Reg) & 0x1
}
func (o *AIPS_Type) SetPACRN_WP7(value uint32) {
	volatile.StoreUint32(&o.PACRN.Reg, volatile.LoadUint32(&o.PACRN.Reg)&^(0x2)|value<<1)
}
func (o *AIPS_Type) GetPACRN_WP7() uint32 {
	return (volatile.LoadUint32(&o.PACRN.Reg) & 0x2) >> 1
}
func (o *AIPS_Type) SetPACRN_SP7(value uint32) {
	volatile.StoreUint32(&o.PACRN.Reg, volatile.LoadUint32(&o.PACRN.Reg)&^(0x4)|value<<2)
}
func (o *AIPS_Type) GetPACRN_SP7() uint32 {
	return (volatile.LoadUint32(&o.PACRN.Reg) & 0x4) >> 2
}
func (o *AIPS_Type) SetPACRN_TP6(value uint32) {
	volatile.StoreUint32(&o.PACRN.Reg, volatile.LoadUint32(&o.PACRN.Reg)&^(0x10)|value<<4)
}
func (o *AIPS_Type) GetPACRN_TP6() uint32 {
	return (volatile.LoadUint32(&o.PACRN.Reg) & 0x10) >> 4
}
func (o *AIPS_Type) SetPACRN_WP6(value uint32) {
	volatile.StoreUint32(&o.PACRN.Reg, volatile.LoadUint32(&o.PACRN.Reg)&^(0x20)|value<<5)
}
func (o *AIPS_Type) GetPACRN_WP6() uint32 {
	return (volatile.LoadUint32(&o.PACRN.Reg) & 0x20) >> 5
}
func (o *AIPS_Type) SetPACRN_SP6(value uint32) {
	volatile.StoreUint32(&o.PACRN.Reg, volatile.LoadUint32(&o.PACRN.Reg)&^(0x40)|value<<6)
}
func (o *AIPS_Type) GetPACRN_SP6() uint32 {
	return (volatile.LoadUint32(&o.PACRN.Reg) & 0x40) >> 6
}
func (o *AIPS_Type) SetPACRN_TP5(value uint32) {
	volatile.StoreUint32(&o.PACRN.Reg, volatile.LoadUint32(&o.PACRN.Reg)&^(0x100)|value<<8)
}
func (o *AIPS_Type) GetPACRN_TP5() uint32 {
	return (volatile.LoadUint32(&o.PACRN.Reg) & 0x100) >> 8
}
func (o *AIPS_Type) SetPACRN_WP5(value uint32) {
	volatile.StoreUint32(&o.PACRN.Reg, volatile.LoadUint32(&o.PACRN.Reg)&^(0x200)|value<<9)
}
func (o *AIPS_Type) GetPACRN_WP5() uint32 {
	return (volatile.LoadUint32(&o.PACRN.Reg) & 0x200) >> 9
}
func (o *AIPS_Type) SetPACRN_SP5(value uint32) {
	volatile.StoreUint32(&o.PACRN.Reg, volatile.LoadUint32(&o.PACRN.Reg)&^(0x400)|value<<10)
}
func (o *AIPS_Type) GetPACRN_SP5() uint32 {
	return (volatile.LoadUint32(&o.PACRN.Reg) & 0x400) >> 10
}
func (o *AIPS_Type) SetPACRN_TP4(value uint32) {
	volatile.StoreUint32(&o.PACRN.Reg, volatile.LoadUint32(&o.PACRN.Reg)&^(0x1000)|value<<12)
}
func (o *AIPS_Type) GetPACRN_TP4() uint32 {
	return (volatile.LoadUint32(&o.PACRN.Reg) & 0x1000) >> 12
}
func (o *AIPS_Type) SetPACRN_WP4(value uint32) {
	volatile.StoreUint32(&o.PACRN.Reg, volatile.LoadUint32(&o.PACRN.Reg)&^(0x2000)|value<<13)
}
func (o *AIPS_Type) GetPACRN_WP4() uint32 {
	return (volatile.LoadUint32(&o.PACRN.Reg) & 0x2000) >> 13
}
func (o *AIPS_Type) SetPACRN_SP4(value uint32) {
	volatile.StoreUint32(&o.PACRN.Reg, volatile.LoadUint32(&o.PACRN.Reg)&^(0x4000)|value<<14)
}
func (o *AIPS_Type) GetPACRN_SP4() uint32 {
	return (volatile.LoadUint32(&o.PACRN.Reg) & 0x4000) >> 14
}
func (o *AIPS_Type) SetPACRN_TP3(value uint32) {
	volatile.StoreUint32(&o.PACRN.Reg, volatile.LoadUint32(&o.PACRN.Reg)&^(0x10000)|value<<16)
}
func (o *AIPS_Type) GetPACRN_TP3() uint32 {
	return (volatile.LoadUint32(&o.PACRN.Reg) & 0x10000) >> 16
}
func (o *AIPS_Type) SetPACRN_WP3(value uint32) {
	volatile.StoreUint32(&o.PACRN.Reg, volatile.LoadUint32(&o.PACRN.Reg)&^(0x20000)|value<<17)
}
func (o *AIPS_Type) GetPACRN_WP3() uint32 {
	return (volatile.LoadUint32(&o.PACRN.Reg) & 0x20000) >> 17
}
func (o *AIPS_Type) SetPACRN_SP3(value uint32) {
	volatile.StoreUint32(&o.PACRN.Reg, volatile.LoadUint32(&o.PACRN.Reg)&^(0x40000)|value<<18)
}
func (o *AIPS_Type) GetPACRN_SP3() uint32 {
	return (volatile.LoadUint32(&o.PACRN.Reg) & 0x40000) >> 18
}
func (o *AIPS_Type) SetPACRN_TP2(value uint32) {
	volatile.StoreUint32(&o.PACRN.Reg, volatile.LoadUint32(&o.PACRN.Reg)&^(0x100000)|value<<20)
}
func (o *AIPS_Type) GetPACRN_TP2() uint32 {
	return (volatile.LoadUint32(&o.PACRN.Reg) & 0x100000) >> 20
}
func (o *AIPS_Type) SetPACRN_WP2(value uint32) {
	volatile.StoreUint32(&o.PACRN.Reg, volatile.LoadUint32(&o.PACRN.Reg)&^(0x200000)|value<<21)
}
func (o *AIPS_Type) GetPACRN_WP2() uint32 {
	return (volatile.LoadUint32(&o.PACRN.Reg) & 0x200000) >> 21
}
func (o *AIPS_Type) SetPACRN_SP2(value uint32) {
	volatile.StoreUint32(&o.PACRN.Reg, volatile.LoadUint32(&o.PACRN.Reg)&^(0x400000)|value<<22)
}
func (o *AIPS_Type) GetPACRN_SP2() uint32 {
	return (volatile.LoadUint32(&o.PACRN.Reg) & 0x400000) >> 22
}
func (o *AIPS_Type) SetPACRN_TP1(value uint32) {
	volatile.StoreUint32(&o.PACRN.Reg, volatile.LoadUint32(&o.PACRN.Reg)&^(0x1000000)|value<<24)
}
func (o *AIPS_Type) GetPACRN_TP1() uint32 {
	return (volatile.LoadUint32(&o.PACRN.Reg) & 0x1000000) >> 24
}
func (o *AIPS_Type) SetPACRN_WP1(value uint32) {
	volatile.StoreUint32(&o.PACRN.Reg, volatile.LoadUint32(&o.PACRN.Reg)&^(0x2000000)|value<<25)
}
func (o *AIPS_Type) GetPACRN_WP1() uint32 {
	return (volatile.LoadUint32(&o.PACRN.Reg) & 0x2000000) >> 25
}
func (o *AIPS_Type) SetPACRN_SP1(value uint32) {
	volatile.StoreUint32(&o.PACRN.Reg, volatile.LoadUint32(&o.PACRN.Reg)&^(0x4000000)|value<<26)
}
func (o *AIPS_Type) GetPACRN_SP1() uint32 {
	return (volatile.LoadUint32(&o.PACRN.Reg) & 0x4000000) >> 26
}
func (o *AIPS_Type) SetPACRN_TP0(value uint32) {
	volatile.StoreUint32(&o.PACRN.Reg, volatile.LoadUint32(&o.PACRN.Reg)&^(0x10000000)|value<<28)
}
func (o *AIPS_Type) GetPACRN_TP0() uint32 {
	return (volatile.LoadUint32(&o.PACRN.Reg) & 0x10000000) >> 28
}
func (o *AIPS_Type) SetPACRN_WP0(value uint32) {
	volatile.StoreUint32(&o.PACRN.Reg, volatile.LoadUint32(&o.PACRN.Reg)&^(0x20000000)|value<<29)
}
func (o *AIPS_Type) GetPACRN_WP0() uint32 {
	return (volatile.LoadUint32(&o.PACRN.Reg) & 0x20000000) >> 29
}
func (o *AIPS_Type) SetPACRN_SP0(value uint32) {
	volatile.StoreUint32(&o.PACRN.Reg, volatile.LoadUint32(&o.PACRN.Reg)&^(0x40000000)|value<<30)
}
func (o *AIPS_Type) GetPACRN_SP0() uint32 {
	return (volatile.LoadUint32(&o.PACRN.Reg) & 0x40000000) >> 30
}

// AIPS.PACRO: Peripheral Access Control Register
func (o *AIPS_Type) SetPACRO_TP7(value uint32) {
	volatile.StoreUint32(&o.PACRO.Reg, volatile.LoadUint32(&o.PACRO.Reg)&^(0x1)|value)
}
func (o *AIPS_Type) GetPACRO_TP7() uint32 {
	return volatile.LoadUint32(&o.PACRO.Reg) & 0x1
}
func (o *AIPS_Type) SetPACRO_WP7(value uint32) {
	volatile.StoreUint32(&o.PACRO.Reg, volatile.LoadUint32(&o.PACRO.Reg)&^(0x2)|value<<1)
}
func (o *AIPS_Type) GetPACRO_WP7() uint32 {
	return (volatile.LoadUint32(&o.PACRO.Reg) & 0x2) >> 1
}
func (o *AIPS_Type) SetPACRO_SP7(value uint32) {
	volatile.StoreUint32(&o.PACRO.Reg, volatile.LoadUint32(&o.PACRO.Reg)&^(0x4)|value<<2)
}
func (o *AIPS_Type) GetPACRO_SP7() uint32 {
	return (volatile.LoadUint32(&o.PACRO.Reg) & 0x4) >> 2
}
func (o *AIPS_Type) SetPACRO_TP6(value uint32) {
	volatile.StoreUint32(&o.PACRO.Reg, volatile.LoadUint32(&o.PACRO.Reg)&^(0x10)|value<<4)
}
func (o *AIPS_Type) GetPACRO_TP6() uint32 {
	return (volatile.LoadUint32(&o.PACRO.Reg) & 0x10) >> 4
}
func (o *AIPS_Type) SetPACRO_WP6(value uint32) {
	volatile.StoreUint32(&o.PACRO.Reg, volatile.LoadUint32(&o.PACRO.Reg)&^(0x20)|value<<5)
}
func (o *AIPS_Type) GetPACRO_WP6() uint32 {
	return (volatile.LoadUint32(&o.PACRO.Reg) & 0x20) >> 5
}
func (o *AIPS_Type) SetPACRO_SP6(value uint32) {
	volatile.StoreUint32(&o.PACRO.Reg, volatile.LoadUint32(&o.PACRO.Reg)&^(0x40)|value<<6)
}
func (o *AIPS_Type) GetPACRO_SP6() uint32 {
	return (volatile.LoadUint32(&o.PACRO.Reg) & 0x40) >> 6
}
func (o *AIPS_Type) SetPACRO_TP5(value uint32) {
	volatile.StoreUint32(&o.PACRO.Reg, volatile.LoadUint32(&o.PACRO.Reg)&^(0x100)|value<<8)
}
func (o *AIPS_Type) GetPACRO_TP5() uint32 {
	return (volatile.LoadUint32(&o.PACRO.Reg) & 0x100) >> 8
}
func (o *AIPS_Type) SetPACRO_WP5(value uint32) {
	volatile.StoreUint32(&o.PACRO.Reg, volatile.LoadUint32(&o.PACRO.Reg)&^(0x200)|value<<9)
}
func (o *AIPS_Type) GetPACRO_WP5() uint32 {
	return (volatile.LoadUint32(&o.PACRO.Reg) & 0x200) >> 9
}
func (o *AIPS_Type) SetPACRO_SP5(value uint32) {
	volatile.StoreUint32(&o.PACRO.Reg, volatile.LoadUint32(&o.PACRO.Reg)&^(0x400)|value<<10)
}
func (o *AIPS_Type) GetPACRO_SP5() uint32 {
	return (volatile.LoadUint32(&o.PACRO.Reg) & 0x400) >> 10
}
func (o *AIPS_Type) SetPACRO_TP4(value uint32) {
	volatile.StoreUint32(&o.PACRO.Reg, volatile.LoadUint32(&o.PACRO.Reg)&^(0x1000)|value<<12)
}
func (o *AIPS_Type) GetPACRO_TP4() uint32 {
	return (volatile.LoadUint32(&o.PACRO.Reg) & 0x1000) >> 12
}
func (o *AIPS_Type) SetPACRO_WP4(value uint32) {
	volatile.StoreUint32(&o.PACRO.Reg, volatile.LoadUint32(&o.PACRO.Reg)&^(0x2000)|value<<13)
}
func (o *AIPS_Type) GetPACRO_WP4() uint32 {
	return (volatile.LoadUint32(&o.PACRO.Reg) & 0x2000) >> 13
}
func (o *AIPS_Type) SetPACRO_SP4(value uint32) {
	volatile.StoreUint32(&o.PACRO.Reg, volatile.LoadUint32(&o.PACRO.Reg)&^(0x4000)|value<<14)
}
func (o *AIPS_Type) GetPACRO_SP4() uint32 {
	return (volatile.LoadUint32(&o.PACRO.Reg) & 0x4000) >> 14
}
func (o *AIPS_Type) SetPACRO_TP3(value uint32) {
	volatile.StoreUint32(&o.PACRO.Reg, volatile.LoadUint32(&o.PACRO.Reg)&^(0x10000)|value<<16)
}
func (o *AIPS_Type) GetPACRO_TP3() uint32 {
	return (volatile.LoadUint32(&o.PACRO.Reg) & 0x10000) >> 16
}
func (o *AIPS_Type) SetPACRO_WP3(value uint32) {
	volatile.StoreUint32(&o.PACRO.Reg, volatile.LoadUint32(&o.PACRO.Reg)&^(0x20000)|value<<17)
}
func (o *AIPS_Type) GetPACRO_WP3() uint32 {
	return (volatile.LoadUint32(&o.PACRO.Reg) & 0x20000) >> 17
}
func (o *AIPS_Type) SetPACRO_SP3(value uint32) {
	volatile.StoreUint32(&o.PACRO.Reg, volatile.LoadUint32(&o.PACRO.Reg)&^(0x40000)|value<<18)
}
func (o *AIPS_Type) GetPACRO_SP3() uint32 {
	return (volatile.LoadUint32(&o.PACRO.Reg) & 0x40000) >> 18
}
func (o *AIPS_Type) SetPACRO_TP2(value uint32) {
	volatile.StoreUint32(&o.PACRO.Reg, volatile.LoadUint32(&o.PACRO.Reg)&^(0x100000)|value<<20)
}
func (o *AIPS_Type) GetPACRO_TP2() uint32 {
	return (volatile.LoadUint32(&o.PACRO.Reg) & 0x100000) >> 20
}
func (o *AIPS_Type) SetPACRO_WP2(value uint32) {
	volatile.StoreUint32(&o.PACRO.Reg, volatile.LoadUint32(&o.PACRO.Reg)&^(0x200000)|value<<21)
}
func (o *AIPS_Type) GetPACRO_WP2() uint32 {
	return (volatile.LoadUint32(&o.PACRO.Reg) & 0x200000) >> 21
}
func (o *AIPS_Type) SetPACRO_SP2(value uint32) {
	volatile.StoreUint32(&o.PACRO.Reg, volatile.LoadUint32(&o.PACRO.Reg)&^(0x400000)|value<<22)
}
func (o *AIPS_Type) GetPACRO_SP2() uint32 {
	return (volatile.LoadUint32(&o.PACRO.Reg) & 0x400000) >> 22
}
func (o *AIPS_Type) SetPACRO_TP1(value uint32) {
	volatile.StoreUint32(&o.PACRO.Reg, volatile.LoadUint32(&o.PACRO.Reg)&^(0x1000000)|value<<24)
}
func (o *AIPS_Type) GetPACRO_TP1() uint32 {
	return (volatile.LoadUint32(&o.PACRO.Reg) & 0x1000000) >> 24
}
func (o *AIPS_Type) SetPACRO_WP1(value uint32) {
	volatile.StoreUint32(&o.PACRO.Reg, volatile.LoadUint32(&o.PACRO.Reg)&^(0x2000000)|value<<25)
}
func (o *AIPS_Type) GetPACRO_WP1() uint32 {
	return (volatile.LoadUint32(&o.PACRO.Reg) & 0x2000000) >> 25
}
func (o *AIPS_Type) SetPACRO_SP1(value uint32) {
	volatile.StoreUint32(&o.PACRO.Reg, volatile.LoadUint32(&o.PACRO.Reg)&^(0x4000000)|value<<26)
}
func (o *AIPS_Type) GetPACRO_SP1() uint32 {
	return (volatile.LoadUint32(&o.PACRO.Reg) & 0x4000000) >> 26
}
func (o *AIPS_Type) SetPACRO_TP0(value uint32) {
	volatile.StoreUint32(&o.PACRO.Reg, volatile.LoadUint32(&o.PACRO.Reg)&^(0x10000000)|value<<28)
}
func (o *AIPS_Type) GetPACRO_TP0() uint32 {
	return (volatile.LoadUint32(&o.PACRO.Reg) & 0x10000000) >> 28
}
func (o *AIPS_Type) SetPACRO_WP0(value uint32) {
	volatile.StoreUint32(&o.PACRO.Reg, volatile.LoadUint32(&o.PACRO.Reg)&^(0x20000000)|value<<29)
}
func (o *AIPS_Type) GetPACRO_WP0() uint32 {
	return (volatile.LoadUint32(&o.PACRO.Reg) & 0x20000000) >> 29
}
func (o *AIPS_Type) SetPACRO_SP0(value uint32) {
	volatile.StoreUint32(&o.PACRO.Reg, volatile.LoadUint32(&o.PACRO.Reg)&^(0x40000000)|value<<30)
}
func (o *AIPS_Type) GetPACRO_SP0() uint32 {
	return (volatile.LoadUint32(&o.PACRO.Reg) & 0x40000000) >> 30
}

// AIPS.PACRP: Peripheral Access Control Register
func (o *AIPS_Type) SetPACRP_TP7(value uint32) {
	volatile.StoreUint32(&o.PACRP.Reg, volatile.LoadUint32(&o.PACRP.Reg)&^(0x1)|value)
}
func (o *AIPS_Type) GetPACRP_TP7() uint32 {
	return volatile.LoadUint32(&o.PACRP.Reg) & 0x1
}
func (o *AIPS_Type) SetPACRP_WP7(value uint32) {
	volatile.StoreUint32(&o.PACRP.Reg, volatile.LoadUint32(&o.PACRP.Reg)&^(0x2)|value<<1)
}
func (o *AIPS_Type) GetPACRP_WP7() uint32 {
	return (volatile.LoadUint32(&o.PACRP.Reg) & 0x2) >> 1
}
func (o *AIPS_Type) SetPACRP_SP7(value uint32) {
	volatile.StoreUint32(&o.PACRP.Reg, volatile.LoadUint32(&o.PACRP.Reg)&^(0x4)|value<<2)
}
func (o *AIPS_Type) GetPACRP_SP7() uint32 {
	return (volatile.LoadUint32(&o.PACRP.Reg) & 0x4) >> 2
}
func (o *AIPS_Type) SetPACRP_TP6(value uint32) {
	volatile.StoreUint32(&o.PACRP.Reg, volatile.LoadUint32(&o.PACRP.Reg)&^(0x10)|value<<4)
}
func (o *AIPS_Type) GetPACRP_TP6() uint32 {
	return (volatile.LoadUint32(&o.PACRP.Reg) & 0x10) >> 4
}
func (o *AIPS_Type) SetPACRP_WP6(value uint32) {
	volatile.StoreUint32(&o.PACRP.Reg, volatile.LoadUint32(&o.PACRP.Reg)&^(0x20)|value<<5)
}
func (o *AIPS_Type) GetPACRP_WP6() uint32 {
	return (volatile.LoadUint32(&o.PACRP.Reg) & 0x20) >> 5
}
func (o *AIPS_Type) SetPACRP_SP6(value uint32) {
	volatile.StoreUint32(&o.PACRP.Reg, volatile.LoadUint32(&o.PACRP.Reg)&^(0x40)|value<<6)
}
func (o *AIPS_Type) GetPACRP_SP6() uint32 {
	return (volatile.LoadUint32(&o.PACRP.Reg) & 0x40) >> 6
}
func (o *AIPS_Type) SetPACRP_TP5(value uint32) {
	volatile.StoreUint32(&o.PACRP.Reg, volatile.LoadUint32(&o.PACRP.Reg)&^(0x100)|value<<8)
}
func (o *AIPS_Type) GetPACRP_TP5() uint32 {
	return (volatile.LoadUint32(&o.PACRP.Reg) & 0x100) >> 8
}
func (o *AIPS_Type) SetPACRP_WP5(value uint32) {
	volatile.StoreUint32(&o.PACRP.Reg, volatile.LoadUint32(&o.PACRP.Reg)&^(0x200)|value<<9)
}
func (o *AIPS_Type) GetPACRP_WP5() uint32 {
	return (volatile.LoadUint32(&o.PACRP.Reg) & 0x200) >> 9
}
func (o *AIPS_Type) SetPACRP_SP5(value uint32) {
	volatile.StoreUint32(&o.PACRP.Reg, volatile.LoadUint32(&o.PACRP.Reg)&^(0x400)|value<<10)
}
func (o *AIPS_Type) GetPACRP_SP5() uint32 {
	return (volatile.LoadUint32(&o.PACRP.Reg) & 0x400) >> 10
}
func (o *AIPS_Type) SetPACRP_TP4(value uint32) {
	volatile.StoreUint32(&o.PACRP.Reg, volatile.LoadUint32(&o.PACRP.Reg)&^(0x1000)|value<<12)
}
func (o *AIPS_Type) GetPACRP_TP4() uint32 {
	return (volatile.LoadUint32(&o.PACRP.Reg) & 0x1000) >> 12
}
func (o *AIPS_Type) SetPACRP_WP4(value uint32) {
	volatile.StoreUint32(&o.PACRP.Reg, volatile.LoadUint32(&o.PACRP.Reg)&^(0x2000)|value<<13)
}
func (o *AIPS_Type) GetPACRP_WP4() uint32 {
	return (volatile.LoadUint32(&o.PACRP.Reg) & 0x2000) >> 13
}
func (o *AIPS_Type) SetPACRP_SP4(value uint32) {
	volatile.StoreUint32(&o.PACRP.Reg, volatile.LoadUint32(&o.PACRP.Reg)&^(0x4000)|value<<14)
}
func (o *AIPS_Type) GetPACRP_SP4() uint32 {
	return (volatile.LoadUint32(&o.PACRP.Reg) & 0x4000) >> 14
}
func (o *AIPS_Type) SetPACRP_TP3(value uint32) {
	volatile.StoreUint32(&o.PACRP.Reg, volatile.LoadUint32(&o.PACRP.Reg)&^(0x10000)|value<<16)
}
func (o *AIPS_Type) GetPACRP_TP3() uint32 {
	return (volatile.LoadUint32(&o.PACRP.Reg) & 0x10000) >> 16
}
func (o *AIPS_Type) SetPACRP_WP3(value uint32) {
	volatile.StoreUint32(&o.PACRP.Reg, volatile.LoadUint32(&o.PACRP.Reg)&^(0x20000)|value<<17)
}
func (o *AIPS_Type) GetPACRP_WP3() uint32 {
	return (volatile.LoadUint32(&o.PACRP.Reg) & 0x20000) >> 17
}
func (o *AIPS_Type) SetPACRP_SP3(value uint32) {
	volatile.StoreUint32(&o.PACRP.Reg, volatile.LoadUint32(&o.PACRP.Reg)&^(0x40000)|value<<18)
}
func (o *AIPS_Type) GetPACRP_SP3() uint32 {
	return (volatile.LoadUint32(&o.PACRP.Reg) & 0x40000) >> 18
}
func (o *AIPS_Type) SetPACRP_TP2(value uint32) {
	volatile.StoreUint32(&o.PACRP.Reg, volatile.LoadUint32(&o.PACRP.Reg)&^(0x100000)|value<<20)
}
func (o *AIPS_Type) GetPACRP_TP2() uint32 {
	return (volatile.LoadUint32(&o.PACRP.Reg) & 0x100000) >> 20
}
func (o *AIPS_Type) SetPACRP_WP2(value uint32) {
	volatile.StoreUint32(&o.PACRP.Reg, volatile.LoadUint32(&o.PACRP.Reg)&^(0x200000)|value<<21)
}
func (o *AIPS_Type) GetPACRP_WP2() uint32 {
	return (volatile.LoadUint32(&o.PACRP.Reg) & 0x200000) >> 21
}
func (o *AIPS_Type) SetPACRP_SP2(value uint32) {
	volatile.StoreUint32(&o.PACRP.Reg, volatile.LoadUint32(&o.PACRP.Reg)&^(0x400000)|value<<22)
}
func (o *AIPS_Type) GetPACRP_SP2() uint32 {
	return (volatile.LoadUint32(&o.PACRP.Reg) & 0x400000) >> 22
}
func (o *AIPS_Type) SetPACRP_TP1(value uint32) {
	volatile.StoreUint32(&o.PACRP.Reg, volatile.LoadUint32(&o.PACRP.Reg)&^(0x1000000)|value<<24)
}
func (o *AIPS_Type) GetPACRP_TP1() uint32 {
	return (volatile.LoadUint32(&o.PACRP.Reg) & 0x1000000) >> 24
}
func (o *AIPS_Type) SetPACRP_WP1(value uint32) {
	volatile.StoreUint32(&o.PACRP.Reg, volatile.LoadUint32(&o.PACRP.Reg)&^(0x2000000)|value<<25)
}
func (o *AIPS_Type) GetPACRP_WP1() uint32 {
	return (volatile.LoadUint32(&o.PACRP.Reg) & 0x2000000) >> 25
}
func (o *AIPS_Type) SetPACRP_SP1(value uint32) {
	volatile.StoreUint32(&o.PACRP.Reg, volatile.LoadUint32(&o.PACRP.Reg)&^(0x4000000)|value<<26)
}
func (o *AIPS_Type) GetPACRP_SP1() uint32 {
	return (volatile.LoadUint32(&o.PACRP.Reg) & 0x4000000) >> 26
}
func (o *AIPS_Type) SetPACRP_TP0(value uint32) {
	volatile.StoreUint32(&o.PACRP.Reg, volatile.LoadUint32(&o.PACRP.Reg)&^(0x10000000)|value<<28)
}
func (o *AIPS_Type) GetPACRP_TP0() uint32 {
	return (volatile.LoadUint32(&o.PACRP.Reg) & 0x10000000) >> 28
}
func (o *AIPS_Type) SetPACRP_WP0(value uint32) {
	volatile.StoreUint32(&o.PACRP.Reg, volatile.LoadUint32(&o.PACRP.Reg)&^(0x20000000)|value<<29)
}
func (o *AIPS_Type) GetPACRP_WP0() uint32 {
	return (volatile.LoadUint32(&o.PACRP.Reg) & 0x20000000) >> 29
}
func (o *AIPS_Type) SetPACRP_SP0(value uint32) {
	volatile.StoreUint32(&o.PACRP.Reg, volatile.LoadUint32(&o.PACRP.Reg)&^(0x40000000)|value<<30)
}
func (o *AIPS_Type) GetPACRP_SP0() uint32 {
	return (volatile.LoadUint32(&o.PACRP.Reg) & 0x40000000) >> 30
}

// AIPS.PACRU: Peripheral Access Control Register
func (o *AIPS_Type) SetPACRU_TP1(value uint32) {
	volatile.StoreUint32(&o.PACRU.Reg, volatile.LoadUint32(&o.PACRU.Reg)&^(0x1000000)|value<<24)
}
func (o *AIPS_Type) GetPACRU_TP1() uint32 {
	return (volatile.LoadUint32(&o.PACRU.Reg) & 0x1000000) >> 24
}
func (o *AIPS_Type) SetPACRU_WP1(value uint32) {
	volatile.StoreUint32(&o.PACRU.Reg, volatile.LoadUint32(&o.PACRU.Reg)&^(0x2000000)|value<<25)
}
func (o *AIPS_Type) GetPACRU_WP1() uint32 {
	return (volatile.LoadUint32(&o.PACRU.Reg) & 0x2000000) >> 25
}
func (o *AIPS_Type) SetPACRU_SP1(value uint32) {
	volatile.StoreUint32(&o.PACRU.Reg, volatile.LoadUint32(&o.PACRU.Reg)&^(0x4000000)|value<<26)
}
func (o *AIPS_Type) GetPACRU_SP1() uint32 {
	return (volatile.LoadUint32(&o.PACRU.Reg) & 0x4000000) >> 26
}
func (o *AIPS_Type) SetPACRU_TP0(value uint32) {
	volatile.StoreUint32(&o.PACRU.Reg, volatile.LoadUint32(&o.PACRU.Reg)&^(0x10000000)|value<<28)
}
func (o *AIPS_Type) GetPACRU_TP0() uint32 {
	return (volatile.LoadUint32(&o.PACRU.Reg) & 0x10000000) >> 28
}
func (o *AIPS_Type) SetPACRU_WP0(value uint32) {
	volatile.StoreUint32(&o.PACRU.Reg, volatile.LoadUint32(&o.PACRU.Reg)&^(0x20000000)|value<<29)
}
func (o *AIPS_Type) GetPACRU_WP0() uint32 {
	return (volatile.LoadUint32(&o.PACRU.Reg) & 0x20000000) >> 29
}
func (o *AIPS_Type) SetPACRU_SP0(value uint32) {
	volatile.StoreUint32(&o.PACRU.Reg, volatile.LoadUint32(&o.PACRU.Reg)&^(0x40000000)|value<<30)
}
func (o *AIPS_Type) GetPACRU_SP0() uint32 {
	return (volatile.LoadUint32(&o.PACRU.Reg) & 0x40000000) >> 30
}

// Crossbar switch
type AXBS_Type struct {
	PRS0   volatile.Register32 // 0x0
	_      [12]byte
	CRS0   volatile.Register32 // 0x10
	_      [236]byte
	PRS1   volatile.Register32 // 0x100
	_      [12]byte
	CRS1   volatile.Register32 // 0x110
	_      [236]byte
	PRS2   volatile.Register32 // 0x200
	_      [12]byte
	CRS2   volatile.Register32 // 0x210
	_      [236]byte
	PRS3   volatile.Register32 // 0x300
	_      [12]byte
	CRS3   volatile.Register32 // 0x310
	_      [236]byte
	PRS4   volatile.Register32 // 0x400
	_      [12]byte
	CRS4   volatile.Register32 // 0x410
	_      [1004]byte
	MGPCR0 volatile.Register32 // 0x800
	_      [252]byte
	MGPCR1 volatile.Register32 // 0x900
	_      [252]byte
	MGPCR2 volatile.Register32 // 0xA00
	_      [252]byte
	MGPCR3 volatile.Register32 // 0xB00
	_      [252]byte
	MGPCR4 volatile.Register32 // 0xC00
	_      [252]byte
	MGPCR5 volatile.Register32 // 0xD00
}

// AXBS.PRS0: Priority Registers Slave
func (o *AXBS_Type) SetPRS0_M0(value uint32) {
	volatile.StoreUint32(&o.PRS0.Reg, volatile.LoadUint32(&o.PRS0.Reg)&^(0x7)|value)
}
func (o *AXBS_Type) GetPRS0_M0() uint32 {
	return volatile.LoadUint32(&o.PRS0.Reg) & 0x7
}
func (o *AXBS_Type) SetPRS0_M1(value uint32) {
	volatile.StoreUint32(&o.PRS0.Reg, volatile.LoadUint32(&o.PRS0.Reg)&^(0x70)|value<<4)
}
func (o *AXBS_Type) GetPRS0_M1() uint32 {
	return (volatile.LoadUint32(&o.PRS0.Reg) & 0x70) >> 4
}
func (o *AXBS_Type) SetPRS0_M2(value uint32) {
	volatile.StoreUint32(&o.PRS0.Reg, volatile.LoadUint32(&o.PRS0.Reg)&^(0x700)|value<<8)
}
func (o *AXBS_Type) GetPRS0_M2() uint32 {
	return (volatile.LoadUint32(&o.PRS0.Reg) & 0x700) >> 8
}
func (o *AXBS_Type) SetPRS0_M3(value uint32) {
	volatile.StoreUint32(&o.PRS0.Reg, volatile.LoadUint32(&o.PRS0.Reg)&^(0x7000)|value<<12)
}
func (o *AXBS_Type) GetPRS0_M3() uint32 {
	return (volatile.LoadUint32(&o.PRS0.Reg) & 0x7000) >> 12
}
func (o *AXBS_Type) SetPRS0_M4(value uint32) {
	volatile.StoreUint32(&o.PRS0.Reg, volatile.LoadUint32(&o.PRS0.Reg)&^(0x70000)|value<<16)
}
func (o *AXBS_Type) GetPRS0_M4() uint32 {
	return (volatile.LoadUint32(&o.PRS0.Reg) & 0x70000) >> 16
}
func (o *AXBS_Type) SetPRS0_M5(value uint32) {
	volatile.StoreUint32(&o.PRS0.Reg, volatile.LoadUint32(&o.PRS0.Reg)&^(0x700000)|value<<20)
}
func (o *AXBS_Type) GetPRS0_M5() uint32 {
	return (volatile.LoadUint32(&o.PRS0.Reg) & 0x700000) >> 20
}

// AXBS.CRS0: Control Register
func (o *AXBS_Type) SetCRS0_PARK(value uint32) {
	volatile.StoreUint32(&o.CRS0.Reg, volatile.LoadUint32(&o.CRS0.Reg)&^(0x7)|value)
}
func (o *AXBS_Type) GetCRS0_PARK() uint32 {
	return volatile.LoadUint32(&o.CRS0.Reg) & 0x7
}
func (o *AXBS_Type) SetCRS0_PCTL(value uint32) {
	volatile.StoreUint32(&o.CRS0.Reg, volatile.LoadUint32(&o.CRS0.Reg)&^(0x30)|value<<4)
}
func (o *AXBS_Type) GetCRS0_PCTL() uint32 {
	return (volatile.LoadUint32(&o.CRS0.Reg) & 0x30) >> 4
}
func (o *AXBS_Type) SetCRS0_ARB(value uint32) {
	volatile.StoreUint32(&o.CRS0.Reg, volatile.LoadUint32(&o.CRS0.Reg)&^(0x300)|value<<8)
}
func (o *AXBS_Type) GetCRS0_ARB() uint32 {
	return (volatile.LoadUint32(&o.CRS0.Reg) & 0x300) >> 8
}
func (o *AXBS_Type) SetCRS0_HLP(value uint32) {
	volatile.StoreUint32(&o.CRS0.Reg, volatile.LoadUint32(&o.CRS0.Reg)&^(0x40000000)|value<<30)
}
func (o *AXBS_Type) GetCRS0_HLP() uint32 {
	return (volatile.LoadUint32(&o.CRS0.Reg) & 0x40000000) >> 30
}
func (o *AXBS_Type) SetCRS0_RO(value uint32) {
	volatile.StoreUint32(&o.CRS0.Reg, volatile.LoadUint32(&o.CRS0.Reg)&^(0x80000000)|value<<31)
}
func (o *AXBS_Type) GetCRS0_RO() uint32 {
	return (volatile.LoadUint32(&o.CRS0.Reg) & 0x80000000) >> 31
}

// AXBS.PRS1: Priority Registers Slave
func (o *AXBS_Type) SetPRS1_M0(value uint32) {
	volatile.StoreUint32(&o.PRS1.Reg, volatile.LoadUint32(&o.PRS1.Reg)&^(0x7)|value)
}
func (o *AXBS_Type) GetPRS1_M0() uint32 {
	return volatile.LoadUint32(&o.PRS1.Reg) & 0x7
}
func (o *AXBS_Type) SetPRS1_M1(value uint32) {
	volatile.StoreUint32(&o.PRS1.Reg, volatile.LoadUint32(&o.PRS1.Reg)&^(0x70)|value<<4)
}
func (o *AXBS_Type) GetPRS1_M1() uint32 {
	return (volatile.LoadUint32(&o.PRS1.Reg) & 0x70) >> 4
}
func (o *AXBS_Type) SetPRS1_M2(value uint32) {
	volatile.StoreUint32(&o.PRS1.Reg, volatile.LoadUint32(&o.PRS1.Reg)&^(0x700)|value<<8)
}
func (o *AXBS_Type) GetPRS1_M2() uint32 {
	return (volatile.LoadUint32(&o.PRS1.Reg) & 0x700) >> 8
}
func (o *AXBS_Type) SetPRS1_M3(value uint32) {
	volatile.StoreUint32(&o.PRS1.Reg, volatile.LoadUint32(&o.PRS1.Reg)&^(0x7000)|value<<12)
}
func (o *AXBS_Type) GetPRS1_M3() uint32 {
	return (volatile.LoadUint32(&o.PRS1.Reg) & 0x7000) >> 12
}
func (o *AXBS_Type) SetPRS1_M4(value uint32) {
	volatile.StoreUint32(&o.PRS1.Reg, volatile.LoadUint32(&o.PRS1.Reg)&^(0x70000)|value<<16)
}
func (o *AXBS_Type) GetPRS1_M4() uint32 {
	return (volatile.LoadUint32(&o.PRS1.Reg) & 0x70000) >> 16
}
func (o *AXBS_Type) SetPRS1_M5(value uint32) {
	volatile.StoreUint32(&o.PRS1.Reg, volatile.LoadUint32(&o.PRS1.Reg)&^(0x700000)|value<<20)
}
func (o *AXBS_Type) GetPRS1_M5() uint32 {
	return (volatile.LoadUint32(&o.PRS1.Reg) & 0x700000) >> 20
}

// AXBS.CRS1: Control Register
func (o *AXBS_Type) SetCRS1_PARK(value uint32) {
	volatile.StoreUint32(&o.CRS1.Reg, volatile.LoadUint32(&o.CRS1.Reg)&^(0x7)|value)
}
func (o *AXBS_Type) GetCRS1_PARK() uint32 {
	return volatile.LoadUint32(&o.CRS1.Reg) & 0x7
}
func (o *AXBS_Type) SetCRS1_PCTL(value uint32) {
	volatile.StoreUint32(&o.CRS1.Reg, volatile.LoadUint32(&o.CRS1.Reg)&^(0x30)|value<<4)
}
func (o *AXBS_Type) GetCRS1_PCTL() uint32 {
	return (volatile.LoadUint32(&o.CRS1.Reg) & 0x30) >> 4
}
func (o *AXBS_Type) SetCRS1_ARB(value uint32) {
	volatile.StoreUint32(&o.CRS1.Reg, volatile.LoadUint32(&o.CRS1.Reg)&^(0x300)|value<<8)
}
func (o *AXBS_Type) GetCRS1_ARB() uint32 {
	return (volatile.LoadUint32(&o.CRS1.Reg) & 0x300) >> 8
}
func (o *AXBS_Type) SetCRS1_HLP(value uint32) {
	volatile.StoreUint32(&o.CRS1.Reg, volatile.LoadUint32(&o.CRS1.Reg)&^(0x40000000)|value<<30)
}
func (o *AXBS_Type) GetCRS1_HLP() uint32 {
	return (volatile.LoadUint32(&o.CRS1.Reg) & 0x40000000) >> 30
}
func (o *AXBS_Type) SetCRS1_RO(value uint32) {
	volatile.StoreUint32(&o.CRS1.Reg, volatile.LoadUint32(&o.CRS1.Reg)&^(0x80000000)|value<<31)
}
func (o *AXBS_Type) GetCRS1_RO() uint32 {
	return (volatile.LoadUint32(&o.CRS1.Reg) & 0x80000000) >> 31
}

// AXBS.PRS2: Priority Registers Slave
func (o *AXBS_Type) SetPRS2_M0(value uint32) {
	volatile.StoreUint32(&o.PRS2.Reg, volatile.LoadUint32(&o.PRS2.Reg)&^(0x7)|value)
}
func (o *AXBS_Type) GetPRS2_M0() uint32 {
	return volatile.LoadUint32(&o.PRS2.Reg) & 0x7
}
func (o *AXBS_Type) SetPRS2_M1(value uint32) {
	volatile.StoreUint32(&o.PRS2.Reg, volatile.LoadUint32(&o.PRS2.Reg)&^(0x70)|value<<4)
}
func (o *AXBS_Type) GetPRS2_M1() uint32 {
	return (volatile.LoadUint32(&o.PRS2.Reg) & 0x70) >> 4
}
func (o *AXBS_Type) SetPRS2_M2(value uint32) {
	volatile.StoreUint32(&o.PRS2.Reg, volatile.LoadUint32(&o.PRS2.Reg)&^(0x700)|value<<8)
}
func (o *AXBS_Type) GetPRS2_M2() uint32 {
	return (volatile.LoadUint32(&o.PRS2.Reg) & 0x700) >> 8
}
func (o *AXBS_Type) SetPRS2_M3(value uint32) {
	volatile.StoreUint32(&o.PRS2.Reg, volatile.LoadUint32(&o.PRS2.Reg)&^(0x7000)|value<<12)
}
func (o *AXBS_Type) GetPRS2_M3() uint32 {
	return (volatile.LoadUint32(&o.PRS2.Reg) & 0x7000) >> 12
}
func (o *AXBS_Type) SetPRS2_M4(value uint32) {
	volatile.StoreUint32(&o.PRS2.Reg, volatile.LoadUint32(&o.PRS2.Reg)&^(0x70000)|value<<16)
}
func (o *AXBS_Type) GetPRS2_M4() uint32 {
	return (volatile.LoadUint32(&o.PRS2.Reg) & 0x70000) >> 16
}
func (o *AXBS_Type) SetPRS2_M5(value uint32) {
	volatile.StoreUint32(&o.PRS2.Reg, volatile.LoadUint32(&o.PRS2.Reg)&^(0x700000)|value<<20)
}
func (o *AXBS_Type) GetPRS2_M5() uint32 {
	return (volatile.LoadUint32(&o.PRS2.Reg) & 0x700000) >> 20
}

// AXBS.CRS2: Control Register
func (o *AXBS_Type) SetCRS2_PARK(value uint32) {
	volatile.StoreUint32(&o.CRS2.Reg, volatile.LoadUint32(&o.CRS2.Reg)&^(0x7)|value)
}
func (o *AXBS_Type) GetCRS2_PARK() uint32 {
	return volatile.LoadUint32(&o.CRS2.Reg) & 0x7
}
func (o *AXBS_Type) SetCRS2_PCTL(value uint32) {
	volatile.StoreUint32(&o.CRS2.Reg, volatile.LoadUint32(&o.CRS2.Reg)&^(0x30)|value<<4)
}
func (o *AXBS_Type) GetCRS2_PCTL() uint32 {
	return (volatile.LoadUint32(&o.CRS2.Reg) & 0x30) >> 4
}
func (o *AXBS_Type) SetCRS2_ARB(value uint32) {
	volatile.StoreUint32(&o.CRS2.Reg, volatile.LoadUint32(&o.CRS2.Reg)&^(0x300)|value<<8)
}
func (o *AXBS_Type) GetCRS2_ARB() uint32 {
	return (volatile.LoadUint32(&o.CRS2.Reg) & 0x300) >> 8
}
func (o *AXBS_Type) SetCRS2_HLP(value uint32) {
	volatile.StoreUint32(&o.CRS2.Reg, volatile.LoadUint32(&o.CRS2.Reg)&^(0x40000000)|value<<30)
}
func (o *AXBS_Type) GetCRS2_HLP() uint32 {
	return (volatile.LoadUint32(&o.CRS2.Reg) & 0x40000000) >> 30
}
func (o *AXBS_Type) SetCRS2_RO(value uint32) {
	volatile.StoreUint32(&o.CRS2.Reg, volatile.LoadUint32(&o.CRS2.Reg)&^(0x80000000)|value<<31)
}
func (o *AXBS_Type) GetCRS2_RO() uint32 {
	return (volatile.LoadUint32(&o.CRS2.Reg) & 0x80000000) >> 31
}

// AXBS.PRS3: Priority Registers Slave
func (o *AXBS_Type) SetPRS3_M0(value uint32) {
	volatile.StoreUint32(&o.PRS3.Reg, volatile.LoadUint32(&o.PRS3.Reg)&^(0x7)|value)
}
func (o *AXBS_Type) GetPRS3_M0() uint32 {
	return volatile.LoadUint32(&o.PRS3.Reg) & 0x7
}
func (o *AXBS_Type) SetPRS3_M1(value uint32) {
	volatile.StoreUint32(&o.PRS3.Reg, volatile.LoadUint32(&o.PRS3.Reg)&^(0x70)|value<<4)
}
func (o *AXBS_Type) GetPRS3_M1() uint32 {
	return (volatile.LoadUint32(&o.PRS3.Reg) & 0x70) >> 4
}
func (o *AXBS_Type) SetPRS3_M2(value uint32) {
	volatile.StoreUint32(&o.PRS3.Reg, volatile.LoadUint32(&o.PRS3.Reg)&^(0x700)|value<<8)
}
func (o *AXBS_Type) GetPRS3_M2() uint32 {
	return (volatile.LoadUint32(&o.PRS3.Reg) & 0x700) >> 8
}
func (o *AXBS_Type) SetPRS3_M3(value uint32) {
	volatile.StoreUint32(&o.PRS3.Reg, volatile.LoadUint32(&o.PRS3.Reg)&^(0x7000)|value<<12)
}
func (o *AXBS_Type) GetPRS3_M3() uint32 {
	return (volatile.LoadUint32(&o.PRS3.Reg) & 0x7000) >> 12
}
func (o *AXBS_Type) SetPRS3_M4(value uint32) {
	volatile.StoreUint32(&o.PRS3.Reg, volatile.LoadUint32(&o.PRS3.Reg)&^(0x70000)|value<<16)
}
func (o *AXBS_Type) GetPRS3_M4() uint32 {
	return (volatile.LoadUint32(&o.PRS3.Reg) & 0x70000) >> 16
}
func (o *AXBS_Type) SetPRS3_M5(value uint32) {
	volatile.StoreUint32(&o.PRS3.Reg, volatile.LoadUint32(&o.PRS3.Reg)&^(0x700000)|value<<20)
}
func (o *AXBS_Type) GetPRS3_M5() uint32 {
	return (volatile.LoadUint32(&o.PRS3.Reg) & 0x700000) >> 20
}

// AXBS.CRS3: Control Register
func (o *AXBS_Type) SetCRS3_PARK(value uint32) {
	volatile.StoreUint32(&o.CRS3.Reg, volatile.LoadUint32(&o.CRS3.Reg)&^(0x7)|value)
}
func (o *AXBS_Type) GetCRS3_PARK() uint32 {
	return volatile.LoadUint32(&o.CRS3.Reg) & 0x7
}
func (o *AXBS_Type) SetCRS3_PCTL(value uint32) {
	volatile.StoreUint32(&o.CRS3.Reg, volatile.LoadUint32(&o.CRS3.Reg)&^(0x30)|value<<4)
}
func (o *AXBS_Type) GetCRS3_PCTL() uint32 {
	return (volatile.LoadUint32(&o.CRS3.Reg) & 0x30) >> 4
}
func (o *AXBS_Type) SetCRS3_ARB(value uint32) {
	volatile.StoreUint32(&o.CRS3.Reg, volatile.LoadUint32(&o.CRS3.Reg)&^(0x300)|value<<8)
}
func (o *AXBS_Type) GetCRS3_ARB() uint32 {
	return (volatile.LoadUint32(&o.CRS3.Reg) & 0x300) >> 8
}
func (o *AXBS_Type) SetCRS3_HLP(value uint32) {
	volatile.StoreUint32(&o.CRS3.Reg, volatile.LoadUint32(&o.CRS3.Reg)&^(0x40000000)|value<<30)
}
func (o *AXBS_Type) GetCRS3_HLP() uint32 {
	return (volatile.LoadUint32(&o.CRS3.Reg) & 0x40000000) >> 30
}
func (o *AXBS_Type) SetCRS3_RO(value uint32) {
	volatile.StoreUint32(&o.CRS3.Reg, volatile.LoadUint32(&o.CRS3.Reg)&^(0x80000000)|value<<31)
}
func (o *AXBS_Type) GetCRS3_RO() uint32 {
	return (volatile.LoadUint32(&o.CRS3.Reg) & 0x80000000) >> 31
}

// AXBS.PRS4: Priority Registers Slave
func (o *AXBS_Type) SetPRS4_M0(value uint32) {
	volatile.StoreUint32(&o.PRS4.Reg, volatile.LoadUint32(&o.PRS4.Reg)&^(0x7)|value)
}
func (o *AXBS_Type) GetPRS4_M0() uint32 {
	return volatile.LoadUint32(&o.PRS4.Reg) & 0x7
}
func (o *AXBS_Type) SetPRS4_M1(value uint32) {
	volatile.StoreUint32(&o.PRS4.Reg, volatile.LoadUint32(&o.PRS4.Reg)&^(0x70)|value<<4)
}
func (o *AXBS_Type) GetPRS4_M1() uint32 {
	return (volatile.LoadUint32(&o.PRS4.Reg) & 0x70) >> 4
}
func (o *AXBS_Type) SetPRS4_M2(value uint32) {
	volatile.StoreUint32(&o.PRS4.Reg, volatile.LoadUint32(&o.PRS4.Reg)&^(0x700)|value<<8)
}
func (o *AXBS_Type) GetPRS4_M2() uint32 {
	return (volatile.LoadUint32(&o.PRS4.Reg) & 0x700) >> 8
}
func (o *AXBS_Type) SetPRS4_M3(value uint32) {
	volatile.StoreUint32(&o.PRS4.Reg, volatile.LoadUint32(&o.PRS4.Reg)&^(0x7000)|value<<12)
}
func (o *AXBS_Type) GetPRS4_M3() uint32 {
	return (volatile.LoadUint32(&o.PRS4.Reg) & 0x7000) >> 12
}
func (o *AXBS_Type) SetPRS4_M4(value uint32) {
	volatile.StoreUint32(&o.PRS4.Reg, volatile.LoadUint32(&o.PRS4.Reg)&^(0x70000)|value<<16)
}
func (o *AXBS_Type) GetPRS4_M4() uint32 {
	return (volatile.LoadUint32(&o.PRS4.Reg) & 0x70000) >> 16
}
func (o *AXBS_Type) SetPRS4_M5(value uint32) {
	volatile.StoreUint32(&o.PRS4.Reg, volatile.LoadUint32(&o.PRS4.Reg)&^(0x700000)|value<<20)
}
func (o *AXBS_Type) GetPRS4_M5() uint32 {
	return (volatile.LoadUint32(&o.PRS4.Reg) & 0x700000) >> 20
}

// AXBS.CRS4: Control Register
func (o *AXBS_Type) SetCRS4_PARK(value uint32) {
	volatile.StoreUint32(&o.CRS4.Reg, volatile.LoadUint32(&o.CRS4.Reg)&^(0x7)|value)
}
func (o *AXBS_Type) GetCRS4_PARK() uint32 {
	return volatile.LoadUint32(&o.CRS4.Reg) & 0x7
}
func (o *AXBS_Type) SetCRS4_PCTL(value uint32) {
	volatile.StoreUint32(&o.CRS4.Reg, volatile.LoadUint32(&o.CRS4.Reg)&^(0x30)|value<<4)
}
func (o *AXBS_Type) GetCRS4_PCTL() uint32 {
	return (volatile.LoadUint32(&o.CRS4.Reg) & 0x30) >> 4
}
func (o *AXBS_Type) SetCRS4_ARB(value uint32) {
	volatile.StoreUint32(&o.CRS4.Reg, volatile.LoadUint32(&o.CRS4.Reg)&^(0x300)|value<<8)
}
func (o *AXBS_Type) GetCRS4_ARB() uint32 {
	return (volatile.LoadUint32(&o.CRS4.Reg) & 0x300) >> 8
}
func (o *AXBS_Type) SetCRS4_HLP(value uint32) {
	volatile.StoreUint32(&o.CRS4.Reg, volatile.LoadUint32(&o.CRS4.Reg)&^(0x40000000)|value<<30)
}
func (o *AXBS_Type) GetCRS4_HLP() uint32 {
	return (volatile.LoadUint32(&o.CRS4.Reg) & 0x40000000) >> 30
}
func (o *AXBS_Type) SetCRS4_RO(value uint32) {
	volatile.StoreUint32(&o.CRS4.Reg, volatile.LoadUint32(&o.CRS4.Reg)&^(0x80000000)|value<<31)
}
func (o *AXBS_Type) GetCRS4_RO() uint32 {
	return (volatile.LoadUint32(&o.CRS4.Reg) & 0x80000000) >> 31
}

// AXBS.MGPCR0: Master General Purpose Control Register
func (o *AXBS_Type) SetMGPCR0_AULB(value uint32) {
	volatile.StoreUint32(&o.MGPCR0.Reg, volatile.LoadUint32(&o.MGPCR0.Reg)&^(0x7)|value)
}
func (o *AXBS_Type) GetMGPCR0_AULB() uint32 {
	return volatile.LoadUint32(&o.MGPCR0.Reg) & 0x7
}

// AXBS.MGPCR1: Master General Purpose Control Register
func (o *AXBS_Type) SetMGPCR1_AULB(value uint32) {
	volatile.StoreUint32(&o.MGPCR1.Reg, volatile.LoadUint32(&o.MGPCR1.Reg)&^(0x7)|value)
}
func (o *AXBS_Type) GetMGPCR1_AULB() uint32 {
	return volatile.LoadUint32(&o.MGPCR1.Reg) & 0x7
}

// AXBS.MGPCR2: Master General Purpose Control Register
func (o *AXBS_Type) SetMGPCR2_AULB(value uint32) {
	volatile.StoreUint32(&o.MGPCR2.Reg, volatile.LoadUint32(&o.MGPCR2.Reg)&^(0x7)|value)
}
func (o *AXBS_Type) GetMGPCR2_AULB() uint32 {
	return volatile.LoadUint32(&o.MGPCR2.Reg) & 0x7
}

// AXBS.MGPCR3: Master General Purpose Control Register
func (o *AXBS_Type) SetMGPCR3_AULB(value uint32) {
	volatile.StoreUint32(&o.MGPCR3.Reg, volatile.LoadUint32(&o.MGPCR3.Reg)&^(0x7)|value)
}
func (o *AXBS_Type) GetMGPCR3_AULB() uint32 {
	return volatile.LoadUint32(&o.MGPCR3.Reg) & 0x7
}

// AXBS.MGPCR4: Master General Purpose Control Register
func (o *AXBS_Type) SetMGPCR4_AULB(value uint32) {
	volatile.StoreUint32(&o.MGPCR4.Reg, volatile.LoadUint32(&o.MGPCR4.Reg)&^(0x7)|value)
}
func (o *AXBS_Type) GetMGPCR4_AULB() uint32 {
	return volatile.LoadUint32(&o.MGPCR4.Reg) & 0x7
}

// AXBS.MGPCR5: Master General Purpose Control Register
func (o *AXBS_Type) SetMGPCR5_AULB(value uint32) {
	volatile.StoreUint32(&o.MGPCR5.Reg, volatile.LoadUint32(&o.MGPCR5.Reg)&^(0x7)|value)
}
func (o *AXBS_Type) GetMGPCR5_AULB() uint32 {
	return volatile.LoadUint32(&o.MGPCR5.Reg) & 0x7
}

// Enhanced direct memory access controller
type DMA_Type struct {
	CR                  volatile.Register32 // 0x0
	ES                  volatile.Register32 // 0x4
	_                   [4]byte
	ERQ                 volatile.Register32 // 0xC
	_                   [4]byte
	EEI                 volatile.Register32 // 0x14
	CEEI                volatile.Register8  // 0x18
	SEEI                volatile.Register8  // 0x19
	CERQ                volatile.Register8  // 0x1A
	SERQ                volatile.Register8  // 0x1B
	CDNE                volatile.Register8  // 0x1C
	SSRT                volatile.Register8  // 0x1D
	CERR                volatile.Register8  // 0x1E
	CINT                volatile.Register8  // 0x1F
	_                   [4]byte
	INT                 volatile.Register32 // 0x24
	_                   [4]byte
	ERR                 volatile.Register32 // 0x2C
	_                   [4]byte
	HRS                 volatile.Register32 // 0x34
	_                   [200]byte
	DCHPRI3             volatile.Register8 // 0x100
	DCHPRI2             volatile.Register8 // 0x101
	DCHPRI1             volatile.Register8 // 0x102
	DCHPRI0             volatile.Register8 // 0x103
	DCHPRI7             volatile.Register8 // 0x104
	DCHPRI6             volatile.Register8 // 0x105
	DCHPRI5             volatile.Register8 // 0x106
	DCHPRI4             volatile.Register8 // 0x107
	DCHPRI11            volatile.Register8 // 0x108
	DCHPRI10            volatile.Register8 // 0x109
	DCHPRI9             volatile.Register8 // 0x10A
	DCHPRI8             volatile.Register8 // 0x10B
	DCHPRI15            volatile.Register8 // 0x10C
	DCHPRI14            volatile.Register8 // 0x10D
	DCHPRI13            volatile.Register8 // 0x10E
	DCHPRI12            volatile.Register8 // 0x10F
	_                   [3824]byte
	TCD0_SADDR          volatile.Register32 // 0x1000
	TCD0_SOFF           volatile.Register16 // 0x1004
	TCD0_ATTR           volatile.Register16 // 0x1006
	TCD0_NBYTES_MLNO    volatile.Register32 // 0x1008
	TCD0_SLAST          volatile.Register32 // 0x100C
	TCD0_DADDR          volatile.Register32 // 0x1010
	TCD0_DOFF           volatile.Register16 // 0x1014
	TCD0_CITER_ELINKNO  volatile.Register16 // 0x1016
	TCD0_DLASTSGA       volatile.Register32 // 0x1018
	TCD0_CSR            volatile.Register16 // 0x101C
	TCD0_BITER_ELINKNO  volatile.Register16 // 0x101E
	TCD1_SADDR          volatile.Register32 // 0x1020
	TCD1_SOFF           volatile.Register16 // 0x1024
	TCD1_ATTR           volatile.Register16 // 0x1026
	TCD1_NBYTES_MLNO    volatile.Register32 // 0x1028
	TCD1_SLAST          volatile.Register32 // 0x102C
	TCD1_DADDR          volatile.Register32 // 0x1030
	TCD1_DOFF           volatile.Register16 // 0x1034
	TCD1_CITER_ELINKNO  volatile.Register16 // 0x1036
	TCD1_DLASTSGA       volatile.Register32 // 0x1038
	TCD1_CSR            volatile.Register16 // 0x103C
	TCD1_BITER_ELINKNO  volatile.Register16 // 0x103E
	TCD2_SADDR          volatile.Register32 // 0x1040
	TCD2_SOFF           volatile.Register16 // 0x1044
	TCD2_ATTR           volatile.Register16 // 0x1046
	TCD2_NBYTES_MLNO    volatile.Register32 // 0x1048
	TCD2_SLAST          volatile.Register32 // 0x104C
	TCD2_DADDR          volatile.Register32 // 0x1050
	TCD2_DOFF           volatile.Register16 // 0x1054
	TCD2_CITER_ELINKNO  volatile.Register16 // 0x1056
	TCD2_DLASTSGA       volatile.Register32 // 0x1058
	TCD2_CSR            volatile.Register16 // 0x105C
	TCD2_BITER_ELINKNO  volatile.Register16 // 0x105E
	TCD3_SADDR          volatile.Register32 // 0x1060
	TCD3_SOFF           volatile.Register16 // 0x1064
	TCD3_ATTR           volatile.Register16 // 0x1066
	TCD3_NBYTES_MLNO    volatile.Register32 // 0x1068
	TCD3_SLAST          volatile.Register32 // 0x106C
	TCD3_DADDR          volatile.Register32 // 0x1070
	TCD3_DOFF           volatile.Register16 // 0x1074
	TCD3_CITER_ELINKNO  volatile.Register16 // 0x1076
	TCD3_DLASTSGA       volatile.Register32 // 0x1078
	TCD3_CSR            volatile.Register16 // 0x107C
	TCD3_BITER_ELINKNO  volatile.Register16 // 0x107E
	TCD4_SADDR          volatile.Register32 // 0x1080
	TCD4_SOFF           volatile.Register16 // 0x1084
	TCD4_ATTR           volatile.Register16 // 0x1086
	TCD4_NBYTES_MLNO    volatile.Register32 // 0x1088
	TCD4_SLAST          volatile.Register32 // 0x108C
	TCD4_DADDR          volatile.Register32 // 0x1090
	TCD4_DOFF           volatile.Register16 // 0x1094
	TCD4_CITER_ELINKNO  volatile.Register16 // 0x1096
	TCD4_DLASTSGA       volatile.Register32 // 0x1098
	TCD4_CSR            volatile.Register16 // 0x109C
	TCD4_BITER_ELINKNO  volatile.Register16 // 0x109E
	TCD5_SADDR          volatile.Register32 // 0x10A0
	TCD5_SOFF           volatile.Register16 // 0x10A4
	TCD5_ATTR           volatile.Register16 // 0x10A6
	TCD5_NBYTES_MLNO    volatile.Register32 // 0x10A8
	TCD5_SLAST          volatile.Register32 // 0x10AC
	TCD5_DADDR          volatile.Register32 // 0x10B0
	TCD5_DOFF           volatile.Register16 // 0x10B4
	TCD5_CITER_ELINKNO  volatile.Register16 // 0x10B6
	TCD5_DLASTSGA       volatile.Register32 // 0x10B8
	TCD5_CSR            volatile.Register16 // 0x10BC
	TCD5_BITER_ELINKNO  volatile.Register16 // 0x10BE
	TCD6_SADDR          volatile.Register32 // 0x10C0
	TCD6_SOFF           volatile.Register16 // 0x10C4
	TCD6_ATTR           volatile.Register16 // 0x10C6
	TCD6_NBYTES_MLNO    volatile.Register32 // 0x10C8
	TCD6_SLAST          volatile.Register32 // 0x10CC
	TCD6_DADDR          volatile.Register32 // 0x10D0
	TCD6_DOFF           volatile.Register16 // 0x10D4
	TCD6_CITER_ELINKNO  volatile.Register16 // 0x10D6
	TCD6_DLASTSGA       volatile.Register32 // 0x10D8
	TCD6_CSR            volatile.Register16 // 0x10DC
	TCD6_BITER_ELINKNO  volatile.Register16 // 0x10DE
	TCD7_SADDR          volatile.Register32 // 0x10E0
	TCD7_SOFF           volatile.Register16 // 0x10E4
	TCD7_ATTR           volatile.Register16 // 0x10E6
	TCD7_NBYTES_MLNO    volatile.Register32 // 0x10E8
	TCD7_SLAST          volatile.Register32 // 0x10EC
	TCD7_DADDR          volatile.Register32 // 0x10F0
	TCD7_DOFF           volatile.Register16 // 0x10F4
	TCD7_CITER_ELINKNO  volatile.Register16 // 0x10F6
	TCD7_DLASTSGA       volatile.Register32 // 0x10F8
	TCD7_CSR            volatile.Register16 // 0x10FC
	TCD7_BITER_ELINKNO  volatile.Register16 // 0x10FE
	TCD8_SADDR          volatile.Register32 // 0x1100
	TCD8_SOFF           volatile.Register16 // 0x1104
	TCD8_ATTR           volatile.Register16 // 0x1106
	TCD8_NBYTES_MLNO    volatile.Register32 // 0x1108
	TCD8_SLAST          volatile.Register32 // 0x110C
	TCD8_DADDR          volatile.Register32 // 0x1110
	TCD8_DOFF           volatile.Register16 // 0x1114
	TCD8_CITER_ELINKNO  volatile.Register16 // 0x1116
	TCD8_DLASTSGA       volatile.Register32 // 0x1118
	TCD8_CSR            volatile.Register16 // 0x111C
	TCD8_BITER_ELINKNO  volatile.Register16 // 0x111E
	TCD9_SADDR          volatile.Register32 // 0x1120
	TCD9_SOFF           volatile.Register16 // 0x1124
	TCD9_ATTR           volatile.Register16 // 0x1126
	TCD9_NBYTES_MLNO    volatile.Register32 // 0x1128
	TCD9_SLAST          volatile.Register32 // 0x112C
	TCD9_DADDR          volatile.Register32 // 0x1130
	TCD9_DOFF           volatile.Register16 // 0x1134
	TCD9_CITER_ELINKNO  volatile.Register16 // 0x1136
	TCD9_DLASTSGA       volatile.Register32 // 0x1138
	TCD9_CSR            volatile.Register16 // 0x113C
	TCD9_BITER_ELINKNO  volatile.Register16 // 0x113E
	TCD10_SADDR         volatile.Register32 // 0x1140
	TCD10_SOFF          volatile.Register16 // 0x1144
	TCD10_ATTR          volatile.Register16 // 0x1146
	TCD10_NBYTES_MLNO   volatile.Register32 // 0x1148
	TCD10_SLAST         volatile.Register32 // 0x114C
	TCD10_DADDR         volatile.Register32 // 0x1150
	TCD10_DOFF          volatile.Register16 // 0x1154
	TCD10_CITER_ELINKNO volatile.Register16 // 0x1156
	TCD10_DLASTSGA      volatile.Register32 // 0x1158
	TCD10_CSR           volatile.Register16 // 0x115C
	TCD10_BITER_ELINKNO volatile.Register16 // 0x115E
	TCD11_SADDR         volatile.Register32 // 0x1160
	TCD11_SOFF          volatile.Register16 // 0x1164
	TCD11_ATTR          volatile.Register16 // 0x1166
	TCD11_NBYTES_MLNO   volatile.Register32 // 0x1168
	TCD11_SLAST         volatile.Register32 // 0x116C
	TCD11_DADDR         volatile.Register32 // 0x1170
	TCD11_DOFF          volatile.Register16 // 0x1174
	TCD11_CITER_ELINKNO volatile.Register16 // 0x1176
	TCD11_DLASTSGA      volatile.Register32 // 0x1178
	TCD11_CSR           volatile.Register16 // 0x117C
	TCD11_BITER_ELINKNO volatile.Register16 // 0x117E
	TCD12_SADDR         volatile.Register32 // 0x1180
	TCD12_SOFF          volatile.Register16 // 0x1184
	TCD12_ATTR          volatile.Register16 // 0x1186
	TCD12_NBYTES_MLNO   volatile.Register32 // 0x1188
	TCD12_SLAST         volatile.Register32 // 0x118C
	TCD12_DADDR         volatile.Register32 // 0x1190
	TCD12_DOFF          volatile.Register16 // 0x1194
	TCD12_CITER_ELINKNO volatile.Register16 // 0x1196
	TCD12_DLASTSGA      volatile.Register32 // 0x1198
	TCD12_CSR           volatile.Register16 // 0x119C
	TCD12_BITER_ELINKNO volatile.Register16 // 0x119E
	TCD13_SADDR         volatile.Register32 // 0x11A0
	TCD13_SOFF          volatile.Register16 // 0x11A4
	TCD13_ATTR          volatile.Register16 // 0x11A6
	TCD13_NBYTES_MLNO   volatile.Register32 // 0x11A8
	TCD13_SLAST         volatile.Register32 // 0x11AC
	TCD13_DADDR         volatile.Register32 // 0x11B0
	TCD13_DOFF          volatile.Register16 // 0x11B4
	TCD13_CITER_ELINKNO volatile.Register16 // 0x11B6
	TCD13_DLASTSGA      volatile.Register32 // 0x11B8
	TCD13_CSR           volatile.Register16 // 0x11BC
	TCD13_BITER_ELINKNO volatile.Register16 // 0x11BE
	TCD14_SADDR         volatile.Register32 // 0x11C0
	TCD14_SOFF          volatile.Register16 // 0x11C4
	TCD14_ATTR          volatile.Register16 // 0x11C6
	TCD14_NBYTES_MLNO   volatile.Register32 // 0x11C8
	TCD14_SLAST         volatile.Register32 // 0x11CC
	TCD14_DADDR         volatile.Register32 // 0x11D0
	TCD14_DOFF          volatile.Register16 // 0x11D4
	TCD14_CITER_ELINKNO volatile.Register16 // 0x11D6
	TCD14_DLASTSGA      volatile.Register32 // 0x11D8
	TCD14_CSR           volatile.Register16 // 0x11DC
	TCD14_BITER_ELINKNO volatile.Register16 // 0x11DE
	TCD15_SADDR         volatile.Register32 // 0x11E0
	TCD15_SOFF          volatile.Register16 // 0x11E4
	TCD15_ATTR          volatile.Register16 // 0x11E6
	TCD15_NBYTES_MLNO   volatile.Register32 // 0x11E8
	TCD15_SLAST         volatile.Register32 // 0x11EC
	TCD15_DADDR         volatile.Register32 // 0x11F0
	TCD15_DOFF          volatile.Register16 // 0x11F4
	TCD15_CITER_ELINKNO volatile.Register16 // 0x11F6
	TCD15_DLASTSGA      volatile.Register32 // 0x11F8
	TCD15_CSR           volatile.Register16 // 0x11FC
	TCD15_BITER_ELINKNO volatile.Register16 // 0x11FE
}

// DMA.CR: Control Register
func (o *DMA_Type) SetCR_EDBG(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetCR_EDBG() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetCR_ERCA(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetCR_ERCA() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetCR_HOE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetCR_HOE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetCR_HALT(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetCR_HALT() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetCR_CLM(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetCR_CLM() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetCR_EMLM(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetCR_EMLM() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetCR_ECX(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10000)|value<<16)
}
func (o *DMA_Type) GetCR_ECX() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10000) >> 16
}
func (o *DMA_Type) SetCR_CX(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20000)|value<<17)
}
func (o *DMA_Type) GetCR_CX() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20000) >> 17
}

// DMA.ES: Error Status Register
func (o *DMA_Type) SetES_DBE(value uint32) {
	volatile.StoreUint32(&o.ES.Reg, volatile.LoadUint32(&o.ES.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetES_DBE() uint32 {
	return volatile.LoadUint32(&o.ES.Reg) & 0x1
}
func (o *DMA_Type) SetES_SBE(value uint32) {
	volatile.StoreUint32(&o.ES.Reg, volatile.LoadUint32(&o.ES.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetES_SBE() uint32 {
	return (volatile.LoadUint32(&o.ES.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetES_SGE(value uint32) {
	volatile.StoreUint32(&o.ES.Reg, volatile.LoadUint32(&o.ES.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetES_SGE() uint32 {
	return (volatile.LoadUint32(&o.ES.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetES_NCE(value uint32) {
	volatile.StoreUint32(&o.ES.Reg, volatile.LoadUint32(&o.ES.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetES_NCE() uint32 {
	return (volatile.LoadUint32(&o.ES.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetES_DOE(value uint32) {
	volatile.StoreUint32(&o.ES.Reg, volatile.LoadUint32(&o.ES.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetES_DOE() uint32 {
	return (volatile.LoadUint32(&o.ES.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetES_DAE(value uint32) {
	volatile.StoreUint32(&o.ES.Reg, volatile.LoadUint32(&o.ES.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetES_DAE() uint32 {
	return (volatile.LoadUint32(&o.ES.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetES_SOE(value uint32) {
	volatile.StoreUint32(&o.ES.Reg, volatile.LoadUint32(&o.ES.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetES_SOE() uint32 {
	return (volatile.LoadUint32(&o.ES.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetES_SAE(value uint32) {
	volatile.StoreUint32(&o.ES.Reg, volatile.LoadUint32(&o.ES.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetES_SAE() uint32 {
	return (volatile.LoadUint32(&o.ES.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetES_ERRCHN(value uint32) {
	volatile.StoreUint32(&o.ES.Reg, volatile.LoadUint32(&o.ES.Reg)&^(0xf00)|value<<8)
}
func (o *DMA_Type) GetES_ERRCHN() uint32 {
	return (volatile.LoadUint32(&o.ES.Reg) & 0xf00) >> 8
}
func (o *DMA_Type) SetES_CPE(value uint32) {
	volatile.StoreUint32(&o.ES.Reg, volatile.LoadUint32(&o.ES.Reg)&^(0x4000)|value<<14)
}
func (o *DMA_Type) GetES_CPE() uint32 {
	return (volatile.LoadUint32(&o.ES.Reg) & 0x4000) >> 14
}
func (o *DMA_Type) SetES_ECX(value uint32) {
	volatile.StoreUint32(&o.ES.Reg, volatile.LoadUint32(&o.ES.Reg)&^(0x10000)|value<<16)
}
func (o *DMA_Type) GetES_ECX() uint32 {
	return (volatile.LoadUint32(&o.ES.Reg) & 0x10000) >> 16
}
func (o *DMA_Type) SetES_VLD(value uint32) {
	volatile.StoreUint32(&o.ES.Reg, volatile.LoadUint32(&o.ES.Reg)&^(0x80000000)|value<<31)
}
func (o *DMA_Type) GetES_VLD() uint32 {
	return (volatile.LoadUint32(&o.ES.Reg) & 0x80000000) >> 31
}

// DMA.ERQ: Enable Request Register
func (o *DMA_Type) SetERQ_ERQ0(value uint32) {
	volatile.StoreUint32(&o.ERQ.Reg, volatile.LoadUint32(&o.ERQ.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetERQ_ERQ0() uint32 {
	return volatile.LoadUint32(&o.ERQ.Reg) & 0x1
}
func (o *DMA_Type) SetERQ_ERQ1(value uint32) {
	volatile.StoreUint32(&o.ERQ.Reg, volatile.LoadUint32(&o.ERQ.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetERQ_ERQ1() uint32 {
	return (volatile.LoadUint32(&o.ERQ.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetERQ_ERQ2(value uint32) {
	volatile.StoreUint32(&o.ERQ.Reg, volatile.LoadUint32(&o.ERQ.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetERQ_ERQ2() uint32 {
	return (volatile.LoadUint32(&o.ERQ.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetERQ_ERQ3(value uint32) {
	volatile.StoreUint32(&o.ERQ.Reg, volatile.LoadUint32(&o.ERQ.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetERQ_ERQ3() uint32 {
	return (volatile.LoadUint32(&o.ERQ.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetERQ_ERQ4(value uint32) {
	volatile.StoreUint32(&o.ERQ.Reg, volatile.LoadUint32(&o.ERQ.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetERQ_ERQ4() uint32 {
	return (volatile.LoadUint32(&o.ERQ.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetERQ_ERQ5(value uint32) {
	volatile.StoreUint32(&o.ERQ.Reg, volatile.LoadUint32(&o.ERQ.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetERQ_ERQ5() uint32 {
	return (volatile.LoadUint32(&o.ERQ.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetERQ_ERQ6(value uint32) {
	volatile.StoreUint32(&o.ERQ.Reg, volatile.LoadUint32(&o.ERQ.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetERQ_ERQ6() uint32 {
	return (volatile.LoadUint32(&o.ERQ.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetERQ_ERQ7(value uint32) {
	volatile.StoreUint32(&o.ERQ.Reg, volatile.LoadUint32(&o.ERQ.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetERQ_ERQ7() uint32 {
	return (volatile.LoadUint32(&o.ERQ.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetERQ_ERQ8(value uint32) {
	volatile.StoreUint32(&o.ERQ.Reg, volatile.LoadUint32(&o.ERQ.Reg)&^(0x100)|value<<8)
}
func (o *DMA_Type) GetERQ_ERQ8() uint32 {
	return (volatile.LoadUint32(&o.ERQ.Reg) & 0x100) >> 8
}
func (o *DMA_Type) SetERQ_ERQ9(value uint32) {
	volatile.StoreUint32(&o.ERQ.Reg, volatile.LoadUint32(&o.ERQ.Reg)&^(0x200)|value<<9)
}
func (o *DMA_Type) GetERQ_ERQ9() uint32 {
	return (volatile.LoadUint32(&o.ERQ.Reg) & 0x200) >> 9
}
func (o *DMA_Type) SetERQ_ERQ10(value uint32) {
	volatile.StoreUint32(&o.ERQ.Reg, volatile.LoadUint32(&o.ERQ.Reg)&^(0x400)|value<<10)
}
func (o *DMA_Type) GetERQ_ERQ10() uint32 {
	return (volatile.LoadUint32(&o.ERQ.Reg) & 0x400) >> 10
}
func (o *DMA_Type) SetERQ_ERQ11(value uint32) {
	volatile.StoreUint32(&o.ERQ.Reg, volatile.LoadUint32(&o.ERQ.Reg)&^(0x800)|value<<11)
}
func (o *DMA_Type) GetERQ_ERQ11() uint32 {
	return (volatile.LoadUint32(&o.ERQ.Reg) & 0x800) >> 11
}
func (o *DMA_Type) SetERQ_ERQ12(value uint32) {
	volatile.StoreUint32(&o.ERQ.Reg, volatile.LoadUint32(&o.ERQ.Reg)&^(0x1000)|value<<12)
}
func (o *DMA_Type) GetERQ_ERQ12() uint32 {
	return (volatile.LoadUint32(&o.ERQ.Reg) & 0x1000) >> 12
}
func (o *DMA_Type) SetERQ_ERQ13(value uint32) {
	volatile.StoreUint32(&o.ERQ.Reg, volatile.LoadUint32(&o.ERQ.Reg)&^(0x2000)|value<<13)
}
func (o *DMA_Type) GetERQ_ERQ13() uint32 {
	return (volatile.LoadUint32(&o.ERQ.Reg) & 0x2000) >> 13
}
func (o *DMA_Type) SetERQ_ERQ14(value uint32) {
	volatile.StoreUint32(&o.ERQ.Reg, volatile.LoadUint32(&o.ERQ.Reg)&^(0x4000)|value<<14)
}
func (o *DMA_Type) GetERQ_ERQ14() uint32 {
	return (volatile.LoadUint32(&o.ERQ.Reg) & 0x4000) >> 14
}
func (o *DMA_Type) SetERQ_ERQ15(value uint32) {
	volatile.StoreUint32(&o.ERQ.Reg, volatile.LoadUint32(&o.ERQ.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetERQ_ERQ15() uint32 {
	return (volatile.LoadUint32(&o.ERQ.Reg) & 0x8000) >> 15
}

// DMA.EEI: Enable Error Interrupt Register
func (o *DMA_Type) SetEEI_EEI0(value uint32) {
	volatile.StoreUint32(&o.EEI.Reg, volatile.LoadUint32(&o.EEI.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetEEI_EEI0() uint32 {
	return volatile.LoadUint32(&o.EEI.Reg) & 0x1
}
func (o *DMA_Type) SetEEI_EEI1(value uint32) {
	volatile.StoreUint32(&o.EEI.Reg, volatile.LoadUint32(&o.EEI.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetEEI_EEI1() uint32 {
	return (volatile.LoadUint32(&o.EEI.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetEEI_EEI2(value uint32) {
	volatile.StoreUint32(&o.EEI.Reg, volatile.LoadUint32(&o.EEI.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetEEI_EEI2() uint32 {
	return (volatile.LoadUint32(&o.EEI.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetEEI_EEI3(value uint32) {
	volatile.StoreUint32(&o.EEI.Reg, volatile.LoadUint32(&o.EEI.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetEEI_EEI3() uint32 {
	return (volatile.LoadUint32(&o.EEI.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetEEI_EEI4(value uint32) {
	volatile.StoreUint32(&o.EEI.Reg, volatile.LoadUint32(&o.EEI.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetEEI_EEI4() uint32 {
	return (volatile.LoadUint32(&o.EEI.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetEEI_EEI5(value uint32) {
	volatile.StoreUint32(&o.EEI.Reg, volatile.LoadUint32(&o.EEI.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetEEI_EEI5() uint32 {
	return (volatile.LoadUint32(&o.EEI.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetEEI_EEI6(value uint32) {
	volatile.StoreUint32(&o.EEI.Reg, volatile.LoadUint32(&o.EEI.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetEEI_EEI6() uint32 {
	return (volatile.LoadUint32(&o.EEI.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetEEI_EEI7(value uint32) {
	volatile.StoreUint32(&o.EEI.Reg, volatile.LoadUint32(&o.EEI.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetEEI_EEI7() uint32 {
	return (volatile.LoadUint32(&o.EEI.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetEEI_EEI8(value uint32) {
	volatile.StoreUint32(&o.EEI.Reg, volatile.LoadUint32(&o.EEI.Reg)&^(0x100)|value<<8)
}
func (o *DMA_Type) GetEEI_EEI8() uint32 {
	return (volatile.LoadUint32(&o.EEI.Reg) & 0x100) >> 8
}
func (o *DMA_Type) SetEEI_EEI9(value uint32) {
	volatile.StoreUint32(&o.EEI.Reg, volatile.LoadUint32(&o.EEI.Reg)&^(0x200)|value<<9)
}
func (o *DMA_Type) GetEEI_EEI9() uint32 {
	return (volatile.LoadUint32(&o.EEI.Reg) & 0x200) >> 9
}
func (o *DMA_Type) SetEEI_EEI10(value uint32) {
	volatile.StoreUint32(&o.EEI.Reg, volatile.LoadUint32(&o.EEI.Reg)&^(0x400)|value<<10)
}
func (o *DMA_Type) GetEEI_EEI10() uint32 {
	return (volatile.LoadUint32(&o.EEI.Reg) & 0x400) >> 10
}
func (o *DMA_Type) SetEEI_EEI11(value uint32) {
	volatile.StoreUint32(&o.EEI.Reg, volatile.LoadUint32(&o.EEI.Reg)&^(0x800)|value<<11)
}
func (o *DMA_Type) GetEEI_EEI11() uint32 {
	return (volatile.LoadUint32(&o.EEI.Reg) & 0x800) >> 11
}
func (o *DMA_Type) SetEEI_EEI12(value uint32) {
	volatile.StoreUint32(&o.EEI.Reg, volatile.LoadUint32(&o.EEI.Reg)&^(0x1000)|value<<12)
}
func (o *DMA_Type) GetEEI_EEI12() uint32 {
	return (volatile.LoadUint32(&o.EEI.Reg) & 0x1000) >> 12
}
func (o *DMA_Type) SetEEI_EEI13(value uint32) {
	volatile.StoreUint32(&o.EEI.Reg, volatile.LoadUint32(&o.EEI.Reg)&^(0x2000)|value<<13)
}
func (o *DMA_Type) GetEEI_EEI13() uint32 {
	return (volatile.LoadUint32(&o.EEI.Reg) & 0x2000) >> 13
}
func (o *DMA_Type) SetEEI_EEI14(value uint32) {
	volatile.StoreUint32(&o.EEI.Reg, volatile.LoadUint32(&o.EEI.Reg)&^(0x4000)|value<<14)
}
func (o *DMA_Type) GetEEI_EEI14() uint32 {
	return (volatile.LoadUint32(&o.EEI.Reg) & 0x4000) >> 14
}
func (o *DMA_Type) SetEEI_EEI15(value uint32) {
	volatile.StoreUint32(&o.EEI.Reg, volatile.LoadUint32(&o.EEI.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetEEI_EEI15() uint32 {
	return (volatile.LoadUint32(&o.EEI.Reg) & 0x8000) >> 15
}

// DMA.CEEI: Clear Enable Error Interrupt Register
func (o *DMA_Type) SetCEEI(value uint8) {
	volatile.StoreUint8(&o.CEEI.Reg, volatile.LoadUint8(&o.CEEI.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetCEEI() uint8 {
	return volatile.LoadUint8(&o.CEEI.Reg) & 0xf
}
func (o *DMA_Type) SetCEEI_CAEE(value uint8) {
	volatile.StoreUint8(&o.CEEI.Reg, volatile.LoadUint8(&o.CEEI.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetCEEI_CAEE() uint8 {
	return (volatile.LoadUint8(&o.CEEI.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetCEEI_NOP(value uint8) {
	volatile.StoreUint8(&o.CEEI.Reg, volatile.LoadUint8(&o.CEEI.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetCEEI_NOP() uint8 {
	return (volatile.LoadUint8(&o.CEEI.Reg) & 0x80) >> 7
}

// DMA.SEEI: Set Enable Error Interrupt Register
func (o *DMA_Type) SetSEEI(value uint8) {
	volatile.StoreUint8(&o.SEEI.Reg, volatile.LoadUint8(&o.SEEI.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetSEEI() uint8 {
	return volatile.LoadUint8(&o.SEEI.Reg) & 0xf
}
func (o *DMA_Type) SetSEEI_SAEE(value uint8) {
	volatile.StoreUint8(&o.SEEI.Reg, volatile.LoadUint8(&o.SEEI.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetSEEI_SAEE() uint8 {
	return (volatile.LoadUint8(&o.SEEI.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetSEEI_NOP(value uint8) {
	volatile.StoreUint8(&o.SEEI.Reg, volatile.LoadUint8(&o.SEEI.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetSEEI_NOP() uint8 {
	return (volatile.LoadUint8(&o.SEEI.Reg) & 0x80) >> 7
}

// DMA.CERQ: Clear Enable Request Register
func (o *DMA_Type) SetCERQ(value uint8) {
	volatile.StoreUint8(&o.CERQ.Reg, volatile.LoadUint8(&o.CERQ.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetCERQ() uint8 {
	return volatile.LoadUint8(&o.CERQ.Reg) & 0xf
}
func (o *DMA_Type) SetCERQ_CAER(value uint8) {
	volatile.StoreUint8(&o.CERQ.Reg, volatile.LoadUint8(&o.CERQ.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetCERQ_CAER() uint8 {
	return (volatile.LoadUint8(&o.CERQ.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetCERQ_NOP(value uint8) {
	volatile.StoreUint8(&o.CERQ.Reg, volatile.LoadUint8(&o.CERQ.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetCERQ_NOP() uint8 {
	return (volatile.LoadUint8(&o.CERQ.Reg) & 0x80) >> 7
}

// DMA.SERQ: Set Enable Request Register
func (o *DMA_Type) SetSERQ(value uint8) {
	volatile.StoreUint8(&o.SERQ.Reg, volatile.LoadUint8(&o.SERQ.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetSERQ() uint8 {
	return volatile.LoadUint8(&o.SERQ.Reg) & 0xf
}
func (o *DMA_Type) SetSERQ_SAER(value uint8) {
	volatile.StoreUint8(&o.SERQ.Reg, volatile.LoadUint8(&o.SERQ.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetSERQ_SAER() uint8 {
	return (volatile.LoadUint8(&o.SERQ.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetSERQ_NOP(value uint8) {
	volatile.StoreUint8(&o.SERQ.Reg, volatile.LoadUint8(&o.SERQ.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetSERQ_NOP() uint8 {
	return (volatile.LoadUint8(&o.SERQ.Reg) & 0x80) >> 7
}

// DMA.CDNE: Clear DONE Status Bit Register
func (o *DMA_Type) SetCDNE(value uint8) {
	volatile.StoreUint8(&o.CDNE.Reg, volatile.LoadUint8(&o.CDNE.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetCDNE() uint8 {
	return volatile.LoadUint8(&o.CDNE.Reg) & 0xf
}
func (o *DMA_Type) SetCDNE_CADN(value uint8) {
	volatile.StoreUint8(&o.CDNE.Reg, volatile.LoadUint8(&o.CDNE.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetCDNE_CADN() uint8 {
	return (volatile.LoadUint8(&o.CDNE.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetCDNE_NOP(value uint8) {
	volatile.StoreUint8(&o.CDNE.Reg, volatile.LoadUint8(&o.CDNE.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetCDNE_NOP() uint8 {
	return (volatile.LoadUint8(&o.CDNE.Reg) & 0x80) >> 7
}

// DMA.SSRT: Set START Bit Register
func (o *DMA_Type) SetSSRT(value uint8) {
	volatile.StoreUint8(&o.SSRT.Reg, volatile.LoadUint8(&o.SSRT.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetSSRT() uint8 {
	return volatile.LoadUint8(&o.SSRT.Reg) & 0xf
}
func (o *DMA_Type) SetSSRT_SAST(value uint8) {
	volatile.StoreUint8(&o.SSRT.Reg, volatile.LoadUint8(&o.SSRT.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetSSRT_SAST() uint8 {
	return (volatile.LoadUint8(&o.SSRT.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetSSRT_NOP(value uint8) {
	volatile.StoreUint8(&o.SSRT.Reg, volatile.LoadUint8(&o.SSRT.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetSSRT_NOP() uint8 {
	return (volatile.LoadUint8(&o.SSRT.Reg) & 0x80) >> 7
}

// DMA.CERR: Clear Error Register
func (o *DMA_Type) SetCERR(value uint8) {
	volatile.StoreUint8(&o.CERR.Reg, volatile.LoadUint8(&o.CERR.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetCERR() uint8 {
	return volatile.LoadUint8(&o.CERR.Reg) & 0xf
}
func (o *DMA_Type) SetCERR_CAEI(value uint8) {
	volatile.StoreUint8(&o.CERR.Reg, volatile.LoadUint8(&o.CERR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetCERR_CAEI() uint8 {
	return (volatile.LoadUint8(&o.CERR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetCERR_NOP(value uint8) {
	volatile.StoreUint8(&o.CERR.Reg, volatile.LoadUint8(&o.CERR.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetCERR_NOP() uint8 {
	return (volatile.LoadUint8(&o.CERR.Reg) & 0x80) >> 7
}

// DMA.CINT: Clear Interrupt Request Register
func (o *DMA_Type) SetCINT(value uint8) {
	volatile.StoreUint8(&o.CINT.Reg, volatile.LoadUint8(&o.CINT.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetCINT() uint8 {
	return volatile.LoadUint8(&o.CINT.Reg) & 0xf
}
func (o *DMA_Type) SetCINT_CAIR(value uint8) {
	volatile.StoreUint8(&o.CINT.Reg, volatile.LoadUint8(&o.CINT.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetCINT_CAIR() uint8 {
	return (volatile.LoadUint8(&o.CINT.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetCINT_NOP(value uint8) {
	volatile.StoreUint8(&o.CINT.Reg, volatile.LoadUint8(&o.CINT.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetCINT_NOP() uint8 {
	return (volatile.LoadUint8(&o.CINT.Reg) & 0x80) >> 7
}

// DMA.INT: Interrupt Request Register
func (o *DMA_Type) SetINT_INT0(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetINT_INT0() uint32 {
	return volatile.LoadUint32(&o.INT.Reg) & 0x1
}
func (o *DMA_Type) SetINT_INT1(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetINT_INT1() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetINT_INT2(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetINT_INT2() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetINT_INT3(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetINT_INT3() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetINT_INT4(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetINT_INT4() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetINT_INT5(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetINT_INT5() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetINT_INT6(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetINT_INT6() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetINT_INT7(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetINT_INT7() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetINT_INT8(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x100)|value<<8)
}
func (o *DMA_Type) GetINT_INT8() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x100) >> 8
}
func (o *DMA_Type) SetINT_INT9(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x200)|value<<9)
}
func (o *DMA_Type) GetINT_INT9() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x200) >> 9
}
func (o *DMA_Type) SetINT_INT10(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x400)|value<<10)
}
func (o *DMA_Type) GetINT_INT10() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x400) >> 10
}
func (o *DMA_Type) SetINT_INT11(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x800)|value<<11)
}
func (o *DMA_Type) GetINT_INT11() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x800) >> 11
}
func (o *DMA_Type) SetINT_INT12(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x1000)|value<<12)
}
func (o *DMA_Type) GetINT_INT12() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x1000) >> 12
}
func (o *DMA_Type) SetINT_INT13(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x2000)|value<<13)
}
func (o *DMA_Type) GetINT_INT13() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x2000) >> 13
}
func (o *DMA_Type) SetINT_INT14(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x4000)|value<<14)
}
func (o *DMA_Type) GetINT_INT14() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x4000) >> 14
}
func (o *DMA_Type) SetINT_INT15(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetINT_INT15() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x8000) >> 15
}

// DMA.ERR: Error Register
func (o *DMA_Type) SetERR_ERR0(value uint32) {
	volatile.StoreUint32(&o.ERR.Reg, volatile.LoadUint32(&o.ERR.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetERR_ERR0() uint32 {
	return volatile.LoadUint32(&o.ERR.Reg) & 0x1
}
func (o *DMA_Type) SetERR_ERR1(value uint32) {
	volatile.StoreUint32(&o.ERR.Reg, volatile.LoadUint32(&o.ERR.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetERR_ERR1() uint32 {
	return (volatile.LoadUint32(&o.ERR.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetERR_ERR2(value uint32) {
	volatile.StoreUint32(&o.ERR.Reg, volatile.LoadUint32(&o.ERR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetERR_ERR2() uint32 {
	return (volatile.LoadUint32(&o.ERR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetERR_ERR3(value uint32) {
	volatile.StoreUint32(&o.ERR.Reg, volatile.LoadUint32(&o.ERR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetERR_ERR3() uint32 {
	return (volatile.LoadUint32(&o.ERR.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetERR_ERR4(value uint32) {
	volatile.StoreUint32(&o.ERR.Reg, volatile.LoadUint32(&o.ERR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetERR_ERR4() uint32 {
	return (volatile.LoadUint32(&o.ERR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetERR_ERR5(value uint32) {
	volatile.StoreUint32(&o.ERR.Reg, volatile.LoadUint32(&o.ERR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetERR_ERR5() uint32 {
	return (volatile.LoadUint32(&o.ERR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetERR_ERR6(value uint32) {
	volatile.StoreUint32(&o.ERR.Reg, volatile.LoadUint32(&o.ERR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetERR_ERR6() uint32 {
	return (volatile.LoadUint32(&o.ERR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetERR_ERR7(value uint32) {
	volatile.StoreUint32(&o.ERR.Reg, volatile.LoadUint32(&o.ERR.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetERR_ERR7() uint32 {
	return (volatile.LoadUint32(&o.ERR.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetERR_ERR8(value uint32) {
	volatile.StoreUint32(&o.ERR.Reg, volatile.LoadUint32(&o.ERR.Reg)&^(0x100)|value<<8)
}
func (o *DMA_Type) GetERR_ERR8() uint32 {
	return (volatile.LoadUint32(&o.ERR.Reg) & 0x100) >> 8
}
func (o *DMA_Type) SetERR_ERR9(value uint32) {
	volatile.StoreUint32(&o.ERR.Reg, volatile.LoadUint32(&o.ERR.Reg)&^(0x200)|value<<9)
}
func (o *DMA_Type) GetERR_ERR9() uint32 {
	return (volatile.LoadUint32(&o.ERR.Reg) & 0x200) >> 9
}
func (o *DMA_Type) SetERR_ERR10(value uint32) {
	volatile.StoreUint32(&o.ERR.Reg, volatile.LoadUint32(&o.ERR.Reg)&^(0x400)|value<<10)
}
func (o *DMA_Type) GetERR_ERR10() uint32 {
	return (volatile.LoadUint32(&o.ERR.Reg) & 0x400) >> 10
}
func (o *DMA_Type) SetERR_ERR11(value uint32) {
	volatile.StoreUint32(&o.ERR.Reg, volatile.LoadUint32(&o.ERR.Reg)&^(0x800)|value<<11)
}
func (o *DMA_Type) GetERR_ERR11() uint32 {
	return (volatile.LoadUint32(&o.ERR.Reg) & 0x800) >> 11
}
func (o *DMA_Type) SetERR_ERR12(value uint32) {
	volatile.StoreUint32(&o.ERR.Reg, volatile.LoadUint32(&o.ERR.Reg)&^(0x1000)|value<<12)
}
func (o *DMA_Type) GetERR_ERR12() uint32 {
	return (volatile.LoadUint32(&o.ERR.Reg) & 0x1000) >> 12
}
func (o *DMA_Type) SetERR_ERR13(value uint32) {
	volatile.StoreUint32(&o.ERR.Reg, volatile.LoadUint32(&o.ERR.Reg)&^(0x2000)|value<<13)
}
func (o *DMA_Type) GetERR_ERR13() uint32 {
	return (volatile.LoadUint32(&o.ERR.Reg) & 0x2000) >> 13
}
func (o *DMA_Type) SetERR_ERR14(value uint32) {
	volatile.StoreUint32(&o.ERR.Reg, volatile.LoadUint32(&o.ERR.Reg)&^(0x4000)|value<<14)
}
func (o *DMA_Type) GetERR_ERR14() uint32 {
	return (volatile.LoadUint32(&o.ERR.Reg) & 0x4000) >> 14
}
func (o *DMA_Type) SetERR_ERR15(value uint32) {
	volatile.StoreUint32(&o.ERR.Reg, volatile.LoadUint32(&o.ERR.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetERR_ERR15() uint32 {
	return (volatile.LoadUint32(&o.ERR.Reg) & 0x8000) >> 15
}

// DMA.HRS: Hardware Request Status Register
func (o *DMA_Type) SetHRS_HRS0(value uint32) {
	volatile.StoreUint32(&o.HRS.Reg, volatile.LoadUint32(&o.HRS.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetHRS_HRS0() uint32 {
	return volatile.LoadUint32(&o.HRS.Reg) & 0x1
}
func (o *DMA_Type) SetHRS_HRS1(value uint32) {
	volatile.StoreUint32(&o.HRS.Reg, volatile.LoadUint32(&o.HRS.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetHRS_HRS1() uint32 {
	return (volatile.LoadUint32(&o.HRS.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetHRS_HRS2(value uint32) {
	volatile.StoreUint32(&o.HRS.Reg, volatile.LoadUint32(&o.HRS.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetHRS_HRS2() uint32 {
	return (volatile.LoadUint32(&o.HRS.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetHRS_HRS3(value uint32) {
	volatile.StoreUint32(&o.HRS.Reg, volatile.LoadUint32(&o.HRS.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetHRS_HRS3() uint32 {
	return (volatile.LoadUint32(&o.HRS.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetHRS_HRS4(value uint32) {
	volatile.StoreUint32(&o.HRS.Reg, volatile.LoadUint32(&o.HRS.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetHRS_HRS4() uint32 {
	return (volatile.LoadUint32(&o.HRS.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetHRS_HRS5(value uint32) {
	volatile.StoreUint32(&o.HRS.Reg, volatile.LoadUint32(&o.HRS.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetHRS_HRS5() uint32 {
	return (volatile.LoadUint32(&o.HRS.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetHRS_HRS6(value uint32) {
	volatile.StoreUint32(&o.HRS.Reg, volatile.LoadUint32(&o.HRS.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetHRS_HRS6() uint32 {
	return (volatile.LoadUint32(&o.HRS.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetHRS_HRS7(value uint32) {
	volatile.StoreUint32(&o.HRS.Reg, volatile.LoadUint32(&o.HRS.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetHRS_HRS7() uint32 {
	return (volatile.LoadUint32(&o.HRS.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetHRS_HRS8(value uint32) {
	volatile.StoreUint32(&o.HRS.Reg, volatile.LoadUint32(&o.HRS.Reg)&^(0x100)|value<<8)
}
func (o *DMA_Type) GetHRS_HRS8() uint32 {
	return (volatile.LoadUint32(&o.HRS.Reg) & 0x100) >> 8
}
func (o *DMA_Type) SetHRS_HRS9(value uint32) {
	volatile.StoreUint32(&o.HRS.Reg, volatile.LoadUint32(&o.HRS.Reg)&^(0x200)|value<<9)
}
func (o *DMA_Type) GetHRS_HRS9() uint32 {
	return (volatile.LoadUint32(&o.HRS.Reg) & 0x200) >> 9
}
func (o *DMA_Type) SetHRS_HRS10(value uint32) {
	volatile.StoreUint32(&o.HRS.Reg, volatile.LoadUint32(&o.HRS.Reg)&^(0x400)|value<<10)
}
func (o *DMA_Type) GetHRS_HRS10() uint32 {
	return (volatile.LoadUint32(&o.HRS.Reg) & 0x400) >> 10
}
func (o *DMA_Type) SetHRS_HRS11(value uint32) {
	volatile.StoreUint32(&o.HRS.Reg, volatile.LoadUint32(&o.HRS.Reg)&^(0x800)|value<<11)
}
func (o *DMA_Type) GetHRS_HRS11() uint32 {
	return (volatile.LoadUint32(&o.HRS.Reg) & 0x800) >> 11
}
func (o *DMA_Type) SetHRS_HRS12(value uint32) {
	volatile.StoreUint32(&o.HRS.Reg, volatile.LoadUint32(&o.HRS.Reg)&^(0x1000)|value<<12)
}
func (o *DMA_Type) GetHRS_HRS12() uint32 {
	return (volatile.LoadUint32(&o.HRS.Reg) & 0x1000) >> 12
}
func (o *DMA_Type) SetHRS_HRS13(value uint32) {
	volatile.StoreUint32(&o.HRS.Reg, volatile.LoadUint32(&o.HRS.Reg)&^(0x2000)|value<<13)
}
func (o *DMA_Type) GetHRS_HRS13() uint32 {
	return (volatile.LoadUint32(&o.HRS.Reg) & 0x2000) >> 13
}
func (o *DMA_Type) SetHRS_HRS14(value uint32) {
	volatile.StoreUint32(&o.HRS.Reg, volatile.LoadUint32(&o.HRS.Reg)&^(0x4000)|value<<14)
}
func (o *DMA_Type) GetHRS_HRS14() uint32 {
	return (volatile.LoadUint32(&o.HRS.Reg) & 0x4000) >> 14
}
func (o *DMA_Type) SetHRS_HRS15(value uint32) {
	volatile.StoreUint32(&o.HRS.Reg, volatile.LoadUint32(&o.HRS.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetHRS_HRS15() uint32 {
	return (volatile.LoadUint32(&o.HRS.Reg) & 0x8000) >> 15
}

// DMA.DCHPRI3: Channel n Priority Register
func (o *DMA_Type) SetDCHPRI3_CHPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI3.Reg, volatile.LoadUint8(&o.DCHPRI3.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetDCHPRI3_CHPRI() uint8 {
	return volatile.LoadUint8(&o.DCHPRI3.Reg) & 0xf
}
func (o *DMA_Type) SetDCHPRI3_DPA(value uint8) {
	volatile.StoreUint8(&o.DCHPRI3.Reg, volatile.LoadUint8(&o.DCHPRI3.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetDCHPRI3_DPA() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI3.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetDCHPRI3_ECP(value uint8) {
	volatile.StoreUint8(&o.DCHPRI3.Reg, volatile.LoadUint8(&o.DCHPRI3.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetDCHPRI3_ECP() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI3.Reg) & 0x80) >> 7
}

// DMA.DCHPRI2: Channel n Priority Register
func (o *DMA_Type) SetDCHPRI2_CHPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI2.Reg, volatile.LoadUint8(&o.DCHPRI2.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetDCHPRI2_CHPRI() uint8 {
	return volatile.LoadUint8(&o.DCHPRI2.Reg) & 0xf
}
func (o *DMA_Type) SetDCHPRI2_DPA(value uint8) {
	volatile.StoreUint8(&o.DCHPRI2.Reg, volatile.LoadUint8(&o.DCHPRI2.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetDCHPRI2_DPA() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI2.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetDCHPRI2_ECP(value uint8) {
	volatile.StoreUint8(&o.DCHPRI2.Reg, volatile.LoadUint8(&o.DCHPRI2.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetDCHPRI2_ECP() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI2.Reg) & 0x80) >> 7
}

// DMA.DCHPRI1: Channel n Priority Register
func (o *DMA_Type) SetDCHPRI1_CHPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI1.Reg, volatile.LoadUint8(&o.DCHPRI1.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetDCHPRI1_CHPRI() uint8 {
	return volatile.LoadUint8(&o.DCHPRI1.Reg) & 0xf
}
func (o *DMA_Type) SetDCHPRI1_DPA(value uint8) {
	volatile.StoreUint8(&o.DCHPRI1.Reg, volatile.LoadUint8(&o.DCHPRI1.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetDCHPRI1_DPA() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI1.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetDCHPRI1_ECP(value uint8) {
	volatile.StoreUint8(&o.DCHPRI1.Reg, volatile.LoadUint8(&o.DCHPRI1.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetDCHPRI1_ECP() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI1.Reg) & 0x80) >> 7
}

// DMA.DCHPRI0: Channel n Priority Register
func (o *DMA_Type) SetDCHPRI0_CHPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI0.Reg, volatile.LoadUint8(&o.DCHPRI0.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetDCHPRI0_CHPRI() uint8 {
	return volatile.LoadUint8(&o.DCHPRI0.Reg) & 0xf
}
func (o *DMA_Type) SetDCHPRI0_DPA(value uint8) {
	volatile.StoreUint8(&o.DCHPRI0.Reg, volatile.LoadUint8(&o.DCHPRI0.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetDCHPRI0_DPA() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI0.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetDCHPRI0_ECP(value uint8) {
	volatile.StoreUint8(&o.DCHPRI0.Reg, volatile.LoadUint8(&o.DCHPRI0.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetDCHPRI0_ECP() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI0.Reg) & 0x80) >> 7
}

// DMA.DCHPRI7: Channel n Priority Register
func (o *DMA_Type) SetDCHPRI7_CHPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI7.Reg, volatile.LoadUint8(&o.DCHPRI7.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetDCHPRI7_CHPRI() uint8 {
	return volatile.LoadUint8(&o.DCHPRI7.Reg) & 0xf
}
func (o *DMA_Type) SetDCHPRI7_DPA(value uint8) {
	volatile.StoreUint8(&o.DCHPRI7.Reg, volatile.LoadUint8(&o.DCHPRI7.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetDCHPRI7_DPA() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI7.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetDCHPRI7_ECP(value uint8) {
	volatile.StoreUint8(&o.DCHPRI7.Reg, volatile.LoadUint8(&o.DCHPRI7.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetDCHPRI7_ECP() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI7.Reg) & 0x80) >> 7
}

// DMA.DCHPRI6: Channel n Priority Register
func (o *DMA_Type) SetDCHPRI6_CHPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI6.Reg, volatile.LoadUint8(&o.DCHPRI6.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetDCHPRI6_CHPRI() uint8 {
	return volatile.LoadUint8(&o.DCHPRI6.Reg) & 0xf
}
func (o *DMA_Type) SetDCHPRI6_DPA(value uint8) {
	volatile.StoreUint8(&o.DCHPRI6.Reg, volatile.LoadUint8(&o.DCHPRI6.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetDCHPRI6_DPA() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI6.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetDCHPRI6_ECP(value uint8) {
	volatile.StoreUint8(&o.DCHPRI6.Reg, volatile.LoadUint8(&o.DCHPRI6.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetDCHPRI6_ECP() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI6.Reg) & 0x80) >> 7
}

// DMA.DCHPRI5: Channel n Priority Register
func (o *DMA_Type) SetDCHPRI5_CHPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI5.Reg, volatile.LoadUint8(&o.DCHPRI5.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetDCHPRI5_CHPRI() uint8 {
	return volatile.LoadUint8(&o.DCHPRI5.Reg) & 0xf
}
func (o *DMA_Type) SetDCHPRI5_DPA(value uint8) {
	volatile.StoreUint8(&o.DCHPRI5.Reg, volatile.LoadUint8(&o.DCHPRI5.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetDCHPRI5_DPA() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI5.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetDCHPRI5_ECP(value uint8) {
	volatile.StoreUint8(&o.DCHPRI5.Reg, volatile.LoadUint8(&o.DCHPRI5.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetDCHPRI5_ECP() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI5.Reg) & 0x80) >> 7
}

// DMA.DCHPRI4: Channel n Priority Register
func (o *DMA_Type) SetDCHPRI4_CHPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI4.Reg, volatile.LoadUint8(&o.DCHPRI4.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetDCHPRI4_CHPRI() uint8 {
	return volatile.LoadUint8(&o.DCHPRI4.Reg) & 0xf
}
func (o *DMA_Type) SetDCHPRI4_DPA(value uint8) {
	volatile.StoreUint8(&o.DCHPRI4.Reg, volatile.LoadUint8(&o.DCHPRI4.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetDCHPRI4_DPA() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI4.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetDCHPRI4_ECP(value uint8) {
	volatile.StoreUint8(&o.DCHPRI4.Reg, volatile.LoadUint8(&o.DCHPRI4.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetDCHPRI4_ECP() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI4.Reg) & 0x80) >> 7
}

// DMA.DCHPRI11: Channel n Priority Register
func (o *DMA_Type) SetDCHPRI11_CHPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI11.Reg, volatile.LoadUint8(&o.DCHPRI11.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetDCHPRI11_CHPRI() uint8 {
	return volatile.LoadUint8(&o.DCHPRI11.Reg) & 0xf
}
func (o *DMA_Type) SetDCHPRI11_DPA(value uint8) {
	volatile.StoreUint8(&o.DCHPRI11.Reg, volatile.LoadUint8(&o.DCHPRI11.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetDCHPRI11_DPA() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI11.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetDCHPRI11_ECP(value uint8) {
	volatile.StoreUint8(&o.DCHPRI11.Reg, volatile.LoadUint8(&o.DCHPRI11.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetDCHPRI11_ECP() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI11.Reg) & 0x80) >> 7
}

// DMA.DCHPRI10: Channel n Priority Register
func (o *DMA_Type) SetDCHPRI10_CHPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI10.Reg, volatile.LoadUint8(&o.DCHPRI10.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetDCHPRI10_CHPRI() uint8 {
	return volatile.LoadUint8(&o.DCHPRI10.Reg) & 0xf
}
func (o *DMA_Type) SetDCHPRI10_DPA(value uint8) {
	volatile.StoreUint8(&o.DCHPRI10.Reg, volatile.LoadUint8(&o.DCHPRI10.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetDCHPRI10_DPA() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI10.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetDCHPRI10_ECP(value uint8) {
	volatile.StoreUint8(&o.DCHPRI10.Reg, volatile.LoadUint8(&o.DCHPRI10.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetDCHPRI10_ECP() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI10.Reg) & 0x80) >> 7
}

// DMA.DCHPRI9: Channel n Priority Register
func (o *DMA_Type) SetDCHPRI9_CHPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI9.Reg, volatile.LoadUint8(&o.DCHPRI9.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetDCHPRI9_CHPRI() uint8 {
	return volatile.LoadUint8(&o.DCHPRI9.Reg) & 0xf
}
func (o *DMA_Type) SetDCHPRI9_DPA(value uint8) {
	volatile.StoreUint8(&o.DCHPRI9.Reg, volatile.LoadUint8(&o.DCHPRI9.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetDCHPRI9_DPA() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI9.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetDCHPRI9_ECP(value uint8) {
	volatile.StoreUint8(&o.DCHPRI9.Reg, volatile.LoadUint8(&o.DCHPRI9.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetDCHPRI9_ECP() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI9.Reg) & 0x80) >> 7
}

// DMA.DCHPRI8: Channel n Priority Register
func (o *DMA_Type) SetDCHPRI8_CHPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI8.Reg, volatile.LoadUint8(&o.DCHPRI8.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetDCHPRI8_CHPRI() uint8 {
	return volatile.LoadUint8(&o.DCHPRI8.Reg) & 0xf
}
func (o *DMA_Type) SetDCHPRI8_DPA(value uint8) {
	volatile.StoreUint8(&o.DCHPRI8.Reg, volatile.LoadUint8(&o.DCHPRI8.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetDCHPRI8_DPA() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI8.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetDCHPRI8_ECP(value uint8) {
	volatile.StoreUint8(&o.DCHPRI8.Reg, volatile.LoadUint8(&o.DCHPRI8.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetDCHPRI8_ECP() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI8.Reg) & 0x80) >> 7
}

// DMA.DCHPRI15: Channel n Priority Register
func (o *DMA_Type) SetDCHPRI15_CHPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI15.Reg, volatile.LoadUint8(&o.DCHPRI15.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetDCHPRI15_CHPRI() uint8 {
	return volatile.LoadUint8(&o.DCHPRI15.Reg) & 0xf
}
func (o *DMA_Type) SetDCHPRI15_DPA(value uint8) {
	volatile.StoreUint8(&o.DCHPRI15.Reg, volatile.LoadUint8(&o.DCHPRI15.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetDCHPRI15_DPA() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI15.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetDCHPRI15_ECP(value uint8) {
	volatile.StoreUint8(&o.DCHPRI15.Reg, volatile.LoadUint8(&o.DCHPRI15.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetDCHPRI15_ECP() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI15.Reg) & 0x80) >> 7
}

// DMA.DCHPRI14: Channel n Priority Register
func (o *DMA_Type) SetDCHPRI14_CHPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI14.Reg, volatile.LoadUint8(&o.DCHPRI14.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetDCHPRI14_CHPRI() uint8 {
	return volatile.LoadUint8(&o.DCHPRI14.Reg) & 0xf
}
func (o *DMA_Type) SetDCHPRI14_DPA(value uint8) {
	volatile.StoreUint8(&o.DCHPRI14.Reg, volatile.LoadUint8(&o.DCHPRI14.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetDCHPRI14_DPA() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI14.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetDCHPRI14_ECP(value uint8) {
	volatile.StoreUint8(&o.DCHPRI14.Reg, volatile.LoadUint8(&o.DCHPRI14.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetDCHPRI14_ECP() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI14.Reg) & 0x80) >> 7
}

// DMA.DCHPRI13: Channel n Priority Register
func (o *DMA_Type) SetDCHPRI13_CHPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI13.Reg, volatile.LoadUint8(&o.DCHPRI13.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetDCHPRI13_CHPRI() uint8 {
	return volatile.LoadUint8(&o.DCHPRI13.Reg) & 0xf
}
func (o *DMA_Type) SetDCHPRI13_DPA(value uint8) {
	volatile.StoreUint8(&o.DCHPRI13.Reg, volatile.LoadUint8(&o.DCHPRI13.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetDCHPRI13_DPA() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI13.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetDCHPRI13_ECP(value uint8) {
	volatile.StoreUint8(&o.DCHPRI13.Reg, volatile.LoadUint8(&o.DCHPRI13.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetDCHPRI13_ECP() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI13.Reg) & 0x80) >> 7
}

// DMA.DCHPRI12: Channel n Priority Register
func (o *DMA_Type) SetDCHPRI12_CHPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI12.Reg, volatile.LoadUint8(&o.DCHPRI12.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetDCHPRI12_CHPRI() uint8 {
	return volatile.LoadUint8(&o.DCHPRI12.Reg) & 0xf
}
func (o *DMA_Type) SetDCHPRI12_DPA(value uint8) {
	volatile.StoreUint8(&o.DCHPRI12.Reg, volatile.LoadUint8(&o.DCHPRI12.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetDCHPRI12_DPA() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI12.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetDCHPRI12_ECP(value uint8) {
	volatile.StoreUint8(&o.DCHPRI12.Reg, volatile.LoadUint8(&o.DCHPRI12.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetDCHPRI12_ECP() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI12.Reg) & 0x80) >> 7
}

// DMA.TCD0_SADDR: TCD Source Address
func (o *DMA_Type) SetTCD0_SADDR(value uint32) {
	volatile.StoreUint32(&o.TCD0_SADDR.Reg, value)
}
func (o *DMA_Type) GetTCD0_SADDR() uint32 {
	return volatile.LoadUint32(&o.TCD0_SADDR.Reg)
}

// DMA.TCD0_SOFF: TCD Signed Source Address Offset
func (o *DMA_Type) SetTCD0_SOFF(value uint16) {
	volatile.StoreUint16(&o.TCD0_SOFF.Reg, value)
}
func (o *DMA_Type) GetTCD0_SOFF() uint16 {
	return volatile.LoadUint16(&o.TCD0_SOFF.Reg)
}

// DMA.TCD0_ATTR: TCD Transfer Attributes
func (o *DMA_Type) SetTCD0_ATTR_DSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD0_ATTR.Reg, volatile.LoadUint16(&o.TCD0_ATTR.Reg)&^(0x7)|value)
}
func (o *DMA_Type) GetTCD0_ATTR_DSIZE() uint16 {
	return volatile.LoadUint16(&o.TCD0_ATTR.Reg) & 0x7
}
func (o *DMA_Type) SetTCD0_ATTR_DMOD(value uint16) {
	volatile.StoreUint16(&o.TCD0_ATTR.Reg, volatile.LoadUint16(&o.TCD0_ATTR.Reg)&^(0xf8)|value<<3)
}
func (o *DMA_Type) GetTCD0_ATTR_DMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD0_ATTR.Reg) & 0xf8) >> 3
}
func (o *DMA_Type) SetTCD0_ATTR_SSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD0_ATTR.Reg, volatile.LoadUint16(&o.TCD0_ATTR.Reg)&^(0x700)|value<<8)
}
func (o *DMA_Type) GetTCD0_ATTR_SSIZE() uint16 {
	return (volatile.LoadUint16(&o.TCD0_ATTR.Reg) & 0x700) >> 8
}
func (o *DMA_Type) SetTCD0_ATTR_SMOD(value uint16) {
	volatile.StoreUint16(&o.TCD0_ATTR.Reg, volatile.LoadUint16(&o.TCD0_ATTR.Reg)&^(0xf800)|value<<11)
}
func (o *DMA_Type) GetTCD0_ATTR_SMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD0_ATTR.Reg) & 0xf800) >> 11
}

// DMA.TCD0_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Disabled)
func (o *DMA_Type) SetTCD0_NBYTES_MLNO(value uint32) {
	volatile.StoreUint32(&o.TCD0_NBYTES_MLNO.Reg, value)
}
func (o *DMA_Type) GetTCD0_NBYTES_MLNO() uint32 {
	return volatile.LoadUint32(&o.TCD0_NBYTES_MLNO.Reg)
}

// DMA.TCD0_SLAST: TCD Last Source Address Adjustment
func (o *DMA_Type) SetTCD0_SLAST(value uint32) {
	volatile.StoreUint32(&o.TCD0_SLAST.Reg, value)
}
func (o *DMA_Type) GetTCD0_SLAST() uint32 {
	return volatile.LoadUint32(&o.TCD0_SLAST.Reg)
}

// DMA.TCD0_DADDR: TCD Destination Address
func (o *DMA_Type) SetTCD0_DADDR(value uint32) {
	volatile.StoreUint32(&o.TCD0_DADDR.Reg, value)
}
func (o *DMA_Type) GetTCD0_DADDR() uint32 {
	return volatile.LoadUint32(&o.TCD0_DADDR.Reg)
}

// DMA.TCD0_DOFF: TCD Signed Destination Address Offset
func (o *DMA_Type) SetTCD0_DOFF(value uint16) {
	volatile.StoreUint16(&o.TCD0_DOFF.Reg, value)
}
func (o *DMA_Type) GetTCD0_DOFF() uint16 {
	return volatile.LoadUint16(&o.TCD0_DOFF.Reg)
}

// DMA.TCD0_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD0_CITER_ELINKNO_CITER(value uint16) {
	volatile.StoreUint16(&o.TCD0_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD0_CITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD0_CITER_ELINKNO_CITER() uint16 {
	return volatile.LoadUint16(&o.TCD0_CITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD0_CITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD0_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD0_CITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD0_CITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD0_CITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD0_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
func (o *DMA_Type) SetTCD0_DLASTSGA(value uint32) {
	volatile.StoreUint32(&o.TCD0_DLASTSGA.Reg, value)
}
func (o *DMA_Type) GetTCD0_DLASTSGA() uint32 {
	return volatile.LoadUint32(&o.TCD0_DLASTSGA.Reg)
}

// DMA.TCD0_CSR: TCD Control and Status
func (o *DMA_Type) SetTCD0_CSR_START(value uint16) {
	volatile.StoreUint16(&o.TCD0_CSR.Reg, volatile.LoadUint16(&o.TCD0_CSR.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetTCD0_CSR_START() uint16 {
	return volatile.LoadUint16(&o.TCD0_CSR.Reg) & 0x1
}
func (o *DMA_Type) SetTCD0_CSR_INTMAJOR(value uint16) {
	volatile.StoreUint16(&o.TCD0_CSR.Reg, volatile.LoadUint16(&o.TCD0_CSR.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetTCD0_CSR_INTMAJOR() uint16 {
	return (volatile.LoadUint16(&o.TCD0_CSR.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetTCD0_CSR_INTHALF(value uint16) {
	volatile.StoreUint16(&o.TCD0_CSR.Reg, volatile.LoadUint16(&o.TCD0_CSR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetTCD0_CSR_INTHALF() uint16 {
	return (volatile.LoadUint16(&o.TCD0_CSR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetTCD0_CSR_DREQ(value uint16) {
	volatile.StoreUint16(&o.TCD0_CSR.Reg, volatile.LoadUint16(&o.TCD0_CSR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetTCD0_CSR_DREQ() uint16 {
	return (volatile.LoadUint16(&o.TCD0_CSR.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetTCD0_CSR_ESG(value uint16) {
	volatile.StoreUint16(&o.TCD0_CSR.Reg, volatile.LoadUint16(&o.TCD0_CSR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetTCD0_CSR_ESG() uint16 {
	return (volatile.LoadUint16(&o.TCD0_CSR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetTCD0_CSR_MAJORELINK(value uint16) {
	volatile.StoreUint16(&o.TCD0_CSR.Reg, volatile.LoadUint16(&o.TCD0_CSR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetTCD0_CSR_MAJORELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD0_CSR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetTCD0_CSR_ACTIVE(value uint16) {
	volatile.StoreUint16(&o.TCD0_CSR.Reg, volatile.LoadUint16(&o.TCD0_CSR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetTCD0_CSR_ACTIVE() uint16 {
	return (volatile.LoadUint16(&o.TCD0_CSR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetTCD0_CSR_DONE(value uint16) {
	volatile.StoreUint16(&o.TCD0_CSR.Reg, volatile.LoadUint16(&o.TCD0_CSR.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetTCD0_CSR_DONE() uint16 {
	return (volatile.LoadUint16(&o.TCD0_CSR.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetTCD0_CSR_MAJORLINKCH(value uint16) {
	volatile.StoreUint16(&o.TCD0_CSR.Reg, volatile.LoadUint16(&o.TCD0_CSR.Reg)&^(0xf00)|value<<8)
}
func (o *DMA_Type) GetTCD0_CSR_MAJORLINKCH() uint16 {
	return (volatile.LoadUint16(&o.TCD0_CSR.Reg) & 0xf00) >> 8
}
func (o *DMA_Type) SetTCD0_CSR_BWC(value uint16) {
	volatile.StoreUint16(&o.TCD0_CSR.Reg, volatile.LoadUint16(&o.TCD0_CSR.Reg)&^(0xc000)|value<<14)
}
func (o *DMA_Type) GetTCD0_CSR_BWC() uint16 {
	return (volatile.LoadUint16(&o.TCD0_CSR.Reg) & 0xc000) >> 14
}

// DMA.TCD0_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD0_BITER_ELINKNO_BITER(value uint16) {
	volatile.StoreUint16(&o.TCD0_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD0_BITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD0_BITER_ELINKNO_BITER() uint16 {
	return volatile.LoadUint16(&o.TCD0_BITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD0_BITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD0_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD0_BITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD0_BITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD0_BITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD1_SADDR: TCD Source Address
func (o *DMA_Type) SetTCD1_SADDR(value uint32) {
	volatile.StoreUint32(&o.TCD1_SADDR.Reg, value)
}
func (o *DMA_Type) GetTCD1_SADDR() uint32 {
	return volatile.LoadUint32(&o.TCD1_SADDR.Reg)
}

// DMA.TCD1_SOFF: TCD Signed Source Address Offset
func (o *DMA_Type) SetTCD1_SOFF(value uint16) {
	volatile.StoreUint16(&o.TCD1_SOFF.Reg, value)
}
func (o *DMA_Type) GetTCD1_SOFF() uint16 {
	return volatile.LoadUint16(&o.TCD1_SOFF.Reg)
}

// DMA.TCD1_ATTR: TCD Transfer Attributes
func (o *DMA_Type) SetTCD1_ATTR_DSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD1_ATTR.Reg, volatile.LoadUint16(&o.TCD1_ATTR.Reg)&^(0x7)|value)
}
func (o *DMA_Type) GetTCD1_ATTR_DSIZE() uint16 {
	return volatile.LoadUint16(&o.TCD1_ATTR.Reg) & 0x7
}
func (o *DMA_Type) SetTCD1_ATTR_DMOD(value uint16) {
	volatile.StoreUint16(&o.TCD1_ATTR.Reg, volatile.LoadUint16(&o.TCD1_ATTR.Reg)&^(0xf8)|value<<3)
}
func (o *DMA_Type) GetTCD1_ATTR_DMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD1_ATTR.Reg) & 0xf8) >> 3
}
func (o *DMA_Type) SetTCD1_ATTR_SSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD1_ATTR.Reg, volatile.LoadUint16(&o.TCD1_ATTR.Reg)&^(0x700)|value<<8)
}
func (o *DMA_Type) GetTCD1_ATTR_SSIZE() uint16 {
	return (volatile.LoadUint16(&o.TCD1_ATTR.Reg) & 0x700) >> 8
}
func (o *DMA_Type) SetTCD1_ATTR_SMOD(value uint16) {
	volatile.StoreUint16(&o.TCD1_ATTR.Reg, volatile.LoadUint16(&o.TCD1_ATTR.Reg)&^(0xf800)|value<<11)
}
func (o *DMA_Type) GetTCD1_ATTR_SMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD1_ATTR.Reg) & 0xf800) >> 11
}

// DMA.TCD1_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Disabled)
func (o *DMA_Type) SetTCD1_NBYTES_MLNO(value uint32) {
	volatile.StoreUint32(&o.TCD1_NBYTES_MLNO.Reg, value)
}
func (o *DMA_Type) GetTCD1_NBYTES_MLNO() uint32 {
	return volatile.LoadUint32(&o.TCD1_NBYTES_MLNO.Reg)
}

// DMA.TCD1_SLAST: TCD Last Source Address Adjustment
func (o *DMA_Type) SetTCD1_SLAST(value uint32) {
	volatile.StoreUint32(&o.TCD1_SLAST.Reg, value)
}
func (o *DMA_Type) GetTCD1_SLAST() uint32 {
	return volatile.LoadUint32(&o.TCD1_SLAST.Reg)
}

// DMA.TCD1_DADDR: TCD Destination Address
func (o *DMA_Type) SetTCD1_DADDR(value uint32) {
	volatile.StoreUint32(&o.TCD1_DADDR.Reg, value)
}
func (o *DMA_Type) GetTCD1_DADDR() uint32 {
	return volatile.LoadUint32(&o.TCD1_DADDR.Reg)
}

// DMA.TCD1_DOFF: TCD Signed Destination Address Offset
func (o *DMA_Type) SetTCD1_DOFF(value uint16) {
	volatile.StoreUint16(&o.TCD1_DOFF.Reg, value)
}
func (o *DMA_Type) GetTCD1_DOFF() uint16 {
	return volatile.LoadUint16(&o.TCD1_DOFF.Reg)
}

// DMA.TCD1_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD1_CITER_ELINKNO_CITER(value uint16) {
	volatile.StoreUint16(&o.TCD1_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD1_CITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD1_CITER_ELINKNO_CITER() uint16 {
	return volatile.LoadUint16(&o.TCD1_CITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD1_CITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD1_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD1_CITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD1_CITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD1_CITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD1_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
func (o *DMA_Type) SetTCD1_DLASTSGA(value uint32) {
	volatile.StoreUint32(&o.TCD1_DLASTSGA.Reg, value)
}
func (o *DMA_Type) GetTCD1_DLASTSGA() uint32 {
	return volatile.LoadUint32(&o.TCD1_DLASTSGA.Reg)
}

// DMA.TCD1_CSR: TCD Control and Status
func (o *DMA_Type) SetTCD1_CSR_START(value uint16) {
	volatile.StoreUint16(&o.TCD1_CSR.Reg, volatile.LoadUint16(&o.TCD1_CSR.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetTCD1_CSR_START() uint16 {
	return volatile.LoadUint16(&o.TCD1_CSR.Reg) & 0x1
}
func (o *DMA_Type) SetTCD1_CSR_INTMAJOR(value uint16) {
	volatile.StoreUint16(&o.TCD1_CSR.Reg, volatile.LoadUint16(&o.TCD1_CSR.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetTCD1_CSR_INTMAJOR() uint16 {
	return (volatile.LoadUint16(&o.TCD1_CSR.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetTCD1_CSR_INTHALF(value uint16) {
	volatile.StoreUint16(&o.TCD1_CSR.Reg, volatile.LoadUint16(&o.TCD1_CSR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetTCD1_CSR_INTHALF() uint16 {
	return (volatile.LoadUint16(&o.TCD1_CSR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetTCD1_CSR_DREQ(value uint16) {
	volatile.StoreUint16(&o.TCD1_CSR.Reg, volatile.LoadUint16(&o.TCD1_CSR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetTCD1_CSR_DREQ() uint16 {
	return (volatile.LoadUint16(&o.TCD1_CSR.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetTCD1_CSR_ESG(value uint16) {
	volatile.StoreUint16(&o.TCD1_CSR.Reg, volatile.LoadUint16(&o.TCD1_CSR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetTCD1_CSR_ESG() uint16 {
	return (volatile.LoadUint16(&o.TCD1_CSR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetTCD1_CSR_MAJORELINK(value uint16) {
	volatile.StoreUint16(&o.TCD1_CSR.Reg, volatile.LoadUint16(&o.TCD1_CSR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetTCD1_CSR_MAJORELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD1_CSR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetTCD1_CSR_ACTIVE(value uint16) {
	volatile.StoreUint16(&o.TCD1_CSR.Reg, volatile.LoadUint16(&o.TCD1_CSR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetTCD1_CSR_ACTIVE() uint16 {
	return (volatile.LoadUint16(&o.TCD1_CSR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetTCD1_CSR_DONE(value uint16) {
	volatile.StoreUint16(&o.TCD1_CSR.Reg, volatile.LoadUint16(&o.TCD1_CSR.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetTCD1_CSR_DONE() uint16 {
	return (volatile.LoadUint16(&o.TCD1_CSR.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetTCD1_CSR_MAJORLINKCH(value uint16) {
	volatile.StoreUint16(&o.TCD1_CSR.Reg, volatile.LoadUint16(&o.TCD1_CSR.Reg)&^(0xf00)|value<<8)
}
func (o *DMA_Type) GetTCD1_CSR_MAJORLINKCH() uint16 {
	return (volatile.LoadUint16(&o.TCD1_CSR.Reg) & 0xf00) >> 8
}
func (o *DMA_Type) SetTCD1_CSR_BWC(value uint16) {
	volatile.StoreUint16(&o.TCD1_CSR.Reg, volatile.LoadUint16(&o.TCD1_CSR.Reg)&^(0xc000)|value<<14)
}
func (o *DMA_Type) GetTCD1_CSR_BWC() uint16 {
	return (volatile.LoadUint16(&o.TCD1_CSR.Reg) & 0xc000) >> 14
}

// DMA.TCD1_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD1_BITER_ELINKNO_BITER(value uint16) {
	volatile.StoreUint16(&o.TCD1_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD1_BITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD1_BITER_ELINKNO_BITER() uint16 {
	return volatile.LoadUint16(&o.TCD1_BITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD1_BITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD1_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD1_BITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD1_BITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD1_BITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD2_SADDR: TCD Source Address
func (o *DMA_Type) SetTCD2_SADDR(value uint32) {
	volatile.StoreUint32(&o.TCD2_SADDR.Reg, value)
}
func (o *DMA_Type) GetTCD2_SADDR() uint32 {
	return volatile.LoadUint32(&o.TCD2_SADDR.Reg)
}

// DMA.TCD2_SOFF: TCD Signed Source Address Offset
func (o *DMA_Type) SetTCD2_SOFF(value uint16) {
	volatile.StoreUint16(&o.TCD2_SOFF.Reg, value)
}
func (o *DMA_Type) GetTCD2_SOFF() uint16 {
	return volatile.LoadUint16(&o.TCD2_SOFF.Reg)
}

// DMA.TCD2_ATTR: TCD Transfer Attributes
func (o *DMA_Type) SetTCD2_ATTR_DSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD2_ATTR.Reg, volatile.LoadUint16(&o.TCD2_ATTR.Reg)&^(0x7)|value)
}
func (o *DMA_Type) GetTCD2_ATTR_DSIZE() uint16 {
	return volatile.LoadUint16(&o.TCD2_ATTR.Reg) & 0x7
}
func (o *DMA_Type) SetTCD2_ATTR_DMOD(value uint16) {
	volatile.StoreUint16(&o.TCD2_ATTR.Reg, volatile.LoadUint16(&o.TCD2_ATTR.Reg)&^(0xf8)|value<<3)
}
func (o *DMA_Type) GetTCD2_ATTR_DMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD2_ATTR.Reg) & 0xf8) >> 3
}
func (o *DMA_Type) SetTCD2_ATTR_SSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD2_ATTR.Reg, volatile.LoadUint16(&o.TCD2_ATTR.Reg)&^(0x700)|value<<8)
}
func (o *DMA_Type) GetTCD2_ATTR_SSIZE() uint16 {
	return (volatile.LoadUint16(&o.TCD2_ATTR.Reg) & 0x700) >> 8
}
func (o *DMA_Type) SetTCD2_ATTR_SMOD(value uint16) {
	volatile.StoreUint16(&o.TCD2_ATTR.Reg, volatile.LoadUint16(&o.TCD2_ATTR.Reg)&^(0xf800)|value<<11)
}
func (o *DMA_Type) GetTCD2_ATTR_SMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD2_ATTR.Reg) & 0xf800) >> 11
}

// DMA.TCD2_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Disabled)
func (o *DMA_Type) SetTCD2_NBYTES_MLNO(value uint32) {
	volatile.StoreUint32(&o.TCD2_NBYTES_MLNO.Reg, value)
}
func (o *DMA_Type) GetTCD2_NBYTES_MLNO() uint32 {
	return volatile.LoadUint32(&o.TCD2_NBYTES_MLNO.Reg)
}

// DMA.TCD2_SLAST: TCD Last Source Address Adjustment
func (o *DMA_Type) SetTCD2_SLAST(value uint32) {
	volatile.StoreUint32(&o.TCD2_SLAST.Reg, value)
}
func (o *DMA_Type) GetTCD2_SLAST() uint32 {
	return volatile.LoadUint32(&o.TCD2_SLAST.Reg)
}

// DMA.TCD2_DADDR: TCD Destination Address
func (o *DMA_Type) SetTCD2_DADDR(value uint32) {
	volatile.StoreUint32(&o.TCD2_DADDR.Reg, value)
}
func (o *DMA_Type) GetTCD2_DADDR() uint32 {
	return volatile.LoadUint32(&o.TCD2_DADDR.Reg)
}

// DMA.TCD2_DOFF: TCD Signed Destination Address Offset
func (o *DMA_Type) SetTCD2_DOFF(value uint16) {
	volatile.StoreUint16(&o.TCD2_DOFF.Reg, value)
}
func (o *DMA_Type) GetTCD2_DOFF() uint16 {
	return volatile.LoadUint16(&o.TCD2_DOFF.Reg)
}

// DMA.TCD2_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD2_CITER_ELINKNO_CITER(value uint16) {
	volatile.StoreUint16(&o.TCD2_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD2_CITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD2_CITER_ELINKNO_CITER() uint16 {
	return volatile.LoadUint16(&o.TCD2_CITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD2_CITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD2_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD2_CITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD2_CITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD2_CITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD2_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
func (o *DMA_Type) SetTCD2_DLASTSGA(value uint32) {
	volatile.StoreUint32(&o.TCD2_DLASTSGA.Reg, value)
}
func (o *DMA_Type) GetTCD2_DLASTSGA() uint32 {
	return volatile.LoadUint32(&o.TCD2_DLASTSGA.Reg)
}

// DMA.TCD2_CSR: TCD Control and Status
func (o *DMA_Type) SetTCD2_CSR_START(value uint16) {
	volatile.StoreUint16(&o.TCD2_CSR.Reg, volatile.LoadUint16(&o.TCD2_CSR.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetTCD2_CSR_START() uint16 {
	return volatile.LoadUint16(&o.TCD2_CSR.Reg) & 0x1
}
func (o *DMA_Type) SetTCD2_CSR_INTMAJOR(value uint16) {
	volatile.StoreUint16(&o.TCD2_CSR.Reg, volatile.LoadUint16(&o.TCD2_CSR.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetTCD2_CSR_INTMAJOR() uint16 {
	return (volatile.LoadUint16(&o.TCD2_CSR.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetTCD2_CSR_INTHALF(value uint16) {
	volatile.StoreUint16(&o.TCD2_CSR.Reg, volatile.LoadUint16(&o.TCD2_CSR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetTCD2_CSR_INTHALF() uint16 {
	return (volatile.LoadUint16(&o.TCD2_CSR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetTCD2_CSR_DREQ(value uint16) {
	volatile.StoreUint16(&o.TCD2_CSR.Reg, volatile.LoadUint16(&o.TCD2_CSR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetTCD2_CSR_DREQ() uint16 {
	return (volatile.LoadUint16(&o.TCD2_CSR.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetTCD2_CSR_ESG(value uint16) {
	volatile.StoreUint16(&o.TCD2_CSR.Reg, volatile.LoadUint16(&o.TCD2_CSR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetTCD2_CSR_ESG() uint16 {
	return (volatile.LoadUint16(&o.TCD2_CSR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetTCD2_CSR_MAJORELINK(value uint16) {
	volatile.StoreUint16(&o.TCD2_CSR.Reg, volatile.LoadUint16(&o.TCD2_CSR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetTCD2_CSR_MAJORELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD2_CSR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetTCD2_CSR_ACTIVE(value uint16) {
	volatile.StoreUint16(&o.TCD2_CSR.Reg, volatile.LoadUint16(&o.TCD2_CSR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetTCD2_CSR_ACTIVE() uint16 {
	return (volatile.LoadUint16(&o.TCD2_CSR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetTCD2_CSR_DONE(value uint16) {
	volatile.StoreUint16(&o.TCD2_CSR.Reg, volatile.LoadUint16(&o.TCD2_CSR.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetTCD2_CSR_DONE() uint16 {
	return (volatile.LoadUint16(&o.TCD2_CSR.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetTCD2_CSR_MAJORLINKCH(value uint16) {
	volatile.StoreUint16(&o.TCD2_CSR.Reg, volatile.LoadUint16(&o.TCD2_CSR.Reg)&^(0xf00)|value<<8)
}
func (o *DMA_Type) GetTCD2_CSR_MAJORLINKCH() uint16 {
	return (volatile.LoadUint16(&o.TCD2_CSR.Reg) & 0xf00) >> 8
}
func (o *DMA_Type) SetTCD2_CSR_BWC(value uint16) {
	volatile.StoreUint16(&o.TCD2_CSR.Reg, volatile.LoadUint16(&o.TCD2_CSR.Reg)&^(0xc000)|value<<14)
}
func (o *DMA_Type) GetTCD2_CSR_BWC() uint16 {
	return (volatile.LoadUint16(&o.TCD2_CSR.Reg) & 0xc000) >> 14
}

// DMA.TCD2_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD2_BITER_ELINKNO_BITER(value uint16) {
	volatile.StoreUint16(&o.TCD2_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD2_BITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD2_BITER_ELINKNO_BITER() uint16 {
	return volatile.LoadUint16(&o.TCD2_BITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD2_BITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD2_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD2_BITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD2_BITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD2_BITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD3_SADDR: TCD Source Address
func (o *DMA_Type) SetTCD3_SADDR(value uint32) {
	volatile.StoreUint32(&o.TCD3_SADDR.Reg, value)
}
func (o *DMA_Type) GetTCD3_SADDR() uint32 {
	return volatile.LoadUint32(&o.TCD3_SADDR.Reg)
}

// DMA.TCD3_SOFF: TCD Signed Source Address Offset
func (o *DMA_Type) SetTCD3_SOFF(value uint16) {
	volatile.StoreUint16(&o.TCD3_SOFF.Reg, value)
}
func (o *DMA_Type) GetTCD3_SOFF() uint16 {
	return volatile.LoadUint16(&o.TCD3_SOFF.Reg)
}

// DMA.TCD3_ATTR: TCD Transfer Attributes
func (o *DMA_Type) SetTCD3_ATTR_DSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD3_ATTR.Reg, volatile.LoadUint16(&o.TCD3_ATTR.Reg)&^(0x7)|value)
}
func (o *DMA_Type) GetTCD3_ATTR_DSIZE() uint16 {
	return volatile.LoadUint16(&o.TCD3_ATTR.Reg) & 0x7
}
func (o *DMA_Type) SetTCD3_ATTR_DMOD(value uint16) {
	volatile.StoreUint16(&o.TCD3_ATTR.Reg, volatile.LoadUint16(&o.TCD3_ATTR.Reg)&^(0xf8)|value<<3)
}
func (o *DMA_Type) GetTCD3_ATTR_DMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD3_ATTR.Reg) & 0xf8) >> 3
}
func (o *DMA_Type) SetTCD3_ATTR_SSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD3_ATTR.Reg, volatile.LoadUint16(&o.TCD3_ATTR.Reg)&^(0x700)|value<<8)
}
func (o *DMA_Type) GetTCD3_ATTR_SSIZE() uint16 {
	return (volatile.LoadUint16(&o.TCD3_ATTR.Reg) & 0x700) >> 8
}
func (o *DMA_Type) SetTCD3_ATTR_SMOD(value uint16) {
	volatile.StoreUint16(&o.TCD3_ATTR.Reg, volatile.LoadUint16(&o.TCD3_ATTR.Reg)&^(0xf800)|value<<11)
}
func (o *DMA_Type) GetTCD3_ATTR_SMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD3_ATTR.Reg) & 0xf800) >> 11
}

// DMA.TCD3_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Disabled)
func (o *DMA_Type) SetTCD3_NBYTES_MLNO(value uint32) {
	volatile.StoreUint32(&o.TCD3_NBYTES_MLNO.Reg, value)
}
func (o *DMA_Type) GetTCD3_NBYTES_MLNO() uint32 {
	return volatile.LoadUint32(&o.TCD3_NBYTES_MLNO.Reg)
}

// DMA.TCD3_SLAST: TCD Last Source Address Adjustment
func (o *DMA_Type) SetTCD3_SLAST(value uint32) {
	volatile.StoreUint32(&o.TCD3_SLAST.Reg, value)
}
func (o *DMA_Type) GetTCD3_SLAST() uint32 {
	return volatile.LoadUint32(&o.TCD3_SLAST.Reg)
}

// DMA.TCD3_DADDR: TCD Destination Address
func (o *DMA_Type) SetTCD3_DADDR(value uint32) {
	volatile.StoreUint32(&o.TCD3_DADDR.Reg, value)
}
func (o *DMA_Type) GetTCD3_DADDR() uint32 {
	return volatile.LoadUint32(&o.TCD3_DADDR.Reg)
}

// DMA.TCD3_DOFF: TCD Signed Destination Address Offset
func (o *DMA_Type) SetTCD3_DOFF(value uint16) {
	volatile.StoreUint16(&o.TCD3_DOFF.Reg, value)
}
func (o *DMA_Type) GetTCD3_DOFF() uint16 {
	return volatile.LoadUint16(&o.TCD3_DOFF.Reg)
}

// DMA.TCD3_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD3_CITER_ELINKNO_CITER(value uint16) {
	volatile.StoreUint16(&o.TCD3_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD3_CITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD3_CITER_ELINKNO_CITER() uint16 {
	return volatile.LoadUint16(&o.TCD3_CITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD3_CITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD3_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD3_CITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD3_CITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD3_CITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD3_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
func (o *DMA_Type) SetTCD3_DLASTSGA(value uint32) {
	volatile.StoreUint32(&o.TCD3_DLASTSGA.Reg, value)
}
func (o *DMA_Type) GetTCD3_DLASTSGA() uint32 {
	return volatile.LoadUint32(&o.TCD3_DLASTSGA.Reg)
}

// DMA.TCD3_CSR: TCD Control and Status
func (o *DMA_Type) SetTCD3_CSR_START(value uint16) {
	volatile.StoreUint16(&o.TCD3_CSR.Reg, volatile.LoadUint16(&o.TCD3_CSR.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetTCD3_CSR_START() uint16 {
	return volatile.LoadUint16(&o.TCD3_CSR.Reg) & 0x1
}
func (o *DMA_Type) SetTCD3_CSR_INTMAJOR(value uint16) {
	volatile.StoreUint16(&o.TCD3_CSR.Reg, volatile.LoadUint16(&o.TCD3_CSR.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetTCD3_CSR_INTMAJOR() uint16 {
	return (volatile.LoadUint16(&o.TCD3_CSR.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetTCD3_CSR_INTHALF(value uint16) {
	volatile.StoreUint16(&o.TCD3_CSR.Reg, volatile.LoadUint16(&o.TCD3_CSR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetTCD3_CSR_INTHALF() uint16 {
	return (volatile.LoadUint16(&o.TCD3_CSR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetTCD3_CSR_DREQ(value uint16) {
	volatile.StoreUint16(&o.TCD3_CSR.Reg, volatile.LoadUint16(&o.TCD3_CSR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetTCD3_CSR_DREQ() uint16 {
	return (volatile.LoadUint16(&o.TCD3_CSR.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetTCD3_CSR_ESG(value uint16) {
	volatile.StoreUint16(&o.TCD3_CSR.Reg, volatile.LoadUint16(&o.TCD3_CSR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetTCD3_CSR_ESG() uint16 {
	return (volatile.LoadUint16(&o.TCD3_CSR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetTCD3_CSR_MAJORELINK(value uint16) {
	volatile.StoreUint16(&o.TCD3_CSR.Reg, volatile.LoadUint16(&o.TCD3_CSR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetTCD3_CSR_MAJORELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD3_CSR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetTCD3_CSR_ACTIVE(value uint16) {
	volatile.StoreUint16(&o.TCD3_CSR.Reg, volatile.LoadUint16(&o.TCD3_CSR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetTCD3_CSR_ACTIVE() uint16 {
	return (volatile.LoadUint16(&o.TCD3_CSR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetTCD3_CSR_DONE(value uint16) {
	volatile.StoreUint16(&o.TCD3_CSR.Reg, volatile.LoadUint16(&o.TCD3_CSR.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetTCD3_CSR_DONE() uint16 {
	return (volatile.LoadUint16(&o.TCD3_CSR.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetTCD3_CSR_MAJORLINKCH(value uint16) {
	volatile.StoreUint16(&o.TCD3_CSR.Reg, volatile.LoadUint16(&o.TCD3_CSR.Reg)&^(0xf00)|value<<8)
}
func (o *DMA_Type) GetTCD3_CSR_MAJORLINKCH() uint16 {
	return (volatile.LoadUint16(&o.TCD3_CSR.Reg) & 0xf00) >> 8
}
func (o *DMA_Type) SetTCD3_CSR_BWC(value uint16) {
	volatile.StoreUint16(&o.TCD3_CSR.Reg, volatile.LoadUint16(&o.TCD3_CSR.Reg)&^(0xc000)|value<<14)
}
func (o *DMA_Type) GetTCD3_CSR_BWC() uint16 {
	return (volatile.LoadUint16(&o.TCD3_CSR.Reg) & 0xc000) >> 14
}

// DMA.TCD3_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD3_BITER_ELINKNO_BITER(value uint16) {
	volatile.StoreUint16(&o.TCD3_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD3_BITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD3_BITER_ELINKNO_BITER() uint16 {
	return volatile.LoadUint16(&o.TCD3_BITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD3_BITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD3_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD3_BITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD3_BITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD3_BITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD4_SADDR: TCD Source Address
func (o *DMA_Type) SetTCD4_SADDR(value uint32) {
	volatile.StoreUint32(&o.TCD4_SADDR.Reg, value)
}
func (o *DMA_Type) GetTCD4_SADDR() uint32 {
	return volatile.LoadUint32(&o.TCD4_SADDR.Reg)
}

// DMA.TCD4_SOFF: TCD Signed Source Address Offset
func (o *DMA_Type) SetTCD4_SOFF(value uint16) {
	volatile.StoreUint16(&o.TCD4_SOFF.Reg, value)
}
func (o *DMA_Type) GetTCD4_SOFF() uint16 {
	return volatile.LoadUint16(&o.TCD4_SOFF.Reg)
}

// DMA.TCD4_ATTR: TCD Transfer Attributes
func (o *DMA_Type) SetTCD4_ATTR_DSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD4_ATTR.Reg, volatile.LoadUint16(&o.TCD4_ATTR.Reg)&^(0x7)|value)
}
func (o *DMA_Type) GetTCD4_ATTR_DSIZE() uint16 {
	return volatile.LoadUint16(&o.TCD4_ATTR.Reg) & 0x7
}
func (o *DMA_Type) SetTCD4_ATTR_DMOD(value uint16) {
	volatile.StoreUint16(&o.TCD4_ATTR.Reg, volatile.LoadUint16(&o.TCD4_ATTR.Reg)&^(0xf8)|value<<3)
}
func (o *DMA_Type) GetTCD4_ATTR_DMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD4_ATTR.Reg) & 0xf8) >> 3
}
func (o *DMA_Type) SetTCD4_ATTR_SSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD4_ATTR.Reg, volatile.LoadUint16(&o.TCD4_ATTR.Reg)&^(0x700)|value<<8)
}
func (o *DMA_Type) GetTCD4_ATTR_SSIZE() uint16 {
	return (volatile.LoadUint16(&o.TCD4_ATTR.Reg) & 0x700) >> 8
}
func (o *DMA_Type) SetTCD4_ATTR_SMOD(value uint16) {
	volatile.StoreUint16(&o.TCD4_ATTR.Reg, volatile.LoadUint16(&o.TCD4_ATTR.Reg)&^(0xf800)|value<<11)
}
func (o *DMA_Type) GetTCD4_ATTR_SMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD4_ATTR.Reg) & 0xf800) >> 11
}

// DMA.TCD4_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Disabled)
func (o *DMA_Type) SetTCD4_NBYTES_MLNO(value uint32) {
	volatile.StoreUint32(&o.TCD4_NBYTES_MLNO.Reg, value)
}
func (o *DMA_Type) GetTCD4_NBYTES_MLNO() uint32 {
	return volatile.LoadUint32(&o.TCD4_NBYTES_MLNO.Reg)
}

// DMA.TCD4_SLAST: TCD Last Source Address Adjustment
func (o *DMA_Type) SetTCD4_SLAST(value uint32) {
	volatile.StoreUint32(&o.TCD4_SLAST.Reg, value)
}
func (o *DMA_Type) GetTCD4_SLAST() uint32 {
	return volatile.LoadUint32(&o.TCD4_SLAST.Reg)
}

// DMA.TCD4_DADDR: TCD Destination Address
func (o *DMA_Type) SetTCD4_DADDR(value uint32) {
	volatile.StoreUint32(&o.TCD4_DADDR.Reg, value)
}
func (o *DMA_Type) GetTCD4_DADDR() uint32 {
	return volatile.LoadUint32(&o.TCD4_DADDR.Reg)
}

// DMA.TCD4_DOFF: TCD Signed Destination Address Offset
func (o *DMA_Type) SetTCD4_DOFF(value uint16) {
	volatile.StoreUint16(&o.TCD4_DOFF.Reg, value)
}
func (o *DMA_Type) GetTCD4_DOFF() uint16 {
	return volatile.LoadUint16(&o.TCD4_DOFF.Reg)
}

// DMA.TCD4_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD4_CITER_ELINKNO_CITER(value uint16) {
	volatile.StoreUint16(&o.TCD4_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD4_CITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD4_CITER_ELINKNO_CITER() uint16 {
	return volatile.LoadUint16(&o.TCD4_CITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD4_CITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD4_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD4_CITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD4_CITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD4_CITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD4_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
func (o *DMA_Type) SetTCD4_DLASTSGA(value uint32) {
	volatile.StoreUint32(&o.TCD4_DLASTSGA.Reg, value)
}
func (o *DMA_Type) GetTCD4_DLASTSGA() uint32 {
	return volatile.LoadUint32(&o.TCD4_DLASTSGA.Reg)
}

// DMA.TCD4_CSR: TCD Control and Status
func (o *DMA_Type) SetTCD4_CSR_START(value uint16) {
	volatile.StoreUint16(&o.TCD4_CSR.Reg, volatile.LoadUint16(&o.TCD4_CSR.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetTCD4_CSR_START() uint16 {
	return volatile.LoadUint16(&o.TCD4_CSR.Reg) & 0x1
}
func (o *DMA_Type) SetTCD4_CSR_INTMAJOR(value uint16) {
	volatile.StoreUint16(&o.TCD4_CSR.Reg, volatile.LoadUint16(&o.TCD4_CSR.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetTCD4_CSR_INTMAJOR() uint16 {
	return (volatile.LoadUint16(&o.TCD4_CSR.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetTCD4_CSR_INTHALF(value uint16) {
	volatile.StoreUint16(&o.TCD4_CSR.Reg, volatile.LoadUint16(&o.TCD4_CSR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetTCD4_CSR_INTHALF() uint16 {
	return (volatile.LoadUint16(&o.TCD4_CSR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetTCD4_CSR_DREQ(value uint16) {
	volatile.StoreUint16(&o.TCD4_CSR.Reg, volatile.LoadUint16(&o.TCD4_CSR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetTCD4_CSR_DREQ() uint16 {
	return (volatile.LoadUint16(&o.TCD4_CSR.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetTCD4_CSR_ESG(value uint16) {
	volatile.StoreUint16(&o.TCD4_CSR.Reg, volatile.LoadUint16(&o.TCD4_CSR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetTCD4_CSR_ESG() uint16 {
	return (volatile.LoadUint16(&o.TCD4_CSR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetTCD4_CSR_MAJORELINK(value uint16) {
	volatile.StoreUint16(&o.TCD4_CSR.Reg, volatile.LoadUint16(&o.TCD4_CSR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetTCD4_CSR_MAJORELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD4_CSR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetTCD4_CSR_ACTIVE(value uint16) {
	volatile.StoreUint16(&o.TCD4_CSR.Reg, volatile.LoadUint16(&o.TCD4_CSR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetTCD4_CSR_ACTIVE() uint16 {
	return (volatile.LoadUint16(&o.TCD4_CSR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetTCD4_CSR_DONE(value uint16) {
	volatile.StoreUint16(&o.TCD4_CSR.Reg, volatile.LoadUint16(&o.TCD4_CSR.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetTCD4_CSR_DONE() uint16 {
	return (volatile.LoadUint16(&o.TCD4_CSR.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetTCD4_CSR_MAJORLINKCH(value uint16) {
	volatile.StoreUint16(&o.TCD4_CSR.Reg, volatile.LoadUint16(&o.TCD4_CSR.Reg)&^(0xf00)|value<<8)
}
func (o *DMA_Type) GetTCD4_CSR_MAJORLINKCH() uint16 {
	return (volatile.LoadUint16(&o.TCD4_CSR.Reg) & 0xf00) >> 8
}
func (o *DMA_Type) SetTCD4_CSR_BWC(value uint16) {
	volatile.StoreUint16(&o.TCD4_CSR.Reg, volatile.LoadUint16(&o.TCD4_CSR.Reg)&^(0xc000)|value<<14)
}
func (o *DMA_Type) GetTCD4_CSR_BWC() uint16 {
	return (volatile.LoadUint16(&o.TCD4_CSR.Reg) & 0xc000) >> 14
}

// DMA.TCD4_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD4_BITER_ELINKNO_BITER(value uint16) {
	volatile.StoreUint16(&o.TCD4_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD4_BITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD4_BITER_ELINKNO_BITER() uint16 {
	return volatile.LoadUint16(&o.TCD4_BITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD4_BITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD4_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD4_BITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD4_BITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD4_BITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD5_SADDR: TCD Source Address
func (o *DMA_Type) SetTCD5_SADDR(value uint32) {
	volatile.StoreUint32(&o.TCD5_SADDR.Reg, value)
}
func (o *DMA_Type) GetTCD5_SADDR() uint32 {
	return volatile.LoadUint32(&o.TCD5_SADDR.Reg)
}

// DMA.TCD5_SOFF: TCD Signed Source Address Offset
func (o *DMA_Type) SetTCD5_SOFF(value uint16) {
	volatile.StoreUint16(&o.TCD5_SOFF.Reg, value)
}
func (o *DMA_Type) GetTCD5_SOFF() uint16 {
	return volatile.LoadUint16(&o.TCD5_SOFF.Reg)
}

// DMA.TCD5_ATTR: TCD Transfer Attributes
func (o *DMA_Type) SetTCD5_ATTR_DSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD5_ATTR.Reg, volatile.LoadUint16(&o.TCD5_ATTR.Reg)&^(0x7)|value)
}
func (o *DMA_Type) GetTCD5_ATTR_DSIZE() uint16 {
	return volatile.LoadUint16(&o.TCD5_ATTR.Reg) & 0x7
}
func (o *DMA_Type) SetTCD5_ATTR_DMOD(value uint16) {
	volatile.StoreUint16(&o.TCD5_ATTR.Reg, volatile.LoadUint16(&o.TCD5_ATTR.Reg)&^(0xf8)|value<<3)
}
func (o *DMA_Type) GetTCD5_ATTR_DMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD5_ATTR.Reg) & 0xf8) >> 3
}
func (o *DMA_Type) SetTCD5_ATTR_SSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD5_ATTR.Reg, volatile.LoadUint16(&o.TCD5_ATTR.Reg)&^(0x700)|value<<8)
}
func (o *DMA_Type) GetTCD5_ATTR_SSIZE() uint16 {
	return (volatile.LoadUint16(&o.TCD5_ATTR.Reg) & 0x700) >> 8
}
func (o *DMA_Type) SetTCD5_ATTR_SMOD(value uint16) {
	volatile.StoreUint16(&o.TCD5_ATTR.Reg, volatile.LoadUint16(&o.TCD5_ATTR.Reg)&^(0xf800)|value<<11)
}
func (o *DMA_Type) GetTCD5_ATTR_SMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD5_ATTR.Reg) & 0xf800) >> 11
}

// DMA.TCD5_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Disabled)
func (o *DMA_Type) SetTCD5_NBYTES_MLNO(value uint32) {
	volatile.StoreUint32(&o.TCD5_NBYTES_MLNO.Reg, value)
}
func (o *DMA_Type) GetTCD5_NBYTES_MLNO() uint32 {
	return volatile.LoadUint32(&o.TCD5_NBYTES_MLNO.Reg)
}

// DMA.TCD5_SLAST: TCD Last Source Address Adjustment
func (o *DMA_Type) SetTCD5_SLAST(value uint32) {
	volatile.StoreUint32(&o.TCD5_SLAST.Reg, value)
}
func (o *DMA_Type) GetTCD5_SLAST() uint32 {
	return volatile.LoadUint32(&o.TCD5_SLAST.Reg)
}

// DMA.TCD5_DADDR: TCD Destination Address
func (o *DMA_Type) SetTCD5_DADDR(value uint32) {
	volatile.StoreUint32(&o.TCD5_DADDR.Reg, value)
}
func (o *DMA_Type) GetTCD5_DADDR() uint32 {
	return volatile.LoadUint32(&o.TCD5_DADDR.Reg)
}

// DMA.TCD5_DOFF: TCD Signed Destination Address Offset
func (o *DMA_Type) SetTCD5_DOFF(value uint16) {
	volatile.StoreUint16(&o.TCD5_DOFF.Reg, value)
}
func (o *DMA_Type) GetTCD5_DOFF() uint16 {
	return volatile.LoadUint16(&o.TCD5_DOFF.Reg)
}

// DMA.TCD5_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD5_CITER_ELINKNO_CITER(value uint16) {
	volatile.StoreUint16(&o.TCD5_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD5_CITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD5_CITER_ELINKNO_CITER() uint16 {
	return volatile.LoadUint16(&o.TCD5_CITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD5_CITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD5_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD5_CITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD5_CITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD5_CITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD5_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
func (o *DMA_Type) SetTCD5_DLASTSGA(value uint32) {
	volatile.StoreUint32(&o.TCD5_DLASTSGA.Reg, value)
}
func (o *DMA_Type) GetTCD5_DLASTSGA() uint32 {
	return volatile.LoadUint32(&o.TCD5_DLASTSGA.Reg)
}

// DMA.TCD5_CSR: TCD Control and Status
func (o *DMA_Type) SetTCD5_CSR_START(value uint16) {
	volatile.StoreUint16(&o.TCD5_CSR.Reg, volatile.LoadUint16(&o.TCD5_CSR.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetTCD5_CSR_START() uint16 {
	return volatile.LoadUint16(&o.TCD5_CSR.Reg) & 0x1
}
func (o *DMA_Type) SetTCD5_CSR_INTMAJOR(value uint16) {
	volatile.StoreUint16(&o.TCD5_CSR.Reg, volatile.LoadUint16(&o.TCD5_CSR.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetTCD5_CSR_INTMAJOR() uint16 {
	return (volatile.LoadUint16(&o.TCD5_CSR.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetTCD5_CSR_INTHALF(value uint16) {
	volatile.StoreUint16(&o.TCD5_CSR.Reg, volatile.LoadUint16(&o.TCD5_CSR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetTCD5_CSR_INTHALF() uint16 {
	return (volatile.LoadUint16(&o.TCD5_CSR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetTCD5_CSR_DREQ(value uint16) {
	volatile.StoreUint16(&o.TCD5_CSR.Reg, volatile.LoadUint16(&o.TCD5_CSR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetTCD5_CSR_DREQ() uint16 {
	return (volatile.LoadUint16(&o.TCD5_CSR.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetTCD5_CSR_ESG(value uint16) {
	volatile.StoreUint16(&o.TCD5_CSR.Reg, volatile.LoadUint16(&o.TCD5_CSR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetTCD5_CSR_ESG() uint16 {
	return (volatile.LoadUint16(&o.TCD5_CSR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetTCD5_CSR_MAJORELINK(value uint16) {
	volatile.StoreUint16(&o.TCD5_CSR.Reg, volatile.LoadUint16(&o.TCD5_CSR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetTCD5_CSR_MAJORELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD5_CSR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetTCD5_CSR_ACTIVE(value uint16) {
	volatile.StoreUint16(&o.TCD5_CSR.Reg, volatile.LoadUint16(&o.TCD5_CSR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetTCD5_CSR_ACTIVE() uint16 {
	return (volatile.LoadUint16(&o.TCD5_CSR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetTCD5_CSR_DONE(value uint16) {
	volatile.StoreUint16(&o.TCD5_CSR.Reg, volatile.LoadUint16(&o.TCD5_CSR.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetTCD5_CSR_DONE() uint16 {
	return (volatile.LoadUint16(&o.TCD5_CSR.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetTCD5_CSR_MAJORLINKCH(value uint16) {
	volatile.StoreUint16(&o.TCD5_CSR.Reg, volatile.LoadUint16(&o.TCD5_CSR.Reg)&^(0xf00)|value<<8)
}
func (o *DMA_Type) GetTCD5_CSR_MAJORLINKCH() uint16 {
	return (volatile.LoadUint16(&o.TCD5_CSR.Reg) & 0xf00) >> 8
}
func (o *DMA_Type) SetTCD5_CSR_BWC(value uint16) {
	volatile.StoreUint16(&o.TCD5_CSR.Reg, volatile.LoadUint16(&o.TCD5_CSR.Reg)&^(0xc000)|value<<14)
}
func (o *DMA_Type) GetTCD5_CSR_BWC() uint16 {
	return (volatile.LoadUint16(&o.TCD5_CSR.Reg) & 0xc000) >> 14
}

// DMA.TCD5_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD5_BITER_ELINKNO_BITER(value uint16) {
	volatile.StoreUint16(&o.TCD5_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD5_BITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD5_BITER_ELINKNO_BITER() uint16 {
	return volatile.LoadUint16(&o.TCD5_BITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD5_BITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD5_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD5_BITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD5_BITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD5_BITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD6_SADDR: TCD Source Address
func (o *DMA_Type) SetTCD6_SADDR(value uint32) {
	volatile.StoreUint32(&o.TCD6_SADDR.Reg, value)
}
func (o *DMA_Type) GetTCD6_SADDR() uint32 {
	return volatile.LoadUint32(&o.TCD6_SADDR.Reg)
}

// DMA.TCD6_SOFF: TCD Signed Source Address Offset
func (o *DMA_Type) SetTCD6_SOFF(value uint16) {
	volatile.StoreUint16(&o.TCD6_SOFF.Reg, value)
}
func (o *DMA_Type) GetTCD6_SOFF() uint16 {
	return volatile.LoadUint16(&o.TCD6_SOFF.Reg)
}

// DMA.TCD6_ATTR: TCD Transfer Attributes
func (o *DMA_Type) SetTCD6_ATTR_DSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD6_ATTR.Reg, volatile.LoadUint16(&o.TCD6_ATTR.Reg)&^(0x7)|value)
}
func (o *DMA_Type) GetTCD6_ATTR_DSIZE() uint16 {
	return volatile.LoadUint16(&o.TCD6_ATTR.Reg) & 0x7
}
func (o *DMA_Type) SetTCD6_ATTR_DMOD(value uint16) {
	volatile.StoreUint16(&o.TCD6_ATTR.Reg, volatile.LoadUint16(&o.TCD6_ATTR.Reg)&^(0xf8)|value<<3)
}
func (o *DMA_Type) GetTCD6_ATTR_DMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD6_ATTR.Reg) & 0xf8) >> 3
}
func (o *DMA_Type) SetTCD6_ATTR_SSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD6_ATTR.Reg, volatile.LoadUint16(&o.TCD6_ATTR.Reg)&^(0x700)|value<<8)
}
func (o *DMA_Type) GetTCD6_ATTR_SSIZE() uint16 {
	return (volatile.LoadUint16(&o.TCD6_ATTR.Reg) & 0x700) >> 8
}
func (o *DMA_Type) SetTCD6_ATTR_SMOD(value uint16) {
	volatile.StoreUint16(&o.TCD6_ATTR.Reg, volatile.LoadUint16(&o.TCD6_ATTR.Reg)&^(0xf800)|value<<11)
}
func (o *DMA_Type) GetTCD6_ATTR_SMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD6_ATTR.Reg) & 0xf800) >> 11
}

// DMA.TCD6_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Disabled)
func (o *DMA_Type) SetTCD6_NBYTES_MLNO(value uint32) {
	volatile.StoreUint32(&o.TCD6_NBYTES_MLNO.Reg, value)
}
func (o *DMA_Type) GetTCD6_NBYTES_MLNO() uint32 {
	return volatile.LoadUint32(&o.TCD6_NBYTES_MLNO.Reg)
}

// DMA.TCD6_SLAST: TCD Last Source Address Adjustment
func (o *DMA_Type) SetTCD6_SLAST(value uint32) {
	volatile.StoreUint32(&o.TCD6_SLAST.Reg, value)
}
func (o *DMA_Type) GetTCD6_SLAST() uint32 {
	return volatile.LoadUint32(&o.TCD6_SLAST.Reg)
}

// DMA.TCD6_DADDR: TCD Destination Address
func (o *DMA_Type) SetTCD6_DADDR(value uint32) {
	volatile.StoreUint32(&o.TCD6_DADDR.Reg, value)
}
func (o *DMA_Type) GetTCD6_DADDR() uint32 {
	return volatile.LoadUint32(&o.TCD6_DADDR.Reg)
}

// DMA.TCD6_DOFF: TCD Signed Destination Address Offset
func (o *DMA_Type) SetTCD6_DOFF(value uint16) {
	volatile.StoreUint16(&o.TCD6_DOFF.Reg, value)
}
func (o *DMA_Type) GetTCD6_DOFF() uint16 {
	return volatile.LoadUint16(&o.TCD6_DOFF.Reg)
}

// DMA.TCD6_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD6_CITER_ELINKNO_CITER(value uint16) {
	volatile.StoreUint16(&o.TCD6_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD6_CITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD6_CITER_ELINKNO_CITER() uint16 {
	return volatile.LoadUint16(&o.TCD6_CITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD6_CITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD6_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD6_CITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD6_CITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD6_CITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD6_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
func (o *DMA_Type) SetTCD6_DLASTSGA(value uint32) {
	volatile.StoreUint32(&o.TCD6_DLASTSGA.Reg, value)
}
func (o *DMA_Type) GetTCD6_DLASTSGA() uint32 {
	return volatile.LoadUint32(&o.TCD6_DLASTSGA.Reg)
}

// DMA.TCD6_CSR: TCD Control and Status
func (o *DMA_Type) SetTCD6_CSR_START(value uint16) {
	volatile.StoreUint16(&o.TCD6_CSR.Reg, volatile.LoadUint16(&o.TCD6_CSR.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetTCD6_CSR_START() uint16 {
	return volatile.LoadUint16(&o.TCD6_CSR.Reg) & 0x1
}
func (o *DMA_Type) SetTCD6_CSR_INTMAJOR(value uint16) {
	volatile.StoreUint16(&o.TCD6_CSR.Reg, volatile.LoadUint16(&o.TCD6_CSR.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetTCD6_CSR_INTMAJOR() uint16 {
	return (volatile.LoadUint16(&o.TCD6_CSR.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetTCD6_CSR_INTHALF(value uint16) {
	volatile.StoreUint16(&o.TCD6_CSR.Reg, volatile.LoadUint16(&o.TCD6_CSR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetTCD6_CSR_INTHALF() uint16 {
	return (volatile.LoadUint16(&o.TCD6_CSR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetTCD6_CSR_DREQ(value uint16) {
	volatile.StoreUint16(&o.TCD6_CSR.Reg, volatile.LoadUint16(&o.TCD6_CSR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetTCD6_CSR_DREQ() uint16 {
	return (volatile.LoadUint16(&o.TCD6_CSR.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetTCD6_CSR_ESG(value uint16) {
	volatile.StoreUint16(&o.TCD6_CSR.Reg, volatile.LoadUint16(&o.TCD6_CSR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetTCD6_CSR_ESG() uint16 {
	return (volatile.LoadUint16(&o.TCD6_CSR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetTCD6_CSR_MAJORELINK(value uint16) {
	volatile.StoreUint16(&o.TCD6_CSR.Reg, volatile.LoadUint16(&o.TCD6_CSR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetTCD6_CSR_MAJORELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD6_CSR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetTCD6_CSR_ACTIVE(value uint16) {
	volatile.StoreUint16(&o.TCD6_CSR.Reg, volatile.LoadUint16(&o.TCD6_CSR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetTCD6_CSR_ACTIVE() uint16 {
	return (volatile.LoadUint16(&o.TCD6_CSR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetTCD6_CSR_DONE(value uint16) {
	volatile.StoreUint16(&o.TCD6_CSR.Reg, volatile.LoadUint16(&o.TCD6_CSR.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetTCD6_CSR_DONE() uint16 {
	return (volatile.LoadUint16(&o.TCD6_CSR.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetTCD6_CSR_MAJORLINKCH(value uint16) {
	volatile.StoreUint16(&o.TCD6_CSR.Reg, volatile.LoadUint16(&o.TCD6_CSR.Reg)&^(0xf00)|value<<8)
}
func (o *DMA_Type) GetTCD6_CSR_MAJORLINKCH() uint16 {
	return (volatile.LoadUint16(&o.TCD6_CSR.Reg) & 0xf00) >> 8
}
func (o *DMA_Type) SetTCD6_CSR_BWC(value uint16) {
	volatile.StoreUint16(&o.TCD6_CSR.Reg, volatile.LoadUint16(&o.TCD6_CSR.Reg)&^(0xc000)|value<<14)
}
func (o *DMA_Type) GetTCD6_CSR_BWC() uint16 {
	return (volatile.LoadUint16(&o.TCD6_CSR.Reg) & 0xc000) >> 14
}

// DMA.TCD6_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD6_BITER_ELINKNO_BITER(value uint16) {
	volatile.StoreUint16(&o.TCD6_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD6_BITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD6_BITER_ELINKNO_BITER() uint16 {
	return volatile.LoadUint16(&o.TCD6_BITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD6_BITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD6_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD6_BITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD6_BITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD6_BITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD7_SADDR: TCD Source Address
func (o *DMA_Type) SetTCD7_SADDR(value uint32) {
	volatile.StoreUint32(&o.TCD7_SADDR.Reg, value)
}
func (o *DMA_Type) GetTCD7_SADDR() uint32 {
	return volatile.LoadUint32(&o.TCD7_SADDR.Reg)
}

// DMA.TCD7_SOFF: TCD Signed Source Address Offset
func (o *DMA_Type) SetTCD7_SOFF(value uint16) {
	volatile.StoreUint16(&o.TCD7_SOFF.Reg, value)
}
func (o *DMA_Type) GetTCD7_SOFF() uint16 {
	return volatile.LoadUint16(&o.TCD7_SOFF.Reg)
}

// DMA.TCD7_ATTR: TCD Transfer Attributes
func (o *DMA_Type) SetTCD7_ATTR_DSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD7_ATTR.Reg, volatile.LoadUint16(&o.TCD7_ATTR.Reg)&^(0x7)|value)
}
func (o *DMA_Type) GetTCD7_ATTR_DSIZE() uint16 {
	return volatile.LoadUint16(&o.TCD7_ATTR.Reg) & 0x7
}
func (o *DMA_Type) SetTCD7_ATTR_DMOD(value uint16) {
	volatile.StoreUint16(&o.TCD7_ATTR.Reg, volatile.LoadUint16(&o.TCD7_ATTR.Reg)&^(0xf8)|value<<3)
}
func (o *DMA_Type) GetTCD7_ATTR_DMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD7_ATTR.Reg) & 0xf8) >> 3
}
func (o *DMA_Type) SetTCD7_ATTR_SSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD7_ATTR.Reg, volatile.LoadUint16(&o.TCD7_ATTR.Reg)&^(0x700)|value<<8)
}
func (o *DMA_Type) GetTCD7_ATTR_SSIZE() uint16 {
	return (volatile.LoadUint16(&o.TCD7_ATTR.Reg) & 0x700) >> 8
}
func (o *DMA_Type) SetTCD7_ATTR_SMOD(value uint16) {
	volatile.StoreUint16(&o.TCD7_ATTR.Reg, volatile.LoadUint16(&o.TCD7_ATTR.Reg)&^(0xf800)|value<<11)
}
func (o *DMA_Type) GetTCD7_ATTR_SMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD7_ATTR.Reg) & 0xf800) >> 11
}

// DMA.TCD7_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Disabled)
func (o *DMA_Type) SetTCD7_NBYTES_MLNO(value uint32) {
	volatile.StoreUint32(&o.TCD7_NBYTES_MLNO.Reg, value)
}
func (o *DMA_Type) GetTCD7_NBYTES_MLNO() uint32 {
	return volatile.LoadUint32(&o.TCD7_NBYTES_MLNO.Reg)
}

// DMA.TCD7_SLAST: TCD Last Source Address Adjustment
func (o *DMA_Type) SetTCD7_SLAST(value uint32) {
	volatile.StoreUint32(&o.TCD7_SLAST.Reg, value)
}
func (o *DMA_Type) GetTCD7_SLAST() uint32 {
	return volatile.LoadUint32(&o.TCD7_SLAST.Reg)
}

// DMA.TCD7_DADDR: TCD Destination Address
func (o *DMA_Type) SetTCD7_DADDR(value uint32) {
	volatile.StoreUint32(&o.TCD7_DADDR.Reg, value)
}
func (o *DMA_Type) GetTCD7_DADDR() uint32 {
	return volatile.LoadUint32(&o.TCD7_DADDR.Reg)
}

// DMA.TCD7_DOFF: TCD Signed Destination Address Offset
func (o *DMA_Type) SetTCD7_DOFF(value uint16) {
	volatile.StoreUint16(&o.TCD7_DOFF.Reg, value)
}
func (o *DMA_Type) GetTCD7_DOFF() uint16 {
	return volatile.LoadUint16(&o.TCD7_DOFF.Reg)
}

// DMA.TCD7_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD7_CITER_ELINKNO_CITER(value uint16) {
	volatile.StoreUint16(&o.TCD7_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD7_CITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD7_CITER_ELINKNO_CITER() uint16 {
	return volatile.LoadUint16(&o.TCD7_CITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD7_CITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD7_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD7_CITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD7_CITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD7_CITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD7_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
func (o *DMA_Type) SetTCD7_DLASTSGA(value uint32) {
	volatile.StoreUint32(&o.TCD7_DLASTSGA.Reg, value)
}
func (o *DMA_Type) GetTCD7_DLASTSGA() uint32 {
	return volatile.LoadUint32(&o.TCD7_DLASTSGA.Reg)
}

// DMA.TCD7_CSR: TCD Control and Status
func (o *DMA_Type) SetTCD7_CSR_START(value uint16) {
	volatile.StoreUint16(&o.TCD7_CSR.Reg, volatile.LoadUint16(&o.TCD7_CSR.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetTCD7_CSR_START() uint16 {
	return volatile.LoadUint16(&o.TCD7_CSR.Reg) & 0x1
}
func (o *DMA_Type) SetTCD7_CSR_INTMAJOR(value uint16) {
	volatile.StoreUint16(&o.TCD7_CSR.Reg, volatile.LoadUint16(&o.TCD7_CSR.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetTCD7_CSR_INTMAJOR() uint16 {
	return (volatile.LoadUint16(&o.TCD7_CSR.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetTCD7_CSR_INTHALF(value uint16) {
	volatile.StoreUint16(&o.TCD7_CSR.Reg, volatile.LoadUint16(&o.TCD7_CSR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetTCD7_CSR_INTHALF() uint16 {
	return (volatile.LoadUint16(&o.TCD7_CSR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetTCD7_CSR_DREQ(value uint16) {
	volatile.StoreUint16(&o.TCD7_CSR.Reg, volatile.LoadUint16(&o.TCD7_CSR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetTCD7_CSR_DREQ() uint16 {
	return (volatile.LoadUint16(&o.TCD7_CSR.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetTCD7_CSR_ESG(value uint16) {
	volatile.StoreUint16(&o.TCD7_CSR.Reg, volatile.LoadUint16(&o.TCD7_CSR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetTCD7_CSR_ESG() uint16 {
	return (volatile.LoadUint16(&o.TCD7_CSR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetTCD7_CSR_MAJORELINK(value uint16) {
	volatile.StoreUint16(&o.TCD7_CSR.Reg, volatile.LoadUint16(&o.TCD7_CSR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetTCD7_CSR_MAJORELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD7_CSR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetTCD7_CSR_ACTIVE(value uint16) {
	volatile.StoreUint16(&o.TCD7_CSR.Reg, volatile.LoadUint16(&o.TCD7_CSR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetTCD7_CSR_ACTIVE() uint16 {
	return (volatile.LoadUint16(&o.TCD7_CSR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetTCD7_CSR_DONE(value uint16) {
	volatile.StoreUint16(&o.TCD7_CSR.Reg, volatile.LoadUint16(&o.TCD7_CSR.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetTCD7_CSR_DONE() uint16 {
	return (volatile.LoadUint16(&o.TCD7_CSR.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetTCD7_CSR_MAJORLINKCH(value uint16) {
	volatile.StoreUint16(&o.TCD7_CSR.Reg, volatile.LoadUint16(&o.TCD7_CSR.Reg)&^(0xf00)|value<<8)
}
func (o *DMA_Type) GetTCD7_CSR_MAJORLINKCH() uint16 {
	return (volatile.LoadUint16(&o.TCD7_CSR.Reg) & 0xf00) >> 8
}
func (o *DMA_Type) SetTCD7_CSR_BWC(value uint16) {
	volatile.StoreUint16(&o.TCD7_CSR.Reg, volatile.LoadUint16(&o.TCD7_CSR.Reg)&^(0xc000)|value<<14)
}
func (o *DMA_Type) GetTCD7_CSR_BWC() uint16 {
	return (volatile.LoadUint16(&o.TCD7_CSR.Reg) & 0xc000) >> 14
}

// DMA.TCD7_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD7_BITER_ELINKNO_BITER(value uint16) {
	volatile.StoreUint16(&o.TCD7_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD7_BITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD7_BITER_ELINKNO_BITER() uint16 {
	return volatile.LoadUint16(&o.TCD7_BITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD7_BITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD7_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD7_BITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD7_BITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD7_BITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD8_SADDR: TCD Source Address
func (o *DMA_Type) SetTCD8_SADDR(value uint32) {
	volatile.StoreUint32(&o.TCD8_SADDR.Reg, value)
}
func (o *DMA_Type) GetTCD8_SADDR() uint32 {
	return volatile.LoadUint32(&o.TCD8_SADDR.Reg)
}

// DMA.TCD8_SOFF: TCD Signed Source Address Offset
func (o *DMA_Type) SetTCD8_SOFF(value uint16) {
	volatile.StoreUint16(&o.TCD8_SOFF.Reg, value)
}
func (o *DMA_Type) GetTCD8_SOFF() uint16 {
	return volatile.LoadUint16(&o.TCD8_SOFF.Reg)
}

// DMA.TCD8_ATTR: TCD Transfer Attributes
func (o *DMA_Type) SetTCD8_ATTR_DSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD8_ATTR.Reg, volatile.LoadUint16(&o.TCD8_ATTR.Reg)&^(0x7)|value)
}
func (o *DMA_Type) GetTCD8_ATTR_DSIZE() uint16 {
	return volatile.LoadUint16(&o.TCD8_ATTR.Reg) & 0x7
}
func (o *DMA_Type) SetTCD8_ATTR_DMOD(value uint16) {
	volatile.StoreUint16(&o.TCD8_ATTR.Reg, volatile.LoadUint16(&o.TCD8_ATTR.Reg)&^(0xf8)|value<<3)
}
func (o *DMA_Type) GetTCD8_ATTR_DMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD8_ATTR.Reg) & 0xf8) >> 3
}
func (o *DMA_Type) SetTCD8_ATTR_SSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD8_ATTR.Reg, volatile.LoadUint16(&o.TCD8_ATTR.Reg)&^(0x700)|value<<8)
}
func (o *DMA_Type) GetTCD8_ATTR_SSIZE() uint16 {
	return (volatile.LoadUint16(&o.TCD8_ATTR.Reg) & 0x700) >> 8
}
func (o *DMA_Type) SetTCD8_ATTR_SMOD(value uint16) {
	volatile.StoreUint16(&o.TCD8_ATTR.Reg, volatile.LoadUint16(&o.TCD8_ATTR.Reg)&^(0xf800)|value<<11)
}
func (o *DMA_Type) GetTCD8_ATTR_SMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD8_ATTR.Reg) & 0xf800) >> 11
}

// DMA.TCD8_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Disabled)
func (o *DMA_Type) SetTCD8_NBYTES_MLNO(value uint32) {
	volatile.StoreUint32(&o.TCD8_NBYTES_MLNO.Reg, value)
}
func (o *DMA_Type) GetTCD8_NBYTES_MLNO() uint32 {
	return volatile.LoadUint32(&o.TCD8_NBYTES_MLNO.Reg)
}

// DMA.TCD8_SLAST: TCD Last Source Address Adjustment
func (o *DMA_Type) SetTCD8_SLAST(value uint32) {
	volatile.StoreUint32(&o.TCD8_SLAST.Reg, value)
}
func (o *DMA_Type) GetTCD8_SLAST() uint32 {
	return volatile.LoadUint32(&o.TCD8_SLAST.Reg)
}

// DMA.TCD8_DADDR: TCD Destination Address
func (o *DMA_Type) SetTCD8_DADDR(value uint32) {
	volatile.StoreUint32(&o.TCD8_DADDR.Reg, value)
}
func (o *DMA_Type) GetTCD8_DADDR() uint32 {
	return volatile.LoadUint32(&o.TCD8_DADDR.Reg)
}

// DMA.TCD8_DOFF: TCD Signed Destination Address Offset
func (o *DMA_Type) SetTCD8_DOFF(value uint16) {
	volatile.StoreUint16(&o.TCD8_DOFF.Reg, value)
}
func (o *DMA_Type) GetTCD8_DOFF() uint16 {
	return volatile.LoadUint16(&o.TCD8_DOFF.Reg)
}

// DMA.TCD8_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD8_CITER_ELINKNO_CITER(value uint16) {
	volatile.StoreUint16(&o.TCD8_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD8_CITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD8_CITER_ELINKNO_CITER() uint16 {
	return volatile.LoadUint16(&o.TCD8_CITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD8_CITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD8_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD8_CITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD8_CITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD8_CITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD8_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
func (o *DMA_Type) SetTCD8_DLASTSGA(value uint32) {
	volatile.StoreUint32(&o.TCD8_DLASTSGA.Reg, value)
}
func (o *DMA_Type) GetTCD8_DLASTSGA() uint32 {
	return volatile.LoadUint32(&o.TCD8_DLASTSGA.Reg)
}

// DMA.TCD8_CSR: TCD Control and Status
func (o *DMA_Type) SetTCD8_CSR_START(value uint16) {
	volatile.StoreUint16(&o.TCD8_CSR.Reg, volatile.LoadUint16(&o.TCD8_CSR.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetTCD8_CSR_START() uint16 {
	return volatile.LoadUint16(&o.TCD8_CSR.Reg) & 0x1
}
func (o *DMA_Type) SetTCD8_CSR_INTMAJOR(value uint16) {
	volatile.StoreUint16(&o.TCD8_CSR.Reg, volatile.LoadUint16(&o.TCD8_CSR.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetTCD8_CSR_INTMAJOR() uint16 {
	return (volatile.LoadUint16(&o.TCD8_CSR.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetTCD8_CSR_INTHALF(value uint16) {
	volatile.StoreUint16(&o.TCD8_CSR.Reg, volatile.LoadUint16(&o.TCD8_CSR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetTCD8_CSR_INTHALF() uint16 {
	return (volatile.LoadUint16(&o.TCD8_CSR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetTCD8_CSR_DREQ(value uint16) {
	volatile.StoreUint16(&o.TCD8_CSR.Reg, volatile.LoadUint16(&o.TCD8_CSR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetTCD8_CSR_DREQ() uint16 {
	return (volatile.LoadUint16(&o.TCD8_CSR.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetTCD8_CSR_ESG(value uint16) {
	volatile.StoreUint16(&o.TCD8_CSR.Reg, volatile.LoadUint16(&o.TCD8_CSR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetTCD8_CSR_ESG() uint16 {
	return (volatile.LoadUint16(&o.TCD8_CSR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetTCD8_CSR_MAJORELINK(value uint16) {
	volatile.StoreUint16(&o.TCD8_CSR.Reg, volatile.LoadUint16(&o.TCD8_CSR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetTCD8_CSR_MAJORELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD8_CSR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetTCD8_CSR_ACTIVE(value uint16) {
	volatile.StoreUint16(&o.TCD8_CSR.Reg, volatile.LoadUint16(&o.TCD8_CSR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetTCD8_CSR_ACTIVE() uint16 {
	return (volatile.LoadUint16(&o.TCD8_CSR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetTCD8_CSR_DONE(value uint16) {
	volatile.StoreUint16(&o.TCD8_CSR.Reg, volatile.LoadUint16(&o.TCD8_CSR.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetTCD8_CSR_DONE() uint16 {
	return (volatile.LoadUint16(&o.TCD8_CSR.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetTCD8_CSR_MAJORLINKCH(value uint16) {
	volatile.StoreUint16(&o.TCD8_CSR.Reg, volatile.LoadUint16(&o.TCD8_CSR.Reg)&^(0xf00)|value<<8)
}
func (o *DMA_Type) GetTCD8_CSR_MAJORLINKCH() uint16 {
	return (volatile.LoadUint16(&o.TCD8_CSR.Reg) & 0xf00) >> 8
}
func (o *DMA_Type) SetTCD8_CSR_BWC(value uint16) {
	volatile.StoreUint16(&o.TCD8_CSR.Reg, volatile.LoadUint16(&o.TCD8_CSR.Reg)&^(0xc000)|value<<14)
}
func (o *DMA_Type) GetTCD8_CSR_BWC() uint16 {
	return (volatile.LoadUint16(&o.TCD8_CSR.Reg) & 0xc000) >> 14
}

// DMA.TCD8_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD8_BITER_ELINKNO_BITER(value uint16) {
	volatile.StoreUint16(&o.TCD8_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD8_BITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD8_BITER_ELINKNO_BITER() uint16 {
	return volatile.LoadUint16(&o.TCD8_BITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD8_BITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD8_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD8_BITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD8_BITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD8_BITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD9_SADDR: TCD Source Address
func (o *DMA_Type) SetTCD9_SADDR(value uint32) {
	volatile.StoreUint32(&o.TCD9_SADDR.Reg, value)
}
func (o *DMA_Type) GetTCD9_SADDR() uint32 {
	return volatile.LoadUint32(&o.TCD9_SADDR.Reg)
}

// DMA.TCD9_SOFF: TCD Signed Source Address Offset
func (o *DMA_Type) SetTCD9_SOFF(value uint16) {
	volatile.StoreUint16(&o.TCD9_SOFF.Reg, value)
}
func (o *DMA_Type) GetTCD9_SOFF() uint16 {
	return volatile.LoadUint16(&o.TCD9_SOFF.Reg)
}

// DMA.TCD9_ATTR: TCD Transfer Attributes
func (o *DMA_Type) SetTCD9_ATTR_DSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD9_ATTR.Reg, volatile.LoadUint16(&o.TCD9_ATTR.Reg)&^(0x7)|value)
}
func (o *DMA_Type) GetTCD9_ATTR_DSIZE() uint16 {
	return volatile.LoadUint16(&o.TCD9_ATTR.Reg) & 0x7
}
func (o *DMA_Type) SetTCD9_ATTR_DMOD(value uint16) {
	volatile.StoreUint16(&o.TCD9_ATTR.Reg, volatile.LoadUint16(&o.TCD9_ATTR.Reg)&^(0xf8)|value<<3)
}
func (o *DMA_Type) GetTCD9_ATTR_DMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD9_ATTR.Reg) & 0xf8) >> 3
}
func (o *DMA_Type) SetTCD9_ATTR_SSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD9_ATTR.Reg, volatile.LoadUint16(&o.TCD9_ATTR.Reg)&^(0x700)|value<<8)
}
func (o *DMA_Type) GetTCD9_ATTR_SSIZE() uint16 {
	return (volatile.LoadUint16(&o.TCD9_ATTR.Reg) & 0x700) >> 8
}
func (o *DMA_Type) SetTCD9_ATTR_SMOD(value uint16) {
	volatile.StoreUint16(&o.TCD9_ATTR.Reg, volatile.LoadUint16(&o.TCD9_ATTR.Reg)&^(0xf800)|value<<11)
}
func (o *DMA_Type) GetTCD9_ATTR_SMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD9_ATTR.Reg) & 0xf800) >> 11
}

// DMA.TCD9_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Disabled)
func (o *DMA_Type) SetTCD9_NBYTES_MLNO(value uint32) {
	volatile.StoreUint32(&o.TCD9_NBYTES_MLNO.Reg, value)
}
func (o *DMA_Type) GetTCD9_NBYTES_MLNO() uint32 {
	return volatile.LoadUint32(&o.TCD9_NBYTES_MLNO.Reg)
}

// DMA.TCD9_SLAST: TCD Last Source Address Adjustment
func (o *DMA_Type) SetTCD9_SLAST(value uint32) {
	volatile.StoreUint32(&o.TCD9_SLAST.Reg, value)
}
func (o *DMA_Type) GetTCD9_SLAST() uint32 {
	return volatile.LoadUint32(&o.TCD9_SLAST.Reg)
}

// DMA.TCD9_DADDR: TCD Destination Address
func (o *DMA_Type) SetTCD9_DADDR(value uint32) {
	volatile.StoreUint32(&o.TCD9_DADDR.Reg, value)
}
func (o *DMA_Type) GetTCD9_DADDR() uint32 {
	return volatile.LoadUint32(&o.TCD9_DADDR.Reg)
}

// DMA.TCD9_DOFF: TCD Signed Destination Address Offset
func (o *DMA_Type) SetTCD9_DOFF(value uint16) {
	volatile.StoreUint16(&o.TCD9_DOFF.Reg, value)
}
func (o *DMA_Type) GetTCD9_DOFF() uint16 {
	return volatile.LoadUint16(&o.TCD9_DOFF.Reg)
}

// DMA.TCD9_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD9_CITER_ELINKNO_CITER(value uint16) {
	volatile.StoreUint16(&o.TCD9_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD9_CITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD9_CITER_ELINKNO_CITER() uint16 {
	return volatile.LoadUint16(&o.TCD9_CITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD9_CITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD9_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD9_CITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD9_CITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD9_CITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD9_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
func (o *DMA_Type) SetTCD9_DLASTSGA(value uint32) {
	volatile.StoreUint32(&o.TCD9_DLASTSGA.Reg, value)
}
func (o *DMA_Type) GetTCD9_DLASTSGA() uint32 {
	return volatile.LoadUint32(&o.TCD9_DLASTSGA.Reg)
}

// DMA.TCD9_CSR: TCD Control and Status
func (o *DMA_Type) SetTCD9_CSR_START(value uint16) {
	volatile.StoreUint16(&o.TCD9_CSR.Reg, volatile.LoadUint16(&o.TCD9_CSR.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetTCD9_CSR_START() uint16 {
	return volatile.LoadUint16(&o.TCD9_CSR.Reg) & 0x1
}
func (o *DMA_Type) SetTCD9_CSR_INTMAJOR(value uint16) {
	volatile.StoreUint16(&o.TCD9_CSR.Reg, volatile.LoadUint16(&o.TCD9_CSR.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetTCD9_CSR_INTMAJOR() uint16 {
	return (volatile.LoadUint16(&o.TCD9_CSR.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetTCD9_CSR_INTHALF(value uint16) {
	volatile.StoreUint16(&o.TCD9_CSR.Reg, volatile.LoadUint16(&o.TCD9_CSR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetTCD9_CSR_INTHALF() uint16 {
	return (volatile.LoadUint16(&o.TCD9_CSR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetTCD9_CSR_DREQ(value uint16) {
	volatile.StoreUint16(&o.TCD9_CSR.Reg, volatile.LoadUint16(&o.TCD9_CSR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetTCD9_CSR_DREQ() uint16 {
	return (volatile.LoadUint16(&o.TCD9_CSR.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetTCD9_CSR_ESG(value uint16) {
	volatile.StoreUint16(&o.TCD9_CSR.Reg, volatile.LoadUint16(&o.TCD9_CSR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetTCD9_CSR_ESG() uint16 {
	return (volatile.LoadUint16(&o.TCD9_CSR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetTCD9_CSR_MAJORELINK(value uint16) {
	volatile.StoreUint16(&o.TCD9_CSR.Reg, volatile.LoadUint16(&o.TCD9_CSR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetTCD9_CSR_MAJORELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD9_CSR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetTCD9_CSR_ACTIVE(value uint16) {
	volatile.StoreUint16(&o.TCD9_CSR.Reg, volatile.LoadUint16(&o.TCD9_CSR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetTCD9_CSR_ACTIVE() uint16 {
	return (volatile.LoadUint16(&o.TCD9_CSR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetTCD9_CSR_DONE(value uint16) {
	volatile.StoreUint16(&o.TCD9_CSR.Reg, volatile.LoadUint16(&o.TCD9_CSR.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetTCD9_CSR_DONE() uint16 {
	return (volatile.LoadUint16(&o.TCD9_CSR.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetTCD9_CSR_MAJORLINKCH(value uint16) {
	volatile.StoreUint16(&o.TCD9_CSR.Reg, volatile.LoadUint16(&o.TCD9_CSR.Reg)&^(0xf00)|value<<8)
}
func (o *DMA_Type) GetTCD9_CSR_MAJORLINKCH() uint16 {
	return (volatile.LoadUint16(&o.TCD9_CSR.Reg) & 0xf00) >> 8
}
func (o *DMA_Type) SetTCD9_CSR_BWC(value uint16) {
	volatile.StoreUint16(&o.TCD9_CSR.Reg, volatile.LoadUint16(&o.TCD9_CSR.Reg)&^(0xc000)|value<<14)
}
func (o *DMA_Type) GetTCD9_CSR_BWC() uint16 {
	return (volatile.LoadUint16(&o.TCD9_CSR.Reg) & 0xc000) >> 14
}

// DMA.TCD9_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD9_BITER_ELINKNO_BITER(value uint16) {
	volatile.StoreUint16(&o.TCD9_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD9_BITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD9_BITER_ELINKNO_BITER() uint16 {
	return volatile.LoadUint16(&o.TCD9_BITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD9_BITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD9_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD9_BITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD9_BITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD9_BITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD10_SADDR: TCD Source Address
func (o *DMA_Type) SetTCD10_SADDR(value uint32) {
	volatile.StoreUint32(&o.TCD10_SADDR.Reg, value)
}
func (o *DMA_Type) GetTCD10_SADDR() uint32 {
	return volatile.LoadUint32(&o.TCD10_SADDR.Reg)
}

// DMA.TCD10_SOFF: TCD Signed Source Address Offset
func (o *DMA_Type) SetTCD10_SOFF(value uint16) {
	volatile.StoreUint16(&o.TCD10_SOFF.Reg, value)
}
func (o *DMA_Type) GetTCD10_SOFF() uint16 {
	return volatile.LoadUint16(&o.TCD10_SOFF.Reg)
}

// DMA.TCD10_ATTR: TCD Transfer Attributes
func (o *DMA_Type) SetTCD10_ATTR_DSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD10_ATTR.Reg, volatile.LoadUint16(&o.TCD10_ATTR.Reg)&^(0x7)|value)
}
func (o *DMA_Type) GetTCD10_ATTR_DSIZE() uint16 {
	return volatile.LoadUint16(&o.TCD10_ATTR.Reg) & 0x7
}
func (o *DMA_Type) SetTCD10_ATTR_DMOD(value uint16) {
	volatile.StoreUint16(&o.TCD10_ATTR.Reg, volatile.LoadUint16(&o.TCD10_ATTR.Reg)&^(0xf8)|value<<3)
}
func (o *DMA_Type) GetTCD10_ATTR_DMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD10_ATTR.Reg) & 0xf8) >> 3
}
func (o *DMA_Type) SetTCD10_ATTR_SSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD10_ATTR.Reg, volatile.LoadUint16(&o.TCD10_ATTR.Reg)&^(0x700)|value<<8)
}
func (o *DMA_Type) GetTCD10_ATTR_SSIZE() uint16 {
	return (volatile.LoadUint16(&o.TCD10_ATTR.Reg) & 0x700) >> 8
}
func (o *DMA_Type) SetTCD10_ATTR_SMOD(value uint16) {
	volatile.StoreUint16(&o.TCD10_ATTR.Reg, volatile.LoadUint16(&o.TCD10_ATTR.Reg)&^(0xf800)|value<<11)
}
func (o *DMA_Type) GetTCD10_ATTR_SMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD10_ATTR.Reg) & 0xf800) >> 11
}

// DMA.TCD10_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Disabled)
func (o *DMA_Type) SetTCD10_NBYTES_MLNO(value uint32) {
	volatile.StoreUint32(&o.TCD10_NBYTES_MLNO.Reg, value)
}
func (o *DMA_Type) GetTCD10_NBYTES_MLNO() uint32 {
	return volatile.LoadUint32(&o.TCD10_NBYTES_MLNO.Reg)
}

// DMA.TCD10_SLAST: TCD Last Source Address Adjustment
func (o *DMA_Type) SetTCD10_SLAST(value uint32) {
	volatile.StoreUint32(&o.TCD10_SLAST.Reg, value)
}
func (o *DMA_Type) GetTCD10_SLAST() uint32 {
	return volatile.LoadUint32(&o.TCD10_SLAST.Reg)
}

// DMA.TCD10_DADDR: TCD Destination Address
func (o *DMA_Type) SetTCD10_DADDR(value uint32) {
	volatile.StoreUint32(&o.TCD10_DADDR.Reg, value)
}
func (o *DMA_Type) GetTCD10_DADDR() uint32 {
	return volatile.LoadUint32(&o.TCD10_DADDR.Reg)
}

// DMA.TCD10_DOFF: TCD Signed Destination Address Offset
func (o *DMA_Type) SetTCD10_DOFF(value uint16) {
	volatile.StoreUint16(&o.TCD10_DOFF.Reg, value)
}
func (o *DMA_Type) GetTCD10_DOFF() uint16 {
	return volatile.LoadUint16(&o.TCD10_DOFF.Reg)
}

// DMA.TCD10_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD10_CITER_ELINKNO_CITER(value uint16) {
	volatile.StoreUint16(&o.TCD10_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD10_CITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD10_CITER_ELINKNO_CITER() uint16 {
	return volatile.LoadUint16(&o.TCD10_CITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD10_CITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD10_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD10_CITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD10_CITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD10_CITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD10_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
func (o *DMA_Type) SetTCD10_DLASTSGA(value uint32) {
	volatile.StoreUint32(&o.TCD10_DLASTSGA.Reg, value)
}
func (o *DMA_Type) GetTCD10_DLASTSGA() uint32 {
	return volatile.LoadUint32(&o.TCD10_DLASTSGA.Reg)
}

// DMA.TCD10_CSR: TCD Control and Status
func (o *DMA_Type) SetTCD10_CSR_START(value uint16) {
	volatile.StoreUint16(&o.TCD10_CSR.Reg, volatile.LoadUint16(&o.TCD10_CSR.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetTCD10_CSR_START() uint16 {
	return volatile.LoadUint16(&o.TCD10_CSR.Reg) & 0x1
}
func (o *DMA_Type) SetTCD10_CSR_INTMAJOR(value uint16) {
	volatile.StoreUint16(&o.TCD10_CSR.Reg, volatile.LoadUint16(&o.TCD10_CSR.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetTCD10_CSR_INTMAJOR() uint16 {
	return (volatile.LoadUint16(&o.TCD10_CSR.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetTCD10_CSR_INTHALF(value uint16) {
	volatile.StoreUint16(&o.TCD10_CSR.Reg, volatile.LoadUint16(&o.TCD10_CSR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetTCD10_CSR_INTHALF() uint16 {
	return (volatile.LoadUint16(&o.TCD10_CSR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetTCD10_CSR_DREQ(value uint16) {
	volatile.StoreUint16(&o.TCD10_CSR.Reg, volatile.LoadUint16(&o.TCD10_CSR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetTCD10_CSR_DREQ() uint16 {
	return (volatile.LoadUint16(&o.TCD10_CSR.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetTCD10_CSR_ESG(value uint16) {
	volatile.StoreUint16(&o.TCD10_CSR.Reg, volatile.LoadUint16(&o.TCD10_CSR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetTCD10_CSR_ESG() uint16 {
	return (volatile.LoadUint16(&o.TCD10_CSR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetTCD10_CSR_MAJORELINK(value uint16) {
	volatile.StoreUint16(&o.TCD10_CSR.Reg, volatile.LoadUint16(&o.TCD10_CSR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetTCD10_CSR_MAJORELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD10_CSR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetTCD10_CSR_ACTIVE(value uint16) {
	volatile.StoreUint16(&o.TCD10_CSR.Reg, volatile.LoadUint16(&o.TCD10_CSR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetTCD10_CSR_ACTIVE() uint16 {
	return (volatile.LoadUint16(&o.TCD10_CSR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetTCD10_CSR_DONE(value uint16) {
	volatile.StoreUint16(&o.TCD10_CSR.Reg, volatile.LoadUint16(&o.TCD10_CSR.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetTCD10_CSR_DONE() uint16 {
	return (volatile.LoadUint16(&o.TCD10_CSR.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetTCD10_CSR_MAJORLINKCH(value uint16) {
	volatile.StoreUint16(&o.TCD10_CSR.Reg, volatile.LoadUint16(&o.TCD10_CSR.Reg)&^(0xf00)|value<<8)
}
func (o *DMA_Type) GetTCD10_CSR_MAJORLINKCH() uint16 {
	return (volatile.LoadUint16(&o.TCD10_CSR.Reg) & 0xf00) >> 8
}
func (o *DMA_Type) SetTCD10_CSR_BWC(value uint16) {
	volatile.StoreUint16(&o.TCD10_CSR.Reg, volatile.LoadUint16(&o.TCD10_CSR.Reg)&^(0xc000)|value<<14)
}
func (o *DMA_Type) GetTCD10_CSR_BWC() uint16 {
	return (volatile.LoadUint16(&o.TCD10_CSR.Reg) & 0xc000) >> 14
}

// DMA.TCD10_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD10_BITER_ELINKNO_BITER(value uint16) {
	volatile.StoreUint16(&o.TCD10_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD10_BITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD10_BITER_ELINKNO_BITER() uint16 {
	return volatile.LoadUint16(&o.TCD10_BITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD10_BITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD10_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD10_BITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD10_BITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD10_BITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD11_SADDR: TCD Source Address
func (o *DMA_Type) SetTCD11_SADDR(value uint32) {
	volatile.StoreUint32(&o.TCD11_SADDR.Reg, value)
}
func (o *DMA_Type) GetTCD11_SADDR() uint32 {
	return volatile.LoadUint32(&o.TCD11_SADDR.Reg)
}

// DMA.TCD11_SOFF: TCD Signed Source Address Offset
func (o *DMA_Type) SetTCD11_SOFF(value uint16) {
	volatile.StoreUint16(&o.TCD11_SOFF.Reg, value)
}
func (o *DMA_Type) GetTCD11_SOFF() uint16 {
	return volatile.LoadUint16(&o.TCD11_SOFF.Reg)
}

// DMA.TCD11_ATTR: TCD Transfer Attributes
func (o *DMA_Type) SetTCD11_ATTR_DSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD11_ATTR.Reg, volatile.LoadUint16(&o.TCD11_ATTR.Reg)&^(0x7)|value)
}
func (o *DMA_Type) GetTCD11_ATTR_DSIZE() uint16 {
	return volatile.LoadUint16(&o.TCD11_ATTR.Reg) & 0x7
}
func (o *DMA_Type) SetTCD11_ATTR_DMOD(value uint16) {
	volatile.StoreUint16(&o.TCD11_ATTR.Reg, volatile.LoadUint16(&o.TCD11_ATTR.Reg)&^(0xf8)|value<<3)
}
func (o *DMA_Type) GetTCD11_ATTR_DMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD11_ATTR.Reg) & 0xf8) >> 3
}
func (o *DMA_Type) SetTCD11_ATTR_SSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD11_ATTR.Reg, volatile.LoadUint16(&o.TCD11_ATTR.Reg)&^(0x700)|value<<8)
}
func (o *DMA_Type) GetTCD11_ATTR_SSIZE() uint16 {
	return (volatile.LoadUint16(&o.TCD11_ATTR.Reg) & 0x700) >> 8
}
func (o *DMA_Type) SetTCD11_ATTR_SMOD(value uint16) {
	volatile.StoreUint16(&o.TCD11_ATTR.Reg, volatile.LoadUint16(&o.TCD11_ATTR.Reg)&^(0xf800)|value<<11)
}
func (o *DMA_Type) GetTCD11_ATTR_SMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD11_ATTR.Reg) & 0xf800) >> 11
}

// DMA.TCD11_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Disabled)
func (o *DMA_Type) SetTCD11_NBYTES_MLNO(value uint32) {
	volatile.StoreUint32(&o.TCD11_NBYTES_MLNO.Reg, value)
}
func (o *DMA_Type) GetTCD11_NBYTES_MLNO() uint32 {
	return volatile.LoadUint32(&o.TCD11_NBYTES_MLNO.Reg)
}

// DMA.TCD11_SLAST: TCD Last Source Address Adjustment
func (o *DMA_Type) SetTCD11_SLAST(value uint32) {
	volatile.StoreUint32(&o.TCD11_SLAST.Reg, value)
}
func (o *DMA_Type) GetTCD11_SLAST() uint32 {
	return volatile.LoadUint32(&o.TCD11_SLAST.Reg)
}

// DMA.TCD11_DADDR: TCD Destination Address
func (o *DMA_Type) SetTCD11_DADDR(value uint32) {
	volatile.StoreUint32(&o.TCD11_DADDR.Reg, value)
}
func (o *DMA_Type) GetTCD11_DADDR() uint32 {
	return volatile.LoadUint32(&o.TCD11_DADDR.Reg)
}

// DMA.TCD11_DOFF: TCD Signed Destination Address Offset
func (o *DMA_Type) SetTCD11_DOFF(value uint16) {
	volatile.StoreUint16(&o.TCD11_DOFF.Reg, value)
}
func (o *DMA_Type) GetTCD11_DOFF() uint16 {
	return volatile.LoadUint16(&o.TCD11_DOFF.Reg)
}

// DMA.TCD11_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD11_CITER_ELINKNO_CITER(value uint16) {
	volatile.StoreUint16(&o.TCD11_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD11_CITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD11_CITER_ELINKNO_CITER() uint16 {
	return volatile.LoadUint16(&o.TCD11_CITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD11_CITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD11_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD11_CITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD11_CITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD11_CITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD11_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
func (o *DMA_Type) SetTCD11_DLASTSGA(value uint32) {
	volatile.StoreUint32(&o.TCD11_DLASTSGA.Reg, value)
}
func (o *DMA_Type) GetTCD11_DLASTSGA() uint32 {
	return volatile.LoadUint32(&o.TCD11_DLASTSGA.Reg)
}

// DMA.TCD11_CSR: TCD Control and Status
func (o *DMA_Type) SetTCD11_CSR_START(value uint16) {
	volatile.StoreUint16(&o.TCD11_CSR.Reg, volatile.LoadUint16(&o.TCD11_CSR.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetTCD11_CSR_START() uint16 {
	return volatile.LoadUint16(&o.TCD11_CSR.Reg) & 0x1
}
func (o *DMA_Type) SetTCD11_CSR_INTMAJOR(value uint16) {
	volatile.StoreUint16(&o.TCD11_CSR.Reg, volatile.LoadUint16(&o.TCD11_CSR.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetTCD11_CSR_INTMAJOR() uint16 {
	return (volatile.LoadUint16(&o.TCD11_CSR.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetTCD11_CSR_INTHALF(value uint16) {
	volatile.StoreUint16(&o.TCD11_CSR.Reg, volatile.LoadUint16(&o.TCD11_CSR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetTCD11_CSR_INTHALF() uint16 {
	return (volatile.LoadUint16(&o.TCD11_CSR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetTCD11_CSR_DREQ(value uint16) {
	volatile.StoreUint16(&o.TCD11_CSR.Reg, volatile.LoadUint16(&o.TCD11_CSR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetTCD11_CSR_DREQ() uint16 {
	return (volatile.LoadUint16(&o.TCD11_CSR.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetTCD11_CSR_ESG(value uint16) {
	volatile.StoreUint16(&o.TCD11_CSR.Reg, volatile.LoadUint16(&o.TCD11_CSR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetTCD11_CSR_ESG() uint16 {
	return (volatile.LoadUint16(&o.TCD11_CSR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetTCD11_CSR_MAJORELINK(value uint16) {
	volatile.StoreUint16(&o.TCD11_CSR.Reg, volatile.LoadUint16(&o.TCD11_CSR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetTCD11_CSR_MAJORELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD11_CSR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetTCD11_CSR_ACTIVE(value uint16) {
	volatile.StoreUint16(&o.TCD11_CSR.Reg, volatile.LoadUint16(&o.TCD11_CSR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetTCD11_CSR_ACTIVE() uint16 {
	return (volatile.LoadUint16(&o.TCD11_CSR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetTCD11_CSR_DONE(value uint16) {
	volatile.StoreUint16(&o.TCD11_CSR.Reg, volatile.LoadUint16(&o.TCD11_CSR.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetTCD11_CSR_DONE() uint16 {
	return (volatile.LoadUint16(&o.TCD11_CSR.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetTCD11_CSR_MAJORLINKCH(value uint16) {
	volatile.StoreUint16(&o.TCD11_CSR.Reg, volatile.LoadUint16(&o.TCD11_CSR.Reg)&^(0xf00)|value<<8)
}
func (o *DMA_Type) GetTCD11_CSR_MAJORLINKCH() uint16 {
	return (volatile.LoadUint16(&o.TCD11_CSR.Reg) & 0xf00) >> 8
}
func (o *DMA_Type) SetTCD11_CSR_BWC(value uint16) {
	volatile.StoreUint16(&o.TCD11_CSR.Reg, volatile.LoadUint16(&o.TCD11_CSR.Reg)&^(0xc000)|value<<14)
}
func (o *DMA_Type) GetTCD11_CSR_BWC() uint16 {
	return (volatile.LoadUint16(&o.TCD11_CSR.Reg) & 0xc000) >> 14
}

// DMA.TCD11_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD11_BITER_ELINKNO_BITER(value uint16) {
	volatile.StoreUint16(&o.TCD11_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD11_BITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD11_BITER_ELINKNO_BITER() uint16 {
	return volatile.LoadUint16(&o.TCD11_BITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD11_BITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD11_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD11_BITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD11_BITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD11_BITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD12_SADDR: TCD Source Address
func (o *DMA_Type) SetTCD12_SADDR(value uint32) {
	volatile.StoreUint32(&o.TCD12_SADDR.Reg, value)
}
func (o *DMA_Type) GetTCD12_SADDR() uint32 {
	return volatile.LoadUint32(&o.TCD12_SADDR.Reg)
}

// DMA.TCD12_SOFF: TCD Signed Source Address Offset
func (o *DMA_Type) SetTCD12_SOFF(value uint16) {
	volatile.StoreUint16(&o.TCD12_SOFF.Reg, value)
}
func (o *DMA_Type) GetTCD12_SOFF() uint16 {
	return volatile.LoadUint16(&o.TCD12_SOFF.Reg)
}

// DMA.TCD12_ATTR: TCD Transfer Attributes
func (o *DMA_Type) SetTCD12_ATTR_DSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD12_ATTR.Reg, volatile.LoadUint16(&o.TCD12_ATTR.Reg)&^(0x7)|value)
}
func (o *DMA_Type) GetTCD12_ATTR_DSIZE() uint16 {
	return volatile.LoadUint16(&o.TCD12_ATTR.Reg) & 0x7
}
func (o *DMA_Type) SetTCD12_ATTR_DMOD(value uint16) {
	volatile.StoreUint16(&o.TCD12_ATTR.Reg, volatile.LoadUint16(&o.TCD12_ATTR.Reg)&^(0xf8)|value<<3)
}
func (o *DMA_Type) GetTCD12_ATTR_DMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD12_ATTR.Reg) & 0xf8) >> 3
}
func (o *DMA_Type) SetTCD12_ATTR_SSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD12_ATTR.Reg, volatile.LoadUint16(&o.TCD12_ATTR.Reg)&^(0x700)|value<<8)
}
func (o *DMA_Type) GetTCD12_ATTR_SSIZE() uint16 {
	return (volatile.LoadUint16(&o.TCD12_ATTR.Reg) & 0x700) >> 8
}
func (o *DMA_Type) SetTCD12_ATTR_SMOD(value uint16) {
	volatile.StoreUint16(&o.TCD12_ATTR.Reg, volatile.LoadUint16(&o.TCD12_ATTR.Reg)&^(0xf800)|value<<11)
}
func (o *DMA_Type) GetTCD12_ATTR_SMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD12_ATTR.Reg) & 0xf800) >> 11
}

// DMA.TCD12_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Disabled)
func (o *DMA_Type) SetTCD12_NBYTES_MLNO(value uint32) {
	volatile.StoreUint32(&o.TCD12_NBYTES_MLNO.Reg, value)
}
func (o *DMA_Type) GetTCD12_NBYTES_MLNO() uint32 {
	return volatile.LoadUint32(&o.TCD12_NBYTES_MLNO.Reg)
}

// DMA.TCD12_SLAST: TCD Last Source Address Adjustment
func (o *DMA_Type) SetTCD12_SLAST(value uint32) {
	volatile.StoreUint32(&o.TCD12_SLAST.Reg, value)
}
func (o *DMA_Type) GetTCD12_SLAST() uint32 {
	return volatile.LoadUint32(&o.TCD12_SLAST.Reg)
}

// DMA.TCD12_DADDR: TCD Destination Address
func (o *DMA_Type) SetTCD12_DADDR(value uint32) {
	volatile.StoreUint32(&o.TCD12_DADDR.Reg, value)
}
func (o *DMA_Type) GetTCD12_DADDR() uint32 {
	return volatile.LoadUint32(&o.TCD12_DADDR.Reg)
}

// DMA.TCD12_DOFF: TCD Signed Destination Address Offset
func (o *DMA_Type) SetTCD12_DOFF(value uint16) {
	volatile.StoreUint16(&o.TCD12_DOFF.Reg, value)
}
func (o *DMA_Type) GetTCD12_DOFF() uint16 {
	return volatile.LoadUint16(&o.TCD12_DOFF.Reg)
}

// DMA.TCD12_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD12_CITER_ELINKNO_CITER(value uint16) {
	volatile.StoreUint16(&o.TCD12_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD12_CITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD12_CITER_ELINKNO_CITER() uint16 {
	return volatile.LoadUint16(&o.TCD12_CITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD12_CITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD12_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD12_CITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD12_CITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD12_CITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD12_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
func (o *DMA_Type) SetTCD12_DLASTSGA(value uint32) {
	volatile.StoreUint32(&o.TCD12_DLASTSGA.Reg, value)
}
func (o *DMA_Type) GetTCD12_DLASTSGA() uint32 {
	return volatile.LoadUint32(&o.TCD12_DLASTSGA.Reg)
}

// DMA.TCD12_CSR: TCD Control and Status
func (o *DMA_Type) SetTCD12_CSR_START(value uint16) {
	volatile.StoreUint16(&o.TCD12_CSR.Reg, volatile.LoadUint16(&o.TCD12_CSR.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetTCD12_CSR_START() uint16 {
	return volatile.LoadUint16(&o.TCD12_CSR.Reg) & 0x1
}
func (o *DMA_Type) SetTCD12_CSR_INTMAJOR(value uint16) {
	volatile.StoreUint16(&o.TCD12_CSR.Reg, volatile.LoadUint16(&o.TCD12_CSR.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetTCD12_CSR_INTMAJOR() uint16 {
	return (volatile.LoadUint16(&o.TCD12_CSR.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetTCD12_CSR_INTHALF(value uint16) {
	volatile.StoreUint16(&o.TCD12_CSR.Reg, volatile.LoadUint16(&o.TCD12_CSR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetTCD12_CSR_INTHALF() uint16 {
	return (volatile.LoadUint16(&o.TCD12_CSR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetTCD12_CSR_DREQ(value uint16) {
	volatile.StoreUint16(&o.TCD12_CSR.Reg, volatile.LoadUint16(&o.TCD12_CSR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetTCD12_CSR_DREQ() uint16 {
	return (volatile.LoadUint16(&o.TCD12_CSR.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetTCD12_CSR_ESG(value uint16) {
	volatile.StoreUint16(&o.TCD12_CSR.Reg, volatile.LoadUint16(&o.TCD12_CSR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetTCD12_CSR_ESG() uint16 {
	return (volatile.LoadUint16(&o.TCD12_CSR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetTCD12_CSR_MAJORELINK(value uint16) {
	volatile.StoreUint16(&o.TCD12_CSR.Reg, volatile.LoadUint16(&o.TCD12_CSR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetTCD12_CSR_MAJORELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD12_CSR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetTCD12_CSR_ACTIVE(value uint16) {
	volatile.StoreUint16(&o.TCD12_CSR.Reg, volatile.LoadUint16(&o.TCD12_CSR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetTCD12_CSR_ACTIVE() uint16 {
	return (volatile.LoadUint16(&o.TCD12_CSR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetTCD12_CSR_DONE(value uint16) {
	volatile.StoreUint16(&o.TCD12_CSR.Reg, volatile.LoadUint16(&o.TCD12_CSR.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetTCD12_CSR_DONE() uint16 {
	return (volatile.LoadUint16(&o.TCD12_CSR.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetTCD12_CSR_MAJORLINKCH(value uint16) {
	volatile.StoreUint16(&o.TCD12_CSR.Reg, volatile.LoadUint16(&o.TCD12_CSR.Reg)&^(0xf00)|value<<8)
}
func (o *DMA_Type) GetTCD12_CSR_MAJORLINKCH() uint16 {
	return (volatile.LoadUint16(&o.TCD12_CSR.Reg) & 0xf00) >> 8
}
func (o *DMA_Type) SetTCD12_CSR_BWC(value uint16) {
	volatile.StoreUint16(&o.TCD12_CSR.Reg, volatile.LoadUint16(&o.TCD12_CSR.Reg)&^(0xc000)|value<<14)
}
func (o *DMA_Type) GetTCD12_CSR_BWC() uint16 {
	return (volatile.LoadUint16(&o.TCD12_CSR.Reg) & 0xc000) >> 14
}

// DMA.TCD12_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD12_BITER_ELINKNO_BITER(value uint16) {
	volatile.StoreUint16(&o.TCD12_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD12_BITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD12_BITER_ELINKNO_BITER() uint16 {
	return volatile.LoadUint16(&o.TCD12_BITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD12_BITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD12_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD12_BITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD12_BITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD12_BITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD13_SADDR: TCD Source Address
func (o *DMA_Type) SetTCD13_SADDR(value uint32) {
	volatile.StoreUint32(&o.TCD13_SADDR.Reg, value)
}
func (o *DMA_Type) GetTCD13_SADDR() uint32 {
	return volatile.LoadUint32(&o.TCD13_SADDR.Reg)
}

// DMA.TCD13_SOFF: TCD Signed Source Address Offset
func (o *DMA_Type) SetTCD13_SOFF(value uint16) {
	volatile.StoreUint16(&o.TCD13_SOFF.Reg, value)
}
func (o *DMA_Type) GetTCD13_SOFF() uint16 {
	return volatile.LoadUint16(&o.TCD13_SOFF.Reg)
}

// DMA.TCD13_ATTR: TCD Transfer Attributes
func (o *DMA_Type) SetTCD13_ATTR_DSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD13_ATTR.Reg, volatile.LoadUint16(&o.TCD13_ATTR.Reg)&^(0x7)|value)
}
func (o *DMA_Type) GetTCD13_ATTR_DSIZE() uint16 {
	return volatile.LoadUint16(&o.TCD13_ATTR.Reg) & 0x7
}
func (o *DMA_Type) SetTCD13_ATTR_DMOD(value uint16) {
	volatile.StoreUint16(&o.TCD13_ATTR.Reg, volatile.LoadUint16(&o.TCD13_ATTR.Reg)&^(0xf8)|value<<3)
}
func (o *DMA_Type) GetTCD13_ATTR_DMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD13_ATTR.Reg) & 0xf8) >> 3
}
func (o *DMA_Type) SetTCD13_ATTR_SSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD13_ATTR.Reg, volatile.LoadUint16(&o.TCD13_ATTR.Reg)&^(0x700)|value<<8)
}
func (o *DMA_Type) GetTCD13_ATTR_SSIZE() uint16 {
	return (volatile.LoadUint16(&o.TCD13_ATTR.Reg) & 0x700) >> 8
}
func (o *DMA_Type) SetTCD13_ATTR_SMOD(value uint16) {
	volatile.StoreUint16(&o.TCD13_ATTR.Reg, volatile.LoadUint16(&o.TCD13_ATTR.Reg)&^(0xf800)|value<<11)
}
func (o *DMA_Type) GetTCD13_ATTR_SMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD13_ATTR.Reg) & 0xf800) >> 11
}

// DMA.TCD13_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Disabled)
func (o *DMA_Type) SetTCD13_NBYTES_MLNO(value uint32) {
	volatile.StoreUint32(&o.TCD13_NBYTES_MLNO.Reg, value)
}
func (o *DMA_Type) GetTCD13_NBYTES_MLNO() uint32 {
	return volatile.LoadUint32(&o.TCD13_NBYTES_MLNO.Reg)
}

// DMA.TCD13_SLAST: TCD Last Source Address Adjustment
func (o *DMA_Type) SetTCD13_SLAST(value uint32) {
	volatile.StoreUint32(&o.TCD13_SLAST.Reg, value)
}
func (o *DMA_Type) GetTCD13_SLAST() uint32 {
	return volatile.LoadUint32(&o.TCD13_SLAST.Reg)
}

// DMA.TCD13_DADDR: TCD Destination Address
func (o *DMA_Type) SetTCD13_DADDR(value uint32) {
	volatile.StoreUint32(&o.TCD13_DADDR.Reg, value)
}
func (o *DMA_Type) GetTCD13_DADDR() uint32 {
	return volatile.LoadUint32(&o.TCD13_DADDR.Reg)
}

// DMA.TCD13_DOFF: TCD Signed Destination Address Offset
func (o *DMA_Type) SetTCD13_DOFF(value uint16) {
	volatile.StoreUint16(&o.TCD13_DOFF.Reg, value)
}
func (o *DMA_Type) GetTCD13_DOFF() uint16 {
	return volatile.LoadUint16(&o.TCD13_DOFF.Reg)
}

// DMA.TCD13_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD13_CITER_ELINKNO_CITER(value uint16) {
	volatile.StoreUint16(&o.TCD13_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD13_CITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD13_CITER_ELINKNO_CITER() uint16 {
	return volatile.LoadUint16(&o.TCD13_CITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD13_CITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD13_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD13_CITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD13_CITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD13_CITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD13_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
func (o *DMA_Type) SetTCD13_DLASTSGA(value uint32) {
	volatile.StoreUint32(&o.TCD13_DLASTSGA.Reg, value)
}
func (o *DMA_Type) GetTCD13_DLASTSGA() uint32 {
	return volatile.LoadUint32(&o.TCD13_DLASTSGA.Reg)
}

// DMA.TCD13_CSR: TCD Control and Status
func (o *DMA_Type) SetTCD13_CSR_START(value uint16) {
	volatile.StoreUint16(&o.TCD13_CSR.Reg, volatile.LoadUint16(&o.TCD13_CSR.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetTCD13_CSR_START() uint16 {
	return volatile.LoadUint16(&o.TCD13_CSR.Reg) & 0x1
}
func (o *DMA_Type) SetTCD13_CSR_INTMAJOR(value uint16) {
	volatile.StoreUint16(&o.TCD13_CSR.Reg, volatile.LoadUint16(&o.TCD13_CSR.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetTCD13_CSR_INTMAJOR() uint16 {
	return (volatile.LoadUint16(&o.TCD13_CSR.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetTCD13_CSR_INTHALF(value uint16) {
	volatile.StoreUint16(&o.TCD13_CSR.Reg, volatile.LoadUint16(&o.TCD13_CSR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetTCD13_CSR_INTHALF() uint16 {
	return (volatile.LoadUint16(&o.TCD13_CSR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetTCD13_CSR_DREQ(value uint16) {
	volatile.StoreUint16(&o.TCD13_CSR.Reg, volatile.LoadUint16(&o.TCD13_CSR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetTCD13_CSR_DREQ() uint16 {
	return (volatile.LoadUint16(&o.TCD13_CSR.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetTCD13_CSR_ESG(value uint16) {
	volatile.StoreUint16(&o.TCD13_CSR.Reg, volatile.LoadUint16(&o.TCD13_CSR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetTCD13_CSR_ESG() uint16 {
	return (volatile.LoadUint16(&o.TCD13_CSR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetTCD13_CSR_MAJORELINK(value uint16) {
	volatile.StoreUint16(&o.TCD13_CSR.Reg, volatile.LoadUint16(&o.TCD13_CSR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetTCD13_CSR_MAJORELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD13_CSR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetTCD13_CSR_ACTIVE(value uint16) {
	volatile.StoreUint16(&o.TCD13_CSR.Reg, volatile.LoadUint16(&o.TCD13_CSR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetTCD13_CSR_ACTIVE() uint16 {
	return (volatile.LoadUint16(&o.TCD13_CSR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetTCD13_CSR_DONE(value uint16) {
	volatile.StoreUint16(&o.TCD13_CSR.Reg, volatile.LoadUint16(&o.TCD13_CSR.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetTCD13_CSR_DONE() uint16 {
	return (volatile.LoadUint16(&o.TCD13_CSR.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetTCD13_CSR_MAJORLINKCH(value uint16) {
	volatile.StoreUint16(&o.TCD13_CSR.Reg, volatile.LoadUint16(&o.TCD13_CSR.Reg)&^(0xf00)|value<<8)
}
func (o *DMA_Type) GetTCD13_CSR_MAJORLINKCH() uint16 {
	return (volatile.LoadUint16(&o.TCD13_CSR.Reg) & 0xf00) >> 8
}
func (o *DMA_Type) SetTCD13_CSR_BWC(value uint16) {
	volatile.StoreUint16(&o.TCD13_CSR.Reg, volatile.LoadUint16(&o.TCD13_CSR.Reg)&^(0xc000)|value<<14)
}
func (o *DMA_Type) GetTCD13_CSR_BWC() uint16 {
	return (volatile.LoadUint16(&o.TCD13_CSR.Reg) & 0xc000) >> 14
}

// DMA.TCD13_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD13_BITER_ELINKNO_BITER(value uint16) {
	volatile.StoreUint16(&o.TCD13_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD13_BITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD13_BITER_ELINKNO_BITER() uint16 {
	return volatile.LoadUint16(&o.TCD13_BITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD13_BITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD13_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD13_BITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD13_BITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD13_BITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD14_SADDR: TCD Source Address
func (o *DMA_Type) SetTCD14_SADDR(value uint32) {
	volatile.StoreUint32(&o.TCD14_SADDR.Reg, value)
}
func (o *DMA_Type) GetTCD14_SADDR() uint32 {
	return volatile.LoadUint32(&o.TCD14_SADDR.Reg)
}

// DMA.TCD14_SOFF: TCD Signed Source Address Offset
func (o *DMA_Type) SetTCD14_SOFF(value uint16) {
	volatile.StoreUint16(&o.TCD14_SOFF.Reg, value)
}
func (o *DMA_Type) GetTCD14_SOFF() uint16 {
	return volatile.LoadUint16(&o.TCD14_SOFF.Reg)
}

// DMA.TCD14_ATTR: TCD Transfer Attributes
func (o *DMA_Type) SetTCD14_ATTR_DSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD14_ATTR.Reg, volatile.LoadUint16(&o.TCD14_ATTR.Reg)&^(0x7)|value)
}
func (o *DMA_Type) GetTCD14_ATTR_DSIZE() uint16 {
	return volatile.LoadUint16(&o.TCD14_ATTR.Reg) & 0x7
}
func (o *DMA_Type) SetTCD14_ATTR_DMOD(value uint16) {
	volatile.StoreUint16(&o.TCD14_ATTR.Reg, volatile.LoadUint16(&o.TCD14_ATTR.Reg)&^(0xf8)|value<<3)
}
func (o *DMA_Type) GetTCD14_ATTR_DMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD14_ATTR.Reg) & 0xf8) >> 3
}
func (o *DMA_Type) SetTCD14_ATTR_SSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD14_ATTR.Reg, volatile.LoadUint16(&o.TCD14_ATTR.Reg)&^(0x700)|value<<8)
}
func (o *DMA_Type) GetTCD14_ATTR_SSIZE() uint16 {
	return (volatile.LoadUint16(&o.TCD14_ATTR.Reg) & 0x700) >> 8
}
func (o *DMA_Type) SetTCD14_ATTR_SMOD(value uint16) {
	volatile.StoreUint16(&o.TCD14_ATTR.Reg, volatile.LoadUint16(&o.TCD14_ATTR.Reg)&^(0xf800)|value<<11)
}
func (o *DMA_Type) GetTCD14_ATTR_SMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD14_ATTR.Reg) & 0xf800) >> 11
}

// DMA.TCD14_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Disabled)
func (o *DMA_Type) SetTCD14_NBYTES_MLNO(value uint32) {
	volatile.StoreUint32(&o.TCD14_NBYTES_MLNO.Reg, value)
}
func (o *DMA_Type) GetTCD14_NBYTES_MLNO() uint32 {
	return volatile.LoadUint32(&o.TCD14_NBYTES_MLNO.Reg)
}

// DMA.TCD14_SLAST: TCD Last Source Address Adjustment
func (o *DMA_Type) SetTCD14_SLAST(value uint32) {
	volatile.StoreUint32(&o.TCD14_SLAST.Reg, value)
}
func (o *DMA_Type) GetTCD14_SLAST() uint32 {
	return volatile.LoadUint32(&o.TCD14_SLAST.Reg)
}

// DMA.TCD14_DADDR: TCD Destination Address
func (o *DMA_Type) SetTCD14_DADDR(value uint32) {
	volatile.StoreUint32(&o.TCD14_DADDR.Reg, value)
}
func (o *DMA_Type) GetTCD14_DADDR() uint32 {
	return volatile.LoadUint32(&o.TCD14_DADDR.Reg)
}

// DMA.TCD14_DOFF: TCD Signed Destination Address Offset
func (o *DMA_Type) SetTCD14_DOFF(value uint16) {
	volatile.StoreUint16(&o.TCD14_DOFF.Reg, value)
}
func (o *DMA_Type) GetTCD14_DOFF() uint16 {
	return volatile.LoadUint16(&o.TCD14_DOFF.Reg)
}

// DMA.TCD14_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD14_CITER_ELINKNO_CITER(value uint16) {
	volatile.StoreUint16(&o.TCD14_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD14_CITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD14_CITER_ELINKNO_CITER() uint16 {
	return volatile.LoadUint16(&o.TCD14_CITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD14_CITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD14_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD14_CITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD14_CITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD14_CITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD14_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
func (o *DMA_Type) SetTCD14_DLASTSGA(value uint32) {
	volatile.StoreUint32(&o.TCD14_DLASTSGA.Reg, value)
}
func (o *DMA_Type) GetTCD14_DLASTSGA() uint32 {
	return volatile.LoadUint32(&o.TCD14_DLASTSGA.Reg)
}

// DMA.TCD14_CSR: TCD Control and Status
func (o *DMA_Type) SetTCD14_CSR_START(value uint16) {
	volatile.StoreUint16(&o.TCD14_CSR.Reg, volatile.LoadUint16(&o.TCD14_CSR.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetTCD14_CSR_START() uint16 {
	return volatile.LoadUint16(&o.TCD14_CSR.Reg) & 0x1
}
func (o *DMA_Type) SetTCD14_CSR_INTMAJOR(value uint16) {
	volatile.StoreUint16(&o.TCD14_CSR.Reg, volatile.LoadUint16(&o.TCD14_CSR.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetTCD14_CSR_INTMAJOR() uint16 {
	return (volatile.LoadUint16(&o.TCD14_CSR.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetTCD14_CSR_INTHALF(value uint16) {
	volatile.StoreUint16(&o.TCD14_CSR.Reg, volatile.LoadUint16(&o.TCD14_CSR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetTCD14_CSR_INTHALF() uint16 {
	return (volatile.LoadUint16(&o.TCD14_CSR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetTCD14_CSR_DREQ(value uint16) {
	volatile.StoreUint16(&o.TCD14_CSR.Reg, volatile.LoadUint16(&o.TCD14_CSR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetTCD14_CSR_DREQ() uint16 {
	return (volatile.LoadUint16(&o.TCD14_CSR.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetTCD14_CSR_ESG(value uint16) {
	volatile.StoreUint16(&o.TCD14_CSR.Reg, volatile.LoadUint16(&o.TCD14_CSR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetTCD14_CSR_ESG() uint16 {
	return (volatile.LoadUint16(&o.TCD14_CSR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetTCD14_CSR_MAJORELINK(value uint16) {
	volatile.StoreUint16(&o.TCD14_CSR.Reg, volatile.LoadUint16(&o.TCD14_CSR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetTCD14_CSR_MAJORELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD14_CSR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetTCD14_CSR_ACTIVE(value uint16) {
	volatile.StoreUint16(&o.TCD14_CSR.Reg, volatile.LoadUint16(&o.TCD14_CSR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetTCD14_CSR_ACTIVE() uint16 {
	return (volatile.LoadUint16(&o.TCD14_CSR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetTCD14_CSR_DONE(value uint16) {
	volatile.StoreUint16(&o.TCD14_CSR.Reg, volatile.LoadUint16(&o.TCD14_CSR.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetTCD14_CSR_DONE() uint16 {
	return (volatile.LoadUint16(&o.TCD14_CSR.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetTCD14_CSR_MAJORLINKCH(value uint16) {
	volatile.StoreUint16(&o.TCD14_CSR.Reg, volatile.LoadUint16(&o.TCD14_CSR.Reg)&^(0xf00)|value<<8)
}
func (o *DMA_Type) GetTCD14_CSR_MAJORLINKCH() uint16 {
	return (volatile.LoadUint16(&o.TCD14_CSR.Reg) & 0xf00) >> 8
}
func (o *DMA_Type) SetTCD14_CSR_BWC(value uint16) {
	volatile.StoreUint16(&o.TCD14_CSR.Reg, volatile.LoadUint16(&o.TCD14_CSR.Reg)&^(0xc000)|value<<14)
}
func (o *DMA_Type) GetTCD14_CSR_BWC() uint16 {
	return (volatile.LoadUint16(&o.TCD14_CSR.Reg) & 0xc000) >> 14
}

// DMA.TCD14_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD14_BITER_ELINKNO_BITER(value uint16) {
	volatile.StoreUint16(&o.TCD14_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD14_BITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD14_BITER_ELINKNO_BITER() uint16 {
	return volatile.LoadUint16(&o.TCD14_BITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD14_BITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD14_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD14_BITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD14_BITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD14_BITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD15_SADDR: TCD Source Address
func (o *DMA_Type) SetTCD15_SADDR(value uint32) {
	volatile.StoreUint32(&o.TCD15_SADDR.Reg, value)
}
func (o *DMA_Type) GetTCD15_SADDR() uint32 {
	return volatile.LoadUint32(&o.TCD15_SADDR.Reg)
}

// DMA.TCD15_SOFF: TCD Signed Source Address Offset
func (o *DMA_Type) SetTCD15_SOFF(value uint16) {
	volatile.StoreUint16(&o.TCD15_SOFF.Reg, value)
}
func (o *DMA_Type) GetTCD15_SOFF() uint16 {
	return volatile.LoadUint16(&o.TCD15_SOFF.Reg)
}

// DMA.TCD15_ATTR: TCD Transfer Attributes
func (o *DMA_Type) SetTCD15_ATTR_DSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD15_ATTR.Reg, volatile.LoadUint16(&o.TCD15_ATTR.Reg)&^(0x7)|value)
}
func (o *DMA_Type) GetTCD15_ATTR_DSIZE() uint16 {
	return volatile.LoadUint16(&o.TCD15_ATTR.Reg) & 0x7
}
func (o *DMA_Type) SetTCD15_ATTR_DMOD(value uint16) {
	volatile.StoreUint16(&o.TCD15_ATTR.Reg, volatile.LoadUint16(&o.TCD15_ATTR.Reg)&^(0xf8)|value<<3)
}
func (o *DMA_Type) GetTCD15_ATTR_DMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD15_ATTR.Reg) & 0xf8) >> 3
}
func (o *DMA_Type) SetTCD15_ATTR_SSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD15_ATTR.Reg, volatile.LoadUint16(&o.TCD15_ATTR.Reg)&^(0x700)|value<<8)
}
func (o *DMA_Type) GetTCD15_ATTR_SSIZE() uint16 {
	return (volatile.LoadUint16(&o.TCD15_ATTR.Reg) & 0x700) >> 8
}
func (o *DMA_Type) SetTCD15_ATTR_SMOD(value uint16) {
	volatile.StoreUint16(&o.TCD15_ATTR.Reg, volatile.LoadUint16(&o.TCD15_ATTR.Reg)&^(0xf800)|value<<11)
}
func (o *DMA_Type) GetTCD15_ATTR_SMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD15_ATTR.Reg) & 0xf800) >> 11
}

// DMA.TCD15_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Disabled)
func (o *DMA_Type) SetTCD15_NBYTES_MLNO(value uint32) {
	volatile.StoreUint32(&o.TCD15_NBYTES_MLNO.Reg, value)
}
func (o *DMA_Type) GetTCD15_NBYTES_MLNO() uint32 {
	return volatile.LoadUint32(&o.TCD15_NBYTES_MLNO.Reg)
}

// DMA.TCD15_SLAST: TCD Last Source Address Adjustment
func (o *DMA_Type) SetTCD15_SLAST(value uint32) {
	volatile.StoreUint32(&o.TCD15_SLAST.Reg, value)
}
func (o *DMA_Type) GetTCD15_SLAST() uint32 {
	return volatile.LoadUint32(&o.TCD15_SLAST.Reg)
}

// DMA.TCD15_DADDR: TCD Destination Address
func (o *DMA_Type) SetTCD15_DADDR(value uint32) {
	volatile.StoreUint32(&o.TCD15_DADDR.Reg, value)
}
func (o *DMA_Type) GetTCD15_DADDR() uint32 {
	return volatile.LoadUint32(&o.TCD15_DADDR.Reg)
}

// DMA.TCD15_DOFF: TCD Signed Destination Address Offset
func (o *DMA_Type) SetTCD15_DOFF(value uint16) {
	volatile.StoreUint16(&o.TCD15_DOFF.Reg, value)
}
func (o *DMA_Type) GetTCD15_DOFF() uint16 {
	return volatile.LoadUint16(&o.TCD15_DOFF.Reg)
}

// DMA.TCD15_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD15_CITER_ELINKNO_CITER(value uint16) {
	volatile.StoreUint16(&o.TCD15_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD15_CITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD15_CITER_ELINKNO_CITER() uint16 {
	return volatile.LoadUint16(&o.TCD15_CITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD15_CITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD15_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD15_CITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD15_CITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD15_CITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD15_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
func (o *DMA_Type) SetTCD15_DLASTSGA(value uint32) {
	volatile.StoreUint32(&o.TCD15_DLASTSGA.Reg, value)
}
func (o *DMA_Type) GetTCD15_DLASTSGA() uint32 {
	return volatile.LoadUint32(&o.TCD15_DLASTSGA.Reg)
}

// DMA.TCD15_CSR: TCD Control and Status
func (o *DMA_Type) SetTCD15_CSR_START(value uint16) {
	volatile.StoreUint16(&o.TCD15_CSR.Reg, volatile.LoadUint16(&o.TCD15_CSR.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetTCD15_CSR_START() uint16 {
	return volatile.LoadUint16(&o.TCD15_CSR.Reg) & 0x1
}
func (o *DMA_Type) SetTCD15_CSR_INTMAJOR(value uint16) {
	volatile.StoreUint16(&o.TCD15_CSR.Reg, volatile.LoadUint16(&o.TCD15_CSR.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetTCD15_CSR_INTMAJOR() uint16 {
	return (volatile.LoadUint16(&o.TCD15_CSR.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetTCD15_CSR_INTHALF(value uint16) {
	volatile.StoreUint16(&o.TCD15_CSR.Reg, volatile.LoadUint16(&o.TCD15_CSR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetTCD15_CSR_INTHALF() uint16 {
	return (volatile.LoadUint16(&o.TCD15_CSR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetTCD15_CSR_DREQ(value uint16) {
	volatile.StoreUint16(&o.TCD15_CSR.Reg, volatile.LoadUint16(&o.TCD15_CSR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetTCD15_CSR_DREQ() uint16 {
	return (volatile.LoadUint16(&o.TCD15_CSR.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetTCD15_CSR_ESG(value uint16) {
	volatile.StoreUint16(&o.TCD15_CSR.Reg, volatile.LoadUint16(&o.TCD15_CSR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetTCD15_CSR_ESG() uint16 {
	return (volatile.LoadUint16(&o.TCD15_CSR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetTCD15_CSR_MAJORELINK(value uint16) {
	volatile.StoreUint16(&o.TCD15_CSR.Reg, volatile.LoadUint16(&o.TCD15_CSR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetTCD15_CSR_MAJORELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD15_CSR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetTCD15_CSR_ACTIVE(value uint16) {
	volatile.StoreUint16(&o.TCD15_CSR.Reg, volatile.LoadUint16(&o.TCD15_CSR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetTCD15_CSR_ACTIVE() uint16 {
	return (volatile.LoadUint16(&o.TCD15_CSR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetTCD15_CSR_DONE(value uint16) {
	volatile.StoreUint16(&o.TCD15_CSR.Reg, volatile.LoadUint16(&o.TCD15_CSR.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetTCD15_CSR_DONE() uint16 {
	return (volatile.LoadUint16(&o.TCD15_CSR.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetTCD15_CSR_MAJORLINKCH(value uint16) {
	volatile.StoreUint16(&o.TCD15_CSR.Reg, volatile.LoadUint16(&o.TCD15_CSR.Reg)&^(0xf00)|value<<8)
}
func (o *DMA_Type) GetTCD15_CSR_MAJORLINKCH() uint16 {
	return (volatile.LoadUint16(&o.TCD15_CSR.Reg) & 0xf00) >> 8
}
func (o *DMA_Type) SetTCD15_CSR_BWC(value uint16) {
	volatile.StoreUint16(&o.TCD15_CSR.Reg, volatile.LoadUint16(&o.TCD15_CSR.Reg)&^(0xc000)|value<<14)
}
func (o *DMA_Type) GetTCD15_CSR_BWC() uint16 {
	return (volatile.LoadUint16(&o.TCD15_CSR.Reg) & 0xc000) >> 14
}

// DMA.TCD15_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD15_BITER_ELINKNO_BITER(value uint16) {
	volatile.StoreUint16(&o.TCD15_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD15_BITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD15_BITER_ELINKNO_BITER() uint16 {
	return volatile.LoadUint16(&o.TCD15_BITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD15_BITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD15_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD15_BITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD15_BITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD15_BITER_ELINKNO.Reg) & 0x8000) >> 15
}

// FlexBus external bus interface
type FB_Type struct {
	CSAR0  volatile.Register32 // 0x0
	CSMR0  volatile.Register32 // 0x4
	CSCR0  volatile.Register32 // 0x8
	CSAR1  volatile.Register32 // 0xC
	CSMR1  volatile.Register32 // 0x10
	CSCR1  volatile.Register32 // 0x14
	CSAR2  volatile.Register32 // 0x18
	CSMR2  volatile.Register32 // 0x1C
	CSCR2  volatile.Register32 // 0x20
	CSAR3  volatile.Register32 // 0x24
	CSMR3  volatile.Register32 // 0x28
	CSCR3  volatile.Register32 // 0x2C
	CSAR4  volatile.Register32 // 0x30
	CSMR4  volatile.Register32 // 0x34
	CSCR4  volatile.Register32 // 0x38
	CSAR5  volatile.Register32 // 0x3C
	CSMR5  volatile.Register32 // 0x40
	CSCR5  volatile.Register32 // 0x44
	_      [24]byte
	CSPMCR volatile.Register32 // 0x60
}

// FB.CSAR0: Chip Select Address Register
func (o *FB_Type) SetCSAR0_BA(value uint32) {
	volatile.StoreUint32(&o.CSAR0.Reg, volatile.LoadUint32(&o.CSAR0.Reg)&^(0xffff0000)|value<<16)
}
func (o *FB_Type) GetCSAR0_BA() uint32 {
	return (volatile.LoadUint32(&o.CSAR0.Reg) & 0xffff0000) >> 16
}

// FB.CSMR0: Chip Select Mask Register
func (o *FB_Type) SetCSMR0_V(value uint32) {
	volatile.StoreUint32(&o.CSMR0.Reg, volatile.LoadUint32(&o.CSMR0.Reg)&^(0x1)|value)
}
func (o *FB_Type) GetCSMR0_V() uint32 {
	return volatile.LoadUint32(&o.CSMR0.Reg) & 0x1
}
func (o *FB_Type) SetCSMR0_WP(value uint32) {
	volatile.StoreUint32(&o.CSMR0.Reg, volatile.LoadUint32(&o.CSMR0.Reg)&^(0x100)|value<<8)
}
func (o *FB_Type) GetCSMR0_WP() uint32 {
	return (volatile.LoadUint32(&o.CSMR0.Reg) & 0x100) >> 8
}
func (o *FB_Type) SetCSMR0_BAM(value uint32) {
	volatile.StoreUint32(&o.CSMR0.Reg, volatile.LoadUint32(&o.CSMR0.Reg)&^(0xffff0000)|value<<16)
}
func (o *FB_Type) GetCSMR0_BAM() uint32 {
	return (volatile.LoadUint32(&o.CSMR0.Reg) & 0xffff0000) >> 16
}

// FB.CSCR0: Chip Select Control Register
func (o *FB_Type) SetCSCR0_BSTW(value uint32) {
	volatile.StoreUint32(&o.CSCR0.Reg, volatile.LoadUint32(&o.CSCR0.Reg)&^(0x8)|value<<3)
}
func (o *FB_Type) GetCSCR0_BSTW() uint32 {
	return (volatile.LoadUint32(&o.CSCR0.Reg) & 0x8) >> 3
}
func (o *FB_Type) SetCSCR0_BSTR(value uint32) {
	volatile.StoreUint32(&o.CSCR0.Reg, volatile.LoadUint32(&o.CSCR0.Reg)&^(0x10)|value<<4)
}
func (o *FB_Type) GetCSCR0_BSTR() uint32 {
	return (volatile.LoadUint32(&o.CSCR0.Reg) & 0x10) >> 4
}
func (o *FB_Type) SetCSCR0_BEM(value uint32) {
	volatile.StoreUint32(&o.CSCR0.Reg, volatile.LoadUint32(&o.CSCR0.Reg)&^(0x20)|value<<5)
}
func (o *FB_Type) GetCSCR0_BEM() uint32 {
	return (volatile.LoadUint32(&o.CSCR0.Reg) & 0x20) >> 5
}
func (o *FB_Type) SetCSCR0_PS(value uint32) {
	volatile.StoreUint32(&o.CSCR0.Reg, volatile.LoadUint32(&o.CSCR0.Reg)&^(0xc0)|value<<6)
}
func (o *FB_Type) GetCSCR0_PS() uint32 {
	return (volatile.LoadUint32(&o.CSCR0.Reg) & 0xc0) >> 6
}
func (o *FB_Type) SetCSCR0_AA(value uint32) {
	volatile.StoreUint32(&o.CSCR0.Reg, volatile.LoadUint32(&o.CSCR0.Reg)&^(0x100)|value<<8)
}
func (o *FB_Type) GetCSCR0_AA() uint32 {
	return (volatile.LoadUint32(&o.CSCR0.Reg) & 0x100) >> 8
}
func (o *FB_Type) SetCSCR0_BLS(value uint32) {
	volatile.StoreUint32(&o.CSCR0.Reg, volatile.LoadUint32(&o.CSCR0.Reg)&^(0x200)|value<<9)
}
func (o *FB_Type) GetCSCR0_BLS() uint32 {
	return (volatile.LoadUint32(&o.CSCR0.Reg) & 0x200) >> 9
}
func (o *FB_Type) SetCSCR0_WS(value uint32) {
	volatile.StoreUint32(&o.CSCR0.Reg, volatile.LoadUint32(&o.CSCR0.Reg)&^(0xfc00)|value<<10)
}
func (o *FB_Type) GetCSCR0_WS() uint32 {
	return (volatile.LoadUint32(&o.CSCR0.Reg) & 0xfc00) >> 10
}
func (o *FB_Type) SetCSCR0_WRAH(value uint32) {
	volatile.StoreUint32(&o.CSCR0.Reg, volatile.LoadUint32(&o.CSCR0.Reg)&^(0x30000)|value<<16)
}
func (o *FB_Type) GetCSCR0_WRAH() uint32 {
	return (volatile.LoadUint32(&o.CSCR0.Reg) & 0x30000) >> 16
}
func (o *FB_Type) SetCSCR0_RDAH(value uint32) {
	volatile.StoreUint32(&o.CSCR0.Reg, volatile.LoadUint32(&o.CSCR0.Reg)&^(0xc0000)|value<<18)
}
func (o *FB_Type) GetCSCR0_RDAH() uint32 {
	return (volatile.LoadUint32(&o.CSCR0.Reg) & 0xc0000) >> 18
}
func (o *FB_Type) SetCSCR0_ASET(value uint32) {
	volatile.StoreUint32(&o.CSCR0.Reg, volatile.LoadUint32(&o.CSCR0.Reg)&^(0x300000)|value<<20)
}
func (o *FB_Type) GetCSCR0_ASET() uint32 {
	return (volatile.LoadUint32(&o.CSCR0.Reg) & 0x300000) >> 20
}
func (o *FB_Type) SetCSCR0_EXTS(value uint32) {
	volatile.StoreUint32(&o.CSCR0.Reg, volatile.LoadUint32(&o.CSCR0.Reg)&^(0x400000)|value<<22)
}
func (o *FB_Type) GetCSCR0_EXTS() uint32 {
	return (volatile.LoadUint32(&o.CSCR0.Reg) & 0x400000) >> 22
}
func (o *FB_Type) SetCSCR0_SWSEN(value uint32) {
	volatile.StoreUint32(&o.CSCR0.Reg, volatile.LoadUint32(&o.CSCR0.Reg)&^(0x800000)|value<<23)
}
func (o *FB_Type) GetCSCR0_SWSEN() uint32 {
	return (volatile.LoadUint32(&o.CSCR0.Reg) & 0x800000) >> 23
}
func (o *FB_Type) SetCSCR0_SWS(value uint32) {
	volatile.StoreUint32(&o.CSCR0.Reg, volatile.LoadUint32(&o.CSCR0.Reg)&^(0xfc000000)|value<<26)
}
func (o *FB_Type) GetCSCR0_SWS() uint32 {
	return (volatile.LoadUint32(&o.CSCR0.Reg) & 0xfc000000) >> 26
}

// FB.CSAR1: Chip Select Address Register
func (o *FB_Type) SetCSAR1_BA(value uint32) {
	volatile.StoreUint32(&o.CSAR1.Reg, volatile.LoadUint32(&o.CSAR1.Reg)&^(0xffff0000)|value<<16)
}
func (o *FB_Type) GetCSAR1_BA() uint32 {
	return (volatile.LoadUint32(&o.CSAR1.Reg) & 0xffff0000) >> 16
}

// FB.CSMR1: Chip Select Mask Register
func (o *FB_Type) SetCSMR1_V(value uint32) {
	volatile.StoreUint32(&o.CSMR1.Reg, volatile.LoadUint32(&o.CSMR1.Reg)&^(0x1)|value)
}
func (o *FB_Type) GetCSMR1_V() uint32 {
	return volatile.LoadUint32(&o.CSMR1.Reg) & 0x1
}
func (o *FB_Type) SetCSMR1_WP(value uint32) {
	volatile.StoreUint32(&o.CSMR1.Reg, volatile.LoadUint32(&o.CSMR1.Reg)&^(0x100)|value<<8)
}
func (o *FB_Type) GetCSMR1_WP() uint32 {
	return (volatile.LoadUint32(&o.CSMR1.Reg) & 0x100) >> 8
}
func (o *FB_Type) SetCSMR1_BAM(value uint32) {
	volatile.StoreUint32(&o.CSMR1.Reg, volatile.LoadUint32(&o.CSMR1.Reg)&^(0xffff0000)|value<<16)
}
func (o *FB_Type) GetCSMR1_BAM() uint32 {
	return (volatile.LoadUint32(&o.CSMR1.Reg) & 0xffff0000) >> 16
}

// FB.CSCR1: Chip Select Control Register
func (o *FB_Type) SetCSCR1_BSTW(value uint32) {
	volatile.StoreUint32(&o.CSCR1.Reg, volatile.LoadUint32(&o.CSCR1.Reg)&^(0x8)|value<<3)
}
func (o *FB_Type) GetCSCR1_BSTW() uint32 {
	return (volatile.LoadUint32(&o.CSCR1.Reg) & 0x8) >> 3
}
func (o *FB_Type) SetCSCR1_BSTR(value uint32) {
	volatile.StoreUint32(&o.CSCR1.Reg, volatile.LoadUint32(&o.CSCR1.Reg)&^(0x10)|value<<4)
}
func (o *FB_Type) GetCSCR1_BSTR() uint32 {
	return (volatile.LoadUint32(&o.CSCR1.Reg) & 0x10) >> 4
}
func (o *FB_Type) SetCSCR1_BEM(value uint32) {
	volatile.StoreUint32(&o.CSCR1.Reg, volatile.LoadUint32(&o.CSCR1.Reg)&^(0x20)|value<<5)
}
func (o *FB_Type) GetCSCR1_BEM() uint32 {
	return (volatile.LoadUint32(&o.CSCR1.Reg) & 0x20) >> 5
}
func (o *FB_Type) SetCSCR1_PS(value uint32) {
	volatile.StoreUint32(&o.CSCR1.Reg, volatile.LoadUint32(&o.CSCR1.Reg)&^(0xc0)|value<<6)
}
func (o *FB_Type) GetCSCR1_PS() uint32 {
	return (volatile.LoadUint32(&o.CSCR1.Reg) & 0xc0) >> 6
}
func (o *FB_Type) SetCSCR1_AA(value uint32) {
	volatile.StoreUint32(&o.CSCR1.Reg, volatile.LoadUint32(&o.CSCR1.Reg)&^(0x100)|value<<8)
}
func (o *FB_Type) GetCSCR1_AA() uint32 {
	return (volatile.LoadUint32(&o.CSCR1.Reg) & 0x100) >> 8
}
func (o *FB_Type) SetCSCR1_BLS(value uint32) {
	volatile.StoreUint32(&o.CSCR1.Reg, volatile.LoadUint32(&o.CSCR1.Reg)&^(0x200)|value<<9)
}
func (o *FB_Type) GetCSCR1_BLS() uint32 {
	return (volatile.LoadUint32(&o.CSCR1.Reg) & 0x200) >> 9
}
func (o *FB_Type) SetCSCR1_WS(value uint32) {
	volatile.StoreUint32(&o.CSCR1.Reg, volatile.LoadUint32(&o.CSCR1.Reg)&^(0xfc00)|value<<10)
}
func (o *FB_Type) GetCSCR1_WS() uint32 {
	return (volatile.LoadUint32(&o.CSCR1.Reg) & 0xfc00) >> 10
}
func (o *FB_Type) SetCSCR1_WRAH(value uint32) {
	volatile.StoreUint32(&o.CSCR1.Reg, volatile.LoadUint32(&o.CSCR1.Reg)&^(0x30000)|value<<16)
}
func (o *FB_Type) GetCSCR1_WRAH() uint32 {
	return (volatile.LoadUint32(&o.CSCR1.Reg) & 0x30000) >> 16
}
func (o *FB_Type) SetCSCR1_RDAH(value uint32) {
	volatile.StoreUint32(&o.CSCR1.Reg, volatile.LoadUint32(&o.CSCR1.Reg)&^(0xc0000)|value<<18)
}
func (o *FB_Type) GetCSCR1_RDAH() uint32 {
	return (volatile.LoadUint32(&o.CSCR1.Reg) & 0xc0000) >> 18
}
func (o *FB_Type) SetCSCR1_ASET(value uint32) {
	volatile.StoreUint32(&o.CSCR1.Reg, volatile.LoadUint32(&o.CSCR1.Reg)&^(0x300000)|value<<20)
}
func (o *FB_Type) GetCSCR1_ASET() uint32 {
	return (volatile.LoadUint32(&o.CSCR1.Reg) & 0x300000) >> 20
}
func (o *FB_Type) SetCSCR1_EXTS(value uint32) {
	volatile.StoreUint32(&o.CSCR1.Reg, volatile.LoadUint32(&o.CSCR1.Reg)&^(0x400000)|value<<22)
}
func (o *FB_Type) GetCSCR1_EXTS() uint32 {
	return (volatile.LoadUint32(&o.CSCR1.Reg) & 0x400000) >> 22
}
func (o *FB_Type) SetCSCR1_SWSEN(value uint32) {
	volatile.StoreUint32(&o.CSCR1.Reg, volatile.LoadUint32(&o.CSCR1.Reg)&^(0x800000)|value<<23)
}
func (o *FB_Type) GetCSCR1_SWSEN() uint32 {
	return (volatile.LoadUint32(&o.CSCR1.Reg) & 0x800000) >> 23
}
func (o *FB_Type) SetCSCR1_SWS(value uint32) {
	volatile.StoreUint32(&o.CSCR1.Reg, volatile.LoadUint32(&o.CSCR1.Reg)&^(0xfc000000)|value<<26)
}
func (o *FB_Type) GetCSCR1_SWS() uint32 {
	return (volatile.LoadUint32(&o.CSCR1.Reg) & 0xfc000000) >> 26
}

// FB.CSAR2: Chip Select Address Register
func (o *FB_Type) SetCSAR2_BA(value uint32) {
	volatile.StoreUint32(&o.CSAR2.Reg, volatile.LoadUint32(&o.CSAR2.Reg)&^(0xffff0000)|value<<16)
}
func (o *FB_Type) GetCSAR2_BA() uint32 {
	return (volatile.LoadUint32(&o.CSAR2.Reg) & 0xffff0000) >> 16
}

// FB.CSMR2: Chip Select Mask Register
func (o *FB_Type) SetCSMR2_V(value uint32) {
	volatile.StoreUint32(&o.CSMR2.Reg, volatile.LoadUint32(&o.CSMR2.Reg)&^(0x1)|value)
}
func (o *FB_Type) GetCSMR2_V() uint32 {
	return volatile.LoadUint32(&o.CSMR2.Reg) & 0x1
}
func (o *FB_Type) SetCSMR2_WP(value uint32) {
	volatile.StoreUint32(&o.CSMR2.Reg, volatile.LoadUint32(&o.CSMR2.Reg)&^(0x100)|value<<8)
}
func (o *FB_Type) GetCSMR2_WP() uint32 {
	return (volatile.LoadUint32(&o.CSMR2.Reg) & 0x100) >> 8
}
func (o *FB_Type) SetCSMR2_BAM(value uint32) {
	volatile.StoreUint32(&o.CSMR2.Reg, volatile.LoadUint32(&o.CSMR2.Reg)&^(0xffff0000)|value<<16)
}
func (o *FB_Type) GetCSMR2_BAM() uint32 {
	return (volatile.LoadUint32(&o.CSMR2.Reg) & 0xffff0000) >> 16
}

// FB.CSCR2: Chip Select Control Register
func (o *FB_Type) SetCSCR2_BSTW(value uint32) {
	volatile.StoreUint32(&o.CSCR2.Reg, volatile.LoadUint32(&o.CSCR2.Reg)&^(0x8)|value<<3)
}
func (o *FB_Type) GetCSCR2_BSTW() uint32 {
	return (volatile.LoadUint32(&o.CSCR2.Reg) & 0x8) >> 3
}
func (o *FB_Type) SetCSCR2_BSTR(value uint32) {
	volatile.StoreUint32(&o.CSCR2.Reg, volatile.LoadUint32(&o.CSCR2.Reg)&^(0x10)|value<<4)
}
func (o *FB_Type) GetCSCR2_BSTR() uint32 {
	return (volatile.LoadUint32(&o.CSCR2.Reg) & 0x10) >> 4
}
func (o *FB_Type) SetCSCR2_BEM(value uint32) {
	volatile.StoreUint32(&o.CSCR2.Reg, volatile.LoadUint32(&o.CSCR2.Reg)&^(0x20)|value<<5)
}
func (o *FB_Type) GetCSCR2_BEM() uint32 {
	return (volatile.LoadUint32(&o.CSCR2.Reg) & 0x20) >> 5
}
func (o *FB_Type) SetCSCR2_PS(value uint32) {
	volatile.StoreUint32(&o.CSCR2.Reg, volatile.LoadUint32(&o.CSCR2.Reg)&^(0xc0)|value<<6)
}
func (o *FB_Type) GetCSCR2_PS() uint32 {
	return (volatile.LoadUint32(&o.CSCR2.Reg) & 0xc0) >> 6
}
func (o *FB_Type) SetCSCR2_AA(value uint32) {
	volatile.StoreUint32(&o.CSCR2.Reg, volatile.LoadUint32(&o.CSCR2.Reg)&^(0x100)|value<<8)
}
func (o *FB_Type) GetCSCR2_AA() uint32 {
	return (volatile.LoadUint32(&o.CSCR2.Reg) & 0x100) >> 8
}
func (o *FB_Type) SetCSCR2_BLS(value uint32) {
	volatile.StoreUint32(&o.CSCR2.Reg, volatile.LoadUint32(&o.CSCR2.Reg)&^(0x200)|value<<9)
}
func (o *FB_Type) GetCSCR2_BLS() uint32 {
	return (volatile.LoadUint32(&o.CSCR2.Reg) & 0x200) >> 9
}
func (o *FB_Type) SetCSCR2_WS(value uint32) {
	volatile.StoreUint32(&o.CSCR2.Reg, volatile.LoadUint32(&o.CSCR2.Reg)&^(0xfc00)|value<<10)
}
func (o *FB_Type) GetCSCR2_WS() uint32 {
	return (volatile.LoadUint32(&o.CSCR2.Reg) & 0xfc00) >> 10
}
func (o *FB_Type) SetCSCR2_WRAH(value uint32) {
	volatile.StoreUint32(&o.CSCR2.Reg, volatile.LoadUint32(&o.CSCR2.Reg)&^(0x30000)|value<<16)
}
func (o *FB_Type) GetCSCR2_WRAH() uint32 {
	return (volatile.LoadUint32(&o.CSCR2.Reg) & 0x30000) >> 16
}
func (o *FB_Type) SetCSCR2_RDAH(value uint32) {
	volatile.StoreUint32(&o.CSCR2.Reg, volatile.LoadUint32(&o.CSCR2.Reg)&^(0xc0000)|value<<18)
}
func (o *FB_Type) GetCSCR2_RDAH() uint32 {
	return (volatile.LoadUint32(&o.CSCR2.Reg) & 0xc0000) >> 18
}
func (o *FB_Type) SetCSCR2_ASET(value uint32) {
	volatile.StoreUint32(&o.CSCR2.Reg, volatile.LoadUint32(&o.CSCR2.Reg)&^(0x300000)|value<<20)
}
func (o *FB_Type) GetCSCR2_ASET() uint32 {
	return (volatile.LoadUint32(&o.CSCR2.Reg) & 0x300000) >> 20
}
func (o *FB_Type) SetCSCR2_EXTS(value uint32) {
	volatile.StoreUint32(&o.CSCR2.Reg, volatile.LoadUint32(&o.CSCR2.Reg)&^(0x400000)|value<<22)
}
func (o *FB_Type) GetCSCR2_EXTS() uint32 {
	return (volatile.LoadUint32(&o.CSCR2.Reg) & 0x400000) >> 22
}
func (o *FB_Type) SetCSCR2_SWSEN(value uint32) {
	volatile.StoreUint32(&o.CSCR2.Reg, volatile.LoadUint32(&o.CSCR2.Reg)&^(0x800000)|value<<23)
}
func (o *FB_Type) GetCSCR2_SWSEN() uint32 {
	return (volatile.LoadUint32(&o.CSCR2.Reg) & 0x800000) >> 23
}
func (o *FB_Type) SetCSCR2_SWS(value uint32) {
	volatile.StoreUint32(&o.CSCR2.Reg, volatile.LoadUint32(&o.CSCR2.Reg)&^(0xfc000000)|value<<26)
}
func (o *FB_Type) GetCSCR2_SWS() uint32 {
	return (volatile.LoadUint32(&o.CSCR2.Reg) & 0xfc000000) >> 26
}

// FB.CSAR3: Chip Select Address Register
func (o *FB_Type) SetCSAR3_BA(value uint32) {
	volatile.StoreUint32(&o.CSAR3.Reg, volatile.LoadUint32(&o.CSAR3.Reg)&^(0xffff0000)|value<<16)
}
func (o *FB_Type) GetCSAR3_BA() uint32 {
	return (volatile.LoadUint32(&o.CSAR3.Reg) & 0xffff0000) >> 16
}

// FB.CSMR3: Chip Select Mask Register
func (o *FB_Type) SetCSMR3_V(value uint32) {
	volatile.StoreUint32(&o.CSMR3.Reg, volatile.LoadUint32(&o.CSMR3.Reg)&^(0x1)|value)
}
func (o *FB_Type) GetCSMR3_V() uint32 {
	return volatile.LoadUint32(&o.CSMR3.Reg) & 0x1
}
func (o *FB_Type) SetCSMR3_WP(value uint32) {
	volatile.StoreUint32(&o.CSMR3.Reg, volatile.LoadUint32(&o.CSMR3.Reg)&^(0x100)|value<<8)
}
func (o *FB_Type) GetCSMR3_WP() uint32 {
	return (volatile.LoadUint32(&o.CSMR3.Reg) & 0x100) >> 8
}
func (o *FB_Type) SetCSMR3_BAM(value uint32) {
	volatile.StoreUint32(&o.CSMR3.Reg, volatile.LoadUint32(&o.CSMR3.Reg)&^(0xffff0000)|value<<16)
}
func (o *FB_Type) GetCSMR3_BAM() uint32 {
	return (volatile.LoadUint32(&o.CSMR3.Reg) & 0xffff0000) >> 16
}

// FB.CSCR3: Chip Select Control Register
func (o *FB_Type) SetCSCR3_BSTW(value uint32) {
	volatile.StoreUint32(&o.CSCR3.Reg, volatile.LoadUint32(&o.CSCR3.Reg)&^(0x8)|value<<3)
}
func (o *FB_Type) GetCSCR3_BSTW() uint32 {
	return (volatile.LoadUint32(&o.CSCR3.Reg) & 0x8) >> 3
}
func (o *FB_Type) SetCSCR3_BSTR(value uint32) {
	volatile.StoreUint32(&o.CSCR3.Reg, volatile.LoadUint32(&o.CSCR3.Reg)&^(0x10)|value<<4)
}
func (o *FB_Type) GetCSCR3_BSTR() uint32 {
	return (volatile.LoadUint32(&o.CSCR3.Reg) & 0x10) >> 4
}
func (o *FB_Type) SetCSCR3_BEM(value uint32) {
	volatile.StoreUint32(&o.CSCR3.Reg, volatile.LoadUint32(&o.CSCR3.Reg)&^(0x20)|value<<5)
}
func (o *FB_Type) GetCSCR3_BEM() uint32 {
	return (volatile.LoadUint32(&o.CSCR3.Reg) & 0x20) >> 5
}
func (o *FB_Type) SetCSCR3_PS(value uint32) {
	volatile.StoreUint32(&o.CSCR3.Reg, volatile.LoadUint32(&o.CSCR3.Reg)&^(0xc0)|value<<6)
}
func (o *FB_Type) GetCSCR3_PS() uint32 {
	return (volatile.LoadUint32(&o.CSCR3.Reg) & 0xc0) >> 6
}
func (o *FB_Type) SetCSCR3_AA(value uint32) {
	volatile.StoreUint32(&o.CSCR3.Reg, volatile.LoadUint32(&o.CSCR3.Reg)&^(0x100)|value<<8)
}
func (o *FB_Type) GetCSCR3_AA() uint32 {
	return (volatile.LoadUint32(&o.CSCR3.Reg) & 0x100) >> 8
}
func (o *FB_Type) SetCSCR3_BLS(value uint32) {
	volatile.StoreUint32(&o.CSCR3.Reg, volatile.LoadUint32(&o.CSCR3.Reg)&^(0x200)|value<<9)
}
func (o *FB_Type) GetCSCR3_BLS() uint32 {
	return (volatile.LoadUint32(&o.CSCR3.Reg) & 0x200) >> 9
}
func (o *FB_Type) SetCSCR3_WS(value uint32) {
	volatile.StoreUint32(&o.CSCR3.Reg, volatile.LoadUint32(&o.CSCR3.Reg)&^(0xfc00)|value<<10)
}
func (o *FB_Type) GetCSCR3_WS() uint32 {
	return (volatile.LoadUint32(&o.CSCR3.Reg) & 0xfc00) >> 10
}
func (o *FB_Type) SetCSCR3_WRAH(value uint32) {
	volatile.StoreUint32(&o.CSCR3.Reg, volatile.LoadUint32(&o.CSCR3.Reg)&^(0x30000)|value<<16)
}
func (o *FB_Type) GetCSCR3_WRAH() uint32 {
	return (volatile.LoadUint32(&o.CSCR3.Reg) & 0x30000) >> 16
}
func (o *FB_Type) SetCSCR3_RDAH(value uint32) {
	volatile.StoreUint32(&o.CSCR3.Reg, volatile.LoadUint32(&o.CSCR3.Reg)&^(0xc0000)|value<<18)
}
func (o *FB_Type) GetCSCR3_RDAH() uint32 {
	return (volatile.LoadUint32(&o.CSCR3.Reg) & 0xc0000) >> 18
}
func (o *FB_Type) SetCSCR3_ASET(value uint32) {
	volatile.StoreUint32(&o.CSCR3.Reg, volatile.LoadUint32(&o.CSCR3.Reg)&^(0x300000)|value<<20)
}
func (o *FB_Type) GetCSCR3_ASET() uint32 {
	return (volatile.LoadUint32(&o.CSCR3.Reg) & 0x300000) >> 20
}
func (o *FB_Type) SetCSCR3_EXTS(value uint32) {
	volatile.StoreUint32(&o.CSCR3.Reg, volatile.LoadUint32(&o.CSCR3.Reg)&^(0x400000)|value<<22)
}
func (o *FB_Type) GetCSCR3_EXTS() uint32 {
	return (volatile.LoadUint32(&o.CSCR3.Reg) & 0x400000) >> 22
}
func (o *FB_Type) SetCSCR3_SWSEN(value uint32) {
	volatile.StoreUint32(&o.CSCR3.Reg, volatile.LoadUint32(&o.CSCR3.Reg)&^(0x800000)|value<<23)
}
func (o *FB_Type) GetCSCR3_SWSEN() uint32 {
	return (volatile.LoadUint32(&o.CSCR3.Reg) & 0x800000) >> 23
}
func (o *FB_Type) SetCSCR3_SWS(value uint32) {
	volatile.StoreUint32(&o.CSCR3.Reg, volatile.LoadUint32(&o.CSCR3.Reg)&^(0xfc000000)|value<<26)
}
func (o *FB_Type) GetCSCR3_SWS() uint32 {
	return (volatile.LoadUint32(&o.CSCR3.Reg) & 0xfc000000) >> 26
}

// FB.CSAR4: Chip Select Address Register
func (o *FB_Type) SetCSAR4_BA(value uint32) {
	volatile.StoreUint32(&o.CSAR4.Reg, volatile.LoadUint32(&o.CSAR4.Reg)&^(0xffff0000)|value<<16)
}
func (o *FB_Type) GetCSAR4_BA() uint32 {
	return (volatile.LoadUint32(&o.CSAR4.Reg) & 0xffff0000) >> 16
}

// FB.CSMR4: Chip Select Mask Register
func (o *FB_Type) SetCSMR4_V(value uint32) {
	volatile.StoreUint32(&o.CSMR4.Reg, volatile.LoadUint32(&o.CSMR4.Reg)&^(0x1)|value)
}
func (o *FB_Type) GetCSMR4_V() uint32 {
	return volatile.LoadUint32(&o.CSMR4.Reg) & 0x1
}
func (o *FB_Type) SetCSMR4_WP(value uint32) {
	volatile.StoreUint32(&o.CSMR4.Reg, volatile.LoadUint32(&o.CSMR4.Reg)&^(0x100)|value<<8)
}
func (o *FB_Type) GetCSMR4_WP() uint32 {
	return (volatile.LoadUint32(&o.CSMR4.Reg) & 0x100) >> 8
}
func (o *FB_Type) SetCSMR4_BAM(value uint32) {
	volatile.StoreUint32(&o.CSMR4.Reg, volatile.LoadUint32(&o.CSMR4.Reg)&^(0xffff0000)|value<<16)
}
func (o *FB_Type) GetCSMR4_BAM() uint32 {
	return (volatile.LoadUint32(&o.CSMR4.Reg) & 0xffff0000) >> 16
}

// FB.CSCR4: Chip Select Control Register
func (o *FB_Type) SetCSCR4_BSTW(value uint32) {
	volatile.StoreUint32(&o.CSCR4.Reg, volatile.LoadUint32(&o.CSCR4.Reg)&^(0x8)|value<<3)
}
func (o *FB_Type) GetCSCR4_BSTW() uint32 {
	return (volatile.LoadUint32(&o.CSCR4.Reg) & 0x8) >> 3
}
func (o *FB_Type) SetCSCR4_BSTR(value uint32) {
	volatile.StoreUint32(&o.CSCR4.Reg, volatile.LoadUint32(&o.CSCR4.Reg)&^(0x10)|value<<4)
}
func (o *FB_Type) GetCSCR4_BSTR() uint32 {
	return (volatile.LoadUint32(&o.CSCR4.Reg) & 0x10) >> 4
}
func (o *FB_Type) SetCSCR4_BEM(value uint32) {
	volatile.StoreUint32(&o.CSCR4.Reg, volatile.LoadUint32(&o.CSCR4.Reg)&^(0x20)|value<<5)
}
func (o *FB_Type) GetCSCR4_BEM() uint32 {
	return (volatile.LoadUint32(&o.CSCR4.Reg) & 0x20) >> 5
}
func (o *FB_Type) SetCSCR4_PS(value uint32) {
	volatile.StoreUint32(&o.CSCR4.Reg, volatile.LoadUint32(&o.CSCR4.Reg)&^(0xc0)|value<<6)
}
func (o *FB_Type) GetCSCR4_PS() uint32 {
	return (volatile.LoadUint32(&o.CSCR4.Reg) & 0xc0) >> 6
}
func (o *FB_Type) SetCSCR4_AA(value uint32) {
	volatile.StoreUint32(&o.CSCR4.Reg, volatile.LoadUint32(&o.CSCR4.Reg)&^(0x100)|value<<8)
}
func (o *FB_Type) GetCSCR4_AA() uint32 {
	return (volatile.LoadUint32(&o.CSCR4.Reg) & 0x100) >> 8
}
func (o *FB_Type) SetCSCR4_BLS(value uint32) {
	volatile.StoreUint32(&o.CSCR4.Reg, volatile.LoadUint32(&o.CSCR4.Reg)&^(0x200)|value<<9)
}
func (o *FB_Type) GetCSCR4_BLS() uint32 {
	return (volatile.LoadUint32(&o.CSCR4.Reg) & 0x200) >> 9
}
func (o *FB_Type) SetCSCR4_WS(value uint32) {
	volatile.StoreUint32(&o.CSCR4.Reg, volatile.LoadUint32(&o.CSCR4.Reg)&^(0xfc00)|value<<10)
}
func (o *FB_Type) GetCSCR4_WS() uint32 {
	return (volatile.LoadUint32(&o.CSCR4.Reg) & 0xfc00) >> 10
}
func (o *FB_Type) SetCSCR4_WRAH(value uint32) {
	volatile.StoreUint32(&o.CSCR4.Reg, volatile.LoadUint32(&o.CSCR4.Reg)&^(0x30000)|value<<16)
}
func (o *FB_Type) GetCSCR4_WRAH() uint32 {
	return (volatile.LoadUint32(&o.CSCR4.Reg) & 0x30000) >> 16
}
func (o *FB_Type) SetCSCR4_RDAH(value uint32) {
	volatile.StoreUint32(&o.CSCR4.Reg, volatile.LoadUint32(&o.CSCR4.Reg)&^(0xc0000)|value<<18)
}
func (o *FB_Type) GetCSCR4_RDAH() uint32 {
	return (volatile.LoadUint32(&o.CSCR4.Reg) & 0xc0000) >> 18
}
func (o *FB_Type) SetCSCR4_ASET(value uint32) {
	volatile.StoreUint32(&o.CSCR4.Reg, volatile.LoadUint32(&o.CSCR4.Reg)&^(0x300000)|value<<20)
}
func (o *FB_Type) GetCSCR4_ASET() uint32 {
	return (volatile.LoadUint32(&o.CSCR4.Reg) & 0x300000) >> 20
}
func (o *FB_Type) SetCSCR4_EXTS(value uint32) {
	volatile.StoreUint32(&o.CSCR4.Reg, volatile.LoadUint32(&o.CSCR4.Reg)&^(0x400000)|value<<22)
}
func (o *FB_Type) GetCSCR4_EXTS() uint32 {
	return (volatile.LoadUint32(&o.CSCR4.Reg) & 0x400000) >> 22
}
func (o *FB_Type) SetCSCR4_SWSEN(value uint32) {
	volatile.StoreUint32(&o.CSCR4.Reg, volatile.LoadUint32(&o.CSCR4.Reg)&^(0x800000)|value<<23)
}
func (o *FB_Type) GetCSCR4_SWSEN() uint32 {
	return (volatile.LoadUint32(&o.CSCR4.Reg) & 0x800000) >> 23
}
func (o *FB_Type) SetCSCR4_SWS(value uint32) {
	volatile.StoreUint32(&o.CSCR4.Reg, volatile.LoadUint32(&o.CSCR4.Reg)&^(0xfc000000)|value<<26)
}
func (o *FB_Type) GetCSCR4_SWS() uint32 {
	return (volatile.LoadUint32(&o.CSCR4.Reg) & 0xfc000000) >> 26
}

// FB.CSAR5: Chip Select Address Register
func (o *FB_Type) SetCSAR5_BA(value uint32) {
	volatile.StoreUint32(&o.CSAR5.Reg, volatile.LoadUint32(&o.CSAR5.Reg)&^(0xffff0000)|value<<16)
}
func (o *FB_Type) GetCSAR5_BA() uint32 {
	return (volatile.LoadUint32(&o.CSAR5.Reg) & 0xffff0000) >> 16
}

// FB.CSMR5: Chip Select Mask Register
func (o *FB_Type) SetCSMR5_V(value uint32) {
	volatile.StoreUint32(&o.CSMR5.Reg, volatile.LoadUint32(&o.CSMR5.Reg)&^(0x1)|value)
}
func (o *FB_Type) GetCSMR5_V() uint32 {
	return volatile.LoadUint32(&o.CSMR5.Reg) & 0x1
}
func (o *FB_Type) SetCSMR5_WP(value uint32) {
	volatile.StoreUint32(&o.CSMR5.Reg, volatile.LoadUint32(&o.CSMR5.Reg)&^(0x100)|value<<8)
}
func (o *FB_Type) GetCSMR5_WP() uint32 {
	return (volatile.LoadUint32(&o.CSMR5.Reg) & 0x100) >> 8
}
func (o *FB_Type) SetCSMR5_BAM(value uint32) {
	volatile.StoreUint32(&o.CSMR5.Reg, volatile.LoadUint32(&o.CSMR5.Reg)&^(0xffff0000)|value<<16)
}
func (o *FB_Type) GetCSMR5_BAM() uint32 {
	return (volatile.LoadUint32(&o.CSMR5.Reg) & 0xffff0000) >> 16
}

// FB.CSCR5: Chip Select Control Register
func (o *FB_Type) SetCSCR5_BSTW(value uint32) {
	volatile.StoreUint32(&o.CSCR5.Reg, volatile.LoadUint32(&o.CSCR5.Reg)&^(0x8)|value<<3)
}
func (o *FB_Type) GetCSCR5_BSTW() uint32 {
	return (volatile.LoadUint32(&o.CSCR5.Reg) & 0x8) >> 3
}
func (o *FB_Type) SetCSCR5_BSTR(value uint32) {
	volatile.StoreUint32(&o.CSCR5.Reg, volatile.LoadUint32(&o.CSCR5.Reg)&^(0x10)|value<<4)
}
func (o *FB_Type) GetCSCR5_BSTR() uint32 {
	return (volatile.LoadUint32(&o.CSCR5.Reg) & 0x10) >> 4
}
func (o *FB_Type) SetCSCR5_BEM(value uint32) {
	volatile.StoreUint32(&o.CSCR5.Reg, volatile.LoadUint32(&o.CSCR5.Reg)&^(0x20)|value<<5)
}
func (o *FB_Type) GetCSCR5_BEM() uint32 {
	return (volatile.LoadUint32(&o.CSCR5.Reg) & 0x20) >> 5
}
func (o *FB_Type) SetCSCR5_PS(value uint32) {
	volatile.StoreUint32(&o.CSCR5.Reg, volatile.LoadUint32(&o.CSCR5.Reg)&^(0xc0)|value<<6)
}
func (o *FB_Type) GetCSCR5_PS() uint32 {
	return (volatile.LoadUint32(&o.CSCR5.Reg) & 0xc0) >> 6
}
func (o *FB_Type) SetCSCR5_AA(value uint32) {
	volatile.StoreUint32(&o.CSCR5.Reg, volatile.LoadUint32(&o.CSCR5.Reg)&^(0x100)|value<<8)
}
func (o *FB_Type) GetCSCR5_AA() uint32 {
	return (volatile.LoadUint32(&o.CSCR5.Reg) & 0x100) >> 8
}
func (o *FB_Type) SetCSCR5_BLS(value uint32) {
	volatile.StoreUint32(&o.CSCR5.Reg, volatile.LoadUint32(&o.CSCR5.Reg)&^(0x200)|value<<9)
}
func (o *FB_Type) GetCSCR5_BLS() uint32 {
	return (volatile.LoadUint32(&o.CSCR5.Reg) & 0x200) >> 9
}
func (o *FB_Type) SetCSCR5_WS(value uint32) {
	volatile.StoreUint32(&o.CSCR5.Reg, volatile.LoadUint32(&o.CSCR5.Reg)&^(0xfc00)|value<<10)
}
func (o *FB_Type) GetCSCR5_WS() uint32 {
	return (volatile.LoadUint32(&o.CSCR5.Reg) & 0xfc00) >> 10
}
func (o *FB_Type) SetCSCR5_WRAH(value uint32) {
	volatile.StoreUint32(&o.CSCR5.Reg, volatile.LoadUint32(&o.CSCR5.Reg)&^(0x30000)|value<<16)
}
func (o *FB_Type) GetCSCR5_WRAH() uint32 {
	return (volatile.LoadUint32(&o.CSCR5.Reg) & 0x30000) >> 16
}
func (o *FB_Type) SetCSCR5_RDAH(value uint32) {
	volatile.StoreUint32(&o.CSCR5.Reg, volatile.LoadUint32(&o.CSCR5.Reg)&^(0xc0000)|value<<18)
}
func (o *FB_Type) GetCSCR5_RDAH() uint32 {
	return (volatile.LoadUint32(&o.CSCR5.Reg) & 0xc0000) >> 18
}
func (o *FB_Type) SetCSCR5_ASET(value uint32) {
	volatile.StoreUint32(&o.CSCR5.Reg, volatile.LoadUint32(&o.CSCR5.Reg)&^(0x300000)|value<<20)
}
func (o *FB_Type) GetCSCR5_ASET() uint32 {
	return (volatile.LoadUint32(&o.CSCR5.Reg) & 0x300000) >> 20
}
func (o *FB_Type) SetCSCR5_EXTS(value uint32) {
	volatile.StoreUint32(&o.CSCR5.Reg, volatile.LoadUint32(&o.CSCR5.Reg)&^(0x400000)|value<<22)
}
func (o *FB_Type) GetCSCR5_EXTS() uint32 {
	return (volatile.LoadUint32(&o.CSCR5.Reg) & 0x400000) >> 22
}
func (o *FB_Type) SetCSCR5_SWSEN(value uint32) {
	volatile.StoreUint32(&o.CSCR5.Reg, volatile.LoadUint32(&o.CSCR5.Reg)&^(0x800000)|value<<23)
}
func (o *FB_Type) GetCSCR5_SWSEN() uint32 {
	return (volatile.LoadUint32(&o.CSCR5.Reg) & 0x800000) >> 23
}
func (o *FB_Type) SetCSCR5_SWS(value uint32) {
	volatile.StoreUint32(&o.CSCR5.Reg, volatile.LoadUint32(&o.CSCR5.Reg)&^(0xfc000000)|value<<26)
}
func (o *FB_Type) GetCSCR5_SWS() uint32 {
	return (volatile.LoadUint32(&o.CSCR5.Reg) & 0xfc000000) >> 26
}

// FB.CSPMCR: Chip Select port Multiplexing Control Register
func (o *FB_Type) SetCSPMCR_GROUP5(value uint32) {
	volatile.StoreUint32(&o.CSPMCR.Reg, volatile.LoadUint32(&o.CSPMCR.Reg)&^(0xf000)|value<<12)
}
func (o *FB_Type) GetCSPMCR_GROUP5() uint32 {
	return (volatile.LoadUint32(&o.CSPMCR.Reg) & 0xf000) >> 12
}
func (o *FB_Type) SetCSPMCR_GROUP4(value uint32) {
	volatile.StoreUint32(&o.CSPMCR.Reg, volatile.LoadUint32(&o.CSPMCR.Reg)&^(0xf0000)|value<<16)
}
func (o *FB_Type) GetCSPMCR_GROUP4() uint32 {
	return (volatile.LoadUint32(&o.CSPMCR.Reg) & 0xf0000) >> 16
}
func (o *FB_Type) SetCSPMCR_GROUP3(value uint32) {
	volatile.StoreUint32(&o.CSPMCR.Reg, volatile.LoadUint32(&o.CSPMCR.Reg)&^(0xf00000)|value<<20)
}
func (o *FB_Type) GetCSPMCR_GROUP3() uint32 {
	return (volatile.LoadUint32(&o.CSPMCR.Reg) & 0xf00000) >> 20
}
func (o *FB_Type) SetCSPMCR_GROUP2(value uint32) {
	volatile.StoreUint32(&o.CSPMCR.Reg, volatile.LoadUint32(&o.CSPMCR.Reg)&^(0xf000000)|value<<24)
}
func (o *FB_Type) GetCSPMCR_GROUP2() uint32 {
	return (volatile.LoadUint32(&o.CSPMCR.Reg) & 0xf000000) >> 24
}
func (o *FB_Type) SetCSPMCR_GROUP1(value uint32) {
	volatile.StoreUint32(&o.CSPMCR.Reg, volatile.LoadUint32(&o.CSPMCR.Reg)&^(0xf0000000)|value<<28)
}
func (o *FB_Type) GetCSPMCR_GROUP1() uint32 {
	return (volatile.LoadUint32(&o.CSPMCR.Reg) & 0xf0000000) >> 28
}

// Memory protection unit
type SYSMPU_Type struct {
	CESR        volatile.Register32 // 0x0
	_           [12]byte
	EAR0        volatile.Register32 // 0x10
	EDR0        volatile.Register32 // 0x14
	EAR1        volatile.Register32 // 0x18
	EDR1        volatile.Register32 // 0x1C
	EAR2        volatile.Register32 // 0x20
	EDR2        volatile.Register32 // 0x24
	EAR3        volatile.Register32 // 0x28
	EDR3        volatile.Register32 // 0x2C
	EAR4        volatile.Register32 // 0x30
	EDR4        volatile.Register32 // 0x34
	_           [968]byte
	RGD0_WORD0  volatile.Register32 // 0x400
	RGD0_WORD1  volatile.Register32 // 0x404
	RGD0_WORD2  volatile.Register32 // 0x408
	RGD0_WORD3  volatile.Register32 // 0x40C
	RGD1_WORD0  volatile.Register32 // 0x410
	RGD1_WORD1  volatile.Register32 // 0x414
	RGD1_WORD2  volatile.Register32 // 0x418
	RGD1_WORD3  volatile.Register32 // 0x41C
	RGD2_WORD0  volatile.Register32 // 0x420
	RGD2_WORD1  volatile.Register32 // 0x424
	RGD2_WORD2  volatile.Register32 // 0x428
	RGD2_WORD3  volatile.Register32 // 0x42C
	RGD3_WORD0  volatile.Register32 // 0x430
	RGD3_WORD1  volatile.Register32 // 0x434
	RGD3_WORD2  volatile.Register32 // 0x438
	RGD3_WORD3  volatile.Register32 // 0x43C
	RGD4_WORD0  volatile.Register32 // 0x440
	RGD4_WORD1  volatile.Register32 // 0x444
	RGD4_WORD2  volatile.Register32 // 0x448
	RGD4_WORD3  volatile.Register32 // 0x44C
	RGD5_WORD0  volatile.Register32 // 0x450
	RGD5_WORD1  volatile.Register32 // 0x454
	RGD5_WORD2  volatile.Register32 // 0x458
	RGD5_WORD3  volatile.Register32 // 0x45C
	RGD6_WORD0  volatile.Register32 // 0x460
	RGD6_WORD1  volatile.Register32 // 0x464
	RGD6_WORD2  volatile.Register32 // 0x468
	RGD6_WORD3  volatile.Register32 // 0x46C
	RGD7_WORD0  volatile.Register32 // 0x470
	RGD7_WORD1  volatile.Register32 // 0x474
	RGD7_WORD2  volatile.Register32 // 0x478
	RGD7_WORD3  volatile.Register32 // 0x47C
	RGD8_WORD0  volatile.Register32 // 0x480
	RGD8_WORD1  volatile.Register32 // 0x484
	RGD8_WORD2  volatile.Register32 // 0x488
	RGD8_WORD3  volatile.Register32 // 0x48C
	RGD9_WORD0  volatile.Register32 // 0x490
	RGD9_WORD1  volatile.Register32 // 0x494
	RGD9_WORD2  volatile.Register32 // 0x498
	RGD9_WORD3  volatile.Register32 // 0x49C
	RGD10_WORD0 volatile.Register32 // 0x4A0
	RGD10_WORD1 volatile.Register32 // 0x4A4
	RGD10_WORD2 volatile.Register32 // 0x4A8
	RGD10_WORD3 volatile.Register32 // 0x4AC
	RGD11_WORD0 volatile.Register32 // 0x4B0
	RGD11_WORD1 volatile.Register32 // 0x4B4
	RGD11_WORD2 volatile.Register32 // 0x4B8
	RGD11_WORD3 volatile.Register32 // 0x4BC
	_           [832]byte
	RGDAAC0     volatile.Register32 // 0x800
	RGDAAC1     volatile.Register32 // 0x804
	RGDAAC2     volatile.Register32 // 0x808
	RGDAAC3     volatile.Register32 // 0x80C
	RGDAAC4     volatile.Register32 // 0x810
	RGDAAC5     volatile.Register32 // 0x814
	RGDAAC6     volatile.Register32 // 0x818
	RGDAAC7     volatile.Register32 // 0x81C
	RGDAAC8     volatile.Register32 // 0x820
	RGDAAC9     volatile.Register32 // 0x824
	RGDAAC10    volatile.Register32 // 0x828
	RGDAAC11    volatile.Register32 // 0x82C
}

// SYSMPU.CESR: Control/Error Status Register
func (o *SYSMPU_Type) SetCESR_VLD(value uint32) {
	volatile.StoreUint32(&o.CESR.Reg, volatile.LoadUint32(&o.CESR.Reg)&^(0x1)|value)
}
func (o *SYSMPU_Type) GetCESR_VLD() uint32 {
	return volatile.LoadUint32(&o.CESR.Reg) & 0x1
}
func (o *SYSMPU_Type) SetCESR_NRGD(value uint32) {
	volatile.StoreUint32(&o.CESR.Reg, volatile.LoadUint32(&o.CESR.Reg)&^(0xf00)|value<<8)
}
func (o *SYSMPU_Type) GetCESR_NRGD() uint32 {
	return (volatile.LoadUint32(&o.CESR.Reg) & 0xf00) >> 8
}
func (o *SYSMPU_Type) SetCESR_NSP(value uint32) {
	volatile.StoreUint32(&o.CESR.Reg, volatile.LoadUint32(&o.CESR.Reg)&^(0xf000)|value<<12)
}
func (o *SYSMPU_Type) GetCESR_NSP() uint32 {
	return (volatile.LoadUint32(&o.CESR.Reg) & 0xf000) >> 12
}
func (o *SYSMPU_Type) SetCESR_HRL(value uint32) {
	volatile.StoreUint32(&o.CESR.Reg, volatile.LoadUint32(&o.CESR.Reg)&^(0xf0000)|value<<16)
}
func (o *SYSMPU_Type) GetCESR_HRL() uint32 {
	return (volatile.LoadUint32(&o.CESR.Reg) & 0xf0000) >> 16
}
func (o *SYSMPU_Type) SetCESR_SPERR(value uint32) {
	volatile.StoreUint32(&o.CESR.Reg, volatile.LoadUint32(&o.CESR.Reg)&^(0xf8000000)|value<<27)
}
func (o *SYSMPU_Type) GetCESR_SPERR() uint32 {
	return (volatile.LoadUint32(&o.CESR.Reg) & 0xf8000000) >> 27
}

// SYSMPU.EAR0: Error Address Register, slave port n
func (o *SYSMPU_Type) SetEAR0(value uint32) {
	volatile.StoreUint32(&o.EAR0.Reg, value)
}
func (o *SYSMPU_Type) GetEAR0() uint32 {
	return volatile.LoadUint32(&o.EAR0.Reg)
}

// SYSMPU.EDR0: Error Detail Register, slave port n
func (o *SYSMPU_Type) SetEDR0_ERW(value uint32) {
	volatile.StoreUint32(&o.EDR0.Reg, volatile.LoadUint32(&o.EDR0.Reg)&^(0x1)|value)
}
func (o *SYSMPU_Type) GetEDR0_ERW() uint32 {
	return volatile.LoadUint32(&o.EDR0.Reg) & 0x1
}
func (o *SYSMPU_Type) SetEDR0_EATTR(value uint32) {
	volatile.StoreUint32(&o.EDR0.Reg, volatile.LoadUint32(&o.EDR0.Reg)&^(0xe)|value<<1)
}
func (o *SYSMPU_Type) GetEDR0_EATTR() uint32 {
	return (volatile.LoadUint32(&o.EDR0.Reg) & 0xe) >> 1
}
func (o *SYSMPU_Type) SetEDR0_EMN(value uint32) {
	volatile.StoreUint32(&o.EDR0.Reg, volatile.LoadUint32(&o.EDR0.Reg)&^(0xf0)|value<<4)
}
func (o *SYSMPU_Type) GetEDR0_EMN() uint32 {
	return (volatile.LoadUint32(&o.EDR0.Reg) & 0xf0) >> 4
}
func (o *SYSMPU_Type) SetEDR0_EPID(value uint32) {
	volatile.StoreUint32(&o.EDR0.Reg, volatile.LoadUint32(&o.EDR0.Reg)&^(0xff00)|value<<8)
}
func (o *SYSMPU_Type) GetEDR0_EPID() uint32 {
	return (volatile.LoadUint32(&o.EDR0.Reg) & 0xff00) >> 8
}
func (o *SYSMPU_Type) SetEDR0_EACD(value uint32) {
	volatile.StoreUint32(&o.EDR0.Reg, volatile.LoadUint32(&o.EDR0.Reg)&^(0xffff0000)|value<<16)
}
func (o *SYSMPU_Type) GetEDR0_EACD() uint32 {
	return (volatile.LoadUint32(&o.EDR0.Reg) & 0xffff0000) >> 16
}

// SYSMPU.EAR1: Error Address Register, slave port n
func (o *SYSMPU_Type) SetEAR1(value uint32) {
	volatile.StoreUint32(&o.EAR1.Reg, value)
}
func (o *SYSMPU_Type) GetEAR1() uint32 {
	return volatile.LoadUint32(&o.EAR1.Reg)
}

// SYSMPU.EDR1: Error Detail Register, slave port n
func (o *SYSMPU_Type) SetEDR1_ERW(value uint32) {
	volatile.StoreUint32(&o.EDR1.Reg, volatile.LoadUint32(&o.EDR1.Reg)&^(0x1)|value)
}
func (o *SYSMPU_Type) GetEDR1_ERW() uint32 {
	return volatile.LoadUint32(&o.EDR1.Reg) & 0x1
}
func (o *SYSMPU_Type) SetEDR1_EATTR(value uint32) {
	volatile.StoreUint32(&o.EDR1.Reg, volatile.LoadUint32(&o.EDR1.Reg)&^(0xe)|value<<1)
}
func (o *SYSMPU_Type) GetEDR1_EATTR() uint32 {
	return (volatile.LoadUint32(&o.EDR1.Reg) & 0xe) >> 1
}
func (o *SYSMPU_Type) SetEDR1_EMN(value uint32) {
	volatile.StoreUint32(&o.EDR1.Reg, volatile.LoadUint32(&o.EDR1.Reg)&^(0xf0)|value<<4)
}
func (o *SYSMPU_Type) GetEDR1_EMN() uint32 {
	return (volatile.LoadUint32(&o.EDR1.Reg) & 0xf0) >> 4
}
func (o *SYSMPU_Type) SetEDR1_EPID(value uint32) {
	volatile.StoreUint32(&o.EDR1.Reg, volatile.LoadUint32(&o.EDR1.Reg)&^(0xff00)|value<<8)
}
func (o *SYSMPU_Type) GetEDR1_EPID() uint32 {
	return (volatile.LoadUint32(&o.EDR1.Reg) & 0xff00) >> 8
}
func (o *SYSMPU_Type) SetEDR1_EACD(value uint32) {
	volatile.StoreUint32(&o.EDR1.Reg, volatile.LoadUint32(&o.EDR1.Reg)&^(0xffff0000)|value<<16)
}
func (o *SYSMPU_Type) GetEDR1_EACD() uint32 {
	return (volatile.LoadUint32(&o.EDR1.Reg) & 0xffff0000) >> 16
}

// SYSMPU.EAR2: Error Address Register, slave port n
func (o *SYSMPU_Type) SetEAR2(value uint32) {
	volatile.StoreUint32(&o.EAR2.Reg, value)
}
func (o *SYSMPU_Type) GetEAR2() uint32 {
	return volatile.LoadUint32(&o.EAR2.Reg)
}

// SYSMPU.EDR2: Error Detail Register, slave port n
func (o *SYSMPU_Type) SetEDR2_ERW(value uint32) {
	volatile.StoreUint32(&o.EDR2.Reg, volatile.LoadUint32(&o.EDR2.Reg)&^(0x1)|value)
}
func (o *SYSMPU_Type) GetEDR2_ERW() uint32 {
	return volatile.LoadUint32(&o.EDR2.Reg) & 0x1
}
func (o *SYSMPU_Type) SetEDR2_EATTR(value uint32) {
	volatile.StoreUint32(&o.EDR2.Reg, volatile.LoadUint32(&o.EDR2.Reg)&^(0xe)|value<<1)
}
func (o *SYSMPU_Type) GetEDR2_EATTR() uint32 {
	return (volatile.LoadUint32(&o.EDR2.Reg) & 0xe) >> 1
}
func (o *SYSMPU_Type) SetEDR2_EMN(value uint32) {
	volatile.StoreUint32(&o.EDR2.Reg, volatile.LoadUint32(&o.EDR2.Reg)&^(0xf0)|value<<4)
}
func (o *SYSMPU_Type) GetEDR2_EMN() uint32 {
	return (volatile.LoadUint32(&o.EDR2.Reg) & 0xf0) >> 4
}
func (o *SYSMPU_Type) SetEDR2_EPID(value uint32) {
	volatile.StoreUint32(&o.EDR2.Reg, volatile.LoadUint32(&o.EDR2.Reg)&^(0xff00)|value<<8)
}
func (o *SYSMPU_Type) GetEDR2_EPID() uint32 {
	return (volatile.LoadUint32(&o.EDR2.Reg) & 0xff00) >> 8
}
func (o *SYSMPU_Type) SetEDR2_EACD(value uint32) {
	volatile.StoreUint32(&o.EDR2.Reg, volatile.LoadUint32(&o.EDR2.Reg)&^(0xffff0000)|value<<16)
}
func (o *SYSMPU_Type) GetEDR2_EACD() uint32 {
	return (volatile.LoadUint32(&o.EDR2.Reg) & 0xffff0000) >> 16
}

// SYSMPU.EAR3: Error Address Register, slave port n
func (o *SYSMPU_Type) SetEAR3(value uint32) {
	volatile.StoreUint32(&o.EAR3.Reg, value)
}
func (o *SYSMPU_Type) GetEAR3() uint32 {
	return volatile.LoadUint32(&o.EAR3.Reg)
}

// SYSMPU.EDR3: Error Detail Register, slave port n
func (o *SYSMPU_Type) SetEDR3_ERW(value uint32) {
	volatile.StoreUint32(&o.EDR3.Reg, volatile.LoadUint32(&o.EDR3.Reg)&^(0x1)|value)
}
func (o *SYSMPU_Type) GetEDR3_ERW() uint32 {
	return volatile.LoadUint32(&o.EDR3.Reg) & 0x1
}
func (o *SYSMPU_Type) SetEDR3_EATTR(value uint32) {
	volatile.StoreUint32(&o.EDR3.Reg, volatile.LoadUint32(&o.EDR3.Reg)&^(0xe)|value<<1)
}
func (o *SYSMPU_Type) GetEDR3_EATTR() uint32 {
	return (volatile.LoadUint32(&o.EDR3.Reg) & 0xe) >> 1
}
func (o *SYSMPU_Type) SetEDR3_EMN(value uint32) {
	volatile.StoreUint32(&o.EDR3.Reg, volatile.LoadUint32(&o.EDR3.Reg)&^(0xf0)|value<<4)
}
func (o *SYSMPU_Type) GetEDR3_EMN() uint32 {
	return (volatile.LoadUint32(&o.EDR3.Reg) & 0xf0) >> 4
}
func (o *SYSMPU_Type) SetEDR3_EPID(value uint32) {
	volatile.StoreUint32(&o.EDR3.Reg, volatile.LoadUint32(&o.EDR3.Reg)&^(0xff00)|value<<8)
}
func (o *SYSMPU_Type) GetEDR3_EPID() uint32 {
	return (volatile.LoadUint32(&o.EDR3.Reg) & 0xff00) >> 8
}
func (o *SYSMPU_Type) SetEDR3_EACD(value uint32) {
	volatile.StoreUint32(&o.EDR3.Reg, volatile.LoadUint32(&o.EDR3.Reg)&^(0xffff0000)|value<<16)
}
func (o *SYSMPU_Type) GetEDR3_EACD() uint32 {
	return (volatile.LoadUint32(&o.EDR3.Reg) & 0xffff0000) >> 16
}

// SYSMPU.EAR4: Error Address Register, slave port n
func (o *SYSMPU_Type) SetEAR4(value uint32) {
	volatile.StoreUint32(&o.EAR4.Reg, value)
}
func (o *SYSMPU_Type) GetEAR4() uint32 {
	return volatile.LoadUint32(&o.EAR4.Reg)
}

// SYSMPU.EDR4: Error Detail Register, slave port n
func (o *SYSMPU_Type) SetEDR4_ERW(value uint32) {
	volatile.StoreUint32(&o.EDR4.Reg, volatile.LoadUint32(&o.EDR4.Reg)&^(0x1)|value)
}
func (o *SYSMPU_Type) GetEDR4_ERW() uint32 {
	return volatile.LoadUint32(&o.EDR4.Reg) & 0x1
}
func (o *SYSMPU_Type) SetEDR4_EATTR(value uint32) {
	volatile.StoreUint32(&o.EDR4.Reg, volatile.LoadUint32(&o.EDR4.Reg)&^(0xe)|value<<1)
}
func (o *SYSMPU_Type) GetEDR4_EATTR() uint32 {
	return (volatile.LoadUint32(&o.EDR4.Reg) & 0xe) >> 1
}
func (o *SYSMPU_Type) SetEDR4_EMN(value uint32) {
	volatile.StoreUint32(&o.EDR4.Reg, volatile.LoadUint32(&o.EDR4.Reg)&^(0xf0)|value<<4)
}
func (o *SYSMPU_Type) GetEDR4_EMN() uint32 {
	return (volatile.LoadUint32(&o.EDR4.Reg) & 0xf0) >> 4
}
func (o *SYSMPU_Type) SetEDR4_EPID(value uint32) {
	volatile.StoreUint32(&o.EDR4.Reg, volatile.LoadUint32(&o.EDR4.Reg)&^(0xff00)|value<<8)
}
func (o *SYSMPU_Type) GetEDR4_EPID() uint32 {
	return (volatile.LoadUint32(&o.EDR4.Reg) & 0xff00) >> 8
}
func (o *SYSMPU_Type) SetEDR4_EACD(value uint32) {
	volatile.StoreUint32(&o.EDR4.Reg, volatile.LoadUint32(&o.EDR4.Reg)&^(0xffff0000)|value<<16)
}
func (o *SYSMPU_Type) GetEDR4_EACD() uint32 {
	return (volatile.LoadUint32(&o.EDR4.Reg) & 0xffff0000) >> 16
}

// SYSMPU.RGD0_WORD0: Region Descriptor n, Word 0
func (o *SYSMPU_Type) SetRGD0_WORD0_SRTADDR(value uint32) {
	volatile.StoreUint32(&o.RGD0_WORD0.Reg, volatile.LoadUint32(&o.RGD0_WORD0.Reg)&^(0xffffffe0)|value<<5)
}
func (o *SYSMPU_Type) GetRGD0_WORD0_SRTADDR() uint32 {
	return (volatile.LoadUint32(&o.RGD0_WORD0.Reg) & 0xffffffe0) >> 5
}

// SYSMPU.RGD0_WORD1: Region Descriptor n, Word 1
func (o *SYSMPU_Type) SetRGD0_WORD1_ENDADDR(value uint32) {
	volatile.StoreUint32(&o.RGD0_WORD1.Reg, volatile.LoadUint32(&o.RGD0_WORD1.Reg)&^(0xffffffe0)|value<<5)
}
func (o *SYSMPU_Type) GetRGD0_WORD1_ENDADDR() uint32 {
	return (volatile.LoadUint32(&o.RGD0_WORD1.Reg) & 0xffffffe0) >> 5
}

// SYSMPU.RGD0_WORD2: Region Descriptor n, Word 2
func (o *SYSMPU_Type) SetRGD0_WORD2_M0UM(value uint32) {
	volatile.StoreUint32(&o.RGD0_WORD2.Reg, volatile.LoadUint32(&o.RGD0_WORD2.Reg)&^(0x7)|value)
}
func (o *SYSMPU_Type) GetRGD0_WORD2_M0UM() uint32 {
	return volatile.LoadUint32(&o.RGD0_WORD2.Reg) & 0x7
}
func (o *SYSMPU_Type) SetRGD0_WORD2_M0SM(value uint32) {
	volatile.StoreUint32(&o.RGD0_WORD2.Reg, volatile.LoadUint32(&o.RGD0_WORD2.Reg)&^(0x18)|value<<3)
}
func (o *SYSMPU_Type) GetRGD0_WORD2_M0SM() uint32 {
	return (volatile.LoadUint32(&o.RGD0_WORD2.Reg) & 0x18) >> 3
}
func (o *SYSMPU_Type) SetRGD0_WORD2_M0PE(value uint32) {
	volatile.StoreUint32(&o.RGD0_WORD2.Reg, volatile.LoadUint32(&o.RGD0_WORD2.Reg)&^(0x20)|value<<5)
}
func (o *SYSMPU_Type) GetRGD0_WORD2_M0PE() uint32 {
	return (volatile.LoadUint32(&o.RGD0_WORD2.Reg) & 0x20) >> 5
}
func (o *SYSMPU_Type) SetRGD0_WORD2_M1UM(value uint32) {
	volatile.StoreUint32(&o.RGD0_WORD2.Reg, volatile.LoadUint32(&o.RGD0_WORD2.Reg)&^(0x1c0)|value<<6)
}
func (o *SYSMPU_Type) GetRGD0_WORD2_M1UM() uint32 {
	return (volatile.LoadUint32(&o.RGD0_WORD2.Reg) & 0x1c0) >> 6
}
func (o *SYSMPU_Type) SetRGD0_WORD2_M1SM(value uint32) {
	volatile.StoreUint32(&o.RGD0_WORD2.Reg, volatile.LoadUint32(&o.RGD0_WORD2.Reg)&^(0x600)|value<<9)
}
func (o *SYSMPU_Type) GetRGD0_WORD2_M1SM() uint32 {
	return (volatile.LoadUint32(&o.RGD0_WORD2.Reg) & 0x600) >> 9
}
func (o *SYSMPU_Type) SetRGD0_WORD2_M1PE(value uint32) {
	volatile.StoreUint32(&o.RGD0_WORD2.Reg, volatile.LoadUint32(&o.RGD0_WORD2.Reg)&^(0x800)|value<<11)
}
func (o *SYSMPU_Type) GetRGD0_WORD2_M1PE() uint32 {
	return (volatile.LoadUint32(&o.RGD0_WORD2.Reg) & 0x800) >> 11
}
func (o *SYSMPU_Type) SetRGD0_WORD2_M2UM(value uint32) {
	volatile.StoreUint32(&o.RGD0_WORD2.Reg, volatile.LoadUint32(&o.RGD0_WORD2.Reg)&^(0x7000)|value<<12)
}
func (o *SYSMPU_Type) GetRGD0_WORD2_M2UM() uint32 {
	return (volatile.LoadUint32(&o.RGD0_WORD2.Reg) & 0x7000) >> 12
}
func (o *SYSMPU_Type) SetRGD0_WORD2_M2SM(value uint32) {
	volatile.StoreUint32(&o.RGD0_WORD2.Reg, volatile.LoadUint32(&o.RGD0_WORD2.Reg)&^(0x18000)|value<<15)
}
func (o *SYSMPU_Type) GetRGD0_WORD2_M2SM() uint32 {
	return (volatile.LoadUint32(&o.RGD0_WORD2.Reg) & 0x18000) >> 15
}
func (o *SYSMPU_Type) SetRGD0_WORD2_M2PE(value uint32) {
	volatile.StoreUint32(&o.RGD0_WORD2.Reg, volatile.LoadUint32(&o.RGD0_WORD2.Reg)&^(0x20000)|value<<17)
}
func (o *SYSMPU_Type) GetRGD0_WORD2_M2PE() uint32 {
	return (volatile.LoadUint32(&o.RGD0_WORD2.Reg) & 0x20000) >> 17
}
func (o *SYSMPU_Type) SetRGD0_WORD2_M3UM(value uint32) {
	volatile.StoreUint32(&o.RGD0_WORD2.Reg, volatile.LoadUint32(&o.RGD0_WORD2.Reg)&^(0x1c0000)|value<<18)
}
func (o *SYSMPU_Type) GetRGD0_WORD2_M3UM() uint32 {
	return (volatile.LoadUint32(&o.RGD0_WORD2.Reg) & 0x1c0000) >> 18
}
func (o *SYSMPU_Type) SetRGD0_WORD2_M3SM(value uint32) {
	volatile.StoreUint32(&o.RGD0_WORD2.Reg, volatile.LoadUint32(&o.RGD0_WORD2.Reg)&^(0x600000)|value<<21)
}
func (o *SYSMPU_Type) GetRGD0_WORD2_M3SM() uint32 {
	return (volatile.LoadUint32(&o.RGD0_WORD2.Reg) & 0x600000) >> 21
}
func (o *SYSMPU_Type) SetRGD0_WORD2_M3PE(value uint32) {
	volatile.StoreUint32(&o.RGD0_WORD2.Reg, volatile.LoadUint32(&o.RGD0_WORD2.Reg)&^(0x800000)|value<<23)
}
func (o *SYSMPU_Type) GetRGD0_WORD2_M3PE() uint32 {
	return (volatile.LoadUint32(&o.RGD0_WORD2.Reg) & 0x800000) >> 23
}
func (o *SYSMPU_Type) SetRGD0_WORD2_M4WE(value uint32) {
	volatile.StoreUint32(&o.RGD0_WORD2.Reg, volatile.LoadUint32(&o.RGD0_WORD2.Reg)&^(0x1000000)|value<<24)
}
func (o *SYSMPU_Type) GetRGD0_WORD2_M4WE() uint32 {
	return (volatile.LoadUint32(&o.RGD0_WORD2.Reg) & 0x1000000) >> 24
}
func (o *SYSMPU_Type) SetRGD0_WORD2_M4RE(value uint32) {
	volatile.StoreUint32(&o.RGD0_WORD2.Reg, volatile.LoadUint32(&o.RGD0_WORD2.Reg)&^(0x2000000)|value<<25)
}
func (o *SYSMPU_Type) GetRGD0_WORD2_M4RE() uint32 {
	return (volatile.LoadUint32(&o.RGD0_WORD2.Reg) & 0x2000000) >> 25
}
func (o *SYSMPU_Type) SetRGD0_WORD2_M5WE(value uint32) {
	volatile.StoreUint32(&o.RGD0_WORD2.Reg, volatile.LoadUint32(&o.RGD0_WORD2.Reg)&^(0x4000000)|value<<26)
}
func (o *SYSMPU_Type) GetRGD0_WORD2_M5WE() uint32 {
	return (volatile.LoadUint32(&o.RGD0_WORD2.Reg) & 0x4000000) >> 26
}
func (o *SYSMPU_Type) SetRGD0_WORD2_M5RE(value uint32) {
	volatile.StoreUint32(&o.RGD0_WORD2.Reg, volatile.LoadUint32(&o.RGD0_WORD2.Reg)&^(0x8000000)|value<<27)
}
func (o *SYSMPU_Type) GetRGD0_WORD2_M5RE() uint32 {
	return (volatile.LoadUint32(&o.RGD0_WORD2.Reg) & 0x8000000) >> 27
}
func (o *SYSMPU_Type) SetRGD0_WORD2_M6WE(value uint32) {
	volatile.StoreUint32(&o.RGD0_WORD2.Reg, volatile.LoadUint32(&o.RGD0_WORD2.Reg)&^(0x10000000)|value<<28)
}
func (o *SYSMPU_Type) GetRGD0_WORD2_M6WE() uint32 {
	return (volatile.LoadUint32(&o.RGD0_WORD2.Reg) & 0x10000000) >> 28
}
func (o *SYSMPU_Type) SetRGD0_WORD2_M6RE(value uint32) {
	volatile.StoreUint32(&o.RGD0_WORD2.Reg, volatile.LoadUint32(&o.RGD0_WORD2.Reg)&^(0x20000000)|value<<29)
}
func (o *SYSMPU_Type) GetRGD0_WORD2_M6RE() uint32 {
	return (volatile.LoadUint32(&o.RGD0_WORD2.Reg) & 0x20000000) >> 29
}
func (o *SYSMPU_Type) SetRGD0_WORD2_M7WE(value uint32) {
	volatile.StoreUint32(&o.RGD0_WORD2.Reg, volatile.LoadUint32(&o.RGD0_WORD2.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSMPU_Type) GetRGD0_WORD2_M7WE() uint32 {
	return (volatile.LoadUint32(&o.RGD0_WORD2.Reg) & 0x40000000) >> 30
}
func (o *SYSMPU_Type) SetRGD0_WORD2_M7RE(value uint32) {
	volatile.StoreUint32(&o.RGD0_WORD2.Reg, volatile.LoadUint32(&o.RGD0_WORD2.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSMPU_Type) GetRGD0_WORD2_M7RE() uint32 {
	return (volatile.LoadUint32(&o.RGD0_WORD2.Reg) & 0x80000000) >> 31
}

// SYSMPU.RGD0_WORD3: Region Descriptor n, Word 3
func (o *SYSMPU_Type) SetRGD0_WORD3_VLD(value uint32) {
	volatile.StoreUint32(&o.RGD0_WORD3.Reg, volatile.LoadUint32(&o.RGD0_WORD3.Reg)&^(0x1)|value)
}
func (o *SYSMPU_Type) GetRGD0_WORD3_VLD() uint32 {
	return volatile.LoadUint32(&o.RGD0_WORD3.Reg) & 0x1
}
func (o *SYSMPU_Type) SetRGD0_WORD3_PIDMASK(value uint32) {
	volatile.StoreUint32(&o.RGD0_WORD3.Reg, volatile.LoadUint32(&o.RGD0_WORD3.Reg)&^(0xff0000)|value<<16)
}
func (o *SYSMPU_Type) GetRGD0_WORD3_PIDMASK() uint32 {
	return (volatile.LoadUint32(&o.RGD0_WORD3.Reg) & 0xff0000) >> 16
}
func (o *SYSMPU_Type) SetRGD0_WORD3_PID(value uint32) {
	volatile.StoreUint32(&o.RGD0_WORD3.Reg, volatile.LoadUint32(&o.RGD0_WORD3.Reg)&^(0xff000000)|value<<24)
}
func (o *SYSMPU_Type) GetRGD0_WORD3_PID() uint32 {
	return (volatile.LoadUint32(&o.RGD0_WORD3.Reg) & 0xff000000) >> 24
}

// SYSMPU.RGD1_WORD0: Region Descriptor n, Word 0
func (o *SYSMPU_Type) SetRGD1_WORD0_SRTADDR(value uint32) {
	volatile.StoreUint32(&o.RGD1_WORD0.Reg, volatile.LoadUint32(&o.RGD1_WORD0.Reg)&^(0xffffffe0)|value<<5)
}
func (o *SYSMPU_Type) GetRGD1_WORD0_SRTADDR() uint32 {
	return (volatile.LoadUint32(&o.RGD1_WORD0.Reg) & 0xffffffe0) >> 5
}

// SYSMPU.RGD1_WORD1: Region Descriptor n, Word 1
func (o *SYSMPU_Type) SetRGD1_WORD1_ENDADDR(value uint32) {
	volatile.StoreUint32(&o.RGD1_WORD1.Reg, volatile.LoadUint32(&o.RGD1_WORD1.Reg)&^(0xffffffe0)|value<<5)
}
func (o *SYSMPU_Type) GetRGD1_WORD1_ENDADDR() uint32 {
	return (volatile.LoadUint32(&o.RGD1_WORD1.Reg) & 0xffffffe0) >> 5
}

// SYSMPU.RGD1_WORD2: Region Descriptor n, Word 2
func (o *SYSMPU_Type) SetRGD1_WORD2_M0UM(value uint32) {
	volatile.StoreUint32(&o.RGD1_WORD2.Reg, volatile.LoadUint32(&o.RGD1_WORD2.Reg)&^(0x7)|value)
}
func (o *SYSMPU_Type) GetRGD1_WORD2_M0UM() uint32 {
	return volatile.LoadUint32(&o.RGD1_WORD2.Reg) & 0x7
}
func (o *SYSMPU_Type) SetRGD1_WORD2_M0SM(value uint32) {
	volatile.StoreUint32(&o.RGD1_WORD2.Reg, volatile.LoadUint32(&o.RGD1_WORD2.Reg)&^(0x18)|value<<3)
}
func (o *SYSMPU_Type) GetRGD1_WORD2_M0SM() uint32 {
	return (volatile.LoadUint32(&o.RGD1_WORD2.Reg) & 0x18) >> 3
}
func (o *SYSMPU_Type) SetRGD1_WORD2_M0PE(value uint32) {
	volatile.StoreUint32(&o.RGD1_WORD2.Reg, volatile.LoadUint32(&o.RGD1_WORD2.Reg)&^(0x20)|value<<5)
}
func (o *SYSMPU_Type) GetRGD1_WORD2_M0PE() uint32 {
	return (volatile.LoadUint32(&o.RGD1_WORD2.Reg) & 0x20) >> 5
}
func (o *SYSMPU_Type) SetRGD1_WORD2_M1UM(value uint32) {
	volatile.StoreUint32(&o.RGD1_WORD2.Reg, volatile.LoadUint32(&o.RGD1_WORD2.Reg)&^(0x1c0)|value<<6)
}
func (o *SYSMPU_Type) GetRGD1_WORD2_M1UM() uint32 {
	return (volatile.LoadUint32(&o.RGD1_WORD2.Reg) & 0x1c0) >> 6
}
func (o *SYSMPU_Type) SetRGD1_WORD2_M1SM(value uint32) {
	volatile.StoreUint32(&o.RGD1_WORD2.Reg, volatile.LoadUint32(&o.RGD1_WORD2.Reg)&^(0x600)|value<<9)
}
func (o *SYSMPU_Type) GetRGD1_WORD2_M1SM() uint32 {
	return (volatile.LoadUint32(&o.RGD1_WORD2.Reg) & 0x600) >> 9
}
func (o *SYSMPU_Type) SetRGD1_WORD2_M1PE(value uint32) {
	volatile.StoreUint32(&o.RGD1_WORD2.Reg, volatile.LoadUint32(&o.RGD1_WORD2.Reg)&^(0x800)|value<<11)
}
func (o *SYSMPU_Type) GetRGD1_WORD2_M1PE() uint32 {
	return (volatile.LoadUint32(&o.RGD1_WORD2.Reg) & 0x800) >> 11
}
func (o *SYSMPU_Type) SetRGD1_WORD2_M2UM(value uint32) {
	volatile.StoreUint32(&o.RGD1_WORD2.Reg, volatile.LoadUint32(&o.RGD1_WORD2.Reg)&^(0x7000)|value<<12)
}
func (o *SYSMPU_Type) GetRGD1_WORD2_M2UM() uint32 {
	return (volatile.LoadUint32(&o.RGD1_WORD2.Reg) & 0x7000) >> 12
}
func (o *SYSMPU_Type) SetRGD1_WORD2_M2SM(value uint32) {
	volatile.StoreUint32(&o.RGD1_WORD2.Reg, volatile.LoadUint32(&o.RGD1_WORD2.Reg)&^(0x18000)|value<<15)
}
func (o *SYSMPU_Type) GetRGD1_WORD2_M2SM() uint32 {
	return (volatile.LoadUint32(&o.RGD1_WORD2.Reg) & 0x18000) >> 15
}
func (o *SYSMPU_Type) SetRGD1_WORD2_M2PE(value uint32) {
	volatile.StoreUint32(&o.RGD1_WORD2.Reg, volatile.LoadUint32(&o.RGD1_WORD2.Reg)&^(0x20000)|value<<17)
}
func (o *SYSMPU_Type) GetRGD1_WORD2_M2PE() uint32 {
	return (volatile.LoadUint32(&o.RGD1_WORD2.Reg) & 0x20000) >> 17
}
func (o *SYSMPU_Type) SetRGD1_WORD2_M3UM(value uint32) {
	volatile.StoreUint32(&o.RGD1_WORD2.Reg, volatile.LoadUint32(&o.RGD1_WORD2.Reg)&^(0x1c0000)|value<<18)
}
func (o *SYSMPU_Type) GetRGD1_WORD2_M3UM() uint32 {
	return (volatile.LoadUint32(&o.RGD1_WORD2.Reg) & 0x1c0000) >> 18
}
func (o *SYSMPU_Type) SetRGD1_WORD2_M3SM(value uint32) {
	volatile.StoreUint32(&o.RGD1_WORD2.Reg, volatile.LoadUint32(&o.RGD1_WORD2.Reg)&^(0x600000)|value<<21)
}
func (o *SYSMPU_Type) GetRGD1_WORD2_M3SM() uint32 {
	return (volatile.LoadUint32(&o.RGD1_WORD2.Reg) & 0x600000) >> 21
}
func (o *SYSMPU_Type) SetRGD1_WORD2_M3PE(value uint32) {
	volatile.StoreUint32(&o.RGD1_WORD2.Reg, volatile.LoadUint32(&o.RGD1_WORD2.Reg)&^(0x800000)|value<<23)
}
func (o *SYSMPU_Type) GetRGD1_WORD2_M3PE() uint32 {
	return (volatile.LoadUint32(&o.RGD1_WORD2.Reg) & 0x800000) >> 23
}
func (o *SYSMPU_Type) SetRGD1_WORD2_M4WE(value uint32) {
	volatile.StoreUint32(&o.RGD1_WORD2.Reg, volatile.LoadUint32(&o.RGD1_WORD2.Reg)&^(0x1000000)|value<<24)
}
func (o *SYSMPU_Type) GetRGD1_WORD2_M4WE() uint32 {
	return (volatile.LoadUint32(&o.RGD1_WORD2.Reg) & 0x1000000) >> 24
}
func (o *SYSMPU_Type) SetRGD1_WORD2_M4RE(value uint32) {
	volatile.StoreUint32(&o.RGD1_WORD2.Reg, volatile.LoadUint32(&o.RGD1_WORD2.Reg)&^(0x2000000)|value<<25)
}
func (o *SYSMPU_Type) GetRGD1_WORD2_M4RE() uint32 {
	return (volatile.LoadUint32(&o.RGD1_WORD2.Reg) & 0x2000000) >> 25
}
func (o *SYSMPU_Type) SetRGD1_WORD2_M5WE(value uint32) {
	volatile.StoreUint32(&o.RGD1_WORD2.Reg, volatile.LoadUint32(&o.RGD1_WORD2.Reg)&^(0x4000000)|value<<26)
}
func (o *SYSMPU_Type) GetRGD1_WORD2_M5WE() uint32 {
	return (volatile.LoadUint32(&o.RGD1_WORD2.Reg) & 0x4000000) >> 26
}
func (o *SYSMPU_Type) SetRGD1_WORD2_M5RE(value uint32) {
	volatile.StoreUint32(&o.RGD1_WORD2.Reg, volatile.LoadUint32(&o.RGD1_WORD2.Reg)&^(0x8000000)|value<<27)
}
func (o *SYSMPU_Type) GetRGD1_WORD2_M5RE() uint32 {
	return (volatile.LoadUint32(&o.RGD1_WORD2.Reg) & 0x8000000) >> 27
}
func (o *SYSMPU_Type) SetRGD1_WORD2_M6WE(value uint32) {
	volatile.StoreUint32(&o.RGD1_WORD2.Reg, volatile.LoadUint32(&o.RGD1_WORD2.Reg)&^(0x10000000)|value<<28)
}
func (o *SYSMPU_Type) GetRGD1_WORD2_M6WE() uint32 {
	return (volatile.LoadUint32(&o.RGD1_WORD2.Reg) & 0x10000000) >> 28
}
func (o *SYSMPU_Type) SetRGD1_WORD2_M6RE(value uint32) {
	volatile.StoreUint32(&o.RGD1_WORD2.Reg, volatile.LoadUint32(&o.RGD1_WORD2.Reg)&^(0x20000000)|value<<29)
}
func (o *SYSMPU_Type) GetRGD1_WORD2_M6RE() uint32 {
	return (volatile.LoadUint32(&o.RGD1_WORD2.Reg) & 0x20000000) >> 29
}
func (o *SYSMPU_Type) SetRGD1_WORD2_M7WE(value uint32) {
	volatile.StoreUint32(&o.RGD1_WORD2.Reg, volatile.LoadUint32(&o.RGD1_WORD2.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSMPU_Type) GetRGD1_WORD2_M7WE() uint32 {
	return (volatile.LoadUint32(&o.RGD1_WORD2.Reg) & 0x40000000) >> 30
}
func (o *SYSMPU_Type) SetRGD1_WORD2_M7RE(value uint32) {
	volatile.StoreUint32(&o.RGD1_WORD2.Reg, volatile.LoadUint32(&o.RGD1_WORD2.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSMPU_Type) GetRGD1_WORD2_M7RE() uint32 {
	return (volatile.LoadUint32(&o.RGD1_WORD2.Reg) & 0x80000000) >> 31
}

// SYSMPU.RGD1_WORD3: Region Descriptor n, Word 3
func (o *SYSMPU_Type) SetRGD1_WORD3_VLD(value uint32) {
	volatile.StoreUint32(&o.RGD1_WORD3.Reg, volatile.LoadUint32(&o.RGD1_WORD3.Reg)&^(0x1)|value)
}
func (o *SYSMPU_Type) GetRGD1_WORD3_VLD() uint32 {
	return volatile.LoadUint32(&o.RGD1_WORD3.Reg) & 0x1
}
func (o *SYSMPU_Type) SetRGD1_WORD3_PIDMASK(value uint32) {
	volatile.StoreUint32(&o.RGD1_WORD3.Reg, volatile.LoadUint32(&o.RGD1_WORD3.Reg)&^(0xff0000)|value<<16)
}
func (o *SYSMPU_Type) GetRGD1_WORD3_PIDMASK() uint32 {
	return (volatile.LoadUint32(&o.RGD1_WORD3.Reg) & 0xff0000) >> 16
}
func (o *SYSMPU_Type) SetRGD1_WORD3_PID(value uint32) {
	volatile.StoreUint32(&o.RGD1_WORD3.Reg, volatile.LoadUint32(&o.RGD1_WORD3.Reg)&^(0xff000000)|value<<24)
}
func (o *SYSMPU_Type) GetRGD1_WORD3_PID() uint32 {
	return (volatile.LoadUint32(&o.RGD1_WORD3.Reg) & 0xff000000) >> 24
}

// SYSMPU.RGD2_WORD0: Region Descriptor n, Word 0
func (o *SYSMPU_Type) SetRGD2_WORD0_SRTADDR(value uint32) {
	volatile.StoreUint32(&o.RGD2_WORD0.Reg, volatile.LoadUint32(&o.RGD2_WORD0.Reg)&^(0xffffffe0)|value<<5)
}
func (o *SYSMPU_Type) GetRGD2_WORD0_SRTADDR() uint32 {
	return (volatile.LoadUint32(&o.RGD2_WORD0.Reg) & 0xffffffe0) >> 5
}

// SYSMPU.RGD2_WORD1: Region Descriptor n, Word 1
func (o *SYSMPU_Type) SetRGD2_WORD1_ENDADDR(value uint32) {
	volatile.StoreUint32(&o.RGD2_WORD1.Reg, volatile.LoadUint32(&o.RGD2_WORD1.Reg)&^(0xffffffe0)|value<<5)
}
func (o *SYSMPU_Type) GetRGD2_WORD1_ENDADDR() uint32 {
	return (volatile.LoadUint32(&o.RGD2_WORD1.Reg) & 0xffffffe0) >> 5
}

// SYSMPU.RGD2_WORD2: Region Descriptor n, Word 2
func (o *SYSMPU_Type) SetRGD2_WORD2_M0UM(value uint32) {
	volatile.StoreUint32(&o.RGD2_WORD2.Reg, volatile.LoadUint32(&o.RGD2_WORD2.Reg)&^(0x7)|value)
}
func (o *SYSMPU_Type) GetRGD2_WORD2_M0UM() uint32 {
	return volatile.LoadUint32(&o.RGD2_WORD2.Reg) & 0x7
}
func (o *SYSMPU_Type) SetRGD2_WORD2_M0SM(value uint32) {
	volatile.StoreUint32(&o.RGD2_WORD2.Reg, volatile.LoadUint32(&o.RGD2_WORD2.Reg)&^(0x18)|value<<3)
}
func (o *SYSMPU_Type) GetRGD2_WORD2_M0SM() uint32 {
	return (volatile.LoadUint32(&o.RGD2_WORD2.Reg) & 0x18) >> 3
}
func (o *SYSMPU_Type) SetRGD2_WORD2_M0PE(value uint32) {
	volatile.StoreUint32(&o.RGD2_WORD2.Reg, volatile.LoadUint32(&o.RGD2_WORD2.Reg)&^(0x20)|value<<5)
}
func (o *SYSMPU_Type) GetRGD2_WORD2_M0PE() uint32 {
	return (volatile.LoadUint32(&o.RGD2_WORD2.Reg) & 0x20) >> 5
}
func (o *SYSMPU_Type) SetRGD2_WORD2_M1UM(value uint32) {
	volatile.StoreUint32(&o.RGD2_WORD2.Reg, volatile.LoadUint32(&o.RGD2_WORD2.Reg)&^(0x1c0)|value<<6)
}
func (o *SYSMPU_Type) GetRGD2_WORD2_M1UM() uint32 {
	return (volatile.LoadUint32(&o.RGD2_WORD2.Reg) & 0x1c0) >> 6
}
func (o *SYSMPU_Type) SetRGD2_WORD2_M1SM(value uint32) {
	volatile.StoreUint32(&o.RGD2_WORD2.Reg, volatile.LoadUint32(&o.RGD2_WORD2.Reg)&^(0x600)|value<<9)
}
func (o *SYSMPU_Type) GetRGD2_WORD2_M1SM() uint32 {
	return (volatile.LoadUint32(&o.RGD2_WORD2.Reg) & 0x600) >> 9
}
func (o *SYSMPU_Type) SetRGD2_WORD2_M1PE(value uint32) {
	volatile.StoreUint32(&o.RGD2_WORD2.Reg, volatile.LoadUint32(&o.RGD2_WORD2.Reg)&^(0x800)|value<<11)
}
func (o *SYSMPU_Type) GetRGD2_WORD2_M1PE() uint32 {
	return (volatile.LoadUint32(&o.RGD2_WORD2.Reg) & 0x800) >> 11
}
func (o *SYSMPU_Type) SetRGD2_WORD2_M2UM(value uint32) {
	volatile.StoreUint32(&o.RGD2_WORD2.Reg, volatile.LoadUint32(&o.RGD2_WORD2.Reg)&^(0x7000)|value<<12)
}
func (o *SYSMPU_Type) GetRGD2_WORD2_M2UM() uint32 {
	return (volatile.LoadUint32(&o.RGD2_WORD2.Reg) & 0x7000) >> 12
}
func (o *SYSMPU_Type) SetRGD2_WORD2_M2SM(value uint32) {
	volatile.StoreUint32(&o.RGD2_WORD2.Reg, volatile.LoadUint32(&o.RGD2_WORD2.Reg)&^(0x18000)|value<<15)
}
func (o *SYSMPU_Type) GetRGD2_WORD2_M2SM() uint32 {
	return (volatile.LoadUint32(&o.RGD2_WORD2.Reg) & 0x18000) >> 15
}
func (o *SYSMPU_Type) SetRGD2_WORD2_M2PE(value uint32) {
	volatile.StoreUint32(&o.RGD2_WORD2.Reg, volatile.LoadUint32(&o.RGD2_WORD2.Reg)&^(0x20000)|value<<17)
}
func (o *SYSMPU_Type) GetRGD2_WORD2_M2PE() uint32 {
	return (volatile.LoadUint32(&o.RGD2_WORD2.Reg) & 0x20000) >> 17
}
func (o *SYSMPU_Type) SetRGD2_WORD2_M3UM(value uint32) {
	volatile.StoreUint32(&o.RGD2_WORD2.Reg, volatile.LoadUint32(&o.RGD2_WORD2.Reg)&^(0x1c0000)|value<<18)
}
func (o *SYSMPU_Type) GetRGD2_WORD2_M3UM() uint32 {
	return (volatile.LoadUint32(&o.RGD2_WORD2.Reg) & 0x1c0000) >> 18
}
func (o *SYSMPU_Type) SetRGD2_WORD2_M3SM(value uint32) {
	volatile.StoreUint32(&o.RGD2_WORD2.Reg, volatile.LoadUint32(&o.RGD2_WORD2.Reg)&^(0x600000)|value<<21)
}
func (o *SYSMPU_Type) GetRGD2_WORD2_M3SM() uint32 {
	return (volatile.LoadUint32(&o.RGD2_WORD2.Reg) & 0x600000) >> 21
}
func (o *SYSMPU_Type) SetRGD2_WORD2_M3PE(value uint32) {
	volatile.StoreUint32(&o.RGD2_WORD2.Reg, volatile.LoadUint32(&o.RGD2_WORD2.Reg)&^(0x800000)|value<<23)
}
func (o *SYSMPU_Type) GetRGD2_WORD2_M3PE() uint32 {
	return (volatile.LoadUint32(&o.RGD2_WORD2.Reg) & 0x800000) >> 23
}
func (o *SYSMPU_Type) SetRGD2_WORD2_M4WE(value uint32) {
	volatile.StoreUint32(&o.RGD2_WORD2.Reg, volatile.LoadUint32(&o.RGD2_WORD2.Reg)&^(0x1000000)|value<<24)
}
func (o *SYSMPU_Type) GetRGD2_WORD2_M4WE() uint32 {
	return (volatile.LoadUint32(&o.RGD2_WORD2.Reg) & 0x1000000) >> 24
}
func (o *SYSMPU_Type) SetRGD2_WORD2_M4RE(value uint32) {
	volatile.StoreUint32(&o.RGD2_WORD2.Reg, volatile.LoadUint32(&o.RGD2_WORD2.Reg)&^(0x2000000)|value<<25)
}
func (o *SYSMPU_Type) GetRGD2_WORD2_M4RE() uint32 {
	return (volatile.LoadUint32(&o.RGD2_WORD2.Reg) & 0x2000000) >> 25
}
func (o *SYSMPU_Type) SetRGD2_WORD2_M5WE(value uint32) {
	volatile.StoreUint32(&o.RGD2_WORD2.Reg, volatile.LoadUint32(&o.RGD2_WORD2.Reg)&^(0x4000000)|value<<26)
}
func (o *SYSMPU_Type) GetRGD2_WORD2_M5WE() uint32 {
	return (volatile.LoadUint32(&o.RGD2_WORD2.Reg) & 0x4000000) >> 26
}
func (o *SYSMPU_Type) SetRGD2_WORD2_M5RE(value uint32) {
	volatile.StoreUint32(&o.RGD2_WORD2.Reg, volatile.LoadUint32(&o.RGD2_WORD2.Reg)&^(0x8000000)|value<<27)
}
func (o *SYSMPU_Type) GetRGD2_WORD2_M5RE() uint32 {
	return (volatile.LoadUint32(&o.RGD2_WORD2.Reg) & 0x8000000) >> 27
}
func (o *SYSMPU_Type) SetRGD2_WORD2_M6WE(value uint32) {
	volatile.StoreUint32(&o.RGD2_WORD2.Reg, volatile.LoadUint32(&o.RGD2_WORD2.Reg)&^(0x10000000)|value<<28)
}
func (o *SYSMPU_Type) GetRGD2_WORD2_M6WE() uint32 {
	return (volatile.LoadUint32(&o.RGD2_WORD2.Reg) & 0x10000000) >> 28
}
func (o *SYSMPU_Type) SetRGD2_WORD2_M6RE(value uint32) {
	volatile.StoreUint32(&o.RGD2_WORD2.Reg, volatile.LoadUint32(&o.RGD2_WORD2.Reg)&^(0x20000000)|value<<29)
}
func (o *SYSMPU_Type) GetRGD2_WORD2_M6RE() uint32 {
	return (volatile.LoadUint32(&o.RGD2_WORD2.Reg) & 0x20000000) >> 29
}
func (o *SYSMPU_Type) SetRGD2_WORD2_M7WE(value uint32) {
	volatile.StoreUint32(&o.RGD2_WORD2.Reg, volatile.LoadUint32(&o.RGD2_WORD2.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSMPU_Type) GetRGD2_WORD2_M7WE() uint32 {
	return (volatile.LoadUint32(&o.RGD2_WORD2.Reg) & 0x40000000) >> 30
}
func (o *SYSMPU_Type) SetRGD2_WORD2_M7RE(value uint32) {
	volatile.StoreUint32(&o.RGD2_WORD2.Reg, volatile.LoadUint32(&o.RGD2_WORD2.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSMPU_Type) GetRGD2_WORD2_M7RE() uint32 {
	return (volatile.LoadUint32(&o.RGD2_WORD2.Reg) & 0x80000000) >> 31
}

// SYSMPU.RGD2_WORD3: Region Descriptor n, Word 3
func (o *SYSMPU_Type) SetRGD2_WORD3_VLD(value uint32) {
	volatile.StoreUint32(&o.RGD2_WORD3.Reg, volatile.LoadUint32(&o.RGD2_WORD3.Reg)&^(0x1)|value)
}
func (o *SYSMPU_Type) GetRGD2_WORD3_VLD() uint32 {
	return volatile.LoadUint32(&o.RGD2_WORD3.Reg) & 0x1
}
func (o *SYSMPU_Type) SetRGD2_WORD3_PIDMASK(value uint32) {
	volatile.StoreUint32(&o.RGD2_WORD3.Reg, volatile.LoadUint32(&o.RGD2_WORD3.Reg)&^(0xff0000)|value<<16)
}
func (o *SYSMPU_Type) GetRGD2_WORD3_PIDMASK() uint32 {
	return (volatile.LoadUint32(&o.RGD2_WORD3.Reg) & 0xff0000) >> 16
}
func (o *SYSMPU_Type) SetRGD2_WORD3_PID(value uint32) {
	volatile.StoreUint32(&o.RGD2_WORD3.Reg, volatile.LoadUint32(&o.RGD2_WORD3.Reg)&^(0xff000000)|value<<24)
}
func (o *SYSMPU_Type) GetRGD2_WORD3_PID() uint32 {
	return (volatile.LoadUint32(&o.RGD2_WORD3.Reg) & 0xff000000) >> 24
}

// SYSMPU.RGD3_WORD0: Region Descriptor n, Word 0
func (o *SYSMPU_Type) SetRGD3_WORD0_SRTADDR(value uint32) {
	volatile.StoreUint32(&o.RGD3_WORD0.Reg, volatile.LoadUint32(&o.RGD3_WORD0.Reg)&^(0xffffffe0)|value<<5)
}
func (o *SYSMPU_Type) GetRGD3_WORD0_SRTADDR() uint32 {
	return (volatile.LoadUint32(&o.RGD3_WORD0.Reg) & 0xffffffe0) >> 5
}

// SYSMPU.RGD3_WORD1: Region Descriptor n, Word 1
func (o *SYSMPU_Type) SetRGD3_WORD1_ENDADDR(value uint32) {
	volatile.StoreUint32(&o.RGD3_WORD1.Reg, volatile.LoadUint32(&o.RGD3_WORD1.Reg)&^(0xffffffe0)|value<<5)
}
func (o *SYSMPU_Type) GetRGD3_WORD1_ENDADDR() uint32 {
	return (volatile.LoadUint32(&o.RGD3_WORD1.Reg) & 0xffffffe0) >> 5
}

// SYSMPU.RGD3_WORD2: Region Descriptor n, Word 2
func (o *SYSMPU_Type) SetRGD3_WORD2_M0UM(value uint32) {
	volatile.StoreUint32(&o.RGD3_WORD2.Reg, volatile.LoadUint32(&o.RGD3_WORD2.Reg)&^(0x7)|value)
}
func (o *SYSMPU_Type) GetRGD3_WORD2_M0UM() uint32 {
	return volatile.LoadUint32(&o.RGD3_WORD2.Reg) & 0x7
}
func (o *SYSMPU_Type) SetRGD3_WORD2_M0SM(value uint32) {
	volatile.StoreUint32(&o.RGD3_WORD2.Reg, volatile.LoadUint32(&o.RGD3_WORD2.Reg)&^(0x18)|value<<3)
}
func (o *SYSMPU_Type) GetRGD3_WORD2_M0SM() uint32 {
	return (volatile.LoadUint32(&o.RGD3_WORD2.Reg) & 0x18) >> 3
}
func (o *SYSMPU_Type) SetRGD3_WORD2_M0PE(value uint32) {
	volatile.StoreUint32(&o.RGD3_WORD2.Reg, volatile.LoadUint32(&o.RGD3_WORD2.Reg)&^(0x20)|value<<5)
}
func (o *SYSMPU_Type) GetRGD3_WORD2_M0PE() uint32 {
	return (volatile.LoadUint32(&o.RGD3_WORD2.Reg) & 0x20) >> 5
}
func (o *SYSMPU_Type) SetRGD3_WORD2_M1UM(value uint32) {
	volatile.StoreUint32(&o.RGD3_WORD2.Reg, volatile.LoadUint32(&o.RGD3_WORD2.Reg)&^(0x1c0)|value<<6)
}
func (o *SYSMPU_Type) GetRGD3_WORD2_M1UM() uint32 {
	return (volatile.LoadUint32(&o.RGD3_WORD2.Reg) & 0x1c0) >> 6
}
func (o *SYSMPU_Type) SetRGD3_WORD2_M1SM(value uint32) {
	volatile.StoreUint32(&o.RGD3_WORD2.Reg, volatile.LoadUint32(&o.RGD3_WORD2.Reg)&^(0x600)|value<<9)
}
func (o *SYSMPU_Type) GetRGD3_WORD2_M1SM() uint32 {
	return (volatile.LoadUint32(&o.RGD3_WORD2.Reg) & 0x600) >> 9
}
func (o *SYSMPU_Type) SetRGD3_WORD2_M1PE(value uint32) {
	volatile.StoreUint32(&o.RGD3_WORD2.Reg, volatile.LoadUint32(&o.RGD3_WORD2.Reg)&^(0x800)|value<<11)
}
func (o *SYSMPU_Type) GetRGD3_WORD2_M1PE() uint32 {
	return (volatile.LoadUint32(&o.RGD3_WORD2.Reg) & 0x800) >> 11
}
func (o *SYSMPU_Type) SetRGD3_WORD2_M2UM(value uint32) {
	volatile.StoreUint32(&o.RGD3_WORD2.Reg, volatile.LoadUint32(&o.RGD3_WORD2.Reg)&^(0x7000)|value<<12)
}
func (o *SYSMPU_Type) GetRGD3_WORD2_M2UM() uint32 {
	return (volatile.LoadUint32(&o.RGD3_WORD2.Reg) & 0x7000) >> 12
}
func (o *SYSMPU_Type) SetRGD3_WORD2_M2SM(value uint32) {
	volatile.StoreUint32(&o.RGD3_WORD2.Reg, volatile.LoadUint32(&o.RGD3_WORD2.Reg)&^(0x18000)|value<<15)
}
func (o *SYSMPU_Type) GetRGD3_WORD2_M2SM() uint32 {
	return (volatile.LoadUint32(&o.RGD3_WORD2.Reg) & 0x18000) >> 15
}
func (o *SYSMPU_Type) SetRGD3_WORD2_M2PE(value uint32) {
	volatile.StoreUint32(&o.RGD3_WORD2.Reg, volatile.LoadUint32(&o.RGD3_WORD2.Reg)&^(0x20000)|value<<17)
}
func (o *SYSMPU_Type) GetRGD3_WORD2_M2PE() uint32 {
	return (volatile.LoadUint32(&o.RGD3_WORD2.Reg) & 0x20000) >> 17
}
func (o *SYSMPU_Type) SetRGD3_WORD2_M3UM(value uint32) {
	volatile.StoreUint32(&o.RGD3_WORD2.Reg, volatile.LoadUint32(&o.RGD3_WORD2.Reg)&^(0x1c0000)|value<<18)
}
func (o *SYSMPU_Type) GetRGD3_WORD2_M3UM() uint32 {
	return (volatile.LoadUint32(&o.RGD3_WORD2.Reg) & 0x1c0000) >> 18
}
func (o *SYSMPU_Type) SetRGD3_WORD2_M3SM(value uint32) {
	volatile.StoreUint32(&o.RGD3_WORD2.Reg, volatile.LoadUint32(&o.RGD3_WORD2.Reg)&^(0x600000)|value<<21)
}
func (o *SYSMPU_Type) GetRGD3_WORD2_M3SM() uint32 {
	return (volatile.LoadUint32(&o.RGD3_WORD2.Reg) & 0x600000) >> 21
}
func (o *SYSMPU_Type) SetRGD3_WORD2_M3PE(value uint32) {
	volatile.StoreUint32(&o.RGD3_WORD2.Reg, volatile.LoadUint32(&o.RGD3_WORD2.Reg)&^(0x800000)|value<<23)
}
func (o *SYSMPU_Type) GetRGD3_WORD2_M3PE() uint32 {
	return (volatile.LoadUint32(&o.RGD3_WORD2.Reg) & 0x800000) >> 23
}
func (o *SYSMPU_Type) SetRGD3_WORD2_M4WE(value uint32) {
	volatile.StoreUint32(&o.RGD3_WORD2.Reg, volatile.LoadUint32(&o.RGD3_WORD2.Reg)&^(0x1000000)|value<<24)
}
func (o *SYSMPU_Type) GetRGD3_WORD2_M4WE() uint32 {
	return (volatile.LoadUint32(&o.RGD3_WORD2.Reg) & 0x1000000) >> 24
}
func (o *SYSMPU_Type) SetRGD3_WORD2_M4RE(value uint32) {
	volatile.StoreUint32(&o.RGD3_WORD2.Reg, volatile.LoadUint32(&o.RGD3_WORD2.Reg)&^(0x2000000)|value<<25)
}
func (o *SYSMPU_Type) GetRGD3_WORD2_M4RE() uint32 {
	return (volatile.LoadUint32(&o.RGD3_WORD2.Reg) & 0x2000000) >> 25
}
func (o *SYSMPU_Type) SetRGD3_WORD2_M5WE(value uint32) {
	volatile.StoreUint32(&o.RGD3_WORD2.Reg, volatile.LoadUint32(&o.RGD3_WORD2.Reg)&^(0x4000000)|value<<26)
}
func (o *SYSMPU_Type) GetRGD3_WORD2_M5WE() uint32 {
	return (volatile.LoadUint32(&o.RGD3_WORD2.Reg) & 0x4000000) >> 26
}
func (o *SYSMPU_Type) SetRGD3_WORD2_M5RE(value uint32) {
	volatile.StoreUint32(&o.RGD3_WORD2.Reg, volatile.LoadUint32(&o.RGD3_WORD2.Reg)&^(0x8000000)|value<<27)
}
func (o *SYSMPU_Type) GetRGD3_WORD2_M5RE() uint32 {
	return (volatile.LoadUint32(&o.RGD3_WORD2.Reg) & 0x8000000) >> 27
}
func (o *SYSMPU_Type) SetRGD3_WORD2_M6WE(value uint32) {
	volatile.StoreUint32(&o.RGD3_WORD2.Reg, volatile.LoadUint32(&o.RGD3_WORD2.Reg)&^(0x10000000)|value<<28)
}
func (o *SYSMPU_Type) GetRGD3_WORD2_M6WE() uint32 {
	return (volatile.LoadUint32(&o.RGD3_WORD2.Reg) & 0x10000000) >> 28
}
func (o *SYSMPU_Type) SetRGD3_WORD2_M6RE(value uint32) {
	volatile.StoreUint32(&o.RGD3_WORD2.Reg, volatile.LoadUint32(&o.RGD3_WORD2.Reg)&^(0x20000000)|value<<29)
}
func (o *SYSMPU_Type) GetRGD3_WORD2_M6RE() uint32 {
	return (volatile.LoadUint32(&o.RGD3_WORD2.Reg) & 0x20000000) >> 29
}
func (o *SYSMPU_Type) SetRGD3_WORD2_M7WE(value uint32) {
	volatile.StoreUint32(&o.RGD3_WORD2.Reg, volatile.LoadUint32(&o.RGD3_WORD2.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSMPU_Type) GetRGD3_WORD2_M7WE() uint32 {
	return (volatile.LoadUint32(&o.RGD3_WORD2.Reg) & 0x40000000) >> 30
}
func (o *SYSMPU_Type) SetRGD3_WORD2_M7RE(value uint32) {
	volatile.StoreUint32(&o.RGD3_WORD2.Reg, volatile.LoadUint32(&o.RGD3_WORD2.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSMPU_Type) GetRGD3_WORD2_M7RE() uint32 {
	return (volatile.LoadUint32(&o.RGD3_WORD2.Reg) & 0x80000000) >> 31
}

// SYSMPU.RGD3_WORD3: Region Descriptor n, Word 3
func (o *SYSMPU_Type) SetRGD3_WORD3_VLD(value uint32) {
	volatile.StoreUint32(&o.RGD3_WORD3.Reg, volatile.LoadUint32(&o.RGD3_WORD3.Reg)&^(0x1)|value)
}
func (o *SYSMPU_Type) GetRGD3_WORD3_VLD() uint32 {
	return volatile.LoadUint32(&o.RGD3_WORD3.Reg) & 0x1
}
func (o *SYSMPU_Type) SetRGD3_WORD3_PIDMASK(value uint32) {
	volatile.StoreUint32(&o.RGD3_WORD3.Reg, volatile.LoadUint32(&o.RGD3_WORD3.Reg)&^(0xff0000)|value<<16)
}
func (o *SYSMPU_Type) GetRGD3_WORD3_PIDMASK() uint32 {
	return (volatile.LoadUint32(&o.RGD3_WORD3.Reg) & 0xff0000) >> 16
}
func (o *SYSMPU_Type) SetRGD3_WORD3_PID(value uint32) {
	volatile.StoreUint32(&o.RGD3_WORD3.Reg, volatile.LoadUint32(&o.RGD3_WORD3.Reg)&^(0xff000000)|value<<24)
}
func (o *SYSMPU_Type) GetRGD3_WORD3_PID() uint32 {
	return (volatile.LoadUint32(&o.RGD3_WORD3.Reg) & 0xff000000) >> 24
}

// SYSMPU.RGD4_WORD0: Region Descriptor n, Word 0
func (o *SYSMPU_Type) SetRGD4_WORD0_SRTADDR(value uint32) {
	volatile.StoreUint32(&o.RGD4_WORD0.Reg, volatile.LoadUint32(&o.RGD4_WORD0.Reg)&^(0xffffffe0)|value<<5)
}
func (o *SYSMPU_Type) GetRGD4_WORD0_SRTADDR() uint32 {
	return (volatile.LoadUint32(&o.RGD4_WORD0.Reg) & 0xffffffe0) >> 5
}

// SYSMPU.RGD4_WORD1: Region Descriptor n, Word 1
func (o *SYSMPU_Type) SetRGD4_WORD1_ENDADDR(value uint32) {
	volatile.StoreUint32(&o.RGD4_WORD1.Reg, volatile.LoadUint32(&o.RGD4_WORD1.Reg)&^(0xffffffe0)|value<<5)
}
func (o *SYSMPU_Type) GetRGD4_WORD1_ENDADDR() uint32 {
	return (volatile.LoadUint32(&o.RGD4_WORD1.Reg) & 0xffffffe0) >> 5
}

// SYSMPU.RGD4_WORD2: Region Descriptor n, Word 2
func (o *SYSMPU_Type) SetRGD4_WORD2_M0UM(value uint32) {
	volatile.StoreUint32(&o.RGD4_WORD2.Reg, volatile.LoadUint32(&o.RGD4_WORD2.Reg)&^(0x7)|value)
}
func (o *SYSMPU_Type) GetRGD4_WORD2_M0UM() uint32 {
	return volatile.LoadUint32(&o.RGD4_WORD2.Reg) & 0x7
}
func (o *SYSMPU_Type) SetRGD4_WORD2_M0SM(value uint32) {
	volatile.StoreUint32(&o.RGD4_WORD2.Reg, volatile.LoadUint32(&o.RGD4_WORD2.Reg)&^(0x18)|value<<3)
}
func (o *SYSMPU_Type) GetRGD4_WORD2_M0SM() uint32 {
	return (volatile.LoadUint32(&o.RGD4_WORD2.Reg) & 0x18) >> 3
}
func (o *SYSMPU_Type) SetRGD4_WORD2_M0PE(value uint32) {
	volatile.StoreUint32(&o.RGD4_WORD2.Reg, volatile.LoadUint32(&o.RGD4_WORD2.Reg)&^(0x20)|value<<5)
}
func (o *SYSMPU_Type) GetRGD4_WORD2_M0PE() uint32 {
	return (volatile.LoadUint32(&o.RGD4_WORD2.Reg) & 0x20) >> 5
}
func (o *SYSMPU_Type) SetRGD4_WORD2_M1UM(value uint32) {
	volatile.StoreUint32(&o.RGD4_WORD2.Reg, volatile.LoadUint32(&o.RGD4_WORD2.Reg)&^(0x1c0)|value<<6)
}
func (o *SYSMPU_Type) GetRGD4_WORD2_M1UM() uint32 {
	return (volatile.LoadUint32(&o.RGD4_WORD2.Reg) & 0x1c0) >> 6
}
func (o *SYSMPU_Type) SetRGD4_WORD2_M1SM(value uint32) {
	volatile.StoreUint32(&o.RGD4_WORD2.Reg, volatile.LoadUint32(&o.RGD4_WORD2.Reg)&^(0x600)|value<<9)
}
func (o *SYSMPU_Type) GetRGD4_WORD2_M1SM() uint32 {
	return (volatile.LoadUint32(&o.RGD4_WORD2.Reg) & 0x600) >> 9
}
func (o *SYSMPU_Type) SetRGD4_WORD2_M1PE(value uint32) {
	volatile.StoreUint32(&o.RGD4_WORD2.Reg, volatile.LoadUint32(&o.RGD4_WORD2.Reg)&^(0x800)|value<<11)
}
func (o *SYSMPU_Type) GetRGD4_WORD2_M1PE() uint32 {
	return (volatile.LoadUint32(&o.RGD4_WORD2.Reg) & 0x800) >> 11
}
func (o *SYSMPU_Type) SetRGD4_WORD2_M2UM(value uint32) {
	volatile.StoreUint32(&o.RGD4_WORD2.Reg, volatile.LoadUint32(&o.RGD4_WORD2.Reg)&^(0x7000)|value<<12)
}
func (o *SYSMPU_Type) GetRGD4_WORD2_M2UM() uint32 {
	return (volatile.LoadUint32(&o.RGD4_WORD2.Reg) & 0x7000) >> 12
}
func (o *SYSMPU_Type) SetRGD4_WORD2_M2SM(value uint32) {
	volatile.StoreUint32(&o.RGD4_WORD2.Reg, volatile.LoadUint32(&o.RGD4_WORD2.Reg)&^(0x18000)|value<<15)
}
func (o *SYSMPU_Type) GetRGD4_WORD2_M2SM() uint32 {
	return (volatile.LoadUint32(&o.RGD4_WORD2.Reg) & 0x18000) >> 15
}
func (o *SYSMPU_Type) SetRGD4_WORD2_M2PE(value uint32) {
	volatile.StoreUint32(&o.RGD4_WORD2.Reg, volatile.LoadUint32(&o.RGD4_WORD2.Reg)&^(0x20000)|value<<17)
}
func (o *SYSMPU_Type) GetRGD4_WORD2_M2PE() uint32 {
	return (volatile.LoadUint32(&o.RGD4_WORD2.Reg) & 0x20000) >> 17
}
func (o *SYSMPU_Type) SetRGD4_WORD2_M3UM(value uint32) {
	volatile.StoreUint32(&o.RGD4_WORD2.Reg, volatile.LoadUint32(&o.RGD4_WORD2.Reg)&^(0x1c0000)|value<<18)
}
func (o *SYSMPU_Type) GetRGD4_WORD2_M3UM() uint32 {
	return (volatile.LoadUint32(&o.RGD4_WORD2.Reg) & 0x1c0000) >> 18
}
func (o *SYSMPU_Type) SetRGD4_WORD2_M3SM(value uint32) {
	volatile.StoreUint32(&o.RGD4_WORD2.Reg, volatile.LoadUint32(&o.RGD4_WORD2.Reg)&^(0x600000)|value<<21)
}
func (o *SYSMPU_Type) GetRGD4_WORD2_M3SM() uint32 {
	return (volatile.LoadUint32(&o.RGD4_WORD2.Reg) & 0x600000) >> 21
}
func (o *SYSMPU_Type) SetRGD4_WORD2_M3PE(value uint32) {
	volatile.StoreUint32(&o.RGD4_WORD2.Reg, volatile.LoadUint32(&o.RGD4_WORD2.Reg)&^(0x800000)|value<<23)
}
func (o *SYSMPU_Type) GetRGD4_WORD2_M3PE() uint32 {
	return (volatile.LoadUint32(&o.RGD4_WORD2.Reg) & 0x800000) >> 23
}
func (o *SYSMPU_Type) SetRGD4_WORD2_M4WE(value uint32) {
	volatile.StoreUint32(&o.RGD4_WORD2.Reg, volatile.LoadUint32(&o.RGD4_WORD2.Reg)&^(0x1000000)|value<<24)
}
func (o *SYSMPU_Type) GetRGD4_WORD2_M4WE() uint32 {
	return (volatile.LoadUint32(&o.RGD4_WORD2.Reg) & 0x1000000) >> 24
}
func (o *SYSMPU_Type) SetRGD4_WORD2_M4RE(value uint32) {
	volatile.StoreUint32(&o.RGD4_WORD2.Reg, volatile.LoadUint32(&o.RGD4_WORD2.Reg)&^(0x2000000)|value<<25)
}
func (o *SYSMPU_Type) GetRGD4_WORD2_M4RE() uint32 {
	return (volatile.LoadUint32(&o.RGD4_WORD2.Reg) & 0x2000000) >> 25
}
func (o *SYSMPU_Type) SetRGD4_WORD2_M5WE(value uint32) {
	volatile.StoreUint32(&o.RGD4_WORD2.Reg, volatile.LoadUint32(&o.RGD4_WORD2.Reg)&^(0x4000000)|value<<26)
}
func (o *SYSMPU_Type) GetRGD4_WORD2_M5WE() uint32 {
	return (volatile.LoadUint32(&o.RGD4_WORD2.Reg) & 0x4000000) >> 26
}
func (o *SYSMPU_Type) SetRGD4_WORD2_M5RE(value uint32) {
	volatile.StoreUint32(&o.RGD4_WORD2.Reg, volatile.LoadUint32(&o.RGD4_WORD2.Reg)&^(0x8000000)|value<<27)
}
func (o *SYSMPU_Type) GetRGD4_WORD2_M5RE() uint32 {
	return (volatile.LoadUint32(&o.RGD4_WORD2.Reg) & 0x8000000) >> 27
}
func (o *SYSMPU_Type) SetRGD4_WORD2_M6WE(value uint32) {
	volatile.StoreUint32(&o.RGD4_WORD2.Reg, volatile.LoadUint32(&o.RGD4_WORD2.Reg)&^(0x10000000)|value<<28)
}
func (o *SYSMPU_Type) GetRGD4_WORD2_M6WE() uint32 {
	return (volatile.LoadUint32(&o.RGD4_WORD2.Reg) & 0x10000000) >> 28
}
func (o *SYSMPU_Type) SetRGD4_WORD2_M6RE(value uint32) {
	volatile.StoreUint32(&o.RGD4_WORD2.Reg, volatile.LoadUint32(&o.RGD4_WORD2.Reg)&^(0x20000000)|value<<29)
}
func (o *SYSMPU_Type) GetRGD4_WORD2_M6RE() uint32 {
	return (volatile.LoadUint32(&o.RGD4_WORD2.Reg) & 0x20000000) >> 29
}
func (o *SYSMPU_Type) SetRGD4_WORD2_M7WE(value uint32) {
	volatile.StoreUint32(&o.RGD4_WORD2.Reg, volatile.LoadUint32(&o.RGD4_WORD2.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSMPU_Type) GetRGD4_WORD2_M7WE() uint32 {
	return (volatile.LoadUint32(&o.RGD4_WORD2.Reg) & 0x40000000) >> 30
}
func (o *SYSMPU_Type) SetRGD4_WORD2_M7RE(value uint32) {
	volatile.StoreUint32(&o.RGD4_WORD2.Reg, volatile.LoadUint32(&o.RGD4_WORD2.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSMPU_Type) GetRGD4_WORD2_M7RE() uint32 {
	return (volatile.LoadUint32(&o.RGD4_WORD2.Reg) & 0x80000000) >> 31
}

// SYSMPU.RGD4_WORD3: Region Descriptor n, Word 3
func (o *SYSMPU_Type) SetRGD4_WORD3_VLD(value uint32) {
	volatile.StoreUint32(&o.RGD4_WORD3.Reg, volatile.LoadUint32(&o.RGD4_WORD3.Reg)&^(0x1)|value)
}
func (o *SYSMPU_Type) GetRGD4_WORD3_VLD() uint32 {
	return volatile.LoadUint32(&o.RGD4_WORD3.Reg) & 0x1
}
func (o *SYSMPU_Type) SetRGD4_WORD3_PIDMASK(value uint32) {
	volatile.StoreUint32(&o.RGD4_WORD3.Reg, volatile.LoadUint32(&o.RGD4_WORD3.Reg)&^(0xff0000)|value<<16)
}
func (o *SYSMPU_Type) GetRGD4_WORD3_PIDMASK() uint32 {
	return (volatile.LoadUint32(&o.RGD4_WORD3.Reg) & 0xff0000) >> 16
}
func (o *SYSMPU_Type) SetRGD4_WORD3_PID(value uint32) {
	volatile.StoreUint32(&o.RGD4_WORD3.Reg, volatile.LoadUint32(&o.RGD4_WORD3.Reg)&^(0xff000000)|value<<24)
}
func (o *SYSMPU_Type) GetRGD4_WORD3_PID() uint32 {
	return (volatile.LoadUint32(&o.RGD4_WORD3.Reg) & 0xff000000) >> 24
}

// SYSMPU.RGD5_WORD0: Region Descriptor n, Word 0
func (o *SYSMPU_Type) SetRGD5_WORD0_SRTADDR(value uint32) {
	volatile.StoreUint32(&o.RGD5_WORD0.Reg, volatile.LoadUint32(&o.RGD5_WORD0.Reg)&^(0xffffffe0)|value<<5)
}
func (o *SYSMPU_Type) GetRGD5_WORD0_SRTADDR() uint32 {
	return (volatile.LoadUint32(&o.RGD5_WORD0.Reg) & 0xffffffe0) >> 5
}

// SYSMPU.RGD5_WORD1: Region Descriptor n, Word 1
func (o *SYSMPU_Type) SetRGD5_WORD1_ENDADDR(value uint32) {
	volatile.StoreUint32(&o.RGD5_WORD1.Reg, volatile.LoadUint32(&o.RGD5_WORD1.Reg)&^(0xffffffe0)|value<<5)
}
func (o *SYSMPU_Type) GetRGD5_WORD1_ENDADDR() uint32 {
	return (volatile.LoadUint32(&o.RGD5_WORD1.Reg) & 0xffffffe0) >> 5
}

// SYSMPU.RGD5_WORD2: Region Descriptor n, Word 2
func (o *SYSMPU_Type) SetRGD5_WORD2_M0UM(value uint32) {
	volatile.StoreUint32(&o.RGD5_WORD2.Reg, volatile.LoadUint32(&o.RGD5_WORD2.Reg)&^(0x7)|value)
}
func (o *SYSMPU_Type) GetRGD5_WORD2_M0UM() uint32 {
	return volatile.LoadUint32(&o.RGD5_WORD2.Reg) & 0x7
}
func (o *SYSMPU_Type) SetRGD5_WORD2_M0SM(value uint32) {
	volatile.StoreUint32(&o.RGD5_WORD2.Reg, volatile.LoadUint32(&o.RGD5_WORD2.Reg)&^(0x18)|value<<3)
}
func (o *SYSMPU_Type) GetRGD5_WORD2_M0SM() uint32 {
	return (volatile.LoadUint32(&o.RGD5_WORD2.Reg) & 0x18) >> 3
}
func (o *SYSMPU_Type) SetRGD5_WORD2_M0PE(value uint32) {
	volatile.StoreUint32(&o.RGD5_WORD2.Reg, volatile.LoadUint32(&o.RGD5_WORD2.Reg)&^(0x20)|value<<5)
}
func (o *SYSMPU_Type) GetRGD5_WORD2_M0PE() uint32 {
	return (volatile.LoadUint32(&o.RGD5_WORD2.Reg) & 0x20) >> 5
}
func (o *SYSMPU_Type) SetRGD5_WORD2_M1UM(value uint32) {
	volatile.StoreUint32(&o.RGD5_WORD2.Reg, volatile.LoadUint32(&o.RGD5_WORD2.Reg)&^(0x1c0)|value<<6)
}
func (o *SYSMPU_Type) GetRGD5_WORD2_M1UM() uint32 {
	return (volatile.LoadUint32(&o.RGD5_WORD2.Reg) & 0x1c0) >> 6
}
func (o *SYSMPU_Type) SetRGD5_WORD2_M1SM(value uint32) {
	volatile.StoreUint32(&o.RGD5_WORD2.Reg, volatile.LoadUint32(&o.RGD5_WORD2.Reg)&^(0x600)|value<<9)
}
func (o *SYSMPU_Type) GetRGD5_WORD2_M1SM() uint32 {
	return (volatile.LoadUint32(&o.RGD5_WORD2.Reg) & 0x600) >> 9
}
func (o *SYSMPU_Type) SetRGD5_WORD2_M1PE(value uint32) {
	volatile.StoreUint32(&o.RGD5_WORD2.Reg, volatile.LoadUint32(&o.RGD5_WORD2.Reg)&^(0x800)|value<<11)
}
func (o *SYSMPU_Type) GetRGD5_WORD2_M1PE() uint32 {
	return (volatile.LoadUint32(&o.RGD5_WORD2.Reg) & 0x800) >> 11
}
func (o *SYSMPU_Type) SetRGD5_WORD2_M2UM(value uint32) {
	volatile.StoreUint32(&o.RGD5_WORD2.Reg, volatile.LoadUint32(&o.RGD5_WORD2.Reg)&^(0x7000)|value<<12)
}
func (o *SYSMPU_Type) GetRGD5_WORD2_M2UM() uint32 {
	return (volatile.LoadUint32(&o.RGD5_WORD2.Reg) & 0x7000) >> 12
}
func (o *SYSMPU_Type) SetRGD5_WORD2_M2SM(value uint32) {
	volatile.StoreUint32(&o.RGD5_WORD2.Reg, volatile.LoadUint32(&o.RGD5_WORD2.Reg)&^(0x18000)|value<<15)
}
func (o *SYSMPU_Type) GetRGD5_WORD2_M2SM() uint32 {
	return (volatile.LoadUint32(&o.RGD5_WORD2.Reg) & 0x18000) >> 15
}
func (o *SYSMPU_Type) SetRGD5_WORD2_M2PE(value uint32) {
	volatile.StoreUint32(&o.RGD5_WORD2.Reg, volatile.LoadUint32(&o.RGD5_WORD2.Reg)&^(0x20000)|value<<17)
}
func (o *SYSMPU_Type) GetRGD5_WORD2_M2PE() uint32 {
	return (volatile.LoadUint32(&o.RGD5_WORD2.Reg) & 0x20000) >> 17
}
func (o *SYSMPU_Type) SetRGD5_WORD2_M3UM(value uint32) {
	volatile.StoreUint32(&o.RGD5_WORD2.Reg, volatile.LoadUint32(&o.RGD5_WORD2.Reg)&^(0x1c0000)|value<<18)
}
func (o *SYSMPU_Type) GetRGD5_WORD2_M3UM() uint32 {
	return (volatile.LoadUint32(&o.RGD5_WORD2.Reg) & 0x1c0000) >> 18
}
func (o *SYSMPU_Type) SetRGD5_WORD2_M3SM(value uint32) {
	volatile.StoreUint32(&o.RGD5_WORD2.Reg, volatile.LoadUint32(&o.RGD5_WORD2.Reg)&^(0x600000)|value<<21)
}
func (o *SYSMPU_Type) GetRGD5_WORD2_M3SM() uint32 {
	return (volatile.LoadUint32(&o.RGD5_WORD2.Reg) & 0x600000) >> 21
}
func (o *SYSMPU_Type) SetRGD5_WORD2_M3PE(value uint32) {
	volatile.StoreUint32(&o.RGD5_WORD2.Reg, volatile.LoadUint32(&o.RGD5_WORD2.Reg)&^(0x800000)|value<<23)
}
func (o *SYSMPU_Type) GetRGD5_WORD2_M3PE() uint32 {
	return (volatile.LoadUint32(&o.RGD5_WORD2.Reg) & 0x800000) >> 23
}
func (o *SYSMPU_Type) SetRGD5_WORD2_M4WE(value uint32) {
	volatile.StoreUint32(&o.RGD5_WORD2.Reg, volatile.LoadUint32(&o.RGD5_WORD2.Reg)&^(0x1000000)|value<<24)
}
func (o *SYSMPU_Type) GetRGD5_WORD2_M4WE() uint32 {
	return (volatile.LoadUint32(&o.RGD5_WORD2.Reg) & 0x1000000) >> 24
}
func (o *SYSMPU_Type) SetRGD5_WORD2_M4RE(value uint32) {
	volatile.StoreUint32(&o.RGD5_WORD2.Reg, volatile.LoadUint32(&o.RGD5_WORD2.Reg)&^(0x2000000)|value<<25)
}
func (o *SYSMPU_Type) GetRGD5_WORD2_M4RE() uint32 {
	return (volatile.LoadUint32(&o.RGD5_WORD2.Reg) & 0x2000000) >> 25
}
func (o *SYSMPU_Type) SetRGD5_WORD2_M5WE(value uint32) {
	volatile.StoreUint32(&o.RGD5_WORD2.Reg, volatile.LoadUint32(&o.RGD5_WORD2.Reg)&^(0x4000000)|value<<26)
}
func (o *SYSMPU_Type) GetRGD5_WORD2_M5WE() uint32 {
	return (volatile.LoadUint32(&o.RGD5_WORD2.Reg) & 0x4000000) >> 26
}
func (o *SYSMPU_Type) SetRGD5_WORD2_M5RE(value uint32) {
	volatile.StoreUint32(&o.RGD5_WORD2.Reg, volatile.LoadUint32(&o.RGD5_WORD2.Reg)&^(0x8000000)|value<<27)
}
func (o *SYSMPU_Type) GetRGD5_WORD2_M5RE() uint32 {
	return (volatile.LoadUint32(&o.RGD5_WORD2.Reg) & 0x8000000) >> 27
}
func (o *SYSMPU_Type) SetRGD5_WORD2_M6WE(value uint32) {
	volatile.StoreUint32(&o.RGD5_WORD2.Reg, volatile.LoadUint32(&o.RGD5_WORD2.Reg)&^(0x10000000)|value<<28)
}
func (o *SYSMPU_Type) GetRGD5_WORD2_M6WE() uint32 {
	return (volatile.LoadUint32(&o.RGD5_WORD2.Reg) & 0x10000000) >> 28
}
func (o *SYSMPU_Type) SetRGD5_WORD2_M6RE(value uint32) {
	volatile.StoreUint32(&o.RGD5_WORD2.Reg, volatile.LoadUint32(&o.RGD5_WORD2.Reg)&^(0x20000000)|value<<29)
}
func (o *SYSMPU_Type) GetRGD5_WORD2_M6RE() uint32 {
	return (volatile.LoadUint32(&o.RGD5_WORD2.Reg) & 0x20000000) >> 29
}
func (o *SYSMPU_Type) SetRGD5_WORD2_M7WE(value uint32) {
	volatile.StoreUint32(&o.RGD5_WORD2.Reg, volatile.LoadUint32(&o.RGD5_WORD2.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSMPU_Type) GetRGD5_WORD2_M7WE() uint32 {
	return (volatile.LoadUint32(&o.RGD5_WORD2.Reg) & 0x40000000) >> 30
}
func (o *SYSMPU_Type) SetRGD5_WORD2_M7RE(value uint32) {
	volatile.StoreUint32(&o.RGD5_WORD2.Reg, volatile.LoadUint32(&o.RGD5_WORD2.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSMPU_Type) GetRGD5_WORD2_M7RE() uint32 {
	return (volatile.LoadUint32(&o.RGD5_WORD2.Reg) & 0x80000000) >> 31
}

// SYSMPU.RGD5_WORD3: Region Descriptor n, Word 3
func (o *SYSMPU_Type) SetRGD5_WORD3_VLD(value uint32) {
	volatile.StoreUint32(&o.RGD5_WORD3.Reg, volatile.LoadUint32(&o.RGD5_WORD3.Reg)&^(0x1)|value)
}
func (o *SYSMPU_Type) GetRGD5_WORD3_VLD() uint32 {
	return volatile.LoadUint32(&o.RGD5_WORD3.Reg) & 0x1
}
func (o *SYSMPU_Type) SetRGD5_WORD3_PIDMASK(value uint32) {
	volatile.StoreUint32(&o.RGD5_WORD3.Reg, volatile.LoadUint32(&o.RGD5_WORD3.Reg)&^(0xff0000)|value<<16)
}
func (o *SYSMPU_Type) GetRGD5_WORD3_PIDMASK() uint32 {
	return (volatile.LoadUint32(&o.RGD5_WORD3.Reg) & 0xff0000) >> 16
}
func (o *SYSMPU_Type) SetRGD5_WORD3_PID(value uint32) {
	volatile.StoreUint32(&o.RGD5_WORD3.Reg, volatile.LoadUint32(&o.RGD5_WORD3.Reg)&^(0xff000000)|value<<24)
}
func (o *SYSMPU_Type) GetRGD5_WORD3_PID() uint32 {
	return (volatile.LoadUint32(&o.RGD5_WORD3.Reg) & 0xff000000) >> 24
}

// SYSMPU.RGD6_WORD0: Region Descriptor n, Word 0
func (o *SYSMPU_Type) SetRGD6_WORD0_SRTADDR(value uint32) {
	volatile.StoreUint32(&o.RGD6_WORD0.Reg, volatile.LoadUint32(&o.RGD6_WORD0.Reg)&^(0xffffffe0)|value<<5)
}
func (o *SYSMPU_Type) GetRGD6_WORD0_SRTADDR() uint32 {
	return (volatile.LoadUint32(&o.RGD6_WORD0.Reg) & 0xffffffe0) >> 5
}

// SYSMPU.RGD6_WORD1: Region Descriptor n, Word 1
func (o *SYSMPU_Type) SetRGD6_WORD1_ENDADDR(value uint32) {
	volatile.StoreUint32(&o.RGD6_WORD1.Reg, volatile.LoadUint32(&o.RGD6_WORD1.Reg)&^(0xffffffe0)|value<<5)
}
func (o *SYSMPU_Type) GetRGD6_WORD1_ENDADDR() uint32 {
	return (volatile.LoadUint32(&o.RGD6_WORD1.Reg) & 0xffffffe0) >> 5
}

// SYSMPU.RGD6_WORD2: Region Descriptor n, Word 2
func (o *SYSMPU_Type) SetRGD6_WORD2_M0UM(value uint32) {
	volatile.StoreUint32(&o.RGD6_WORD2.Reg, volatile.LoadUint32(&o.RGD6_WORD2.Reg)&^(0x7)|value)
}
func (o *SYSMPU_Type) GetRGD6_WORD2_M0UM() uint32 {
	return volatile.LoadUint32(&o.RGD6_WORD2.Reg) & 0x7
}
func (o *SYSMPU_Type) SetRGD6_WORD2_M0SM(value uint32) {
	volatile.StoreUint32(&o.RGD6_WORD2.Reg, volatile.LoadUint32(&o.RGD6_WORD2.Reg)&^(0x18)|value<<3)
}
func (o *SYSMPU_Type) GetRGD6_WORD2_M0SM() uint32 {
	return (volatile.LoadUint32(&o.RGD6_WORD2.Reg) & 0x18) >> 3
}
func (o *SYSMPU_Type) SetRGD6_WORD2_M0PE(value uint32) {
	volatile.StoreUint32(&o.RGD6_WORD2.Reg, volatile.LoadUint32(&o.RGD6_WORD2.Reg)&^(0x20)|value<<5)
}
func (o *SYSMPU_Type) GetRGD6_WORD2_M0PE() uint32 {
	return (volatile.LoadUint32(&o.RGD6_WORD2.Reg) & 0x20) >> 5
}
func (o *SYSMPU_Type) SetRGD6_WORD2_M1UM(value uint32) {
	volatile.StoreUint32(&o.RGD6_WORD2.Reg, volatile.LoadUint32(&o.RGD6_WORD2.Reg)&^(0x1c0)|value<<6)
}
func (o *SYSMPU_Type) GetRGD6_WORD2_M1UM() uint32 {
	return (volatile.LoadUint32(&o.RGD6_WORD2.Reg) & 0x1c0) >> 6
}
func (o *SYSMPU_Type) SetRGD6_WORD2_M1SM(value uint32) {
	volatile.StoreUint32(&o.RGD6_WORD2.Reg, volatile.LoadUint32(&o.RGD6_WORD2.Reg)&^(0x600)|value<<9)
}
func (o *SYSMPU_Type) GetRGD6_WORD2_M1SM() uint32 {
	return (volatile.LoadUint32(&o.RGD6_WORD2.Reg) & 0x600) >> 9
}
func (o *SYSMPU_Type) SetRGD6_WORD2_M1PE(value uint32) {
	volatile.StoreUint32(&o.RGD6_WORD2.Reg, volatile.LoadUint32(&o.RGD6_WORD2.Reg)&^(0x800)|value<<11)
}
func (o *SYSMPU_Type) GetRGD6_WORD2_M1PE() uint32 {
	return (volatile.LoadUint32(&o.RGD6_WORD2.Reg) & 0x800) >> 11
}
func (o *SYSMPU_Type) SetRGD6_WORD2_M2UM(value uint32) {
	volatile.StoreUint32(&o.RGD6_WORD2.Reg, volatile.LoadUint32(&o.RGD6_WORD2.Reg)&^(0x7000)|value<<12)
}
func (o *SYSMPU_Type) GetRGD6_WORD2_M2UM() uint32 {
	return (volatile.LoadUint32(&o.RGD6_WORD2.Reg) & 0x7000) >> 12
}
func (o *SYSMPU_Type) SetRGD6_WORD2_M2SM(value uint32) {
	volatile.StoreUint32(&o.RGD6_WORD2.Reg, volatile.LoadUint32(&o.RGD6_WORD2.Reg)&^(0x18000)|value<<15)
}
func (o *SYSMPU_Type) GetRGD6_WORD2_M2SM() uint32 {
	return (volatile.LoadUint32(&o.RGD6_WORD2.Reg) & 0x18000) >> 15
}
func (o *SYSMPU_Type) SetRGD6_WORD2_M2PE(value uint32) {
	volatile.StoreUint32(&o.RGD6_WORD2.Reg, volatile.LoadUint32(&o.RGD6_WORD2.Reg)&^(0x20000)|value<<17)
}
func (o *SYSMPU_Type) GetRGD6_WORD2_M2PE() uint32 {
	return (volatile.LoadUint32(&o.RGD6_WORD2.Reg) & 0x20000) >> 17
}
func (o *SYSMPU_Type) SetRGD6_WORD2_M3UM(value uint32) {
	volatile.StoreUint32(&o.RGD6_WORD2.Reg, volatile.LoadUint32(&o.RGD6_WORD2.Reg)&^(0x1c0000)|value<<18)
}
func (o *SYSMPU_Type) GetRGD6_WORD2_M3UM() uint32 {
	return (volatile.LoadUint32(&o.RGD6_WORD2.Reg) & 0x1c0000) >> 18
}
func (o *SYSMPU_Type) SetRGD6_WORD2_M3SM(value uint32) {
	volatile.StoreUint32(&o.RGD6_WORD2.Reg, volatile.LoadUint32(&o.RGD6_WORD2.Reg)&^(0x600000)|value<<21)
}
func (o *SYSMPU_Type) GetRGD6_WORD2_M3SM() uint32 {
	return (volatile.LoadUint32(&o.RGD6_WORD2.Reg) & 0x600000) >> 21
}
func (o *SYSMPU_Type) SetRGD6_WORD2_M3PE(value uint32) {
	volatile.StoreUint32(&o.RGD6_WORD2.Reg, volatile.LoadUint32(&o.RGD6_WORD2.Reg)&^(0x800000)|value<<23)
}
func (o *SYSMPU_Type) GetRGD6_WORD2_M3PE() uint32 {
	return (volatile.LoadUint32(&o.RGD6_WORD2.Reg) & 0x800000) >> 23
}
func (o *SYSMPU_Type) SetRGD6_WORD2_M4WE(value uint32) {
	volatile.StoreUint32(&o.RGD6_WORD2.Reg, volatile.LoadUint32(&o.RGD6_WORD2.Reg)&^(0x1000000)|value<<24)
}
func (o *SYSMPU_Type) GetRGD6_WORD2_M4WE() uint32 {
	return (volatile.LoadUint32(&o.RGD6_WORD2.Reg) & 0x1000000) >> 24
}
func (o *SYSMPU_Type) SetRGD6_WORD2_M4RE(value uint32) {
	volatile.StoreUint32(&o.RGD6_WORD2.Reg, volatile.LoadUint32(&o.RGD6_WORD2.Reg)&^(0x2000000)|value<<25)
}
func (o *SYSMPU_Type) GetRGD6_WORD2_M4RE() uint32 {
	return (volatile.LoadUint32(&o.RGD6_WORD2.Reg) & 0x2000000) >> 25
}
func (o *SYSMPU_Type) SetRGD6_WORD2_M5WE(value uint32) {
	volatile.StoreUint32(&o.RGD6_WORD2.Reg, volatile.LoadUint32(&o.RGD6_WORD2.Reg)&^(0x4000000)|value<<26)
}
func (o *SYSMPU_Type) GetRGD6_WORD2_M5WE() uint32 {
	return (volatile.LoadUint32(&o.RGD6_WORD2.Reg) & 0x4000000) >> 26
}
func (o *SYSMPU_Type) SetRGD6_WORD2_M5RE(value uint32) {
	volatile.StoreUint32(&o.RGD6_WORD2.Reg, volatile.LoadUint32(&o.RGD6_WORD2.Reg)&^(0x8000000)|value<<27)
}
func (o *SYSMPU_Type) GetRGD6_WORD2_M5RE() uint32 {
	return (volatile.LoadUint32(&o.RGD6_WORD2.Reg) & 0x8000000) >> 27
}
func (o *SYSMPU_Type) SetRGD6_WORD2_M6WE(value uint32) {
	volatile.StoreUint32(&o.RGD6_WORD2.Reg, volatile.LoadUint32(&o.RGD6_WORD2.Reg)&^(0x10000000)|value<<28)
}
func (o *SYSMPU_Type) GetRGD6_WORD2_M6WE() uint32 {
	return (volatile.LoadUint32(&o.RGD6_WORD2.Reg) & 0x10000000) >> 28
}
func (o *SYSMPU_Type) SetRGD6_WORD2_M6RE(value uint32) {
	volatile.StoreUint32(&o.RGD6_WORD2.Reg, volatile.LoadUint32(&o.RGD6_WORD2.Reg)&^(0x20000000)|value<<29)
}
func (o *SYSMPU_Type) GetRGD6_WORD2_M6RE() uint32 {
	return (volatile.LoadUint32(&o.RGD6_WORD2.Reg) & 0x20000000) >> 29
}
func (o *SYSMPU_Type) SetRGD6_WORD2_M7WE(value uint32) {
	volatile.StoreUint32(&o.RGD6_WORD2.Reg, volatile.LoadUint32(&o.RGD6_WORD2.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSMPU_Type) GetRGD6_WORD2_M7WE() uint32 {
	return (volatile.LoadUint32(&o.RGD6_WORD2.Reg) & 0x40000000) >> 30
}
func (o *SYSMPU_Type) SetRGD6_WORD2_M7RE(value uint32) {
	volatile.StoreUint32(&o.RGD6_WORD2.Reg, volatile.LoadUint32(&o.RGD6_WORD2.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSMPU_Type) GetRGD6_WORD2_M7RE() uint32 {
	return (volatile.LoadUint32(&o.RGD6_WORD2.Reg) & 0x80000000) >> 31
}

// SYSMPU.RGD6_WORD3: Region Descriptor n, Word 3
func (o *SYSMPU_Type) SetRGD6_WORD3_VLD(value uint32) {
	volatile.StoreUint32(&o.RGD6_WORD3.Reg, volatile.LoadUint32(&o.RGD6_WORD3.Reg)&^(0x1)|value)
}
func (o *SYSMPU_Type) GetRGD6_WORD3_VLD() uint32 {
	return volatile.LoadUint32(&o.RGD6_WORD3.Reg) & 0x1
}
func (o *SYSMPU_Type) SetRGD6_WORD3_PIDMASK(value uint32) {
	volatile.StoreUint32(&o.RGD6_WORD3.Reg, volatile.LoadUint32(&o.RGD6_WORD3.Reg)&^(0xff0000)|value<<16)
}
func (o *SYSMPU_Type) GetRGD6_WORD3_PIDMASK() uint32 {
	return (volatile.LoadUint32(&o.RGD6_WORD3.Reg) & 0xff0000) >> 16
}
func (o *SYSMPU_Type) SetRGD6_WORD3_PID(value uint32) {
	volatile.StoreUint32(&o.RGD6_WORD3.Reg, volatile.LoadUint32(&o.RGD6_WORD3.Reg)&^(0xff000000)|value<<24)
}
func (o *SYSMPU_Type) GetRGD6_WORD3_PID() uint32 {
	return (volatile.LoadUint32(&o.RGD6_WORD3.Reg) & 0xff000000) >> 24
}

// SYSMPU.RGD7_WORD0: Region Descriptor n, Word 0
func (o *SYSMPU_Type) SetRGD7_WORD0_SRTADDR(value uint32) {
	volatile.StoreUint32(&o.RGD7_WORD0.Reg, volatile.LoadUint32(&o.RGD7_WORD0.Reg)&^(0xffffffe0)|value<<5)
}
func (o *SYSMPU_Type) GetRGD7_WORD0_SRTADDR() uint32 {
	return (volatile.LoadUint32(&o.RGD7_WORD0.Reg) & 0xffffffe0) >> 5
}

// SYSMPU.RGD7_WORD1: Region Descriptor n, Word 1
func (o *SYSMPU_Type) SetRGD7_WORD1_ENDADDR(value uint32) {
	volatile.StoreUint32(&o.RGD7_WORD1.Reg, volatile.LoadUint32(&o.RGD7_WORD1.Reg)&^(0xffffffe0)|value<<5)
}
func (o *SYSMPU_Type) GetRGD7_WORD1_ENDADDR() uint32 {
	return (volatile.LoadUint32(&o.RGD7_WORD1.Reg) & 0xffffffe0) >> 5
}

// SYSMPU.RGD7_WORD2: Region Descriptor n, Word 2
func (o *SYSMPU_Type) SetRGD7_WORD2_M0UM(value uint32) {
	volatile.StoreUint32(&o.RGD7_WORD2.Reg, volatile.LoadUint32(&o.RGD7_WORD2.Reg)&^(0x7)|value)
}
func (o *SYSMPU_Type) GetRGD7_WORD2_M0UM() uint32 {
	return volatile.LoadUint32(&o.RGD7_WORD2.Reg) & 0x7
}
func (o *SYSMPU_Type) SetRGD7_WORD2_M0SM(value uint32) {
	volatile.StoreUint32(&o.RGD7_WORD2.Reg, volatile.LoadUint32(&o.RGD7_WORD2.Reg)&^(0x18)|value<<3)
}
func (o *SYSMPU_Type) GetRGD7_WORD2_M0SM() uint32 {
	return (volatile.LoadUint32(&o.RGD7_WORD2.Reg) & 0x18) >> 3
}
func (o *SYSMPU_Type) SetRGD7_WORD2_M0PE(value uint32) {
	volatile.StoreUint32(&o.RGD7_WORD2.Reg, volatile.LoadUint32(&o.RGD7_WORD2.Reg)&^(0x20)|value<<5)
}
func (o *SYSMPU_Type) GetRGD7_WORD2_M0PE() uint32 {
	return (volatile.LoadUint32(&o.RGD7_WORD2.Reg) & 0x20) >> 5
}
func (o *SYSMPU_Type) SetRGD7_WORD2_M1UM(value uint32) {
	volatile.StoreUint32(&o.RGD7_WORD2.Reg, volatile.LoadUint32(&o.RGD7_WORD2.Reg)&^(0x1c0)|value<<6)
}
func (o *SYSMPU_Type) GetRGD7_WORD2_M1UM() uint32 {
	return (volatile.LoadUint32(&o.RGD7_WORD2.Reg) & 0x1c0) >> 6
}
func (o *SYSMPU_Type) SetRGD7_WORD2_M1SM(value uint32) {
	volatile.StoreUint32(&o.RGD7_WORD2.Reg, volatile.LoadUint32(&o.RGD7_WORD2.Reg)&^(0x600)|value<<9)
}
func (o *SYSMPU_Type) GetRGD7_WORD2_M1SM() uint32 {
	return (volatile.LoadUint32(&o.RGD7_WORD2.Reg) & 0x600) >> 9
}
func (o *SYSMPU_Type) SetRGD7_WORD2_M1PE(value uint32) {
	volatile.StoreUint32(&o.RGD7_WORD2.Reg, volatile.LoadUint32(&o.RGD7_WORD2.Reg)&^(0x800)|value<<11)
}
func (o *SYSMPU_Type) GetRGD7_WORD2_M1PE() uint32 {
	return (volatile.LoadUint32(&o.RGD7_WORD2.Reg) & 0x800) >> 11
}
func (o *SYSMPU_Type) SetRGD7_WORD2_M2UM(value uint32) {
	volatile.StoreUint32(&o.RGD7_WORD2.Reg, volatile.LoadUint32(&o.RGD7_WORD2.Reg)&^(0x7000)|value<<12)
}
func (o *SYSMPU_Type) GetRGD7_WORD2_M2UM() uint32 {
	return (volatile.LoadUint32(&o.RGD7_WORD2.Reg) & 0x7000) >> 12
}
func (o *SYSMPU_Type) SetRGD7_WORD2_M2SM(value uint32) {
	volatile.StoreUint32(&o.RGD7_WORD2.Reg, volatile.LoadUint32(&o.RGD7_WORD2.Reg)&^(0x18000)|value<<15)
}
func (o *SYSMPU_Type) GetRGD7_WORD2_M2SM() uint32 {
	return (volatile.LoadUint32(&o.RGD7_WORD2.Reg) & 0x18000) >> 15
}
func (o *SYSMPU_Type) SetRGD7_WORD2_M2PE(value uint32) {
	volatile.StoreUint32(&o.RGD7_WORD2.Reg, volatile.LoadUint32(&o.RGD7_WORD2.Reg)&^(0x20000)|value<<17)
}
func (o *SYSMPU_Type) GetRGD7_WORD2_M2PE() uint32 {
	return (volatile.LoadUint32(&o.RGD7_WORD2.Reg) & 0x20000) >> 17
}
func (o *SYSMPU_Type) SetRGD7_WORD2_M3UM(value uint32) {
	volatile.StoreUint32(&o.RGD7_WORD2.Reg, volatile.LoadUint32(&o.RGD7_WORD2.Reg)&^(0x1c0000)|value<<18)
}
func (o *SYSMPU_Type) GetRGD7_WORD2_M3UM() uint32 {
	return (volatile.LoadUint32(&o.RGD7_WORD2.Reg) & 0x1c0000) >> 18
}
func (o *SYSMPU_Type) SetRGD7_WORD2_M3SM(value uint32) {
	volatile.StoreUint32(&o.RGD7_WORD2.Reg, volatile.LoadUint32(&o.RGD7_WORD2.Reg)&^(0x600000)|value<<21)
}
func (o *SYSMPU_Type) GetRGD7_WORD2_M3SM() uint32 {
	return (volatile.LoadUint32(&o.RGD7_WORD2.Reg) & 0x600000) >> 21
}
func (o *SYSMPU_Type) SetRGD7_WORD2_M3PE(value uint32) {
	volatile.StoreUint32(&o.RGD7_WORD2.Reg, volatile.LoadUint32(&o.RGD7_WORD2.Reg)&^(0x800000)|value<<23)
}
func (o *SYSMPU_Type) GetRGD7_WORD2_M3PE() uint32 {
	return (volatile.LoadUint32(&o.RGD7_WORD2.Reg) & 0x800000) >> 23
}
func (o *SYSMPU_Type) SetRGD7_WORD2_M4WE(value uint32) {
	volatile.StoreUint32(&o.RGD7_WORD2.Reg, volatile.LoadUint32(&o.RGD7_WORD2.Reg)&^(0x1000000)|value<<24)
}
func (o *SYSMPU_Type) GetRGD7_WORD2_M4WE() uint32 {
	return (volatile.LoadUint32(&o.RGD7_WORD2.Reg) & 0x1000000) >> 24
}
func (o *SYSMPU_Type) SetRGD7_WORD2_M4RE(value uint32) {
	volatile.StoreUint32(&o.RGD7_WORD2.Reg, volatile.LoadUint32(&o.RGD7_WORD2.Reg)&^(0x2000000)|value<<25)
}
func (o *SYSMPU_Type) GetRGD7_WORD2_M4RE() uint32 {
	return (volatile.LoadUint32(&o.RGD7_WORD2.Reg) & 0x2000000) >> 25
}
func (o *SYSMPU_Type) SetRGD7_WORD2_M5WE(value uint32) {
	volatile.StoreUint32(&o.RGD7_WORD2.Reg, volatile.LoadUint32(&o.RGD7_WORD2.Reg)&^(0x4000000)|value<<26)
}
func (o *SYSMPU_Type) GetRGD7_WORD2_M5WE() uint32 {
	return (volatile.LoadUint32(&o.RGD7_WORD2.Reg) & 0x4000000) >> 26
}
func (o *SYSMPU_Type) SetRGD7_WORD2_M5RE(value uint32) {
	volatile.StoreUint32(&o.RGD7_WORD2.Reg, volatile.LoadUint32(&o.RGD7_WORD2.Reg)&^(0x8000000)|value<<27)
}
func (o *SYSMPU_Type) GetRGD7_WORD2_M5RE() uint32 {
	return (volatile.LoadUint32(&o.RGD7_WORD2.Reg) & 0x8000000) >> 27
}
func (o *SYSMPU_Type) SetRGD7_WORD2_M6WE(value uint32) {
	volatile.StoreUint32(&o.RGD7_WORD2.Reg, volatile.LoadUint32(&o.RGD7_WORD2.Reg)&^(0x10000000)|value<<28)
}
func (o *SYSMPU_Type) GetRGD7_WORD2_M6WE() uint32 {
	return (volatile.LoadUint32(&o.RGD7_WORD2.Reg) & 0x10000000) >> 28
}
func (o *SYSMPU_Type) SetRGD7_WORD2_M6RE(value uint32) {
	volatile.StoreUint32(&o.RGD7_WORD2.Reg, volatile.LoadUint32(&o.RGD7_WORD2.Reg)&^(0x20000000)|value<<29)
}
func (o *SYSMPU_Type) GetRGD7_WORD2_M6RE() uint32 {
	return (volatile.LoadUint32(&o.RGD7_WORD2.Reg) & 0x20000000) >> 29
}
func (o *SYSMPU_Type) SetRGD7_WORD2_M7WE(value uint32) {
	volatile.StoreUint32(&o.RGD7_WORD2.Reg, volatile.LoadUint32(&o.RGD7_WORD2.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSMPU_Type) GetRGD7_WORD2_M7WE() uint32 {
	return (volatile.LoadUint32(&o.RGD7_WORD2.Reg) & 0x40000000) >> 30
}
func (o *SYSMPU_Type) SetRGD7_WORD2_M7RE(value uint32) {
	volatile.StoreUint32(&o.RGD7_WORD2.Reg, volatile.LoadUint32(&o.RGD7_WORD2.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSMPU_Type) GetRGD7_WORD2_M7RE() uint32 {
	return (volatile.LoadUint32(&o.RGD7_WORD2.Reg) & 0x80000000) >> 31
}

// SYSMPU.RGD7_WORD3: Region Descriptor n, Word 3
func (o *SYSMPU_Type) SetRGD7_WORD3_VLD(value uint32) {
	volatile.StoreUint32(&o.RGD7_WORD3.Reg, volatile.LoadUint32(&o.RGD7_WORD3.Reg)&^(0x1)|value)
}
func (o *SYSMPU_Type) GetRGD7_WORD3_VLD() uint32 {
	return volatile.LoadUint32(&o.RGD7_WORD3.Reg) & 0x1
}
func (o *SYSMPU_Type) SetRGD7_WORD3_PIDMASK(value uint32) {
	volatile.StoreUint32(&o.RGD7_WORD3.Reg, volatile.LoadUint32(&o.RGD7_WORD3.Reg)&^(0xff0000)|value<<16)
}
func (o *SYSMPU_Type) GetRGD7_WORD3_PIDMASK() uint32 {
	return (volatile.LoadUint32(&o.RGD7_WORD3.Reg) & 0xff0000) >> 16
}
func (o *SYSMPU_Type) SetRGD7_WORD3_PID(value uint32) {
	volatile.StoreUint32(&o.RGD7_WORD3.Reg, volatile.LoadUint32(&o.RGD7_WORD3.Reg)&^(0xff000000)|value<<24)
}
func (o *SYSMPU_Type) GetRGD7_WORD3_PID() uint32 {
	return (volatile.LoadUint32(&o.RGD7_WORD3.Reg) & 0xff000000) >> 24
}

// SYSMPU.RGD8_WORD0: Region Descriptor n, Word 0
func (o *SYSMPU_Type) SetRGD8_WORD0_SRTADDR(value uint32) {
	volatile.StoreUint32(&o.RGD8_WORD0.Reg, volatile.LoadUint32(&o.RGD8_WORD0.Reg)&^(0xffffffe0)|value<<5)
}
func (o *SYSMPU_Type) GetRGD8_WORD0_SRTADDR() uint32 {
	return (volatile.LoadUint32(&o.RGD8_WORD0.Reg) & 0xffffffe0) >> 5
}

// SYSMPU.RGD8_WORD1: Region Descriptor n, Word 1
func (o *SYSMPU_Type) SetRGD8_WORD1_ENDADDR(value uint32) {
	volatile.StoreUint32(&o.RGD8_WORD1.Reg, volatile.LoadUint32(&o.RGD8_WORD1.Reg)&^(0xffffffe0)|value<<5)
}
func (o *SYSMPU_Type) GetRGD8_WORD1_ENDADDR() uint32 {
	return (volatile.LoadUint32(&o.RGD8_WORD1.Reg) & 0xffffffe0) >> 5
}

// SYSMPU.RGD8_WORD2: Region Descriptor n, Word 2
func (o *SYSMPU_Type) SetRGD8_WORD2_M0UM(value uint32) {
	volatile.StoreUint32(&o.RGD8_WORD2.Reg, volatile.LoadUint32(&o.RGD8_WORD2.Reg)&^(0x7)|value)
}
func (o *SYSMPU_Type) GetRGD8_WORD2_M0UM() uint32 {
	return volatile.LoadUint32(&o.RGD8_WORD2.Reg) & 0x7
}
func (o *SYSMPU_Type) SetRGD8_WORD2_M0SM(value uint32) {
	volatile.StoreUint32(&o.RGD8_WORD2.Reg, volatile.LoadUint32(&o.RGD8_WORD2.Reg)&^(0x18)|value<<3)
}
func (o *SYSMPU_Type) GetRGD8_WORD2_M0SM() uint32 {
	return (volatile.LoadUint32(&o.RGD8_WORD2.Reg) & 0x18) >> 3
}
func (o *SYSMPU_Type) SetRGD8_WORD2_M0PE(value uint32) {
	volatile.StoreUint32(&o.RGD8_WORD2.Reg, volatile.LoadUint32(&o.RGD8_WORD2.Reg)&^(0x20)|value<<5)
}
func (o *SYSMPU_Type) GetRGD8_WORD2_M0PE() uint32 {
	return (volatile.LoadUint32(&o.RGD8_WORD2.Reg) & 0x20) >> 5
}
func (o *SYSMPU_Type) SetRGD8_WORD2_M1UM(value uint32) {
	volatile.StoreUint32(&o.RGD8_WORD2.Reg, volatile.LoadUint32(&o.RGD8_WORD2.Reg)&^(0x1c0)|value<<6)
}
func (o *SYSMPU_Type) GetRGD8_WORD2_M1UM() uint32 {
	return (volatile.LoadUint32(&o.RGD8_WORD2.Reg) & 0x1c0) >> 6
}
func (o *SYSMPU_Type) SetRGD8_WORD2_M1SM(value uint32) {
	volatile.StoreUint32(&o.RGD8_WORD2.Reg, volatile.LoadUint32(&o.RGD8_WORD2.Reg)&^(0x600)|value<<9)
}
func (o *SYSMPU_Type) GetRGD8_WORD2_M1SM() uint32 {
	return (volatile.LoadUint32(&o.RGD8_WORD2.Reg) & 0x600) >> 9
}
func (o *SYSMPU_Type) SetRGD8_WORD2_M1PE(value uint32) {
	volatile.StoreUint32(&o.RGD8_WORD2.Reg, volatile.LoadUint32(&o.RGD8_WORD2.Reg)&^(0x800)|value<<11)
}
func (o *SYSMPU_Type) GetRGD8_WORD2_M1PE() uint32 {
	return (volatile.LoadUint32(&o.RGD8_WORD2.Reg) & 0x800) >> 11
}
func (o *SYSMPU_Type) SetRGD8_WORD2_M2UM(value uint32) {
	volatile.StoreUint32(&o.RGD8_WORD2.Reg, volatile.LoadUint32(&o.RGD8_WORD2.Reg)&^(0x7000)|value<<12)
}
func (o *SYSMPU_Type) GetRGD8_WORD2_M2UM() uint32 {
	return (volatile.LoadUint32(&o.RGD8_WORD2.Reg) & 0x7000) >> 12
}
func (o *SYSMPU_Type) SetRGD8_WORD2_M2SM(value uint32) {
	volatile.StoreUint32(&o.RGD8_WORD2.Reg, volatile.LoadUint32(&o.RGD8_WORD2.Reg)&^(0x18000)|value<<15)
}
func (o *SYSMPU_Type) GetRGD8_WORD2_M2SM() uint32 {
	return (volatile.LoadUint32(&o.RGD8_WORD2.Reg) & 0x18000) >> 15
}
func (o *SYSMPU_Type) SetRGD8_WORD2_M2PE(value uint32) {
	volatile.StoreUint32(&o.RGD8_WORD2.Reg, volatile.LoadUint32(&o.RGD8_WORD2.Reg)&^(0x20000)|value<<17)
}
func (o *SYSMPU_Type) GetRGD8_WORD2_M2PE() uint32 {
	return (volatile.LoadUint32(&o.RGD8_WORD2.Reg) & 0x20000) >> 17
}
func (o *SYSMPU_Type) SetRGD8_WORD2_M3UM(value uint32) {
	volatile.StoreUint32(&o.RGD8_WORD2.Reg, volatile.LoadUint32(&o.RGD8_WORD2.Reg)&^(0x1c0000)|value<<18)
}
func (o *SYSMPU_Type) GetRGD8_WORD2_M3UM() uint32 {
	return (volatile.LoadUint32(&o.RGD8_WORD2.Reg) & 0x1c0000) >> 18
}
func (o *SYSMPU_Type) SetRGD8_WORD2_M3SM(value uint32) {
	volatile.StoreUint32(&o.RGD8_WORD2.Reg, volatile.LoadUint32(&o.RGD8_WORD2.Reg)&^(0x600000)|value<<21)
}
func (o *SYSMPU_Type) GetRGD8_WORD2_M3SM() uint32 {
	return (volatile.LoadUint32(&o.RGD8_WORD2.Reg) & 0x600000) >> 21
}
func (o *SYSMPU_Type) SetRGD8_WORD2_M3PE(value uint32) {
	volatile.StoreUint32(&o.RGD8_WORD2.Reg, volatile.LoadUint32(&o.RGD8_WORD2.Reg)&^(0x800000)|value<<23)
}
func (o *SYSMPU_Type) GetRGD8_WORD2_M3PE() uint32 {
	return (volatile.LoadUint32(&o.RGD8_WORD2.Reg) & 0x800000) >> 23
}
func (o *SYSMPU_Type) SetRGD8_WORD2_M4WE(value uint32) {
	volatile.StoreUint32(&o.RGD8_WORD2.Reg, volatile.LoadUint32(&o.RGD8_WORD2.Reg)&^(0x1000000)|value<<24)
}
func (o *SYSMPU_Type) GetRGD8_WORD2_M4WE() uint32 {
	return (volatile.LoadUint32(&o.RGD8_WORD2.Reg) & 0x1000000) >> 24
}
func (o *SYSMPU_Type) SetRGD8_WORD2_M4RE(value uint32) {
	volatile.StoreUint32(&o.RGD8_WORD2.Reg, volatile.LoadUint32(&o.RGD8_WORD2.Reg)&^(0x2000000)|value<<25)
}
func (o *SYSMPU_Type) GetRGD8_WORD2_M4RE() uint32 {
	return (volatile.LoadUint32(&o.RGD8_WORD2.Reg) & 0x2000000) >> 25
}
func (o *SYSMPU_Type) SetRGD8_WORD2_M5WE(value uint32) {
	volatile.StoreUint32(&o.RGD8_WORD2.Reg, volatile.LoadUint32(&o.RGD8_WORD2.Reg)&^(0x4000000)|value<<26)
}
func (o *SYSMPU_Type) GetRGD8_WORD2_M5WE() uint32 {
	return (volatile.LoadUint32(&o.RGD8_WORD2.Reg) & 0x4000000) >> 26
}
func (o *SYSMPU_Type) SetRGD8_WORD2_M5RE(value uint32) {
	volatile.StoreUint32(&o.RGD8_WORD2.Reg, volatile.LoadUint32(&o.RGD8_WORD2.Reg)&^(0x8000000)|value<<27)
}
func (o *SYSMPU_Type) GetRGD8_WORD2_M5RE() uint32 {
	return (volatile.LoadUint32(&o.RGD8_WORD2.Reg) & 0x8000000) >> 27
}
func (o *SYSMPU_Type) SetRGD8_WORD2_M6WE(value uint32) {
	volatile.StoreUint32(&o.RGD8_WORD2.Reg, volatile.LoadUint32(&o.RGD8_WORD2.Reg)&^(0x10000000)|value<<28)
}
func (o *SYSMPU_Type) GetRGD8_WORD2_M6WE() uint32 {
	return (volatile.LoadUint32(&o.RGD8_WORD2.Reg) & 0x10000000) >> 28
}
func (o *SYSMPU_Type) SetRGD8_WORD2_M6RE(value uint32) {
	volatile.StoreUint32(&o.RGD8_WORD2.Reg, volatile.LoadUint32(&o.RGD8_WORD2.Reg)&^(0x20000000)|value<<29)
}
func (o *SYSMPU_Type) GetRGD8_WORD2_M6RE() uint32 {
	return (volatile.LoadUint32(&o.RGD8_WORD2.Reg) & 0x20000000) >> 29
}
func (o *SYSMPU_Type) SetRGD8_WORD2_M7WE(value uint32) {
	volatile.StoreUint32(&o.RGD8_WORD2.Reg, volatile.LoadUint32(&o.RGD8_WORD2.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSMPU_Type) GetRGD8_WORD2_M7WE() uint32 {
	return (volatile.LoadUint32(&o.RGD8_WORD2.Reg) & 0x40000000) >> 30
}
func (o *SYSMPU_Type) SetRGD8_WORD2_M7RE(value uint32) {
	volatile.StoreUint32(&o.RGD8_WORD2.Reg, volatile.LoadUint32(&o.RGD8_WORD2.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSMPU_Type) GetRGD8_WORD2_M7RE() uint32 {
	return (volatile.LoadUint32(&o.RGD8_WORD2.Reg) & 0x80000000) >> 31
}

// SYSMPU.RGD8_WORD3: Region Descriptor n, Word 3
func (o *SYSMPU_Type) SetRGD8_WORD3_VLD(value uint32) {
	volatile.StoreUint32(&o.RGD8_WORD3.Reg, volatile.LoadUint32(&o.RGD8_WORD3.Reg)&^(0x1)|value)
}
func (o *SYSMPU_Type) GetRGD8_WORD3_VLD() uint32 {
	return volatile.LoadUint32(&o.RGD8_WORD3.Reg) & 0x1
}
func (o *SYSMPU_Type) SetRGD8_WORD3_PIDMASK(value uint32) {
	volatile.StoreUint32(&o.RGD8_WORD3.Reg, volatile.LoadUint32(&o.RGD8_WORD3.Reg)&^(0xff0000)|value<<16)
}
func (o *SYSMPU_Type) GetRGD8_WORD3_PIDMASK() uint32 {
	return (volatile.LoadUint32(&o.RGD8_WORD3.Reg) & 0xff0000) >> 16
}
func (o *SYSMPU_Type) SetRGD8_WORD3_PID(value uint32) {
	volatile.StoreUint32(&o.RGD8_WORD3.Reg, volatile.LoadUint32(&o.RGD8_WORD3.Reg)&^(0xff000000)|value<<24)
}
func (o *SYSMPU_Type) GetRGD8_WORD3_PID() uint32 {
	return (volatile.LoadUint32(&o.RGD8_WORD3.Reg) & 0xff000000) >> 24
}

// SYSMPU.RGD9_WORD0: Region Descriptor n, Word 0
func (o *SYSMPU_Type) SetRGD9_WORD0_SRTADDR(value uint32) {
	volatile.StoreUint32(&o.RGD9_WORD0.Reg, volatile.LoadUint32(&o.RGD9_WORD0.Reg)&^(0xffffffe0)|value<<5)
}
func (o *SYSMPU_Type) GetRGD9_WORD0_SRTADDR() uint32 {
	return (volatile.LoadUint32(&o.RGD9_WORD0.Reg) & 0xffffffe0) >> 5
}

// SYSMPU.RGD9_WORD1: Region Descriptor n, Word 1
func (o *SYSMPU_Type) SetRGD9_WORD1_ENDADDR(value uint32) {
	volatile.StoreUint32(&o.RGD9_WORD1.Reg, volatile.LoadUint32(&o.RGD9_WORD1.Reg)&^(0xffffffe0)|value<<5)
}
func (o *SYSMPU_Type) GetRGD9_WORD1_ENDADDR() uint32 {
	return (volatile.LoadUint32(&o.RGD9_WORD1.Reg) & 0xffffffe0) >> 5
}

// SYSMPU.RGD9_WORD2: Region Descriptor n, Word 2
func (o *SYSMPU_Type) SetRGD9_WORD2_M0UM(value uint32) {
	volatile.StoreUint32(&o.RGD9_WORD2.Reg, volatile.LoadUint32(&o.RGD9_WORD2.Reg)&^(0x7)|value)
}
func (o *SYSMPU_Type) GetRGD9_WORD2_M0UM() uint32 {
	return volatile.LoadUint32(&o.RGD9_WORD2.Reg) & 0x7
}
func (o *SYSMPU_Type) SetRGD9_WORD2_M0SM(value uint32) {
	volatile.StoreUint32(&o.RGD9_WORD2.Reg, volatile.LoadUint32(&o.RGD9_WORD2.Reg)&^(0x18)|value<<3)
}
func (o *SYSMPU_Type) GetRGD9_WORD2_M0SM() uint32 {
	return (volatile.LoadUint32(&o.RGD9_WORD2.Reg) & 0x18) >> 3
}
func (o *SYSMPU_Type) SetRGD9_WORD2_M0PE(value uint32) {
	volatile.StoreUint32(&o.RGD9_WORD2.Reg, volatile.LoadUint32(&o.RGD9_WORD2.Reg)&^(0x20)|value<<5)
}
func (o *SYSMPU_Type) GetRGD9_WORD2_M0PE() uint32 {
	return (volatile.LoadUint32(&o.RGD9_WORD2.Reg) & 0x20) >> 5
}
func (o *SYSMPU_Type) SetRGD9_WORD2_M1UM(value uint32) {
	volatile.StoreUint32(&o.RGD9_WORD2.Reg, volatile.LoadUint32(&o.RGD9_WORD2.Reg)&^(0x1c0)|value<<6)
}
func (o *SYSMPU_Type) GetRGD9_WORD2_M1UM() uint32 {
	return (volatile.LoadUint32(&o.RGD9_WORD2.Reg) & 0x1c0) >> 6
}
func (o *SYSMPU_Type) SetRGD9_WORD2_M1SM(value uint32) {
	volatile.StoreUint32(&o.RGD9_WORD2.Reg, volatile.LoadUint32(&o.RGD9_WORD2.Reg)&^(0x600)|value<<9)
}
func (o *SYSMPU_Type) GetRGD9_WORD2_M1SM() uint32 {
	return (volatile.LoadUint32(&o.RGD9_WORD2.Reg) & 0x600) >> 9
}
func (o *SYSMPU_Type) SetRGD9_WORD2_M1PE(value uint32) {
	volatile.StoreUint32(&o.RGD9_WORD2.Reg, volatile.LoadUint32(&o.RGD9_WORD2.Reg)&^(0x800)|value<<11)
}
func (o *SYSMPU_Type) GetRGD9_WORD2_M1PE() uint32 {
	return (volatile.LoadUint32(&o.RGD9_WORD2.Reg) & 0x800) >> 11
}
func (o *SYSMPU_Type) SetRGD9_WORD2_M2UM(value uint32) {
	volatile.StoreUint32(&o.RGD9_WORD2.Reg, volatile.LoadUint32(&o.RGD9_WORD2.Reg)&^(0x7000)|value<<12)
}
func (o *SYSMPU_Type) GetRGD9_WORD2_M2UM() uint32 {
	return (volatile.LoadUint32(&o.RGD9_WORD2.Reg) & 0x7000) >> 12
}
func (o *SYSMPU_Type) SetRGD9_WORD2_M2SM(value uint32) {
	volatile.StoreUint32(&o.RGD9_WORD2.Reg, volatile.LoadUint32(&o.RGD9_WORD2.Reg)&^(0x18000)|value<<15)
}
func (o *SYSMPU_Type) GetRGD9_WORD2_M2SM() uint32 {
	return (volatile.LoadUint32(&o.RGD9_WORD2.Reg) & 0x18000) >> 15
}
func (o *SYSMPU_Type) SetRGD9_WORD2_M2PE(value uint32) {
	volatile.StoreUint32(&o.RGD9_WORD2.Reg, volatile.LoadUint32(&o.RGD9_WORD2.Reg)&^(0x20000)|value<<17)
}
func (o *SYSMPU_Type) GetRGD9_WORD2_M2PE() uint32 {
	return (volatile.LoadUint32(&o.RGD9_WORD2.Reg) & 0x20000) >> 17
}
func (o *SYSMPU_Type) SetRGD9_WORD2_M3UM(value uint32) {
	volatile.StoreUint32(&o.RGD9_WORD2.Reg, volatile.LoadUint32(&o.RGD9_WORD2.Reg)&^(0x1c0000)|value<<18)
}
func (o *SYSMPU_Type) GetRGD9_WORD2_M3UM() uint32 {
	return (volatile.LoadUint32(&o.RGD9_WORD2.Reg) & 0x1c0000) >> 18
}
func (o *SYSMPU_Type) SetRGD9_WORD2_M3SM(value uint32) {
	volatile.StoreUint32(&o.RGD9_WORD2.Reg, volatile.LoadUint32(&o.RGD9_WORD2.Reg)&^(0x600000)|value<<21)
}
func (o *SYSMPU_Type) GetRGD9_WORD2_M3SM() uint32 {
	return (volatile.LoadUint32(&o.RGD9_WORD2.Reg) & 0x600000) >> 21
}
func (o *SYSMPU_Type) SetRGD9_WORD2_M3PE(value uint32) {
	volatile.StoreUint32(&o.RGD9_WORD2.Reg, volatile.LoadUint32(&o.RGD9_WORD2.Reg)&^(0x800000)|value<<23)
}
func (o *SYSMPU_Type) GetRGD9_WORD2_M3PE() uint32 {
	return (volatile.LoadUint32(&o.RGD9_WORD2.Reg) & 0x800000) >> 23
}
func (o *SYSMPU_Type) SetRGD9_WORD2_M4WE(value uint32) {
	volatile.StoreUint32(&o.RGD9_WORD2.Reg, volatile.LoadUint32(&o.RGD9_WORD2.Reg)&^(0x1000000)|value<<24)
}
func (o *SYSMPU_Type) GetRGD9_WORD2_M4WE() uint32 {
	return (volatile.LoadUint32(&o.RGD9_WORD2.Reg) & 0x1000000) >> 24
}
func (o *SYSMPU_Type) SetRGD9_WORD2_M4RE(value uint32) {
	volatile.StoreUint32(&o.RGD9_WORD2.Reg, volatile.LoadUint32(&o.RGD9_WORD2.Reg)&^(0x2000000)|value<<25)
}
func (o *SYSMPU_Type) GetRGD9_WORD2_M4RE() uint32 {
	return (volatile.LoadUint32(&o.RGD9_WORD2.Reg) & 0x2000000) >> 25
}
func (o *SYSMPU_Type) SetRGD9_WORD2_M5WE(value uint32) {
	volatile.StoreUint32(&o.RGD9_WORD2.Reg, volatile.LoadUint32(&o.RGD9_WORD2.Reg)&^(0x4000000)|value<<26)
}
func (o *SYSMPU_Type) GetRGD9_WORD2_M5WE() uint32 {
	return (volatile.LoadUint32(&o.RGD9_WORD2.Reg) & 0x4000000) >> 26
}
func (o *SYSMPU_Type) SetRGD9_WORD2_M5RE(value uint32) {
	volatile.StoreUint32(&o.RGD9_WORD2.Reg, volatile.LoadUint32(&o.RGD9_WORD2.Reg)&^(0x8000000)|value<<27)
}
func (o *SYSMPU_Type) GetRGD9_WORD2_M5RE() uint32 {
	return (volatile.LoadUint32(&o.RGD9_WORD2.Reg) & 0x8000000) >> 27
}
func (o *SYSMPU_Type) SetRGD9_WORD2_M6WE(value uint32) {
	volatile.StoreUint32(&o.RGD9_WORD2.Reg, volatile.LoadUint32(&o.RGD9_WORD2.Reg)&^(0x10000000)|value<<28)
}
func (o *SYSMPU_Type) GetRGD9_WORD2_M6WE() uint32 {
	return (volatile.LoadUint32(&o.RGD9_WORD2.Reg) & 0x10000000) >> 28
}
func (o *SYSMPU_Type) SetRGD9_WORD2_M6RE(value uint32) {
	volatile.StoreUint32(&o.RGD9_WORD2.Reg, volatile.LoadUint32(&o.RGD9_WORD2.Reg)&^(0x20000000)|value<<29)
}
func (o *SYSMPU_Type) GetRGD9_WORD2_M6RE() uint32 {
	return (volatile.LoadUint32(&o.RGD9_WORD2.Reg) & 0x20000000) >> 29
}
func (o *SYSMPU_Type) SetRGD9_WORD2_M7WE(value uint32) {
	volatile.StoreUint32(&o.RGD9_WORD2.Reg, volatile.LoadUint32(&o.RGD9_WORD2.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSMPU_Type) GetRGD9_WORD2_M7WE() uint32 {
	return (volatile.LoadUint32(&o.RGD9_WORD2.Reg) & 0x40000000) >> 30
}
func (o *SYSMPU_Type) SetRGD9_WORD2_M7RE(value uint32) {
	volatile.StoreUint32(&o.RGD9_WORD2.Reg, volatile.LoadUint32(&o.RGD9_WORD2.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSMPU_Type) GetRGD9_WORD2_M7RE() uint32 {
	return (volatile.LoadUint32(&o.RGD9_WORD2.Reg) & 0x80000000) >> 31
}

// SYSMPU.RGD9_WORD3: Region Descriptor n, Word 3
func (o *SYSMPU_Type) SetRGD9_WORD3_VLD(value uint32) {
	volatile.StoreUint32(&o.RGD9_WORD3.Reg, volatile.LoadUint32(&o.RGD9_WORD3.Reg)&^(0x1)|value)
}
func (o *SYSMPU_Type) GetRGD9_WORD3_VLD() uint32 {
	return volatile.LoadUint32(&o.RGD9_WORD3.Reg) & 0x1
}
func (o *SYSMPU_Type) SetRGD9_WORD3_PIDMASK(value uint32) {
	volatile.StoreUint32(&o.RGD9_WORD3.Reg, volatile.LoadUint32(&o.RGD9_WORD3.Reg)&^(0xff0000)|value<<16)
}
func (o *SYSMPU_Type) GetRGD9_WORD3_PIDMASK() uint32 {
	return (volatile.LoadUint32(&o.RGD9_WORD3.Reg) & 0xff0000) >> 16
}
func (o *SYSMPU_Type) SetRGD9_WORD3_PID(value uint32) {
	volatile.StoreUint32(&o.RGD9_WORD3.Reg, volatile.LoadUint32(&o.RGD9_WORD3.Reg)&^(0xff000000)|value<<24)
}
func (o *SYSMPU_Type) GetRGD9_WORD3_PID() uint32 {
	return (volatile.LoadUint32(&o.RGD9_WORD3.Reg) & 0xff000000) >> 24
}

// SYSMPU.RGD10_WORD0: Region Descriptor n, Word 0
func (o *SYSMPU_Type) SetRGD10_WORD0_SRTADDR(value uint32) {
	volatile.StoreUint32(&o.RGD10_WORD0.Reg, volatile.LoadUint32(&o.RGD10_WORD0.Reg)&^(0xffffffe0)|value<<5)
}
func (o *SYSMPU_Type) GetRGD10_WORD0_SRTADDR() uint32 {
	return (volatile.LoadUint32(&o.RGD10_WORD0.Reg) & 0xffffffe0) >> 5
}

// SYSMPU.RGD10_WORD1: Region Descriptor n, Word 1
func (o *SYSMPU_Type) SetRGD10_WORD1_ENDADDR(value uint32) {
	volatile.StoreUint32(&o.RGD10_WORD1.Reg, volatile.LoadUint32(&o.RGD10_WORD1.Reg)&^(0xffffffe0)|value<<5)
}
func (o *SYSMPU_Type) GetRGD10_WORD1_ENDADDR() uint32 {
	return (volatile.LoadUint32(&o.RGD10_WORD1.Reg) & 0xffffffe0) >> 5
}

// SYSMPU.RGD10_WORD2: Region Descriptor n, Word 2
func (o *SYSMPU_Type) SetRGD10_WORD2_M0UM(value uint32) {
	volatile.StoreUint32(&o.RGD10_WORD2.Reg, volatile.LoadUint32(&o.RGD10_WORD2.Reg)&^(0x7)|value)
}
func (o *SYSMPU_Type) GetRGD10_WORD2_M0UM() uint32 {
	return volatile.LoadUint32(&o.RGD10_WORD2.Reg) & 0x7
}
func (o *SYSMPU_Type) SetRGD10_WORD2_M0SM(value uint32) {
	volatile.StoreUint32(&o.RGD10_WORD2.Reg, volatile.LoadUint32(&o.RGD10_WORD2.Reg)&^(0x18)|value<<3)
}
func (o *SYSMPU_Type) GetRGD10_WORD2_M0SM() uint32 {
	return (volatile.LoadUint32(&o.RGD10_WORD2.Reg) & 0x18) >> 3
}
func (o *SYSMPU_Type) SetRGD10_WORD2_M0PE(value uint32) {
	volatile.StoreUint32(&o.RGD10_WORD2.Reg, volatile.LoadUint32(&o.RGD10_WORD2.Reg)&^(0x20)|value<<5)
}
func (o *SYSMPU_Type) GetRGD10_WORD2_M0PE() uint32 {
	return (volatile.LoadUint32(&o.RGD10_WORD2.Reg) & 0x20) >> 5
}
func (o *SYSMPU_Type) SetRGD10_WORD2_M1UM(value uint32) {
	volatile.StoreUint32(&o.RGD10_WORD2.Reg, volatile.LoadUint32(&o.RGD10_WORD2.Reg)&^(0x1c0)|value<<6)
}
func (o *SYSMPU_Type) GetRGD10_WORD2_M1UM() uint32 {
	return (volatile.LoadUint32(&o.RGD10_WORD2.Reg) & 0x1c0) >> 6
}
func (o *SYSMPU_Type) SetRGD10_WORD2_M1SM(value uint32) {
	volatile.StoreUint32(&o.RGD10_WORD2.Reg, volatile.LoadUint32(&o.RGD10_WORD2.Reg)&^(0x600)|value<<9)
}
func (o *SYSMPU_Type) GetRGD10_WORD2_M1SM() uint32 {
	return (volatile.LoadUint32(&o.RGD10_WORD2.Reg) & 0x600) >> 9
}
func (o *SYSMPU_Type) SetRGD10_WORD2_M1PE(value uint32) {
	volatile.StoreUint32(&o.RGD10_WORD2.Reg, volatile.LoadUint32(&o.RGD10_WORD2.Reg)&^(0x800)|value<<11)
}
func (o *SYSMPU_Type) GetRGD10_WORD2_M1PE() uint32 {
	return (volatile.LoadUint32(&o.RGD10_WORD2.Reg) & 0x800) >> 11
}
func (o *SYSMPU_Type) SetRGD10_WORD2_M2UM(value uint32) {
	volatile.StoreUint32(&o.RGD10_WORD2.Reg, volatile.LoadUint32(&o.RGD10_WORD2.Reg)&^(0x7000)|value<<12)
}
func (o *SYSMPU_Type) GetRGD10_WORD2_M2UM() uint32 {
	return (volatile.LoadUint32(&o.RGD10_WORD2.Reg) & 0x7000) >> 12
}
func (o *SYSMPU_Type) SetRGD10_WORD2_M2SM(value uint32) {
	volatile.StoreUint32(&o.RGD10_WORD2.Reg, volatile.LoadUint32(&o.RGD10_WORD2.Reg)&^(0x18000)|value<<15)
}
func (o *SYSMPU_Type) GetRGD10_WORD2_M2SM() uint32 {
	return (volatile.LoadUint32(&o.RGD10_WORD2.Reg) & 0x18000) >> 15
}
func (o *SYSMPU_Type) SetRGD10_WORD2_M2PE(value uint32) {
	volatile.StoreUint32(&o.RGD10_WORD2.Reg, volatile.LoadUint32(&o.RGD10_WORD2.Reg)&^(0x20000)|value<<17)
}
func (o *SYSMPU_Type) GetRGD10_WORD2_M2PE() uint32 {
	return (volatile.LoadUint32(&o.RGD10_WORD2.Reg) & 0x20000) >> 17
}
func (o *SYSMPU_Type) SetRGD10_WORD2_M3UM(value uint32) {
	volatile.StoreUint32(&o.RGD10_WORD2.Reg, volatile.LoadUint32(&o.RGD10_WORD2.Reg)&^(0x1c0000)|value<<18)
}
func (o *SYSMPU_Type) GetRGD10_WORD2_M3UM() uint32 {
	return (volatile.LoadUint32(&o.RGD10_WORD2.Reg) & 0x1c0000) >> 18
}
func (o *SYSMPU_Type) SetRGD10_WORD2_M3SM(value uint32) {
	volatile.StoreUint32(&o.RGD10_WORD2.Reg, volatile.LoadUint32(&o.RGD10_WORD2.Reg)&^(0x600000)|value<<21)
}
func (o *SYSMPU_Type) GetRGD10_WORD2_M3SM() uint32 {
	return (volatile.LoadUint32(&o.RGD10_WORD2.Reg) & 0x600000) >> 21
}
func (o *SYSMPU_Type) SetRGD10_WORD2_M3PE(value uint32) {
	volatile.StoreUint32(&o.RGD10_WORD2.Reg, volatile.LoadUint32(&o.RGD10_WORD2.Reg)&^(0x800000)|value<<23)
}
func (o *SYSMPU_Type) GetRGD10_WORD2_M3PE() uint32 {
	return (volatile.LoadUint32(&o.RGD10_WORD2.Reg) & 0x800000) >> 23
}
func (o *SYSMPU_Type) SetRGD10_WORD2_M4WE(value uint32) {
	volatile.StoreUint32(&o.RGD10_WORD2.Reg, volatile.LoadUint32(&o.RGD10_WORD2.Reg)&^(0x1000000)|value<<24)
}
func (o *SYSMPU_Type) GetRGD10_WORD2_M4WE() uint32 {
	return (volatile.LoadUint32(&o.RGD10_WORD2.Reg) & 0x1000000) >> 24
}
func (o *SYSMPU_Type) SetRGD10_WORD2_M4RE(value uint32) {
	volatile.StoreUint32(&o.RGD10_WORD2.Reg, volatile.LoadUint32(&o.RGD10_WORD2.Reg)&^(0x2000000)|value<<25)
}
func (o *SYSMPU_Type) GetRGD10_WORD2_M4RE() uint32 {
	return (volatile.LoadUint32(&o.RGD10_WORD2.Reg) & 0x2000000) >> 25
}
func (o *SYSMPU_Type) SetRGD10_WORD2_M5WE(value uint32) {
	volatile.StoreUint32(&o.RGD10_WORD2.Reg, volatile.LoadUint32(&o.RGD10_WORD2.Reg)&^(0x4000000)|value<<26)
}
func (o *SYSMPU_Type) GetRGD10_WORD2_M5WE() uint32 {
	return (volatile.LoadUint32(&o.RGD10_WORD2.Reg) & 0x4000000) >> 26
}
func (o *SYSMPU_Type) SetRGD10_WORD2_M5RE(value uint32) {
	volatile.StoreUint32(&o.RGD10_WORD2.Reg, volatile.LoadUint32(&o.RGD10_WORD2.Reg)&^(0x8000000)|value<<27)
}
func (o *SYSMPU_Type) GetRGD10_WORD2_M5RE() uint32 {
	return (volatile.LoadUint32(&o.RGD10_WORD2.Reg) & 0x8000000) >> 27
}
func (o *SYSMPU_Type) SetRGD10_WORD2_M6WE(value uint32) {
	volatile.StoreUint32(&o.RGD10_WORD2.Reg, volatile.LoadUint32(&o.RGD10_WORD2.Reg)&^(0x10000000)|value<<28)
}
func (o *SYSMPU_Type) GetRGD10_WORD2_M6WE() uint32 {
	return (volatile.LoadUint32(&o.RGD10_WORD2.Reg) & 0x10000000) >> 28
}
func (o *SYSMPU_Type) SetRGD10_WORD2_M6RE(value uint32) {
	volatile.StoreUint32(&o.RGD10_WORD2.Reg, volatile.LoadUint32(&o.RGD10_WORD2.Reg)&^(0x20000000)|value<<29)
}
func (o *SYSMPU_Type) GetRGD10_WORD2_M6RE() uint32 {
	return (volatile.LoadUint32(&o.RGD10_WORD2.Reg) & 0x20000000) >> 29
}
func (o *SYSMPU_Type) SetRGD10_WORD2_M7WE(value uint32) {
	volatile.StoreUint32(&o.RGD10_WORD2.Reg, volatile.LoadUint32(&o.RGD10_WORD2.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSMPU_Type) GetRGD10_WORD2_M7WE() uint32 {
	return (volatile.LoadUint32(&o.RGD10_WORD2.Reg) & 0x40000000) >> 30
}
func (o *SYSMPU_Type) SetRGD10_WORD2_M7RE(value uint32) {
	volatile.StoreUint32(&o.RGD10_WORD2.Reg, volatile.LoadUint32(&o.RGD10_WORD2.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSMPU_Type) GetRGD10_WORD2_M7RE() uint32 {
	return (volatile.LoadUint32(&o.RGD10_WORD2.Reg) & 0x80000000) >> 31
}

// SYSMPU.RGD10_WORD3: Region Descriptor n, Word 3
func (o *SYSMPU_Type) SetRGD10_WORD3_VLD(value uint32) {
	volatile.StoreUint32(&o.RGD10_WORD3.Reg, volatile.LoadUint32(&o.RGD10_WORD3.Reg)&^(0x1)|value)
}
func (o *SYSMPU_Type) GetRGD10_WORD3_VLD() uint32 {
	return volatile.LoadUint32(&o.RGD10_WORD3.Reg) & 0x1
}
func (o *SYSMPU_Type) SetRGD10_WORD3_PIDMASK(value uint32) {
	volatile.StoreUint32(&o.RGD10_WORD3.Reg, volatile.LoadUint32(&o.RGD10_WORD3.Reg)&^(0xff0000)|value<<16)
}
func (o *SYSMPU_Type) GetRGD10_WORD3_PIDMASK() uint32 {
	return (volatile.LoadUint32(&o.RGD10_WORD3.Reg) & 0xff0000) >> 16
}
func (o *SYSMPU_Type) SetRGD10_WORD3_PID(value uint32) {
	volatile.StoreUint32(&o.RGD10_WORD3.Reg, volatile.LoadUint32(&o.RGD10_WORD3.Reg)&^(0xff000000)|value<<24)
}
func (o *SYSMPU_Type) GetRGD10_WORD3_PID() uint32 {
	return (volatile.LoadUint32(&o.RGD10_WORD3.Reg) & 0xff000000) >> 24
}

// SYSMPU.RGD11_WORD0: Region Descriptor n, Word 0
func (o *SYSMPU_Type) SetRGD11_WORD0_SRTADDR(value uint32) {
	volatile.StoreUint32(&o.RGD11_WORD0.Reg, volatile.LoadUint32(&o.RGD11_WORD0.Reg)&^(0xffffffe0)|value<<5)
}
func (o *SYSMPU_Type) GetRGD11_WORD0_SRTADDR() uint32 {
	return (volatile.LoadUint32(&o.RGD11_WORD0.Reg) & 0xffffffe0) >> 5
}

// SYSMPU.RGD11_WORD1: Region Descriptor n, Word 1
func (o *SYSMPU_Type) SetRGD11_WORD1_ENDADDR(value uint32) {
	volatile.StoreUint32(&o.RGD11_WORD1.Reg, volatile.LoadUint32(&o.RGD11_WORD1.Reg)&^(0xffffffe0)|value<<5)
}
func (o *SYSMPU_Type) GetRGD11_WORD1_ENDADDR() uint32 {
	return (volatile.LoadUint32(&o.RGD11_WORD1.Reg) & 0xffffffe0) >> 5
}

// SYSMPU.RGD11_WORD2: Region Descriptor n, Word 2
func (o *SYSMPU_Type) SetRGD11_WORD2_M0UM(value uint32) {
	volatile.StoreUint32(&o.RGD11_WORD2.Reg, volatile.LoadUint32(&o.RGD11_WORD2.Reg)&^(0x7)|value)
}
func (o *SYSMPU_Type) GetRGD11_WORD2_M0UM() uint32 {
	return volatile.LoadUint32(&o.RGD11_WORD2.Reg) & 0x7
}
func (o *SYSMPU_Type) SetRGD11_WORD2_M0SM(value uint32) {
	volatile.StoreUint32(&o.RGD11_WORD2.Reg, volatile.LoadUint32(&o.RGD11_WORD2.Reg)&^(0x18)|value<<3)
}
func (o *SYSMPU_Type) GetRGD11_WORD2_M0SM() uint32 {
	return (volatile.LoadUint32(&o.RGD11_WORD2.Reg) & 0x18) >> 3
}
func (o *SYSMPU_Type) SetRGD11_WORD2_M0PE(value uint32) {
	volatile.StoreUint32(&o.RGD11_WORD2.Reg, volatile.LoadUint32(&o.RGD11_WORD2.Reg)&^(0x20)|value<<5)
}
func (o *SYSMPU_Type) GetRGD11_WORD2_M0PE() uint32 {
	return (volatile.LoadUint32(&o.RGD11_WORD2.Reg) & 0x20) >> 5
}
func (o *SYSMPU_Type) SetRGD11_WORD2_M1UM(value uint32) {
	volatile.StoreUint32(&o.RGD11_WORD2.Reg, volatile.LoadUint32(&o.RGD11_WORD2.Reg)&^(0x1c0)|value<<6)
}
func (o *SYSMPU_Type) GetRGD11_WORD2_M1UM() uint32 {
	return (volatile.LoadUint32(&o.RGD11_WORD2.Reg) & 0x1c0) >> 6
}
func (o *SYSMPU_Type) SetRGD11_WORD2_M1SM(value uint32) {
	volatile.StoreUint32(&o.RGD11_WORD2.Reg, volatile.LoadUint32(&o.RGD11_WORD2.Reg)&^(0x600)|value<<9)
}
func (o *SYSMPU_Type) GetRGD11_WORD2_M1SM() uint32 {
	return (volatile.LoadUint32(&o.RGD11_WORD2.Reg) & 0x600) >> 9
}
func (o *SYSMPU_Type) SetRGD11_WORD2_M1PE(value uint32) {
	volatile.StoreUint32(&o.RGD11_WORD2.Reg, volatile.LoadUint32(&o.RGD11_WORD2.Reg)&^(0x800)|value<<11)
}
func (o *SYSMPU_Type) GetRGD11_WORD2_M1PE() uint32 {
	return (volatile.LoadUint32(&o.RGD11_WORD2.Reg) & 0x800) >> 11
}
func (o *SYSMPU_Type) SetRGD11_WORD2_M2UM(value uint32) {
	volatile.StoreUint32(&o.RGD11_WORD2.Reg, volatile.LoadUint32(&o.RGD11_WORD2.Reg)&^(0x7000)|value<<12)
}
func (o *SYSMPU_Type) GetRGD11_WORD2_M2UM() uint32 {
	return (volatile.LoadUint32(&o.RGD11_WORD2.Reg) & 0x7000) >> 12
}
func (o *SYSMPU_Type) SetRGD11_WORD2_M2SM(value uint32) {
	volatile.StoreUint32(&o.RGD11_WORD2.Reg, volatile.LoadUint32(&o.RGD11_WORD2.Reg)&^(0x18000)|value<<15)
}
func (o *SYSMPU_Type) GetRGD11_WORD2_M2SM() uint32 {
	return (volatile.LoadUint32(&o.RGD11_WORD2.Reg) & 0x18000) >> 15
}
func (o *SYSMPU_Type) SetRGD11_WORD2_M2PE(value uint32) {
	volatile.StoreUint32(&o.RGD11_WORD2.Reg, volatile.LoadUint32(&o.RGD11_WORD2.Reg)&^(0x20000)|value<<17)
}
func (o *SYSMPU_Type) GetRGD11_WORD2_M2PE() uint32 {
	return (volatile.LoadUint32(&o.RGD11_WORD2.Reg) & 0x20000) >> 17
}
func (o *SYSMPU_Type) SetRGD11_WORD2_M3UM(value uint32) {
	volatile.StoreUint32(&o.RGD11_WORD2.Reg, volatile.LoadUint32(&o.RGD11_WORD2.Reg)&^(0x1c0000)|value<<18)
}
func (o *SYSMPU_Type) GetRGD11_WORD2_M3UM() uint32 {
	return (volatile.LoadUint32(&o.RGD11_WORD2.Reg) & 0x1c0000) >> 18
}
func (o *SYSMPU_Type) SetRGD11_WORD2_M3SM(value uint32) {
	volatile.StoreUint32(&o.RGD11_WORD2.Reg, volatile.LoadUint32(&o.RGD11_WORD2.Reg)&^(0x600000)|value<<21)
}
func (o *SYSMPU_Type) GetRGD11_WORD2_M3SM() uint32 {
	return (volatile.LoadUint32(&o.RGD11_WORD2.Reg) & 0x600000) >> 21
}
func (o *SYSMPU_Type) SetRGD11_WORD2_M3PE(value uint32) {
	volatile.StoreUint32(&o.RGD11_WORD2.Reg, volatile.LoadUint32(&o.RGD11_WORD2.Reg)&^(0x800000)|value<<23)
}
func (o *SYSMPU_Type) GetRGD11_WORD2_M3PE() uint32 {
	return (volatile.LoadUint32(&o.RGD11_WORD2.Reg) & 0x800000) >> 23
}
func (o *SYSMPU_Type) SetRGD11_WORD2_M4WE(value uint32) {
	volatile.StoreUint32(&o.RGD11_WORD2.Reg, volatile.LoadUint32(&o.RGD11_WORD2.Reg)&^(0x1000000)|value<<24)
}
func (o *SYSMPU_Type) GetRGD11_WORD2_M4WE() uint32 {
	return (volatile.LoadUint32(&o.RGD11_WORD2.Reg) & 0x1000000) >> 24
}
func (o *SYSMPU_Type) SetRGD11_WORD2_M4RE(value uint32) {
	volatile.StoreUint32(&o.RGD11_WORD2.Reg, volatile.LoadUint32(&o.RGD11_WORD2.Reg)&^(0x2000000)|value<<25)
}
func (o *SYSMPU_Type) GetRGD11_WORD2_M4RE() uint32 {
	return (volatile.LoadUint32(&o.RGD11_WORD2.Reg) & 0x2000000) >> 25
}
func (o *SYSMPU_Type) SetRGD11_WORD2_M5WE(value uint32) {
	volatile.StoreUint32(&o.RGD11_WORD2.Reg, volatile.LoadUint32(&o.RGD11_WORD2.Reg)&^(0x4000000)|value<<26)
}
func (o *SYSMPU_Type) GetRGD11_WORD2_M5WE() uint32 {
	return (volatile.LoadUint32(&o.RGD11_WORD2.Reg) & 0x4000000) >> 26
}
func (o *SYSMPU_Type) SetRGD11_WORD2_M5RE(value uint32) {
	volatile.StoreUint32(&o.RGD11_WORD2.Reg, volatile.LoadUint32(&o.RGD11_WORD2.Reg)&^(0x8000000)|value<<27)
}
func (o *SYSMPU_Type) GetRGD11_WORD2_M5RE() uint32 {
	return (volatile.LoadUint32(&o.RGD11_WORD2.Reg) & 0x8000000) >> 27
}
func (o *SYSMPU_Type) SetRGD11_WORD2_M6WE(value uint32) {
	volatile.StoreUint32(&o.RGD11_WORD2.Reg, volatile.LoadUint32(&o.RGD11_WORD2.Reg)&^(0x10000000)|value<<28)
}
func (o *SYSMPU_Type) GetRGD11_WORD2_M6WE() uint32 {
	return (volatile.LoadUint32(&o.RGD11_WORD2.Reg) & 0x10000000) >> 28
}
func (o *SYSMPU_Type) SetRGD11_WORD2_M6RE(value uint32) {
	volatile.StoreUint32(&o.RGD11_WORD2.Reg, volatile.LoadUint32(&o.RGD11_WORD2.Reg)&^(0x20000000)|value<<29)
}
func (o *SYSMPU_Type) GetRGD11_WORD2_M6RE() uint32 {
	return (volatile.LoadUint32(&o.RGD11_WORD2.Reg) & 0x20000000) >> 29
}
func (o *SYSMPU_Type) SetRGD11_WORD2_M7WE(value uint32) {
	volatile.StoreUint32(&o.RGD11_WORD2.Reg, volatile.LoadUint32(&o.RGD11_WORD2.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSMPU_Type) GetRGD11_WORD2_M7WE() uint32 {
	return (volatile.LoadUint32(&o.RGD11_WORD2.Reg) & 0x40000000) >> 30
}
func (o *SYSMPU_Type) SetRGD11_WORD2_M7RE(value uint32) {
	volatile.StoreUint32(&o.RGD11_WORD2.Reg, volatile.LoadUint32(&o.RGD11_WORD2.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSMPU_Type) GetRGD11_WORD2_M7RE() uint32 {
	return (volatile.LoadUint32(&o.RGD11_WORD2.Reg) & 0x80000000) >> 31
}

// SYSMPU.RGD11_WORD3: Region Descriptor n, Word 3
func (o *SYSMPU_Type) SetRGD11_WORD3_VLD(value uint32) {
	volatile.StoreUint32(&o.RGD11_WORD3.Reg, volatile.LoadUint32(&o.RGD11_WORD3.Reg)&^(0x1)|value)
}
func (o *SYSMPU_Type) GetRGD11_WORD3_VLD() uint32 {
	return volatile.LoadUint32(&o.RGD11_WORD3.Reg) & 0x1
}
func (o *SYSMPU_Type) SetRGD11_WORD3_PIDMASK(value uint32) {
	volatile.StoreUint32(&o.RGD11_WORD3.Reg, volatile.LoadUint32(&o.RGD11_WORD3.Reg)&^(0xff0000)|value<<16)
}
func (o *SYSMPU_Type) GetRGD11_WORD3_PIDMASK() uint32 {
	return (volatile.LoadUint32(&o.RGD11_WORD3.Reg) & 0xff0000) >> 16
}
func (o *SYSMPU_Type) SetRGD11_WORD3_PID(value uint32) {
	volatile.StoreUint32(&o.RGD11_WORD3.Reg, volatile.LoadUint32(&o.RGD11_WORD3.Reg)&^(0xff000000)|value<<24)
}
func (o *SYSMPU_Type) GetRGD11_WORD3_PID() uint32 {
	return (volatile.LoadUint32(&o.RGD11_WORD3.Reg) & 0xff000000) >> 24
}

// SYSMPU.RGDAAC0: Region Descriptor Alternate Access Control n
func (o *SYSMPU_Type) SetRGDAAC0_M0UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC0.Reg, volatile.LoadUint32(&o.RGDAAC0.Reg)&^(0x7)|value)
}
func (o *SYSMPU_Type) GetRGDAAC0_M0UM() uint32 {
	return volatile.LoadUint32(&o.RGDAAC0.Reg) & 0x7
}
func (o *SYSMPU_Type) SetRGDAAC0_M0SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC0.Reg, volatile.LoadUint32(&o.RGDAAC0.Reg)&^(0x18)|value<<3)
}
func (o *SYSMPU_Type) GetRGDAAC0_M0SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC0.Reg) & 0x18) >> 3
}
func (o *SYSMPU_Type) SetRGDAAC0_M0PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC0.Reg, volatile.LoadUint32(&o.RGDAAC0.Reg)&^(0x20)|value<<5)
}
func (o *SYSMPU_Type) GetRGDAAC0_M0PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC0.Reg) & 0x20) >> 5
}
func (o *SYSMPU_Type) SetRGDAAC0_M1UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC0.Reg, volatile.LoadUint32(&o.RGDAAC0.Reg)&^(0x1c0)|value<<6)
}
func (o *SYSMPU_Type) GetRGDAAC0_M1UM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC0.Reg) & 0x1c0) >> 6
}
func (o *SYSMPU_Type) SetRGDAAC0_M1SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC0.Reg, volatile.LoadUint32(&o.RGDAAC0.Reg)&^(0x600)|value<<9)
}
func (o *SYSMPU_Type) GetRGDAAC0_M1SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC0.Reg) & 0x600) >> 9
}
func (o *SYSMPU_Type) SetRGDAAC0_M1PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC0.Reg, volatile.LoadUint32(&o.RGDAAC0.Reg)&^(0x800)|value<<11)
}
func (o *SYSMPU_Type) GetRGDAAC0_M1PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC0.Reg) & 0x800) >> 11
}
func (o *SYSMPU_Type) SetRGDAAC0_M2UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC0.Reg, volatile.LoadUint32(&o.RGDAAC0.Reg)&^(0x7000)|value<<12)
}
func (o *SYSMPU_Type) GetRGDAAC0_M2UM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC0.Reg) & 0x7000) >> 12
}
func (o *SYSMPU_Type) SetRGDAAC0_M2SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC0.Reg, volatile.LoadUint32(&o.RGDAAC0.Reg)&^(0x18000)|value<<15)
}
func (o *SYSMPU_Type) GetRGDAAC0_M2SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC0.Reg) & 0x18000) >> 15
}
func (o *SYSMPU_Type) SetRGDAAC0_M2PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC0.Reg, volatile.LoadUint32(&o.RGDAAC0.Reg)&^(0x20000)|value<<17)
}
func (o *SYSMPU_Type) GetRGDAAC0_M2PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC0.Reg) & 0x20000) >> 17
}
func (o *SYSMPU_Type) SetRGDAAC0_M3UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC0.Reg, volatile.LoadUint32(&o.RGDAAC0.Reg)&^(0x1c0000)|value<<18)
}
func (o *SYSMPU_Type) GetRGDAAC0_M3UM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC0.Reg) & 0x1c0000) >> 18
}
func (o *SYSMPU_Type) SetRGDAAC0_M3SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC0.Reg, volatile.LoadUint32(&o.RGDAAC0.Reg)&^(0x600000)|value<<21)
}
func (o *SYSMPU_Type) GetRGDAAC0_M3SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC0.Reg) & 0x600000) >> 21
}
func (o *SYSMPU_Type) SetRGDAAC0_M3PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC0.Reg, volatile.LoadUint32(&o.RGDAAC0.Reg)&^(0x800000)|value<<23)
}
func (o *SYSMPU_Type) GetRGDAAC0_M3PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC0.Reg) & 0x800000) >> 23
}
func (o *SYSMPU_Type) SetRGDAAC0_M4WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC0.Reg, volatile.LoadUint32(&o.RGDAAC0.Reg)&^(0x1000000)|value<<24)
}
func (o *SYSMPU_Type) GetRGDAAC0_M4WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC0.Reg) & 0x1000000) >> 24
}
func (o *SYSMPU_Type) SetRGDAAC0_M4RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC0.Reg, volatile.LoadUint32(&o.RGDAAC0.Reg)&^(0x2000000)|value<<25)
}
func (o *SYSMPU_Type) GetRGDAAC0_M4RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC0.Reg) & 0x2000000) >> 25
}
func (o *SYSMPU_Type) SetRGDAAC0_M5WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC0.Reg, volatile.LoadUint32(&o.RGDAAC0.Reg)&^(0x4000000)|value<<26)
}
func (o *SYSMPU_Type) GetRGDAAC0_M5WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC0.Reg) & 0x4000000) >> 26
}
func (o *SYSMPU_Type) SetRGDAAC0_M5RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC0.Reg, volatile.LoadUint32(&o.RGDAAC0.Reg)&^(0x8000000)|value<<27)
}
func (o *SYSMPU_Type) GetRGDAAC0_M5RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC0.Reg) & 0x8000000) >> 27
}
func (o *SYSMPU_Type) SetRGDAAC0_M6WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC0.Reg, volatile.LoadUint32(&o.RGDAAC0.Reg)&^(0x10000000)|value<<28)
}
func (o *SYSMPU_Type) GetRGDAAC0_M6WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC0.Reg) & 0x10000000) >> 28
}
func (o *SYSMPU_Type) SetRGDAAC0_M6RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC0.Reg, volatile.LoadUint32(&o.RGDAAC0.Reg)&^(0x20000000)|value<<29)
}
func (o *SYSMPU_Type) GetRGDAAC0_M6RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC0.Reg) & 0x20000000) >> 29
}
func (o *SYSMPU_Type) SetRGDAAC0_M7WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC0.Reg, volatile.LoadUint32(&o.RGDAAC0.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSMPU_Type) GetRGDAAC0_M7WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC0.Reg) & 0x40000000) >> 30
}
func (o *SYSMPU_Type) SetRGDAAC0_M7RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC0.Reg, volatile.LoadUint32(&o.RGDAAC0.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSMPU_Type) GetRGDAAC0_M7RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC0.Reg) & 0x80000000) >> 31
}

// SYSMPU.RGDAAC1: Region Descriptor Alternate Access Control n
func (o *SYSMPU_Type) SetRGDAAC1_M0UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC1.Reg, volatile.LoadUint32(&o.RGDAAC1.Reg)&^(0x7)|value)
}
func (o *SYSMPU_Type) GetRGDAAC1_M0UM() uint32 {
	return volatile.LoadUint32(&o.RGDAAC1.Reg) & 0x7
}
func (o *SYSMPU_Type) SetRGDAAC1_M0SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC1.Reg, volatile.LoadUint32(&o.RGDAAC1.Reg)&^(0x18)|value<<3)
}
func (o *SYSMPU_Type) GetRGDAAC1_M0SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC1.Reg) & 0x18) >> 3
}
func (o *SYSMPU_Type) SetRGDAAC1_M0PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC1.Reg, volatile.LoadUint32(&o.RGDAAC1.Reg)&^(0x20)|value<<5)
}
func (o *SYSMPU_Type) GetRGDAAC1_M0PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC1.Reg) & 0x20) >> 5
}
func (o *SYSMPU_Type) SetRGDAAC1_M1UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC1.Reg, volatile.LoadUint32(&o.RGDAAC1.Reg)&^(0x1c0)|value<<6)
}
func (o *SYSMPU_Type) GetRGDAAC1_M1UM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC1.Reg) & 0x1c0) >> 6
}
func (o *SYSMPU_Type) SetRGDAAC1_M1SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC1.Reg, volatile.LoadUint32(&o.RGDAAC1.Reg)&^(0x600)|value<<9)
}
func (o *SYSMPU_Type) GetRGDAAC1_M1SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC1.Reg) & 0x600) >> 9
}
func (o *SYSMPU_Type) SetRGDAAC1_M1PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC1.Reg, volatile.LoadUint32(&o.RGDAAC1.Reg)&^(0x800)|value<<11)
}
func (o *SYSMPU_Type) GetRGDAAC1_M1PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC1.Reg) & 0x800) >> 11
}
func (o *SYSMPU_Type) SetRGDAAC1_M2UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC1.Reg, volatile.LoadUint32(&o.RGDAAC1.Reg)&^(0x7000)|value<<12)
}
func (o *SYSMPU_Type) GetRGDAAC1_M2UM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC1.Reg) & 0x7000) >> 12
}
func (o *SYSMPU_Type) SetRGDAAC1_M2SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC1.Reg, volatile.LoadUint32(&o.RGDAAC1.Reg)&^(0x18000)|value<<15)
}
func (o *SYSMPU_Type) GetRGDAAC1_M2SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC1.Reg) & 0x18000) >> 15
}
func (o *SYSMPU_Type) SetRGDAAC1_M2PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC1.Reg, volatile.LoadUint32(&o.RGDAAC1.Reg)&^(0x20000)|value<<17)
}
func (o *SYSMPU_Type) GetRGDAAC1_M2PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC1.Reg) & 0x20000) >> 17
}
func (o *SYSMPU_Type) SetRGDAAC1_M3UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC1.Reg, volatile.LoadUint32(&o.RGDAAC1.Reg)&^(0x1c0000)|value<<18)
}
func (o *SYSMPU_Type) GetRGDAAC1_M3UM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC1.Reg) & 0x1c0000) >> 18
}
func (o *SYSMPU_Type) SetRGDAAC1_M3SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC1.Reg, volatile.LoadUint32(&o.RGDAAC1.Reg)&^(0x600000)|value<<21)
}
func (o *SYSMPU_Type) GetRGDAAC1_M3SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC1.Reg) & 0x600000) >> 21
}
func (o *SYSMPU_Type) SetRGDAAC1_M3PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC1.Reg, volatile.LoadUint32(&o.RGDAAC1.Reg)&^(0x800000)|value<<23)
}
func (o *SYSMPU_Type) GetRGDAAC1_M3PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC1.Reg) & 0x800000) >> 23
}
func (o *SYSMPU_Type) SetRGDAAC1_M4WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC1.Reg, volatile.LoadUint32(&o.RGDAAC1.Reg)&^(0x1000000)|value<<24)
}
func (o *SYSMPU_Type) GetRGDAAC1_M4WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC1.Reg) & 0x1000000) >> 24
}
func (o *SYSMPU_Type) SetRGDAAC1_M4RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC1.Reg, volatile.LoadUint32(&o.RGDAAC1.Reg)&^(0x2000000)|value<<25)
}
func (o *SYSMPU_Type) GetRGDAAC1_M4RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC1.Reg) & 0x2000000) >> 25
}
func (o *SYSMPU_Type) SetRGDAAC1_M5WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC1.Reg, volatile.LoadUint32(&o.RGDAAC1.Reg)&^(0x4000000)|value<<26)
}
func (o *SYSMPU_Type) GetRGDAAC1_M5WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC1.Reg) & 0x4000000) >> 26
}
func (o *SYSMPU_Type) SetRGDAAC1_M5RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC1.Reg, volatile.LoadUint32(&o.RGDAAC1.Reg)&^(0x8000000)|value<<27)
}
func (o *SYSMPU_Type) GetRGDAAC1_M5RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC1.Reg) & 0x8000000) >> 27
}
func (o *SYSMPU_Type) SetRGDAAC1_M6WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC1.Reg, volatile.LoadUint32(&o.RGDAAC1.Reg)&^(0x10000000)|value<<28)
}
func (o *SYSMPU_Type) GetRGDAAC1_M6WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC1.Reg) & 0x10000000) >> 28
}
func (o *SYSMPU_Type) SetRGDAAC1_M6RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC1.Reg, volatile.LoadUint32(&o.RGDAAC1.Reg)&^(0x20000000)|value<<29)
}
func (o *SYSMPU_Type) GetRGDAAC1_M6RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC1.Reg) & 0x20000000) >> 29
}
func (o *SYSMPU_Type) SetRGDAAC1_M7WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC1.Reg, volatile.LoadUint32(&o.RGDAAC1.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSMPU_Type) GetRGDAAC1_M7WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC1.Reg) & 0x40000000) >> 30
}
func (o *SYSMPU_Type) SetRGDAAC1_M7RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC1.Reg, volatile.LoadUint32(&o.RGDAAC1.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSMPU_Type) GetRGDAAC1_M7RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC1.Reg) & 0x80000000) >> 31
}

// SYSMPU.RGDAAC2: Region Descriptor Alternate Access Control n
func (o *SYSMPU_Type) SetRGDAAC2_M0UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC2.Reg, volatile.LoadUint32(&o.RGDAAC2.Reg)&^(0x7)|value)
}
func (o *SYSMPU_Type) GetRGDAAC2_M0UM() uint32 {
	return volatile.LoadUint32(&o.RGDAAC2.Reg) & 0x7
}
func (o *SYSMPU_Type) SetRGDAAC2_M0SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC2.Reg, volatile.LoadUint32(&o.RGDAAC2.Reg)&^(0x18)|value<<3)
}
func (o *SYSMPU_Type) GetRGDAAC2_M0SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC2.Reg) & 0x18) >> 3
}
func (o *SYSMPU_Type) SetRGDAAC2_M0PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC2.Reg, volatile.LoadUint32(&o.RGDAAC2.Reg)&^(0x20)|value<<5)
}
func (o *SYSMPU_Type) GetRGDAAC2_M0PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC2.Reg) & 0x20) >> 5
}
func (o *SYSMPU_Type) SetRGDAAC2_M1UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC2.Reg, volatile.LoadUint32(&o.RGDAAC2.Reg)&^(0x1c0)|value<<6)
}
func (o *SYSMPU_Type) GetRGDAAC2_M1UM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC2.Reg) & 0x1c0) >> 6
}
func (o *SYSMPU_Type) SetRGDAAC2_M1SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC2.Reg, volatile.LoadUint32(&o.RGDAAC2.Reg)&^(0x600)|value<<9)
}
func (o *SYSMPU_Type) GetRGDAAC2_M1SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC2.Reg) & 0x600) >> 9
}
func (o *SYSMPU_Type) SetRGDAAC2_M1PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC2.Reg, volatile.LoadUint32(&o.RGDAAC2.Reg)&^(0x800)|value<<11)
}
func (o *SYSMPU_Type) GetRGDAAC2_M1PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC2.Reg) & 0x800) >> 11
}
func (o *SYSMPU_Type) SetRGDAAC2_M2UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC2.Reg, volatile.LoadUint32(&o.RGDAAC2.Reg)&^(0x7000)|value<<12)
}
func (o *SYSMPU_Type) GetRGDAAC2_M2UM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC2.Reg) & 0x7000) >> 12
}
func (o *SYSMPU_Type) SetRGDAAC2_M2SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC2.Reg, volatile.LoadUint32(&o.RGDAAC2.Reg)&^(0x18000)|value<<15)
}
func (o *SYSMPU_Type) GetRGDAAC2_M2SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC2.Reg) & 0x18000) >> 15
}
func (o *SYSMPU_Type) SetRGDAAC2_M2PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC2.Reg, volatile.LoadUint32(&o.RGDAAC2.Reg)&^(0x20000)|value<<17)
}
func (o *SYSMPU_Type) GetRGDAAC2_M2PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC2.Reg) & 0x20000) >> 17
}
func (o *SYSMPU_Type) SetRGDAAC2_M3UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC2.Reg, volatile.LoadUint32(&o.RGDAAC2.Reg)&^(0x1c0000)|value<<18)
}
func (o *SYSMPU_Type) GetRGDAAC2_M3UM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC2.Reg) & 0x1c0000) >> 18
}
func (o *SYSMPU_Type) SetRGDAAC2_M3SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC2.Reg, volatile.LoadUint32(&o.RGDAAC2.Reg)&^(0x600000)|value<<21)
}
func (o *SYSMPU_Type) GetRGDAAC2_M3SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC2.Reg) & 0x600000) >> 21
}
func (o *SYSMPU_Type) SetRGDAAC2_M3PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC2.Reg, volatile.LoadUint32(&o.RGDAAC2.Reg)&^(0x800000)|value<<23)
}
func (o *SYSMPU_Type) GetRGDAAC2_M3PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC2.Reg) & 0x800000) >> 23
}
func (o *SYSMPU_Type) SetRGDAAC2_M4WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC2.Reg, volatile.LoadUint32(&o.RGDAAC2.Reg)&^(0x1000000)|value<<24)
}
func (o *SYSMPU_Type) GetRGDAAC2_M4WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC2.Reg) & 0x1000000) >> 24
}
func (o *SYSMPU_Type) SetRGDAAC2_M4RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC2.Reg, volatile.LoadUint32(&o.RGDAAC2.Reg)&^(0x2000000)|value<<25)
}
func (o *SYSMPU_Type) GetRGDAAC2_M4RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC2.Reg) & 0x2000000) >> 25
}
func (o *SYSMPU_Type) SetRGDAAC2_M5WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC2.Reg, volatile.LoadUint32(&o.RGDAAC2.Reg)&^(0x4000000)|value<<26)
}
func (o *SYSMPU_Type) GetRGDAAC2_M5WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC2.Reg) & 0x4000000) >> 26
}
func (o *SYSMPU_Type) SetRGDAAC2_M5RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC2.Reg, volatile.LoadUint32(&o.RGDAAC2.Reg)&^(0x8000000)|value<<27)
}
func (o *SYSMPU_Type) GetRGDAAC2_M5RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC2.Reg) & 0x8000000) >> 27
}
func (o *SYSMPU_Type) SetRGDAAC2_M6WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC2.Reg, volatile.LoadUint32(&o.RGDAAC2.Reg)&^(0x10000000)|value<<28)
}
func (o *SYSMPU_Type) GetRGDAAC2_M6WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC2.Reg) & 0x10000000) >> 28
}
func (o *SYSMPU_Type) SetRGDAAC2_M6RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC2.Reg, volatile.LoadUint32(&o.RGDAAC2.Reg)&^(0x20000000)|value<<29)
}
func (o *SYSMPU_Type) GetRGDAAC2_M6RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC2.Reg) & 0x20000000) >> 29
}
func (o *SYSMPU_Type) SetRGDAAC2_M7WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC2.Reg, volatile.LoadUint32(&o.RGDAAC2.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSMPU_Type) GetRGDAAC2_M7WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC2.Reg) & 0x40000000) >> 30
}
func (o *SYSMPU_Type) SetRGDAAC2_M7RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC2.Reg, volatile.LoadUint32(&o.RGDAAC2.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSMPU_Type) GetRGDAAC2_M7RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC2.Reg) & 0x80000000) >> 31
}

// SYSMPU.RGDAAC3: Region Descriptor Alternate Access Control n
func (o *SYSMPU_Type) SetRGDAAC3_M0UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC3.Reg, volatile.LoadUint32(&o.RGDAAC3.Reg)&^(0x7)|value)
}
func (o *SYSMPU_Type) GetRGDAAC3_M0UM() uint32 {
	return volatile.LoadUint32(&o.RGDAAC3.Reg) & 0x7
}
func (o *SYSMPU_Type) SetRGDAAC3_M0SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC3.Reg, volatile.LoadUint32(&o.RGDAAC3.Reg)&^(0x18)|value<<3)
}
func (o *SYSMPU_Type) GetRGDAAC3_M0SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC3.Reg) & 0x18) >> 3
}
func (o *SYSMPU_Type) SetRGDAAC3_M0PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC3.Reg, volatile.LoadUint32(&o.RGDAAC3.Reg)&^(0x20)|value<<5)
}
func (o *SYSMPU_Type) GetRGDAAC3_M0PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC3.Reg) & 0x20) >> 5
}
func (o *SYSMPU_Type) SetRGDAAC3_M1UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC3.Reg, volatile.LoadUint32(&o.RGDAAC3.Reg)&^(0x1c0)|value<<6)
}
func (o *SYSMPU_Type) GetRGDAAC3_M1UM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC3.Reg) & 0x1c0) >> 6
}
func (o *SYSMPU_Type) SetRGDAAC3_M1SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC3.Reg, volatile.LoadUint32(&o.RGDAAC3.Reg)&^(0x600)|value<<9)
}
func (o *SYSMPU_Type) GetRGDAAC3_M1SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC3.Reg) & 0x600) >> 9
}
func (o *SYSMPU_Type) SetRGDAAC3_M1PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC3.Reg, volatile.LoadUint32(&o.RGDAAC3.Reg)&^(0x800)|value<<11)
}
func (o *SYSMPU_Type) GetRGDAAC3_M1PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC3.Reg) & 0x800) >> 11
}
func (o *SYSMPU_Type) SetRGDAAC3_M2UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC3.Reg, volatile.LoadUint32(&o.RGDAAC3.Reg)&^(0x7000)|value<<12)
}
func (o *SYSMPU_Type) GetRGDAAC3_M2UM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC3.Reg) & 0x7000) >> 12
}
func (o *SYSMPU_Type) SetRGDAAC3_M2SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC3.Reg, volatile.LoadUint32(&o.RGDAAC3.Reg)&^(0x18000)|value<<15)
}
func (o *SYSMPU_Type) GetRGDAAC3_M2SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC3.Reg) & 0x18000) >> 15
}
func (o *SYSMPU_Type) SetRGDAAC3_M2PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC3.Reg, volatile.LoadUint32(&o.RGDAAC3.Reg)&^(0x20000)|value<<17)
}
func (o *SYSMPU_Type) GetRGDAAC3_M2PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC3.Reg) & 0x20000) >> 17
}
func (o *SYSMPU_Type) SetRGDAAC3_M3UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC3.Reg, volatile.LoadUint32(&o.RGDAAC3.Reg)&^(0x1c0000)|value<<18)
}
func (o *SYSMPU_Type) GetRGDAAC3_M3UM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC3.Reg) & 0x1c0000) >> 18
}
func (o *SYSMPU_Type) SetRGDAAC3_M3SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC3.Reg, volatile.LoadUint32(&o.RGDAAC3.Reg)&^(0x600000)|value<<21)
}
func (o *SYSMPU_Type) GetRGDAAC3_M3SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC3.Reg) & 0x600000) >> 21
}
func (o *SYSMPU_Type) SetRGDAAC3_M3PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC3.Reg, volatile.LoadUint32(&o.RGDAAC3.Reg)&^(0x800000)|value<<23)
}
func (o *SYSMPU_Type) GetRGDAAC3_M3PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC3.Reg) & 0x800000) >> 23
}
func (o *SYSMPU_Type) SetRGDAAC3_M4WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC3.Reg, volatile.LoadUint32(&o.RGDAAC3.Reg)&^(0x1000000)|value<<24)
}
func (o *SYSMPU_Type) GetRGDAAC3_M4WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC3.Reg) & 0x1000000) >> 24
}
func (o *SYSMPU_Type) SetRGDAAC3_M4RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC3.Reg, volatile.LoadUint32(&o.RGDAAC3.Reg)&^(0x2000000)|value<<25)
}
func (o *SYSMPU_Type) GetRGDAAC3_M4RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC3.Reg) & 0x2000000) >> 25
}
func (o *SYSMPU_Type) SetRGDAAC3_M5WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC3.Reg, volatile.LoadUint32(&o.RGDAAC3.Reg)&^(0x4000000)|value<<26)
}
func (o *SYSMPU_Type) GetRGDAAC3_M5WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC3.Reg) & 0x4000000) >> 26
}
func (o *SYSMPU_Type) SetRGDAAC3_M5RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC3.Reg, volatile.LoadUint32(&o.RGDAAC3.Reg)&^(0x8000000)|value<<27)
}
func (o *SYSMPU_Type) GetRGDAAC3_M5RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC3.Reg) & 0x8000000) >> 27
}
func (o *SYSMPU_Type) SetRGDAAC3_M6WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC3.Reg, volatile.LoadUint32(&o.RGDAAC3.Reg)&^(0x10000000)|value<<28)
}
func (o *SYSMPU_Type) GetRGDAAC3_M6WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC3.Reg) & 0x10000000) >> 28
}
func (o *SYSMPU_Type) SetRGDAAC3_M6RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC3.Reg, volatile.LoadUint32(&o.RGDAAC3.Reg)&^(0x20000000)|value<<29)
}
func (o *SYSMPU_Type) GetRGDAAC3_M6RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC3.Reg) & 0x20000000) >> 29
}
func (o *SYSMPU_Type) SetRGDAAC3_M7WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC3.Reg, volatile.LoadUint32(&o.RGDAAC3.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSMPU_Type) GetRGDAAC3_M7WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC3.Reg) & 0x40000000) >> 30
}
func (o *SYSMPU_Type) SetRGDAAC3_M7RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC3.Reg, volatile.LoadUint32(&o.RGDAAC3.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSMPU_Type) GetRGDAAC3_M7RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC3.Reg) & 0x80000000) >> 31
}

// SYSMPU.RGDAAC4: Region Descriptor Alternate Access Control n
func (o *SYSMPU_Type) SetRGDAAC4_M0UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC4.Reg, volatile.LoadUint32(&o.RGDAAC4.Reg)&^(0x7)|value)
}
func (o *SYSMPU_Type) GetRGDAAC4_M0UM() uint32 {
	return volatile.LoadUint32(&o.RGDAAC4.Reg) & 0x7
}
func (o *SYSMPU_Type) SetRGDAAC4_M0SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC4.Reg, volatile.LoadUint32(&o.RGDAAC4.Reg)&^(0x18)|value<<3)
}
func (o *SYSMPU_Type) GetRGDAAC4_M0SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC4.Reg) & 0x18) >> 3
}
func (o *SYSMPU_Type) SetRGDAAC4_M0PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC4.Reg, volatile.LoadUint32(&o.RGDAAC4.Reg)&^(0x20)|value<<5)
}
func (o *SYSMPU_Type) GetRGDAAC4_M0PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC4.Reg) & 0x20) >> 5
}
func (o *SYSMPU_Type) SetRGDAAC4_M1UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC4.Reg, volatile.LoadUint32(&o.RGDAAC4.Reg)&^(0x1c0)|value<<6)
}
func (o *SYSMPU_Type) GetRGDAAC4_M1UM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC4.Reg) & 0x1c0) >> 6
}
func (o *SYSMPU_Type) SetRGDAAC4_M1SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC4.Reg, volatile.LoadUint32(&o.RGDAAC4.Reg)&^(0x600)|value<<9)
}
func (o *SYSMPU_Type) GetRGDAAC4_M1SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC4.Reg) & 0x600) >> 9
}
func (o *SYSMPU_Type) SetRGDAAC4_M1PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC4.Reg, volatile.LoadUint32(&o.RGDAAC4.Reg)&^(0x800)|value<<11)
}
func (o *SYSMPU_Type) GetRGDAAC4_M1PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC4.Reg) & 0x800) >> 11
}
func (o *SYSMPU_Type) SetRGDAAC4_M2UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC4.Reg, volatile.LoadUint32(&o.RGDAAC4.Reg)&^(0x7000)|value<<12)
}
func (o *SYSMPU_Type) GetRGDAAC4_M2UM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC4.Reg) & 0x7000) >> 12
}
func (o *SYSMPU_Type) SetRGDAAC4_M2SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC4.Reg, volatile.LoadUint32(&o.RGDAAC4.Reg)&^(0x18000)|value<<15)
}
func (o *SYSMPU_Type) GetRGDAAC4_M2SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC4.Reg) & 0x18000) >> 15
}
func (o *SYSMPU_Type) SetRGDAAC4_M2PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC4.Reg, volatile.LoadUint32(&o.RGDAAC4.Reg)&^(0x20000)|value<<17)
}
func (o *SYSMPU_Type) GetRGDAAC4_M2PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC4.Reg) & 0x20000) >> 17
}
func (o *SYSMPU_Type) SetRGDAAC4_M3UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC4.Reg, volatile.LoadUint32(&o.RGDAAC4.Reg)&^(0x1c0000)|value<<18)
}
func (o *SYSMPU_Type) GetRGDAAC4_M3UM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC4.Reg) & 0x1c0000) >> 18
}
func (o *SYSMPU_Type) SetRGDAAC4_M3SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC4.Reg, volatile.LoadUint32(&o.RGDAAC4.Reg)&^(0x600000)|value<<21)
}
func (o *SYSMPU_Type) GetRGDAAC4_M3SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC4.Reg) & 0x600000) >> 21
}
func (o *SYSMPU_Type) SetRGDAAC4_M3PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC4.Reg, volatile.LoadUint32(&o.RGDAAC4.Reg)&^(0x800000)|value<<23)
}
func (o *SYSMPU_Type) GetRGDAAC4_M3PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC4.Reg) & 0x800000) >> 23
}
func (o *SYSMPU_Type) SetRGDAAC4_M4WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC4.Reg, volatile.LoadUint32(&o.RGDAAC4.Reg)&^(0x1000000)|value<<24)
}
func (o *SYSMPU_Type) GetRGDAAC4_M4WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC4.Reg) & 0x1000000) >> 24
}
func (o *SYSMPU_Type) SetRGDAAC4_M4RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC4.Reg, volatile.LoadUint32(&o.RGDAAC4.Reg)&^(0x2000000)|value<<25)
}
func (o *SYSMPU_Type) GetRGDAAC4_M4RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC4.Reg) & 0x2000000) >> 25
}
func (o *SYSMPU_Type) SetRGDAAC4_M5WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC4.Reg, volatile.LoadUint32(&o.RGDAAC4.Reg)&^(0x4000000)|value<<26)
}
func (o *SYSMPU_Type) GetRGDAAC4_M5WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC4.Reg) & 0x4000000) >> 26
}
func (o *SYSMPU_Type) SetRGDAAC4_M5RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC4.Reg, volatile.LoadUint32(&o.RGDAAC4.Reg)&^(0x8000000)|value<<27)
}
func (o *SYSMPU_Type) GetRGDAAC4_M5RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC4.Reg) & 0x8000000) >> 27
}
func (o *SYSMPU_Type) SetRGDAAC4_M6WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC4.Reg, volatile.LoadUint32(&o.RGDAAC4.Reg)&^(0x10000000)|value<<28)
}
func (o *SYSMPU_Type) GetRGDAAC4_M6WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC4.Reg) & 0x10000000) >> 28
}
func (o *SYSMPU_Type) SetRGDAAC4_M6RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC4.Reg, volatile.LoadUint32(&o.RGDAAC4.Reg)&^(0x20000000)|value<<29)
}
func (o *SYSMPU_Type) GetRGDAAC4_M6RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC4.Reg) & 0x20000000) >> 29
}
func (o *SYSMPU_Type) SetRGDAAC4_M7WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC4.Reg, volatile.LoadUint32(&o.RGDAAC4.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSMPU_Type) GetRGDAAC4_M7WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC4.Reg) & 0x40000000) >> 30
}
func (o *SYSMPU_Type) SetRGDAAC4_M7RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC4.Reg, volatile.LoadUint32(&o.RGDAAC4.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSMPU_Type) GetRGDAAC4_M7RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC4.Reg) & 0x80000000) >> 31
}

// SYSMPU.RGDAAC5: Region Descriptor Alternate Access Control n
func (o *SYSMPU_Type) SetRGDAAC5_M0UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC5.Reg, volatile.LoadUint32(&o.RGDAAC5.Reg)&^(0x7)|value)
}
func (o *SYSMPU_Type) GetRGDAAC5_M0UM() uint32 {
	return volatile.LoadUint32(&o.RGDAAC5.Reg) & 0x7
}
func (o *SYSMPU_Type) SetRGDAAC5_M0SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC5.Reg, volatile.LoadUint32(&o.RGDAAC5.Reg)&^(0x18)|value<<3)
}
func (o *SYSMPU_Type) GetRGDAAC5_M0SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC5.Reg) & 0x18) >> 3
}
func (o *SYSMPU_Type) SetRGDAAC5_M0PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC5.Reg, volatile.LoadUint32(&o.RGDAAC5.Reg)&^(0x20)|value<<5)
}
func (o *SYSMPU_Type) GetRGDAAC5_M0PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC5.Reg) & 0x20) >> 5
}
func (o *SYSMPU_Type) SetRGDAAC5_M1UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC5.Reg, volatile.LoadUint32(&o.RGDAAC5.Reg)&^(0x1c0)|value<<6)
}
func (o *SYSMPU_Type) GetRGDAAC5_M1UM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC5.Reg) & 0x1c0) >> 6
}
func (o *SYSMPU_Type) SetRGDAAC5_M1SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC5.Reg, volatile.LoadUint32(&o.RGDAAC5.Reg)&^(0x600)|value<<9)
}
func (o *SYSMPU_Type) GetRGDAAC5_M1SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC5.Reg) & 0x600) >> 9
}
func (o *SYSMPU_Type) SetRGDAAC5_M1PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC5.Reg, volatile.LoadUint32(&o.RGDAAC5.Reg)&^(0x800)|value<<11)
}
func (o *SYSMPU_Type) GetRGDAAC5_M1PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC5.Reg) & 0x800) >> 11
}
func (o *SYSMPU_Type) SetRGDAAC5_M2UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC5.Reg, volatile.LoadUint32(&o.RGDAAC5.Reg)&^(0x7000)|value<<12)
}
func (o *SYSMPU_Type) GetRGDAAC5_M2UM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC5.Reg) & 0x7000) >> 12
}
func (o *SYSMPU_Type) SetRGDAAC5_M2SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC5.Reg, volatile.LoadUint32(&o.RGDAAC5.Reg)&^(0x18000)|value<<15)
}
func (o *SYSMPU_Type) GetRGDAAC5_M2SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC5.Reg) & 0x18000) >> 15
}
func (o *SYSMPU_Type) SetRGDAAC5_M2PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC5.Reg, volatile.LoadUint32(&o.RGDAAC5.Reg)&^(0x20000)|value<<17)
}
func (o *SYSMPU_Type) GetRGDAAC5_M2PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC5.Reg) & 0x20000) >> 17
}
func (o *SYSMPU_Type) SetRGDAAC5_M3UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC5.Reg, volatile.LoadUint32(&o.RGDAAC5.Reg)&^(0x1c0000)|value<<18)
}
func (o *SYSMPU_Type) GetRGDAAC5_M3UM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC5.Reg) & 0x1c0000) >> 18
}
func (o *SYSMPU_Type) SetRGDAAC5_M3SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC5.Reg, volatile.LoadUint32(&o.RGDAAC5.Reg)&^(0x600000)|value<<21)
}
func (o *SYSMPU_Type) GetRGDAAC5_M3SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC5.Reg) & 0x600000) >> 21
}
func (o *SYSMPU_Type) SetRGDAAC5_M3PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC5.Reg, volatile.LoadUint32(&o.RGDAAC5.Reg)&^(0x800000)|value<<23)
}
func (o *SYSMPU_Type) GetRGDAAC5_M3PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC5.Reg) & 0x800000) >> 23
}
func (o *SYSMPU_Type) SetRGDAAC5_M4WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC5.Reg, volatile.LoadUint32(&o.RGDAAC5.Reg)&^(0x1000000)|value<<24)
}
func (o *SYSMPU_Type) GetRGDAAC5_M4WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC5.Reg) & 0x1000000) >> 24
}
func (o *SYSMPU_Type) SetRGDAAC5_M4RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC5.Reg, volatile.LoadUint32(&o.RGDAAC5.Reg)&^(0x2000000)|value<<25)
}
func (o *SYSMPU_Type) GetRGDAAC5_M4RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC5.Reg) & 0x2000000) >> 25
}
func (o *SYSMPU_Type) SetRGDAAC5_M5WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC5.Reg, volatile.LoadUint32(&o.RGDAAC5.Reg)&^(0x4000000)|value<<26)
}
func (o *SYSMPU_Type) GetRGDAAC5_M5WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC5.Reg) & 0x4000000) >> 26
}
func (o *SYSMPU_Type) SetRGDAAC5_M5RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC5.Reg, volatile.LoadUint32(&o.RGDAAC5.Reg)&^(0x8000000)|value<<27)
}
func (o *SYSMPU_Type) GetRGDAAC5_M5RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC5.Reg) & 0x8000000) >> 27
}
func (o *SYSMPU_Type) SetRGDAAC5_M6WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC5.Reg, volatile.LoadUint32(&o.RGDAAC5.Reg)&^(0x10000000)|value<<28)
}
func (o *SYSMPU_Type) GetRGDAAC5_M6WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC5.Reg) & 0x10000000) >> 28
}
func (o *SYSMPU_Type) SetRGDAAC5_M6RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC5.Reg, volatile.LoadUint32(&o.RGDAAC5.Reg)&^(0x20000000)|value<<29)
}
func (o *SYSMPU_Type) GetRGDAAC5_M6RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC5.Reg) & 0x20000000) >> 29
}
func (o *SYSMPU_Type) SetRGDAAC5_M7WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC5.Reg, volatile.LoadUint32(&o.RGDAAC5.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSMPU_Type) GetRGDAAC5_M7WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC5.Reg) & 0x40000000) >> 30
}
func (o *SYSMPU_Type) SetRGDAAC5_M7RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC5.Reg, volatile.LoadUint32(&o.RGDAAC5.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSMPU_Type) GetRGDAAC5_M7RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC5.Reg) & 0x80000000) >> 31
}

// SYSMPU.RGDAAC6: Region Descriptor Alternate Access Control n
func (o *SYSMPU_Type) SetRGDAAC6_M0UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC6.Reg, volatile.LoadUint32(&o.RGDAAC6.Reg)&^(0x7)|value)
}
func (o *SYSMPU_Type) GetRGDAAC6_M0UM() uint32 {
	return volatile.LoadUint32(&o.RGDAAC6.Reg) & 0x7
}
func (o *SYSMPU_Type) SetRGDAAC6_M0SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC6.Reg, volatile.LoadUint32(&o.RGDAAC6.Reg)&^(0x18)|value<<3)
}
func (o *SYSMPU_Type) GetRGDAAC6_M0SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC6.Reg) & 0x18) >> 3
}
func (o *SYSMPU_Type) SetRGDAAC6_M0PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC6.Reg, volatile.LoadUint32(&o.RGDAAC6.Reg)&^(0x20)|value<<5)
}
func (o *SYSMPU_Type) GetRGDAAC6_M0PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC6.Reg) & 0x20) >> 5
}
func (o *SYSMPU_Type) SetRGDAAC6_M1UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC6.Reg, volatile.LoadUint32(&o.RGDAAC6.Reg)&^(0x1c0)|value<<6)
}
func (o *SYSMPU_Type) GetRGDAAC6_M1UM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC6.Reg) & 0x1c0) >> 6
}
func (o *SYSMPU_Type) SetRGDAAC6_M1SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC6.Reg, volatile.LoadUint32(&o.RGDAAC6.Reg)&^(0x600)|value<<9)
}
func (o *SYSMPU_Type) GetRGDAAC6_M1SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC6.Reg) & 0x600) >> 9
}
func (o *SYSMPU_Type) SetRGDAAC6_M1PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC6.Reg, volatile.LoadUint32(&o.RGDAAC6.Reg)&^(0x800)|value<<11)
}
func (o *SYSMPU_Type) GetRGDAAC6_M1PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC6.Reg) & 0x800) >> 11
}
func (o *SYSMPU_Type) SetRGDAAC6_M2UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC6.Reg, volatile.LoadUint32(&o.RGDAAC6.Reg)&^(0x7000)|value<<12)
}
func (o *SYSMPU_Type) GetRGDAAC6_M2UM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC6.Reg) & 0x7000) >> 12
}
func (o *SYSMPU_Type) SetRGDAAC6_M2SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC6.Reg, volatile.LoadUint32(&o.RGDAAC6.Reg)&^(0x18000)|value<<15)
}
func (o *SYSMPU_Type) GetRGDAAC6_M2SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC6.Reg) & 0x18000) >> 15
}
func (o *SYSMPU_Type) SetRGDAAC6_M2PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC6.Reg, volatile.LoadUint32(&o.RGDAAC6.Reg)&^(0x20000)|value<<17)
}
func (o *SYSMPU_Type) GetRGDAAC6_M2PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC6.Reg) & 0x20000) >> 17
}
func (o *SYSMPU_Type) SetRGDAAC6_M3UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC6.Reg, volatile.LoadUint32(&o.RGDAAC6.Reg)&^(0x1c0000)|value<<18)
}
func (o *SYSMPU_Type) GetRGDAAC6_M3UM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC6.Reg) & 0x1c0000) >> 18
}
func (o *SYSMPU_Type) SetRGDAAC6_M3SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC6.Reg, volatile.LoadUint32(&o.RGDAAC6.Reg)&^(0x600000)|value<<21)
}
func (o *SYSMPU_Type) GetRGDAAC6_M3SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC6.Reg) & 0x600000) >> 21
}
func (o *SYSMPU_Type) SetRGDAAC6_M3PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC6.Reg, volatile.LoadUint32(&o.RGDAAC6.Reg)&^(0x800000)|value<<23)
}
func (o *SYSMPU_Type) GetRGDAAC6_M3PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC6.Reg) & 0x800000) >> 23
}
func (o *SYSMPU_Type) SetRGDAAC6_M4WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC6.Reg, volatile.LoadUint32(&o.RGDAAC6.Reg)&^(0x1000000)|value<<24)
}
func (o *SYSMPU_Type) GetRGDAAC6_M4WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC6.Reg) & 0x1000000) >> 24
}
func (o *SYSMPU_Type) SetRGDAAC6_M4RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC6.Reg, volatile.LoadUint32(&o.RGDAAC6.Reg)&^(0x2000000)|value<<25)
}
func (o *SYSMPU_Type) GetRGDAAC6_M4RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC6.Reg) & 0x2000000) >> 25
}
func (o *SYSMPU_Type) SetRGDAAC6_M5WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC6.Reg, volatile.LoadUint32(&o.RGDAAC6.Reg)&^(0x4000000)|value<<26)
}
func (o *SYSMPU_Type) GetRGDAAC6_M5WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC6.Reg) & 0x4000000) >> 26
}
func (o *SYSMPU_Type) SetRGDAAC6_M5RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC6.Reg, volatile.LoadUint32(&o.RGDAAC6.Reg)&^(0x8000000)|value<<27)
}
func (o *SYSMPU_Type) GetRGDAAC6_M5RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC6.Reg) & 0x8000000) >> 27
}
func (o *SYSMPU_Type) SetRGDAAC6_M6WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC6.Reg, volatile.LoadUint32(&o.RGDAAC6.Reg)&^(0x10000000)|value<<28)
}
func (o *SYSMPU_Type) GetRGDAAC6_M6WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC6.Reg) & 0x10000000) >> 28
}
func (o *SYSMPU_Type) SetRGDAAC6_M6RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC6.Reg, volatile.LoadUint32(&o.RGDAAC6.Reg)&^(0x20000000)|value<<29)
}
func (o *SYSMPU_Type) GetRGDAAC6_M6RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC6.Reg) & 0x20000000) >> 29
}
func (o *SYSMPU_Type) SetRGDAAC6_M7WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC6.Reg, volatile.LoadUint32(&o.RGDAAC6.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSMPU_Type) GetRGDAAC6_M7WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC6.Reg) & 0x40000000) >> 30
}
func (o *SYSMPU_Type) SetRGDAAC6_M7RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC6.Reg, volatile.LoadUint32(&o.RGDAAC6.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSMPU_Type) GetRGDAAC6_M7RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC6.Reg) & 0x80000000) >> 31
}

// SYSMPU.RGDAAC7: Region Descriptor Alternate Access Control n
func (o *SYSMPU_Type) SetRGDAAC7_M0UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC7.Reg, volatile.LoadUint32(&o.RGDAAC7.Reg)&^(0x7)|value)
}
func (o *SYSMPU_Type) GetRGDAAC7_M0UM() uint32 {
	return volatile.LoadUint32(&o.RGDAAC7.Reg) & 0x7
}
func (o *SYSMPU_Type) SetRGDAAC7_M0SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC7.Reg, volatile.LoadUint32(&o.RGDAAC7.Reg)&^(0x18)|value<<3)
}
func (o *SYSMPU_Type) GetRGDAAC7_M0SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC7.Reg) & 0x18) >> 3
}
func (o *SYSMPU_Type) SetRGDAAC7_M0PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC7.Reg, volatile.LoadUint32(&o.RGDAAC7.Reg)&^(0x20)|value<<5)
}
func (o *SYSMPU_Type) GetRGDAAC7_M0PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC7.Reg) & 0x20) >> 5
}
func (o *SYSMPU_Type) SetRGDAAC7_M1UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC7.Reg, volatile.LoadUint32(&o.RGDAAC7.Reg)&^(0x1c0)|value<<6)
}
func (o *SYSMPU_Type) GetRGDAAC7_M1UM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC7.Reg) & 0x1c0) >> 6
}
func (o *SYSMPU_Type) SetRGDAAC7_M1SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC7.Reg, volatile.LoadUint32(&o.RGDAAC7.Reg)&^(0x600)|value<<9)
}
func (o *SYSMPU_Type) GetRGDAAC7_M1SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC7.Reg) & 0x600) >> 9
}
func (o *SYSMPU_Type) SetRGDAAC7_M1PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC7.Reg, volatile.LoadUint32(&o.RGDAAC7.Reg)&^(0x800)|value<<11)
}
func (o *SYSMPU_Type) GetRGDAAC7_M1PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC7.Reg) & 0x800) >> 11
}
func (o *SYSMPU_Type) SetRGDAAC7_M2UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC7.Reg, volatile.LoadUint32(&o.RGDAAC7.Reg)&^(0x7000)|value<<12)
}
func (o *SYSMPU_Type) GetRGDAAC7_M2UM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC7.Reg) & 0x7000) >> 12
}
func (o *SYSMPU_Type) SetRGDAAC7_M2SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC7.Reg, volatile.LoadUint32(&o.RGDAAC7.Reg)&^(0x18000)|value<<15)
}
func (o *SYSMPU_Type) GetRGDAAC7_M2SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC7.Reg) & 0x18000) >> 15
}
func (o *SYSMPU_Type) SetRGDAAC7_M2PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC7.Reg, volatile.LoadUint32(&o.RGDAAC7.Reg)&^(0x20000)|value<<17)
}
func (o *SYSMPU_Type) GetRGDAAC7_M2PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC7.Reg) & 0x20000) >> 17
}
func (o *SYSMPU_Type) SetRGDAAC7_M3UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC7.Reg, volatile.LoadUint32(&o.RGDAAC7.Reg)&^(0x1c0000)|value<<18)
}
func (o *SYSMPU_Type) GetRGDAAC7_M3UM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC7.Reg) & 0x1c0000) >> 18
}
func (o *SYSMPU_Type) SetRGDAAC7_M3SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC7.Reg, volatile.LoadUint32(&o.RGDAAC7.Reg)&^(0x600000)|value<<21)
}
func (o *SYSMPU_Type) GetRGDAAC7_M3SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC7.Reg) & 0x600000) >> 21
}
func (o *SYSMPU_Type) SetRGDAAC7_M3PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC7.Reg, volatile.LoadUint32(&o.RGDAAC7.Reg)&^(0x800000)|value<<23)
}
func (o *SYSMPU_Type) GetRGDAAC7_M3PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC7.Reg) & 0x800000) >> 23
}
func (o *SYSMPU_Type) SetRGDAAC7_M4WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC7.Reg, volatile.LoadUint32(&o.RGDAAC7.Reg)&^(0x1000000)|value<<24)
}
func (o *SYSMPU_Type) GetRGDAAC7_M4WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC7.Reg) & 0x1000000) >> 24
}
func (o *SYSMPU_Type) SetRGDAAC7_M4RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC7.Reg, volatile.LoadUint32(&o.RGDAAC7.Reg)&^(0x2000000)|value<<25)
}
func (o *SYSMPU_Type) GetRGDAAC7_M4RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC7.Reg) & 0x2000000) >> 25
}
func (o *SYSMPU_Type) SetRGDAAC7_M5WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC7.Reg, volatile.LoadUint32(&o.RGDAAC7.Reg)&^(0x4000000)|value<<26)
}
func (o *SYSMPU_Type) GetRGDAAC7_M5WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC7.Reg) & 0x4000000) >> 26
}
func (o *SYSMPU_Type) SetRGDAAC7_M5RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC7.Reg, volatile.LoadUint32(&o.RGDAAC7.Reg)&^(0x8000000)|value<<27)
}
func (o *SYSMPU_Type) GetRGDAAC7_M5RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC7.Reg) & 0x8000000) >> 27
}
func (o *SYSMPU_Type) SetRGDAAC7_M6WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC7.Reg, volatile.LoadUint32(&o.RGDAAC7.Reg)&^(0x10000000)|value<<28)
}
func (o *SYSMPU_Type) GetRGDAAC7_M6WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC7.Reg) & 0x10000000) >> 28
}
func (o *SYSMPU_Type) SetRGDAAC7_M6RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC7.Reg, volatile.LoadUint32(&o.RGDAAC7.Reg)&^(0x20000000)|value<<29)
}
func (o *SYSMPU_Type) GetRGDAAC7_M6RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC7.Reg) & 0x20000000) >> 29
}
func (o *SYSMPU_Type) SetRGDAAC7_M7WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC7.Reg, volatile.LoadUint32(&o.RGDAAC7.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSMPU_Type) GetRGDAAC7_M7WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC7.Reg) & 0x40000000) >> 30
}
func (o *SYSMPU_Type) SetRGDAAC7_M7RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC7.Reg, volatile.LoadUint32(&o.RGDAAC7.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSMPU_Type) GetRGDAAC7_M7RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC7.Reg) & 0x80000000) >> 31
}

// SYSMPU.RGDAAC8: Region Descriptor Alternate Access Control n
func (o *SYSMPU_Type) SetRGDAAC8_M0UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC8.Reg, volatile.LoadUint32(&o.RGDAAC8.Reg)&^(0x7)|value)
}
func (o *SYSMPU_Type) GetRGDAAC8_M0UM() uint32 {
	return volatile.LoadUint32(&o.RGDAAC8.Reg) & 0x7
}
func (o *SYSMPU_Type) SetRGDAAC8_M0SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC8.Reg, volatile.LoadUint32(&o.RGDAAC8.Reg)&^(0x18)|value<<3)
}
func (o *SYSMPU_Type) GetRGDAAC8_M0SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC8.Reg) & 0x18) >> 3
}
func (o *SYSMPU_Type) SetRGDAAC8_M0PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC8.Reg, volatile.LoadUint32(&o.RGDAAC8.Reg)&^(0x20)|value<<5)
}
func (o *SYSMPU_Type) GetRGDAAC8_M0PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC8.Reg) & 0x20) >> 5
}
func (o *SYSMPU_Type) SetRGDAAC8_M1UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC8.Reg, volatile.LoadUint32(&o.RGDAAC8.Reg)&^(0x1c0)|value<<6)
}
func (o *SYSMPU_Type) GetRGDAAC8_M1UM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC8.Reg) & 0x1c0) >> 6
}
func (o *SYSMPU_Type) SetRGDAAC8_M1SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC8.Reg, volatile.LoadUint32(&o.RGDAAC8.Reg)&^(0x600)|value<<9)
}
func (o *SYSMPU_Type) GetRGDAAC8_M1SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC8.Reg) & 0x600) >> 9
}
func (o *SYSMPU_Type) SetRGDAAC8_M1PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC8.Reg, volatile.LoadUint32(&o.RGDAAC8.Reg)&^(0x800)|value<<11)
}
func (o *SYSMPU_Type) GetRGDAAC8_M1PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC8.Reg) & 0x800) >> 11
}
func (o *SYSMPU_Type) SetRGDAAC8_M2UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC8.Reg, volatile.LoadUint32(&o.RGDAAC8.Reg)&^(0x7000)|value<<12)
}
func (o *SYSMPU_Type) GetRGDAAC8_M2UM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC8.Reg) & 0x7000) >> 12
}
func (o *SYSMPU_Type) SetRGDAAC8_M2SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC8.Reg, volatile.LoadUint32(&o.RGDAAC8.Reg)&^(0x18000)|value<<15)
}
func (o *SYSMPU_Type) GetRGDAAC8_M2SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC8.Reg) & 0x18000) >> 15
}
func (o *SYSMPU_Type) SetRGDAAC8_M2PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC8.Reg, volatile.LoadUint32(&o.RGDAAC8.Reg)&^(0x20000)|value<<17)
}
func (o *SYSMPU_Type) GetRGDAAC8_M2PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC8.Reg) & 0x20000) >> 17
}
func (o *SYSMPU_Type) SetRGDAAC8_M3UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC8.Reg, volatile.LoadUint32(&o.RGDAAC8.Reg)&^(0x1c0000)|value<<18)
}
func (o *SYSMPU_Type) GetRGDAAC8_M3UM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC8.Reg) & 0x1c0000) >> 18
}
func (o *SYSMPU_Type) SetRGDAAC8_M3SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC8.Reg, volatile.LoadUint32(&o.RGDAAC8.Reg)&^(0x600000)|value<<21)
}
func (o *SYSMPU_Type) GetRGDAAC8_M3SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC8.Reg) & 0x600000) >> 21
}
func (o *SYSMPU_Type) SetRGDAAC8_M3PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC8.Reg, volatile.LoadUint32(&o.RGDAAC8.Reg)&^(0x800000)|value<<23)
}
func (o *SYSMPU_Type) GetRGDAAC8_M3PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC8.Reg) & 0x800000) >> 23
}
func (o *SYSMPU_Type) SetRGDAAC8_M4WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC8.Reg, volatile.LoadUint32(&o.RGDAAC8.Reg)&^(0x1000000)|value<<24)
}
func (o *SYSMPU_Type) GetRGDAAC8_M4WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC8.Reg) & 0x1000000) >> 24
}
func (o *SYSMPU_Type) SetRGDAAC8_M4RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC8.Reg, volatile.LoadUint32(&o.RGDAAC8.Reg)&^(0x2000000)|value<<25)
}
func (o *SYSMPU_Type) GetRGDAAC8_M4RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC8.Reg) & 0x2000000) >> 25
}
func (o *SYSMPU_Type) SetRGDAAC8_M5WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC8.Reg, volatile.LoadUint32(&o.RGDAAC8.Reg)&^(0x4000000)|value<<26)
}
func (o *SYSMPU_Type) GetRGDAAC8_M5WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC8.Reg) & 0x4000000) >> 26
}
func (o *SYSMPU_Type) SetRGDAAC8_M5RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC8.Reg, volatile.LoadUint32(&o.RGDAAC8.Reg)&^(0x8000000)|value<<27)
}
func (o *SYSMPU_Type) GetRGDAAC8_M5RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC8.Reg) & 0x8000000) >> 27
}
func (o *SYSMPU_Type) SetRGDAAC8_M6WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC8.Reg, volatile.LoadUint32(&o.RGDAAC8.Reg)&^(0x10000000)|value<<28)
}
func (o *SYSMPU_Type) GetRGDAAC8_M6WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC8.Reg) & 0x10000000) >> 28
}
func (o *SYSMPU_Type) SetRGDAAC8_M6RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC8.Reg, volatile.LoadUint32(&o.RGDAAC8.Reg)&^(0x20000000)|value<<29)
}
func (o *SYSMPU_Type) GetRGDAAC8_M6RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC8.Reg) & 0x20000000) >> 29
}
func (o *SYSMPU_Type) SetRGDAAC8_M7WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC8.Reg, volatile.LoadUint32(&o.RGDAAC8.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSMPU_Type) GetRGDAAC8_M7WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC8.Reg) & 0x40000000) >> 30
}
func (o *SYSMPU_Type) SetRGDAAC8_M7RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC8.Reg, volatile.LoadUint32(&o.RGDAAC8.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSMPU_Type) GetRGDAAC8_M7RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC8.Reg) & 0x80000000) >> 31
}

// SYSMPU.RGDAAC9: Region Descriptor Alternate Access Control n
func (o *SYSMPU_Type) SetRGDAAC9_M0UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC9.Reg, volatile.LoadUint32(&o.RGDAAC9.Reg)&^(0x7)|value)
}
func (o *SYSMPU_Type) GetRGDAAC9_M0UM() uint32 {
	return volatile.LoadUint32(&o.RGDAAC9.Reg) & 0x7
}
func (o *SYSMPU_Type) SetRGDAAC9_M0SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC9.Reg, volatile.LoadUint32(&o.RGDAAC9.Reg)&^(0x18)|value<<3)
}
func (o *SYSMPU_Type) GetRGDAAC9_M0SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC9.Reg) & 0x18) >> 3
}
func (o *SYSMPU_Type) SetRGDAAC9_M0PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC9.Reg, volatile.LoadUint32(&o.RGDAAC9.Reg)&^(0x20)|value<<5)
}
func (o *SYSMPU_Type) GetRGDAAC9_M0PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC9.Reg) & 0x20) >> 5
}
func (o *SYSMPU_Type) SetRGDAAC9_M1UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC9.Reg, volatile.LoadUint32(&o.RGDAAC9.Reg)&^(0x1c0)|value<<6)
}
func (o *SYSMPU_Type) GetRGDAAC9_M1UM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC9.Reg) & 0x1c0) >> 6
}
func (o *SYSMPU_Type) SetRGDAAC9_M1SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC9.Reg, volatile.LoadUint32(&o.RGDAAC9.Reg)&^(0x600)|value<<9)
}
func (o *SYSMPU_Type) GetRGDAAC9_M1SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC9.Reg) & 0x600) >> 9
}
func (o *SYSMPU_Type) SetRGDAAC9_M1PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC9.Reg, volatile.LoadUint32(&o.RGDAAC9.Reg)&^(0x800)|value<<11)
}
func (o *SYSMPU_Type) GetRGDAAC9_M1PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC9.Reg) & 0x800) >> 11
}
func (o *SYSMPU_Type) SetRGDAAC9_M2UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC9.Reg, volatile.LoadUint32(&o.RGDAAC9.Reg)&^(0x7000)|value<<12)
}
func (o *SYSMPU_Type) GetRGDAAC9_M2UM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC9.Reg) & 0x7000) >> 12
}
func (o *SYSMPU_Type) SetRGDAAC9_M2SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC9.Reg, volatile.LoadUint32(&o.RGDAAC9.Reg)&^(0x18000)|value<<15)
}
func (o *SYSMPU_Type) GetRGDAAC9_M2SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC9.Reg) & 0x18000) >> 15
}
func (o *SYSMPU_Type) SetRGDAAC9_M2PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC9.Reg, volatile.LoadUint32(&o.RGDAAC9.Reg)&^(0x20000)|value<<17)
}
func (o *SYSMPU_Type) GetRGDAAC9_M2PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC9.Reg) & 0x20000) >> 17
}
func (o *SYSMPU_Type) SetRGDAAC9_M3UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC9.Reg, volatile.LoadUint32(&o.RGDAAC9.Reg)&^(0x1c0000)|value<<18)
}
func (o *SYSMPU_Type) GetRGDAAC9_M3UM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC9.Reg) & 0x1c0000) >> 18
}
func (o *SYSMPU_Type) SetRGDAAC9_M3SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC9.Reg, volatile.LoadUint32(&o.RGDAAC9.Reg)&^(0x600000)|value<<21)
}
func (o *SYSMPU_Type) GetRGDAAC9_M3SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC9.Reg) & 0x600000) >> 21
}
func (o *SYSMPU_Type) SetRGDAAC9_M3PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC9.Reg, volatile.LoadUint32(&o.RGDAAC9.Reg)&^(0x800000)|value<<23)
}
func (o *SYSMPU_Type) GetRGDAAC9_M3PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC9.Reg) & 0x800000) >> 23
}
func (o *SYSMPU_Type) SetRGDAAC9_M4WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC9.Reg, volatile.LoadUint32(&o.RGDAAC9.Reg)&^(0x1000000)|value<<24)
}
func (o *SYSMPU_Type) GetRGDAAC9_M4WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC9.Reg) & 0x1000000) >> 24
}
func (o *SYSMPU_Type) SetRGDAAC9_M4RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC9.Reg, volatile.LoadUint32(&o.RGDAAC9.Reg)&^(0x2000000)|value<<25)
}
func (o *SYSMPU_Type) GetRGDAAC9_M4RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC9.Reg) & 0x2000000) >> 25
}
func (o *SYSMPU_Type) SetRGDAAC9_M5WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC9.Reg, volatile.LoadUint32(&o.RGDAAC9.Reg)&^(0x4000000)|value<<26)
}
func (o *SYSMPU_Type) GetRGDAAC9_M5WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC9.Reg) & 0x4000000) >> 26
}
func (o *SYSMPU_Type) SetRGDAAC9_M5RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC9.Reg, volatile.LoadUint32(&o.RGDAAC9.Reg)&^(0x8000000)|value<<27)
}
func (o *SYSMPU_Type) GetRGDAAC9_M5RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC9.Reg) & 0x8000000) >> 27
}
func (o *SYSMPU_Type) SetRGDAAC9_M6WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC9.Reg, volatile.LoadUint32(&o.RGDAAC9.Reg)&^(0x10000000)|value<<28)
}
func (o *SYSMPU_Type) GetRGDAAC9_M6WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC9.Reg) & 0x10000000) >> 28
}
func (o *SYSMPU_Type) SetRGDAAC9_M6RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC9.Reg, volatile.LoadUint32(&o.RGDAAC9.Reg)&^(0x20000000)|value<<29)
}
func (o *SYSMPU_Type) GetRGDAAC9_M6RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC9.Reg) & 0x20000000) >> 29
}
func (o *SYSMPU_Type) SetRGDAAC9_M7WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC9.Reg, volatile.LoadUint32(&o.RGDAAC9.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSMPU_Type) GetRGDAAC9_M7WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC9.Reg) & 0x40000000) >> 30
}
func (o *SYSMPU_Type) SetRGDAAC9_M7RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC9.Reg, volatile.LoadUint32(&o.RGDAAC9.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSMPU_Type) GetRGDAAC9_M7RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC9.Reg) & 0x80000000) >> 31
}

// SYSMPU.RGDAAC10: Region Descriptor Alternate Access Control n
func (o *SYSMPU_Type) SetRGDAAC10_M0UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC10.Reg, volatile.LoadUint32(&o.RGDAAC10.Reg)&^(0x7)|value)
}
func (o *SYSMPU_Type) GetRGDAAC10_M0UM() uint32 {
	return volatile.LoadUint32(&o.RGDAAC10.Reg) & 0x7
}
func (o *SYSMPU_Type) SetRGDAAC10_M0SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC10.Reg, volatile.LoadUint32(&o.RGDAAC10.Reg)&^(0x18)|value<<3)
}
func (o *SYSMPU_Type) GetRGDAAC10_M0SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC10.Reg) & 0x18) >> 3
}
func (o *SYSMPU_Type) SetRGDAAC10_M0PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC10.Reg, volatile.LoadUint32(&o.RGDAAC10.Reg)&^(0x20)|value<<5)
}
func (o *SYSMPU_Type) GetRGDAAC10_M0PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC10.Reg) & 0x20) >> 5
}
func (o *SYSMPU_Type) SetRGDAAC10_M1UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC10.Reg, volatile.LoadUint32(&o.RGDAAC10.Reg)&^(0x1c0)|value<<6)
}
func (o *SYSMPU_Type) GetRGDAAC10_M1UM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC10.Reg) & 0x1c0) >> 6
}
func (o *SYSMPU_Type) SetRGDAAC10_M1SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC10.Reg, volatile.LoadUint32(&o.RGDAAC10.Reg)&^(0x600)|value<<9)
}
func (o *SYSMPU_Type) GetRGDAAC10_M1SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC10.Reg) & 0x600) >> 9
}
func (o *SYSMPU_Type) SetRGDAAC10_M1PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC10.Reg, volatile.LoadUint32(&o.RGDAAC10.Reg)&^(0x800)|value<<11)
}
func (o *SYSMPU_Type) GetRGDAAC10_M1PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC10.Reg) & 0x800) >> 11
}
func (o *SYSMPU_Type) SetRGDAAC10_M2UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC10.Reg, volatile.LoadUint32(&o.RGDAAC10.Reg)&^(0x7000)|value<<12)
}
func (o *SYSMPU_Type) GetRGDAAC10_M2UM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC10.Reg) & 0x7000) >> 12
}
func (o *SYSMPU_Type) SetRGDAAC10_M2SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC10.Reg, volatile.LoadUint32(&o.RGDAAC10.Reg)&^(0x18000)|value<<15)
}
func (o *SYSMPU_Type) GetRGDAAC10_M2SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC10.Reg) & 0x18000) >> 15
}
func (o *SYSMPU_Type) SetRGDAAC10_M2PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC10.Reg, volatile.LoadUint32(&o.RGDAAC10.Reg)&^(0x20000)|value<<17)
}
func (o *SYSMPU_Type) GetRGDAAC10_M2PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC10.Reg) & 0x20000) >> 17
}
func (o *SYSMPU_Type) SetRGDAAC10_M3UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC10.Reg, volatile.LoadUint32(&o.RGDAAC10.Reg)&^(0x1c0000)|value<<18)
}
func (o *SYSMPU_Type) GetRGDAAC10_M3UM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC10.Reg) & 0x1c0000) >> 18
}
func (o *SYSMPU_Type) SetRGDAAC10_M3SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC10.Reg, volatile.LoadUint32(&o.RGDAAC10.Reg)&^(0x600000)|value<<21)
}
func (o *SYSMPU_Type) GetRGDAAC10_M3SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC10.Reg) & 0x600000) >> 21
}
func (o *SYSMPU_Type) SetRGDAAC10_M3PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC10.Reg, volatile.LoadUint32(&o.RGDAAC10.Reg)&^(0x800000)|value<<23)
}
func (o *SYSMPU_Type) GetRGDAAC10_M3PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC10.Reg) & 0x800000) >> 23
}
func (o *SYSMPU_Type) SetRGDAAC10_M4WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC10.Reg, volatile.LoadUint32(&o.RGDAAC10.Reg)&^(0x1000000)|value<<24)
}
func (o *SYSMPU_Type) GetRGDAAC10_M4WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC10.Reg) & 0x1000000) >> 24
}
func (o *SYSMPU_Type) SetRGDAAC10_M4RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC10.Reg, volatile.LoadUint32(&o.RGDAAC10.Reg)&^(0x2000000)|value<<25)
}
func (o *SYSMPU_Type) GetRGDAAC10_M4RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC10.Reg) & 0x2000000) >> 25
}
func (o *SYSMPU_Type) SetRGDAAC10_M5WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC10.Reg, volatile.LoadUint32(&o.RGDAAC10.Reg)&^(0x4000000)|value<<26)
}
func (o *SYSMPU_Type) GetRGDAAC10_M5WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC10.Reg) & 0x4000000) >> 26
}
func (o *SYSMPU_Type) SetRGDAAC10_M5RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC10.Reg, volatile.LoadUint32(&o.RGDAAC10.Reg)&^(0x8000000)|value<<27)
}
func (o *SYSMPU_Type) GetRGDAAC10_M5RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC10.Reg) & 0x8000000) >> 27
}
func (o *SYSMPU_Type) SetRGDAAC10_M6WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC10.Reg, volatile.LoadUint32(&o.RGDAAC10.Reg)&^(0x10000000)|value<<28)
}
func (o *SYSMPU_Type) GetRGDAAC10_M6WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC10.Reg) & 0x10000000) >> 28
}
func (o *SYSMPU_Type) SetRGDAAC10_M6RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC10.Reg, volatile.LoadUint32(&o.RGDAAC10.Reg)&^(0x20000000)|value<<29)
}
func (o *SYSMPU_Type) GetRGDAAC10_M6RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC10.Reg) & 0x20000000) >> 29
}
func (o *SYSMPU_Type) SetRGDAAC10_M7WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC10.Reg, volatile.LoadUint32(&o.RGDAAC10.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSMPU_Type) GetRGDAAC10_M7WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC10.Reg) & 0x40000000) >> 30
}
func (o *SYSMPU_Type) SetRGDAAC10_M7RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC10.Reg, volatile.LoadUint32(&o.RGDAAC10.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSMPU_Type) GetRGDAAC10_M7RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC10.Reg) & 0x80000000) >> 31
}

// SYSMPU.RGDAAC11: Region Descriptor Alternate Access Control n
func (o *SYSMPU_Type) SetRGDAAC11_M0UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC11.Reg, volatile.LoadUint32(&o.RGDAAC11.Reg)&^(0x7)|value)
}
func (o *SYSMPU_Type) GetRGDAAC11_M0UM() uint32 {
	return volatile.LoadUint32(&o.RGDAAC11.Reg) & 0x7
}
func (o *SYSMPU_Type) SetRGDAAC11_M0SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC11.Reg, volatile.LoadUint32(&o.RGDAAC11.Reg)&^(0x18)|value<<3)
}
func (o *SYSMPU_Type) GetRGDAAC11_M0SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC11.Reg) & 0x18) >> 3
}
func (o *SYSMPU_Type) SetRGDAAC11_M0PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC11.Reg, volatile.LoadUint32(&o.RGDAAC11.Reg)&^(0x20)|value<<5)
}
func (o *SYSMPU_Type) GetRGDAAC11_M0PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC11.Reg) & 0x20) >> 5
}
func (o *SYSMPU_Type) SetRGDAAC11_M1UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC11.Reg, volatile.LoadUint32(&o.RGDAAC11.Reg)&^(0x1c0)|value<<6)
}
func (o *SYSMPU_Type) GetRGDAAC11_M1UM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC11.Reg) & 0x1c0) >> 6
}
func (o *SYSMPU_Type) SetRGDAAC11_M1SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC11.Reg, volatile.LoadUint32(&o.RGDAAC11.Reg)&^(0x600)|value<<9)
}
func (o *SYSMPU_Type) GetRGDAAC11_M1SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC11.Reg) & 0x600) >> 9
}
func (o *SYSMPU_Type) SetRGDAAC11_M1PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC11.Reg, volatile.LoadUint32(&o.RGDAAC11.Reg)&^(0x800)|value<<11)
}
func (o *SYSMPU_Type) GetRGDAAC11_M1PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC11.Reg) & 0x800) >> 11
}
func (o *SYSMPU_Type) SetRGDAAC11_M2UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC11.Reg, volatile.LoadUint32(&o.RGDAAC11.Reg)&^(0x7000)|value<<12)
}
func (o *SYSMPU_Type) GetRGDAAC11_M2UM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC11.Reg) & 0x7000) >> 12
}
func (o *SYSMPU_Type) SetRGDAAC11_M2SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC11.Reg, volatile.LoadUint32(&o.RGDAAC11.Reg)&^(0x18000)|value<<15)
}
func (o *SYSMPU_Type) GetRGDAAC11_M2SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC11.Reg) & 0x18000) >> 15
}
func (o *SYSMPU_Type) SetRGDAAC11_M2PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC11.Reg, volatile.LoadUint32(&o.RGDAAC11.Reg)&^(0x20000)|value<<17)
}
func (o *SYSMPU_Type) GetRGDAAC11_M2PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC11.Reg) & 0x20000) >> 17
}
func (o *SYSMPU_Type) SetRGDAAC11_M3UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC11.Reg, volatile.LoadUint32(&o.RGDAAC11.Reg)&^(0x1c0000)|value<<18)
}
func (o *SYSMPU_Type) GetRGDAAC11_M3UM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC11.Reg) & 0x1c0000) >> 18
}
func (o *SYSMPU_Type) SetRGDAAC11_M3SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC11.Reg, volatile.LoadUint32(&o.RGDAAC11.Reg)&^(0x600000)|value<<21)
}
func (o *SYSMPU_Type) GetRGDAAC11_M3SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC11.Reg) & 0x600000) >> 21
}
func (o *SYSMPU_Type) SetRGDAAC11_M3PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC11.Reg, volatile.LoadUint32(&o.RGDAAC11.Reg)&^(0x800000)|value<<23)
}
func (o *SYSMPU_Type) GetRGDAAC11_M3PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC11.Reg) & 0x800000) >> 23
}
func (o *SYSMPU_Type) SetRGDAAC11_M4WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC11.Reg, volatile.LoadUint32(&o.RGDAAC11.Reg)&^(0x1000000)|value<<24)
}
func (o *SYSMPU_Type) GetRGDAAC11_M4WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC11.Reg) & 0x1000000) >> 24
}
func (o *SYSMPU_Type) SetRGDAAC11_M4RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC11.Reg, volatile.LoadUint32(&o.RGDAAC11.Reg)&^(0x2000000)|value<<25)
}
func (o *SYSMPU_Type) GetRGDAAC11_M4RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC11.Reg) & 0x2000000) >> 25
}
func (o *SYSMPU_Type) SetRGDAAC11_M5WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC11.Reg, volatile.LoadUint32(&o.RGDAAC11.Reg)&^(0x4000000)|value<<26)
}
func (o *SYSMPU_Type) GetRGDAAC11_M5WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC11.Reg) & 0x4000000) >> 26
}
func (o *SYSMPU_Type) SetRGDAAC11_M5RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC11.Reg, volatile.LoadUint32(&o.RGDAAC11.Reg)&^(0x8000000)|value<<27)
}
func (o *SYSMPU_Type) GetRGDAAC11_M5RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC11.Reg) & 0x8000000) >> 27
}
func (o *SYSMPU_Type) SetRGDAAC11_M6WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC11.Reg, volatile.LoadUint32(&o.RGDAAC11.Reg)&^(0x10000000)|value<<28)
}
func (o *SYSMPU_Type) GetRGDAAC11_M6WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC11.Reg) & 0x10000000) >> 28
}
func (o *SYSMPU_Type) SetRGDAAC11_M6RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC11.Reg, volatile.LoadUint32(&o.RGDAAC11.Reg)&^(0x20000000)|value<<29)
}
func (o *SYSMPU_Type) GetRGDAAC11_M6RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC11.Reg) & 0x20000000) >> 29
}
func (o *SYSMPU_Type) SetRGDAAC11_M7WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC11.Reg, volatile.LoadUint32(&o.RGDAAC11.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSMPU_Type) GetRGDAAC11_M7WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC11.Reg) & 0x40000000) >> 30
}
func (o *SYSMPU_Type) SetRGDAAC11_M7RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC11.Reg, volatile.LoadUint32(&o.RGDAAC11.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSMPU_Type) GetRGDAAC11_M7RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC11.Reg) & 0x80000000) >> 31
}

// Flash Memory Controller
type FMC_Type struct {
	PFAPR     volatile.Register32 // 0x0
	PFB0CR    volatile.Register32 // 0x4
	PFB1CR    volatile.Register32 // 0x8
	_         [244]byte
	TAGVDW0S0 volatile.Register32 // 0x100
	TAGVDW0S1 volatile.Register32 // 0x104
	TAGVDW0S2 volatile.Register32 // 0x108
	TAGVDW0S3 volatile.Register32 // 0x10C
	TAGVDW1S0 volatile.Register32 // 0x110
	TAGVDW1S1 volatile.Register32 // 0x114
	TAGVDW1S2 volatile.Register32 // 0x118
	TAGVDW1S3 volatile.Register32 // 0x11C
	TAGVDW2S0 volatile.Register32 // 0x120
	TAGVDW2S1 volatile.Register32 // 0x124
	TAGVDW2S2 volatile.Register32 // 0x128
	TAGVDW2S3 volatile.Register32 // 0x12C
	TAGVDW3S0 volatile.Register32 // 0x130
	TAGVDW3S1 volatile.Register32 // 0x134
	TAGVDW3S2 volatile.Register32 // 0x138
	TAGVDW3S3 volatile.Register32 // 0x13C
	_         [192]byte
	DATAW0S0U volatile.Register32 // 0x200
	DATAW0S0L volatile.Register32 // 0x204
	DATAW0S1U volatile.Register32 // 0x208
	DATAW0S1L volatile.Register32 // 0x20C
	DATAW0S2U volatile.Register32 // 0x210
	DATAW0S2L volatile.Register32 // 0x214
	DATAW0S3U volatile.Register32 // 0x218
	DATAW0S3L volatile.Register32 // 0x21C
	DATAW1S0U volatile.Register32 // 0x220
	DATAW1S0L volatile.Register32 // 0x224
	DATAW1S1U volatile.Register32 // 0x228
	DATAW1S1L volatile.Register32 // 0x22C
	DATAW1S2U volatile.Register32 // 0x230
	DATAW1S2L volatile.Register32 // 0x234
	DATAW1S3U volatile.Register32 // 0x238
	DATAW1S3L volatile.Register32 // 0x23C
	DATAW2S0U volatile.Register32 // 0x240
	DATAW2S0L volatile.Register32 // 0x244
	DATAW2S1U volatile.Register32 // 0x248
	DATAW2S1L volatile.Register32 // 0x24C
	DATAW2S2U volatile.Register32 // 0x250
	DATAW2S2L volatile.Register32 // 0x254
	DATAW2S3U volatile.Register32 // 0x258
	DATAW2S3L volatile.Register32 // 0x25C
	DATAW3S0U volatile.Register32 // 0x260
	DATAW3S0L volatile.Register32 // 0x264
	DATAW3S1U volatile.Register32 // 0x268
	DATAW3S1L volatile.Register32 // 0x26C
	DATAW3S2U volatile.Register32 // 0x270
	DATAW3S2L volatile.Register32 // 0x274
	DATAW3S3U volatile.Register32 // 0x278
	DATAW3S3L volatile.Register32 // 0x27C
}

// FMC.PFAPR: Flash Access Protection Register
func (o *FMC_Type) SetPFAPR_M0AP(value uint32) {
	volatile.StoreUint32(&o.PFAPR.Reg, volatile.LoadUint32(&o.PFAPR.Reg)&^(0x3)|value)
}
func (o *FMC_Type) GetPFAPR_M0AP() uint32 {
	return volatile.LoadUint32(&o.PFAPR.Reg) & 0x3
}
func (o *FMC_Type) SetPFAPR_M1AP(value uint32) {
	volatile.StoreUint32(&o.PFAPR.Reg, volatile.LoadUint32(&o.PFAPR.Reg)&^(0xc)|value<<2)
}
func (o *FMC_Type) GetPFAPR_M1AP() uint32 {
	return (volatile.LoadUint32(&o.PFAPR.Reg) & 0xc) >> 2
}
func (o *FMC_Type) SetPFAPR_M2AP(value uint32) {
	volatile.StoreUint32(&o.PFAPR.Reg, volatile.LoadUint32(&o.PFAPR.Reg)&^(0x30)|value<<4)
}
func (o *FMC_Type) GetPFAPR_M2AP() uint32 {
	return (volatile.LoadUint32(&o.PFAPR.Reg) & 0x30) >> 4
}
func (o *FMC_Type) SetPFAPR_M3AP(value uint32) {
	volatile.StoreUint32(&o.PFAPR.Reg, volatile.LoadUint32(&o.PFAPR.Reg)&^(0xc0)|value<<6)
}
func (o *FMC_Type) GetPFAPR_M3AP() uint32 {
	return (volatile.LoadUint32(&o.PFAPR.Reg) & 0xc0) >> 6
}
func (o *FMC_Type) SetPFAPR_M4AP(value uint32) {
	volatile.StoreUint32(&o.PFAPR.Reg, volatile.LoadUint32(&o.PFAPR.Reg)&^(0x300)|value<<8)
}
func (o *FMC_Type) GetPFAPR_M4AP() uint32 {
	return (volatile.LoadUint32(&o.PFAPR.Reg) & 0x300) >> 8
}
func (o *FMC_Type) SetPFAPR_M5AP(value uint32) {
	volatile.StoreUint32(&o.PFAPR.Reg, volatile.LoadUint32(&o.PFAPR.Reg)&^(0xc00)|value<<10)
}
func (o *FMC_Type) GetPFAPR_M5AP() uint32 {
	return (volatile.LoadUint32(&o.PFAPR.Reg) & 0xc00) >> 10
}
func (o *FMC_Type) SetPFAPR_M6AP(value uint32) {
	volatile.StoreUint32(&o.PFAPR.Reg, volatile.LoadUint32(&o.PFAPR.Reg)&^(0x3000)|value<<12)
}
func (o *FMC_Type) GetPFAPR_M6AP() uint32 {
	return (volatile.LoadUint32(&o.PFAPR.Reg) & 0x3000) >> 12
}
func (o *FMC_Type) SetPFAPR_M7AP(value uint32) {
	volatile.StoreUint32(&o.PFAPR.Reg, volatile.LoadUint32(&o.PFAPR.Reg)&^(0xc000)|value<<14)
}
func (o *FMC_Type) GetPFAPR_M7AP() uint32 {
	return (volatile.LoadUint32(&o.PFAPR.Reg) & 0xc000) >> 14
}
func (o *FMC_Type) SetPFAPR_M0PFD(value uint32) {
	volatile.StoreUint32(&o.PFAPR.Reg, volatile.LoadUint32(&o.PFAPR.Reg)&^(0x10000)|value<<16)
}
func (o *FMC_Type) GetPFAPR_M0PFD() uint32 {
	return (volatile.LoadUint32(&o.PFAPR.Reg) & 0x10000) >> 16
}
func (o *FMC_Type) SetPFAPR_M1PFD(value uint32) {
	volatile.StoreUint32(&o.PFAPR.Reg, volatile.LoadUint32(&o.PFAPR.Reg)&^(0x20000)|value<<17)
}
func (o *FMC_Type) GetPFAPR_M1PFD() uint32 {
	return (volatile.LoadUint32(&o.PFAPR.Reg) & 0x20000) >> 17
}
func (o *FMC_Type) SetPFAPR_M2PFD(value uint32) {
	volatile.StoreUint32(&o.PFAPR.Reg, volatile.LoadUint32(&o.PFAPR.Reg)&^(0x40000)|value<<18)
}
func (o *FMC_Type) GetPFAPR_M2PFD() uint32 {
	return (volatile.LoadUint32(&o.PFAPR.Reg) & 0x40000) >> 18
}
func (o *FMC_Type) SetPFAPR_M3PFD(value uint32) {
	volatile.StoreUint32(&o.PFAPR.Reg, volatile.LoadUint32(&o.PFAPR.Reg)&^(0x80000)|value<<19)
}
func (o *FMC_Type) GetPFAPR_M3PFD() uint32 {
	return (volatile.LoadUint32(&o.PFAPR.Reg) & 0x80000) >> 19
}
func (o *FMC_Type) SetPFAPR_M4PFD(value uint32) {
	volatile.StoreUint32(&o.PFAPR.Reg, volatile.LoadUint32(&o.PFAPR.Reg)&^(0x100000)|value<<20)
}
func (o *FMC_Type) GetPFAPR_M4PFD() uint32 {
	return (volatile.LoadUint32(&o.PFAPR.Reg) & 0x100000) >> 20
}
func (o *FMC_Type) SetPFAPR_M5PFD(value uint32) {
	volatile.StoreUint32(&o.PFAPR.Reg, volatile.LoadUint32(&o.PFAPR.Reg)&^(0x200000)|value<<21)
}
func (o *FMC_Type) GetPFAPR_M5PFD() uint32 {
	return (volatile.LoadUint32(&o.PFAPR.Reg) & 0x200000) >> 21
}
func (o *FMC_Type) SetPFAPR_M6PFD(value uint32) {
	volatile.StoreUint32(&o.PFAPR.Reg, volatile.LoadUint32(&o.PFAPR.Reg)&^(0x400000)|value<<22)
}
func (o *FMC_Type) GetPFAPR_M6PFD() uint32 {
	return (volatile.LoadUint32(&o.PFAPR.Reg) & 0x400000) >> 22
}
func (o *FMC_Type) SetPFAPR_M7PFD(value uint32) {
	volatile.StoreUint32(&o.PFAPR.Reg, volatile.LoadUint32(&o.PFAPR.Reg)&^(0x800000)|value<<23)
}
func (o *FMC_Type) GetPFAPR_M7PFD() uint32 {
	return (volatile.LoadUint32(&o.PFAPR.Reg) & 0x800000) >> 23
}

// FMC.PFB0CR: Flash Bank 0 Control Register
func (o *FMC_Type) SetPFB0CR_B0SEBE(value uint32) {
	volatile.StoreUint32(&o.PFB0CR.Reg, volatile.LoadUint32(&o.PFB0CR.Reg)&^(0x1)|value)
}
func (o *FMC_Type) GetPFB0CR_B0SEBE() uint32 {
	return volatile.LoadUint32(&o.PFB0CR.Reg) & 0x1
}
func (o *FMC_Type) SetPFB0CR_B0IPE(value uint32) {
	volatile.StoreUint32(&o.PFB0CR.Reg, volatile.LoadUint32(&o.PFB0CR.Reg)&^(0x2)|value<<1)
}
func (o *FMC_Type) GetPFB0CR_B0IPE() uint32 {
	return (volatile.LoadUint32(&o.PFB0CR.Reg) & 0x2) >> 1
}
func (o *FMC_Type) SetPFB0CR_B0DPE(value uint32) {
	volatile.StoreUint32(&o.PFB0CR.Reg, volatile.LoadUint32(&o.PFB0CR.Reg)&^(0x4)|value<<2)
}
func (o *FMC_Type) GetPFB0CR_B0DPE() uint32 {
	return (volatile.LoadUint32(&o.PFB0CR.Reg) & 0x4) >> 2
}
func (o *FMC_Type) SetPFB0CR_B0ICE(value uint32) {
	volatile.StoreUint32(&o.PFB0CR.Reg, volatile.LoadUint32(&o.PFB0CR.Reg)&^(0x8)|value<<3)
}
func (o *FMC_Type) GetPFB0CR_B0ICE() uint32 {
	return (volatile.LoadUint32(&o.PFB0CR.Reg) & 0x8) >> 3
}
func (o *FMC_Type) SetPFB0CR_B0DCE(value uint32) {
	volatile.StoreUint32(&o.PFB0CR.Reg, volatile.LoadUint32(&o.PFB0CR.Reg)&^(0x10)|value<<4)
}
func (o *FMC_Type) GetPFB0CR_B0DCE() uint32 {
	return (volatile.LoadUint32(&o.PFB0CR.Reg) & 0x10) >> 4
}
func (o *FMC_Type) SetPFB0CR_CRC(value uint32) {
	volatile.StoreUint32(&o.PFB0CR.Reg, volatile.LoadUint32(&o.PFB0CR.Reg)&^(0xe0)|value<<5)
}
func (o *FMC_Type) GetPFB0CR_CRC() uint32 {
	return (volatile.LoadUint32(&o.PFB0CR.Reg) & 0xe0) >> 5
}
func (o *FMC_Type) SetPFB0CR_B0MW(value uint32) {
	volatile.StoreUint32(&o.PFB0CR.Reg, volatile.LoadUint32(&o.PFB0CR.Reg)&^(0x60000)|value<<17)
}
func (o *FMC_Type) GetPFB0CR_B0MW() uint32 {
	return (volatile.LoadUint32(&o.PFB0CR.Reg) & 0x60000) >> 17
}
func (o *FMC_Type) SetPFB0CR_S_B_INV(value uint32) {
	volatile.StoreUint32(&o.PFB0CR.Reg, volatile.LoadUint32(&o.PFB0CR.Reg)&^(0x80000)|value<<19)
}
func (o *FMC_Type) GetPFB0CR_S_B_INV() uint32 {
	return (volatile.LoadUint32(&o.PFB0CR.Reg) & 0x80000) >> 19
}
func (o *FMC_Type) SetPFB0CR_CINV_WAY(value uint32) {
	volatile.StoreUint32(&o.PFB0CR.Reg, volatile.LoadUint32(&o.PFB0CR.Reg)&^(0xf00000)|value<<20)
}
func (o *FMC_Type) GetPFB0CR_CINV_WAY() uint32 {
	return (volatile.LoadUint32(&o.PFB0CR.Reg) & 0xf00000) >> 20
}
func (o *FMC_Type) SetPFB0CR_CLCK_WAY(value uint32) {
	volatile.StoreUint32(&o.PFB0CR.Reg, volatile.LoadUint32(&o.PFB0CR.Reg)&^(0xf000000)|value<<24)
}
func (o *FMC_Type) GetPFB0CR_CLCK_WAY() uint32 {
	return (volatile.LoadUint32(&o.PFB0CR.Reg) & 0xf000000) >> 24
}
func (o *FMC_Type) SetPFB0CR_B0RWSC(value uint32) {
	volatile.StoreUint32(&o.PFB0CR.Reg, volatile.LoadUint32(&o.PFB0CR.Reg)&^(0xf0000000)|value<<28)
}
func (o *FMC_Type) GetPFB0CR_B0RWSC() uint32 {
	return (volatile.LoadUint32(&o.PFB0CR.Reg) & 0xf0000000) >> 28
}

// FMC.PFB1CR: Flash Bank 1 Control Register
func (o *FMC_Type) SetPFB1CR_B1SEBE(value uint32) {
	volatile.StoreUint32(&o.PFB1CR.Reg, volatile.LoadUint32(&o.PFB1CR.Reg)&^(0x1)|value)
}
func (o *FMC_Type) GetPFB1CR_B1SEBE() uint32 {
	return volatile.LoadUint32(&o.PFB1CR.Reg) & 0x1
}
func (o *FMC_Type) SetPFB1CR_B1IPE(value uint32) {
	volatile.StoreUint32(&o.PFB1CR.Reg, volatile.LoadUint32(&o.PFB1CR.Reg)&^(0x2)|value<<1)
}
func (o *FMC_Type) GetPFB1CR_B1IPE() uint32 {
	return (volatile.LoadUint32(&o.PFB1CR.Reg) & 0x2) >> 1
}
func (o *FMC_Type) SetPFB1CR_B1DPE(value uint32) {
	volatile.StoreUint32(&o.PFB1CR.Reg, volatile.LoadUint32(&o.PFB1CR.Reg)&^(0x4)|value<<2)
}
func (o *FMC_Type) GetPFB1CR_B1DPE() uint32 {
	return (volatile.LoadUint32(&o.PFB1CR.Reg) & 0x4) >> 2
}
func (o *FMC_Type) SetPFB1CR_B1ICE(value uint32) {
	volatile.StoreUint32(&o.PFB1CR.Reg, volatile.LoadUint32(&o.PFB1CR.Reg)&^(0x8)|value<<3)
}
func (o *FMC_Type) GetPFB1CR_B1ICE() uint32 {
	return (volatile.LoadUint32(&o.PFB1CR.Reg) & 0x8) >> 3
}
func (o *FMC_Type) SetPFB1CR_B1DCE(value uint32) {
	volatile.StoreUint32(&o.PFB1CR.Reg, volatile.LoadUint32(&o.PFB1CR.Reg)&^(0x10)|value<<4)
}
func (o *FMC_Type) GetPFB1CR_B1DCE() uint32 {
	return (volatile.LoadUint32(&o.PFB1CR.Reg) & 0x10) >> 4
}
func (o *FMC_Type) SetPFB1CR_B1MW(value uint32) {
	volatile.StoreUint32(&o.PFB1CR.Reg, volatile.LoadUint32(&o.PFB1CR.Reg)&^(0x60000)|value<<17)
}
func (o *FMC_Type) GetPFB1CR_B1MW() uint32 {
	return (volatile.LoadUint32(&o.PFB1CR.Reg) & 0x60000) >> 17
}
func (o *FMC_Type) SetPFB1CR_B1RWSC(value uint32) {
	volatile.StoreUint32(&o.PFB1CR.Reg, volatile.LoadUint32(&o.PFB1CR.Reg)&^(0xf0000000)|value<<28)
}
func (o *FMC_Type) GetPFB1CR_B1RWSC() uint32 {
	return (volatile.LoadUint32(&o.PFB1CR.Reg) & 0xf0000000) >> 28
}

// FMC.TAGVDW0S0: Cache Tag Storage
func (o *FMC_Type) SetTAGVDW0S0_VALID(value uint32) {
	volatile.StoreUint32(&o.TAGVDW0S0.Reg, volatile.LoadUint32(&o.TAGVDW0S0.Reg)&^(0x1)|value)
}
func (o *FMC_Type) GetTAGVDW0S0_VALID() uint32 {
	return volatile.LoadUint32(&o.TAGVDW0S0.Reg) & 0x1
}
func (o *FMC_Type) SetTAGVDW0S0_TAG(value uint32) {
	volatile.StoreUint32(&o.TAGVDW0S0.Reg, volatile.LoadUint32(&o.TAGVDW0S0.Reg)&^(0x7ffe0)|value<<5)
}
func (o *FMC_Type) GetTAGVDW0S0_TAG() uint32 {
	return (volatile.LoadUint32(&o.TAGVDW0S0.Reg) & 0x7ffe0) >> 5
}

// FMC.TAGVDW0S1: Cache Tag Storage
func (o *FMC_Type) SetTAGVDW0S1_VALID(value uint32) {
	volatile.StoreUint32(&o.TAGVDW0S1.Reg, volatile.LoadUint32(&o.TAGVDW0S1.Reg)&^(0x1)|value)
}
func (o *FMC_Type) GetTAGVDW0S1_VALID() uint32 {
	return volatile.LoadUint32(&o.TAGVDW0S1.Reg) & 0x1
}
func (o *FMC_Type) SetTAGVDW0S1_TAG(value uint32) {
	volatile.StoreUint32(&o.TAGVDW0S1.Reg, volatile.LoadUint32(&o.TAGVDW0S1.Reg)&^(0x7ffe0)|value<<5)
}
func (o *FMC_Type) GetTAGVDW0S1_TAG() uint32 {
	return (volatile.LoadUint32(&o.TAGVDW0S1.Reg) & 0x7ffe0) >> 5
}

// FMC.TAGVDW0S2: Cache Tag Storage
func (o *FMC_Type) SetTAGVDW0S2_VALID(value uint32) {
	volatile.StoreUint32(&o.TAGVDW0S2.Reg, volatile.LoadUint32(&o.TAGVDW0S2.Reg)&^(0x1)|value)
}
func (o *FMC_Type) GetTAGVDW0S2_VALID() uint32 {
	return volatile.LoadUint32(&o.TAGVDW0S2.Reg) & 0x1
}
func (o *FMC_Type) SetTAGVDW0S2_TAG(value uint32) {
	volatile.StoreUint32(&o.TAGVDW0S2.Reg, volatile.LoadUint32(&o.TAGVDW0S2.Reg)&^(0x7ffe0)|value<<5)
}
func (o *FMC_Type) GetTAGVDW0S2_TAG() uint32 {
	return (volatile.LoadUint32(&o.TAGVDW0S2.Reg) & 0x7ffe0) >> 5
}

// FMC.TAGVDW0S3: Cache Tag Storage
func (o *FMC_Type) SetTAGVDW0S3_VALID(value uint32) {
	volatile.StoreUint32(&o.TAGVDW0S3.Reg, volatile.LoadUint32(&o.TAGVDW0S3.Reg)&^(0x1)|value)
}
func (o *FMC_Type) GetTAGVDW0S3_VALID() uint32 {
	return volatile.LoadUint32(&o.TAGVDW0S3.Reg) & 0x1
}
func (o *FMC_Type) SetTAGVDW0S3_TAG(value uint32) {
	volatile.StoreUint32(&o.TAGVDW0S3.Reg, volatile.LoadUint32(&o.TAGVDW0S3.Reg)&^(0x7ffe0)|value<<5)
}
func (o *FMC_Type) GetTAGVDW0S3_TAG() uint32 {
	return (volatile.LoadUint32(&o.TAGVDW0S3.Reg) & 0x7ffe0) >> 5
}

// FMC.TAGVDW1S0: Cache Tag Storage
func (o *FMC_Type) SetTAGVDW1S0_VALID(value uint32) {
	volatile.StoreUint32(&o.TAGVDW1S0.Reg, volatile.LoadUint32(&o.TAGVDW1S0.Reg)&^(0x1)|value)
}
func (o *FMC_Type) GetTAGVDW1S0_VALID() uint32 {
	return volatile.LoadUint32(&o.TAGVDW1S0.Reg) & 0x1
}
func (o *FMC_Type) SetTAGVDW1S0_TAG(value uint32) {
	volatile.StoreUint32(&o.TAGVDW1S0.Reg, volatile.LoadUint32(&o.TAGVDW1S0.Reg)&^(0x7ffe0)|value<<5)
}
func (o *FMC_Type) GetTAGVDW1S0_TAG() uint32 {
	return (volatile.LoadUint32(&o.TAGVDW1S0.Reg) & 0x7ffe0) >> 5
}

// FMC.TAGVDW1S1: Cache Tag Storage
func (o *FMC_Type) SetTAGVDW1S1_VALID(value uint32) {
	volatile.StoreUint32(&o.TAGVDW1S1.Reg, volatile.LoadUint32(&o.TAGVDW1S1.Reg)&^(0x1)|value)
}
func (o *FMC_Type) GetTAGVDW1S1_VALID() uint32 {
	return volatile.LoadUint32(&o.TAGVDW1S1.Reg) & 0x1
}
func (o *FMC_Type) SetTAGVDW1S1_TAG(value uint32) {
	volatile.StoreUint32(&o.TAGVDW1S1.Reg, volatile.LoadUint32(&o.TAGVDW1S1.Reg)&^(0x7ffe0)|value<<5)
}
func (o *FMC_Type) GetTAGVDW1S1_TAG() uint32 {
	return (volatile.LoadUint32(&o.TAGVDW1S1.Reg) & 0x7ffe0) >> 5
}

// FMC.TAGVDW1S2: Cache Tag Storage
func (o *FMC_Type) SetTAGVDW1S2_VALID(value uint32) {
	volatile.StoreUint32(&o.TAGVDW1S2.Reg, volatile.LoadUint32(&o.TAGVDW1S2.Reg)&^(0x1)|value)
}
func (o *FMC_Type) GetTAGVDW1S2_VALID() uint32 {
	return volatile.LoadUint32(&o.TAGVDW1S2.Reg) & 0x1
}
func (o *FMC_Type) SetTAGVDW1S2_TAG(value uint32) {
	volatile.StoreUint32(&o.TAGVDW1S2.Reg, volatile.LoadUint32(&o.TAGVDW1S2.Reg)&^(0x7ffe0)|value<<5)
}
func (o *FMC_Type) GetTAGVDW1S2_TAG() uint32 {
	return (volatile.LoadUint32(&o.TAGVDW1S2.Reg) & 0x7ffe0) >> 5
}

// FMC.TAGVDW1S3: Cache Tag Storage
func (o *FMC_Type) SetTAGVDW1S3_VALID(value uint32) {
	volatile.StoreUint32(&o.TAGVDW1S3.Reg, volatile.LoadUint32(&o.TAGVDW1S3.Reg)&^(0x1)|value)
}
func (o *FMC_Type) GetTAGVDW1S3_VALID() uint32 {
	return volatile.LoadUint32(&o.TAGVDW1S3.Reg) & 0x1
}
func (o *FMC_Type) SetTAGVDW1S3_TAG(value uint32) {
	volatile.StoreUint32(&o.TAGVDW1S3.Reg, volatile.LoadUint32(&o.TAGVDW1S3.Reg)&^(0x7ffe0)|value<<5)
}
func (o *FMC_Type) GetTAGVDW1S3_TAG() uint32 {
	return (volatile.LoadUint32(&o.TAGVDW1S3.Reg) & 0x7ffe0) >> 5
}

// FMC.TAGVDW2S0: Cache Tag Storage
func (o *FMC_Type) SetTAGVDW2S0_VALID(value uint32) {
	volatile.StoreUint32(&o.TAGVDW2S0.Reg, volatile.LoadUint32(&o.TAGVDW2S0.Reg)&^(0x1)|value)
}
func (o *FMC_Type) GetTAGVDW2S0_VALID() uint32 {
	return volatile.LoadUint32(&o.TAGVDW2S0.Reg) & 0x1
}
func (o *FMC_Type) SetTAGVDW2S0_TAG(value uint32) {
	volatile.StoreUint32(&o.TAGVDW2S0.Reg, volatile.LoadUint32(&o.TAGVDW2S0.Reg)&^(0x7ffe0)|value<<5)
}
func (o *FMC_Type) GetTAGVDW2S0_TAG() uint32 {
	return (volatile.LoadUint32(&o.TAGVDW2S0.Reg) & 0x7ffe0) >> 5
}

// FMC.TAGVDW2S1: Cache Tag Storage
func (o *FMC_Type) SetTAGVDW2S1_VALID(value uint32) {
	volatile.StoreUint32(&o.TAGVDW2S1.Reg, volatile.LoadUint32(&o.TAGVDW2S1.Reg)&^(0x1)|value)
}
func (o *FMC_Type) GetTAGVDW2S1_VALID() uint32 {
	return volatile.LoadUint32(&o.TAGVDW2S1.Reg) & 0x1
}
func (o *FMC_Type) SetTAGVDW2S1_TAG(value uint32) {
	volatile.StoreUint32(&o.TAGVDW2S1.Reg, volatile.LoadUint32(&o.TAGVDW2S1.Reg)&^(0x7ffe0)|value<<5)
}
func (o *FMC_Type) GetTAGVDW2S1_TAG() uint32 {
	return (volatile.LoadUint32(&o.TAGVDW2S1.Reg) & 0x7ffe0) >> 5
}

// FMC.TAGVDW2S2: Cache Tag Storage
func (o *FMC_Type) SetTAGVDW2S2_VALID(value uint32) {
	volatile.StoreUint32(&o.TAGVDW2S2.Reg, volatile.LoadUint32(&o.TAGVDW2S2.Reg)&^(0x1)|value)
}
func (o *FMC_Type) GetTAGVDW2S2_VALID() uint32 {
	return volatile.LoadUint32(&o.TAGVDW2S2.Reg) & 0x1
}
func (o *FMC_Type) SetTAGVDW2S2_TAG(value uint32) {
	volatile.StoreUint32(&o.TAGVDW2S2.Reg, volatile.LoadUint32(&o.TAGVDW2S2.Reg)&^(0x7ffe0)|value<<5)
}
func (o *FMC_Type) GetTAGVDW2S2_TAG() uint32 {
	return (volatile.LoadUint32(&o.TAGVDW2S2.Reg) & 0x7ffe0) >> 5
}

// FMC.TAGVDW2S3: Cache Tag Storage
func (o *FMC_Type) SetTAGVDW2S3_VALID(value uint32) {
	volatile.StoreUint32(&o.TAGVDW2S3.Reg, volatile.LoadUint32(&o.TAGVDW2S3.Reg)&^(0x1)|value)
}
func (o *FMC_Type) GetTAGVDW2S3_VALID() uint32 {
	return volatile.LoadUint32(&o.TAGVDW2S3.Reg) & 0x1
}
func (o *FMC_Type) SetTAGVDW2S3_TAG(value uint32) {
	volatile.StoreUint32(&o.TAGVDW2S3.Reg, volatile.LoadUint32(&o.TAGVDW2S3.Reg)&^(0x7ffe0)|value<<5)
}
func (o *FMC_Type) GetTAGVDW2S3_TAG() uint32 {
	return (volatile.LoadUint32(&o.TAGVDW2S3.Reg) & 0x7ffe0) >> 5
}

// FMC.TAGVDW3S0: Cache Tag Storage
func (o *FMC_Type) SetTAGVDW3S0_VALID(value uint32) {
	volatile.StoreUint32(&o.TAGVDW3S0.Reg, volatile.LoadUint32(&o.TAGVDW3S0.Reg)&^(0x1)|value)
}
func (o *FMC_Type) GetTAGVDW3S0_VALID() uint32 {
	return volatile.LoadUint32(&o.TAGVDW3S0.Reg) & 0x1
}
func (o *FMC_Type) SetTAGVDW3S0_TAG(value uint32) {
	volatile.StoreUint32(&o.TAGVDW3S0.Reg, volatile.LoadUint32(&o.TAGVDW3S0.Reg)&^(0x7ffe0)|value<<5)
}
func (o *FMC_Type) GetTAGVDW3S0_TAG() uint32 {
	return (volatile.LoadUint32(&o.TAGVDW3S0.Reg) & 0x7ffe0) >> 5
}

// FMC.TAGVDW3S1: Cache Tag Storage
func (o *FMC_Type) SetTAGVDW3S1_VALID(value uint32) {
	volatile.StoreUint32(&o.TAGVDW3S1.Reg, volatile.LoadUint32(&o.TAGVDW3S1.Reg)&^(0x1)|value)
}
func (o *FMC_Type) GetTAGVDW3S1_VALID() uint32 {
	return volatile.LoadUint32(&o.TAGVDW3S1.Reg) & 0x1
}
func (o *FMC_Type) SetTAGVDW3S1_TAG(value uint32) {
	volatile.StoreUint32(&o.TAGVDW3S1.Reg, volatile.LoadUint32(&o.TAGVDW3S1.Reg)&^(0x7ffe0)|value<<5)
}
func (o *FMC_Type) GetTAGVDW3S1_TAG() uint32 {
	return (volatile.LoadUint32(&o.TAGVDW3S1.Reg) & 0x7ffe0) >> 5
}

// FMC.TAGVDW3S2: Cache Tag Storage
func (o *FMC_Type) SetTAGVDW3S2_VALID(value uint32) {
	volatile.StoreUint32(&o.TAGVDW3S2.Reg, volatile.LoadUint32(&o.TAGVDW3S2.Reg)&^(0x1)|value)
}
func (o *FMC_Type) GetTAGVDW3S2_VALID() uint32 {
	return volatile.LoadUint32(&o.TAGVDW3S2.Reg) & 0x1
}
func (o *FMC_Type) SetTAGVDW3S2_TAG(value uint32) {
	volatile.StoreUint32(&o.TAGVDW3S2.Reg, volatile.LoadUint32(&o.TAGVDW3S2.Reg)&^(0x7ffe0)|value<<5)
}
func (o *FMC_Type) GetTAGVDW3S2_TAG() uint32 {
	return (volatile.LoadUint32(&o.TAGVDW3S2.Reg) & 0x7ffe0) >> 5
}

// FMC.TAGVDW3S3: Cache Tag Storage
func (o *FMC_Type) SetTAGVDW3S3_VALID(value uint32) {
	volatile.StoreUint32(&o.TAGVDW3S3.Reg, volatile.LoadUint32(&o.TAGVDW3S3.Reg)&^(0x1)|value)
}
func (o *FMC_Type) GetTAGVDW3S3_VALID() uint32 {
	return volatile.LoadUint32(&o.TAGVDW3S3.Reg) & 0x1
}
func (o *FMC_Type) SetTAGVDW3S3_TAG(value uint32) {
	volatile.StoreUint32(&o.TAGVDW3S3.Reg, volatile.LoadUint32(&o.TAGVDW3S3.Reg)&^(0x7ffe0)|value<<5)
}
func (o *FMC_Type) GetTAGVDW3S3_TAG() uint32 {
	return (volatile.LoadUint32(&o.TAGVDW3S3.Reg) & 0x7ffe0) >> 5
}

// FMC.DATAW0S0U: Cache Data Storage (upper word)
func (o *FMC_Type) SetDATAW0S0U(value uint32) {
	volatile.StoreUint32(&o.DATAW0S0U.Reg, value)
}
func (o *FMC_Type) GetDATAW0S0U() uint32 {
	return volatile.LoadUint32(&o.DATAW0S0U.Reg)
}

// FMC.DATAW0S0L: Cache Data Storage (lower word)
func (o *FMC_Type) SetDATAW0S0L(value uint32) {
	volatile.StoreUint32(&o.DATAW0S0L.Reg, value)
}
func (o *FMC_Type) GetDATAW0S0L() uint32 {
	return volatile.LoadUint32(&o.DATAW0S0L.Reg)
}

// FMC.DATAW0S1U: Cache Data Storage (upper word)
func (o *FMC_Type) SetDATAW0S1U(value uint32) {
	volatile.StoreUint32(&o.DATAW0S1U.Reg, value)
}
func (o *FMC_Type) GetDATAW0S1U() uint32 {
	return volatile.LoadUint32(&o.DATAW0S1U.Reg)
}

// FMC.DATAW0S1L: Cache Data Storage (lower word)
func (o *FMC_Type) SetDATAW0S1L(value uint32) {
	volatile.StoreUint32(&o.DATAW0S1L.Reg, value)
}
func (o *FMC_Type) GetDATAW0S1L() uint32 {
	return volatile.LoadUint32(&o.DATAW0S1L.Reg)
}

// FMC.DATAW0S2U: Cache Data Storage (upper word)
func (o *FMC_Type) SetDATAW0S2U(value uint32) {
	volatile.StoreUint32(&o.DATAW0S2U.Reg, value)
}
func (o *FMC_Type) GetDATAW0S2U() uint32 {
	return volatile.LoadUint32(&o.DATAW0S2U.Reg)
}

// FMC.DATAW0S2L: Cache Data Storage (lower word)
func (o *FMC_Type) SetDATAW0S2L(value uint32) {
	volatile.StoreUint32(&o.DATAW0S2L.Reg, value)
}
func (o *FMC_Type) GetDATAW0S2L() uint32 {
	return volatile.LoadUint32(&o.DATAW0S2L.Reg)
}

// FMC.DATAW0S3U: Cache Data Storage (upper word)
func (o *FMC_Type) SetDATAW0S3U(value uint32) {
	volatile.StoreUint32(&o.DATAW0S3U.Reg, value)
}
func (o *FMC_Type) GetDATAW0S3U() uint32 {
	return volatile.LoadUint32(&o.DATAW0S3U.Reg)
}

// FMC.DATAW0S3L: Cache Data Storage (lower word)
func (o *FMC_Type) SetDATAW0S3L(value uint32) {
	volatile.StoreUint32(&o.DATAW0S3L.Reg, value)
}
func (o *FMC_Type) GetDATAW0S3L() uint32 {
	return volatile.LoadUint32(&o.DATAW0S3L.Reg)
}

// FMC.DATAW1S0U: Cache Data Storage (upper word)
func (o *FMC_Type) SetDATAW1S0U(value uint32) {
	volatile.StoreUint32(&o.DATAW1S0U.Reg, value)
}
func (o *FMC_Type) GetDATAW1S0U() uint32 {
	return volatile.LoadUint32(&o.DATAW1S0U.Reg)
}

// FMC.DATAW1S0L: Cache Data Storage (lower word)
func (o *FMC_Type) SetDATAW1S0L(value uint32) {
	volatile.StoreUint32(&o.DATAW1S0L.Reg, value)
}
func (o *FMC_Type) GetDATAW1S0L() uint32 {
	return volatile.LoadUint32(&o.DATAW1S0L.Reg)
}

// FMC.DATAW1S1U: Cache Data Storage (upper word)
func (o *FMC_Type) SetDATAW1S1U(value uint32) {
	volatile.StoreUint32(&o.DATAW1S1U.Reg, value)
}
func (o *FMC_Type) GetDATAW1S1U() uint32 {
	return volatile.LoadUint32(&o.DATAW1S1U.Reg)
}

// FMC.DATAW1S1L: Cache Data Storage (lower word)
func (o *FMC_Type) SetDATAW1S1L(value uint32) {
	volatile.StoreUint32(&o.DATAW1S1L.Reg, value)
}
func (o *FMC_Type) GetDATAW1S1L() uint32 {
	return volatile.LoadUint32(&o.DATAW1S1L.Reg)
}

// FMC.DATAW1S2U: Cache Data Storage (upper word)
func (o *FMC_Type) SetDATAW1S2U(value uint32) {
	volatile.StoreUint32(&o.DATAW1S2U.Reg, value)
}
func (o *FMC_Type) GetDATAW1S2U() uint32 {
	return volatile.LoadUint32(&o.DATAW1S2U.Reg)
}

// FMC.DATAW1S2L: Cache Data Storage (lower word)
func (o *FMC_Type) SetDATAW1S2L(value uint32) {
	volatile.StoreUint32(&o.DATAW1S2L.Reg, value)
}
func (o *FMC_Type) GetDATAW1S2L() uint32 {
	return volatile.LoadUint32(&o.DATAW1S2L.Reg)
}

// FMC.DATAW1S3U: Cache Data Storage (upper word)
func (o *FMC_Type) SetDATAW1S3U(value uint32) {
	volatile.StoreUint32(&o.DATAW1S3U.Reg, value)
}
func (o *FMC_Type) GetDATAW1S3U() uint32 {
	return volatile.LoadUint32(&o.DATAW1S3U.Reg)
}

// FMC.DATAW1S3L: Cache Data Storage (lower word)
func (o *FMC_Type) SetDATAW1S3L(value uint32) {
	volatile.StoreUint32(&o.DATAW1S3L.Reg, value)
}
func (o *FMC_Type) GetDATAW1S3L() uint32 {
	return volatile.LoadUint32(&o.DATAW1S3L.Reg)
}

// FMC.DATAW2S0U: Cache Data Storage (upper word)
func (o *FMC_Type) SetDATAW2S0U(value uint32) {
	volatile.StoreUint32(&o.DATAW2S0U.Reg, value)
}
func (o *FMC_Type) GetDATAW2S0U() uint32 {
	return volatile.LoadUint32(&o.DATAW2S0U.Reg)
}

// FMC.DATAW2S0L: Cache Data Storage (lower word)
func (o *FMC_Type) SetDATAW2S0L(value uint32) {
	volatile.StoreUint32(&o.DATAW2S0L.Reg, value)
}
func (o *FMC_Type) GetDATAW2S0L() uint32 {
	return volatile.LoadUint32(&o.DATAW2S0L.Reg)
}

// FMC.DATAW2S1U: Cache Data Storage (upper word)
func (o *FMC_Type) SetDATAW2S1U(value uint32) {
	volatile.StoreUint32(&o.DATAW2S1U.Reg, value)
}
func (o *FMC_Type) GetDATAW2S1U() uint32 {
	return volatile.LoadUint32(&o.DATAW2S1U.Reg)
}

// FMC.DATAW2S1L: Cache Data Storage (lower word)
func (o *FMC_Type) SetDATAW2S1L(value uint32) {
	volatile.StoreUint32(&o.DATAW2S1L.Reg, value)
}
func (o *FMC_Type) GetDATAW2S1L() uint32 {
	return volatile.LoadUint32(&o.DATAW2S1L.Reg)
}

// FMC.DATAW2S2U: Cache Data Storage (upper word)
func (o *FMC_Type) SetDATAW2S2U(value uint32) {
	volatile.StoreUint32(&o.DATAW2S2U.Reg, value)
}
func (o *FMC_Type) GetDATAW2S2U() uint32 {
	return volatile.LoadUint32(&o.DATAW2S2U.Reg)
}

// FMC.DATAW2S2L: Cache Data Storage (lower word)
func (o *FMC_Type) SetDATAW2S2L(value uint32) {
	volatile.StoreUint32(&o.DATAW2S2L.Reg, value)
}
func (o *FMC_Type) GetDATAW2S2L() uint32 {
	return volatile.LoadUint32(&o.DATAW2S2L.Reg)
}

// FMC.DATAW2S3U: Cache Data Storage (upper word)
func (o *FMC_Type) SetDATAW2S3U(value uint32) {
	volatile.StoreUint32(&o.DATAW2S3U.Reg, value)
}
func (o *FMC_Type) GetDATAW2S3U() uint32 {
	return volatile.LoadUint32(&o.DATAW2S3U.Reg)
}

// FMC.DATAW2S3L: Cache Data Storage (lower word)
func (o *FMC_Type) SetDATAW2S3L(value uint32) {
	volatile.StoreUint32(&o.DATAW2S3L.Reg, value)
}
func (o *FMC_Type) GetDATAW2S3L() uint32 {
	return volatile.LoadUint32(&o.DATAW2S3L.Reg)
}

// FMC.DATAW3S0U: Cache Data Storage (upper word)
func (o *FMC_Type) SetDATAW3S0U(value uint32) {
	volatile.StoreUint32(&o.DATAW3S0U.Reg, value)
}
func (o *FMC_Type) GetDATAW3S0U() uint32 {
	return volatile.LoadUint32(&o.DATAW3S0U.Reg)
}

// FMC.DATAW3S0L: Cache Data Storage (lower word)
func (o *FMC_Type) SetDATAW3S0L(value uint32) {
	volatile.StoreUint32(&o.DATAW3S0L.Reg, value)
}
func (o *FMC_Type) GetDATAW3S0L() uint32 {
	return volatile.LoadUint32(&o.DATAW3S0L.Reg)
}

// FMC.DATAW3S1U: Cache Data Storage (upper word)
func (o *FMC_Type) SetDATAW3S1U(value uint32) {
	volatile.StoreUint32(&o.DATAW3S1U.Reg, value)
}
func (o *FMC_Type) GetDATAW3S1U() uint32 {
	return volatile.LoadUint32(&o.DATAW3S1U.Reg)
}

// FMC.DATAW3S1L: Cache Data Storage (lower word)
func (o *FMC_Type) SetDATAW3S1L(value uint32) {
	volatile.StoreUint32(&o.DATAW3S1L.Reg, value)
}
func (o *FMC_Type) GetDATAW3S1L() uint32 {
	return volatile.LoadUint32(&o.DATAW3S1L.Reg)
}

// FMC.DATAW3S2U: Cache Data Storage (upper word)
func (o *FMC_Type) SetDATAW3S2U(value uint32) {
	volatile.StoreUint32(&o.DATAW3S2U.Reg, value)
}
func (o *FMC_Type) GetDATAW3S2U() uint32 {
	return volatile.LoadUint32(&o.DATAW3S2U.Reg)
}

// FMC.DATAW3S2L: Cache Data Storage (lower word)
func (o *FMC_Type) SetDATAW3S2L(value uint32) {
	volatile.StoreUint32(&o.DATAW3S2L.Reg, value)
}
func (o *FMC_Type) GetDATAW3S2L() uint32 {
	return volatile.LoadUint32(&o.DATAW3S2L.Reg)
}

// FMC.DATAW3S3U: Cache Data Storage (upper word)
func (o *FMC_Type) SetDATAW3S3U(value uint32) {
	volatile.StoreUint32(&o.DATAW3S3U.Reg, value)
}
func (o *FMC_Type) GetDATAW3S3U() uint32 {
	return volatile.LoadUint32(&o.DATAW3S3U.Reg)
}

// FMC.DATAW3S3L: Cache Data Storage (lower word)
func (o *FMC_Type) SetDATAW3S3L(value uint32) {
	volatile.StoreUint32(&o.DATAW3S3L.Reg, value)
}
func (o *FMC_Type) GetDATAW3S3L() uint32 {
	return volatile.LoadUint32(&o.DATAW3S3L.Reg)
}

// Flash Memory Interface
type FTFE_Type struct {
	FSTAT  volatile.Register8 // 0x0
	FCNFG  volatile.Register8 // 0x1
	FSEC   volatile.Register8 // 0x2
	FOPT   volatile.Register8 // 0x3
	FCCOB3 volatile.Register8 // 0x4
	FCCOB2 volatile.Register8 // 0x5
	FCCOB1 volatile.Register8 // 0x6
	FCCOB0 volatile.Register8 // 0x7
	FCCOB7 volatile.Register8 // 0x8
	FCCOB6 volatile.Register8 // 0x9
	FCCOB5 volatile.Register8 // 0xA
	FCCOB4 volatile.Register8 // 0xB
	FCCOBB volatile.Register8 // 0xC
	FCCOBA volatile.Register8 // 0xD
	FCCOB9 volatile.Register8 // 0xE
	FCCOB8 volatile.Register8 // 0xF
	FPROT3 volatile.Register8 // 0x10
	FPROT2 volatile.Register8 // 0x11
	FPROT1 volatile.Register8 // 0x12
	FPROT0 volatile.Register8 // 0x13
	_      [2]byte
	FEPROT volatile.Register8 // 0x16
	FDPROT volatile.Register8 // 0x17
}

// FTFE.FSTAT: Flash Status Register
func (o *FTFE_Type) SetFSTAT_MGSTAT0(value uint8) {
	volatile.StoreUint8(&o.FSTAT.Reg, volatile.LoadUint8(&o.FSTAT.Reg)&^(0x1)|value)
}
func (o *FTFE_Type) GetFSTAT_MGSTAT0() uint8 {
	return volatile.LoadUint8(&o.FSTAT.Reg) & 0x1
}
func (o *FTFE_Type) SetFSTAT_FPVIOL(value uint8) {
	volatile.StoreUint8(&o.FSTAT.Reg, volatile.LoadUint8(&o.FSTAT.Reg)&^(0x10)|value<<4)
}
func (o *FTFE_Type) GetFSTAT_FPVIOL() uint8 {
	return (volatile.LoadUint8(&o.FSTAT.Reg) & 0x10) >> 4
}
func (o *FTFE_Type) SetFSTAT_ACCERR(value uint8) {
	volatile.StoreUint8(&o.FSTAT.Reg, volatile.LoadUint8(&o.FSTAT.Reg)&^(0x20)|value<<5)
}
func (o *FTFE_Type) GetFSTAT_ACCERR() uint8 {
	return (volatile.LoadUint8(&o.FSTAT.Reg) & 0x20) >> 5
}
func (o *FTFE_Type) SetFSTAT_RDCOLERR(value uint8) {
	volatile.StoreUint8(&o.FSTAT.Reg, volatile.LoadUint8(&o.FSTAT.Reg)&^(0x40)|value<<6)
}
func (o *FTFE_Type) GetFSTAT_RDCOLERR() uint8 {
	return (volatile.LoadUint8(&o.FSTAT.Reg) & 0x40) >> 6
}
func (o *FTFE_Type) SetFSTAT_CCIF(value uint8) {
	volatile.StoreUint8(&o.FSTAT.Reg, volatile.LoadUint8(&o.FSTAT.Reg)&^(0x80)|value<<7)
}
func (o *FTFE_Type) GetFSTAT_CCIF() uint8 {
	return (volatile.LoadUint8(&o.FSTAT.Reg) & 0x80) >> 7
}

// FTFE.FCNFG: Flash Configuration Register
func (o *FTFE_Type) SetFCNFG_EEERDY(value uint8) {
	volatile.StoreUint8(&o.FCNFG.Reg, volatile.LoadUint8(&o.FCNFG.Reg)&^(0x1)|value)
}
func (o *FTFE_Type) GetFCNFG_EEERDY() uint8 {
	return volatile.LoadUint8(&o.FCNFG.Reg) & 0x1
}
func (o *FTFE_Type) SetFCNFG_RAMRDY(value uint8) {
	volatile.StoreUint8(&o.FCNFG.Reg, volatile.LoadUint8(&o.FCNFG.Reg)&^(0x2)|value<<1)
}
func (o *FTFE_Type) GetFCNFG_RAMRDY() uint8 {
	return (volatile.LoadUint8(&o.FCNFG.Reg) & 0x2) >> 1
}
func (o *FTFE_Type) SetFCNFG_PFLSH(value uint8) {
	volatile.StoreUint8(&o.FCNFG.Reg, volatile.LoadUint8(&o.FCNFG.Reg)&^(0x4)|value<<2)
}
func (o *FTFE_Type) GetFCNFG_PFLSH() uint8 {
	return (volatile.LoadUint8(&o.FCNFG.Reg) & 0x4) >> 2
}
func (o *FTFE_Type) SetFCNFG_SWAP(value uint8) {
	volatile.StoreUint8(&o.FCNFG.Reg, volatile.LoadUint8(&o.FCNFG.Reg)&^(0x8)|value<<3)
}
func (o *FTFE_Type) GetFCNFG_SWAP() uint8 {
	return (volatile.LoadUint8(&o.FCNFG.Reg) & 0x8) >> 3
}
func (o *FTFE_Type) SetFCNFG_ERSSUSP(value uint8) {
	volatile.StoreUint8(&o.FCNFG.Reg, volatile.LoadUint8(&o.FCNFG.Reg)&^(0x10)|value<<4)
}
func (o *FTFE_Type) GetFCNFG_ERSSUSP() uint8 {
	return (volatile.LoadUint8(&o.FCNFG.Reg) & 0x10) >> 4
}
func (o *FTFE_Type) SetFCNFG_ERSAREQ(value uint8) {
	volatile.StoreUint8(&o.FCNFG.Reg, volatile.LoadUint8(&o.FCNFG.Reg)&^(0x20)|value<<5)
}
func (o *FTFE_Type) GetFCNFG_ERSAREQ() uint8 {
	return (volatile.LoadUint8(&o.FCNFG.Reg) & 0x20) >> 5
}
func (o *FTFE_Type) SetFCNFG_RDCOLLIE(value uint8) {
	volatile.StoreUint8(&o.FCNFG.Reg, volatile.LoadUint8(&o.FCNFG.Reg)&^(0x40)|value<<6)
}
func (o *FTFE_Type) GetFCNFG_RDCOLLIE() uint8 {
	return (volatile.LoadUint8(&o.FCNFG.Reg) & 0x40) >> 6
}
func (o *FTFE_Type) SetFCNFG_CCIE(value uint8) {
	volatile.StoreUint8(&o.FCNFG.Reg, volatile.LoadUint8(&o.FCNFG.Reg)&^(0x80)|value<<7)
}
func (o *FTFE_Type) GetFCNFG_CCIE() uint8 {
	return (volatile.LoadUint8(&o.FCNFG.Reg) & 0x80) >> 7
}

// FTFE.FSEC: Flash Security Register
func (o *FTFE_Type) SetFSEC_SEC(value uint8) {
	volatile.StoreUint8(&o.FSEC.Reg, volatile.LoadUint8(&o.FSEC.Reg)&^(0x3)|value)
}
func (o *FTFE_Type) GetFSEC_SEC() uint8 {
	return volatile.LoadUint8(&o.FSEC.Reg) & 0x3
}
func (o *FTFE_Type) SetFSEC_FSLACC(value uint8) {
	volatile.StoreUint8(&o.FSEC.Reg, volatile.LoadUint8(&o.FSEC.Reg)&^(0xc)|value<<2)
}
func (o *FTFE_Type) GetFSEC_FSLACC() uint8 {
	return (volatile.LoadUint8(&o.FSEC.Reg) & 0xc) >> 2
}
func (o *FTFE_Type) SetFSEC_MEEN(value uint8) {
	volatile.StoreUint8(&o.FSEC.Reg, volatile.LoadUint8(&o.FSEC.Reg)&^(0x30)|value<<4)
}
func (o *FTFE_Type) GetFSEC_MEEN() uint8 {
	return (volatile.LoadUint8(&o.FSEC.Reg) & 0x30) >> 4
}
func (o *FTFE_Type) SetFSEC_KEYEN(value uint8) {
	volatile.StoreUint8(&o.FSEC.Reg, volatile.LoadUint8(&o.FSEC.Reg)&^(0xc0)|value<<6)
}
func (o *FTFE_Type) GetFSEC_KEYEN() uint8 {
	return (volatile.LoadUint8(&o.FSEC.Reg) & 0xc0) >> 6
}

// FTFE.FOPT: Flash Option Register
func (o *FTFE_Type) SetFOPT(value uint8) {
	volatile.StoreUint8(&o.FOPT.Reg, value)
}
func (o *FTFE_Type) GetFOPT() uint8 {
	return volatile.LoadUint8(&o.FOPT.Reg)
}

// FTFE.FCCOB3: Flash Common Command Object Registers
func (o *FTFE_Type) SetFCCOB3(value uint8) {
	volatile.StoreUint8(&o.FCCOB3.Reg, value)
}
func (o *FTFE_Type) GetFCCOB3() uint8 {
	return volatile.LoadUint8(&o.FCCOB3.Reg)
}

// FTFE.FCCOB2: Flash Common Command Object Registers
func (o *FTFE_Type) SetFCCOB2(value uint8) {
	volatile.StoreUint8(&o.FCCOB2.Reg, value)
}
func (o *FTFE_Type) GetFCCOB2() uint8 {
	return volatile.LoadUint8(&o.FCCOB2.Reg)
}

// FTFE.FCCOB1: Flash Common Command Object Registers
func (o *FTFE_Type) SetFCCOB1(value uint8) {
	volatile.StoreUint8(&o.FCCOB1.Reg, value)
}
func (o *FTFE_Type) GetFCCOB1() uint8 {
	return volatile.LoadUint8(&o.FCCOB1.Reg)
}

// FTFE.FCCOB0: Flash Common Command Object Registers
func (o *FTFE_Type) SetFCCOB0(value uint8) {
	volatile.StoreUint8(&o.FCCOB0.Reg, value)
}
func (o *FTFE_Type) GetFCCOB0() uint8 {
	return volatile.LoadUint8(&o.FCCOB0.Reg)
}

// FTFE.FCCOB7: Flash Common Command Object Registers
func (o *FTFE_Type) SetFCCOB7(value uint8) {
	volatile.StoreUint8(&o.FCCOB7.Reg, value)
}
func (o *FTFE_Type) GetFCCOB7() uint8 {
	return volatile.LoadUint8(&o.FCCOB7.Reg)
}

// FTFE.FCCOB6: Flash Common Command Object Registers
func (o *FTFE_Type) SetFCCOB6(value uint8) {
	volatile.StoreUint8(&o.FCCOB6.Reg, value)
}
func (o *FTFE_Type) GetFCCOB6() uint8 {
	return volatile.LoadUint8(&o.FCCOB6.Reg)
}

// FTFE.FCCOB5: Flash Common Command Object Registers
func (o *FTFE_Type) SetFCCOB5(value uint8) {
	volatile.StoreUint8(&o.FCCOB5.Reg, value)
}
func (o *FTFE_Type) GetFCCOB5() uint8 {
	return volatile.LoadUint8(&o.FCCOB5.Reg)
}

// FTFE.FCCOB4: Flash Common Command Object Registers
func (o *FTFE_Type) SetFCCOB4(value uint8) {
	volatile.StoreUint8(&o.FCCOB4.Reg, value)
}
func (o *FTFE_Type) GetFCCOB4() uint8 {
	return volatile.LoadUint8(&o.FCCOB4.Reg)
}

// FTFE.FCCOBB: Flash Common Command Object Registers
func (o *FTFE_Type) SetFCCOBB(value uint8) {
	volatile.StoreUint8(&o.FCCOBB.Reg, value)
}
func (o *FTFE_Type) GetFCCOBB() uint8 {
	return volatile.LoadUint8(&o.FCCOBB.Reg)
}

// FTFE.FCCOBA: Flash Common Command Object Registers
func (o *FTFE_Type) SetFCCOBA(value uint8) {
	volatile.StoreUint8(&o.FCCOBA.Reg, value)
}
func (o *FTFE_Type) GetFCCOBA() uint8 {
	return volatile.LoadUint8(&o.FCCOBA.Reg)
}

// FTFE.FCCOB9: Flash Common Command Object Registers
func (o *FTFE_Type) SetFCCOB9(value uint8) {
	volatile.StoreUint8(&o.FCCOB9.Reg, value)
}
func (o *FTFE_Type) GetFCCOB9() uint8 {
	return volatile.LoadUint8(&o.FCCOB9.Reg)
}

// FTFE.FCCOB8: Flash Common Command Object Registers
func (o *FTFE_Type) SetFCCOB8(value uint8) {
	volatile.StoreUint8(&o.FCCOB8.Reg, value)
}
func (o *FTFE_Type) GetFCCOB8() uint8 {
	return volatile.LoadUint8(&o.FCCOB8.Reg)
}

// FTFE.FPROT3: Program Flash Protection Registers
func (o *FTFE_Type) SetFPROT3(value uint8) {
	volatile.StoreUint8(&o.FPROT3.Reg, value)
}
func (o *FTFE_Type) GetFPROT3() uint8 {
	return volatile.LoadUint8(&o.FPROT3.Reg)
}

// FTFE.FPROT2: Program Flash Protection Registers
func (o *FTFE_Type) SetFPROT2(value uint8) {
	volatile.StoreUint8(&o.FPROT2.Reg, value)
}
func (o *FTFE_Type) GetFPROT2() uint8 {
	return volatile.LoadUint8(&o.FPROT2.Reg)
}

// FTFE.FPROT1: Program Flash Protection Registers
func (o *FTFE_Type) SetFPROT1(value uint8) {
	volatile.StoreUint8(&o.FPROT1.Reg, value)
}
func (o *FTFE_Type) GetFPROT1() uint8 {
	return volatile.LoadUint8(&o.FPROT1.Reg)
}

// FTFE.FPROT0: Program Flash Protection Registers
func (o *FTFE_Type) SetFPROT0(value uint8) {
	volatile.StoreUint8(&o.FPROT0.Reg, value)
}
func (o *FTFE_Type) GetFPROT0() uint8 {
	return volatile.LoadUint8(&o.FPROT0.Reg)
}

// FTFE.FEPROT: EEPROM Protection Register
func (o *FTFE_Type) SetFEPROT(value uint8) {
	volatile.StoreUint8(&o.FEPROT.Reg, value)
}
func (o *FTFE_Type) GetFEPROT() uint8 {
	return volatile.LoadUint8(&o.FEPROT.Reg)
}

// FTFE.FDPROT: Data Flash Protection Register
func (o *FTFE_Type) SetFDPROT(value uint8) {
	volatile.StoreUint8(&o.FDPROT.Reg, value)
}
func (o *FTFE_Type) GetFDPROT() uint8 {
	return volatile.LoadUint8(&o.FDPROT.Reg)
}

// DMA channel multiplexor
type DMAMUX_Type struct {
	CHCFG0  volatile.Register8 // 0x0
	CHCFG1  volatile.Register8 // 0x1
	CHCFG2  volatile.Register8 // 0x2
	CHCFG3  volatile.Register8 // 0x3
	CHCFG4  volatile.Register8 // 0x4
	CHCFG5  volatile.Register8 // 0x5
	CHCFG6  volatile.Register8 // 0x6
	CHCFG7  volatile.Register8 // 0x7
	CHCFG8  volatile.Register8 // 0x8
	CHCFG9  volatile.Register8 // 0x9
	CHCFG10 volatile.Register8 // 0xA
	CHCFG11 volatile.Register8 // 0xB
	CHCFG12 volatile.Register8 // 0xC
	CHCFG13 volatile.Register8 // 0xD
	CHCFG14 volatile.Register8 // 0xE
	CHCFG15 volatile.Register8 // 0xF
}

// DMAMUX.CHCFG0: Channel Configuration register
func (o *DMAMUX_Type) SetCHCFG0_SOURCE(value uint8) {
	volatile.StoreUint8(&o.CHCFG0.Reg, volatile.LoadUint8(&o.CHCFG0.Reg)&^(0x3f)|value)
}
func (o *DMAMUX_Type) GetCHCFG0_SOURCE() uint8 {
	return volatile.LoadUint8(&o.CHCFG0.Reg) & 0x3f
}
func (o *DMAMUX_Type) SetCHCFG0_TRIG(value uint8) {
	volatile.StoreUint8(&o.CHCFG0.Reg, volatile.LoadUint8(&o.CHCFG0.Reg)&^(0x40)|value<<6)
}
func (o *DMAMUX_Type) GetCHCFG0_TRIG() uint8 {
	return (volatile.LoadUint8(&o.CHCFG0.Reg) & 0x40) >> 6
}
func (o *DMAMUX_Type) SetCHCFG0_ENBL(value uint8) {
	volatile.StoreUint8(&o.CHCFG0.Reg, volatile.LoadUint8(&o.CHCFG0.Reg)&^(0x80)|value<<7)
}
func (o *DMAMUX_Type) GetCHCFG0_ENBL() uint8 {
	return (volatile.LoadUint8(&o.CHCFG0.Reg) & 0x80) >> 7
}

// DMAMUX.CHCFG1: Channel Configuration register
func (o *DMAMUX_Type) SetCHCFG1_SOURCE(value uint8) {
	volatile.StoreUint8(&o.CHCFG1.Reg, volatile.LoadUint8(&o.CHCFG1.Reg)&^(0x3f)|value)
}
func (o *DMAMUX_Type) GetCHCFG1_SOURCE() uint8 {
	return volatile.LoadUint8(&o.CHCFG1.Reg) & 0x3f
}
func (o *DMAMUX_Type) SetCHCFG1_TRIG(value uint8) {
	volatile.StoreUint8(&o.CHCFG1.Reg, volatile.LoadUint8(&o.CHCFG1.Reg)&^(0x40)|value<<6)
}
func (o *DMAMUX_Type) GetCHCFG1_TRIG() uint8 {
	return (volatile.LoadUint8(&o.CHCFG1.Reg) & 0x40) >> 6
}
func (o *DMAMUX_Type) SetCHCFG1_ENBL(value uint8) {
	volatile.StoreUint8(&o.CHCFG1.Reg, volatile.LoadUint8(&o.CHCFG1.Reg)&^(0x80)|value<<7)
}
func (o *DMAMUX_Type) GetCHCFG1_ENBL() uint8 {
	return (volatile.LoadUint8(&o.CHCFG1.Reg) & 0x80) >> 7
}

// DMAMUX.CHCFG2: Channel Configuration register
func (o *DMAMUX_Type) SetCHCFG2_SOURCE(value uint8) {
	volatile.StoreUint8(&o.CHCFG2.Reg, volatile.LoadUint8(&o.CHCFG2.Reg)&^(0x3f)|value)
}
func (o *DMAMUX_Type) GetCHCFG2_SOURCE() uint8 {
	return volatile.LoadUint8(&o.CHCFG2.Reg) & 0x3f
}
func (o *DMAMUX_Type) SetCHCFG2_TRIG(value uint8) {
	volatile.StoreUint8(&o.CHCFG2.Reg, volatile.LoadUint8(&o.CHCFG2.Reg)&^(0x40)|value<<6)
}
func (o *DMAMUX_Type) GetCHCFG2_TRIG() uint8 {
	return (volatile.LoadUint8(&o.CHCFG2.Reg) & 0x40) >> 6
}
func (o *DMAMUX_Type) SetCHCFG2_ENBL(value uint8) {
	volatile.StoreUint8(&o.CHCFG2.Reg, volatile.LoadUint8(&o.CHCFG2.Reg)&^(0x80)|value<<7)
}
func (o *DMAMUX_Type) GetCHCFG2_ENBL() uint8 {
	return (volatile.LoadUint8(&o.CHCFG2.Reg) & 0x80) >> 7
}

// DMAMUX.CHCFG3: Channel Configuration register
func (o *DMAMUX_Type) SetCHCFG3_SOURCE(value uint8) {
	volatile.StoreUint8(&o.CHCFG3.Reg, volatile.LoadUint8(&o.CHCFG3.Reg)&^(0x3f)|value)
}
func (o *DMAMUX_Type) GetCHCFG3_SOURCE() uint8 {
	return volatile.LoadUint8(&o.CHCFG3.Reg) & 0x3f
}
func (o *DMAMUX_Type) SetCHCFG3_TRIG(value uint8) {
	volatile.StoreUint8(&o.CHCFG3.Reg, volatile.LoadUint8(&o.CHCFG3.Reg)&^(0x40)|value<<6)
}
func (o *DMAMUX_Type) GetCHCFG3_TRIG() uint8 {
	return (volatile.LoadUint8(&o.CHCFG3.Reg) & 0x40) >> 6
}
func (o *DMAMUX_Type) SetCHCFG3_ENBL(value uint8) {
	volatile.StoreUint8(&o.CHCFG3.Reg, volatile.LoadUint8(&o.CHCFG3.Reg)&^(0x80)|value<<7)
}
func (o *DMAMUX_Type) GetCHCFG3_ENBL() uint8 {
	return (volatile.LoadUint8(&o.CHCFG3.Reg) & 0x80) >> 7
}

// DMAMUX.CHCFG4: Channel Configuration register
func (o *DMAMUX_Type) SetCHCFG4_SOURCE(value uint8) {
	volatile.StoreUint8(&o.CHCFG4.Reg, volatile.LoadUint8(&o.CHCFG4.Reg)&^(0x3f)|value)
}
func (o *DMAMUX_Type) GetCHCFG4_SOURCE() uint8 {
	return volatile.LoadUint8(&o.CHCFG4.Reg) & 0x3f
}
func (o *DMAMUX_Type) SetCHCFG4_TRIG(value uint8) {
	volatile.StoreUint8(&o.CHCFG4.Reg, volatile.LoadUint8(&o.CHCFG4.Reg)&^(0x40)|value<<6)
}
func (o *DMAMUX_Type) GetCHCFG4_TRIG() uint8 {
	return (volatile.LoadUint8(&o.CHCFG4.Reg) & 0x40) >> 6
}
func (o *DMAMUX_Type) SetCHCFG4_ENBL(value uint8) {
	volatile.StoreUint8(&o.CHCFG4.Reg, volatile.LoadUint8(&o.CHCFG4.Reg)&^(0x80)|value<<7)
}
func (o *DMAMUX_Type) GetCHCFG4_ENBL() uint8 {
	return (volatile.LoadUint8(&o.CHCFG4.Reg) & 0x80) >> 7
}

// DMAMUX.CHCFG5: Channel Configuration register
func (o *DMAMUX_Type) SetCHCFG5_SOURCE(value uint8) {
	volatile.StoreUint8(&o.CHCFG5.Reg, volatile.LoadUint8(&o.CHCFG5.Reg)&^(0x3f)|value)
}
func (o *DMAMUX_Type) GetCHCFG5_SOURCE() uint8 {
	return volatile.LoadUint8(&o.CHCFG5.Reg) & 0x3f
}
func (o *DMAMUX_Type) SetCHCFG5_TRIG(value uint8) {
	volatile.StoreUint8(&o.CHCFG5.Reg, volatile.LoadUint8(&o.CHCFG5.Reg)&^(0x40)|value<<6)
}
func (o *DMAMUX_Type) GetCHCFG5_TRIG() uint8 {
	return (volatile.LoadUint8(&o.CHCFG5.Reg) & 0x40) >> 6
}
func (o *DMAMUX_Type) SetCHCFG5_ENBL(value uint8) {
	volatile.StoreUint8(&o.CHCFG5.Reg, volatile.LoadUint8(&o.CHCFG5.Reg)&^(0x80)|value<<7)
}
func (o *DMAMUX_Type) GetCHCFG5_ENBL() uint8 {
	return (volatile.LoadUint8(&o.CHCFG5.Reg) & 0x80) >> 7
}

// DMAMUX.CHCFG6: Channel Configuration register
func (o *DMAMUX_Type) SetCHCFG6_SOURCE(value uint8) {
	volatile.StoreUint8(&o.CHCFG6.Reg, volatile.LoadUint8(&o.CHCFG6.Reg)&^(0x3f)|value)
}
func (o *DMAMUX_Type) GetCHCFG6_SOURCE() uint8 {
	return volatile.LoadUint8(&o.CHCFG6.Reg) & 0x3f
}
func (o *DMAMUX_Type) SetCHCFG6_TRIG(value uint8) {
	volatile.StoreUint8(&o.CHCFG6.Reg, volatile.LoadUint8(&o.CHCFG6.Reg)&^(0x40)|value<<6)
}
func (o *DMAMUX_Type) GetCHCFG6_TRIG() uint8 {
	return (volatile.LoadUint8(&o.CHCFG6.Reg) & 0x40) >> 6
}
func (o *DMAMUX_Type) SetCHCFG6_ENBL(value uint8) {
	volatile.StoreUint8(&o.CHCFG6.Reg, volatile.LoadUint8(&o.CHCFG6.Reg)&^(0x80)|value<<7)
}
func (o *DMAMUX_Type) GetCHCFG6_ENBL() uint8 {
	return (volatile.LoadUint8(&o.CHCFG6.Reg) & 0x80) >> 7
}

// DMAMUX.CHCFG7: Channel Configuration register
func (o *DMAMUX_Type) SetCHCFG7_SOURCE(value uint8) {
	volatile.StoreUint8(&o.CHCFG7.Reg, volatile.LoadUint8(&o.CHCFG7.Reg)&^(0x3f)|value)
}
func (o *DMAMUX_Type) GetCHCFG7_SOURCE() uint8 {
	return volatile.LoadUint8(&o.CHCFG7.Reg) & 0x3f
}
func (o *DMAMUX_Type) SetCHCFG7_TRIG(value uint8) {
	volatile.StoreUint8(&o.CHCFG7.Reg, volatile.LoadUint8(&o.CHCFG7.Reg)&^(0x40)|value<<6)
}
func (o *DMAMUX_Type) GetCHCFG7_TRIG() uint8 {
	return (volatile.LoadUint8(&o.CHCFG7.Reg) & 0x40) >> 6
}
func (o *DMAMUX_Type) SetCHCFG7_ENBL(value uint8) {
	volatile.StoreUint8(&o.CHCFG7.Reg, volatile.LoadUint8(&o.CHCFG7.Reg)&^(0x80)|value<<7)
}
func (o *DMAMUX_Type) GetCHCFG7_ENBL() uint8 {
	return (volatile.LoadUint8(&o.CHCFG7.Reg) & 0x80) >> 7
}

// DMAMUX.CHCFG8: Channel Configuration register
func (o *DMAMUX_Type) SetCHCFG8_SOURCE(value uint8) {
	volatile.StoreUint8(&o.CHCFG8.Reg, volatile.LoadUint8(&o.CHCFG8.Reg)&^(0x3f)|value)
}
func (o *DMAMUX_Type) GetCHCFG8_SOURCE() uint8 {
	return volatile.LoadUint8(&o.CHCFG8.Reg) & 0x3f
}
func (o *DMAMUX_Type) SetCHCFG8_TRIG(value uint8) {
	volatile.StoreUint8(&o.CHCFG8.Reg, volatile.LoadUint8(&o.CHCFG8.Reg)&^(0x40)|value<<6)
}
func (o *DMAMUX_Type) GetCHCFG8_TRIG() uint8 {
	return (volatile.LoadUint8(&o.CHCFG8.Reg) & 0x40) >> 6
}
func (o *DMAMUX_Type) SetCHCFG8_ENBL(value uint8) {
	volatile.StoreUint8(&o.CHCFG8.Reg, volatile.LoadUint8(&o.CHCFG8.Reg)&^(0x80)|value<<7)
}
func (o *DMAMUX_Type) GetCHCFG8_ENBL() uint8 {
	return (volatile.LoadUint8(&o.CHCFG8.Reg) & 0x80) >> 7
}

// DMAMUX.CHCFG9: Channel Configuration register
func (o *DMAMUX_Type) SetCHCFG9_SOURCE(value uint8) {
	volatile.StoreUint8(&o.CHCFG9.Reg, volatile.LoadUint8(&o.CHCFG9.Reg)&^(0x3f)|value)
}
func (o *DMAMUX_Type) GetCHCFG9_SOURCE() uint8 {
	return volatile.LoadUint8(&o.CHCFG9.Reg) & 0x3f
}
func (o *DMAMUX_Type) SetCHCFG9_TRIG(value uint8) {
	volatile.StoreUint8(&o.CHCFG9.Reg, volatile.LoadUint8(&o.CHCFG9.Reg)&^(0x40)|value<<6)
}
func (o *DMAMUX_Type) GetCHCFG9_TRIG() uint8 {
	return (volatile.LoadUint8(&o.CHCFG9.Reg) & 0x40) >> 6
}
func (o *DMAMUX_Type) SetCHCFG9_ENBL(value uint8) {
	volatile.StoreUint8(&o.CHCFG9.Reg, volatile.LoadUint8(&o.CHCFG9.Reg)&^(0x80)|value<<7)
}
func (o *DMAMUX_Type) GetCHCFG9_ENBL() uint8 {
	return (volatile.LoadUint8(&o.CHCFG9.Reg) & 0x80) >> 7
}

// DMAMUX.CHCFG10: Channel Configuration register
func (o *DMAMUX_Type) SetCHCFG10_SOURCE(value uint8) {
	volatile.StoreUint8(&o.CHCFG10.Reg, volatile.LoadUint8(&o.CHCFG10.Reg)&^(0x3f)|value)
}
func (o *DMAMUX_Type) GetCHCFG10_SOURCE() uint8 {
	return volatile.LoadUint8(&o.CHCFG10.Reg) & 0x3f
}
func (o *DMAMUX_Type) SetCHCFG10_TRIG(value uint8) {
	volatile.StoreUint8(&o.CHCFG10.Reg, volatile.LoadUint8(&o.CHCFG10.Reg)&^(0x40)|value<<6)
}
func (o *DMAMUX_Type) GetCHCFG10_TRIG() uint8 {
	return (volatile.LoadUint8(&o.CHCFG10.Reg) & 0x40) >> 6
}
func (o *DMAMUX_Type) SetCHCFG10_ENBL(value uint8) {
	volatile.StoreUint8(&o.CHCFG10.Reg, volatile.LoadUint8(&o.CHCFG10.Reg)&^(0x80)|value<<7)
}
func (o *DMAMUX_Type) GetCHCFG10_ENBL() uint8 {
	return (volatile.LoadUint8(&o.CHCFG10.Reg) & 0x80) >> 7
}

// DMAMUX.CHCFG11: Channel Configuration register
func (o *DMAMUX_Type) SetCHCFG11_SOURCE(value uint8) {
	volatile.StoreUint8(&o.CHCFG11.Reg, volatile.LoadUint8(&o.CHCFG11.Reg)&^(0x3f)|value)
}
func (o *DMAMUX_Type) GetCHCFG11_SOURCE() uint8 {
	return volatile.LoadUint8(&o.CHCFG11.Reg) & 0x3f
}
func (o *DMAMUX_Type) SetCHCFG11_TRIG(value uint8) {
	volatile.StoreUint8(&o.CHCFG11.Reg, volatile.LoadUint8(&o.CHCFG11.Reg)&^(0x40)|value<<6)
}
func (o *DMAMUX_Type) GetCHCFG11_TRIG() uint8 {
	return (volatile.LoadUint8(&o.CHCFG11.Reg) & 0x40) >> 6
}
func (o *DMAMUX_Type) SetCHCFG11_ENBL(value uint8) {
	volatile.StoreUint8(&o.CHCFG11.Reg, volatile.LoadUint8(&o.CHCFG11.Reg)&^(0x80)|value<<7)
}
func (o *DMAMUX_Type) GetCHCFG11_ENBL() uint8 {
	return (volatile.LoadUint8(&o.CHCFG11.Reg) & 0x80) >> 7
}

// DMAMUX.CHCFG12: Channel Configuration register
func (o *DMAMUX_Type) SetCHCFG12_SOURCE(value uint8) {
	volatile.StoreUint8(&o.CHCFG12.Reg, volatile.LoadUint8(&o.CHCFG12.Reg)&^(0x3f)|value)
}
func (o *DMAMUX_Type) GetCHCFG12_SOURCE() uint8 {
	return volatile.LoadUint8(&o.CHCFG12.Reg) & 0x3f
}
func (o *DMAMUX_Type) SetCHCFG12_TRIG(value uint8) {
	volatile.StoreUint8(&o.CHCFG12.Reg, volatile.LoadUint8(&o.CHCFG12.Reg)&^(0x40)|value<<6)
}
func (o *DMAMUX_Type) GetCHCFG12_TRIG() uint8 {
	return (volatile.LoadUint8(&o.CHCFG12.Reg) & 0x40) >> 6
}
func (o *DMAMUX_Type) SetCHCFG12_ENBL(value uint8) {
	volatile.StoreUint8(&o.CHCFG12.Reg, volatile.LoadUint8(&o.CHCFG12.Reg)&^(0x80)|value<<7)
}
func (o *DMAMUX_Type) GetCHCFG12_ENBL() uint8 {
	return (volatile.LoadUint8(&o.CHCFG12.Reg) & 0x80) >> 7
}

// DMAMUX.CHCFG13: Channel Configuration register
func (o *DMAMUX_Type) SetCHCFG13_SOURCE(value uint8) {
	volatile.StoreUint8(&o.CHCFG13.Reg, volatile.LoadUint8(&o.CHCFG13.Reg)&^(0x3f)|value)
}
func (o *DMAMUX_Type) GetCHCFG13_SOURCE() uint8 {
	return volatile.LoadUint8(&o.CHCFG13.Reg) & 0x3f
}
func (o *DMAMUX_Type) SetCHCFG13_TRIG(value uint8) {
	volatile.StoreUint8(&o.CHCFG13.Reg, volatile.LoadUint8(&o.CHCFG13.Reg)&^(0x40)|value<<6)
}
func (o *DMAMUX_Type) GetCHCFG13_TRIG() uint8 {
	return (volatile.LoadUint8(&o.CHCFG13.Reg) & 0x40) >> 6
}
func (o *DMAMUX_Type) SetCHCFG13_ENBL(value uint8) {
	volatile.StoreUint8(&o.CHCFG13.Reg, volatile.LoadUint8(&o.CHCFG13.Reg)&^(0x80)|value<<7)
}
func (o *DMAMUX_Type) GetCHCFG13_ENBL() uint8 {
	return (volatile.LoadUint8(&o.CHCFG13.Reg) & 0x80) >> 7
}

// DMAMUX.CHCFG14: Channel Configuration register
func (o *DMAMUX_Type) SetCHCFG14_SOURCE(value uint8) {
	volatile.StoreUint8(&o.CHCFG14.Reg, volatile.LoadUint8(&o.CHCFG14.Reg)&^(0x3f)|value)
}
func (o *DMAMUX_Type) GetCHCFG14_SOURCE() uint8 {
	return volatile.LoadUint8(&o.CHCFG14.Reg) & 0x3f
}
func (o *DMAMUX_Type) SetCHCFG14_TRIG(value uint8) {
	volatile.StoreUint8(&o.CHCFG14.Reg, volatile.LoadUint8(&o.CHCFG14.Reg)&^(0x40)|value<<6)
}
func (o *DMAMUX_Type) GetCHCFG14_TRIG() uint8 {
	return (volatile.LoadUint8(&o.CHCFG14.Reg) & 0x40) >> 6
}
func (o *DMAMUX_Type) SetCHCFG14_ENBL(value uint8) {
	volatile.StoreUint8(&o.CHCFG14.Reg, volatile.LoadUint8(&o.CHCFG14.Reg)&^(0x80)|value<<7)
}
func (o *DMAMUX_Type) GetCHCFG14_ENBL() uint8 {
	return (volatile.LoadUint8(&o.CHCFG14.Reg) & 0x80) >> 7
}

// DMAMUX.CHCFG15: Channel Configuration register
func (o *DMAMUX_Type) SetCHCFG15_SOURCE(value uint8) {
	volatile.StoreUint8(&o.CHCFG15.Reg, volatile.LoadUint8(&o.CHCFG15.Reg)&^(0x3f)|value)
}
func (o *DMAMUX_Type) GetCHCFG15_SOURCE() uint8 {
	return volatile.LoadUint8(&o.CHCFG15.Reg) & 0x3f
}
func (o *DMAMUX_Type) SetCHCFG15_TRIG(value uint8) {
	volatile.StoreUint8(&o.CHCFG15.Reg, volatile.LoadUint8(&o.CHCFG15.Reg)&^(0x40)|value<<6)
}
func (o *DMAMUX_Type) GetCHCFG15_TRIG() uint8 {
	return (volatile.LoadUint8(&o.CHCFG15.Reg) & 0x40) >> 6
}
func (o *DMAMUX_Type) SetCHCFG15_ENBL(value uint8) {
	volatile.StoreUint8(&o.CHCFG15.Reg, volatile.LoadUint8(&o.CHCFG15.Reg)&^(0x80)|value<<7)
}
func (o *DMAMUX_Type) GetCHCFG15_ENBL() uint8 {
	return (volatile.LoadUint8(&o.CHCFG15.Reg) & 0x80) >> 7
}

// Flex Controller Area Network module
type CAN0_Type struct {
	MCR      volatile.Register32 // 0x0
	CTRL1    volatile.Register32 // 0x4
	TIMER    volatile.Register32 // 0x8
	_        [4]byte
	RXMGMASK volatile.Register32 // 0x10
	RX14MASK volatile.Register32 // 0x14
	RX15MASK volatile.Register32 // 0x18
	ECR      volatile.Register32 // 0x1C
	ESR1     volatile.Register32 // 0x20
	_        [4]byte
	IMASK1   volatile.Register32 // 0x28
	_        [4]byte
	IFLAG1   volatile.Register32 // 0x30
	CTRL2    volatile.Register32 // 0x34
	ESR2     volatile.Register32 // 0x38
	_        [8]byte
	CRCR     volatile.Register32 // 0x44
	RXFGMASK volatile.Register32 // 0x48
	RXFIR    volatile.Register32 // 0x4C
	_        [48]byte
	CS0      volatile.Register32 // 0x80
	ID0      volatile.Register32 // 0x84
	WORD00   volatile.Register32 // 0x88
	WORD10   volatile.Register32 // 0x8C
	CS1      volatile.Register32 // 0x90
	ID1      volatile.Register32 // 0x94
	WORD01   volatile.Register32 // 0x98
	WORD11   volatile.Register32 // 0x9C
	CS2      volatile.Register32 // 0xA0
	ID2      volatile.Register32 // 0xA4
	WORD02   volatile.Register32 // 0xA8
	WORD12   volatile.Register32 // 0xAC
	CS3      volatile.Register32 // 0xB0
	ID3      volatile.Register32 // 0xB4
	WORD03   volatile.Register32 // 0xB8
	WORD13   volatile.Register32 // 0xBC
	CS4      volatile.Register32 // 0xC0
	ID4      volatile.Register32 // 0xC4
	WORD04   volatile.Register32 // 0xC8
	WORD14   volatile.Register32 // 0xCC
	CS5      volatile.Register32 // 0xD0
	ID5      volatile.Register32 // 0xD4
	WORD05   volatile.Register32 // 0xD8
	WORD15   volatile.Register32 // 0xDC
	CS6      volatile.Register32 // 0xE0
	ID6      volatile.Register32 // 0xE4
	WORD06   volatile.Register32 // 0xE8
	WORD16   volatile.Register32 // 0xEC
	CS7      volatile.Register32 // 0xF0
	ID7      volatile.Register32 // 0xF4
	WORD07   volatile.Register32 // 0xF8
	WORD17   volatile.Register32 // 0xFC
	CS8      volatile.Register32 // 0x100
	ID8      volatile.Register32 // 0x104
	WORD08   volatile.Register32 // 0x108
	WORD18   volatile.Register32 // 0x10C
	CS9      volatile.Register32 // 0x110
	ID9      volatile.Register32 // 0x114
	WORD09   volatile.Register32 // 0x118
	WORD19   volatile.Register32 // 0x11C
	CS10     volatile.Register32 // 0x120
	ID10     volatile.Register32 // 0x124
	WORD010  volatile.Register32 // 0x128
	WORD110  volatile.Register32 // 0x12C
	CS11     volatile.Register32 // 0x130
	ID11     volatile.Register32 // 0x134
	WORD011  volatile.Register32 // 0x138
	WORD111  volatile.Register32 // 0x13C
	CS12     volatile.Register32 // 0x140
	ID12     volatile.Register32 // 0x144
	WORD012  volatile.Register32 // 0x148
	WORD112  volatile.Register32 // 0x14C
	CS13     volatile.Register32 // 0x150
	ID13     volatile.Register32 // 0x154
	WORD013  volatile.Register32 // 0x158
	WORD113  volatile.Register32 // 0x15C
	CS14     volatile.Register32 // 0x160
	ID14     volatile.Register32 // 0x164
	WORD014  volatile.Register32 // 0x168
	WORD114  volatile.Register32 // 0x16C
	CS15     volatile.Register32 // 0x170
	ID15     volatile.Register32 // 0x174
	WORD015  volatile.Register32 // 0x178
	WORD115  volatile.Register32 // 0x17C
	_        [1792]byte
	RXIMR0   volatile.Register32 // 0x880
	RXIMR1   volatile.Register32 // 0x884
	RXIMR2   volatile.Register32 // 0x888
	RXIMR3   volatile.Register32 // 0x88C
	RXIMR4   volatile.Register32 // 0x890
	RXIMR5   volatile.Register32 // 0x894
	RXIMR6   volatile.Register32 // 0x898
	RXIMR7   volatile.Register32 // 0x89C
	RXIMR8   volatile.Register32 // 0x8A0
	RXIMR9   volatile.Register32 // 0x8A4
	RXIMR10  volatile.Register32 // 0x8A8
	RXIMR11  volatile.Register32 // 0x8AC
	RXIMR12  volatile.Register32 // 0x8B0
	RXIMR13  volatile.Register32 // 0x8B4
	RXIMR14  volatile.Register32 // 0x8B8
	RXIMR15  volatile.Register32 // 0x8BC
}

// CAN0.MCR: Module Configuration Register
func (o *CAN0_Type) SetMCR_MAXMB(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x7f)|value)
}
func (o *CAN0_Type) GetMCR_MAXMB() uint32 {
	return volatile.LoadUint32(&o.MCR.Reg) & 0x7f
}
func (o *CAN0_Type) SetMCR_IDAM(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x300)|value<<8)
}
func (o *CAN0_Type) GetMCR_IDAM() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x300) >> 8
}
func (o *CAN0_Type) SetMCR_AEN(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x1000)|value<<12)
}
func (o *CAN0_Type) GetMCR_AEN() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x1000) >> 12
}
func (o *CAN0_Type) SetMCR_LPRIOEN(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x2000)|value<<13)
}
func (o *CAN0_Type) GetMCR_LPRIOEN() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x2000) >> 13
}
func (o *CAN0_Type) SetMCR_IRMQ(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x10000)|value<<16)
}
func (o *CAN0_Type) GetMCR_IRMQ() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x10000) >> 16
}
func (o *CAN0_Type) SetMCR_SRXDIS(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x20000)|value<<17)
}
func (o *CAN0_Type) GetMCR_SRXDIS() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x20000) >> 17
}
func (o *CAN0_Type) SetMCR_WAKSRC(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x80000)|value<<19)
}
func (o *CAN0_Type) GetMCR_WAKSRC() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x80000) >> 19
}
func (o *CAN0_Type) SetMCR_LPMACK(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x100000)|value<<20)
}
func (o *CAN0_Type) GetMCR_LPMACK() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x100000) >> 20
}
func (o *CAN0_Type) SetMCR_WRNEN(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x200000)|value<<21)
}
func (o *CAN0_Type) GetMCR_WRNEN() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x200000) >> 21
}
func (o *CAN0_Type) SetMCR_SLFWAK(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x400000)|value<<22)
}
func (o *CAN0_Type) GetMCR_SLFWAK() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x400000) >> 22
}
func (o *CAN0_Type) SetMCR_SUPV(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x800000)|value<<23)
}
func (o *CAN0_Type) GetMCR_SUPV() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x800000) >> 23
}
func (o *CAN0_Type) SetMCR_FRZACK(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x1000000)|value<<24)
}
func (o *CAN0_Type) GetMCR_FRZACK() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x1000000) >> 24
}
func (o *CAN0_Type) SetMCR_SOFTRST(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x2000000)|value<<25)
}
func (o *CAN0_Type) GetMCR_SOFTRST() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x2000000) >> 25
}
func (o *CAN0_Type) SetMCR_WAKMSK(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x4000000)|value<<26)
}
func (o *CAN0_Type) GetMCR_WAKMSK() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x4000000) >> 26
}
func (o *CAN0_Type) SetMCR_NOTRDY(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x8000000)|value<<27)
}
func (o *CAN0_Type) GetMCR_NOTRDY() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x8000000) >> 27
}
func (o *CAN0_Type) SetMCR_HALT(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x10000000)|value<<28)
}
func (o *CAN0_Type) GetMCR_HALT() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x10000000) >> 28
}
func (o *CAN0_Type) SetMCR_RFEN(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetMCR_RFEN() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetMCR_FRZ(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMCR_FRZ() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMCR_MDIS(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMCR_MDIS() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x80000000) >> 31
}

// CAN0.CTRL1: Control 1 register
func (o *CAN0_Type) SetCTRL1_PROPSEG(value uint32) {
	volatile.StoreUint32(&o.CTRL1.Reg, volatile.LoadUint32(&o.CTRL1.Reg)&^(0x7)|value)
}
func (o *CAN0_Type) GetCTRL1_PROPSEG() uint32 {
	return volatile.LoadUint32(&o.CTRL1.Reg) & 0x7
}
func (o *CAN0_Type) SetCTRL1_LOM(value uint32) {
	volatile.StoreUint32(&o.CTRL1.Reg, volatile.LoadUint32(&o.CTRL1.Reg)&^(0x8)|value<<3)
}
func (o *CAN0_Type) GetCTRL1_LOM() uint32 {
	return (volatile.LoadUint32(&o.CTRL1.Reg) & 0x8) >> 3
}
func (o *CAN0_Type) SetCTRL1_LBUF(value uint32) {
	volatile.StoreUint32(&o.CTRL1.Reg, volatile.LoadUint32(&o.CTRL1.Reg)&^(0x10)|value<<4)
}
func (o *CAN0_Type) GetCTRL1_LBUF() uint32 {
	return (volatile.LoadUint32(&o.CTRL1.Reg) & 0x10) >> 4
}
func (o *CAN0_Type) SetCTRL1_TSYN(value uint32) {
	volatile.StoreUint32(&o.CTRL1.Reg, volatile.LoadUint32(&o.CTRL1.Reg)&^(0x20)|value<<5)
}
func (o *CAN0_Type) GetCTRL1_TSYN() uint32 {
	return (volatile.LoadUint32(&o.CTRL1.Reg) & 0x20) >> 5
}
func (o *CAN0_Type) SetCTRL1_BOFFREC(value uint32) {
	volatile.StoreUint32(&o.CTRL1.Reg, volatile.LoadUint32(&o.CTRL1.Reg)&^(0x40)|value<<6)
}
func (o *CAN0_Type) GetCTRL1_BOFFREC() uint32 {
	return (volatile.LoadUint32(&o.CTRL1.Reg) & 0x40) >> 6
}
func (o *CAN0_Type) SetCTRL1_SMP(value uint32) {
	volatile.StoreUint32(&o.CTRL1.Reg, volatile.LoadUint32(&o.CTRL1.Reg)&^(0x80)|value<<7)
}
func (o *CAN0_Type) GetCTRL1_SMP() uint32 {
	return (volatile.LoadUint32(&o.CTRL1.Reg) & 0x80) >> 7
}
func (o *CAN0_Type) SetCTRL1_RWRNMSK(value uint32) {
	volatile.StoreUint32(&o.CTRL1.Reg, volatile.LoadUint32(&o.CTRL1.Reg)&^(0x400)|value<<10)
}
func (o *CAN0_Type) GetCTRL1_RWRNMSK() uint32 {
	return (volatile.LoadUint32(&o.CTRL1.Reg) & 0x400) >> 10
}
func (o *CAN0_Type) SetCTRL1_TWRNMSK(value uint32) {
	volatile.StoreUint32(&o.CTRL1.Reg, volatile.LoadUint32(&o.CTRL1.Reg)&^(0x800)|value<<11)
}
func (o *CAN0_Type) GetCTRL1_TWRNMSK() uint32 {
	return (volatile.LoadUint32(&o.CTRL1.Reg) & 0x800) >> 11
}
func (o *CAN0_Type) SetCTRL1_LPB(value uint32) {
	volatile.StoreUint32(&o.CTRL1.Reg, volatile.LoadUint32(&o.CTRL1.Reg)&^(0x1000)|value<<12)
}
func (o *CAN0_Type) GetCTRL1_LPB() uint32 {
	return (volatile.LoadUint32(&o.CTRL1.Reg) & 0x1000) >> 12
}
func (o *CAN0_Type) SetCTRL1_CLKSRC(value uint32) {
	volatile.StoreUint32(&o.CTRL1.Reg, volatile.LoadUint32(&o.CTRL1.Reg)&^(0x2000)|value<<13)
}
func (o *CAN0_Type) GetCTRL1_CLKSRC() uint32 {
	return (volatile.LoadUint32(&o.CTRL1.Reg) & 0x2000) >> 13
}
func (o *CAN0_Type) SetCTRL1_ERRMSK(value uint32) {
	volatile.StoreUint32(&o.CTRL1.Reg, volatile.LoadUint32(&o.CTRL1.Reg)&^(0x4000)|value<<14)
}
func (o *CAN0_Type) GetCTRL1_ERRMSK() uint32 {
	return (volatile.LoadUint32(&o.CTRL1.Reg) & 0x4000) >> 14
}
func (o *CAN0_Type) SetCTRL1_BOFFMSK(value uint32) {
	volatile.StoreUint32(&o.CTRL1.Reg, volatile.LoadUint32(&o.CTRL1.Reg)&^(0x8000)|value<<15)
}
func (o *CAN0_Type) GetCTRL1_BOFFMSK() uint32 {
	return (volatile.LoadUint32(&o.CTRL1.Reg) & 0x8000) >> 15
}
func (o *CAN0_Type) SetCTRL1_PSEG2(value uint32) {
	volatile.StoreUint32(&o.CTRL1.Reg, volatile.LoadUint32(&o.CTRL1.Reg)&^(0x70000)|value<<16)
}
func (o *CAN0_Type) GetCTRL1_PSEG2() uint32 {
	return (volatile.LoadUint32(&o.CTRL1.Reg) & 0x70000) >> 16
}
func (o *CAN0_Type) SetCTRL1_PSEG1(value uint32) {
	volatile.StoreUint32(&o.CTRL1.Reg, volatile.LoadUint32(&o.CTRL1.Reg)&^(0x380000)|value<<19)
}
func (o *CAN0_Type) GetCTRL1_PSEG1() uint32 {
	return (volatile.LoadUint32(&o.CTRL1.Reg) & 0x380000) >> 19
}
func (o *CAN0_Type) SetCTRL1_RJW(value uint32) {
	volatile.StoreUint32(&o.CTRL1.Reg, volatile.LoadUint32(&o.CTRL1.Reg)&^(0xc00000)|value<<22)
}
func (o *CAN0_Type) GetCTRL1_RJW() uint32 {
	return (volatile.LoadUint32(&o.CTRL1.Reg) & 0xc00000) >> 22
}
func (o *CAN0_Type) SetCTRL1_PRESDIV(value uint32) {
	volatile.StoreUint32(&o.CTRL1.Reg, volatile.LoadUint32(&o.CTRL1.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN0_Type) GetCTRL1_PRESDIV() uint32 {
	return (volatile.LoadUint32(&o.CTRL1.Reg) & 0xff000000) >> 24
}

// CAN0.TIMER: Free Running Timer
func (o *CAN0_Type) SetTIMER(value uint32) {
	volatile.StoreUint32(&o.TIMER.Reg, volatile.LoadUint32(&o.TIMER.Reg)&^(0xffff)|value)
}
func (o *CAN0_Type) GetTIMER() uint32 {
	return volatile.LoadUint32(&o.TIMER.Reg) & 0xffff
}

// CAN0.RXMGMASK: Rx Mailboxes Global Mask Register
func (o *CAN0_Type) SetRXMGMASK_MG0(value uint32) {
	volatile.StoreUint32(&o.RXMGMASK.Reg, volatile.LoadUint32(&o.RXMGMASK.Reg)&^(0x1)|value)
}
func (o *CAN0_Type) GetRXMGMASK_MG0() uint32 {
	return volatile.LoadUint32(&o.RXMGMASK.Reg) & 0x1
}
func (o *CAN0_Type) SetRXMGMASK_MG1(value uint32) {
	volatile.StoreUint32(&o.RXMGMASK.Reg, volatile.LoadUint32(&o.RXMGMASK.Reg)&^(0x2)|value<<1)
}
func (o *CAN0_Type) GetRXMGMASK_MG1() uint32 {
	return (volatile.LoadUint32(&o.RXMGMASK.Reg) & 0x2) >> 1
}
func (o *CAN0_Type) SetRXMGMASK_MG2(value uint32) {
	volatile.StoreUint32(&o.RXMGMASK.Reg, volatile.LoadUint32(&o.RXMGMASK.Reg)&^(0x4)|value<<2)
}
func (o *CAN0_Type) GetRXMGMASK_MG2() uint32 {
	return (volatile.LoadUint32(&o.RXMGMASK.Reg) & 0x4) >> 2
}
func (o *CAN0_Type) SetRXMGMASK_MG3(value uint32) {
	volatile.StoreUint32(&o.RXMGMASK.Reg, volatile.LoadUint32(&o.RXMGMASK.Reg)&^(0x8)|value<<3)
}
func (o *CAN0_Type) GetRXMGMASK_MG3() uint32 {
	return (volatile.LoadUint32(&o.RXMGMASK.Reg) & 0x8) >> 3
}
func (o *CAN0_Type) SetRXMGMASK_MG4(value uint32) {
	volatile.StoreUint32(&o.RXMGMASK.Reg, volatile.LoadUint32(&o.RXMGMASK.Reg)&^(0x10)|value<<4)
}
func (o *CAN0_Type) GetRXMGMASK_MG4() uint32 {
	return (volatile.LoadUint32(&o.RXMGMASK.Reg) & 0x10) >> 4
}
func (o *CAN0_Type) SetRXMGMASK_MG5(value uint32) {
	volatile.StoreUint32(&o.RXMGMASK.Reg, volatile.LoadUint32(&o.RXMGMASK.Reg)&^(0x20)|value<<5)
}
func (o *CAN0_Type) GetRXMGMASK_MG5() uint32 {
	return (volatile.LoadUint32(&o.RXMGMASK.Reg) & 0x20) >> 5
}
func (o *CAN0_Type) SetRXMGMASK_MG6(value uint32) {
	volatile.StoreUint32(&o.RXMGMASK.Reg, volatile.LoadUint32(&o.RXMGMASK.Reg)&^(0x40)|value<<6)
}
func (o *CAN0_Type) GetRXMGMASK_MG6() uint32 {
	return (volatile.LoadUint32(&o.RXMGMASK.Reg) & 0x40) >> 6
}
func (o *CAN0_Type) SetRXMGMASK_MG7(value uint32) {
	volatile.StoreUint32(&o.RXMGMASK.Reg, volatile.LoadUint32(&o.RXMGMASK.Reg)&^(0x80)|value<<7)
}
func (o *CAN0_Type) GetRXMGMASK_MG7() uint32 {
	return (volatile.LoadUint32(&o.RXMGMASK.Reg) & 0x80) >> 7
}
func (o *CAN0_Type) SetRXMGMASK_MG8(value uint32) {
	volatile.StoreUint32(&o.RXMGMASK.Reg, volatile.LoadUint32(&o.RXMGMASK.Reg)&^(0x100)|value<<8)
}
func (o *CAN0_Type) GetRXMGMASK_MG8() uint32 {
	return (volatile.LoadUint32(&o.RXMGMASK.Reg) & 0x100) >> 8
}
func (o *CAN0_Type) SetRXMGMASK_MG9(value uint32) {
	volatile.StoreUint32(&o.RXMGMASK.Reg, volatile.LoadUint32(&o.RXMGMASK.Reg)&^(0x200)|value<<9)
}
func (o *CAN0_Type) GetRXMGMASK_MG9() uint32 {
	return (volatile.LoadUint32(&o.RXMGMASK.Reg) & 0x200) >> 9
}
func (o *CAN0_Type) SetRXMGMASK_MG10(value uint32) {
	volatile.StoreUint32(&o.RXMGMASK.Reg, volatile.LoadUint32(&o.RXMGMASK.Reg)&^(0x400)|value<<10)
}
func (o *CAN0_Type) GetRXMGMASK_MG10() uint32 {
	return (volatile.LoadUint32(&o.RXMGMASK.Reg) & 0x400) >> 10
}
func (o *CAN0_Type) SetRXMGMASK_MG11(value uint32) {
	volatile.StoreUint32(&o.RXMGMASK.Reg, volatile.LoadUint32(&o.RXMGMASK.Reg)&^(0x800)|value<<11)
}
func (o *CAN0_Type) GetRXMGMASK_MG11() uint32 {
	return (volatile.LoadUint32(&o.RXMGMASK.Reg) & 0x800) >> 11
}
func (o *CAN0_Type) SetRXMGMASK_MG12(value uint32) {
	volatile.StoreUint32(&o.RXMGMASK.Reg, volatile.LoadUint32(&o.RXMGMASK.Reg)&^(0x1000)|value<<12)
}
func (o *CAN0_Type) GetRXMGMASK_MG12() uint32 {
	return (volatile.LoadUint32(&o.RXMGMASK.Reg) & 0x1000) >> 12
}
func (o *CAN0_Type) SetRXMGMASK_MG13(value uint32) {
	volatile.StoreUint32(&o.RXMGMASK.Reg, volatile.LoadUint32(&o.RXMGMASK.Reg)&^(0x2000)|value<<13)
}
func (o *CAN0_Type) GetRXMGMASK_MG13() uint32 {
	return (volatile.LoadUint32(&o.RXMGMASK.Reg) & 0x2000) >> 13
}
func (o *CAN0_Type) SetRXMGMASK_MG14(value uint32) {
	volatile.StoreUint32(&o.RXMGMASK.Reg, volatile.LoadUint32(&o.RXMGMASK.Reg)&^(0x4000)|value<<14)
}
func (o *CAN0_Type) GetRXMGMASK_MG14() uint32 {
	return (volatile.LoadUint32(&o.RXMGMASK.Reg) & 0x4000) >> 14
}
func (o *CAN0_Type) SetRXMGMASK_MG15(value uint32) {
	volatile.StoreUint32(&o.RXMGMASK.Reg, volatile.LoadUint32(&o.RXMGMASK.Reg)&^(0x8000)|value<<15)
}
func (o *CAN0_Type) GetRXMGMASK_MG15() uint32 {
	return (volatile.LoadUint32(&o.RXMGMASK.Reg) & 0x8000) >> 15
}
func (o *CAN0_Type) SetRXMGMASK_MG16(value uint32) {
	volatile.StoreUint32(&o.RXMGMASK.Reg, volatile.LoadUint32(&o.RXMGMASK.Reg)&^(0x10000)|value<<16)
}
func (o *CAN0_Type) GetRXMGMASK_MG16() uint32 {
	return (volatile.LoadUint32(&o.RXMGMASK.Reg) & 0x10000) >> 16
}
func (o *CAN0_Type) SetRXMGMASK_MG17(value uint32) {
	volatile.StoreUint32(&o.RXMGMASK.Reg, volatile.LoadUint32(&o.RXMGMASK.Reg)&^(0x20000)|value<<17)
}
func (o *CAN0_Type) GetRXMGMASK_MG17() uint32 {
	return (volatile.LoadUint32(&o.RXMGMASK.Reg) & 0x20000) >> 17
}
func (o *CAN0_Type) SetRXMGMASK_MG18(value uint32) {
	volatile.StoreUint32(&o.RXMGMASK.Reg, volatile.LoadUint32(&o.RXMGMASK.Reg)&^(0x40000)|value<<18)
}
func (o *CAN0_Type) GetRXMGMASK_MG18() uint32 {
	return (volatile.LoadUint32(&o.RXMGMASK.Reg) & 0x40000) >> 18
}
func (o *CAN0_Type) SetRXMGMASK_MG19(value uint32) {
	volatile.StoreUint32(&o.RXMGMASK.Reg, volatile.LoadUint32(&o.RXMGMASK.Reg)&^(0x80000)|value<<19)
}
func (o *CAN0_Type) GetRXMGMASK_MG19() uint32 {
	return (volatile.LoadUint32(&o.RXMGMASK.Reg) & 0x80000) >> 19
}
func (o *CAN0_Type) SetRXMGMASK_MG20(value uint32) {
	volatile.StoreUint32(&o.RXMGMASK.Reg, volatile.LoadUint32(&o.RXMGMASK.Reg)&^(0x100000)|value<<20)
}
func (o *CAN0_Type) GetRXMGMASK_MG20() uint32 {
	return (volatile.LoadUint32(&o.RXMGMASK.Reg) & 0x100000) >> 20
}
func (o *CAN0_Type) SetRXMGMASK_MG21(value uint32) {
	volatile.StoreUint32(&o.RXMGMASK.Reg, volatile.LoadUint32(&o.RXMGMASK.Reg)&^(0x200000)|value<<21)
}
func (o *CAN0_Type) GetRXMGMASK_MG21() uint32 {
	return (volatile.LoadUint32(&o.RXMGMASK.Reg) & 0x200000) >> 21
}
func (o *CAN0_Type) SetRXMGMASK_MG22(value uint32) {
	volatile.StoreUint32(&o.RXMGMASK.Reg, volatile.LoadUint32(&o.RXMGMASK.Reg)&^(0x400000)|value<<22)
}
func (o *CAN0_Type) GetRXMGMASK_MG22() uint32 {
	return (volatile.LoadUint32(&o.RXMGMASK.Reg) & 0x400000) >> 22
}
func (o *CAN0_Type) SetRXMGMASK_MG23(value uint32) {
	volatile.StoreUint32(&o.RXMGMASK.Reg, volatile.LoadUint32(&o.RXMGMASK.Reg)&^(0x800000)|value<<23)
}
func (o *CAN0_Type) GetRXMGMASK_MG23() uint32 {
	return (volatile.LoadUint32(&o.RXMGMASK.Reg) & 0x800000) >> 23
}
func (o *CAN0_Type) SetRXMGMASK_MG24(value uint32) {
	volatile.StoreUint32(&o.RXMGMASK.Reg, volatile.LoadUint32(&o.RXMGMASK.Reg)&^(0x1000000)|value<<24)
}
func (o *CAN0_Type) GetRXMGMASK_MG24() uint32 {
	return (volatile.LoadUint32(&o.RXMGMASK.Reg) & 0x1000000) >> 24
}
func (o *CAN0_Type) SetRXMGMASK_MG25(value uint32) {
	volatile.StoreUint32(&o.RXMGMASK.Reg, volatile.LoadUint32(&o.RXMGMASK.Reg)&^(0x2000000)|value<<25)
}
func (o *CAN0_Type) GetRXMGMASK_MG25() uint32 {
	return (volatile.LoadUint32(&o.RXMGMASK.Reg) & 0x2000000) >> 25
}
func (o *CAN0_Type) SetRXMGMASK_MG26(value uint32) {
	volatile.StoreUint32(&o.RXMGMASK.Reg, volatile.LoadUint32(&o.RXMGMASK.Reg)&^(0x4000000)|value<<26)
}
func (o *CAN0_Type) GetRXMGMASK_MG26() uint32 {
	return (volatile.LoadUint32(&o.RXMGMASK.Reg) & 0x4000000) >> 26
}
func (o *CAN0_Type) SetRXMGMASK_MG27(value uint32) {
	volatile.StoreUint32(&o.RXMGMASK.Reg, volatile.LoadUint32(&o.RXMGMASK.Reg)&^(0x8000000)|value<<27)
}
func (o *CAN0_Type) GetRXMGMASK_MG27() uint32 {
	return (volatile.LoadUint32(&o.RXMGMASK.Reg) & 0x8000000) >> 27
}
func (o *CAN0_Type) SetRXMGMASK_MG28(value uint32) {
	volatile.StoreUint32(&o.RXMGMASK.Reg, volatile.LoadUint32(&o.RXMGMASK.Reg)&^(0x10000000)|value<<28)
}
func (o *CAN0_Type) GetRXMGMASK_MG28() uint32 {
	return (volatile.LoadUint32(&o.RXMGMASK.Reg) & 0x10000000) >> 28
}
func (o *CAN0_Type) SetRXMGMASK_MG29(value uint32) {
	volatile.StoreUint32(&o.RXMGMASK.Reg, volatile.LoadUint32(&o.RXMGMASK.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetRXMGMASK_MG29() uint32 {
	return (volatile.LoadUint32(&o.RXMGMASK.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetRXMGMASK_MG30(value uint32) {
	volatile.StoreUint32(&o.RXMGMASK.Reg, volatile.LoadUint32(&o.RXMGMASK.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetRXMGMASK_MG30() uint32 {
	return (volatile.LoadUint32(&o.RXMGMASK.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetRXMGMASK_MG31(value uint32) {
	volatile.StoreUint32(&o.RXMGMASK.Reg, volatile.LoadUint32(&o.RXMGMASK.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetRXMGMASK_MG31() uint32 {
	return (volatile.LoadUint32(&o.RXMGMASK.Reg) & 0x80000000) >> 31
}

// CAN0.RX14MASK: Rx 14 Mask register
func (o *CAN0_Type) SetRX14MASK_RX14M0(value uint32) {
	volatile.StoreUint32(&o.RX14MASK.Reg, volatile.LoadUint32(&o.RX14MASK.Reg)&^(0x1)|value)
}
func (o *CAN0_Type) GetRX14MASK_RX14M0() uint32 {
	return volatile.LoadUint32(&o.RX14MASK.Reg) & 0x1
}
func (o *CAN0_Type) SetRX14MASK_RX14M1(value uint32) {
	volatile.StoreUint32(&o.RX14MASK.Reg, volatile.LoadUint32(&o.RX14MASK.Reg)&^(0x2)|value<<1)
}
func (o *CAN0_Type) GetRX14MASK_RX14M1() uint32 {
	return (volatile.LoadUint32(&o.RX14MASK.Reg) & 0x2) >> 1
}
func (o *CAN0_Type) SetRX14MASK_RX14M2(value uint32) {
	volatile.StoreUint32(&o.RX14MASK.Reg, volatile.LoadUint32(&o.RX14MASK.Reg)&^(0x4)|value<<2)
}
func (o *CAN0_Type) GetRX14MASK_RX14M2() uint32 {
	return (volatile.LoadUint32(&o.RX14MASK.Reg) & 0x4) >> 2
}
func (o *CAN0_Type) SetRX14MASK_RX14M3(value uint32) {
	volatile.StoreUint32(&o.RX14MASK.Reg, volatile.LoadUint32(&o.RX14MASK.Reg)&^(0x8)|value<<3)
}
func (o *CAN0_Type) GetRX14MASK_RX14M3() uint32 {
	return (volatile.LoadUint32(&o.RX14MASK.Reg) & 0x8) >> 3
}
func (o *CAN0_Type) SetRX14MASK_RX14M4(value uint32) {
	volatile.StoreUint32(&o.RX14MASK.Reg, volatile.LoadUint32(&o.RX14MASK.Reg)&^(0x10)|value<<4)
}
func (o *CAN0_Type) GetRX14MASK_RX14M4() uint32 {
	return (volatile.LoadUint32(&o.RX14MASK.Reg) & 0x10) >> 4
}
func (o *CAN0_Type) SetRX14MASK_RX14M5(value uint32) {
	volatile.StoreUint32(&o.RX14MASK.Reg, volatile.LoadUint32(&o.RX14MASK.Reg)&^(0x20)|value<<5)
}
func (o *CAN0_Type) GetRX14MASK_RX14M5() uint32 {
	return (volatile.LoadUint32(&o.RX14MASK.Reg) & 0x20) >> 5
}
func (o *CAN0_Type) SetRX14MASK_RX14M6(value uint32) {
	volatile.StoreUint32(&o.RX14MASK.Reg, volatile.LoadUint32(&o.RX14MASK.Reg)&^(0x40)|value<<6)
}
func (o *CAN0_Type) GetRX14MASK_RX14M6() uint32 {
	return (volatile.LoadUint32(&o.RX14MASK.Reg) & 0x40) >> 6
}
func (o *CAN0_Type) SetRX14MASK_RX14M7(value uint32) {
	volatile.StoreUint32(&o.RX14MASK.Reg, volatile.LoadUint32(&o.RX14MASK.Reg)&^(0x80)|value<<7)
}
func (o *CAN0_Type) GetRX14MASK_RX14M7() uint32 {
	return (volatile.LoadUint32(&o.RX14MASK.Reg) & 0x80) >> 7
}
func (o *CAN0_Type) SetRX14MASK_RX14M8(value uint32) {
	volatile.StoreUint32(&o.RX14MASK.Reg, volatile.LoadUint32(&o.RX14MASK.Reg)&^(0x100)|value<<8)
}
func (o *CAN0_Type) GetRX14MASK_RX14M8() uint32 {
	return (volatile.LoadUint32(&o.RX14MASK.Reg) & 0x100) >> 8
}
func (o *CAN0_Type) SetRX14MASK_RX14M9(value uint32) {
	volatile.StoreUint32(&o.RX14MASK.Reg, volatile.LoadUint32(&o.RX14MASK.Reg)&^(0x200)|value<<9)
}
func (o *CAN0_Type) GetRX14MASK_RX14M9() uint32 {
	return (volatile.LoadUint32(&o.RX14MASK.Reg) & 0x200) >> 9
}
func (o *CAN0_Type) SetRX14MASK_RX14M10(value uint32) {
	volatile.StoreUint32(&o.RX14MASK.Reg, volatile.LoadUint32(&o.RX14MASK.Reg)&^(0x400)|value<<10)
}
func (o *CAN0_Type) GetRX14MASK_RX14M10() uint32 {
	return (volatile.LoadUint32(&o.RX14MASK.Reg) & 0x400) >> 10
}
func (o *CAN0_Type) SetRX14MASK_RX14M11(value uint32) {
	volatile.StoreUint32(&o.RX14MASK.Reg, volatile.LoadUint32(&o.RX14MASK.Reg)&^(0x800)|value<<11)
}
func (o *CAN0_Type) GetRX14MASK_RX14M11() uint32 {
	return (volatile.LoadUint32(&o.RX14MASK.Reg) & 0x800) >> 11
}
func (o *CAN0_Type) SetRX14MASK_RX14M12(value uint32) {
	volatile.StoreUint32(&o.RX14MASK.Reg, volatile.LoadUint32(&o.RX14MASK.Reg)&^(0x1000)|value<<12)
}
func (o *CAN0_Type) GetRX14MASK_RX14M12() uint32 {
	return (volatile.LoadUint32(&o.RX14MASK.Reg) & 0x1000) >> 12
}
func (o *CAN0_Type) SetRX14MASK_RX14M13(value uint32) {
	volatile.StoreUint32(&o.RX14MASK.Reg, volatile.LoadUint32(&o.RX14MASK.Reg)&^(0x2000)|value<<13)
}
func (o *CAN0_Type) GetRX14MASK_RX14M13() uint32 {
	return (volatile.LoadUint32(&o.RX14MASK.Reg) & 0x2000) >> 13
}
func (o *CAN0_Type) SetRX14MASK_RX14M14(value uint32) {
	volatile.StoreUint32(&o.RX14MASK.Reg, volatile.LoadUint32(&o.RX14MASK.Reg)&^(0x4000)|value<<14)
}
func (o *CAN0_Type) GetRX14MASK_RX14M14() uint32 {
	return (volatile.LoadUint32(&o.RX14MASK.Reg) & 0x4000) >> 14
}
func (o *CAN0_Type) SetRX14MASK_RX14M15(value uint32) {
	volatile.StoreUint32(&o.RX14MASK.Reg, volatile.LoadUint32(&o.RX14MASK.Reg)&^(0x8000)|value<<15)
}
func (o *CAN0_Type) GetRX14MASK_RX14M15() uint32 {
	return (volatile.LoadUint32(&o.RX14MASK.Reg) & 0x8000) >> 15
}
func (o *CAN0_Type) SetRX14MASK_RX14M16(value uint32) {
	volatile.StoreUint32(&o.RX14MASK.Reg, volatile.LoadUint32(&o.RX14MASK.Reg)&^(0x10000)|value<<16)
}
func (o *CAN0_Type) GetRX14MASK_RX14M16() uint32 {
	return (volatile.LoadUint32(&o.RX14MASK.Reg) & 0x10000) >> 16
}
func (o *CAN0_Type) SetRX14MASK_RX14M17(value uint32) {
	volatile.StoreUint32(&o.RX14MASK.Reg, volatile.LoadUint32(&o.RX14MASK.Reg)&^(0x20000)|value<<17)
}
func (o *CAN0_Type) GetRX14MASK_RX14M17() uint32 {
	return (volatile.LoadUint32(&o.RX14MASK.Reg) & 0x20000) >> 17
}
func (o *CAN0_Type) SetRX14MASK_RX14M18(value uint32) {
	volatile.StoreUint32(&o.RX14MASK.Reg, volatile.LoadUint32(&o.RX14MASK.Reg)&^(0x40000)|value<<18)
}
func (o *CAN0_Type) GetRX14MASK_RX14M18() uint32 {
	return (volatile.LoadUint32(&o.RX14MASK.Reg) & 0x40000) >> 18
}
func (o *CAN0_Type) SetRX14MASK_RX14M19(value uint32) {
	volatile.StoreUint32(&o.RX14MASK.Reg, volatile.LoadUint32(&o.RX14MASK.Reg)&^(0x80000)|value<<19)
}
func (o *CAN0_Type) GetRX14MASK_RX14M19() uint32 {
	return (volatile.LoadUint32(&o.RX14MASK.Reg) & 0x80000) >> 19
}
func (o *CAN0_Type) SetRX14MASK_RX14M20(value uint32) {
	volatile.StoreUint32(&o.RX14MASK.Reg, volatile.LoadUint32(&o.RX14MASK.Reg)&^(0x100000)|value<<20)
}
func (o *CAN0_Type) GetRX14MASK_RX14M20() uint32 {
	return (volatile.LoadUint32(&o.RX14MASK.Reg) & 0x100000) >> 20
}
func (o *CAN0_Type) SetRX14MASK_RX14M21(value uint32) {
	volatile.StoreUint32(&o.RX14MASK.Reg, volatile.LoadUint32(&o.RX14MASK.Reg)&^(0x200000)|value<<21)
}
func (o *CAN0_Type) GetRX14MASK_RX14M21() uint32 {
	return (volatile.LoadUint32(&o.RX14MASK.Reg) & 0x200000) >> 21
}
func (o *CAN0_Type) SetRX14MASK_RX14M22(value uint32) {
	volatile.StoreUint32(&o.RX14MASK.Reg, volatile.LoadUint32(&o.RX14MASK.Reg)&^(0x400000)|value<<22)
}
func (o *CAN0_Type) GetRX14MASK_RX14M22() uint32 {
	return (volatile.LoadUint32(&o.RX14MASK.Reg) & 0x400000) >> 22
}
func (o *CAN0_Type) SetRX14MASK_RX14M23(value uint32) {
	volatile.StoreUint32(&o.RX14MASK.Reg, volatile.LoadUint32(&o.RX14MASK.Reg)&^(0x800000)|value<<23)
}
func (o *CAN0_Type) GetRX14MASK_RX14M23() uint32 {
	return (volatile.LoadUint32(&o.RX14MASK.Reg) & 0x800000) >> 23
}
func (o *CAN0_Type) SetRX14MASK_RX14M24(value uint32) {
	volatile.StoreUint32(&o.RX14MASK.Reg, volatile.LoadUint32(&o.RX14MASK.Reg)&^(0x1000000)|value<<24)
}
func (o *CAN0_Type) GetRX14MASK_RX14M24() uint32 {
	return (volatile.LoadUint32(&o.RX14MASK.Reg) & 0x1000000) >> 24
}
func (o *CAN0_Type) SetRX14MASK_RX14M25(value uint32) {
	volatile.StoreUint32(&o.RX14MASK.Reg, volatile.LoadUint32(&o.RX14MASK.Reg)&^(0x2000000)|value<<25)
}
func (o *CAN0_Type) GetRX14MASK_RX14M25() uint32 {
	return (volatile.LoadUint32(&o.RX14MASK.Reg) & 0x2000000) >> 25
}
func (o *CAN0_Type) SetRX14MASK_RX14M26(value uint32) {
	volatile.StoreUint32(&o.RX14MASK.Reg, volatile.LoadUint32(&o.RX14MASK.Reg)&^(0x4000000)|value<<26)
}
func (o *CAN0_Type) GetRX14MASK_RX14M26() uint32 {
	return (volatile.LoadUint32(&o.RX14MASK.Reg) & 0x4000000) >> 26
}
func (o *CAN0_Type) SetRX14MASK_RX14M27(value uint32) {
	volatile.StoreUint32(&o.RX14MASK.Reg, volatile.LoadUint32(&o.RX14MASK.Reg)&^(0x8000000)|value<<27)
}
func (o *CAN0_Type) GetRX14MASK_RX14M27() uint32 {
	return (volatile.LoadUint32(&o.RX14MASK.Reg) & 0x8000000) >> 27
}
func (o *CAN0_Type) SetRX14MASK_RX14M28(value uint32) {
	volatile.StoreUint32(&o.RX14MASK.Reg, volatile.LoadUint32(&o.RX14MASK.Reg)&^(0x10000000)|value<<28)
}
func (o *CAN0_Type) GetRX14MASK_RX14M28() uint32 {
	return (volatile.LoadUint32(&o.RX14MASK.Reg) & 0x10000000) >> 28
}
func (o *CAN0_Type) SetRX14MASK_RX14M29(value uint32) {
	volatile.StoreUint32(&o.RX14MASK.Reg, volatile.LoadUint32(&o.RX14MASK.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetRX14MASK_RX14M29() uint32 {
	return (volatile.LoadUint32(&o.RX14MASK.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetRX14MASK_RX14M30(value uint32) {
	volatile.StoreUint32(&o.RX14MASK.Reg, volatile.LoadUint32(&o.RX14MASK.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetRX14MASK_RX14M30() uint32 {
	return (volatile.LoadUint32(&o.RX14MASK.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetRX14MASK_RX14M31(value uint32) {
	volatile.StoreUint32(&o.RX14MASK.Reg, volatile.LoadUint32(&o.RX14MASK.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetRX14MASK_RX14M31() uint32 {
	return (volatile.LoadUint32(&o.RX14MASK.Reg) & 0x80000000) >> 31
}

// CAN0.RX15MASK: Rx 15 Mask register
func (o *CAN0_Type) SetRX15MASK_RX15M0(value uint32) {
	volatile.StoreUint32(&o.RX15MASK.Reg, volatile.LoadUint32(&o.RX15MASK.Reg)&^(0x1)|value)
}
func (o *CAN0_Type) GetRX15MASK_RX15M0() uint32 {
	return volatile.LoadUint32(&o.RX15MASK.Reg) & 0x1
}
func (o *CAN0_Type) SetRX15MASK_RX15M1(value uint32) {
	volatile.StoreUint32(&o.RX15MASK.Reg, volatile.LoadUint32(&o.RX15MASK.Reg)&^(0x2)|value<<1)
}
func (o *CAN0_Type) GetRX15MASK_RX15M1() uint32 {
	return (volatile.LoadUint32(&o.RX15MASK.Reg) & 0x2) >> 1
}
func (o *CAN0_Type) SetRX15MASK_RX15M2(value uint32) {
	volatile.StoreUint32(&o.RX15MASK.Reg, volatile.LoadUint32(&o.RX15MASK.Reg)&^(0x4)|value<<2)
}
func (o *CAN0_Type) GetRX15MASK_RX15M2() uint32 {
	return (volatile.LoadUint32(&o.RX15MASK.Reg) & 0x4) >> 2
}
func (o *CAN0_Type) SetRX15MASK_RX15M3(value uint32) {
	volatile.StoreUint32(&o.RX15MASK.Reg, volatile.LoadUint32(&o.RX15MASK.Reg)&^(0x8)|value<<3)
}
func (o *CAN0_Type) GetRX15MASK_RX15M3() uint32 {
	return (volatile.LoadUint32(&o.RX15MASK.Reg) & 0x8) >> 3
}
func (o *CAN0_Type) SetRX15MASK_RX15M4(value uint32) {
	volatile.StoreUint32(&o.RX15MASK.Reg, volatile.LoadUint32(&o.RX15MASK.Reg)&^(0x10)|value<<4)
}
func (o *CAN0_Type) GetRX15MASK_RX15M4() uint32 {
	return (volatile.LoadUint32(&o.RX15MASK.Reg) & 0x10) >> 4
}
func (o *CAN0_Type) SetRX15MASK_RX15M5(value uint32) {
	volatile.StoreUint32(&o.RX15MASK.Reg, volatile.LoadUint32(&o.RX15MASK.Reg)&^(0x20)|value<<5)
}
func (o *CAN0_Type) GetRX15MASK_RX15M5() uint32 {
	return (volatile.LoadUint32(&o.RX15MASK.Reg) & 0x20) >> 5
}
func (o *CAN0_Type) SetRX15MASK_RX15M6(value uint32) {
	volatile.StoreUint32(&o.RX15MASK.Reg, volatile.LoadUint32(&o.RX15MASK.Reg)&^(0x40)|value<<6)
}
func (o *CAN0_Type) GetRX15MASK_RX15M6() uint32 {
	return (volatile.LoadUint32(&o.RX15MASK.Reg) & 0x40) >> 6
}
func (o *CAN0_Type) SetRX15MASK_RX15M7(value uint32) {
	volatile.StoreUint32(&o.RX15MASK.Reg, volatile.LoadUint32(&o.RX15MASK.Reg)&^(0x80)|value<<7)
}
func (o *CAN0_Type) GetRX15MASK_RX15M7() uint32 {
	return (volatile.LoadUint32(&o.RX15MASK.Reg) & 0x80) >> 7
}
func (o *CAN0_Type) SetRX15MASK_RX15M8(value uint32) {
	volatile.StoreUint32(&o.RX15MASK.Reg, volatile.LoadUint32(&o.RX15MASK.Reg)&^(0x100)|value<<8)
}
func (o *CAN0_Type) GetRX15MASK_RX15M8() uint32 {
	return (volatile.LoadUint32(&o.RX15MASK.Reg) & 0x100) >> 8
}
func (o *CAN0_Type) SetRX15MASK_RX15M9(value uint32) {
	volatile.StoreUint32(&o.RX15MASK.Reg, volatile.LoadUint32(&o.RX15MASK.Reg)&^(0x200)|value<<9)
}
func (o *CAN0_Type) GetRX15MASK_RX15M9() uint32 {
	return (volatile.LoadUint32(&o.RX15MASK.Reg) & 0x200) >> 9
}
func (o *CAN0_Type) SetRX15MASK_RX15M10(value uint32) {
	volatile.StoreUint32(&o.RX15MASK.Reg, volatile.LoadUint32(&o.RX15MASK.Reg)&^(0x400)|value<<10)
}
func (o *CAN0_Type) GetRX15MASK_RX15M10() uint32 {
	return (volatile.LoadUint32(&o.RX15MASK.Reg) & 0x400) >> 10
}
func (o *CAN0_Type) SetRX15MASK_RX15M11(value uint32) {
	volatile.StoreUint32(&o.RX15MASK.Reg, volatile.LoadUint32(&o.RX15MASK.Reg)&^(0x800)|value<<11)
}
func (o *CAN0_Type) GetRX15MASK_RX15M11() uint32 {
	return (volatile.LoadUint32(&o.RX15MASK.Reg) & 0x800) >> 11
}
func (o *CAN0_Type) SetRX15MASK_RX15M12(value uint32) {
	volatile.StoreUint32(&o.RX15MASK.Reg, volatile.LoadUint32(&o.RX15MASK.Reg)&^(0x1000)|value<<12)
}
func (o *CAN0_Type) GetRX15MASK_RX15M12() uint32 {
	return (volatile.LoadUint32(&o.RX15MASK.Reg) & 0x1000) >> 12
}
func (o *CAN0_Type) SetRX15MASK_RX15M13(value uint32) {
	volatile.StoreUint32(&o.RX15MASK.Reg, volatile.LoadUint32(&o.RX15MASK.Reg)&^(0x2000)|value<<13)
}
func (o *CAN0_Type) GetRX15MASK_RX15M13() uint32 {
	return (volatile.LoadUint32(&o.RX15MASK.Reg) & 0x2000) >> 13
}
func (o *CAN0_Type) SetRX15MASK_RX15M14(value uint32) {
	volatile.StoreUint32(&o.RX15MASK.Reg, volatile.LoadUint32(&o.RX15MASK.Reg)&^(0x4000)|value<<14)
}
func (o *CAN0_Type) GetRX15MASK_RX15M14() uint32 {
	return (volatile.LoadUint32(&o.RX15MASK.Reg) & 0x4000) >> 14
}
func (o *CAN0_Type) SetRX15MASK_RX15M15(value uint32) {
	volatile.StoreUint32(&o.RX15MASK.Reg, volatile.LoadUint32(&o.RX15MASK.Reg)&^(0x8000)|value<<15)
}
func (o *CAN0_Type) GetRX15MASK_RX15M15() uint32 {
	return (volatile.LoadUint32(&o.RX15MASK.Reg) & 0x8000) >> 15
}
func (o *CAN0_Type) SetRX15MASK_RX15M16(value uint32) {
	volatile.StoreUint32(&o.RX15MASK.Reg, volatile.LoadUint32(&o.RX15MASK.Reg)&^(0x10000)|value<<16)
}
func (o *CAN0_Type) GetRX15MASK_RX15M16() uint32 {
	return (volatile.LoadUint32(&o.RX15MASK.Reg) & 0x10000) >> 16
}
func (o *CAN0_Type) SetRX15MASK_RX15M17(value uint32) {
	volatile.StoreUint32(&o.RX15MASK.Reg, volatile.LoadUint32(&o.RX15MASK.Reg)&^(0x20000)|value<<17)
}
func (o *CAN0_Type) GetRX15MASK_RX15M17() uint32 {
	return (volatile.LoadUint32(&o.RX15MASK.Reg) & 0x20000) >> 17
}
func (o *CAN0_Type) SetRX15MASK_RX15M18(value uint32) {
	volatile.StoreUint32(&o.RX15MASK.Reg, volatile.LoadUint32(&o.RX15MASK.Reg)&^(0x40000)|value<<18)
}
func (o *CAN0_Type) GetRX15MASK_RX15M18() uint32 {
	return (volatile.LoadUint32(&o.RX15MASK.Reg) & 0x40000) >> 18
}
func (o *CAN0_Type) SetRX15MASK_RX15M19(value uint32) {
	volatile.StoreUint32(&o.RX15MASK.Reg, volatile.LoadUint32(&o.RX15MASK.Reg)&^(0x80000)|value<<19)
}
func (o *CAN0_Type) GetRX15MASK_RX15M19() uint32 {
	return (volatile.LoadUint32(&o.RX15MASK.Reg) & 0x80000) >> 19
}
func (o *CAN0_Type) SetRX15MASK_RX15M20(value uint32) {
	volatile.StoreUint32(&o.RX15MASK.Reg, volatile.LoadUint32(&o.RX15MASK.Reg)&^(0x100000)|value<<20)
}
func (o *CAN0_Type) GetRX15MASK_RX15M20() uint32 {
	return (volatile.LoadUint32(&o.RX15MASK.Reg) & 0x100000) >> 20
}
func (o *CAN0_Type) SetRX15MASK_RX15M21(value uint32) {
	volatile.StoreUint32(&o.RX15MASK.Reg, volatile.LoadUint32(&o.RX15MASK.Reg)&^(0x200000)|value<<21)
}
func (o *CAN0_Type) GetRX15MASK_RX15M21() uint32 {
	return (volatile.LoadUint32(&o.RX15MASK.Reg) & 0x200000) >> 21
}
func (o *CAN0_Type) SetRX15MASK_RX15M22(value uint32) {
	volatile.StoreUint32(&o.RX15MASK.Reg, volatile.LoadUint32(&o.RX15MASK.Reg)&^(0x400000)|value<<22)
}
func (o *CAN0_Type) GetRX15MASK_RX15M22() uint32 {
	return (volatile.LoadUint32(&o.RX15MASK.Reg) & 0x400000) >> 22
}
func (o *CAN0_Type) SetRX15MASK_RX15M23(value uint32) {
	volatile.StoreUint32(&o.RX15MASK.Reg, volatile.LoadUint32(&o.RX15MASK.Reg)&^(0x800000)|value<<23)
}
func (o *CAN0_Type) GetRX15MASK_RX15M23() uint32 {
	return (volatile.LoadUint32(&o.RX15MASK.Reg) & 0x800000) >> 23
}
func (o *CAN0_Type) SetRX15MASK_RX15M24(value uint32) {
	volatile.StoreUint32(&o.RX15MASK.Reg, volatile.LoadUint32(&o.RX15MASK.Reg)&^(0x1000000)|value<<24)
}
func (o *CAN0_Type) GetRX15MASK_RX15M24() uint32 {
	return (volatile.LoadUint32(&o.RX15MASK.Reg) & 0x1000000) >> 24
}
func (o *CAN0_Type) SetRX15MASK_RX15M25(value uint32) {
	volatile.StoreUint32(&o.RX15MASK.Reg, volatile.LoadUint32(&o.RX15MASK.Reg)&^(0x2000000)|value<<25)
}
func (o *CAN0_Type) GetRX15MASK_RX15M25() uint32 {
	return (volatile.LoadUint32(&o.RX15MASK.Reg) & 0x2000000) >> 25
}
func (o *CAN0_Type) SetRX15MASK_RX15M26(value uint32) {
	volatile.StoreUint32(&o.RX15MASK.Reg, volatile.LoadUint32(&o.RX15MASK.Reg)&^(0x4000000)|value<<26)
}
func (o *CAN0_Type) GetRX15MASK_RX15M26() uint32 {
	return (volatile.LoadUint32(&o.RX15MASK.Reg) & 0x4000000) >> 26
}
func (o *CAN0_Type) SetRX15MASK_RX15M27(value uint32) {
	volatile.StoreUint32(&o.RX15MASK.Reg, volatile.LoadUint32(&o.RX15MASK.Reg)&^(0x8000000)|value<<27)
}
func (o *CAN0_Type) GetRX15MASK_RX15M27() uint32 {
	return (volatile.LoadUint32(&o.RX15MASK.Reg) & 0x8000000) >> 27
}
func (o *CAN0_Type) SetRX15MASK_RX15M28(value uint32) {
	volatile.StoreUint32(&o.RX15MASK.Reg, volatile.LoadUint32(&o.RX15MASK.Reg)&^(0x10000000)|value<<28)
}
func (o *CAN0_Type) GetRX15MASK_RX15M28() uint32 {
	return (volatile.LoadUint32(&o.RX15MASK.Reg) & 0x10000000) >> 28
}
func (o *CAN0_Type) SetRX15MASK_RX15M29(value uint32) {
	volatile.StoreUint32(&o.RX15MASK.Reg, volatile.LoadUint32(&o.RX15MASK.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetRX15MASK_RX15M29() uint32 {
	return (volatile.LoadUint32(&o.RX15MASK.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetRX15MASK_RX15M30(value uint32) {
	volatile.StoreUint32(&o.RX15MASK.Reg, volatile.LoadUint32(&o.RX15MASK.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetRX15MASK_RX15M30() uint32 {
	return (volatile.LoadUint32(&o.RX15MASK.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetRX15MASK_RX15M31(value uint32) {
	volatile.StoreUint32(&o.RX15MASK.Reg, volatile.LoadUint32(&o.RX15MASK.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetRX15MASK_RX15M31() uint32 {
	return (volatile.LoadUint32(&o.RX15MASK.Reg) & 0x80000000) >> 31
}

// CAN0.ECR: Error Counter
func (o *CAN0_Type) SetECR_TXERRCNT(value uint32) {
	volatile.StoreUint32(&o.ECR.Reg, volatile.LoadUint32(&o.ECR.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetECR_TXERRCNT() uint32 {
	return volatile.LoadUint32(&o.ECR.Reg) & 0xff
}
func (o *CAN0_Type) SetECR_RXERRCNT(value uint32) {
	volatile.StoreUint32(&o.ECR.Reg, volatile.LoadUint32(&o.ECR.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetECR_RXERRCNT() uint32 {
	return (volatile.LoadUint32(&o.ECR.Reg) & 0xff00) >> 8
}

// CAN0.ESR1: Error and Status 1 register
func (o *CAN0_Type) SetESR1_WAKINT(value uint32) {
	volatile.StoreUint32(&o.ESR1.Reg, volatile.LoadUint32(&o.ESR1.Reg)&^(0x1)|value)
}
func (o *CAN0_Type) GetESR1_WAKINT() uint32 {
	return volatile.LoadUint32(&o.ESR1.Reg) & 0x1
}
func (o *CAN0_Type) SetESR1_ERRINT(value uint32) {
	volatile.StoreUint32(&o.ESR1.Reg, volatile.LoadUint32(&o.ESR1.Reg)&^(0x2)|value<<1)
}
func (o *CAN0_Type) GetESR1_ERRINT() uint32 {
	return (volatile.LoadUint32(&o.ESR1.Reg) & 0x2) >> 1
}
func (o *CAN0_Type) SetESR1_BOFFINT(value uint32) {
	volatile.StoreUint32(&o.ESR1.Reg, volatile.LoadUint32(&o.ESR1.Reg)&^(0x4)|value<<2)
}
func (o *CAN0_Type) GetESR1_BOFFINT() uint32 {
	return (volatile.LoadUint32(&o.ESR1.Reg) & 0x4) >> 2
}
func (o *CAN0_Type) SetESR1_RX(value uint32) {
	volatile.StoreUint32(&o.ESR1.Reg, volatile.LoadUint32(&o.ESR1.Reg)&^(0x8)|value<<3)
}
func (o *CAN0_Type) GetESR1_RX() uint32 {
	return (volatile.LoadUint32(&o.ESR1.Reg) & 0x8) >> 3
}
func (o *CAN0_Type) SetESR1_FLTCONF(value uint32) {
	volatile.StoreUint32(&o.ESR1.Reg, volatile.LoadUint32(&o.ESR1.Reg)&^(0x30)|value<<4)
}
func (o *CAN0_Type) GetESR1_FLTCONF() uint32 {
	return (volatile.LoadUint32(&o.ESR1.Reg) & 0x30) >> 4
}
func (o *CAN0_Type) SetESR1_TX(value uint32) {
	volatile.StoreUint32(&o.ESR1.Reg, volatile.LoadUint32(&o.ESR1.Reg)&^(0x40)|value<<6)
}
func (o *CAN0_Type) GetESR1_TX() uint32 {
	return (volatile.LoadUint32(&o.ESR1.Reg) & 0x40) >> 6
}
func (o *CAN0_Type) SetESR1_IDLE(value uint32) {
	volatile.StoreUint32(&o.ESR1.Reg, volatile.LoadUint32(&o.ESR1.Reg)&^(0x80)|value<<7)
}
func (o *CAN0_Type) GetESR1_IDLE() uint32 {
	return (volatile.LoadUint32(&o.ESR1.Reg) & 0x80) >> 7
}
func (o *CAN0_Type) SetESR1_RXWRN(value uint32) {
	volatile.StoreUint32(&o.ESR1.Reg, volatile.LoadUint32(&o.ESR1.Reg)&^(0x100)|value<<8)
}
func (o *CAN0_Type) GetESR1_RXWRN() uint32 {
	return (volatile.LoadUint32(&o.ESR1.Reg) & 0x100) >> 8
}
func (o *CAN0_Type) SetESR1_TXWRN(value uint32) {
	volatile.StoreUint32(&o.ESR1.Reg, volatile.LoadUint32(&o.ESR1.Reg)&^(0x200)|value<<9)
}
func (o *CAN0_Type) GetESR1_TXWRN() uint32 {
	return (volatile.LoadUint32(&o.ESR1.Reg) & 0x200) >> 9
}
func (o *CAN0_Type) SetESR1_STFERR(value uint32) {
	volatile.StoreUint32(&o.ESR1.Reg, volatile.LoadUint32(&o.ESR1.Reg)&^(0x400)|value<<10)
}
func (o *CAN0_Type) GetESR1_STFERR() uint32 {
	return (volatile.LoadUint32(&o.ESR1.Reg) & 0x400) >> 10
}
func (o *CAN0_Type) SetESR1_FRMERR(value uint32) {
	volatile.StoreUint32(&o.ESR1.Reg, volatile.LoadUint32(&o.ESR1.Reg)&^(0x800)|value<<11)
}
func (o *CAN0_Type) GetESR1_FRMERR() uint32 {
	return (volatile.LoadUint32(&o.ESR1.Reg) & 0x800) >> 11
}
func (o *CAN0_Type) SetESR1_CRCERR(value uint32) {
	volatile.StoreUint32(&o.ESR1.Reg, volatile.LoadUint32(&o.ESR1.Reg)&^(0x1000)|value<<12)
}
func (o *CAN0_Type) GetESR1_CRCERR() uint32 {
	return (volatile.LoadUint32(&o.ESR1.Reg) & 0x1000) >> 12
}
func (o *CAN0_Type) SetESR1_ACKERR(value uint32) {
	volatile.StoreUint32(&o.ESR1.Reg, volatile.LoadUint32(&o.ESR1.Reg)&^(0x2000)|value<<13)
}
func (o *CAN0_Type) GetESR1_ACKERR() uint32 {
	return (volatile.LoadUint32(&o.ESR1.Reg) & 0x2000) >> 13
}
func (o *CAN0_Type) SetESR1_BIT0ERR(value uint32) {
	volatile.StoreUint32(&o.ESR1.Reg, volatile.LoadUint32(&o.ESR1.Reg)&^(0x4000)|value<<14)
}
func (o *CAN0_Type) GetESR1_BIT0ERR() uint32 {
	return (volatile.LoadUint32(&o.ESR1.Reg) & 0x4000) >> 14
}
func (o *CAN0_Type) SetESR1_BIT1ERR(value uint32) {
	volatile.StoreUint32(&o.ESR1.Reg, volatile.LoadUint32(&o.ESR1.Reg)&^(0x8000)|value<<15)
}
func (o *CAN0_Type) GetESR1_BIT1ERR() uint32 {
	return (volatile.LoadUint32(&o.ESR1.Reg) & 0x8000) >> 15
}
func (o *CAN0_Type) SetESR1_RWRNINT(value uint32) {
	volatile.StoreUint32(&o.ESR1.Reg, volatile.LoadUint32(&o.ESR1.Reg)&^(0x10000)|value<<16)
}
func (o *CAN0_Type) GetESR1_RWRNINT() uint32 {
	return (volatile.LoadUint32(&o.ESR1.Reg) & 0x10000) >> 16
}
func (o *CAN0_Type) SetESR1_TWRNINT(value uint32) {
	volatile.StoreUint32(&o.ESR1.Reg, volatile.LoadUint32(&o.ESR1.Reg)&^(0x20000)|value<<17)
}
func (o *CAN0_Type) GetESR1_TWRNINT() uint32 {
	return (volatile.LoadUint32(&o.ESR1.Reg) & 0x20000) >> 17
}
func (o *CAN0_Type) SetESR1_SYNCH(value uint32) {
	volatile.StoreUint32(&o.ESR1.Reg, volatile.LoadUint32(&o.ESR1.Reg)&^(0x40000)|value<<18)
}
func (o *CAN0_Type) GetESR1_SYNCH() uint32 {
	return (volatile.LoadUint32(&o.ESR1.Reg) & 0x40000) >> 18
}

// CAN0.IMASK1: Interrupt Masks 1 register
func (o *CAN0_Type) SetIMASK1_BUFLM0(value uint32) {
	volatile.StoreUint32(&o.IMASK1.Reg, volatile.LoadUint32(&o.IMASK1.Reg)&^(0x1)|value)
}
func (o *CAN0_Type) GetIMASK1_BUFLM0() uint32 {
	return volatile.LoadUint32(&o.IMASK1.Reg) & 0x1
}
func (o *CAN0_Type) SetIMASK1_BUFLM1(value uint32) {
	volatile.StoreUint32(&o.IMASK1.Reg, volatile.LoadUint32(&o.IMASK1.Reg)&^(0x2)|value<<1)
}
func (o *CAN0_Type) GetIMASK1_BUFLM1() uint32 {
	return (volatile.LoadUint32(&o.IMASK1.Reg) & 0x2) >> 1
}
func (o *CAN0_Type) SetIMASK1_BUFLM2(value uint32) {
	volatile.StoreUint32(&o.IMASK1.Reg, volatile.LoadUint32(&o.IMASK1.Reg)&^(0x4)|value<<2)
}
func (o *CAN0_Type) GetIMASK1_BUFLM2() uint32 {
	return (volatile.LoadUint32(&o.IMASK1.Reg) & 0x4) >> 2
}
func (o *CAN0_Type) SetIMASK1_BUFLM3(value uint32) {
	volatile.StoreUint32(&o.IMASK1.Reg, volatile.LoadUint32(&o.IMASK1.Reg)&^(0x8)|value<<3)
}
func (o *CAN0_Type) GetIMASK1_BUFLM3() uint32 {
	return (volatile.LoadUint32(&o.IMASK1.Reg) & 0x8) >> 3
}
func (o *CAN0_Type) SetIMASK1_BUFLM4(value uint32) {
	volatile.StoreUint32(&o.IMASK1.Reg, volatile.LoadUint32(&o.IMASK1.Reg)&^(0x10)|value<<4)
}
func (o *CAN0_Type) GetIMASK1_BUFLM4() uint32 {
	return (volatile.LoadUint32(&o.IMASK1.Reg) & 0x10) >> 4
}
func (o *CAN0_Type) SetIMASK1_BUFLM5(value uint32) {
	volatile.StoreUint32(&o.IMASK1.Reg, volatile.LoadUint32(&o.IMASK1.Reg)&^(0x20)|value<<5)
}
func (o *CAN0_Type) GetIMASK1_BUFLM5() uint32 {
	return (volatile.LoadUint32(&o.IMASK1.Reg) & 0x20) >> 5
}
func (o *CAN0_Type) SetIMASK1_BUFLM6(value uint32) {
	volatile.StoreUint32(&o.IMASK1.Reg, volatile.LoadUint32(&o.IMASK1.Reg)&^(0x40)|value<<6)
}
func (o *CAN0_Type) GetIMASK1_BUFLM6() uint32 {
	return (volatile.LoadUint32(&o.IMASK1.Reg) & 0x40) >> 6
}
func (o *CAN0_Type) SetIMASK1_BUFLM7(value uint32) {
	volatile.StoreUint32(&o.IMASK1.Reg, volatile.LoadUint32(&o.IMASK1.Reg)&^(0x80)|value<<7)
}
func (o *CAN0_Type) GetIMASK1_BUFLM7() uint32 {
	return (volatile.LoadUint32(&o.IMASK1.Reg) & 0x80) >> 7
}
func (o *CAN0_Type) SetIMASK1_BUFLM8(value uint32) {
	volatile.StoreUint32(&o.IMASK1.Reg, volatile.LoadUint32(&o.IMASK1.Reg)&^(0x100)|value<<8)
}
func (o *CAN0_Type) GetIMASK1_BUFLM8() uint32 {
	return (volatile.LoadUint32(&o.IMASK1.Reg) & 0x100) >> 8
}
func (o *CAN0_Type) SetIMASK1_BUFLM9(value uint32) {
	volatile.StoreUint32(&o.IMASK1.Reg, volatile.LoadUint32(&o.IMASK1.Reg)&^(0x200)|value<<9)
}
func (o *CAN0_Type) GetIMASK1_BUFLM9() uint32 {
	return (volatile.LoadUint32(&o.IMASK1.Reg) & 0x200) >> 9
}
func (o *CAN0_Type) SetIMASK1_BUFLM10(value uint32) {
	volatile.StoreUint32(&o.IMASK1.Reg, volatile.LoadUint32(&o.IMASK1.Reg)&^(0x400)|value<<10)
}
func (o *CAN0_Type) GetIMASK1_BUFLM10() uint32 {
	return (volatile.LoadUint32(&o.IMASK1.Reg) & 0x400) >> 10
}
func (o *CAN0_Type) SetIMASK1_BUFLM11(value uint32) {
	volatile.StoreUint32(&o.IMASK1.Reg, volatile.LoadUint32(&o.IMASK1.Reg)&^(0x800)|value<<11)
}
func (o *CAN0_Type) GetIMASK1_BUFLM11() uint32 {
	return (volatile.LoadUint32(&o.IMASK1.Reg) & 0x800) >> 11
}
func (o *CAN0_Type) SetIMASK1_BUFLM12(value uint32) {
	volatile.StoreUint32(&o.IMASK1.Reg, volatile.LoadUint32(&o.IMASK1.Reg)&^(0x1000)|value<<12)
}
func (o *CAN0_Type) GetIMASK1_BUFLM12() uint32 {
	return (volatile.LoadUint32(&o.IMASK1.Reg) & 0x1000) >> 12
}
func (o *CAN0_Type) SetIMASK1_BUFLM13(value uint32) {
	volatile.StoreUint32(&o.IMASK1.Reg, volatile.LoadUint32(&o.IMASK1.Reg)&^(0x2000)|value<<13)
}
func (o *CAN0_Type) GetIMASK1_BUFLM13() uint32 {
	return (volatile.LoadUint32(&o.IMASK1.Reg) & 0x2000) >> 13
}
func (o *CAN0_Type) SetIMASK1_BUFLM14(value uint32) {
	volatile.StoreUint32(&o.IMASK1.Reg, volatile.LoadUint32(&o.IMASK1.Reg)&^(0x4000)|value<<14)
}
func (o *CAN0_Type) GetIMASK1_BUFLM14() uint32 {
	return (volatile.LoadUint32(&o.IMASK1.Reg) & 0x4000) >> 14
}
func (o *CAN0_Type) SetIMASK1_BUFLM15(value uint32) {
	volatile.StoreUint32(&o.IMASK1.Reg, volatile.LoadUint32(&o.IMASK1.Reg)&^(0x8000)|value<<15)
}
func (o *CAN0_Type) GetIMASK1_BUFLM15() uint32 {
	return (volatile.LoadUint32(&o.IMASK1.Reg) & 0x8000) >> 15
}
func (o *CAN0_Type) SetIMASK1_BUFLM16(value uint32) {
	volatile.StoreUint32(&o.IMASK1.Reg, volatile.LoadUint32(&o.IMASK1.Reg)&^(0x10000)|value<<16)
}
func (o *CAN0_Type) GetIMASK1_BUFLM16() uint32 {
	return (volatile.LoadUint32(&o.IMASK1.Reg) & 0x10000) >> 16
}
func (o *CAN0_Type) SetIMASK1_BUFLM17(value uint32) {
	volatile.StoreUint32(&o.IMASK1.Reg, volatile.LoadUint32(&o.IMASK1.Reg)&^(0x20000)|value<<17)
}
func (o *CAN0_Type) GetIMASK1_BUFLM17() uint32 {
	return (volatile.LoadUint32(&o.IMASK1.Reg) & 0x20000) >> 17
}
func (o *CAN0_Type) SetIMASK1_BUFLM18(value uint32) {
	volatile.StoreUint32(&o.IMASK1.Reg, volatile.LoadUint32(&o.IMASK1.Reg)&^(0x40000)|value<<18)
}
func (o *CAN0_Type) GetIMASK1_BUFLM18() uint32 {
	return (volatile.LoadUint32(&o.IMASK1.Reg) & 0x40000) >> 18
}
func (o *CAN0_Type) SetIMASK1_BUFLM19(value uint32) {
	volatile.StoreUint32(&o.IMASK1.Reg, volatile.LoadUint32(&o.IMASK1.Reg)&^(0x80000)|value<<19)
}
func (o *CAN0_Type) GetIMASK1_BUFLM19() uint32 {
	return (volatile.LoadUint32(&o.IMASK1.Reg) & 0x80000) >> 19
}
func (o *CAN0_Type) SetIMASK1_BUFLM20(value uint32) {
	volatile.StoreUint32(&o.IMASK1.Reg, volatile.LoadUint32(&o.IMASK1.Reg)&^(0x100000)|value<<20)
}
func (o *CAN0_Type) GetIMASK1_BUFLM20() uint32 {
	return (volatile.LoadUint32(&o.IMASK1.Reg) & 0x100000) >> 20
}
func (o *CAN0_Type) SetIMASK1_BUFLM21(value uint32) {
	volatile.StoreUint32(&o.IMASK1.Reg, volatile.LoadUint32(&o.IMASK1.Reg)&^(0x200000)|value<<21)
}
func (o *CAN0_Type) GetIMASK1_BUFLM21() uint32 {
	return (volatile.LoadUint32(&o.IMASK1.Reg) & 0x200000) >> 21
}
func (o *CAN0_Type) SetIMASK1_BUFLM22(value uint32) {
	volatile.StoreUint32(&o.IMASK1.Reg, volatile.LoadUint32(&o.IMASK1.Reg)&^(0x400000)|value<<22)
}
func (o *CAN0_Type) GetIMASK1_BUFLM22() uint32 {
	return (volatile.LoadUint32(&o.IMASK1.Reg) & 0x400000) >> 22
}
func (o *CAN0_Type) SetIMASK1_BUFLM23(value uint32) {
	volatile.StoreUint32(&o.IMASK1.Reg, volatile.LoadUint32(&o.IMASK1.Reg)&^(0x800000)|value<<23)
}
func (o *CAN0_Type) GetIMASK1_BUFLM23() uint32 {
	return (volatile.LoadUint32(&o.IMASK1.Reg) & 0x800000) >> 23
}
func (o *CAN0_Type) SetIMASK1_BUFLM24(value uint32) {
	volatile.StoreUint32(&o.IMASK1.Reg, volatile.LoadUint32(&o.IMASK1.Reg)&^(0x1000000)|value<<24)
}
func (o *CAN0_Type) GetIMASK1_BUFLM24() uint32 {
	return (volatile.LoadUint32(&o.IMASK1.Reg) & 0x1000000) >> 24
}
func (o *CAN0_Type) SetIMASK1_BUFLM25(value uint32) {
	volatile.StoreUint32(&o.IMASK1.Reg, volatile.LoadUint32(&o.IMASK1.Reg)&^(0x2000000)|value<<25)
}
func (o *CAN0_Type) GetIMASK1_BUFLM25() uint32 {
	return (volatile.LoadUint32(&o.IMASK1.Reg) & 0x2000000) >> 25
}
func (o *CAN0_Type) SetIMASK1_BUFLM26(value uint32) {
	volatile.StoreUint32(&o.IMASK1.Reg, volatile.LoadUint32(&o.IMASK1.Reg)&^(0x4000000)|value<<26)
}
func (o *CAN0_Type) GetIMASK1_BUFLM26() uint32 {
	return (volatile.LoadUint32(&o.IMASK1.Reg) & 0x4000000) >> 26
}
func (o *CAN0_Type) SetIMASK1_BUFLM27(value uint32) {
	volatile.StoreUint32(&o.IMASK1.Reg, volatile.LoadUint32(&o.IMASK1.Reg)&^(0x8000000)|value<<27)
}
func (o *CAN0_Type) GetIMASK1_BUFLM27() uint32 {
	return (volatile.LoadUint32(&o.IMASK1.Reg) & 0x8000000) >> 27
}
func (o *CAN0_Type) SetIMASK1_BUFLM28(value uint32) {
	volatile.StoreUint32(&o.IMASK1.Reg, volatile.LoadUint32(&o.IMASK1.Reg)&^(0x10000000)|value<<28)
}
func (o *CAN0_Type) GetIMASK1_BUFLM28() uint32 {
	return (volatile.LoadUint32(&o.IMASK1.Reg) & 0x10000000) >> 28
}
func (o *CAN0_Type) SetIMASK1_BUFLM29(value uint32) {
	volatile.StoreUint32(&o.IMASK1.Reg, volatile.LoadUint32(&o.IMASK1.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetIMASK1_BUFLM29() uint32 {
	return (volatile.LoadUint32(&o.IMASK1.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetIMASK1_BUFLM30(value uint32) {
	volatile.StoreUint32(&o.IMASK1.Reg, volatile.LoadUint32(&o.IMASK1.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetIMASK1_BUFLM30() uint32 {
	return (volatile.LoadUint32(&o.IMASK1.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetIMASK1_BUFLM31(value uint32) {
	volatile.StoreUint32(&o.IMASK1.Reg, volatile.LoadUint32(&o.IMASK1.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetIMASK1_BUFLM31() uint32 {
	return (volatile.LoadUint32(&o.IMASK1.Reg) & 0x80000000) >> 31
}

// CAN0.IFLAG1: Interrupt Flags 1 register
func (o *CAN0_Type) SetIFLAG1_BUF0I(value uint32) {
	volatile.StoreUint32(&o.IFLAG1.Reg, volatile.LoadUint32(&o.IFLAG1.Reg)&^(0x1)|value)
}
func (o *CAN0_Type) GetIFLAG1_BUF0I() uint32 {
	return volatile.LoadUint32(&o.IFLAG1.Reg) & 0x1
}
func (o *CAN0_Type) SetIFLAG1_BUF4TO1I0(value uint32) {
	volatile.StoreUint32(&o.IFLAG1.Reg, volatile.LoadUint32(&o.IFLAG1.Reg)&^(0x2)|value<<1)
}
func (o *CAN0_Type) GetIFLAG1_BUF4TO1I0() uint32 {
	return (volatile.LoadUint32(&o.IFLAG1.Reg) & 0x2) >> 1
}
func (o *CAN0_Type) SetIFLAG1_BUF4TO1I1(value uint32) {
	volatile.StoreUint32(&o.IFLAG1.Reg, volatile.LoadUint32(&o.IFLAG1.Reg)&^(0x4)|value<<2)
}
func (o *CAN0_Type) GetIFLAG1_BUF4TO1I1() uint32 {
	return (volatile.LoadUint32(&o.IFLAG1.Reg) & 0x4) >> 2
}
func (o *CAN0_Type) SetIFLAG1_BUF4TO1I2(value uint32) {
	volatile.StoreUint32(&o.IFLAG1.Reg, volatile.LoadUint32(&o.IFLAG1.Reg)&^(0x8)|value<<3)
}
func (o *CAN0_Type) GetIFLAG1_BUF4TO1I2() uint32 {
	return (volatile.LoadUint32(&o.IFLAG1.Reg) & 0x8) >> 3
}
func (o *CAN0_Type) SetIFLAG1_BUF4TO1I3(value uint32) {
	volatile.StoreUint32(&o.IFLAG1.Reg, volatile.LoadUint32(&o.IFLAG1.Reg)&^(0x10)|value<<4)
}
func (o *CAN0_Type) GetIFLAG1_BUF4TO1I3() uint32 {
	return (volatile.LoadUint32(&o.IFLAG1.Reg) & 0x10) >> 4
}
func (o *CAN0_Type) SetIFLAG1_BUF5I(value uint32) {
	volatile.StoreUint32(&o.IFLAG1.Reg, volatile.LoadUint32(&o.IFLAG1.Reg)&^(0x20)|value<<5)
}
func (o *CAN0_Type) GetIFLAG1_BUF5I() uint32 {
	return (volatile.LoadUint32(&o.IFLAG1.Reg) & 0x20) >> 5
}
func (o *CAN0_Type) SetIFLAG1_BUF6I(value uint32) {
	volatile.StoreUint32(&o.IFLAG1.Reg, volatile.LoadUint32(&o.IFLAG1.Reg)&^(0x40)|value<<6)
}
func (o *CAN0_Type) GetIFLAG1_BUF6I() uint32 {
	return (volatile.LoadUint32(&o.IFLAG1.Reg) & 0x40) >> 6
}
func (o *CAN0_Type) SetIFLAG1_BUF7I(value uint32) {
	volatile.StoreUint32(&o.IFLAG1.Reg, volatile.LoadUint32(&o.IFLAG1.Reg)&^(0x80)|value<<7)
}
func (o *CAN0_Type) GetIFLAG1_BUF7I() uint32 {
	return (volatile.LoadUint32(&o.IFLAG1.Reg) & 0x80) >> 7
}
func (o *CAN0_Type) SetIFLAG1_BUF31TO8I0(value uint32) {
	volatile.StoreUint32(&o.IFLAG1.Reg, volatile.LoadUint32(&o.IFLAG1.Reg)&^(0x100)|value<<8)
}
func (o *CAN0_Type) GetIFLAG1_BUF31TO8I0() uint32 {
	return (volatile.LoadUint32(&o.IFLAG1.Reg) & 0x100) >> 8
}
func (o *CAN0_Type) SetIFLAG1_BUF31TO8I1(value uint32) {
	volatile.StoreUint32(&o.IFLAG1.Reg, volatile.LoadUint32(&o.IFLAG1.Reg)&^(0x200)|value<<9)
}
func (o *CAN0_Type) GetIFLAG1_BUF31TO8I1() uint32 {
	return (volatile.LoadUint32(&o.IFLAG1.Reg) & 0x200) >> 9
}
func (o *CAN0_Type) SetIFLAG1_BUF31TO8I2(value uint32) {
	volatile.StoreUint32(&o.IFLAG1.Reg, volatile.LoadUint32(&o.IFLAG1.Reg)&^(0x400)|value<<10)
}
func (o *CAN0_Type) GetIFLAG1_BUF31TO8I2() uint32 {
	return (volatile.LoadUint32(&o.IFLAG1.Reg) & 0x400) >> 10
}
func (o *CAN0_Type) SetIFLAG1_BUF31TO8I3(value uint32) {
	volatile.StoreUint32(&o.IFLAG1.Reg, volatile.LoadUint32(&o.IFLAG1.Reg)&^(0x800)|value<<11)
}
func (o *CAN0_Type) GetIFLAG1_BUF31TO8I3() uint32 {
	return (volatile.LoadUint32(&o.IFLAG1.Reg) & 0x800) >> 11
}
func (o *CAN0_Type) SetIFLAG1_BUF31TO8I4(value uint32) {
	volatile.StoreUint32(&o.IFLAG1.Reg, volatile.LoadUint32(&o.IFLAG1.Reg)&^(0x1000)|value<<12)
}
func (o *CAN0_Type) GetIFLAG1_BUF31TO8I4() uint32 {
	return (volatile.LoadUint32(&o.IFLAG1.Reg) & 0x1000) >> 12
}
func (o *CAN0_Type) SetIFLAG1_BUF31TO8I5(value uint32) {
	volatile.StoreUint32(&o.IFLAG1.Reg, volatile.LoadUint32(&o.IFLAG1.Reg)&^(0x2000)|value<<13)
}
func (o *CAN0_Type) GetIFLAG1_BUF31TO8I5() uint32 {
	return (volatile.LoadUint32(&o.IFLAG1.Reg) & 0x2000) >> 13
}
func (o *CAN0_Type) SetIFLAG1_BUF31TO8I6(value uint32) {
	volatile.StoreUint32(&o.IFLAG1.Reg, volatile.LoadUint32(&o.IFLAG1.Reg)&^(0x4000)|value<<14)
}
func (o *CAN0_Type) GetIFLAG1_BUF31TO8I6() uint32 {
	return (volatile.LoadUint32(&o.IFLAG1.Reg) & 0x4000) >> 14
}
func (o *CAN0_Type) SetIFLAG1_BUF31TO8I7(value uint32) {
	volatile.StoreUint32(&o.IFLAG1.Reg, volatile.LoadUint32(&o.IFLAG1.Reg)&^(0x8000)|value<<15)
}
func (o *CAN0_Type) GetIFLAG1_BUF31TO8I7() uint32 {
	return (volatile.LoadUint32(&o.IFLAG1.Reg) & 0x8000) >> 15
}
func (o *CAN0_Type) SetIFLAG1_BUF31TO8I8(value uint32) {
	volatile.StoreUint32(&o.IFLAG1.Reg, volatile.LoadUint32(&o.IFLAG1.Reg)&^(0x10000)|value<<16)
}
func (o *CAN0_Type) GetIFLAG1_BUF31TO8I8() uint32 {
	return (volatile.LoadUint32(&o.IFLAG1.Reg) & 0x10000) >> 16
}
func (o *CAN0_Type) SetIFLAG1_BUF31TO8I9(value uint32) {
	volatile.StoreUint32(&o.IFLAG1.Reg, volatile.LoadUint32(&o.IFLAG1.Reg)&^(0x20000)|value<<17)
}
func (o *CAN0_Type) GetIFLAG1_BUF31TO8I9() uint32 {
	return (volatile.LoadUint32(&o.IFLAG1.Reg) & 0x20000) >> 17
}
func (o *CAN0_Type) SetIFLAG1_BUF31TO8I10(value uint32) {
	volatile.StoreUint32(&o.IFLAG1.Reg, volatile.LoadUint32(&o.IFLAG1.Reg)&^(0x40000)|value<<18)
}
func (o *CAN0_Type) GetIFLAG1_BUF31TO8I10() uint32 {
	return (volatile.LoadUint32(&o.IFLAG1.Reg) & 0x40000) >> 18
}
func (o *CAN0_Type) SetIFLAG1_BUF31TO8I11(value uint32) {
	volatile.StoreUint32(&o.IFLAG1.Reg, volatile.LoadUint32(&o.IFLAG1.Reg)&^(0x80000)|value<<19)
}
func (o *CAN0_Type) GetIFLAG1_BUF31TO8I11() uint32 {
	return (volatile.LoadUint32(&o.IFLAG1.Reg) & 0x80000) >> 19
}
func (o *CAN0_Type) SetIFLAG1_BUF31TO8I12(value uint32) {
	volatile.StoreUint32(&o.IFLAG1.Reg, volatile.LoadUint32(&o.IFLAG1.Reg)&^(0x100000)|value<<20)
}
func (o *CAN0_Type) GetIFLAG1_BUF31TO8I12() uint32 {
	return (volatile.LoadUint32(&o.IFLAG1.Reg) & 0x100000) >> 20
}
func (o *CAN0_Type) SetIFLAG1_BUF31TO8I13(value uint32) {
	volatile.StoreUint32(&o.IFLAG1.Reg, volatile.LoadUint32(&o.IFLAG1.Reg)&^(0x200000)|value<<21)
}
func (o *CAN0_Type) GetIFLAG1_BUF31TO8I13() uint32 {
	return (volatile.LoadUint32(&o.IFLAG1.Reg) & 0x200000) >> 21
}
func (o *CAN0_Type) SetIFLAG1_BUF31TO8I14(value uint32) {
	volatile.StoreUint32(&o.IFLAG1.Reg, volatile.LoadUint32(&o.IFLAG1.Reg)&^(0x400000)|value<<22)
}
func (o *CAN0_Type) GetIFLAG1_BUF31TO8I14() uint32 {
	return (volatile.LoadUint32(&o.IFLAG1.Reg) & 0x400000) >> 22
}
func (o *CAN0_Type) SetIFLAG1_BUF31TO8I15(value uint32) {
	volatile.StoreUint32(&o.IFLAG1.Reg, volatile.LoadUint32(&o.IFLAG1.Reg)&^(0x800000)|value<<23)
}
func (o *CAN0_Type) GetIFLAG1_BUF31TO8I15() uint32 {
	return (volatile.LoadUint32(&o.IFLAG1.Reg) & 0x800000) >> 23
}
func (o *CAN0_Type) SetIFLAG1_BUF31TO8I16(value uint32) {
	volatile.StoreUint32(&o.IFLAG1.Reg, volatile.LoadUint32(&o.IFLAG1.Reg)&^(0x1000000)|value<<24)
}
func (o *CAN0_Type) GetIFLAG1_BUF31TO8I16() uint32 {
	return (volatile.LoadUint32(&o.IFLAG1.Reg) & 0x1000000) >> 24
}
func (o *CAN0_Type) SetIFLAG1_BUF31TO8I17(value uint32) {
	volatile.StoreUint32(&o.IFLAG1.Reg, volatile.LoadUint32(&o.IFLAG1.Reg)&^(0x2000000)|value<<25)
}
func (o *CAN0_Type) GetIFLAG1_BUF31TO8I17() uint32 {
	return (volatile.LoadUint32(&o.IFLAG1.Reg) & 0x2000000) >> 25
}
func (o *CAN0_Type) SetIFLAG1_BUF31TO8I18(value uint32) {
	volatile.StoreUint32(&o.IFLAG1.Reg, volatile.LoadUint32(&o.IFLAG1.Reg)&^(0x4000000)|value<<26)
}
func (o *CAN0_Type) GetIFLAG1_BUF31TO8I18() uint32 {
	return (volatile.LoadUint32(&o.IFLAG1.Reg) & 0x4000000) >> 26
}
func (o *CAN0_Type) SetIFLAG1_BUF31TO8I19(value uint32) {
	volatile.StoreUint32(&o.IFLAG1.Reg, volatile.LoadUint32(&o.IFLAG1.Reg)&^(0x8000000)|value<<27)
}
func (o *CAN0_Type) GetIFLAG1_BUF31TO8I19() uint32 {
	return (volatile.LoadUint32(&o.IFLAG1.Reg) & 0x8000000) >> 27
}
func (o *CAN0_Type) SetIFLAG1_BUF31TO8I20(value uint32) {
	volatile.StoreUint32(&o.IFLAG1.Reg, volatile.LoadUint32(&o.IFLAG1.Reg)&^(0x10000000)|value<<28)
}
func (o *CAN0_Type) GetIFLAG1_BUF31TO8I20() uint32 {
	return (volatile.LoadUint32(&o.IFLAG1.Reg) & 0x10000000) >> 28
}
func (o *CAN0_Type) SetIFLAG1_BUF31TO8I21(value uint32) {
	volatile.StoreUint32(&o.IFLAG1.Reg, volatile.LoadUint32(&o.IFLAG1.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetIFLAG1_BUF31TO8I21() uint32 {
	return (volatile.LoadUint32(&o.IFLAG1.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetIFLAG1_BUF31TO8I22(value uint32) {
	volatile.StoreUint32(&o.IFLAG1.Reg, volatile.LoadUint32(&o.IFLAG1.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetIFLAG1_BUF31TO8I22() uint32 {
	return (volatile.LoadUint32(&o.IFLAG1.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetIFLAG1_BUF31TO8I23(value uint32) {
	volatile.StoreUint32(&o.IFLAG1.Reg, volatile.LoadUint32(&o.IFLAG1.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetIFLAG1_BUF31TO8I23() uint32 {
	return (volatile.LoadUint32(&o.IFLAG1.Reg) & 0x80000000) >> 31
}

// CAN0.CTRL2: Control 2 register
func (o *CAN0_Type) SetCTRL2_EACEN(value uint32) {
	volatile.StoreUint32(&o.CTRL2.Reg, volatile.LoadUint32(&o.CTRL2.Reg)&^(0x10000)|value<<16)
}
func (o *CAN0_Type) GetCTRL2_EACEN() uint32 {
	return (volatile.LoadUint32(&o.CTRL2.Reg) & 0x10000) >> 16
}
func (o *CAN0_Type) SetCTRL2_RRS(value uint32) {
	volatile.StoreUint32(&o.CTRL2.Reg, volatile.LoadUint32(&o.CTRL2.Reg)&^(0x20000)|value<<17)
}
func (o *CAN0_Type) GetCTRL2_RRS() uint32 {
	return (volatile.LoadUint32(&o.CTRL2.Reg) & 0x20000) >> 17
}
func (o *CAN0_Type) SetCTRL2_MRP(value uint32) {
	volatile.StoreUint32(&o.CTRL2.Reg, volatile.LoadUint32(&o.CTRL2.Reg)&^(0x40000)|value<<18)
}
func (o *CAN0_Type) GetCTRL2_MRP() uint32 {
	return (volatile.LoadUint32(&o.CTRL2.Reg) & 0x40000) >> 18
}
func (o *CAN0_Type) SetCTRL2_TASD(value uint32) {
	volatile.StoreUint32(&o.CTRL2.Reg, volatile.LoadUint32(&o.CTRL2.Reg)&^(0xf80000)|value<<19)
}
func (o *CAN0_Type) GetCTRL2_TASD() uint32 {
	return (volatile.LoadUint32(&o.CTRL2.Reg) & 0xf80000) >> 19
}
func (o *CAN0_Type) SetCTRL2_RFFN(value uint32) {
	volatile.StoreUint32(&o.CTRL2.Reg, volatile.LoadUint32(&o.CTRL2.Reg)&^(0xf000000)|value<<24)
}
func (o *CAN0_Type) GetCTRL2_RFFN() uint32 {
	return (volatile.LoadUint32(&o.CTRL2.Reg) & 0xf000000) >> 24
}
func (o *CAN0_Type) SetCTRL2_WRMFRZ(value uint32) {
	volatile.StoreUint32(&o.CTRL2.Reg, volatile.LoadUint32(&o.CTRL2.Reg)&^(0x10000000)|value<<28)
}
func (o *CAN0_Type) GetCTRL2_WRMFRZ() uint32 {
	return (volatile.LoadUint32(&o.CTRL2.Reg) & 0x10000000) >> 28
}

// CAN0.ESR2: Error and Status 2 register
func (o *CAN0_Type) SetESR2_IMB(value uint32) {
	volatile.StoreUint32(&o.ESR2.Reg, volatile.LoadUint32(&o.ESR2.Reg)&^(0x2000)|value<<13)
}
func (o *CAN0_Type) GetESR2_IMB() uint32 {
	return (volatile.LoadUint32(&o.ESR2.Reg) & 0x2000) >> 13
}
func (o *CAN0_Type) SetESR2_VPS(value uint32) {
	volatile.StoreUint32(&o.ESR2.Reg, volatile.LoadUint32(&o.ESR2.Reg)&^(0x4000)|value<<14)
}
func (o *CAN0_Type) GetESR2_VPS() uint32 {
	return (volatile.LoadUint32(&o.ESR2.Reg) & 0x4000) >> 14
}
func (o *CAN0_Type) SetESR2_LPTM(value uint32) {
	volatile.StoreUint32(&o.ESR2.Reg, volatile.LoadUint32(&o.ESR2.Reg)&^(0x7f0000)|value<<16)
}
func (o *CAN0_Type) GetESR2_LPTM() uint32 {
	return (volatile.LoadUint32(&o.ESR2.Reg) & 0x7f0000) >> 16
}

// CAN0.CRCR: CRC Register
func (o *CAN0_Type) SetCRCR_TXCRC(value uint32) {
	volatile.StoreUint32(&o.CRCR.Reg, volatile.LoadUint32(&o.CRCR.Reg)&^(0x7fff)|value)
}
func (o *CAN0_Type) GetCRCR_TXCRC() uint32 {
	return volatile.LoadUint32(&o.CRCR.Reg) & 0x7fff
}
func (o *CAN0_Type) SetCRCR_MBCRC(value uint32) {
	volatile.StoreUint32(&o.CRCR.Reg, volatile.LoadUint32(&o.CRCR.Reg)&^(0x7f0000)|value<<16)
}
func (o *CAN0_Type) GetCRCR_MBCRC() uint32 {
	return (volatile.LoadUint32(&o.CRCR.Reg) & 0x7f0000) >> 16
}

// CAN0.RXFGMASK: Rx FIFO Global Mask register
func (o *CAN0_Type) SetRXFGMASK_FGM0(value uint32) {
	volatile.StoreUint32(&o.RXFGMASK.Reg, volatile.LoadUint32(&o.RXFGMASK.Reg)&^(0x1)|value)
}
func (o *CAN0_Type) GetRXFGMASK_FGM0() uint32 {
	return volatile.LoadUint32(&o.RXFGMASK.Reg) & 0x1
}
func (o *CAN0_Type) SetRXFGMASK_FGM1(value uint32) {
	volatile.StoreUint32(&o.RXFGMASK.Reg, volatile.LoadUint32(&o.RXFGMASK.Reg)&^(0x2)|value<<1)
}
func (o *CAN0_Type) GetRXFGMASK_FGM1() uint32 {
	return (volatile.LoadUint32(&o.RXFGMASK.Reg) & 0x2) >> 1
}
func (o *CAN0_Type) SetRXFGMASK_FGM2(value uint32) {
	volatile.StoreUint32(&o.RXFGMASK.Reg, volatile.LoadUint32(&o.RXFGMASK.Reg)&^(0x4)|value<<2)
}
func (o *CAN0_Type) GetRXFGMASK_FGM2() uint32 {
	return (volatile.LoadUint32(&o.RXFGMASK.Reg) & 0x4) >> 2
}
func (o *CAN0_Type) SetRXFGMASK_FGM3(value uint32) {
	volatile.StoreUint32(&o.RXFGMASK.Reg, volatile.LoadUint32(&o.RXFGMASK.Reg)&^(0x8)|value<<3)
}
func (o *CAN0_Type) GetRXFGMASK_FGM3() uint32 {
	return (volatile.LoadUint32(&o.RXFGMASK.Reg) & 0x8) >> 3
}
func (o *CAN0_Type) SetRXFGMASK_FGM4(value uint32) {
	volatile.StoreUint32(&o.RXFGMASK.Reg, volatile.LoadUint32(&o.RXFGMASK.Reg)&^(0x10)|value<<4)
}
func (o *CAN0_Type) GetRXFGMASK_FGM4() uint32 {
	return (volatile.LoadUint32(&o.RXFGMASK.Reg) & 0x10) >> 4
}
func (o *CAN0_Type) SetRXFGMASK_FGM5(value uint32) {
	volatile.StoreUint32(&o.RXFGMASK.Reg, volatile.LoadUint32(&o.RXFGMASK.Reg)&^(0x20)|value<<5)
}
func (o *CAN0_Type) GetRXFGMASK_FGM5() uint32 {
	return (volatile.LoadUint32(&o.RXFGMASK.Reg) & 0x20) >> 5
}
func (o *CAN0_Type) SetRXFGMASK_FGM6(value uint32) {
	volatile.StoreUint32(&o.RXFGMASK.Reg, volatile.LoadUint32(&o.RXFGMASK.Reg)&^(0x40)|value<<6)
}
func (o *CAN0_Type) GetRXFGMASK_FGM6() uint32 {
	return (volatile.LoadUint32(&o.RXFGMASK.Reg) & 0x40) >> 6
}
func (o *CAN0_Type) SetRXFGMASK_FGM7(value uint32) {
	volatile.StoreUint32(&o.RXFGMASK.Reg, volatile.LoadUint32(&o.RXFGMASK.Reg)&^(0x80)|value<<7)
}
func (o *CAN0_Type) GetRXFGMASK_FGM7() uint32 {
	return (volatile.LoadUint32(&o.RXFGMASK.Reg) & 0x80) >> 7
}
func (o *CAN0_Type) SetRXFGMASK_FGM8(value uint32) {
	volatile.StoreUint32(&o.RXFGMASK.Reg, volatile.LoadUint32(&o.RXFGMASK.Reg)&^(0x100)|value<<8)
}
func (o *CAN0_Type) GetRXFGMASK_FGM8() uint32 {
	return (volatile.LoadUint32(&o.RXFGMASK.Reg) & 0x100) >> 8
}
func (o *CAN0_Type) SetRXFGMASK_FGM9(value uint32) {
	volatile.StoreUint32(&o.RXFGMASK.Reg, volatile.LoadUint32(&o.RXFGMASK.Reg)&^(0x200)|value<<9)
}
func (o *CAN0_Type) GetRXFGMASK_FGM9() uint32 {
	return (volatile.LoadUint32(&o.RXFGMASK.Reg) & 0x200) >> 9
}
func (o *CAN0_Type) SetRXFGMASK_FGM10(value uint32) {
	volatile.StoreUint32(&o.RXFGMASK.Reg, volatile.LoadUint32(&o.RXFGMASK.Reg)&^(0x400)|value<<10)
}
func (o *CAN0_Type) GetRXFGMASK_FGM10() uint32 {
	return (volatile.LoadUint32(&o.RXFGMASK.Reg) & 0x400) >> 10
}
func (o *CAN0_Type) SetRXFGMASK_FGM11(value uint32) {
	volatile.StoreUint32(&o.RXFGMASK.Reg, volatile.LoadUint32(&o.RXFGMASK.Reg)&^(0x800)|value<<11)
}
func (o *CAN0_Type) GetRXFGMASK_FGM11() uint32 {
	return (volatile.LoadUint32(&o.RXFGMASK.Reg) & 0x800) >> 11
}
func (o *CAN0_Type) SetRXFGMASK_FGM12(value uint32) {
	volatile.StoreUint32(&o.RXFGMASK.Reg, volatile.LoadUint32(&o.RXFGMASK.Reg)&^(0x1000)|value<<12)
}
func (o *CAN0_Type) GetRXFGMASK_FGM12() uint32 {
	return (volatile.LoadUint32(&o.RXFGMASK.Reg) & 0x1000) >> 12
}
func (o *CAN0_Type) SetRXFGMASK_FGM13(value uint32) {
	volatile.StoreUint32(&o.RXFGMASK.Reg, volatile.LoadUint32(&o.RXFGMASK.Reg)&^(0x2000)|value<<13)
}
func (o *CAN0_Type) GetRXFGMASK_FGM13() uint32 {
	return (volatile.LoadUint32(&o.RXFGMASK.Reg) & 0x2000) >> 13
}
func (o *CAN0_Type) SetRXFGMASK_FGM14(value uint32) {
	volatile.StoreUint32(&o.RXFGMASK.Reg, volatile.LoadUint32(&o.RXFGMASK.Reg)&^(0x4000)|value<<14)
}
func (o *CAN0_Type) GetRXFGMASK_FGM14() uint32 {
	return (volatile.LoadUint32(&o.RXFGMASK.Reg) & 0x4000) >> 14
}
func (o *CAN0_Type) SetRXFGMASK_FGM15(value uint32) {
	volatile.StoreUint32(&o.RXFGMASK.Reg, volatile.LoadUint32(&o.RXFGMASK.Reg)&^(0x8000)|value<<15)
}
func (o *CAN0_Type) GetRXFGMASK_FGM15() uint32 {
	return (volatile.LoadUint32(&o.RXFGMASK.Reg) & 0x8000) >> 15
}
func (o *CAN0_Type) SetRXFGMASK_FGM16(value uint32) {
	volatile.StoreUint32(&o.RXFGMASK.Reg, volatile.LoadUint32(&o.RXFGMASK.Reg)&^(0x10000)|value<<16)
}
func (o *CAN0_Type) GetRXFGMASK_FGM16() uint32 {
	return (volatile.LoadUint32(&o.RXFGMASK.Reg) & 0x10000) >> 16
}
func (o *CAN0_Type) SetRXFGMASK_FGM17(value uint32) {
	volatile.StoreUint32(&o.RXFGMASK.Reg, volatile.LoadUint32(&o.RXFGMASK.Reg)&^(0x20000)|value<<17)
}
func (o *CAN0_Type) GetRXFGMASK_FGM17() uint32 {
	return (volatile.LoadUint32(&o.RXFGMASK.Reg) & 0x20000) >> 17
}
func (o *CAN0_Type) SetRXFGMASK_FGM18(value uint32) {
	volatile.StoreUint32(&o.RXFGMASK.Reg, volatile.LoadUint32(&o.RXFGMASK.Reg)&^(0x40000)|value<<18)
}
func (o *CAN0_Type) GetRXFGMASK_FGM18() uint32 {
	return (volatile.LoadUint32(&o.RXFGMASK.Reg) & 0x40000) >> 18
}
func (o *CAN0_Type) SetRXFGMASK_FGM19(value uint32) {
	volatile.StoreUint32(&o.RXFGMASK.Reg, volatile.LoadUint32(&o.RXFGMASK.Reg)&^(0x80000)|value<<19)
}
func (o *CAN0_Type) GetRXFGMASK_FGM19() uint32 {
	return (volatile.LoadUint32(&o.RXFGMASK.Reg) & 0x80000) >> 19
}
func (o *CAN0_Type) SetRXFGMASK_FGM20(value uint32) {
	volatile.StoreUint32(&o.RXFGMASK.Reg, volatile.LoadUint32(&o.RXFGMASK.Reg)&^(0x100000)|value<<20)
}
func (o *CAN0_Type) GetRXFGMASK_FGM20() uint32 {
	return (volatile.LoadUint32(&o.RXFGMASK.Reg) & 0x100000) >> 20
}
func (o *CAN0_Type) SetRXFGMASK_FGM21(value uint32) {
	volatile.StoreUint32(&o.RXFGMASK.Reg, volatile.LoadUint32(&o.RXFGMASK.Reg)&^(0x200000)|value<<21)
}
func (o *CAN0_Type) GetRXFGMASK_FGM21() uint32 {
	return (volatile.LoadUint32(&o.RXFGMASK.Reg) & 0x200000) >> 21
}
func (o *CAN0_Type) SetRXFGMASK_FGM22(value uint32) {
	volatile.StoreUint32(&o.RXFGMASK.Reg, volatile.LoadUint32(&o.RXFGMASK.Reg)&^(0x400000)|value<<22)
}
func (o *CAN0_Type) GetRXFGMASK_FGM22() uint32 {
	return (volatile.LoadUint32(&o.RXFGMASK.Reg) & 0x400000) >> 22
}
func (o *CAN0_Type) SetRXFGMASK_FGM23(value uint32) {
	volatile.StoreUint32(&o.RXFGMASK.Reg, volatile.LoadUint32(&o.RXFGMASK.Reg)&^(0x800000)|value<<23)
}
func (o *CAN0_Type) GetRXFGMASK_FGM23() uint32 {
	return (volatile.LoadUint32(&o.RXFGMASK.Reg) & 0x800000) >> 23
}
func (o *CAN0_Type) SetRXFGMASK_FGM24(value uint32) {
	volatile.StoreUint32(&o.RXFGMASK.Reg, volatile.LoadUint32(&o.RXFGMASK.Reg)&^(0x1000000)|value<<24)
}
func (o *CAN0_Type) GetRXFGMASK_FGM24() uint32 {
	return (volatile.LoadUint32(&o.RXFGMASK.Reg) & 0x1000000) >> 24
}
func (o *CAN0_Type) SetRXFGMASK_FGM25(value uint32) {
	volatile.StoreUint32(&o.RXFGMASK.Reg, volatile.LoadUint32(&o.RXFGMASK.Reg)&^(0x2000000)|value<<25)
}
func (o *CAN0_Type) GetRXFGMASK_FGM25() uint32 {
	return (volatile.LoadUint32(&o.RXFGMASK.Reg) & 0x2000000) >> 25
}
func (o *CAN0_Type) SetRXFGMASK_FGM26(value uint32) {
	volatile.StoreUint32(&o.RXFGMASK.Reg, volatile.LoadUint32(&o.RXFGMASK.Reg)&^(0x4000000)|value<<26)
}
func (o *CAN0_Type) GetRXFGMASK_FGM26() uint32 {
	return (volatile.LoadUint32(&o.RXFGMASK.Reg) & 0x4000000) >> 26
}
func (o *CAN0_Type) SetRXFGMASK_FGM27(value uint32) {
	volatile.StoreUint32(&o.RXFGMASK.Reg, volatile.LoadUint32(&o.RXFGMASK.Reg)&^(0x8000000)|value<<27)
}
func (o *CAN0_Type) GetRXFGMASK_FGM27() uint32 {
	return (volatile.LoadUint32(&o.RXFGMASK.Reg) & 0x8000000) >> 27
}
func (o *CAN0_Type) SetRXFGMASK_FGM28(value uint32) {
	volatile.StoreUint32(&o.RXFGMASK.Reg, volatile.LoadUint32(&o.RXFGMASK.Reg)&^(0x10000000)|value<<28)
}
func (o *CAN0_Type) GetRXFGMASK_FGM28() uint32 {
	return (volatile.LoadUint32(&o.RXFGMASK.Reg) & 0x10000000) >> 28
}
func (o *CAN0_Type) SetRXFGMASK_FGM29(value uint32) {
	volatile.StoreUint32(&o.RXFGMASK.Reg, volatile.LoadUint32(&o.RXFGMASK.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetRXFGMASK_FGM29() uint32 {
	return (volatile.LoadUint32(&o.RXFGMASK.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetRXFGMASK_FGM30(value uint32) {
	volatile.StoreUint32(&o.RXFGMASK.Reg, volatile.LoadUint32(&o.RXFGMASK.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetRXFGMASK_FGM30() uint32 {
	return (volatile.LoadUint32(&o.RXFGMASK.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetRXFGMASK_FGM31(value uint32) {
	volatile.StoreUint32(&o.RXFGMASK.Reg, volatile.LoadUint32(&o.RXFGMASK.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetRXFGMASK_FGM31() uint32 {
	return (volatile.LoadUint32(&o.RXFGMASK.Reg) & 0x80000000) >> 31
}

// CAN0.RXFIR: Rx FIFO Information Register
func (o *CAN0_Type) SetRXFIR_IDHIT(value uint32) {
	volatile.StoreUint32(&o.RXFIR.Reg, volatile.LoadUint32(&o.RXFIR.Reg)&^(0x1ff)|value)
}
func (o *CAN0_Type) GetRXFIR_IDHIT() uint32 {
	return volatile.LoadUint32(&o.RXFIR.Reg) & 0x1ff
}

// CAN0.CS0: Message Buffer 0 CS Register
func (o *CAN0_Type) SetCS0_TIME_STAMP(value uint32) {
	volatile.StoreUint32(&o.CS0.Reg, volatile.LoadUint32(&o.CS0.Reg)&^(0xffff)|value)
}
func (o *CAN0_Type) GetCS0_TIME_STAMP() uint32 {
	return volatile.LoadUint32(&o.CS0.Reg) & 0xffff
}
func (o *CAN0_Type) SetCS0_DLC(value uint32) {
	volatile.StoreUint32(&o.CS0.Reg, volatile.LoadUint32(&o.CS0.Reg)&^(0xf0000)|value<<16)
}
func (o *CAN0_Type) GetCS0_DLC() uint32 {
	return (volatile.LoadUint32(&o.CS0.Reg) & 0xf0000) >> 16
}
func (o *CAN0_Type) SetCS0_RTR(value uint32) {
	volatile.StoreUint32(&o.CS0.Reg, volatile.LoadUint32(&o.CS0.Reg)&^(0x100000)|value<<20)
}
func (o *CAN0_Type) GetCS0_RTR() uint32 {
	return (volatile.LoadUint32(&o.CS0.Reg) & 0x100000) >> 20
}
func (o *CAN0_Type) SetCS0_IDE(value uint32) {
	volatile.StoreUint32(&o.CS0.Reg, volatile.LoadUint32(&o.CS0.Reg)&^(0x200000)|value<<21)
}
func (o *CAN0_Type) GetCS0_IDE() uint32 {
	return (volatile.LoadUint32(&o.CS0.Reg) & 0x200000) >> 21
}
func (o *CAN0_Type) SetCS0_SRR(value uint32) {
	volatile.StoreUint32(&o.CS0.Reg, volatile.LoadUint32(&o.CS0.Reg)&^(0x400000)|value<<22)
}
func (o *CAN0_Type) GetCS0_SRR() uint32 {
	return (volatile.LoadUint32(&o.CS0.Reg) & 0x400000) >> 22
}
func (o *CAN0_Type) SetCS0_CODE(value uint32) {
	volatile.StoreUint32(&o.CS0.Reg, volatile.LoadUint32(&o.CS0.Reg)&^(0xf000000)|value<<24)
}
func (o *CAN0_Type) GetCS0_CODE() uint32 {
	return (volatile.LoadUint32(&o.CS0.Reg) & 0xf000000) >> 24
}

// CAN0.ID0: Message Buffer 0 ID Register
func (o *CAN0_Type) SetID0_EXT(value uint32) {
	volatile.StoreUint32(&o.ID0.Reg, volatile.LoadUint32(&o.ID0.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetID0_EXT() uint32 {
	return volatile.LoadUint32(&o.ID0.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetID0_STD(value uint32) {
	volatile.StoreUint32(&o.ID0.Reg, volatile.LoadUint32(&o.ID0.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetID0_STD() uint32 {
	return (volatile.LoadUint32(&o.ID0.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetID0_PRIO(value uint32) {
	volatile.StoreUint32(&o.ID0.Reg, volatile.LoadUint32(&o.ID0.Reg)&^(0xe0000000)|value<<29)
}
func (o *CAN0_Type) GetID0_PRIO() uint32 {
	return (volatile.LoadUint32(&o.ID0.Reg) & 0xe0000000) >> 29
}

// CAN0.WORD00: Message Buffer 0 WORD0 Register
func (o *CAN0_Type) SetWORD00_DATA_BYTE_3(value uint32) {
	volatile.StoreUint32(&o.WORD00.Reg, volatile.LoadUint32(&o.WORD00.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetWORD00_DATA_BYTE_3() uint32 {
	return volatile.LoadUint32(&o.WORD00.Reg) & 0xff
}
func (o *CAN0_Type) SetWORD00_DATA_BYTE_2(value uint32) {
	volatile.StoreUint32(&o.WORD00.Reg, volatile.LoadUint32(&o.WORD00.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetWORD00_DATA_BYTE_2() uint32 {
	return (volatile.LoadUint32(&o.WORD00.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetWORD00_DATA_BYTE_1(value uint32) {
	volatile.StoreUint32(&o.WORD00.Reg, volatile.LoadUint32(&o.WORD00.Reg)&^(0xff0000)|value<<16)
}
func (o *CAN0_Type) GetWORD00_DATA_BYTE_1() uint32 {
	return (volatile.LoadUint32(&o.WORD00.Reg) & 0xff0000) >> 16
}
func (o *CAN0_Type) SetWORD00_DATA_BYTE_0(value uint32) {
	volatile.StoreUint32(&o.WORD00.Reg, volatile.LoadUint32(&o.WORD00.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN0_Type) GetWORD00_DATA_BYTE_0() uint32 {
	return (volatile.LoadUint32(&o.WORD00.Reg) & 0xff000000) >> 24
}

// CAN0.WORD10: Message Buffer 0 WORD1 Register
func (o *CAN0_Type) SetWORD10_DATA_BYTE_7(value uint32) {
	volatile.StoreUint32(&o.WORD10.Reg, volatile.LoadUint32(&o.WORD10.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetWORD10_DATA_BYTE_7() uint32 {
	return volatile.LoadUint32(&o.WORD10.Reg) & 0xff
}
func (o *CAN0_Type) SetWORD10_DATA_BYTE_6(value uint32) {
	volatile.StoreUint32(&o.WORD10.Reg, volatile.LoadUint32(&o.WORD10.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetWORD10_DATA_BYTE_6() uint32 {
	return (volatile.LoadUint32(&o.WORD10.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetWORD10_DATA_BYTE_5(value uint32) {
	volatile.StoreUint32(&o.WORD10.Reg, volatile.LoadUint32(&o.WORD10.Reg)&^(0xff0000)|value<<16)
}
func (o *CAN0_Type) GetWORD10_DATA_BYTE_5() uint32 {
	return (volatile.LoadUint32(&o.WORD10.Reg) & 0xff0000) >> 16
}
func (o *CAN0_Type) SetWORD10_DATA_BYTE_4(value uint32) {
	volatile.StoreUint32(&o.WORD10.Reg, volatile.LoadUint32(&o.WORD10.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN0_Type) GetWORD10_DATA_BYTE_4() uint32 {
	return (volatile.LoadUint32(&o.WORD10.Reg) & 0xff000000) >> 24
}

// CAN0.CS1: Message Buffer 1 CS Register
func (o *CAN0_Type) SetCS1_TIME_STAMP(value uint32) {
	volatile.StoreUint32(&o.CS1.Reg, volatile.LoadUint32(&o.CS1.Reg)&^(0xffff)|value)
}
func (o *CAN0_Type) GetCS1_TIME_STAMP() uint32 {
	return volatile.LoadUint32(&o.CS1.Reg) & 0xffff
}
func (o *CAN0_Type) SetCS1_DLC(value uint32) {
	volatile.StoreUint32(&o.CS1.Reg, volatile.LoadUint32(&o.CS1.Reg)&^(0xf0000)|value<<16)
}
func (o *CAN0_Type) GetCS1_DLC() uint32 {
	return (volatile.LoadUint32(&o.CS1.Reg) & 0xf0000) >> 16
}
func (o *CAN0_Type) SetCS1_RTR(value uint32) {
	volatile.StoreUint32(&o.CS1.Reg, volatile.LoadUint32(&o.CS1.Reg)&^(0x100000)|value<<20)
}
func (o *CAN0_Type) GetCS1_RTR() uint32 {
	return (volatile.LoadUint32(&o.CS1.Reg) & 0x100000) >> 20
}
func (o *CAN0_Type) SetCS1_IDE(value uint32) {
	volatile.StoreUint32(&o.CS1.Reg, volatile.LoadUint32(&o.CS1.Reg)&^(0x200000)|value<<21)
}
func (o *CAN0_Type) GetCS1_IDE() uint32 {
	return (volatile.LoadUint32(&o.CS1.Reg) & 0x200000) >> 21
}
func (o *CAN0_Type) SetCS1_SRR(value uint32) {
	volatile.StoreUint32(&o.CS1.Reg, volatile.LoadUint32(&o.CS1.Reg)&^(0x400000)|value<<22)
}
func (o *CAN0_Type) GetCS1_SRR() uint32 {
	return (volatile.LoadUint32(&o.CS1.Reg) & 0x400000) >> 22
}
func (o *CAN0_Type) SetCS1_CODE(value uint32) {
	volatile.StoreUint32(&o.CS1.Reg, volatile.LoadUint32(&o.CS1.Reg)&^(0xf000000)|value<<24)
}
func (o *CAN0_Type) GetCS1_CODE() uint32 {
	return (volatile.LoadUint32(&o.CS1.Reg) & 0xf000000) >> 24
}

// CAN0.ID1: Message Buffer 1 ID Register
func (o *CAN0_Type) SetID1_EXT(value uint32) {
	volatile.StoreUint32(&o.ID1.Reg, volatile.LoadUint32(&o.ID1.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetID1_EXT() uint32 {
	return volatile.LoadUint32(&o.ID1.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetID1_STD(value uint32) {
	volatile.StoreUint32(&o.ID1.Reg, volatile.LoadUint32(&o.ID1.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetID1_STD() uint32 {
	return (volatile.LoadUint32(&o.ID1.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetID1_PRIO(value uint32) {
	volatile.StoreUint32(&o.ID1.Reg, volatile.LoadUint32(&o.ID1.Reg)&^(0xe0000000)|value<<29)
}
func (o *CAN0_Type) GetID1_PRIO() uint32 {
	return (volatile.LoadUint32(&o.ID1.Reg) & 0xe0000000) >> 29
}

// CAN0.WORD01: Message Buffer 1 WORD0 Register
func (o *CAN0_Type) SetWORD01_DATA_BYTE_3(value uint32) {
	volatile.StoreUint32(&o.WORD01.Reg, volatile.LoadUint32(&o.WORD01.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetWORD01_DATA_BYTE_3() uint32 {
	return volatile.LoadUint32(&o.WORD01.Reg) & 0xff
}
func (o *CAN0_Type) SetWORD01_DATA_BYTE_2(value uint32) {
	volatile.StoreUint32(&o.WORD01.Reg, volatile.LoadUint32(&o.WORD01.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetWORD01_DATA_BYTE_2() uint32 {
	return (volatile.LoadUint32(&o.WORD01.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetWORD01_DATA_BYTE_1(value uint32) {
	volatile.StoreUint32(&o.WORD01.Reg, volatile.LoadUint32(&o.WORD01.Reg)&^(0xff0000)|value<<16)
}
func (o *CAN0_Type) GetWORD01_DATA_BYTE_1() uint32 {
	return (volatile.LoadUint32(&o.WORD01.Reg) & 0xff0000) >> 16
}
func (o *CAN0_Type) SetWORD01_DATA_BYTE_0(value uint32) {
	volatile.StoreUint32(&o.WORD01.Reg, volatile.LoadUint32(&o.WORD01.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN0_Type) GetWORD01_DATA_BYTE_0() uint32 {
	return (volatile.LoadUint32(&o.WORD01.Reg) & 0xff000000) >> 24
}

// CAN0.WORD11: Message Buffer 1 WORD1 Register
func (o *CAN0_Type) SetWORD11_DATA_BYTE_7(value uint32) {
	volatile.StoreUint32(&o.WORD11.Reg, volatile.LoadUint32(&o.WORD11.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetWORD11_DATA_BYTE_7() uint32 {
	return volatile.LoadUint32(&o.WORD11.Reg) & 0xff
}
func (o *CAN0_Type) SetWORD11_DATA_BYTE_6(value uint32) {
	volatile.StoreUint32(&o.WORD11.Reg, volatile.LoadUint32(&o.WORD11.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetWORD11_DATA_BYTE_6() uint32 {
	return (volatile.LoadUint32(&o.WORD11.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetWORD11_DATA_BYTE_5(value uint32) {
	volatile.StoreUint32(&o.WORD11.Reg, volatile.LoadUint32(&o.WORD11.Reg)&^(0xff0000)|value<<16)
}
func (o *CAN0_Type) GetWORD11_DATA_BYTE_5() uint32 {
	return (volatile.LoadUint32(&o.WORD11.Reg) & 0xff0000) >> 16
}
func (o *CAN0_Type) SetWORD11_DATA_BYTE_4(value uint32) {
	volatile.StoreUint32(&o.WORD11.Reg, volatile.LoadUint32(&o.WORD11.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN0_Type) GetWORD11_DATA_BYTE_4() uint32 {
	return (volatile.LoadUint32(&o.WORD11.Reg) & 0xff000000) >> 24
}

// CAN0.CS2: Message Buffer 2 CS Register
func (o *CAN0_Type) SetCS2_TIME_STAMP(value uint32) {
	volatile.StoreUint32(&o.CS2.Reg, volatile.LoadUint32(&o.CS2.Reg)&^(0xffff)|value)
}
func (o *CAN0_Type) GetCS2_TIME_STAMP() uint32 {
	return volatile.LoadUint32(&o.CS2.Reg) & 0xffff
}
func (o *CAN0_Type) SetCS2_DLC(value uint32) {
	volatile.StoreUint32(&o.CS2.Reg, volatile.LoadUint32(&o.CS2.Reg)&^(0xf0000)|value<<16)
}
func (o *CAN0_Type) GetCS2_DLC() uint32 {
	return (volatile.LoadUint32(&o.CS2.Reg) & 0xf0000) >> 16
}
func (o *CAN0_Type) SetCS2_RTR(value uint32) {
	volatile.StoreUint32(&o.CS2.Reg, volatile.LoadUint32(&o.CS2.Reg)&^(0x100000)|value<<20)
}
func (o *CAN0_Type) GetCS2_RTR() uint32 {
	return (volatile.LoadUint32(&o.CS2.Reg) & 0x100000) >> 20
}
func (o *CAN0_Type) SetCS2_IDE(value uint32) {
	volatile.StoreUint32(&o.CS2.Reg, volatile.LoadUint32(&o.CS2.Reg)&^(0x200000)|value<<21)
}
func (o *CAN0_Type) GetCS2_IDE() uint32 {
	return (volatile.LoadUint32(&o.CS2.Reg) & 0x200000) >> 21
}
func (o *CAN0_Type) SetCS2_SRR(value uint32) {
	volatile.StoreUint32(&o.CS2.Reg, volatile.LoadUint32(&o.CS2.Reg)&^(0x400000)|value<<22)
}
func (o *CAN0_Type) GetCS2_SRR() uint32 {
	return (volatile.LoadUint32(&o.CS2.Reg) & 0x400000) >> 22
}
func (o *CAN0_Type) SetCS2_CODE(value uint32) {
	volatile.StoreUint32(&o.CS2.Reg, volatile.LoadUint32(&o.CS2.Reg)&^(0xf000000)|value<<24)
}
func (o *CAN0_Type) GetCS2_CODE() uint32 {
	return (volatile.LoadUint32(&o.CS2.Reg) & 0xf000000) >> 24
}

// CAN0.ID2: Message Buffer 2 ID Register
func (o *CAN0_Type) SetID2_EXT(value uint32) {
	volatile.StoreUint32(&o.ID2.Reg, volatile.LoadUint32(&o.ID2.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetID2_EXT() uint32 {
	return volatile.LoadUint32(&o.ID2.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetID2_STD(value uint32) {
	volatile.StoreUint32(&o.ID2.Reg, volatile.LoadUint32(&o.ID2.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetID2_STD() uint32 {
	return (volatile.LoadUint32(&o.ID2.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetID2_PRIO(value uint32) {
	volatile.StoreUint32(&o.ID2.Reg, volatile.LoadUint32(&o.ID2.Reg)&^(0xe0000000)|value<<29)
}
func (o *CAN0_Type) GetID2_PRIO() uint32 {
	return (volatile.LoadUint32(&o.ID2.Reg) & 0xe0000000) >> 29
}

// CAN0.WORD02: Message Buffer 2 WORD0 Register
func (o *CAN0_Type) SetWORD02_DATA_BYTE_3(value uint32) {
	volatile.StoreUint32(&o.WORD02.Reg, volatile.LoadUint32(&o.WORD02.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetWORD02_DATA_BYTE_3() uint32 {
	return volatile.LoadUint32(&o.WORD02.Reg) & 0xff
}
func (o *CAN0_Type) SetWORD02_DATA_BYTE_2(value uint32) {
	volatile.StoreUint32(&o.WORD02.Reg, volatile.LoadUint32(&o.WORD02.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetWORD02_DATA_BYTE_2() uint32 {
	return (volatile.LoadUint32(&o.WORD02.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetWORD02_DATA_BYTE_1(value uint32) {
	volatile.StoreUint32(&o.WORD02.Reg, volatile.LoadUint32(&o.WORD02.Reg)&^(0xff0000)|value<<16)
}
func (o *CAN0_Type) GetWORD02_DATA_BYTE_1() uint32 {
	return (volatile.LoadUint32(&o.WORD02.Reg) & 0xff0000) >> 16
}
func (o *CAN0_Type) SetWORD02_DATA_BYTE_0(value uint32) {
	volatile.StoreUint32(&o.WORD02.Reg, volatile.LoadUint32(&o.WORD02.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN0_Type) GetWORD02_DATA_BYTE_0() uint32 {
	return (volatile.LoadUint32(&o.WORD02.Reg) & 0xff000000) >> 24
}

// CAN0.WORD12: Message Buffer 2 WORD1 Register
func (o *CAN0_Type) SetWORD12_DATA_BYTE_7(value uint32) {
	volatile.StoreUint32(&o.WORD12.Reg, volatile.LoadUint32(&o.WORD12.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetWORD12_DATA_BYTE_7() uint32 {
	return volatile.LoadUint32(&o.WORD12.Reg) & 0xff
}
func (o *CAN0_Type) SetWORD12_DATA_BYTE_6(value uint32) {
	volatile.StoreUint32(&o.WORD12.Reg, volatile.LoadUint32(&o.WORD12.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetWORD12_DATA_BYTE_6() uint32 {
	return (volatile.LoadUint32(&o.WORD12.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetWORD12_DATA_BYTE_5(value uint32) {
	volatile.StoreUint32(&o.WORD12.Reg, volatile.LoadUint32(&o.WORD12.Reg)&^(0xff0000)|value<<16)
}
func (o *CAN0_Type) GetWORD12_DATA_BYTE_5() uint32 {
	return (volatile.LoadUint32(&o.WORD12.Reg) & 0xff0000) >> 16
}
func (o *CAN0_Type) SetWORD12_DATA_BYTE_4(value uint32) {
	volatile.StoreUint32(&o.WORD12.Reg, volatile.LoadUint32(&o.WORD12.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN0_Type) GetWORD12_DATA_BYTE_4() uint32 {
	return (volatile.LoadUint32(&o.WORD12.Reg) & 0xff000000) >> 24
}

// CAN0.CS3: Message Buffer 3 CS Register
func (o *CAN0_Type) SetCS3_TIME_STAMP(value uint32) {
	volatile.StoreUint32(&o.CS3.Reg, volatile.LoadUint32(&o.CS3.Reg)&^(0xffff)|value)
}
func (o *CAN0_Type) GetCS3_TIME_STAMP() uint32 {
	return volatile.LoadUint32(&o.CS3.Reg) & 0xffff
}
func (o *CAN0_Type) SetCS3_DLC(value uint32) {
	volatile.StoreUint32(&o.CS3.Reg, volatile.LoadUint32(&o.CS3.Reg)&^(0xf0000)|value<<16)
}
func (o *CAN0_Type) GetCS3_DLC() uint32 {
	return (volatile.LoadUint32(&o.CS3.Reg) & 0xf0000) >> 16
}
func (o *CAN0_Type) SetCS3_RTR(value uint32) {
	volatile.StoreUint32(&o.CS3.Reg, volatile.LoadUint32(&o.CS3.Reg)&^(0x100000)|value<<20)
}
func (o *CAN0_Type) GetCS3_RTR() uint32 {
	return (volatile.LoadUint32(&o.CS3.Reg) & 0x100000) >> 20
}
func (o *CAN0_Type) SetCS3_IDE(value uint32) {
	volatile.StoreUint32(&o.CS3.Reg, volatile.LoadUint32(&o.CS3.Reg)&^(0x200000)|value<<21)
}
func (o *CAN0_Type) GetCS3_IDE() uint32 {
	return (volatile.LoadUint32(&o.CS3.Reg) & 0x200000) >> 21
}
func (o *CAN0_Type) SetCS3_SRR(value uint32) {
	volatile.StoreUint32(&o.CS3.Reg, volatile.LoadUint32(&o.CS3.Reg)&^(0x400000)|value<<22)
}
func (o *CAN0_Type) GetCS3_SRR() uint32 {
	return (volatile.LoadUint32(&o.CS3.Reg) & 0x400000) >> 22
}
func (o *CAN0_Type) SetCS3_CODE(value uint32) {
	volatile.StoreUint32(&o.CS3.Reg, volatile.LoadUint32(&o.CS3.Reg)&^(0xf000000)|value<<24)
}
func (o *CAN0_Type) GetCS3_CODE() uint32 {
	return (volatile.LoadUint32(&o.CS3.Reg) & 0xf000000) >> 24
}

// CAN0.ID3: Message Buffer 3 ID Register
func (o *CAN0_Type) SetID3_EXT(value uint32) {
	volatile.StoreUint32(&o.ID3.Reg, volatile.LoadUint32(&o.ID3.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetID3_EXT() uint32 {
	return volatile.LoadUint32(&o.ID3.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetID3_STD(value uint32) {
	volatile.StoreUint32(&o.ID3.Reg, volatile.LoadUint32(&o.ID3.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetID3_STD() uint32 {
	return (volatile.LoadUint32(&o.ID3.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetID3_PRIO(value uint32) {
	volatile.StoreUint32(&o.ID3.Reg, volatile.LoadUint32(&o.ID3.Reg)&^(0xe0000000)|value<<29)
}
func (o *CAN0_Type) GetID3_PRIO() uint32 {
	return (volatile.LoadUint32(&o.ID3.Reg) & 0xe0000000) >> 29
}

// CAN0.WORD03: Message Buffer 3 WORD0 Register
func (o *CAN0_Type) SetWORD03_DATA_BYTE_3(value uint32) {
	volatile.StoreUint32(&o.WORD03.Reg, volatile.LoadUint32(&o.WORD03.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetWORD03_DATA_BYTE_3() uint32 {
	return volatile.LoadUint32(&o.WORD03.Reg) & 0xff
}
func (o *CAN0_Type) SetWORD03_DATA_BYTE_2(value uint32) {
	volatile.StoreUint32(&o.WORD03.Reg, volatile.LoadUint32(&o.WORD03.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetWORD03_DATA_BYTE_2() uint32 {
	return (volatile.LoadUint32(&o.WORD03.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetWORD03_DATA_BYTE_1(value uint32) {
	volatile.StoreUint32(&o.WORD03.Reg, volatile.LoadUint32(&o.WORD03.Reg)&^(0xff0000)|value<<16)
}
func (o *CAN0_Type) GetWORD03_DATA_BYTE_1() uint32 {
	return (volatile.LoadUint32(&o.WORD03.Reg) & 0xff0000) >> 16
}
func (o *CAN0_Type) SetWORD03_DATA_BYTE_0(value uint32) {
	volatile.StoreUint32(&o.WORD03.Reg, volatile.LoadUint32(&o.WORD03.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN0_Type) GetWORD03_DATA_BYTE_0() uint32 {
	return (volatile.LoadUint32(&o.WORD03.Reg) & 0xff000000) >> 24
}

// CAN0.WORD13: Message Buffer 3 WORD1 Register
func (o *CAN0_Type) SetWORD13_DATA_BYTE_7(value uint32) {
	volatile.StoreUint32(&o.WORD13.Reg, volatile.LoadUint32(&o.WORD13.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetWORD13_DATA_BYTE_7() uint32 {
	return volatile.LoadUint32(&o.WORD13.Reg) & 0xff
}
func (o *CAN0_Type) SetWORD13_DATA_BYTE_6(value uint32) {
	volatile.StoreUint32(&o.WORD13.Reg, volatile.LoadUint32(&o.WORD13.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetWORD13_DATA_BYTE_6() uint32 {
	return (volatile.LoadUint32(&o.WORD13.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetWORD13_DATA_BYTE_5(value uint32) {
	volatile.StoreUint32(&o.WORD13.Reg, volatile.LoadUint32(&o.WORD13.Reg)&^(0xff0000)|value<<16)
}
func (o *CAN0_Type) GetWORD13_DATA_BYTE_5() uint32 {
	return (volatile.LoadUint32(&o.WORD13.Reg) & 0xff0000) >> 16
}
func (o *CAN0_Type) SetWORD13_DATA_BYTE_4(value uint32) {
	volatile.StoreUint32(&o.WORD13.Reg, volatile.LoadUint32(&o.WORD13.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN0_Type) GetWORD13_DATA_BYTE_4() uint32 {
	return (volatile.LoadUint32(&o.WORD13.Reg) & 0xff000000) >> 24
}

// CAN0.CS4: Message Buffer 4 CS Register
func (o *CAN0_Type) SetCS4_TIME_STAMP(value uint32) {
	volatile.StoreUint32(&o.CS4.Reg, volatile.LoadUint32(&o.CS4.Reg)&^(0xffff)|value)
}
func (o *CAN0_Type) GetCS4_TIME_STAMP() uint32 {
	return volatile.LoadUint32(&o.CS4.Reg) & 0xffff
}
func (o *CAN0_Type) SetCS4_DLC(value uint32) {
	volatile.StoreUint32(&o.CS4.Reg, volatile.LoadUint32(&o.CS4.Reg)&^(0xf0000)|value<<16)
}
func (o *CAN0_Type) GetCS4_DLC() uint32 {
	return (volatile.LoadUint32(&o.CS4.Reg) & 0xf0000) >> 16
}
func (o *CAN0_Type) SetCS4_RTR(value uint32) {
	volatile.StoreUint32(&o.CS4.Reg, volatile.LoadUint32(&o.CS4.Reg)&^(0x100000)|value<<20)
}
func (o *CAN0_Type) GetCS4_RTR() uint32 {
	return (volatile.LoadUint32(&o.CS4.Reg) & 0x100000) >> 20
}
func (o *CAN0_Type) SetCS4_IDE(value uint32) {
	volatile.StoreUint32(&o.CS4.Reg, volatile.LoadUint32(&o.CS4.Reg)&^(0x200000)|value<<21)
}
func (o *CAN0_Type) GetCS4_IDE() uint32 {
	return (volatile.LoadUint32(&o.CS4.Reg) & 0x200000) >> 21
}
func (o *CAN0_Type) SetCS4_SRR(value uint32) {
	volatile.StoreUint32(&o.CS4.Reg, volatile.LoadUint32(&o.CS4.Reg)&^(0x400000)|value<<22)
}
func (o *CAN0_Type) GetCS4_SRR() uint32 {
	return (volatile.LoadUint32(&o.CS4.Reg) & 0x400000) >> 22
}
func (o *CAN0_Type) SetCS4_CODE(value uint32) {
	volatile.StoreUint32(&o.CS4.Reg, volatile.LoadUint32(&o.CS4.Reg)&^(0xf000000)|value<<24)
}
func (o *CAN0_Type) GetCS4_CODE() uint32 {
	return (volatile.LoadUint32(&o.CS4.Reg) & 0xf000000) >> 24
}

// CAN0.ID4: Message Buffer 4 ID Register
func (o *CAN0_Type) SetID4_EXT(value uint32) {
	volatile.StoreUint32(&o.ID4.Reg, volatile.LoadUint32(&o.ID4.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetID4_EXT() uint32 {
	return volatile.LoadUint32(&o.ID4.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetID4_STD(value uint32) {
	volatile.StoreUint32(&o.ID4.Reg, volatile.LoadUint32(&o.ID4.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetID4_STD() uint32 {
	return (volatile.LoadUint32(&o.ID4.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetID4_PRIO(value uint32) {
	volatile.StoreUint32(&o.ID4.Reg, volatile.LoadUint32(&o.ID4.Reg)&^(0xe0000000)|value<<29)
}
func (o *CAN0_Type) GetID4_PRIO() uint32 {
	return (volatile.LoadUint32(&o.ID4.Reg) & 0xe0000000) >> 29
}

// CAN0.WORD04: Message Buffer 4 WORD0 Register
func (o *CAN0_Type) SetWORD04_DATA_BYTE_3(value uint32) {
	volatile.StoreUint32(&o.WORD04.Reg, volatile.LoadUint32(&o.WORD04.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetWORD04_DATA_BYTE_3() uint32 {
	return volatile.LoadUint32(&o.WORD04.Reg) & 0xff
}
func (o *CAN0_Type) SetWORD04_DATA_BYTE_2(value uint32) {
	volatile.StoreUint32(&o.WORD04.Reg, volatile.LoadUint32(&o.WORD04.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetWORD04_DATA_BYTE_2() uint32 {
	return (volatile.LoadUint32(&o.WORD04.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetWORD04_DATA_BYTE_1(value uint32) {
	volatile.StoreUint32(&o.WORD04.Reg, volatile.LoadUint32(&o.WORD04.Reg)&^(0xff0000)|value<<16)
}
func (o *CAN0_Type) GetWORD04_DATA_BYTE_1() uint32 {
	return (volatile.LoadUint32(&o.WORD04.Reg) & 0xff0000) >> 16
}
func (o *CAN0_Type) SetWORD04_DATA_BYTE_0(value uint32) {
	volatile.StoreUint32(&o.WORD04.Reg, volatile.LoadUint32(&o.WORD04.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN0_Type) GetWORD04_DATA_BYTE_0() uint32 {
	return (volatile.LoadUint32(&o.WORD04.Reg) & 0xff000000) >> 24
}

// CAN0.WORD14: Message Buffer 4 WORD1 Register
func (o *CAN0_Type) SetWORD14_DATA_BYTE_7(value uint32) {
	volatile.StoreUint32(&o.WORD14.Reg, volatile.LoadUint32(&o.WORD14.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetWORD14_DATA_BYTE_7() uint32 {
	return volatile.LoadUint32(&o.WORD14.Reg) & 0xff
}
func (o *CAN0_Type) SetWORD14_DATA_BYTE_6(value uint32) {
	volatile.StoreUint32(&o.WORD14.Reg, volatile.LoadUint32(&o.WORD14.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetWORD14_DATA_BYTE_6() uint32 {
	return (volatile.LoadUint32(&o.WORD14.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetWORD14_DATA_BYTE_5(value uint32) {
	volatile.StoreUint32(&o.WORD14.Reg, volatile.LoadUint32(&o.WORD14.Reg)&^(0xff0000)|value<<16)
}
func (o *CAN0_Type) GetWORD14_DATA_BYTE_5() uint32 {
	return (volatile.LoadUint32(&o.WORD14.Reg) & 0xff0000) >> 16
}
func (o *CAN0_Type) SetWORD14_DATA_BYTE_4(value uint32) {
	volatile.StoreUint32(&o.WORD14.Reg, volatile.LoadUint32(&o.WORD14.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN0_Type) GetWORD14_DATA_BYTE_4() uint32 {
	return (volatile.LoadUint32(&o.WORD14.Reg) & 0xff000000) >> 24
}

// CAN0.CS5: Message Buffer 5 CS Register
func (o *CAN0_Type) SetCS5_TIME_STAMP(value uint32) {
	volatile.StoreUint32(&o.CS5.Reg, volatile.LoadUint32(&o.CS5.Reg)&^(0xffff)|value)
}
func (o *CAN0_Type) GetCS5_TIME_STAMP() uint32 {
	return volatile.LoadUint32(&o.CS5.Reg) & 0xffff
}
func (o *CAN0_Type) SetCS5_DLC(value uint32) {
	volatile.StoreUint32(&o.CS5.Reg, volatile.LoadUint32(&o.CS5.Reg)&^(0xf0000)|value<<16)
}
func (o *CAN0_Type) GetCS5_DLC() uint32 {
	return (volatile.LoadUint32(&o.CS5.Reg) & 0xf0000) >> 16
}
func (o *CAN0_Type) SetCS5_RTR(value uint32) {
	volatile.StoreUint32(&o.CS5.Reg, volatile.LoadUint32(&o.CS5.Reg)&^(0x100000)|value<<20)
}
func (o *CAN0_Type) GetCS5_RTR() uint32 {
	return (volatile.LoadUint32(&o.CS5.Reg) & 0x100000) >> 20
}
func (o *CAN0_Type) SetCS5_IDE(value uint32) {
	volatile.StoreUint32(&o.CS5.Reg, volatile.LoadUint32(&o.CS5.Reg)&^(0x200000)|value<<21)
}
func (o *CAN0_Type) GetCS5_IDE() uint32 {
	return (volatile.LoadUint32(&o.CS5.Reg) & 0x200000) >> 21
}
func (o *CAN0_Type) SetCS5_SRR(value uint32) {
	volatile.StoreUint32(&o.CS5.Reg, volatile.LoadUint32(&o.CS5.Reg)&^(0x400000)|value<<22)
}
func (o *CAN0_Type) GetCS5_SRR() uint32 {
	return (volatile.LoadUint32(&o.CS5.Reg) & 0x400000) >> 22
}
func (o *CAN0_Type) SetCS5_CODE(value uint32) {
	volatile.StoreUint32(&o.CS5.Reg, volatile.LoadUint32(&o.CS5.Reg)&^(0xf000000)|value<<24)
}
func (o *CAN0_Type) GetCS5_CODE() uint32 {
	return (volatile.LoadUint32(&o.CS5.Reg) & 0xf000000) >> 24
}

// CAN0.ID5: Message Buffer 5 ID Register
func (o *CAN0_Type) SetID5_EXT(value uint32) {
	volatile.StoreUint32(&o.ID5.Reg, volatile.LoadUint32(&o.ID5.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetID5_EXT() uint32 {
	return volatile.LoadUint32(&o.ID5.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetID5_STD(value uint32) {
	volatile.StoreUint32(&o.ID5.Reg, volatile.LoadUint32(&o.ID5.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetID5_STD() uint32 {
	return (volatile.LoadUint32(&o.ID5.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetID5_PRIO(value uint32) {
	volatile.StoreUint32(&o.ID5.Reg, volatile.LoadUint32(&o.ID5.Reg)&^(0xe0000000)|value<<29)
}
func (o *CAN0_Type) GetID5_PRIO() uint32 {
	return (volatile.LoadUint32(&o.ID5.Reg) & 0xe0000000) >> 29
}

// CAN0.WORD05: Message Buffer 5 WORD0 Register
func (o *CAN0_Type) SetWORD05_DATA_BYTE_3(value uint32) {
	volatile.StoreUint32(&o.WORD05.Reg, volatile.LoadUint32(&o.WORD05.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetWORD05_DATA_BYTE_3() uint32 {
	return volatile.LoadUint32(&o.WORD05.Reg) & 0xff
}
func (o *CAN0_Type) SetWORD05_DATA_BYTE_2(value uint32) {
	volatile.StoreUint32(&o.WORD05.Reg, volatile.LoadUint32(&o.WORD05.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetWORD05_DATA_BYTE_2() uint32 {
	return (volatile.LoadUint32(&o.WORD05.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetWORD05_DATA_BYTE_1(value uint32) {
	volatile.StoreUint32(&o.WORD05.Reg, volatile.LoadUint32(&o.WORD05.Reg)&^(0xff0000)|value<<16)
}
func (o *CAN0_Type) GetWORD05_DATA_BYTE_1() uint32 {
	return (volatile.LoadUint32(&o.WORD05.Reg) & 0xff0000) >> 16
}
func (o *CAN0_Type) SetWORD05_DATA_BYTE_0(value uint32) {
	volatile.StoreUint32(&o.WORD05.Reg, volatile.LoadUint32(&o.WORD05.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN0_Type) GetWORD05_DATA_BYTE_0() uint32 {
	return (volatile.LoadUint32(&o.WORD05.Reg) & 0xff000000) >> 24
}

// CAN0.WORD15: Message Buffer 5 WORD1 Register
func (o *CAN0_Type) SetWORD15_DATA_BYTE_7(value uint32) {
	volatile.StoreUint32(&o.WORD15.Reg, volatile.LoadUint32(&o.WORD15.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetWORD15_DATA_BYTE_7() uint32 {
	return volatile.LoadUint32(&o.WORD15.Reg) & 0xff
}
func (o *CAN0_Type) SetWORD15_DATA_BYTE_6(value uint32) {
	volatile.StoreUint32(&o.WORD15.Reg, volatile.LoadUint32(&o.WORD15.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetWORD15_DATA_BYTE_6() uint32 {
	return (volatile.LoadUint32(&o.WORD15.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetWORD15_DATA_BYTE_5(value uint32) {
	volatile.StoreUint32(&o.WORD15.Reg, volatile.LoadUint32(&o.WORD15.Reg)&^(0xff0000)|value<<16)
}
func (o *CAN0_Type) GetWORD15_DATA_BYTE_5() uint32 {
	return (volatile.LoadUint32(&o.WORD15.Reg) & 0xff0000) >> 16
}
func (o *CAN0_Type) SetWORD15_DATA_BYTE_4(value uint32) {
	volatile.StoreUint32(&o.WORD15.Reg, volatile.LoadUint32(&o.WORD15.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN0_Type) GetWORD15_DATA_BYTE_4() uint32 {
	return (volatile.LoadUint32(&o.WORD15.Reg) & 0xff000000) >> 24
}

// CAN0.CS6: Message Buffer 6 CS Register
func (o *CAN0_Type) SetCS6_TIME_STAMP(value uint32) {
	volatile.StoreUint32(&o.CS6.Reg, volatile.LoadUint32(&o.CS6.Reg)&^(0xffff)|value)
}
func (o *CAN0_Type) GetCS6_TIME_STAMP() uint32 {
	return volatile.LoadUint32(&o.CS6.Reg) & 0xffff
}
func (o *CAN0_Type) SetCS6_DLC(value uint32) {
	volatile.StoreUint32(&o.CS6.Reg, volatile.LoadUint32(&o.CS6.Reg)&^(0xf0000)|value<<16)
}
func (o *CAN0_Type) GetCS6_DLC() uint32 {
	return (volatile.LoadUint32(&o.CS6.Reg) & 0xf0000) >> 16
}
func (o *CAN0_Type) SetCS6_RTR(value uint32) {
	volatile.StoreUint32(&o.CS6.Reg, volatile.LoadUint32(&o.CS6.Reg)&^(0x100000)|value<<20)
}
func (o *CAN0_Type) GetCS6_RTR() uint32 {
	return (volatile.LoadUint32(&o.CS6.Reg) & 0x100000) >> 20
}
func (o *CAN0_Type) SetCS6_IDE(value uint32) {
	volatile.StoreUint32(&o.CS6.Reg, volatile.LoadUint32(&o.CS6.Reg)&^(0x200000)|value<<21)
}
func (o *CAN0_Type) GetCS6_IDE() uint32 {
	return (volatile.LoadUint32(&o.CS6.Reg) & 0x200000) >> 21
}
func (o *CAN0_Type) SetCS6_SRR(value uint32) {
	volatile.StoreUint32(&o.CS6.Reg, volatile.LoadUint32(&o.CS6.Reg)&^(0x400000)|value<<22)
}
func (o *CAN0_Type) GetCS6_SRR() uint32 {
	return (volatile.LoadUint32(&o.CS6.Reg) & 0x400000) >> 22
}
func (o *CAN0_Type) SetCS6_CODE(value uint32) {
	volatile.StoreUint32(&o.CS6.Reg, volatile.LoadUint32(&o.CS6.Reg)&^(0xf000000)|value<<24)
}
func (o *CAN0_Type) GetCS6_CODE() uint32 {
	return (volatile.LoadUint32(&o.CS6.Reg) & 0xf000000) >> 24
}

// CAN0.ID6: Message Buffer 6 ID Register
func (o *CAN0_Type) SetID6_EXT(value uint32) {
	volatile.StoreUint32(&o.ID6.Reg, volatile.LoadUint32(&o.ID6.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetID6_EXT() uint32 {
	return volatile.LoadUint32(&o.ID6.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetID6_STD(value uint32) {
	volatile.StoreUint32(&o.ID6.Reg, volatile.LoadUint32(&o.ID6.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetID6_STD() uint32 {
	return (volatile.LoadUint32(&o.ID6.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetID6_PRIO(value uint32) {
	volatile.StoreUint32(&o.ID6.Reg, volatile.LoadUint32(&o.ID6.Reg)&^(0xe0000000)|value<<29)
}
func (o *CAN0_Type) GetID6_PRIO() uint32 {
	return (volatile.LoadUint32(&o.ID6.Reg) & 0xe0000000) >> 29
}

// CAN0.WORD06: Message Buffer 6 WORD0 Register
func (o *CAN0_Type) SetWORD06_DATA_BYTE_3(value uint32) {
	volatile.StoreUint32(&o.WORD06.Reg, volatile.LoadUint32(&o.WORD06.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetWORD06_DATA_BYTE_3() uint32 {
	return volatile.LoadUint32(&o.WORD06.Reg) & 0xff
}
func (o *CAN0_Type) SetWORD06_DATA_BYTE_2(value uint32) {
	volatile.StoreUint32(&o.WORD06.Reg, volatile.LoadUint32(&o.WORD06.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetWORD06_DATA_BYTE_2() uint32 {
	return (volatile.LoadUint32(&o.WORD06.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetWORD06_DATA_BYTE_1(value uint32) {
	volatile.StoreUint32(&o.WORD06.Reg, volatile.LoadUint32(&o.WORD06.Reg)&^(0xff0000)|value<<16)
}
func (o *CAN0_Type) GetWORD06_DATA_BYTE_1() uint32 {
	return (volatile.LoadUint32(&o.WORD06.Reg) & 0xff0000) >> 16
}
func (o *CAN0_Type) SetWORD06_DATA_BYTE_0(value uint32) {
	volatile.StoreUint32(&o.WORD06.Reg, volatile.LoadUint32(&o.WORD06.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN0_Type) GetWORD06_DATA_BYTE_0() uint32 {
	return (volatile.LoadUint32(&o.WORD06.Reg) & 0xff000000) >> 24
}

// CAN0.WORD16: Message Buffer 6 WORD1 Register
func (o *CAN0_Type) SetWORD16_DATA_BYTE_7(value uint32) {
	volatile.StoreUint32(&o.WORD16.Reg, volatile.LoadUint32(&o.WORD16.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetWORD16_DATA_BYTE_7() uint32 {
	return volatile.LoadUint32(&o.WORD16.Reg) & 0xff
}
func (o *CAN0_Type) SetWORD16_DATA_BYTE_6(value uint32) {
	volatile.StoreUint32(&o.WORD16.Reg, volatile.LoadUint32(&o.WORD16.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetWORD16_DATA_BYTE_6() uint32 {
	return (volatile.LoadUint32(&o.WORD16.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetWORD16_DATA_BYTE_5(value uint32) {
	volatile.StoreUint32(&o.WORD16.Reg, volatile.LoadUint32(&o.WORD16.Reg)&^(0xff0000)|value<<16)
}
func (o *CAN0_Type) GetWORD16_DATA_BYTE_5() uint32 {
	return (volatile.LoadUint32(&o.WORD16.Reg) & 0xff0000) >> 16
}
func (o *CAN0_Type) SetWORD16_DATA_BYTE_4(value uint32) {
	volatile.StoreUint32(&o.WORD16.Reg, volatile.LoadUint32(&o.WORD16.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN0_Type) GetWORD16_DATA_BYTE_4() uint32 {
	return (volatile.LoadUint32(&o.WORD16.Reg) & 0xff000000) >> 24
}

// CAN0.CS7: Message Buffer 7 CS Register
func (o *CAN0_Type) SetCS7_TIME_STAMP(value uint32) {
	volatile.StoreUint32(&o.CS7.Reg, volatile.LoadUint32(&o.CS7.Reg)&^(0xffff)|value)
}
func (o *CAN0_Type) GetCS7_TIME_STAMP() uint32 {
	return volatile.LoadUint32(&o.CS7.Reg) & 0xffff
}
func (o *CAN0_Type) SetCS7_DLC(value uint32) {
	volatile.StoreUint32(&o.CS7.Reg, volatile.LoadUint32(&o.CS7.Reg)&^(0xf0000)|value<<16)
}
func (o *CAN0_Type) GetCS7_DLC() uint32 {
	return (volatile.LoadUint32(&o.CS7.Reg) & 0xf0000) >> 16
}
func (o *CAN0_Type) SetCS7_RTR(value uint32) {
	volatile.StoreUint32(&o.CS7.Reg, volatile.LoadUint32(&o.CS7.Reg)&^(0x100000)|value<<20)
}
func (o *CAN0_Type) GetCS7_RTR() uint32 {
	return (volatile.LoadUint32(&o.CS7.Reg) & 0x100000) >> 20
}
func (o *CAN0_Type) SetCS7_IDE(value uint32) {
	volatile.StoreUint32(&o.CS7.Reg, volatile.LoadUint32(&o.CS7.Reg)&^(0x200000)|value<<21)
}
func (o *CAN0_Type) GetCS7_IDE() uint32 {
	return (volatile.LoadUint32(&o.CS7.Reg) & 0x200000) >> 21
}
func (o *CAN0_Type) SetCS7_SRR(value uint32) {
	volatile.StoreUint32(&o.CS7.Reg, volatile.LoadUint32(&o.CS7.Reg)&^(0x400000)|value<<22)
}
func (o *CAN0_Type) GetCS7_SRR() uint32 {
	return (volatile.LoadUint32(&o.CS7.Reg) & 0x400000) >> 22
}
func (o *CAN0_Type) SetCS7_CODE(value uint32) {
	volatile.StoreUint32(&o.CS7.Reg, volatile.LoadUint32(&o.CS7.Reg)&^(0xf000000)|value<<24)
}
func (o *CAN0_Type) GetCS7_CODE() uint32 {
	return (volatile.LoadUint32(&o.CS7.Reg) & 0xf000000) >> 24
}

// CAN0.ID7: Message Buffer 7 ID Register
func (o *CAN0_Type) SetID7_EXT(value uint32) {
	volatile.StoreUint32(&o.ID7.Reg, volatile.LoadUint32(&o.ID7.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetID7_EXT() uint32 {
	return volatile.LoadUint32(&o.ID7.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetID7_STD(value uint32) {
	volatile.StoreUint32(&o.ID7.Reg, volatile.LoadUint32(&o.ID7.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetID7_STD() uint32 {
	return (volatile.LoadUint32(&o.ID7.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetID7_PRIO(value uint32) {
	volatile.StoreUint32(&o.ID7.Reg, volatile.LoadUint32(&o.ID7.Reg)&^(0xe0000000)|value<<29)
}
func (o *CAN0_Type) GetID7_PRIO() uint32 {
	return (volatile.LoadUint32(&o.ID7.Reg) & 0xe0000000) >> 29
}

// CAN0.WORD07: Message Buffer 7 WORD0 Register
func (o *CAN0_Type) SetWORD07_DATA_BYTE_3(value uint32) {
	volatile.StoreUint32(&o.WORD07.Reg, volatile.LoadUint32(&o.WORD07.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetWORD07_DATA_BYTE_3() uint32 {
	return volatile.LoadUint32(&o.WORD07.Reg) & 0xff
}
func (o *CAN0_Type) SetWORD07_DATA_BYTE_2(value uint32) {
	volatile.StoreUint32(&o.WORD07.Reg, volatile.LoadUint32(&o.WORD07.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetWORD07_DATA_BYTE_2() uint32 {
	return (volatile.LoadUint32(&o.WORD07.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetWORD07_DATA_BYTE_1(value uint32) {
	volatile.StoreUint32(&o.WORD07.Reg, volatile.LoadUint32(&o.WORD07.Reg)&^(0xff0000)|value<<16)
}
func (o *CAN0_Type) GetWORD07_DATA_BYTE_1() uint32 {
	return (volatile.LoadUint32(&o.WORD07.Reg) & 0xff0000) >> 16
}
func (o *CAN0_Type) SetWORD07_DATA_BYTE_0(value uint32) {
	volatile.StoreUint32(&o.WORD07.Reg, volatile.LoadUint32(&o.WORD07.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN0_Type) GetWORD07_DATA_BYTE_0() uint32 {
	return (volatile.LoadUint32(&o.WORD07.Reg) & 0xff000000) >> 24
}

// CAN0.WORD17: Message Buffer 7 WORD1 Register
func (o *CAN0_Type) SetWORD17_DATA_BYTE_7(value uint32) {
	volatile.StoreUint32(&o.WORD17.Reg, volatile.LoadUint32(&o.WORD17.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetWORD17_DATA_BYTE_7() uint32 {
	return volatile.LoadUint32(&o.WORD17.Reg) & 0xff
}
func (o *CAN0_Type) SetWORD17_DATA_BYTE_6(value uint32) {
	volatile.StoreUint32(&o.WORD17.Reg, volatile.LoadUint32(&o.WORD17.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetWORD17_DATA_BYTE_6() uint32 {
	return (volatile.LoadUint32(&o.WORD17.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetWORD17_DATA_BYTE_5(value uint32) {
	volatile.StoreUint32(&o.WORD17.Reg, volatile.LoadUint32(&o.WORD17.Reg)&^(0xff0000)|value<<16)
}
func (o *CAN0_Type) GetWORD17_DATA_BYTE_5() uint32 {
	return (volatile.LoadUint32(&o.WORD17.Reg) & 0xff0000) >> 16
}
func (o *CAN0_Type) SetWORD17_DATA_BYTE_4(value uint32) {
	volatile.StoreUint32(&o.WORD17.Reg, volatile.LoadUint32(&o.WORD17.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN0_Type) GetWORD17_DATA_BYTE_4() uint32 {
	return (volatile.LoadUint32(&o.WORD17.Reg) & 0xff000000) >> 24
}

// CAN0.CS8: Message Buffer 8 CS Register
func (o *CAN0_Type) SetCS8_TIME_STAMP(value uint32) {
	volatile.StoreUint32(&o.CS8.Reg, volatile.LoadUint32(&o.CS8.Reg)&^(0xffff)|value)
}
func (o *CAN0_Type) GetCS8_TIME_STAMP() uint32 {
	return volatile.LoadUint32(&o.CS8.Reg) & 0xffff
}
func (o *CAN0_Type) SetCS8_DLC(value uint32) {
	volatile.StoreUint32(&o.CS8.Reg, volatile.LoadUint32(&o.CS8.Reg)&^(0xf0000)|value<<16)
}
func (o *CAN0_Type) GetCS8_DLC() uint32 {
	return (volatile.LoadUint32(&o.CS8.Reg) & 0xf0000) >> 16
}
func (o *CAN0_Type) SetCS8_RTR(value uint32) {
	volatile.StoreUint32(&o.CS8.Reg, volatile.LoadUint32(&o.CS8.Reg)&^(0x100000)|value<<20)
}
func (o *CAN0_Type) GetCS8_RTR() uint32 {
	return (volatile.LoadUint32(&o.CS8.Reg) & 0x100000) >> 20
}
func (o *CAN0_Type) SetCS8_IDE(value uint32) {
	volatile.StoreUint32(&o.CS8.Reg, volatile.LoadUint32(&o.CS8.Reg)&^(0x200000)|value<<21)
}
func (o *CAN0_Type) GetCS8_IDE() uint32 {
	return (volatile.LoadUint32(&o.CS8.Reg) & 0x200000) >> 21
}
func (o *CAN0_Type) SetCS8_SRR(value uint32) {
	volatile.StoreUint32(&o.CS8.Reg, volatile.LoadUint32(&o.CS8.Reg)&^(0x400000)|value<<22)
}
func (o *CAN0_Type) GetCS8_SRR() uint32 {
	return (volatile.LoadUint32(&o.CS8.Reg) & 0x400000) >> 22
}
func (o *CAN0_Type) SetCS8_CODE(value uint32) {
	volatile.StoreUint32(&o.CS8.Reg, volatile.LoadUint32(&o.CS8.Reg)&^(0xf000000)|value<<24)
}
func (o *CAN0_Type) GetCS8_CODE() uint32 {
	return (volatile.LoadUint32(&o.CS8.Reg) & 0xf000000) >> 24
}

// CAN0.ID8: Message Buffer 8 ID Register
func (o *CAN0_Type) SetID8_EXT(value uint32) {
	volatile.StoreUint32(&o.ID8.Reg, volatile.LoadUint32(&o.ID8.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetID8_EXT() uint32 {
	return volatile.LoadUint32(&o.ID8.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetID8_STD(value uint32) {
	volatile.StoreUint32(&o.ID8.Reg, volatile.LoadUint32(&o.ID8.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetID8_STD() uint32 {
	return (volatile.LoadUint32(&o.ID8.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetID8_PRIO(value uint32) {
	volatile.StoreUint32(&o.ID8.Reg, volatile.LoadUint32(&o.ID8.Reg)&^(0xe0000000)|value<<29)
}
func (o *CAN0_Type) GetID8_PRIO() uint32 {
	return (volatile.LoadUint32(&o.ID8.Reg) & 0xe0000000) >> 29
}

// CAN0.WORD08: Message Buffer 8 WORD0 Register
func (o *CAN0_Type) SetWORD08_DATA_BYTE_3(value uint32) {
	volatile.StoreUint32(&o.WORD08.Reg, volatile.LoadUint32(&o.WORD08.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetWORD08_DATA_BYTE_3() uint32 {
	return volatile.LoadUint32(&o.WORD08.Reg) & 0xff
}
func (o *CAN0_Type) SetWORD08_DATA_BYTE_2(value uint32) {
	volatile.StoreUint32(&o.WORD08.Reg, volatile.LoadUint32(&o.WORD08.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetWORD08_DATA_BYTE_2() uint32 {
	return (volatile.LoadUint32(&o.WORD08.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetWORD08_DATA_BYTE_1(value uint32) {
	volatile.StoreUint32(&o.WORD08.Reg, volatile.LoadUint32(&o.WORD08.Reg)&^(0xff0000)|value<<16)
}
func (o *CAN0_Type) GetWORD08_DATA_BYTE_1() uint32 {
	return (volatile.LoadUint32(&o.WORD08.Reg) & 0xff0000) >> 16
}
func (o *CAN0_Type) SetWORD08_DATA_BYTE_0(value uint32) {
	volatile.StoreUint32(&o.WORD08.Reg, volatile.LoadUint32(&o.WORD08.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN0_Type) GetWORD08_DATA_BYTE_0() uint32 {
	return (volatile.LoadUint32(&o.WORD08.Reg) & 0xff000000) >> 24
}

// CAN0.WORD18: Message Buffer 8 WORD1 Register
func (o *CAN0_Type) SetWORD18_DATA_BYTE_7(value uint32) {
	volatile.StoreUint32(&o.WORD18.Reg, volatile.LoadUint32(&o.WORD18.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetWORD18_DATA_BYTE_7() uint32 {
	return volatile.LoadUint32(&o.WORD18.Reg) & 0xff
}
func (o *CAN0_Type) SetWORD18_DATA_BYTE_6(value uint32) {
	volatile.StoreUint32(&o.WORD18.Reg, volatile.LoadUint32(&o.WORD18.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetWORD18_DATA_BYTE_6() uint32 {
	return (volatile.LoadUint32(&o.WORD18.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetWORD18_DATA_BYTE_5(value uint32) {
	volatile.StoreUint32(&o.WORD18.Reg, volatile.LoadUint32(&o.WORD18.Reg)&^(0xff0000)|value<<16)
}
func (o *CAN0_Type) GetWORD18_DATA_BYTE_5() uint32 {
	return (volatile.LoadUint32(&o.WORD18.Reg) & 0xff0000) >> 16
}
func (o *CAN0_Type) SetWORD18_DATA_BYTE_4(value uint32) {
	volatile.StoreUint32(&o.WORD18.Reg, volatile.LoadUint32(&o.WORD18.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN0_Type) GetWORD18_DATA_BYTE_4() uint32 {
	return (volatile.LoadUint32(&o.WORD18.Reg) & 0xff000000) >> 24
}

// CAN0.CS9: Message Buffer 9 CS Register
func (o *CAN0_Type) SetCS9_TIME_STAMP(value uint32) {
	volatile.StoreUint32(&o.CS9.Reg, volatile.LoadUint32(&o.CS9.Reg)&^(0xffff)|value)
}
func (o *CAN0_Type) GetCS9_TIME_STAMP() uint32 {
	return volatile.LoadUint32(&o.CS9.Reg) & 0xffff
}
func (o *CAN0_Type) SetCS9_DLC(value uint32) {
	volatile.StoreUint32(&o.CS9.Reg, volatile.LoadUint32(&o.CS9.Reg)&^(0xf0000)|value<<16)
}
func (o *CAN0_Type) GetCS9_DLC() uint32 {
	return (volatile.LoadUint32(&o.CS9.Reg) & 0xf0000) >> 16
}
func (o *CAN0_Type) SetCS9_RTR(value uint32) {
	volatile.StoreUint32(&o.CS9.Reg, volatile.LoadUint32(&o.CS9.Reg)&^(0x100000)|value<<20)
}
func (o *CAN0_Type) GetCS9_RTR() uint32 {
	return (volatile.LoadUint32(&o.CS9.Reg) & 0x100000) >> 20
}
func (o *CAN0_Type) SetCS9_IDE(value uint32) {
	volatile.StoreUint32(&o.CS9.Reg, volatile.LoadUint32(&o.CS9.Reg)&^(0x200000)|value<<21)
}
func (o *CAN0_Type) GetCS9_IDE() uint32 {
	return (volatile.LoadUint32(&o.CS9.Reg) & 0x200000) >> 21
}
func (o *CAN0_Type) SetCS9_SRR(value uint32) {
	volatile.StoreUint32(&o.CS9.Reg, volatile.LoadUint32(&o.CS9.Reg)&^(0x400000)|value<<22)
}
func (o *CAN0_Type) GetCS9_SRR() uint32 {
	return (volatile.LoadUint32(&o.CS9.Reg) & 0x400000) >> 22
}
func (o *CAN0_Type) SetCS9_CODE(value uint32) {
	volatile.StoreUint32(&o.CS9.Reg, volatile.LoadUint32(&o.CS9.Reg)&^(0xf000000)|value<<24)
}
func (o *CAN0_Type) GetCS9_CODE() uint32 {
	return (volatile.LoadUint32(&o.CS9.Reg) & 0xf000000) >> 24
}

// CAN0.ID9: Message Buffer 9 ID Register
func (o *CAN0_Type) SetID9_EXT(value uint32) {
	volatile.StoreUint32(&o.ID9.Reg, volatile.LoadUint32(&o.ID9.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetID9_EXT() uint32 {
	return volatile.LoadUint32(&o.ID9.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetID9_STD(value uint32) {
	volatile.StoreUint32(&o.ID9.Reg, volatile.LoadUint32(&o.ID9.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetID9_STD() uint32 {
	return (volatile.LoadUint32(&o.ID9.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetID9_PRIO(value uint32) {
	volatile.StoreUint32(&o.ID9.Reg, volatile.LoadUint32(&o.ID9.Reg)&^(0xe0000000)|value<<29)
}
func (o *CAN0_Type) GetID9_PRIO() uint32 {
	return (volatile.LoadUint32(&o.ID9.Reg) & 0xe0000000) >> 29
}

// CAN0.WORD09: Message Buffer 9 WORD0 Register
func (o *CAN0_Type) SetWORD09_DATA_BYTE_3(value uint32) {
	volatile.StoreUint32(&o.WORD09.Reg, volatile.LoadUint32(&o.WORD09.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetWORD09_DATA_BYTE_3() uint32 {
	return volatile.LoadUint32(&o.WORD09.Reg) & 0xff
}
func (o *CAN0_Type) SetWORD09_DATA_BYTE_2(value uint32) {
	volatile.StoreUint32(&o.WORD09.Reg, volatile.LoadUint32(&o.WORD09.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetWORD09_DATA_BYTE_2() uint32 {
	return (volatile.LoadUint32(&o.WORD09.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetWORD09_DATA_BYTE_1(value uint32) {
	volatile.StoreUint32(&o.WORD09.Reg, volatile.LoadUint32(&o.WORD09.Reg)&^(0xff0000)|value<<16)
}
func (o *CAN0_Type) GetWORD09_DATA_BYTE_1() uint32 {
	return (volatile.LoadUint32(&o.WORD09.Reg) & 0xff0000) >> 16
}
func (o *CAN0_Type) SetWORD09_DATA_BYTE_0(value uint32) {
	volatile.StoreUint32(&o.WORD09.Reg, volatile.LoadUint32(&o.WORD09.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN0_Type) GetWORD09_DATA_BYTE_0() uint32 {
	return (volatile.LoadUint32(&o.WORD09.Reg) & 0xff000000) >> 24
}

// CAN0.WORD19: Message Buffer 9 WORD1 Register
func (o *CAN0_Type) SetWORD19_DATA_BYTE_7(value uint32) {
	volatile.StoreUint32(&o.WORD19.Reg, volatile.LoadUint32(&o.WORD19.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetWORD19_DATA_BYTE_7() uint32 {
	return volatile.LoadUint32(&o.WORD19.Reg) & 0xff
}
func (o *CAN0_Type) SetWORD19_DATA_BYTE_6(value uint32) {
	volatile.StoreUint32(&o.WORD19.Reg, volatile.LoadUint32(&o.WORD19.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetWORD19_DATA_BYTE_6() uint32 {
	return (volatile.LoadUint32(&o.WORD19.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetWORD19_DATA_BYTE_5(value uint32) {
	volatile.StoreUint32(&o.WORD19.Reg, volatile.LoadUint32(&o.WORD19.Reg)&^(0xff0000)|value<<16)
}
func (o *CAN0_Type) GetWORD19_DATA_BYTE_5() uint32 {
	return (volatile.LoadUint32(&o.WORD19.Reg) & 0xff0000) >> 16
}
func (o *CAN0_Type) SetWORD19_DATA_BYTE_4(value uint32) {
	volatile.StoreUint32(&o.WORD19.Reg, volatile.LoadUint32(&o.WORD19.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN0_Type) GetWORD19_DATA_BYTE_4() uint32 {
	return (volatile.LoadUint32(&o.WORD19.Reg) & 0xff000000) >> 24
}

// CAN0.CS10: Message Buffer 10 CS Register
func (o *CAN0_Type) SetCS10_TIME_STAMP(value uint32) {
	volatile.StoreUint32(&o.CS10.Reg, volatile.LoadUint32(&o.CS10.Reg)&^(0xffff)|value)
}
func (o *CAN0_Type) GetCS10_TIME_STAMP() uint32 {
	return volatile.LoadUint32(&o.CS10.Reg) & 0xffff
}
func (o *CAN0_Type) SetCS10_DLC(value uint32) {
	volatile.StoreUint32(&o.CS10.Reg, volatile.LoadUint32(&o.CS10.Reg)&^(0xf0000)|value<<16)
}
func (o *CAN0_Type) GetCS10_DLC() uint32 {
	return (volatile.LoadUint32(&o.CS10.Reg) & 0xf0000) >> 16
}
func (o *CAN0_Type) SetCS10_RTR(value uint32) {
	volatile.StoreUint32(&o.CS10.Reg, volatile.LoadUint32(&o.CS10.Reg)&^(0x100000)|value<<20)
}
func (o *CAN0_Type) GetCS10_RTR() uint32 {
	return (volatile.LoadUint32(&o.CS10.Reg) & 0x100000) >> 20
}
func (o *CAN0_Type) SetCS10_IDE(value uint32) {
	volatile.StoreUint32(&o.CS10.Reg, volatile.LoadUint32(&o.CS10.Reg)&^(0x200000)|value<<21)
}
func (o *CAN0_Type) GetCS10_IDE() uint32 {
	return (volatile.LoadUint32(&o.CS10.Reg) & 0x200000) >> 21
}
func (o *CAN0_Type) SetCS10_SRR(value uint32) {
	volatile.StoreUint32(&o.CS10.Reg, volatile.LoadUint32(&o.CS10.Reg)&^(0x400000)|value<<22)
}
func (o *CAN0_Type) GetCS10_SRR() uint32 {
	return (volatile.LoadUint32(&o.CS10.Reg) & 0x400000) >> 22
}
func (o *CAN0_Type) SetCS10_CODE(value uint32) {
	volatile.StoreUint32(&o.CS10.Reg, volatile.LoadUint32(&o.CS10.Reg)&^(0xf000000)|value<<24)
}
func (o *CAN0_Type) GetCS10_CODE() uint32 {
	return (volatile.LoadUint32(&o.CS10.Reg) & 0xf000000) >> 24
}

// CAN0.ID10: Message Buffer 10 ID Register
func (o *CAN0_Type) SetID10_EXT(value uint32) {
	volatile.StoreUint32(&o.ID10.Reg, volatile.LoadUint32(&o.ID10.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetID10_EXT() uint32 {
	return volatile.LoadUint32(&o.ID10.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetID10_STD(value uint32) {
	volatile.StoreUint32(&o.ID10.Reg, volatile.LoadUint32(&o.ID10.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetID10_STD() uint32 {
	return (volatile.LoadUint32(&o.ID10.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetID10_PRIO(value uint32) {
	volatile.StoreUint32(&o.ID10.Reg, volatile.LoadUint32(&o.ID10.Reg)&^(0xe0000000)|value<<29)
}
func (o *CAN0_Type) GetID10_PRIO() uint32 {
	return (volatile.LoadUint32(&o.ID10.Reg) & 0xe0000000) >> 29
}

// CAN0.WORD010: Message Buffer 10 WORD0 Register
func (o *CAN0_Type) SetWORD010_DATA_BYTE_3(value uint32) {
	volatile.StoreUint32(&o.WORD010.Reg, volatile.LoadUint32(&o.WORD010.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetWORD010_DATA_BYTE_3() uint32 {
	return volatile.LoadUint32(&o.WORD010.Reg) & 0xff
}
func (o *CAN0_Type) SetWORD010_DATA_BYTE_2(value uint32) {
	volatile.StoreUint32(&o.WORD010.Reg, volatile.LoadUint32(&o.WORD010.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetWORD010_DATA_BYTE_2() uint32 {
	return (volatile.LoadUint32(&o.WORD010.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetWORD010_DATA_BYTE_1(value uint32) {
	volatile.StoreUint32(&o.WORD010.Reg, volatile.LoadUint32(&o.WORD010.Reg)&^(0xff0000)|value<<16)
}
func (o *CAN0_Type) GetWORD010_DATA_BYTE_1() uint32 {
	return (volatile.LoadUint32(&o.WORD010.Reg) & 0xff0000) >> 16
}
func (o *CAN0_Type) SetWORD010_DATA_BYTE_0(value uint32) {
	volatile.StoreUint32(&o.WORD010.Reg, volatile.LoadUint32(&o.WORD010.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN0_Type) GetWORD010_DATA_BYTE_0() uint32 {
	return (volatile.LoadUint32(&o.WORD010.Reg) & 0xff000000) >> 24
}

// CAN0.WORD110: Message Buffer 10 WORD1 Register
func (o *CAN0_Type) SetWORD110_DATA_BYTE_7(value uint32) {
	volatile.StoreUint32(&o.WORD110.Reg, volatile.LoadUint32(&o.WORD110.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetWORD110_DATA_BYTE_7() uint32 {
	return volatile.LoadUint32(&o.WORD110.Reg) & 0xff
}
func (o *CAN0_Type) SetWORD110_DATA_BYTE_6(value uint32) {
	volatile.StoreUint32(&o.WORD110.Reg, volatile.LoadUint32(&o.WORD110.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetWORD110_DATA_BYTE_6() uint32 {
	return (volatile.LoadUint32(&o.WORD110.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetWORD110_DATA_BYTE_5(value uint32) {
	volatile.StoreUint32(&o.WORD110.Reg, volatile.LoadUint32(&o.WORD110.Reg)&^(0xff0000)|value<<16)
}
func (o *CAN0_Type) GetWORD110_DATA_BYTE_5() uint32 {
	return (volatile.LoadUint32(&o.WORD110.Reg) & 0xff0000) >> 16
}
func (o *CAN0_Type) SetWORD110_DATA_BYTE_4(value uint32) {
	volatile.StoreUint32(&o.WORD110.Reg, volatile.LoadUint32(&o.WORD110.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN0_Type) GetWORD110_DATA_BYTE_4() uint32 {
	return (volatile.LoadUint32(&o.WORD110.Reg) & 0xff000000) >> 24
}

// CAN0.CS11: Message Buffer 11 CS Register
func (o *CAN0_Type) SetCS11_TIME_STAMP(value uint32) {
	volatile.StoreUint32(&o.CS11.Reg, volatile.LoadUint32(&o.CS11.Reg)&^(0xffff)|value)
}
func (o *CAN0_Type) GetCS11_TIME_STAMP() uint32 {
	return volatile.LoadUint32(&o.CS11.Reg) & 0xffff
}
func (o *CAN0_Type) SetCS11_DLC(value uint32) {
	volatile.StoreUint32(&o.CS11.Reg, volatile.LoadUint32(&o.CS11.Reg)&^(0xf0000)|value<<16)
}
func (o *CAN0_Type) GetCS11_DLC() uint32 {
	return (volatile.LoadUint32(&o.CS11.Reg) & 0xf0000) >> 16
}
func (o *CAN0_Type) SetCS11_RTR(value uint32) {
	volatile.StoreUint32(&o.CS11.Reg, volatile.LoadUint32(&o.CS11.Reg)&^(0x100000)|value<<20)
}
func (o *CAN0_Type) GetCS11_RTR() uint32 {
	return (volatile.LoadUint32(&o.CS11.Reg) & 0x100000) >> 20
}
func (o *CAN0_Type) SetCS11_IDE(value uint32) {
	volatile.StoreUint32(&o.CS11.Reg, volatile.LoadUint32(&o.CS11.Reg)&^(0x200000)|value<<21)
}
func (o *CAN0_Type) GetCS11_IDE() uint32 {
	return (volatile.LoadUint32(&o.CS11.Reg) & 0x200000) >> 21
}
func (o *CAN0_Type) SetCS11_SRR(value uint32) {
	volatile.StoreUint32(&o.CS11.Reg, volatile.LoadUint32(&o.CS11.Reg)&^(0x400000)|value<<22)
}
func (o *CAN0_Type) GetCS11_SRR() uint32 {
	return (volatile.LoadUint32(&o.CS11.Reg) & 0x400000) >> 22
}
func (o *CAN0_Type) SetCS11_CODE(value uint32) {
	volatile.StoreUint32(&o.CS11.Reg, volatile.LoadUint32(&o.CS11.Reg)&^(0xf000000)|value<<24)
}
func (o *CAN0_Type) GetCS11_CODE() uint32 {
	return (volatile.LoadUint32(&o.CS11.Reg) & 0xf000000) >> 24
}

// CAN0.ID11: Message Buffer 11 ID Register
func (o *CAN0_Type) SetID11_EXT(value uint32) {
	volatile.StoreUint32(&o.ID11.Reg, volatile.LoadUint32(&o.ID11.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetID11_EXT() uint32 {
	return volatile.LoadUint32(&o.ID11.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetID11_STD(value uint32) {
	volatile.StoreUint32(&o.ID11.Reg, volatile.LoadUint32(&o.ID11.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetID11_STD() uint32 {
	return (volatile.LoadUint32(&o.ID11.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetID11_PRIO(value uint32) {
	volatile.StoreUint32(&o.ID11.Reg, volatile.LoadUint32(&o.ID11.Reg)&^(0xe0000000)|value<<29)
}
func (o *CAN0_Type) GetID11_PRIO() uint32 {
	return (volatile.LoadUint32(&o.ID11.Reg) & 0xe0000000) >> 29
}

// CAN0.WORD011: Message Buffer 11 WORD0 Register
func (o *CAN0_Type) SetWORD011_DATA_BYTE_3(value uint32) {
	volatile.StoreUint32(&o.WORD011.Reg, volatile.LoadUint32(&o.WORD011.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetWORD011_DATA_BYTE_3() uint32 {
	return volatile.LoadUint32(&o.WORD011.Reg) & 0xff
}
func (o *CAN0_Type) SetWORD011_DATA_BYTE_2(value uint32) {
	volatile.StoreUint32(&o.WORD011.Reg, volatile.LoadUint32(&o.WORD011.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetWORD011_DATA_BYTE_2() uint32 {
	return (volatile.LoadUint32(&o.WORD011.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetWORD011_DATA_BYTE_1(value uint32) {
	volatile.StoreUint32(&o.WORD011.Reg, volatile.LoadUint32(&o.WORD011.Reg)&^(0xff0000)|value<<16)
}
func (o *CAN0_Type) GetWORD011_DATA_BYTE_1() uint32 {
	return (volatile.LoadUint32(&o.WORD011.Reg) & 0xff0000) >> 16
}
func (o *CAN0_Type) SetWORD011_DATA_BYTE_0(value uint32) {
	volatile.StoreUint32(&o.WORD011.Reg, volatile.LoadUint32(&o.WORD011.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN0_Type) GetWORD011_DATA_BYTE_0() uint32 {
	return (volatile.LoadUint32(&o.WORD011.Reg) & 0xff000000) >> 24
}

// CAN0.WORD111: Message Buffer 11 WORD1 Register
func (o *CAN0_Type) SetWORD111_DATA_BYTE_7(value uint32) {
	volatile.StoreUint32(&o.WORD111.Reg, volatile.LoadUint32(&o.WORD111.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetWORD111_DATA_BYTE_7() uint32 {
	return volatile.LoadUint32(&o.WORD111.Reg) & 0xff
}
func (o *CAN0_Type) SetWORD111_DATA_BYTE_6(value uint32) {
	volatile.StoreUint32(&o.WORD111.Reg, volatile.LoadUint32(&o.WORD111.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetWORD111_DATA_BYTE_6() uint32 {
	return (volatile.LoadUint32(&o.WORD111.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetWORD111_DATA_BYTE_5(value uint32) {
	volatile.StoreUint32(&o.WORD111.Reg, volatile.LoadUint32(&o.WORD111.Reg)&^(0xff0000)|value<<16)
}
func (o *CAN0_Type) GetWORD111_DATA_BYTE_5() uint32 {
	return (volatile.LoadUint32(&o.WORD111.Reg) & 0xff0000) >> 16
}
func (o *CAN0_Type) SetWORD111_DATA_BYTE_4(value uint32) {
	volatile.StoreUint32(&o.WORD111.Reg, volatile.LoadUint32(&o.WORD111.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN0_Type) GetWORD111_DATA_BYTE_4() uint32 {
	return (volatile.LoadUint32(&o.WORD111.Reg) & 0xff000000) >> 24
}

// CAN0.CS12: Message Buffer 12 CS Register
func (o *CAN0_Type) SetCS12_TIME_STAMP(value uint32) {
	volatile.StoreUint32(&o.CS12.Reg, volatile.LoadUint32(&o.CS12.Reg)&^(0xffff)|value)
}
func (o *CAN0_Type) GetCS12_TIME_STAMP() uint32 {
	return volatile.LoadUint32(&o.CS12.Reg) & 0xffff
}
func (o *CAN0_Type) SetCS12_DLC(value uint32) {
	volatile.StoreUint32(&o.CS12.Reg, volatile.LoadUint32(&o.CS12.Reg)&^(0xf0000)|value<<16)
}
func (o *CAN0_Type) GetCS12_DLC() uint32 {
	return (volatile.LoadUint32(&o.CS12.Reg) & 0xf0000) >> 16
}
func (o *CAN0_Type) SetCS12_RTR(value uint32) {
	volatile.StoreUint32(&o.CS12.Reg, volatile.LoadUint32(&o.CS12.Reg)&^(0x100000)|value<<20)
}
func (o *CAN0_Type) GetCS12_RTR() uint32 {
	return (volatile.LoadUint32(&o.CS12.Reg) & 0x100000) >> 20
}
func (o *CAN0_Type) SetCS12_IDE(value uint32) {
	volatile.StoreUint32(&o.CS12.Reg, volatile.LoadUint32(&o.CS12.Reg)&^(0x200000)|value<<21)
}
func (o *CAN0_Type) GetCS12_IDE() uint32 {
	return (volatile.LoadUint32(&o.CS12.Reg) & 0x200000) >> 21
}
func (o *CAN0_Type) SetCS12_SRR(value uint32) {
	volatile.StoreUint32(&o.CS12.Reg, volatile.LoadUint32(&o.CS12.Reg)&^(0x400000)|value<<22)
}
func (o *CAN0_Type) GetCS12_SRR() uint32 {
	return (volatile.LoadUint32(&o.CS12.Reg) & 0x400000) >> 22
}
func (o *CAN0_Type) SetCS12_CODE(value uint32) {
	volatile.StoreUint32(&o.CS12.Reg, volatile.LoadUint32(&o.CS12.Reg)&^(0xf000000)|value<<24)
}
func (o *CAN0_Type) GetCS12_CODE() uint32 {
	return (volatile.LoadUint32(&o.CS12.Reg) & 0xf000000) >> 24
}

// CAN0.ID12: Message Buffer 12 ID Register
func (o *CAN0_Type) SetID12_EXT(value uint32) {
	volatile.StoreUint32(&o.ID12.Reg, volatile.LoadUint32(&o.ID12.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetID12_EXT() uint32 {
	return volatile.LoadUint32(&o.ID12.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetID12_STD(value uint32) {
	volatile.StoreUint32(&o.ID12.Reg, volatile.LoadUint32(&o.ID12.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetID12_STD() uint32 {
	return (volatile.LoadUint32(&o.ID12.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetID12_PRIO(value uint32) {
	volatile.StoreUint32(&o.ID12.Reg, volatile.LoadUint32(&o.ID12.Reg)&^(0xe0000000)|value<<29)
}
func (o *CAN0_Type) GetID12_PRIO() uint32 {
	return (volatile.LoadUint32(&o.ID12.Reg) & 0xe0000000) >> 29
}

// CAN0.WORD012: Message Buffer 12 WORD0 Register
func (o *CAN0_Type) SetWORD012_DATA_BYTE_3(value uint32) {
	volatile.StoreUint32(&o.WORD012.Reg, volatile.LoadUint32(&o.WORD012.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetWORD012_DATA_BYTE_3() uint32 {
	return volatile.LoadUint32(&o.WORD012.Reg) & 0xff
}
func (o *CAN0_Type) SetWORD012_DATA_BYTE_2(value uint32) {
	volatile.StoreUint32(&o.WORD012.Reg, volatile.LoadUint32(&o.WORD012.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetWORD012_DATA_BYTE_2() uint32 {
	return (volatile.LoadUint32(&o.WORD012.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetWORD012_DATA_BYTE_1(value uint32) {
	volatile.StoreUint32(&o.WORD012.Reg, volatile.LoadUint32(&o.WORD012.Reg)&^(0xff0000)|value<<16)
}
func (o *CAN0_Type) GetWORD012_DATA_BYTE_1() uint32 {
	return (volatile.LoadUint32(&o.WORD012.Reg) & 0xff0000) >> 16
}
func (o *CAN0_Type) SetWORD012_DATA_BYTE_0(value uint32) {
	volatile.StoreUint32(&o.WORD012.Reg, volatile.LoadUint32(&o.WORD012.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN0_Type) GetWORD012_DATA_BYTE_0() uint32 {
	return (volatile.LoadUint32(&o.WORD012.Reg) & 0xff000000) >> 24
}

// CAN0.WORD112: Message Buffer 12 WORD1 Register
func (o *CAN0_Type) SetWORD112_DATA_BYTE_7(value uint32) {
	volatile.StoreUint32(&o.WORD112.Reg, volatile.LoadUint32(&o.WORD112.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetWORD112_DATA_BYTE_7() uint32 {
	return volatile.LoadUint32(&o.WORD112.Reg) & 0xff
}
func (o *CAN0_Type) SetWORD112_DATA_BYTE_6(value uint32) {
	volatile.StoreUint32(&o.WORD112.Reg, volatile.LoadUint32(&o.WORD112.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetWORD112_DATA_BYTE_6() uint32 {
	return (volatile.LoadUint32(&o.WORD112.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetWORD112_DATA_BYTE_5(value uint32) {
	volatile.StoreUint32(&o.WORD112.Reg, volatile.LoadUint32(&o.WORD112.Reg)&^(0xff0000)|value<<16)
}
func (o *CAN0_Type) GetWORD112_DATA_BYTE_5() uint32 {
	return (volatile.LoadUint32(&o.WORD112.Reg) & 0xff0000) >> 16
}
func (o *CAN0_Type) SetWORD112_DATA_BYTE_4(value uint32) {
	volatile.StoreUint32(&o.WORD112.Reg, volatile.LoadUint32(&o.WORD112.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN0_Type) GetWORD112_DATA_BYTE_4() uint32 {
	return (volatile.LoadUint32(&o.WORD112.Reg) & 0xff000000) >> 24
}

// CAN0.CS13: Message Buffer 13 CS Register
func (o *CAN0_Type) SetCS13_TIME_STAMP(value uint32) {
	volatile.StoreUint32(&o.CS13.Reg, volatile.LoadUint32(&o.CS13.Reg)&^(0xffff)|value)
}
func (o *CAN0_Type) GetCS13_TIME_STAMP() uint32 {
	return volatile.LoadUint32(&o.CS13.Reg) & 0xffff
}
func (o *CAN0_Type) SetCS13_DLC(value uint32) {
	volatile.StoreUint32(&o.CS13.Reg, volatile.LoadUint32(&o.CS13.Reg)&^(0xf0000)|value<<16)
}
func (o *CAN0_Type) GetCS13_DLC() uint32 {
	return (volatile.LoadUint32(&o.CS13.Reg) & 0xf0000) >> 16
}
func (o *CAN0_Type) SetCS13_RTR(value uint32) {
	volatile.StoreUint32(&o.CS13.Reg, volatile.LoadUint32(&o.CS13.Reg)&^(0x100000)|value<<20)
}
func (o *CAN0_Type) GetCS13_RTR() uint32 {
	return (volatile.LoadUint32(&o.CS13.Reg) & 0x100000) >> 20
}
func (o *CAN0_Type) SetCS13_IDE(value uint32) {
	volatile.StoreUint32(&o.CS13.Reg, volatile.LoadUint32(&o.CS13.Reg)&^(0x200000)|value<<21)
}
func (o *CAN0_Type) GetCS13_IDE() uint32 {
	return (volatile.LoadUint32(&o.CS13.Reg) & 0x200000) >> 21
}
func (o *CAN0_Type) SetCS13_SRR(value uint32) {
	volatile.StoreUint32(&o.CS13.Reg, volatile.LoadUint32(&o.CS13.Reg)&^(0x400000)|value<<22)
}
func (o *CAN0_Type) GetCS13_SRR() uint32 {
	return (volatile.LoadUint32(&o.CS13.Reg) & 0x400000) >> 22
}
func (o *CAN0_Type) SetCS13_CODE(value uint32) {
	volatile.StoreUint32(&o.CS13.Reg, volatile.LoadUint32(&o.CS13.Reg)&^(0xf000000)|value<<24)
}
func (o *CAN0_Type) GetCS13_CODE() uint32 {
	return (volatile.LoadUint32(&o.CS13.Reg) & 0xf000000) >> 24
}

// CAN0.ID13: Message Buffer 13 ID Register
func (o *CAN0_Type) SetID13_EXT(value uint32) {
	volatile.StoreUint32(&o.ID13.Reg, volatile.LoadUint32(&o.ID13.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetID13_EXT() uint32 {
	return volatile.LoadUint32(&o.ID13.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetID13_STD(value uint32) {
	volatile.StoreUint32(&o.ID13.Reg, volatile.LoadUint32(&o.ID13.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetID13_STD() uint32 {
	return (volatile.LoadUint32(&o.ID13.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetID13_PRIO(value uint32) {
	volatile.StoreUint32(&o.ID13.Reg, volatile.LoadUint32(&o.ID13.Reg)&^(0xe0000000)|value<<29)
}
func (o *CAN0_Type) GetID13_PRIO() uint32 {
	return (volatile.LoadUint32(&o.ID13.Reg) & 0xe0000000) >> 29
}

// CAN0.WORD013: Message Buffer 13 WORD0 Register
func (o *CAN0_Type) SetWORD013_DATA_BYTE_3(value uint32) {
	volatile.StoreUint32(&o.WORD013.Reg, volatile.LoadUint32(&o.WORD013.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetWORD013_DATA_BYTE_3() uint32 {
	return volatile.LoadUint32(&o.WORD013.Reg) & 0xff
}
func (o *CAN0_Type) SetWORD013_DATA_BYTE_2(value uint32) {
	volatile.StoreUint32(&o.WORD013.Reg, volatile.LoadUint32(&o.WORD013.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetWORD013_DATA_BYTE_2() uint32 {
	return (volatile.LoadUint32(&o.WORD013.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetWORD013_DATA_BYTE_1(value uint32) {
	volatile.StoreUint32(&o.WORD013.Reg, volatile.LoadUint32(&o.WORD013.Reg)&^(0xff0000)|value<<16)
}
func (o *CAN0_Type) GetWORD013_DATA_BYTE_1() uint32 {
	return (volatile.LoadUint32(&o.WORD013.Reg) & 0xff0000) >> 16
}
func (o *CAN0_Type) SetWORD013_DATA_BYTE_0(value uint32) {
	volatile.StoreUint32(&o.WORD013.Reg, volatile.LoadUint32(&o.WORD013.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN0_Type) GetWORD013_DATA_BYTE_0() uint32 {
	return (volatile.LoadUint32(&o.WORD013.Reg) & 0xff000000) >> 24
}

// CAN0.WORD113: Message Buffer 13 WORD1 Register
func (o *CAN0_Type) SetWORD113_DATA_BYTE_7(value uint32) {
	volatile.StoreUint32(&o.WORD113.Reg, volatile.LoadUint32(&o.WORD113.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetWORD113_DATA_BYTE_7() uint32 {
	return volatile.LoadUint32(&o.WORD113.Reg) & 0xff
}
func (o *CAN0_Type) SetWORD113_DATA_BYTE_6(value uint32) {
	volatile.StoreUint32(&o.WORD113.Reg, volatile.LoadUint32(&o.WORD113.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetWORD113_DATA_BYTE_6() uint32 {
	return (volatile.LoadUint32(&o.WORD113.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetWORD113_DATA_BYTE_5(value uint32) {
	volatile.StoreUint32(&o.WORD113.Reg, volatile.LoadUint32(&o.WORD113.Reg)&^(0xff0000)|value<<16)
}
func (o *CAN0_Type) GetWORD113_DATA_BYTE_5() uint32 {
	return (volatile.LoadUint32(&o.WORD113.Reg) & 0xff0000) >> 16
}
func (o *CAN0_Type) SetWORD113_DATA_BYTE_4(value uint32) {
	volatile.StoreUint32(&o.WORD113.Reg, volatile.LoadUint32(&o.WORD113.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN0_Type) GetWORD113_DATA_BYTE_4() uint32 {
	return (volatile.LoadUint32(&o.WORD113.Reg) & 0xff000000) >> 24
}

// CAN0.CS14: Message Buffer 14 CS Register
func (o *CAN0_Type) SetCS14_TIME_STAMP(value uint32) {
	volatile.StoreUint32(&o.CS14.Reg, volatile.LoadUint32(&o.CS14.Reg)&^(0xffff)|value)
}
func (o *CAN0_Type) GetCS14_TIME_STAMP() uint32 {
	return volatile.LoadUint32(&o.CS14.Reg) & 0xffff
}
func (o *CAN0_Type) SetCS14_DLC(value uint32) {
	volatile.StoreUint32(&o.CS14.Reg, volatile.LoadUint32(&o.CS14.Reg)&^(0xf0000)|value<<16)
}
func (o *CAN0_Type) GetCS14_DLC() uint32 {
	return (volatile.LoadUint32(&o.CS14.Reg) & 0xf0000) >> 16
}
func (o *CAN0_Type) SetCS14_RTR(value uint32) {
	volatile.StoreUint32(&o.CS14.Reg, volatile.LoadUint32(&o.CS14.Reg)&^(0x100000)|value<<20)
}
func (o *CAN0_Type) GetCS14_RTR() uint32 {
	return (volatile.LoadUint32(&o.CS14.Reg) & 0x100000) >> 20
}
func (o *CAN0_Type) SetCS14_IDE(value uint32) {
	volatile.StoreUint32(&o.CS14.Reg, volatile.LoadUint32(&o.CS14.Reg)&^(0x200000)|value<<21)
}
func (o *CAN0_Type) GetCS14_IDE() uint32 {
	return (volatile.LoadUint32(&o.CS14.Reg) & 0x200000) >> 21
}
func (o *CAN0_Type) SetCS14_SRR(value uint32) {
	volatile.StoreUint32(&o.CS14.Reg, volatile.LoadUint32(&o.CS14.Reg)&^(0x400000)|value<<22)
}
func (o *CAN0_Type) GetCS14_SRR() uint32 {
	return (volatile.LoadUint32(&o.CS14.Reg) & 0x400000) >> 22
}
func (o *CAN0_Type) SetCS14_CODE(value uint32) {
	volatile.StoreUint32(&o.CS14.Reg, volatile.LoadUint32(&o.CS14.Reg)&^(0xf000000)|value<<24)
}
func (o *CAN0_Type) GetCS14_CODE() uint32 {
	return (volatile.LoadUint32(&o.CS14.Reg) & 0xf000000) >> 24
}

// CAN0.ID14: Message Buffer 14 ID Register
func (o *CAN0_Type) SetID14_EXT(value uint32) {
	volatile.StoreUint32(&o.ID14.Reg, volatile.LoadUint32(&o.ID14.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetID14_EXT() uint32 {
	return volatile.LoadUint32(&o.ID14.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetID14_STD(value uint32) {
	volatile.StoreUint32(&o.ID14.Reg, volatile.LoadUint32(&o.ID14.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetID14_STD() uint32 {
	return (volatile.LoadUint32(&o.ID14.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetID14_PRIO(value uint32) {
	volatile.StoreUint32(&o.ID14.Reg, volatile.LoadUint32(&o.ID14.Reg)&^(0xe0000000)|value<<29)
}
func (o *CAN0_Type) GetID14_PRIO() uint32 {
	return (volatile.LoadUint32(&o.ID14.Reg) & 0xe0000000) >> 29
}

// CAN0.WORD014: Message Buffer 14 WORD0 Register
func (o *CAN0_Type) SetWORD014_DATA_BYTE_3(value uint32) {
	volatile.StoreUint32(&o.WORD014.Reg, volatile.LoadUint32(&o.WORD014.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetWORD014_DATA_BYTE_3() uint32 {
	return volatile.LoadUint32(&o.WORD014.Reg) & 0xff
}
func (o *CAN0_Type) SetWORD014_DATA_BYTE_2(value uint32) {
	volatile.StoreUint32(&o.WORD014.Reg, volatile.LoadUint32(&o.WORD014.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetWORD014_DATA_BYTE_2() uint32 {
	return (volatile.LoadUint32(&o.WORD014.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetWORD014_DATA_BYTE_1(value uint32) {
	volatile.StoreUint32(&o.WORD014.Reg, volatile.LoadUint32(&o.WORD014.Reg)&^(0xff0000)|value<<16)
}
func (o *CAN0_Type) GetWORD014_DATA_BYTE_1() uint32 {
	return (volatile.LoadUint32(&o.WORD014.Reg) & 0xff0000) >> 16
}
func (o *CAN0_Type) SetWORD014_DATA_BYTE_0(value uint32) {
	volatile.StoreUint32(&o.WORD014.Reg, volatile.LoadUint32(&o.WORD014.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN0_Type) GetWORD014_DATA_BYTE_0() uint32 {
	return (volatile.LoadUint32(&o.WORD014.Reg) & 0xff000000) >> 24
}

// CAN0.WORD114: Message Buffer 14 WORD1 Register
func (o *CAN0_Type) SetWORD114_DATA_BYTE_7(value uint32) {
	volatile.StoreUint32(&o.WORD114.Reg, volatile.LoadUint32(&o.WORD114.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetWORD114_DATA_BYTE_7() uint32 {
	return volatile.LoadUint32(&o.WORD114.Reg) & 0xff
}
func (o *CAN0_Type) SetWORD114_DATA_BYTE_6(value uint32) {
	volatile.StoreUint32(&o.WORD114.Reg, volatile.LoadUint32(&o.WORD114.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetWORD114_DATA_BYTE_6() uint32 {
	return (volatile.LoadUint32(&o.WORD114.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetWORD114_DATA_BYTE_5(value uint32) {
	volatile.StoreUint32(&o.WORD114.Reg, volatile.LoadUint32(&o.WORD114.Reg)&^(0xff0000)|value<<16)
}
func (o *CAN0_Type) GetWORD114_DATA_BYTE_5() uint32 {
	return (volatile.LoadUint32(&o.WORD114.Reg) & 0xff0000) >> 16
}
func (o *CAN0_Type) SetWORD114_DATA_BYTE_4(value uint32) {
	volatile.StoreUint32(&o.WORD114.Reg, volatile.LoadUint32(&o.WORD114.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN0_Type) GetWORD114_DATA_BYTE_4() uint32 {
	return (volatile.LoadUint32(&o.WORD114.Reg) & 0xff000000) >> 24
}

// CAN0.CS15: Message Buffer 15 CS Register
func (o *CAN0_Type) SetCS15_TIME_STAMP(value uint32) {
	volatile.StoreUint32(&o.CS15.Reg, volatile.LoadUint32(&o.CS15.Reg)&^(0xffff)|value)
}
func (o *CAN0_Type) GetCS15_TIME_STAMP() uint32 {
	return volatile.LoadUint32(&o.CS15.Reg) & 0xffff
}
func (o *CAN0_Type) SetCS15_DLC(value uint32) {
	volatile.StoreUint32(&o.CS15.Reg, volatile.LoadUint32(&o.CS15.Reg)&^(0xf0000)|value<<16)
}
func (o *CAN0_Type) GetCS15_DLC() uint32 {
	return (volatile.LoadUint32(&o.CS15.Reg) & 0xf0000) >> 16
}
func (o *CAN0_Type) SetCS15_RTR(value uint32) {
	volatile.StoreUint32(&o.CS15.Reg, volatile.LoadUint32(&o.CS15.Reg)&^(0x100000)|value<<20)
}
func (o *CAN0_Type) GetCS15_RTR() uint32 {
	return (volatile.LoadUint32(&o.CS15.Reg) & 0x100000) >> 20
}
func (o *CAN0_Type) SetCS15_IDE(value uint32) {
	volatile.StoreUint32(&o.CS15.Reg, volatile.LoadUint32(&o.CS15.Reg)&^(0x200000)|value<<21)
}
func (o *CAN0_Type) GetCS15_IDE() uint32 {
	return (volatile.LoadUint32(&o.CS15.Reg) & 0x200000) >> 21
}
func (o *CAN0_Type) SetCS15_SRR(value uint32) {
	volatile.StoreUint32(&o.CS15.Reg, volatile.LoadUint32(&o.CS15.Reg)&^(0x400000)|value<<22)
}
func (o *CAN0_Type) GetCS15_SRR() uint32 {
	return (volatile.LoadUint32(&o.CS15.Reg) & 0x400000) >> 22
}
func (o *CAN0_Type) SetCS15_CODE(value uint32) {
	volatile.StoreUint32(&o.CS15.Reg, volatile.LoadUint32(&o.CS15.Reg)&^(0xf000000)|value<<24)
}
func (o *CAN0_Type) GetCS15_CODE() uint32 {
	return (volatile.LoadUint32(&o.CS15.Reg) & 0xf000000) >> 24
}

// CAN0.ID15: Message Buffer 15 ID Register
func (o *CAN0_Type) SetID15_EXT(value uint32) {
	volatile.StoreUint32(&o.ID15.Reg, volatile.LoadUint32(&o.ID15.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetID15_EXT() uint32 {
	return volatile.LoadUint32(&o.ID15.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetID15_STD(value uint32) {
	volatile.StoreUint32(&o.ID15.Reg, volatile.LoadUint32(&o.ID15.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetID15_STD() uint32 {
	return (volatile.LoadUint32(&o.ID15.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetID15_PRIO(value uint32) {
	volatile.StoreUint32(&o.ID15.Reg, volatile.LoadUint32(&o.ID15.Reg)&^(0xe0000000)|value<<29)
}
func (o *CAN0_Type) GetID15_PRIO() uint32 {
	return (volatile.LoadUint32(&o.ID15.Reg) & 0xe0000000) >> 29
}

// CAN0.WORD015: Message Buffer 15 WORD0 Register
func (o *CAN0_Type) SetWORD015_DATA_BYTE_3(value uint32) {
	volatile.StoreUint32(&o.WORD015.Reg, volatile.LoadUint32(&o.WORD015.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetWORD015_DATA_BYTE_3() uint32 {
	return volatile.LoadUint32(&o.WORD015.Reg) & 0xff
}
func (o *CAN0_Type) SetWORD015_DATA_BYTE_2(value uint32) {
	volatile.StoreUint32(&o.WORD015.Reg, volatile.LoadUint32(&o.WORD015.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetWORD015_DATA_BYTE_2() uint32 {
	return (volatile.LoadUint32(&o.WORD015.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetWORD015_DATA_BYTE_1(value uint32) {
	volatile.StoreUint32(&o.WORD015.Reg, volatile.LoadUint32(&o.WORD015.Reg)&^(0xff0000)|value<<16)
}
func (o *CAN0_Type) GetWORD015_DATA_BYTE_1() uint32 {
	return (volatile.LoadUint32(&o.WORD015.Reg) & 0xff0000) >> 16
}
func (o *CAN0_Type) SetWORD015_DATA_BYTE_0(value uint32) {
	volatile.StoreUint32(&o.WORD015.Reg, volatile.LoadUint32(&o.WORD015.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN0_Type) GetWORD015_DATA_BYTE_0() uint32 {
	return (volatile.LoadUint32(&o.WORD015.Reg) & 0xff000000) >> 24
}

// CAN0.WORD115: Message Buffer 15 WORD1 Register
func (o *CAN0_Type) SetWORD115_DATA_BYTE_7(value uint32) {
	volatile.StoreUint32(&o.WORD115.Reg, volatile.LoadUint32(&o.WORD115.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetWORD115_DATA_BYTE_7() uint32 {
	return volatile.LoadUint32(&o.WORD115.Reg) & 0xff
}
func (o *CAN0_Type) SetWORD115_DATA_BYTE_6(value uint32) {
	volatile.StoreUint32(&o.WORD115.Reg, volatile.LoadUint32(&o.WORD115.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetWORD115_DATA_BYTE_6() uint32 {
	return (volatile.LoadUint32(&o.WORD115.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetWORD115_DATA_BYTE_5(value uint32) {
	volatile.StoreUint32(&o.WORD115.Reg, volatile.LoadUint32(&o.WORD115.Reg)&^(0xff0000)|value<<16)
}
func (o *CAN0_Type) GetWORD115_DATA_BYTE_5() uint32 {
	return (volatile.LoadUint32(&o.WORD115.Reg) & 0xff0000) >> 16
}
func (o *CAN0_Type) SetWORD115_DATA_BYTE_4(value uint32) {
	volatile.StoreUint32(&o.WORD115.Reg, volatile.LoadUint32(&o.WORD115.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN0_Type) GetWORD115_DATA_BYTE_4() uint32 {
	return (volatile.LoadUint32(&o.WORD115.Reg) & 0xff000000) >> 24
}

// CAN0.RXIMR0: Rx Individual Mask Registers
func (o *CAN0_Type) SetRXIMR0_MI0(value uint32) {
	volatile.StoreUint32(&o.RXIMR0.Reg, volatile.LoadUint32(&o.RXIMR0.Reg)&^(0x1)|value)
}
func (o *CAN0_Type) GetRXIMR0_MI0() uint32 {
	return volatile.LoadUint32(&o.RXIMR0.Reg) & 0x1
}
func (o *CAN0_Type) SetRXIMR0_MI1(value uint32) {
	volatile.StoreUint32(&o.RXIMR0.Reg, volatile.LoadUint32(&o.RXIMR0.Reg)&^(0x2)|value<<1)
}
func (o *CAN0_Type) GetRXIMR0_MI1() uint32 {
	return (volatile.LoadUint32(&o.RXIMR0.Reg) & 0x2) >> 1
}
func (o *CAN0_Type) SetRXIMR0_MI2(value uint32) {
	volatile.StoreUint32(&o.RXIMR0.Reg, volatile.LoadUint32(&o.RXIMR0.Reg)&^(0x4)|value<<2)
}
func (o *CAN0_Type) GetRXIMR0_MI2() uint32 {
	return (volatile.LoadUint32(&o.RXIMR0.Reg) & 0x4) >> 2
}
func (o *CAN0_Type) SetRXIMR0_MI3(value uint32) {
	volatile.StoreUint32(&o.RXIMR0.Reg, volatile.LoadUint32(&o.RXIMR0.Reg)&^(0x8)|value<<3)
}
func (o *CAN0_Type) GetRXIMR0_MI3() uint32 {
	return (volatile.LoadUint32(&o.RXIMR0.Reg) & 0x8) >> 3
}
func (o *CAN0_Type) SetRXIMR0_MI4(value uint32) {
	volatile.StoreUint32(&o.RXIMR0.Reg, volatile.LoadUint32(&o.RXIMR0.Reg)&^(0x10)|value<<4)
}
func (o *CAN0_Type) GetRXIMR0_MI4() uint32 {
	return (volatile.LoadUint32(&o.RXIMR0.Reg) & 0x10) >> 4
}
func (o *CAN0_Type) SetRXIMR0_MI5(value uint32) {
	volatile.StoreUint32(&o.RXIMR0.Reg, volatile.LoadUint32(&o.RXIMR0.Reg)&^(0x20)|value<<5)
}
func (o *CAN0_Type) GetRXIMR0_MI5() uint32 {
	return (volatile.LoadUint32(&o.RXIMR0.Reg) & 0x20) >> 5
}
func (o *CAN0_Type) SetRXIMR0_MI6(value uint32) {
	volatile.StoreUint32(&o.RXIMR0.Reg, volatile.LoadUint32(&o.RXIMR0.Reg)&^(0x40)|value<<6)
}
func (o *CAN0_Type) GetRXIMR0_MI6() uint32 {
	return (volatile.LoadUint32(&o.RXIMR0.Reg) & 0x40) >> 6
}
func (o *CAN0_Type) SetRXIMR0_MI7(value uint32) {
	volatile.StoreUint32(&o.RXIMR0.Reg, volatile.LoadUint32(&o.RXIMR0.Reg)&^(0x80)|value<<7)
}
func (o *CAN0_Type) GetRXIMR0_MI7() uint32 {
	return (volatile.LoadUint32(&o.RXIMR0.Reg) & 0x80) >> 7
}
func (o *CAN0_Type) SetRXIMR0_MI8(value uint32) {
	volatile.StoreUint32(&o.RXIMR0.Reg, volatile.LoadUint32(&o.RXIMR0.Reg)&^(0x100)|value<<8)
}
func (o *CAN0_Type) GetRXIMR0_MI8() uint32 {
	return (volatile.LoadUint32(&o.RXIMR0.Reg) & 0x100) >> 8
}
func (o *CAN0_Type) SetRXIMR0_MI9(value uint32) {
	volatile.StoreUint32(&o.RXIMR0.Reg, volatile.LoadUint32(&o.RXIMR0.Reg)&^(0x200)|value<<9)
}
func (o *CAN0_Type) GetRXIMR0_MI9() uint32 {
	return (volatile.LoadUint32(&o.RXIMR0.Reg) & 0x200) >> 9
}
func (o *CAN0_Type) SetRXIMR0_MI10(value uint32) {
	volatile.StoreUint32(&o.RXIMR0.Reg, volatile.LoadUint32(&o.RXIMR0.Reg)&^(0x400)|value<<10)
}
func (o *CAN0_Type) GetRXIMR0_MI10() uint32 {
	return (volatile.LoadUint32(&o.RXIMR0.Reg) & 0x400) >> 10
}
func (o *CAN0_Type) SetRXIMR0_MI11(value uint32) {
	volatile.StoreUint32(&o.RXIMR0.Reg, volatile.LoadUint32(&o.RXIMR0.Reg)&^(0x800)|value<<11)
}
func (o *CAN0_Type) GetRXIMR0_MI11() uint32 {
	return (volatile.LoadUint32(&o.RXIMR0.Reg) & 0x800) >> 11
}
func (o *CAN0_Type) SetRXIMR0_MI12(value uint32) {
	volatile.StoreUint32(&o.RXIMR0.Reg, volatile.LoadUint32(&o.RXIMR0.Reg)&^(0x1000)|value<<12)
}
func (o *CAN0_Type) GetRXIMR0_MI12() uint32 {
	return (volatile.LoadUint32(&o.RXIMR0.Reg) & 0x1000) >> 12
}
func (o *CAN0_Type) SetRXIMR0_MI13(value uint32) {
	volatile.StoreUint32(&o.RXIMR0.Reg, volatile.LoadUint32(&o.RXIMR0.Reg)&^(0x2000)|value<<13)
}
func (o *CAN0_Type) GetRXIMR0_MI13() uint32 {
	return (volatile.LoadUint32(&o.RXIMR0.Reg) & 0x2000) >> 13
}
func (o *CAN0_Type) SetRXIMR0_MI14(value uint32) {
	volatile.StoreUint32(&o.RXIMR0.Reg, volatile.LoadUint32(&o.RXIMR0.Reg)&^(0x4000)|value<<14)
}
func (o *CAN0_Type) GetRXIMR0_MI14() uint32 {
	return (volatile.LoadUint32(&o.RXIMR0.Reg) & 0x4000) >> 14
}
func (o *CAN0_Type) SetRXIMR0_MI15(value uint32) {
	volatile.StoreUint32(&o.RXIMR0.Reg, volatile.LoadUint32(&o.RXIMR0.Reg)&^(0x8000)|value<<15)
}
func (o *CAN0_Type) GetRXIMR0_MI15() uint32 {
	return (volatile.LoadUint32(&o.RXIMR0.Reg) & 0x8000) >> 15
}
func (o *CAN0_Type) SetRXIMR0_MI16(value uint32) {
	volatile.StoreUint32(&o.RXIMR0.Reg, volatile.LoadUint32(&o.RXIMR0.Reg)&^(0x10000)|value<<16)
}
func (o *CAN0_Type) GetRXIMR0_MI16() uint32 {
	return (volatile.LoadUint32(&o.RXIMR0.Reg) & 0x10000) >> 16
}
func (o *CAN0_Type) SetRXIMR0_MI17(value uint32) {
	volatile.StoreUint32(&o.RXIMR0.Reg, volatile.LoadUint32(&o.RXIMR0.Reg)&^(0x20000)|value<<17)
}
func (o *CAN0_Type) GetRXIMR0_MI17() uint32 {
	return (volatile.LoadUint32(&o.RXIMR0.Reg) & 0x20000) >> 17
}
func (o *CAN0_Type) SetRXIMR0_MI18(value uint32) {
	volatile.StoreUint32(&o.RXIMR0.Reg, volatile.LoadUint32(&o.RXIMR0.Reg)&^(0x40000)|value<<18)
}
func (o *CAN0_Type) GetRXIMR0_MI18() uint32 {
	return (volatile.LoadUint32(&o.RXIMR0.Reg) & 0x40000) >> 18
}
func (o *CAN0_Type) SetRXIMR0_MI19(value uint32) {
	volatile.StoreUint32(&o.RXIMR0.Reg, volatile.LoadUint32(&o.RXIMR0.Reg)&^(0x80000)|value<<19)
}
func (o *CAN0_Type) GetRXIMR0_MI19() uint32 {
	return (volatile.LoadUint32(&o.RXIMR0.Reg) & 0x80000) >> 19
}
func (o *CAN0_Type) SetRXIMR0_MI20(value uint32) {
	volatile.StoreUint32(&o.RXIMR0.Reg, volatile.LoadUint32(&o.RXIMR0.Reg)&^(0x100000)|value<<20)
}
func (o *CAN0_Type) GetRXIMR0_MI20() uint32 {
	return (volatile.LoadUint32(&o.RXIMR0.Reg) & 0x100000) >> 20
}
func (o *CAN0_Type) SetRXIMR0_MI21(value uint32) {
	volatile.StoreUint32(&o.RXIMR0.Reg, volatile.LoadUint32(&o.RXIMR0.Reg)&^(0x200000)|value<<21)
}
func (o *CAN0_Type) GetRXIMR0_MI21() uint32 {
	return (volatile.LoadUint32(&o.RXIMR0.Reg) & 0x200000) >> 21
}
func (o *CAN0_Type) SetRXIMR0_MI22(value uint32) {
	volatile.StoreUint32(&o.RXIMR0.Reg, volatile.LoadUint32(&o.RXIMR0.Reg)&^(0x400000)|value<<22)
}
func (o *CAN0_Type) GetRXIMR0_MI22() uint32 {
	return (volatile.LoadUint32(&o.RXIMR0.Reg) & 0x400000) >> 22
}
func (o *CAN0_Type) SetRXIMR0_MI23(value uint32) {
	volatile.StoreUint32(&o.RXIMR0.Reg, volatile.LoadUint32(&o.RXIMR0.Reg)&^(0x800000)|value<<23)
}
func (o *CAN0_Type) GetRXIMR0_MI23() uint32 {
	return (volatile.LoadUint32(&o.RXIMR0.Reg) & 0x800000) >> 23
}
func (o *CAN0_Type) SetRXIMR0_MI24(value uint32) {
	volatile.StoreUint32(&o.RXIMR0.Reg, volatile.LoadUint32(&o.RXIMR0.Reg)&^(0x1000000)|value<<24)
}
func (o *CAN0_Type) GetRXIMR0_MI24() uint32 {
	return (volatile.LoadUint32(&o.RXIMR0.Reg) & 0x1000000) >> 24
}
func (o *CAN0_Type) SetRXIMR0_MI25(value uint32) {
	volatile.StoreUint32(&o.RXIMR0.Reg, volatile.LoadUint32(&o.RXIMR0.Reg)&^(0x2000000)|value<<25)
}
func (o *CAN0_Type) GetRXIMR0_MI25() uint32 {
	return (volatile.LoadUint32(&o.RXIMR0.Reg) & 0x2000000) >> 25
}
func (o *CAN0_Type) SetRXIMR0_MI26(value uint32) {
	volatile.StoreUint32(&o.RXIMR0.Reg, volatile.LoadUint32(&o.RXIMR0.Reg)&^(0x4000000)|value<<26)
}
func (o *CAN0_Type) GetRXIMR0_MI26() uint32 {
	return (volatile.LoadUint32(&o.RXIMR0.Reg) & 0x4000000) >> 26
}
func (o *CAN0_Type) SetRXIMR0_MI27(value uint32) {
	volatile.StoreUint32(&o.RXIMR0.Reg, volatile.LoadUint32(&o.RXIMR0.Reg)&^(0x8000000)|value<<27)
}
func (o *CAN0_Type) GetRXIMR0_MI27() uint32 {
	return (volatile.LoadUint32(&o.RXIMR0.Reg) & 0x8000000) >> 27
}
func (o *CAN0_Type) SetRXIMR0_MI28(value uint32) {
	volatile.StoreUint32(&o.RXIMR0.Reg, volatile.LoadUint32(&o.RXIMR0.Reg)&^(0x10000000)|value<<28)
}
func (o *CAN0_Type) GetRXIMR0_MI28() uint32 {
	return (volatile.LoadUint32(&o.RXIMR0.Reg) & 0x10000000) >> 28
}
func (o *CAN0_Type) SetRXIMR0_MI29(value uint32) {
	volatile.StoreUint32(&o.RXIMR0.Reg, volatile.LoadUint32(&o.RXIMR0.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetRXIMR0_MI29() uint32 {
	return (volatile.LoadUint32(&o.RXIMR0.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetRXIMR0_MI30(value uint32) {
	volatile.StoreUint32(&o.RXIMR0.Reg, volatile.LoadUint32(&o.RXIMR0.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetRXIMR0_MI30() uint32 {
	return (volatile.LoadUint32(&o.RXIMR0.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetRXIMR0_MI31(value uint32) {
	volatile.StoreUint32(&o.RXIMR0.Reg, volatile.LoadUint32(&o.RXIMR0.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetRXIMR0_MI31() uint32 {
	return (volatile.LoadUint32(&o.RXIMR0.Reg) & 0x80000000) >> 31
}

// CAN0.RXIMR1: Rx Individual Mask Registers
func (o *CAN0_Type) SetRXIMR1_MI0(value uint32) {
	volatile.StoreUint32(&o.RXIMR1.Reg, volatile.LoadUint32(&o.RXIMR1.Reg)&^(0x1)|value)
}
func (o *CAN0_Type) GetRXIMR1_MI0() uint32 {
	return volatile.LoadUint32(&o.RXIMR1.Reg) & 0x1
}
func (o *CAN0_Type) SetRXIMR1_MI1(value uint32) {
	volatile.StoreUint32(&o.RXIMR1.Reg, volatile.LoadUint32(&o.RXIMR1.Reg)&^(0x2)|value<<1)
}
func (o *CAN0_Type) GetRXIMR1_MI1() uint32 {
	return (volatile.LoadUint32(&o.RXIMR1.Reg) & 0x2) >> 1
}
func (o *CAN0_Type) SetRXIMR1_MI2(value uint32) {
	volatile.StoreUint32(&o.RXIMR1.Reg, volatile.LoadUint32(&o.RXIMR1.Reg)&^(0x4)|value<<2)
}
func (o *CAN0_Type) GetRXIMR1_MI2() uint32 {
	return (volatile.LoadUint32(&o.RXIMR1.Reg) & 0x4) >> 2
}
func (o *CAN0_Type) SetRXIMR1_MI3(value uint32) {
	volatile.StoreUint32(&o.RXIMR1.Reg, volatile.LoadUint32(&o.RXIMR1.Reg)&^(0x8)|value<<3)
}
func (o *CAN0_Type) GetRXIMR1_MI3() uint32 {
	return (volatile.LoadUint32(&o.RXIMR1.Reg) & 0x8) >> 3
}
func (o *CAN0_Type) SetRXIMR1_MI4(value uint32) {
	volatile.StoreUint32(&o.RXIMR1.Reg, volatile.LoadUint32(&o.RXIMR1.Reg)&^(0x10)|value<<4)
}
func (o *CAN0_Type) GetRXIMR1_MI4() uint32 {
	return (volatile.LoadUint32(&o.RXIMR1.Reg) & 0x10) >> 4
}
func (o *CAN0_Type) SetRXIMR1_MI5(value uint32) {
	volatile.StoreUint32(&o.RXIMR1.Reg, volatile.LoadUint32(&o.RXIMR1.Reg)&^(0x20)|value<<5)
}
func (o *CAN0_Type) GetRXIMR1_MI5() uint32 {
	return (volatile.LoadUint32(&o.RXIMR1.Reg) & 0x20) >> 5
}
func (o *CAN0_Type) SetRXIMR1_MI6(value uint32) {
	volatile.StoreUint32(&o.RXIMR1.Reg, volatile.LoadUint32(&o.RXIMR1.Reg)&^(0x40)|value<<6)
}
func (o *CAN0_Type) GetRXIMR1_MI6() uint32 {
	return (volatile.LoadUint32(&o.RXIMR1.Reg) & 0x40) >> 6
}
func (o *CAN0_Type) SetRXIMR1_MI7(value uint32) {
	volatile.StoreUint32(&o.RXIMR1.Reg, volatile.LoadUint32(&o.RXIMR1.Reg)&^(0x80)|value<<7)
}
func (o *CAN0_Type) GetRXIMR1_MI7() uint32 {
	return (volatile.LoadUint32(&o.RXIMR1.Reg) & 0x80) >> 7
}
func (o *CAN0_Type) SetRXIMR1_MI8(value uint32) {
	volatile.StoreUint32(&o.RXIMR1.Reg, volatile.LoadUint32(&o.RXIMR1.Reg)&^(0x100)|value<<8)
}
func (o *CAN0_Type) GetRXIMR1_MI8() uint32 {
	return (volatile.LoadUint32(&o.RXIMR1.Reg) & 0x100) >> 8
}
func (o *CAN0_Type) SetRXIMR1_MI9(value uint32) {
	volatile.StoreUint32(&o.RXIMR1.Reg, volatile.LoadUint32(&o.RXIMR1.Reg)&^(0x200)|value<<9)
}
func (o *CAN0_Type) GetRXIMR1_MI9() uint32 {
	return (volatile.LoadUint32(&o.RXIMR1.Reg) & 0x200) >> 9
}
func (o *CAN0_Type) SetRXIMR1_MI10(value uint32) {
	volatile.StoreUint32(&o.RXIMR1.Reg, volatile.LoadUint32(&o.RXIMR1.Reg)&^(0x400)|value<<10)
}
func (o *CAN0_Type) GetRXIMR1_MI10() uint32 {
	return (volatile.LoadUint32(&o.RXIMR1.Reg) & 0x400) >> 10
}
func (o *CAN0_Type) SetRXIMR1_MI11(value uint32) {
	volatile.StoreUint32(&o.RXIMR1.Reg, volatile.LoadUint32(&o.RXIMR1.Reg)&^(0x800)|value<<11)
}
func (o *CAN0_Type) GetRXIMR1_MI11() uint32 {
	return (volatile.LoadUint32(&o.RXIMR1.Reg) & 0x800) >> 11
}
func (o *CAN0_Type) SetRXIMR1_MI12(value uint32) {
	volatile.StoreUint32(&o.RXIMR1.Reg, volatile.LoadUint32(&o.RXIMR1.Reg)&^(0x1000)|value<<12)
}
func (o *CAN0_Type) GetRXIMR1_MI12() uint32 {
	return (volatile.LoadUint32(&o.RXIMR1.Reg) & 0x1000) >> 12
}
func (o *CAN0_Type) SetRXIMR1_MI13(value uint32) {
	volatile.StoreUint32(&o.RXIMR1.Reg, volatile.LoadUint32(&o.RXIMR1.Reg)&^(0x2000)|value<<13)
}
func (o *CAN0_Type) GetRXIMR1_MI13() uint32 {
	return (volatile.LoadUint32(&o.RXIMR1.Reg) & 0x2000) >> 13
}
func (o *CAN0_Type) SetRXIMR1_MI14(value uint32) {
	volatile.StoreUint32(&o.RXIMR1.Reg, volatile.LoadUint32(&o.RXIMR1.Reg)&^(0x4000)|value<<14)
}
func (o *CAN0_Type) GetRXIMR1_MI14() uint32 {
	return (volatile.LoadUint32(&o.RXIMR1.Reg) & 0x4000) >> 14
}
func (o *CAN0_Type) SetRXIMR1_MI15(value uint32) {
	volatile.StoreUint32(&o.RXIMR1.Reg, volatile.LoadUint32(&o.RXIMR1.Reg)&^(0x8000)|value<<15)
}
func (o *CAN0_Type) GetRXIMR1_MI15() uint32 {
	return (volatile.LoadUint32(&o.RXIMR1.Reg) & 0x8000) >> 15
}
func (o *CAN0_Type) SetRXIMR1_MI16(value uint32) {
	volatile.StoreUint32(&o.RXIMR1.Reg, volatile.LoadUint32(&o.RXIMR1.Reg)&^(0x10000)|value<<16)
}
func (o *CAN0_Type) GetRXIMR1_MI16() uint32 {
	return (volatile.LoadUint32(&o.RXIMR1.Reg) & 0x10000) >> 16
}
func (o *CAN0_Type) SetRXIMR1_MI17(value uint32) {
	volatile.StoreUint32(&o.RXIMR1.Reg, volatile.LoadUint32(&o.RXIMR1.Reg)&^(0x20000)|value<<17)
}
func (o *CAN0_Type) GetRXIMR1_MI17() uint32 {
	return (volatile.LoadUint32(&o.RXIMR1.Reg) & 0x20000) >> 17
}
func (o *CAN0_Type) SetRXIMR1_MI18(value uint32) {
	volatile.StoreUint32(&o.RXIMR1.Reg, volatile.LoadUint32(&o.RXIMR1.Reg)&^(0x40000)|value<<18)
}
func (o *CAN0_Type) GetRXIMR1_MI18() uint32 {
	return (volatile.LoadUint32(&o.RXIMR1.Reg) & 0x40000) >> 18
}
func (o *CAN0_Type) SetRXIMR1_MI19(value uint32) {
	volatile.StoreUint32(&o.RXIMR1.Reg, volatile.LoadUint32(&o.RXIMR1.Reg)&^(0x80000)|value<<19)
}
func (o *CAN0_Type) GetRXIMR1_MI19() uint32 {
	return (volatile.LoadUint32(&o.RXIMR1.Reg) & 0x80000) >> 19
}
func (o *CAN0_Type) SetRXIMR1_MI20(value uint32) {
	volatile.StoreUint32(&o.RXIMR1.Reg, volatile.LoadUint32(&o.RXIMR1.Reg)&^(0x100000)|value<<20)
}
func (o *CAN0_Type) GetRXIMR1_MI20() uint32 {
	return (volatile.LoadUint32(&o.RXIMR1.Reg) & 0x100000) >> 20
}
func (o *CAN0_Type) SetRXIMR1_MI21(value uint32) {
	volatile.StoreUint32(&o.RXIMR1.Reg, volatile.LoadUint32(&o.RXIMR1.Reg)&^(0x200000)|value<<21)
}
func (o *CAN0_Type) GetRXIMR1_MI21() uint32 {
	return (volatile.LoadUint32(&o.RXIMR1.Reg) & 0x200000) >> 21
}
func (o *CAN0_Type) SetRXIMR1_MI22(value uint32) {
	volatile.StoreUint32(&o.RXIMR1.Reg, volatile.LoadUint32(&o.RXIMR1.Reg)&^(0x400000)|value<<22)
}
func (o *CAN0_Type) GetRXIMR1_MI22() uint32 {
	return (volatile.LoadUint32(&o.RXIMR1.Reg) & 0x400000) >> 22
}
func (o *CAN0_Type) SetRXIMR1_MI23(value uint32) {
	volatile.StoreUint32(&o.RXIMR1.Reg, volatile.LoadUint32(&o.RXIMR1.Reg)&^(0x800000)|value<<23)
}
func (o *CAN0_Type) GetRXIMR1_MI23() uint32 {
	return (volatile.LoadUint32(&o.RXIMR1.Reg) & 0x800000) >> 23
}
func (o *CAN0_Type) SetRXIMR1_MI24(value uint32) {
	volatile.StoreUint32(&o.RXIMR1.Reg, volatile.LoadUint32(&o.RXIMR1.Reg)&^(0x1000000)|value<<24)
}
func (o *CAN0_Type) GetRXIMR1_MI24() uint32 {
	return (volatile.LoadUint32(&o.RXIMR1.Reg) & 0x1000000) >> 24
}
func (o *CAN0_Type) SetRXIMR1_MI25(value uint32) {
	volatile.StoreUint32(&o.RXIMR1.Reg, volatile.LoadUint32(&o.RXIMR1.Reg)&^(0x2000000)|value<<25)
}
func (o *CAN0_Type) GetRXIMR1_MI25() uint32 {
	return (volatile.LoadUint32(&o.RXIMR1.Reg) & 0x2000000) >> 25
}
func (o *CAN0_Type) SetRXIMR1_MI26(value uint32) {
	volatile.StoreUint32(&o.RXIMR1.Reg, volatile.LoadUint32(&o.RXIMR1.Reg)&^(0x4000000)|value<<26)
}
func (o *CAN0_Type) GetRXIMR1_MI26() uint32 {
	return (volatile.LoadUint32(&o.RXIMR1.Reg) & 0x4000000) >> 26
}
func (o *CAN0_Type) SetRXIMR1_MI27(value uint32) {
	volatile.StoreUint32(&o.RXIMR1.Reg, volatile.LoadUint32(&o.RXIMR1.Reg)&^(0x8000000)|value<<27)
}
func (o *CAN0_Type) GetRXIMR1_MI27() uint32 {
	return (volatile.LoadUint32(&o.RXIMR1.Reg) & 0x8000000) >> 27
}
func (o *CAN0_Type) SetRXIMR1_MI28(value uint32) {
	volatile.StoreUint32(&o.RXIMR1.Reg, volatile.LoadUint32(&o.RXIMR1.Reg)&^(0x10000000)|value<<28)
}
func (o *CAN0_Type) GetRXIMR1_MI28() uint32 {
	return (volatile.LoadUint32(&o.RXIMR1.Reg) & 0x10000000) >> 28
}
func (o *CAN0_Type) SetRXIMR1_MI29(value uint32) {
	volatile.StoreUint32(&o.RXIMR1.Reg, volatile.LoadUint32(&o.RXIMR1.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetRXIMR1_MI29() uint32 {
	return (volatile.LoadUint32(&o.RXIMR1.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetRXIMR1_MI30(value uint32) {
	volatile.StoreUint32(&o.RXIMR1.Reg, volatile.LoadUint32(&o.RXIMR1.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetRXIMR1_MI30() uint32 {
	return (volatile.LoadUint32(&o.RXIMR1.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetRXIMR1_MI31(value uint32) {
	volatile.StoreUint32(&o.RXIMR1.Reg, volatile.LoadUint32(&o.RXIMR1.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetRXIMR1_MI31() uint32 {
	return (volatile.LoadUint32(&o.RXIMR1.Reg) & 0x80000000) >> 31
}

// CAN0.RXIMR2: Rx Individual Mask Registers
func (o *CAN0_Type) SetRXIMR2_MI0(value uint32) {
	volatile.StoreUint32(&o.RXIMR2.Reg, volatile.LoadUint32(&o.RXIMR2.Reg)&^(0x1)|value)
}
func (o *CAN0_Type) GetRXIMR2_MI0() uint32 {
	return volatile.LoadUint32(&o.RXIMR2.Reg) & 0x1
}
func (o *CAN0_Type) SetRXIMR2_MI1(value uint32) {
	volatile.StoreUint32(&o.RXIMR2.Reg, volatile.LoadUint32(&o.RXIMR2.Reg)&^(0x2)|value<<1)
}
func (o *CAN0_Type) GetRXIMR2_MI1() uint32 {
	return (volatile.LoadUint32(&o.RXIMR2.Reg) & 0x2) >> 1
}
func (o *CAN0_Type) SetRXIMR2_MI2(value uint32) {
	volatile.StoreUint32(&o.RXIMR2.Reg, volatile.LoadUint32(&o.RXIMR2.Reg)&^(0x4)|value<<2)
}
func (o *CAN0_Type) GetRXIMR2_MI2() uint32 {
	return (volatile.LoadUint32(&o.RXIMR2.Reg) & 0x4) >> 2
}
func (o *CAN0_Type) SetRXIMR2_MI3(value uint32) {
	volatile.StoreUint32(&o.RXIMR2.Reg, volatile.LoadUint32(&o.RXIMR2.Reg)&^(0x8)|value<<3)
}
func (o *CAN0_Type) GetRXIMR2_MI3() uint32 {
	return (volatile.LoadUint32(&o.RXIMR2.Reg) & 0x8) >> 3
}
func (o *CAN0_Type) SetRXIMR2_MI4(value uint32) {
	volatile.StoreUint32(&o.RXIMR2.Reg, volatile.LoadUint32(&o.RXIMR2.Reg)&^(0x10)|value<<4)
}
func (o *CAN0_Type) GetRXIMR2_MI4() uint32 {
	return (volatile.LoadUint32(&o.RXIMR2.Reg) & 0x10) >> 4
}
func (o *CAN0_Type) SetRXIMR2_MI5(value uint32) {
	volatile.StoreUint32(&o.RXIMR2.Reg, volatile.LoadUint32(&o.RXIMR2.Reg)&^(0x20)|value<<5)
}
func (o *CAN0_Type) GetRXIMR2_MI5() uint32 {
	return (volatile.LoadUint32(&o.RXIMR2.Reg) & 0x20) >> 5
}
func (o *CAN0_Type) SetRXIMR2_MI6(value uint32) {
	volatile.StoreUint32(&o.RXIMR2.Reg, volatile.LoadUint32(&o.RXIMR2.Reg)&^(0x40)|value<<6)
}
func (o *CAN0_Type) GetRXIMR2_MI6() uint32 {
	return (volatile.LoadUint32(&o.RXIMR2.Reg) & 0x40) >> 6
}
func (o *CAN0_Type) SetRXIMR2_MI7(value uint32) {
	volatile.StoreUint32(&o.RXIMR2.Reg, volatile.LoadUint32(&o.RXIMR2.Reg)&^(0x80)|value<<7)
}
func (o *CAN0_Type) GetRXIMR2_MI7() uint32 {
	return (volatile.LoadUint32(&o.RXIMR2.Reg) & 0x80) >> 7
}
func (o *CAN0_Type) SetRXIMR2_MI8(value uint32) {
	volatile.StoreUint32(&o.RXIMR2.Reg, volatile.LoadUint32(&o.RXIMR2.Reg)&^(0x100)|value<<8)
}
func (o *CAN0_Type) GetRXIMR2_MI8() uint32 {
	return (volatile.LoadUint32(&o.RXIMR2.Reg) & 0x100) >> 8
}
func (o *CAN0_Type) SetRXIMR2_MI9(value uint32) {
	volatile.StoreUint32(&o.RXIMR2.Reg, volatile.LoadUint32(&o.RXIMR2.Reg)&^(0x200)|value<<9)
}
func (o *CAN0_Type) GetRXIMR2_MI9() uint32 {
	return (volatile.LoadUint32(&o.RXIMR2.Reg) & 0x200) >> 9
}
func (o *CAN0_Type) SetRXIMR2_MI10(value uint32) {
	volatile.StoreUint32(&o.RXIMR2.Reg, volatile.LoadUint32(&o.RXIMR2.Reg)&^(0x400)|value<<10)
}
func (o *CAN0_Type) GetRXIMR2_MI10() uint32 {
	return (volatile.LoadUint32(&o.RXIMR2.Reg) & 0x400) >> 10
}
func (o *CAN0_Type) SetRXIMR2_MI11(value uint32) {
	volatile.StoreUint32(&o.RXIMR2.Reg, volatile.LoadUint32(&o.RXIMR2.Reg)&^(0x800)|value<<11)
}
func (o *CAN0_Type) GetRXIMR2_MI11() uint32 {
	return (volatile.LoadUint32(&o.RXIMR2.Reg) & 0x800) >> 11
}
func (o *CAN0_Type) SetRXIMR2_MI12(value uint32) {
	volatile.StoreUint32(&o.RXIMR2.Reg, volatile.LoadUint32(&o.RXIMR2.Reg)&^(0x1000)|value<<12)
}
func (o *CAN0_Type) GetRXIMR2_MI12() uint32 {
	return (volatile.LoadUint32(&o.RXIMR2.Reg) & 0x1000) >> 12
}
func (o *CAN0_Type) SetRXIMR2_MI13(value uint32) {
	volatile.StoreUint32(&o.RXIMR2.Reg, volatile.LoadUint32(&o.RXIMR2.Reg)&^(0x2000)|value<<13)
}
func (o *CAN0_Type) GetRXIMR2_MI13() uint32 {
	return (volatile.LoadUint32(&o.RXIMR2.Reg) & 0x2000) >> 13
}
func (o *CAN0_Type) SetRXIMR2_MI14(value uint32) {
	volatile.StoreUint32(&o.RXIMR2.Reg, volatile.LoadUint32(&o.RXIMR2.Reg)&^(0x4000)|value<<14)
}
func (o *CAN0_Type) GetRXIMR2_MI14() uint32 {
	return (volatile.LoadUint32(&o.RXIMR2.Reg) & 0x4000) >> 14
}
func (o *CAN0_Type) SetRXIMR2_MI15(value uint32) {
	volatile.StoreUint32(&o.RXIMR2.Reg, volatile.LoadUint32(&o.RXIMR2.Reg)&^(0x8000)|value<<15)
}
func (o *CAN0_Type) GetRXIMR2_MI15() uint32 {
	return (volatile.LoadUint32(&o.RXIMR2.Reg) & 0x8000) >> 15
}
func (o *CAN0_Type) SetRXIMR2_MI16(value uint32) {
	volatile.StoreUint32(&o.RXIMR2.Reg, volatile.LoadUint32(&o.RXIMR2.Reg)&^(0x10000)|value<<16)
}
func (o *CAN0_Type) GetRXIMR2_MI16() uint32 {
	return (volatile.LoadUint32(&o.RXIMR2.Reg) & 0x10000) >> 16
}
func (o *CAN0_Type) SetRXIMR2_MI17(value uint32) {
	volatile.StoreUint32(&o.RXIMR2.Reg, volatile.LoadUint32(&o.RXIMR2.Reg)&^(0x20000)|value<<17)
}
func (o *CAN0_Type) GetRXIMR2_MI17() uint32 {
	return (volatile.LoadUint32(&o.RXIMR2.Reg) & 0x20000) >> 17
}
func (o *CAN0_Type) SetRXIMR2_MI18(value uint32) {
	volatile.StoreUint32(&o.RXIMR2.Reg, volatile.LoadUint32(&o.RXIMR2.Reg)&^(0x40000)|value<<18)
}
func (o *CAN0_Type) GetRXIMR2_MI18() uint32 {
	return (volatile.LoadUint32(&o.RXIMR2.Reg) & 0x40000) >> 18
}
func (o *CAN0_Type) SetRXIMR2_MI19(value uint32) {
	volatile.StoreUint32(&o.RXIMR2.Reg, volatile.LoadUint32(&o.RXIMR2.Reg)&^(0x80000)|value<<19)
}
func (o *CAN0_Type) GetRXIMR2_MI19() uint32 {
	return (volatile.LoadUint32(&o.RXIMR2.Reg) & 0x80000) >> 19
}
func (o *CAN0_Type) SetRXIMR2_MI20(value uint32) {
	volatile.StoreUint32(&o.RXIMR2.Reg, volatile.LoadUint32(&o.RXIMR2.Reg)&^(0x100000)|value<<20)
}
func (o *CAN0_Type) GetRXIMR2_MI20() uint32 {
	return (volatile.LoadUint32(&o.RXIMR2.Reg) & 0x100000) >> 20
}
func (o *CAN0_Type) SetRXIMR2_MI21(value uint32) {
	volatile.StoreUint32(&o.RXIMR2.Reg, volatile.LoadUint32(&o.RXIMR2.Reg)&^(0x200000)|value<<21)
}
func (o *CAN0_Type) GetRXIMR2_MI21() uint32 {
	return (volatile.LoadUint32(&o.RXIMR2.Reg) & 0x200000) >> 21
}
func (o *CAN0_Type) SetRXIMR2_MI22(value uint32) {
	volatile.StoreUint32(&o.RXIMR2.Reg, volatile.LoadUint32(&o.RXIMR2.Reg)&^(0x400000)|value<<22)
}
func (o *CAN0_Type) GetRXIMR2_MI22() uint32 {
	return (volatile.LoadUint32(&o.RXIMR2.Reg) & 0x400000) >> 22
}
func (o *CAN0_Type) SetRXIMR2_MI23(value uint32) {
	volatile.StoreUint32(&o.RXIMR2.Reg, volatile.LoadUint32(&o.RXIMR2.Reg)&^(0x800000)|value<<23)
}
func (o *CAN0_Type) GetRXIMR2_MI23() uint32 {
	return (volatile.LoadUint32(&o.RXIMR2.Reg) & 0x800000) >> 23
}
func (o *CAN0_Type) SetRXIMR2_MI24(value uint32) {
	volatile.StoreUint32(&o.RXIMR2.Reg, volatile.LoadUint32(&o.RXIMR2.Reg)&^(0x1000000)|value<<24)
}
func (o *CAN0_Type) GetRXIMR2_MI24() uint32 {
	return (volatile.LoadUint32(&o.RXIMR2.Reg) & 0x1000000) >> 24
}
func (o *CAN0_Type) SetRXIMR2_MI25(value uint32) {
	volatile.StoreUint32(&o.RXIMR2.Reg, volatile.LoadUint32(&o.RXIMR2.Reg)&^(0x2000000)|value<<25)
}
func (o *CAN0_Type) GetRXIMR2_MI25() uint32 {
	return (volatile.LoadUint32(&o.RXIMR2.Reg) & 0x2000000) >> 25
}
func (o *CAN0_Type) SetRXIMR2_MI26(value uint32) {
	volatile.StoreUint32(&o.RXIMR2.Reg, volatile.LoadUint32(&o.RXIMR2.Reg)&^(0x4000000)|value<<26)
}
func (o *CAN0_Type) GetRXIMR2_MI26() uint32 {
	return (volatile.LoadUint32(&o.RXIMR2.Reg) & 0x4000000) >> 26
}
func (o *CAN0_Type) SetRXIMR2_MI27(value uint32) {
	volatile.StoreUint32(&o.RXIMR2.Reg, volatile.LoadUint32(&o.RXIMR2.Reg)&^(0x8000000)|value<<27)
}
func (o *CAN0_Type) GetRXIMR2_MI27() uint32 {
	return (volatile.LoadUint32(&o.RXIMR2.Reg) & 0x8000000) >> 27
}
func (o *CAN0_Type) SetRXIMR2_MI28(value uint32) {
	volatile.StoreUint32(&o.RXIMR2.Reg, volatile.LoadUint32(&o.RXIMR2.Reg)&^(0x10000000)|value<<28)
}
func (o *CAN0_Type) GetRXIMR2_MI28() uint32 {
	return (volatile.LoadUint32(&o.RXIMR2.Reg) & 0x10000000) >> 28
}
func (o *CAN0_Type) SetRXIMR2_MI29(value uint32) {
	volatile.StoreUint32(&o.RXIMR2.Reg, volatile.LoadUint32(&o.RXIMR2.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetRXIMR2_MI29() uint32 {
	return (volatile.LoadUint32(&o.RXIMR2.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetRXIMR2_MI30(value uint32) {
	volatile.StoreUint32(&o.RXIMR2.Reg, volatile.LoadUint32(&o.RXIMR2.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetRXIMR2_MI30() uint32 {
	return (volatile.LoadUint32(&o.RXIMR2.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetRXIMR2_MI31(value uint32) {
	volatile.StoreUint32(&o.RXIMR2.Reg, volatile.LoadUint32(&o.RXIMR2.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetRXIMR2_MI31() uint32 {
	return (volatile.LoadUint32(&o.RXIMR2.Reg) & 0x80000000) >> 31
}

// CAN0.RXIMR3: Rx Individual Mask Registers
func (o *CAN0_Type) SetRXIMR3_MI0(value uint32) {
	volatile.StoreUint32(&o.RXIMR3.Reg, volatile.LoadUint32(&o.RXIMR3.Reg)&^(0x1)|value)
}
func (o *CAN0_Type) GetRXIMR3_MI0() uint32 {
	return volatile.LoadUint32(&o.RXIMR3.Reg) & 0x1
}
func (o *CAN0_Type) SetRXIMR3_MI1(value uint32) {
	volatile.StoreUint32(&o.RXIMR3.Reg, volatile.LoadUint32(&o.RXIMR3.Reg)&^(0x2)|value<<1)
}
func (o *CAN0_Type) GetRXIMR3_MI1() uint32 {
	return (volatile.LoadUint32(&o.RXIMR3.Reg) & 0x2) >> 1
}
func (o *CAN0_Type) SetRXIMR3_MI2(value uint32) {
	volatile.StoreUint32(&o.RXIMR3.Reg, volatile.LoadUint32(&o.RXIMR3.Reg)&^(0x4)|value<<2)
}
func (o *CAN0_Type) GetRXIMR3_MI2() uint32 {
	return (volatile.LoadUint32(&o.RXIMR3.Reg) & 0x4) >> 2
}
func (o *CAN0_Type) SetRXIMR3_MI3(value uint32) {
	volatile.StoreUint32(&o.RXIMR3.Reg, volatile.LoadUint32(&o.RXIMR3.Reg)&^(0x8)|value<<3)
}
func (o *CAN0_Type) GetRXIMR3_MI3() uint32 {
	return (volatile.LoadUint32(&o.RXIMR3.Reg) & 0x8) >> 3
}
func (o *CAN0_Type) SetRXIMR3_MI4(value uint32) {
	volatile.StoreUint32(&o.RXIMR3.Reg, volatile.LoadUint32(&o.RXIMR3.Reg)&^(0x10)|value<<4)
}
func (o *CAN0_Type) GetRXIMR3_MI4() uint32 {
	return (volatile.LoadUint32(&o.RXIMR3.Reg) & 0x10) >> 4
}
func (o *CAN0_Type) SetRXIMR3_MI5(value uint32) {
	volatile.StoreUint32(&o.RXIMR3.Reg, volatile.LoadUint32(&o.RXIMR3.Reg)&^(0x20)|value<<5)
}
func (o *CAN0_Type) GetRXIMR3_MI5() uint32 {
	return (volatile.LoadUint32(&o.RXIMR3.Reg) & 0x20) >> 5
}
func (o *CAN0_Type) SetRXIMR3_MI6(value uint32) {
	volatile.StoreUint32(&o.RXIMR3.Reg, volatile.LoadUint32(&o.RXIMR3.Reg)&^(0x40)|value<<6)
}
func (o *CAN0_Type) GetRXIMR3_MI6() uint32 {
	return (volatile.LoadUint32(&o.RXIMR3.Reg) & 0x40) >> 6
}
func (o *CAN0_Type) SetRXIMR3_MI7(value uint32) {
	volatile.StoreUint32(&o.RXIMR3.Reg, volatile.LoadUint32(&o.RXIMR3.Reg)&^(0x80)|value<<7)
}
func (o *CAN0_Type) GetRXIMR3_MI7() uint32 {
	return (volatile.LoadUint32(&o.RXIMR3.Reg) & 0x80) >> 7
}
func (o *CAN0_Type) SetRXIMR3_MI8(value uint32) {
	volatile.StoreUint32(&o.RXIMR3.Reg, volatile.LoadUint32(&o.RXIMR3.Reg)&^(0x100)|value<<8)
}
func (o *CAN0_Type) GetRXIMR3_MI8() uint32 {
	return (volatile.LoadUint32(&o.RXIMR3.Reg) & 0x100) >> 8
}
func (o *CAN0_Type) SetRXIMR3_MI9(value uint32) {
	volatile.StoreUint32(&o.RXIMR3.Reg, volatile.LoadUint32(&o.RXIMR3.Reg)&^(0x200)|value<<9)
}
func (o *CAN0_Type) GetRXIMR3_MI9() uint32 {
	return (volatile.LoadUint32(&o.RXIMR3.Reg) & 0x200) >> 9
}
func (o *CAN0_Type) SetRXIMR3_MI10(value uint32) {
	volatile.StoreUint32(&o.RXIMR3.Reg, volatile.LoadUint32(&o.RXIMR3.Reg)&^(0x400)|value<<10)
}
func (o *CAN0_Type) GetRXIMR3_MI10() uint32 {
	return (volatile.LoadUint32(&o.RXIMR3.Reg) & 0x400) >> 10
}
func (o *CAN0_Type) SetRXIMR3_MI11(value uint32) {
	volatile.StoreUint32(&o.RXIMR3.Reg, volatile.LoadUint32(&o.RXIMR3.Reg)&^(0x800)|value<<11)
}
func (o *CAN0_Type) GetRXIMR3_MI11() uint32 {
	return (volatile.LoadUint32(&o.RXIMR3.Reg) & 0x800) >> 11
}
func (o *CAN0_Type) SetRXIMR3_MI12(value uint32) {
	volatile.StoreUint32(&o.RXIMR3.Reg, volatile.LoadUint32(&o.RXIMR3.Reg)&^(0x1000)|value<<12)
}
func (o *CAN0_Type) GetRXIMR3_MI12() uint32 {
	return (volatile.LoadUint32(&o.RXIMR3.Reg) & 0x1000) >> 12
}
func (o *CAN0_Type) SetRXIMR3_MI13(value uint32) {
	volatile.StoreUint32(&o.RXIMR3.Reg, volatile.LoadUint32(&o.RXIMR3.Reg)&^(0x2000)|value<<13)
}
func (o *CAN0_Type) GetRXIMR3_MI13() uint32 {
	return (volatile.LoadUint32(&o.RXIMR3.Reg) & 0x2000) >> 13
}
func (o *CAN0_Type) SetRXIMR3_MI14(value uint32) {
	volatile.StoreUint32(&o.RXIMR3.Reg, volatile.LoadUint32(&o.RXIMR3.Reg)&^(0x4000)|value<<14)
}
func (o *CAN0_Type) GetRXIMR3_MI14() uint32 {
	return (volatile.LoadUint32(&o.RXIMR3.Reg) & 0x4000) >> 14
}
func (o *CAN0_Type) SetRXIMR3_MI15(value uint32) {
	volatile.StoreUint32(&o.RXIMR3.Reg, volatile.LoadUint32(&o.RXIMR3.Reg)&^(0x8000)|value<<15)
}
func (o *CAN0_Type) GetRXIMR3_MI15() uint32 {
	return (volatile.LoadUint32(&o.RXIMR3.Reg) & 0x8000) >> 15
}
func (o *CAN0_Type) SetRXIMR3_MI16(value uint32) {
	volatile.StoreUint32(&o.RXIMR3.Reg, volatile.LoadUint32(&o.RXIMR3.Reg)&^(0x10000)|value<<16)
}
func (o *CAN0_Type) GetRXIMR3_MI16() uint32 {
	return (volatile.LoadUint32(&o.RXIMR3.Reg) & 0x10000) >> 16
}
func (o *CAN0_Type) SetRXIMR3_MI17(value uint32) {
	volatile.StoreUint32(&o.RXIMR3.Reg, volatile.LoadUint32(&o.RXIMR3.Reg)&^(0x20000)|value<<17)
}
func (o *CAN0_Type) GetRXIMR3_MI17() uint32 {
	return (volatile.LoadUint32(&o.RXIMR3.Reg) & 0x20000) >> 17
}
func (o *CAN0_Type) SetRXIMR3_MI18(value uint32) {
	volatile.StoreUint32(&o.RXIMR3.Reg, volatile.LoadUint32(&o.RXIMR3.Reg)&^(0x40000)|value<<18)
}
func (o *CAN0_Type) GetRXIMR3_MI18() uint32 {
	return (volatile.LoadUint32(&o.RXIMR3.Reg) & 0x40000) >> 18
}
func (o *CAN0_Type) SetRXIMR3_MI19(value uint32) {
	volatile.StoreUint32(&o.RXIMR3.Reg, volatile.LoadUint32(&o.RXIMR3.Reg)&^(0x80000)|value<<19)
}
func (o *CAN0_Type) GetRXIMR3_MI19() uint32 {
	return (volatile.LoadUint32(&o.RXIMR3.Reg) & 0x80000) >> 19
}
func (o *CAN0_Type) SetRXIMR3_MI20(value uint32) {
	volatile.StoreUint32(&o.RXIMR3.Reg, volatile.LoadUint32(&o.RXIMR3.Reg)&^(0x100000)|value<<20)
}
func (o *CAN0_Type) GetRXIMR3_MI20() uint32 {
	return (volatile.LoadUint32(&o.RXIMR3.Reg) & 0x100000) >> 20
}
func (o *CAN0_Type) SetRXIMR3_MI21(value uint32) {
	volatile.StoreUint32(&o.RXIMR3.Reg, volatile.LoadUint32(&o.RXIMR3.Reg)&^(0x200000)|value<<21)
}
func (o *CAN0_Type) GetRXIMR3_MI21() uint32 {
	return (volatile.LoadUint32(&o.RXIMR3.Reg) & 0x200000) >> 21
}
func (o *CAN0_Type) SetRXIMR3_MI22(value uint32) {
	volatile.StoreUint32(&o.RXIMR3.Reg, volatile.LoadUint32(&o.RXIMR3.Reg)&^(0x400000)|value<<22)
}
func (o *CAN0_Type) GetRXIMR3_MI22() uint32 {
	return (volatile.LoadUint32(&o.RXIMR3.Reg) & 0x400000) >> 22
}
func (o *CAN0_Type) SetRXIMR3_MI23(value uint32) {
	volatile.StoreUint32(&o.RXIMR3.Reg, volatile.LoadUint32(&o.RXIMR3.Reg)&^(0x800000)|value<<23)
}
func (o *CAN0_Type) GetRXIMR3_MI23() uint32 {
	return (volatile.LoadUint32(&o.RXIMR3.Reg) & 0x800000) >> 23
}
func (o *CAN0_Type) SetRXIMR3_MI24(value uint32) {
	volatile.StoreUint32(&o.RXIMR3.Reg, volatile.LoadUint32(&o.RXIMR3.Reg)&^(0x1000000)|value<<24)
}
func (o *CAN0_Type) GetRXIMR3_MI24() uint32 {
	return (volatile.LoadUint32(&o.RXIMR3.Reg) & 0x1000000) >> 24
}
func (o *CAN0_Type) SetRXIMR3_MI25(value uint32) {
	volatile.StoreUint32(&o.RXIMR3.Reg, volatile.LoadUint32(&o.RXIMR3.Reg)&^(0x2000000)|value<<25)
}
func (o *CAN0_Type) GetRXIMR3_MI25() uint32 {
	return (volatile.LoadUint32(&o.RXIMR3.Reg) & 0x2000000) >> 25
}
func (o *CAN0_Type) SetRXIMR3_MI26(value uint32) {
	volatile.StoreUint32(&o.RXIMR3.Reg, volatile.LoadUint32(&o.RXIMR3.Reg)&^(0x4000000)|value<<26)
}
func (o *CAN0_Type) GetRXIMR3_MI26() uint32 {
	return (volatile.LoadUint32(&o.RXIMR3.Reg) & 0x4000000) >> 26
}
func (o *CAN0_Type) SetRXIMR3_MI27(value uint32) {
	volatile.StoreUint32(&o.RXIMR3.Reg, volatile.LoadUint32(&o.RXIMR3.Reg)&^(0x8000000)|value<<27)
}
func (o *CAN0_Type) GetRXIMR3_MI27() uint32 {
	return (volatile.LoadUint32(&o.RXIMR3.Reg) & 0x8000000) >> 27
}
func (o *CAN0_Type) SetRXIMR3_MI28(value uint32) {
	volatile.StoreUint32(&o.RXIMR3.Reg, volatile.LoadUint32(&o.RXIMR3.Reg)&^(0x10000000)|value<<28)
}
func (o *CAN0_Type) GetRXIMR3_MI28() uint32 {
	return (volatile.LoadUint32(&o.RXIMR3.Reg) & 0x10000000) >> 28
}
func (o *CAN0_Type) SetRXIMR3_MI29(value uint32) {
	volatile.StoreUint32(&o.RXIMR3.Reg, volatile.LoadUint32(&o.RXIMR3.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetRXIMR3_MI29() uint32 {
	return (volatile.LoadUint32(&o.RXIMR3.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetRXIMR3_MI30(value uint32) {
	volatile.StoreUint32(&o.RXIMR3.Reg, volatile.LoadUint32(&o.RXIMR3.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetRXIMR3_MI30() uint32 {
	return (volatile.LoadUint32(&o.RXIMR3.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetRXIMR3_MI31(value uint32) {
	volatile.StoreUint32(&o.RXIMR3.Reg, volatile.LoadUint32(&o.RXIMR3.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetRXIMR3_MI31() uint32 {
	return (volatile.LoadUint32(&o.RXIMR3.Reg) & 0x80000000) >> 31
}

// CAN0.RXIMR4: Rx Individual Mask Registers
func (o *CAN0_Type) SetRXIMR4_MI0(value uint32) {
	volatile.StoreUint32(&o.RXIMR4.Reg, volatile.LoadUint32(&o.RXIMR4.Reg)&^(0x1)|value)
}
func (o *CAN0_Type) GetRXIMR4_MI0() uint32 {
	return volatile.LoadUint32(&o.RXIMR4.Reg) & 0x1
}
func (o *CAN0_Type) SetRXIMR4_MI1(value uint32) {
	volatile.StoreUint32(&o.RXIMR4.Reg, volatile.LoadUint32(&o.RXIMR4.Reg)&^(0x2)|value<<1)
}
func (o *CAN0_Type) GetRXIMR4_MI1() uint32 {
	return (volatile.LoadUint32(&o.RXIMR4.Reg) & 0x2) >> 1
}
func (o *CAN0_Type) SetRXIMR4_MI2(value uint32) {
	volatile.StoreUint32(&o.RXIMR4.Reg, volatile.LoadUint32(&o.RXIMR4.Reg)&^(0x4)|value<<2)
}
func (o *CAN0_Type) GetRXIMR4_MI2() uint32 {
	return (volatile.LoadUint32(&o.RXIMR4.Reg) & 0x4) >> 2
}
func (o *CAN0_Type) SetRXIMR4_MI3(value uint32) {
	volatile.StoreUint32(&o.RXIMR4.Reg, volatile.LoadUint32(&o.RXIMR4.Reg)&^(0x8)|value<<3)
}
func (o *CAN0_Type) GetRXIMR4_MI3() uint32 {
	return (volatile.LoadUint32(&o.RXIMR4.Reg) & 0x8) >> 3
}
func (o *CAN0_Type) SetRXIMR4_MI4(value uint32) {
	volatile.StoreUint32(&o.RXIMR4.Reg, volatile.LoadUint32(&o.RXIMR4.Reg)&^(0x10)|value<<4)
}
func (o *CAN0_Type) GetRXIMR4_MI4() uint32 {
	return (volatile.LoadUint32(&o.RXIMR4.Reg) & 0x10) >> 4
}
func (o *CAN0_Type) SetRXIMR4_MI5(value uint32) {
	volatile.StoreUint32(&o.RXIMR4.Reg, volatile.LoadUint32(&o.RXIMR4.Reg)&^(0x20)|value<<5)
}
func (o *CAN0_Type) GetRXIMR4_MI5() uint32 {
	return (volatile.LoadUint32(&o.RXIMR4.Reg) & 0x20) >> 5
}
func (o *CAN0_Type) SetRXIMR4_MI6(value uint32) {
	volatile.StoreUint32(&o.RXIMR4.Reg, volatile.LoadUint32(&o.RXIMR4.Reg)&^(0x40)|value<<6)
}
func (o *CAN0_Type) GetRXIMR4_MI6() uint32 {
	return (volatile.LoadUint32(&o.RXIMR4.Reg) & 0x40) >> 6
}
func (o *CAN0_Type) SetRXIMR4_MI7(value uint32) {
	volatile.StoreUint32(&o.RXIMR4.Reg, volatile.LoadUint32(&o.RXIMR4.Reg)&^(0x80)|value<<7)
}
func (o *CAN0_Type) GetRXIMR4_MI7() uint32 {
	return (volatile.LoadUint32(&o.RXIMR4.Reg) & 0x80) >> 7
}
func (o *CAN0_Type) SetRXIMR4_MI8(value uint32) {
	volatile.StoreUint32(&o.RXIMR4.Reg, volatile.LoadUint32(&o.RXIMR4.Reg)&^(0x100)|value<<8)
}
func (o *CAN0_Type) GetRXIMR4_MI8() uint32 {
	return (volatile.LoadUint32(&o.RXIMR4.Reg) & 0x100) >> 8
}
func (o *CAN0_Type) SetRXIMR4_MI9(value uint32) {
	volatile.StoreUint32(&o.RXIMR4.Reg, volatile.LoadUint32(&o.RXIMR4.Reg)&^(0x200)|value<<9)
}
func (o *CAN0_Type) GetRXIMR4_MI9() uint32 {
	return (volatile.LoadUint32(&o.RXIMR4.Reg) & 0x200) >> 9
}
func (o *CAN0_Type) SetRXIMR4_MI10(value uint32) {
	volatile.StoreUint32(&o.RXIMR4.Reg, volatile.LoadUint32(&o.RXIMR4.Reg)&^(0x400)|value<<10)
}
func (o *CAN0_Type) GetRXIMR4_MI10() uint32 {
	return (volatile.LoadUint32(&o.RXIMR4.Reg) & 0x400) >> 10
}
func (o *CAN0_Type) SetRXIMR4_MI11(value uint32) {
	volatile.StoreUint32(&o.RXIMR4.Reg, volatile.LoadUint32(&o.RXIMR4.Reg)&^(0x800)|value<<11)
}
func (o *CAN0_Type) GetRXIMR4_MI11() uint32 {
	return (volatile.LoadUint32(&o.RXIMR4.Reg) & 0x800) >> 11
}
func (o *CAN0_Type) SetRXIMR4_MI12(value uint32) {
	volatile.StoreUint32(&o.RXIMR4.Reg, volatile.LoadUint32(&o.RXIMR4.Reg)&^(0x1000)|value<<12)
}
func (o *CAN0_Type) GetRXIMR4_MI12() uint32 {
	return (volatile.LoadUint32(&o.RXIMR4.Reg) & 0x1000) >> 12
}
func (o *CAN0_Type) SetRXIMR4_MI13(value uint32) {
	volatile.StoreUint32(&o.RXIMR4.Reg, volatile.LoadUint32(&o.RXIMR4.Reg)&^(0x2000)|value<<13)
}
func (o *CAN0_Type) GetRXIMR4_MI13() uint32 {
	return (volatile.LoadUint32(&o.RXIMR4.Reg) & 0x2000) >> 13
}
func (o *CAN0_Type) SetRXIMR4_MI14(value uint32) {
	volatile.StoreUint32(&o.RXIMR4.Reg, volatile.LoadUint32(&o.RXIMR4.Reg)&^(0x4000)|value<<14)
}
func (o *CAN0_Type) GetRXIMR4_MI14() uint32 {
	return (volatile.LoadUint32(&o.RXIMR4.Reg) & 0x4000) >> 14
}
func (o *CAN0_Type) SetRXIMR4_MI15(value uint32) {
	volatile.StoreUint32(&o.RXIMR4.Reg, volatile.LoadUint32(&o.RXIMR4.Reg)&^(0x8000)|value<<15)
}
func (o *CAN0_Type) GetRXIMR4_MI15() uint32 {
	return (volatile.LoadUint32(&o.RXIMR4.Reg) & 0x8000) >> 15
}
func (o *CAN0_Type) SetRXIMR4_MI16(value uint32) {
	volatile.StoreUint32(&o.RXIMR4.Reg, volatile.LoadUint32(&o.RXIMR4.Reg)&^(0x10000)|value<<16)
}
func (o *CAN0_Type) GetRXIMR4_MI16() uint32 {
	return (volatile.LoadUint32(&o.RXIMR4.Reg) & 0x10000) >> 16
}
func (o *CAN0_Type) SetRXIMR4_MI17(value uint32) {
	volatile.StoreUint32(&o.RXIMR4.Reg, volatile.LoadUint32(&o.RXIMR4.Reg)&^(0x20000)|value<<17)
}
func (o *CAN0_Type) GetRXIMR4_MI17() uint32 {
	return (volatile.LoadUint32(&o.RXIMR4.Reg) & 0x20000) >> 17
}
func (o *CAN0_Type) SetRXIMR4_MI18(value uint32) {
	volatile.StoreUint32(&o.RXIMR4.Reg, volatile.LoadUint32(&o.RXIMR4.Reg)&^(0x40000)|value<<18)
}
func (o *CAN0_Type) GetRXIMR4_MI18() uint32 {
	return (volatile.LoadUint32(&o.RXIMR4.Reg) & 0x40000) >> 18
}
func (o *CAN0_Type) SetRXIMR4_MI19(value uint32) {
	volatile.StoreUint32(&o.RXIMR4.Reg, volatile.LoadUint32(&o.RXIMR4.Reg)&^(0x80000)|value<<19)
}
func (o *CAN0_Type) GetRXIMR4_MI19() uint32 {
	return (volatile.LoadUint32(&o.RXIMR4.Reg) & 0x80000) >> 19
}
func (o *CAN0_Type) SetRXIMR4_MI20(value uint32) {
	volatile.StoreUint32(&o.RXIMR4.Reg, volatile.LoadUint32(&o.RXIMR4.Reg)&^(0x100000)|value<<20)
}
func (o *CAN0_Type) GetRXIMR4_MI20() uint32 {
	return (volatile.LoadUint32(&o.RXIMR4.Reg) & 0x100000) >> 20
}
func (o *CAN0_Type) SetRXIMR4_MI21(value uint32) {
	volatile.StoreUint32(&o.RXIMR4.Reg, volatile.LoadUint32(&o.RXIMR4.Reg)&^(0x200000)|value<<21)
}
func (o *CAN0_Type) GetRXIMR4_MI21() uint32 {
	return (volatile.LoadUint32(&o.RXIMR4.Reg) & 0x200000) >> 21
}
func (o *CAN0_Type) SetRXIMR4_MI22(value uint32) {
	volatile.StoreUint32(&o.RXIMR4.Reg, volatile.LoadUint32(&o.RXIMR4.Reg)&^(0x400000)|value<<22)
}
func (o *CAN0_Type) GetRXIMR4_MI22() uint32 {
	return (volatile.LoadUint32(&o.RXIMR4.Reg) & 0x400000) >> 22
}
func (o *CAN0_Type) SetRXIMR4_MI23(value uint32) {
	volatile.StoreUint32(&o.RXIMR4.Reg, volatile.LoadUint32(&o.RXIMR4.Reg)&^(0x800000)|value<<23)
}
func (o *CAN0_Type) GetRXIMR4_MI23() uint32 {
	return (volatile.LoadUint32(&o.RXIMR4.Reg) & 0x800000) >> 23
}
func (o *CAN0_Type) SetRXIMR4_MI24(value uint32) {
	volatile.StoreUint32(&o.RXIMR4.Reg, volatile.LoadUint32(&o.RXIMR4.Reg)&^(0x1000000)|value<<24)
}
func (o *CAN0_Type) GetRXIMR4_MI24() uint32 {
	return (volatile.LoadUint32(&o.RXIMR4.Reg) & 0x1000000) >> 24
}
func (o *CAN0_Type) SetRXIMR4_MI25(value uint32) {
	volatile.StoreUint32(&o.RXIMR4.Reg, volatile.LoadUint32(&o.RXIMR4.Reg)&^(0x2000000)|value<<25)
}
func (o *CAN0_Type) GetRXIMR4_MI25() uint32 {
	return (volatile.LoadUint32(&o.RXIMR4.Reg) & 0x2000000) >> 25
}
func (o *CAN0_Type) SetRXIMR4_MI26(value uint32) {
	volatile.StoreUint32(&o.RXIMR4.Reg, volatile.LoadUint32(&o.RXIMR4.Reg)&^(0x4000000)|value<<26)
}
func (o *CAN0_Type) GetRXIMR4_MI26() uint32 {
	return (volatile.LoadUint32(&o.RXIMR4.Reg) & 0x4000000) >> 26
}
func (o *CAN0_Type) SetRXIMR4_MI27(value uint32) {
	volatile.StoreUint32(&o.RXIMR4.Reg, volatile.LoadUint32(&o.RXIMR4.Reg)&^(0x8000000)|value<<27)
}
func (o *CAN0_Type) GetRXIMR4_MI27() uint32 {
	return (volatile.LoadUint32(&o.RXIMR4.Reg) & 0x8000000) >> 27
}
func (o *CAN0_Type) SetRXIMR4_MI28(value uint32) {
	volatile.StoreUint32(&o.RXIMR4.Reg, volatile.LoadUint32(&o.RXIMR4.Reg)&^(0x10000000)|value<<28)
}
func (o *CAN0_Type) GetRXIMR4_MI28() uint32 {
	return (volatile.LoadUint32(&o.RXIMR4.Reg) & 0x10000000) >> 28
}
func (o *CAN0_Type) SetRXIMR4_MI29(value uint32) {
	volatile.StoreUint32(&o.RXIMR4.Reg, volatile.LoadUint32(&o.RXIMR4.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetRXIMR4_MI29() uint32 {
	return (volatile.LoadUint32(&o.RXIMR4.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetRXIMR4_MI30(value uint32) {
	volatile.StoreUint32(&o.RXIMR4.Reg, volatile.LoadUint32(&o.RXIMR4.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetRXIMR4_MI30() uint32 {
	return (volatile.LoadUint32(&o.RXIMR4.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetRXIMR4_MI31(value uint32) {
	volatile.StoreUint32(&o.RXIMR4.Reg, volatile.LoadUint32(&o.RXIMR4.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetRXIMR4_MI31() uint32 {
	return (volatile.LoadUint32(&o.RXIMR4.Reg) & 0x80000000) >> 31
}

// CAN0.RXIMR5: Rx Individual Mask Registers
func (o *CAN0_Type) SetRXIMR5_MI0(value uint32) {
	volatile.StoreUint32(&o.RXIMR5.Reg, volatile.LoadUint32(&o.RXIMR5.Reg)&^(0x1)|value)
}
func (o *CAN0_Type) GetRXIMR5_MI0() uint32 {
	return volatile.LoadUint32(&o.RXIMR5.Reg) & 0x1
}
func (o *CAN0_Type) SetRXIMR5_MI1(value uint32) {
	volatile.StoreUint32(&o.RXIMR5.Reg, volatile.LoadUint32(&o.RXIMR5.Reg)&^(0x2)|value<<1)
}
func (o *CAN0_Type) GetRXIMR5_MI1() uint32 {
	return (volatile.LoadUint32(&o.RXIMR5.Reg) & 0x2) >> 1
}
func (o *CAN0_Type) SetRXIMR5_MI2(value uint32) {
	volatile.StoreUint32(&o.RXIMR5.Reg, volatile.LoadUint32(&o.RXIMR5.Reg)&^(0x4)|value<<2)
}
func (o *CAN0_Type) GetRXIMR5_MI2() uint32 {
	return (volatile.LoadUint32(&o.RXIMR5.Reg) & 0x4) >> 2
}
func (o *CAN0_Type) SetRXIMR5_MI3(value uint32) {
	volatile.StoreUint32(&o.RXIMR5.Reg, volatile.LoadUint32(&o.RXIMR5.Reg)&^(0x8)|value<<3)
}
func (o *CAN0_Type) GetRXIMR5_MI3() uint32 {
	return (volatile.LoadUint32(&o.RXIMR5.Reg) & 0x8) >> 3
}
func (o *CAN0_Type) SetRXIMR5_MI4(value uint32) {
	volatile.StoreUint32(&o.RXIMR5.Reg, volatile.LoadUint32(&o.RXIMR5.Reg)&^(0x10)|value<<4)
}
func (o *CAN0_Type) GetRXIMR5_MI4() uint32 {
	return (volatile.LoadUint32(&o.RXIMR5.Reg) & 0x10) >> 4
}
func (o *CAN0_Type) SetRXIMR5_MI5(value uint32) {
	volatile.StoreUint32(&o.RXIMR5.Reg, volatile.LoadUint32(&o.RXIMR5.Reg)&^(0x20)|value<<5)
}
func (o *CAN0_Type) GetRXIMR5_MI5() uint32 {
	return (volatile.LoadUint32(&o.RXIMR5.Reg) & 0x20) >> 5
}
func (o *CAN0_Type) SetRXIMR5_MI6(value uint32) {
	volatile.StoreUint32(&o.RXIMR5.Reg, volatile.LoadUint32(&o.RXIMR5.Reg)&^(0x40)|value<<6)
}
func (o *CAN0_Type) GetRXIMR5_MI6() uint32 {
	return (volatile.LoadUint32(&o.RXIMR5.Reg) & 0x40) >> 6
}
func (o *CAN0_Type) SetRXIMR5_MI7(value uint32) {
	volatile.StoreUint32(&o.RXIMR5.Reg, volatile.LoadUint32(&o.RXIMR5.Reg)&^(0x80)|value<<7)
}
func (o *CAN0_Type) GetRXIMR5_MI7() uint32 {
	return (volatile.LoadUint32(&o.RXIMR5.Reg) & 0x80) >> 7
}
func (o *CAN0_Type) SetRXIMR5_MI8(value uint32) {
	volatile.StoreUint32(&o.RXIMR5.Reg, volatile.LoadUint32(&o.RXIMR5.Reg)&^(0x100)|value<<8)
}
func (o *CAN0_Type) GetRXIMR5_MI8() uint32 {
	return (volatile.LoadUint32(&o.RXIMR5.Reg) & 0x100) >> 8
}
func (o *CAN0_Type) SetRXIMR5_MI9(value uint32) {
	volatile.StoreUint32(&o.RXIMR5.Reg, volatile.LoadUint32(&o.RXIMR5.Reg)&^(0x200)|value<<9)
}
func (o *CAN0_Type) GetRXIMR5_MI9() uint32 {
	return (volatile.LoadUint32(&o.RXIMR5.Reg) & 0x200) >> 9
}
func (o *CAN0_Type) SetRXIMR5_MI10(value uint32) {
	volatile.StoreUint32(&o.RXIMR5.Reg, volatile.LoadUint32(&o.RXIMR5.Reg)&^(0x400)|value<<10)
}
func (o *CAN0_Type) GetRXIMR5_MI10() uint32 {
	return (volatile.LoadUint32(&o.RXIMR5.Reg) & 0x400) >> 10
}
func (o *CAN0_Type) SetRXIMR5_MI11(value uint32) {
	volatile.StoreUint32(&o.RXIMR5.Reg, volatile.LoadUint32(&o.RXIMR5.Reg)&^(0x800)|value<<11)
}
func (o *CAN0_Type) GetRXIMR5_MI11() uint32 {
	return (volatile.LoadUint32(&o.RXIMR5.Reg) & 0x800) >> 11
}
func (o *CAN0_Type) SetRXIMR5_MI12(value uint32) {
	volatile.StoreUint32(&o.RXIMR5.Reg, volatile.LoadUint32(&o.RXIMR5.Reg)&^(0x1000)|value<<12)
}
func (o *CAN0_Type) GetRXIMR5_MI12() uint32 {
	return (volatile.LoadUint32(&o.RXIMR5.Reg) & 0x1000) >> 12
}
func (o *CAN0_Type) SetRXIMR5_MI13(value uint32) {
	volatile.StoreUint32(&o.RXIMR5.Reg, volatile.LoadUint32(&o.RXIMR5.Reg)&^(0x2000)|value<<13)
}
func (o *CAN0_Type) GetRXIMR5_MI13() uint32 {
	return (volatile.LoadUint32(&o.RXIMR5.Reg) & 0x2000) >> 13
}
func (o *CAN0_Type) SetRXIMR5_MI14(value uint32) {
	volatile.StoreUint32(&o.RXIMR5.Reg, volatile.LoadUint32(&o.RXIMR5.Reg)&^(0x4000)|value<<14)
}
func (o *CAN0_Type) GetRXIMR5_MI14() uint32 {
	return (volatile.LoadUint32(&o.RXIMR5.Reg) & 0x4000) >> 14
}
func (o *CAN0_Type) SetRXIMR5_MI15(value uint32) {
	volatile.StoreUint32(&o.RXIMR5.Reg, volatile.LoadUint32(&o.RXIMR5.Reg)&^(0x8000)|value<<15)
}
func (o *CAN0_Type) GetRXIMR5_MI15() uint32 {
	return (volatile.LoadUint32(&o.RXIMR5.Reg) & 0x8000) >> 15
}
func (o *CAN0_Type) SetRXIMR5_MI16(value uint32) {
	volatile.StoreUint32(&o.RXIMR5.Reg, volatile.LoadUint32(&o.RXIMR5.Reg)&^(0x10000)|value<<16)
}
func (o *CAN0_Type) GetRXIMR5_MI16() uint32 {
	return (volatile.LoadUint32(&o.RXIMR5.Reg) & 0x10000) >> 16
}
func (o *CAN0_Type) SetRXIMR5_MI17(value uint32) {
	volatile.StoreUint32(&o.RXIMR5.Reg, volatile.LoadUint32(&o.RXIMR5.Reg)&^(0x20000)|value<<17)
}
func (o *CAN0_Type) GetRXIMR5_MI17() uint32 {
	return (volatile.LoadUint32(&o.RXIMR5.Reg) & 0x20000) >> 17
}
func (o *CAN0_Type) SetRXIMR5_MI18(value uint32) {
	volatile.StoreUint32(&o.RXIMR5.Reg, volatile.LoadUint32(&o.RXIMR5.Reg)&^(0x40000)|value<<18)
}
func (o *CAN0_Type) GetRXIMR5_MI18() uint32 {
	return (volatile.LoadUint32(&o.RXIMR5.Reg) & 0x40000) >> 18
}
func (o *CAN0_Type) SetRXIMR5_MI19(value uint32) {
	volatile.StoreUint32(&o.RXIMR5.Reg, volatile.LoadUint32(&o.RXIMR5.Reg)&^(0x80000)|value<<19)
}
func (o *CAN0_Type) GetRXIMR5_MI19() uint32 {
	return (volatile.LoadUint32(&o.RXIMR5.Reg) & 0x80000) >> 19
}
func (o *CAN0_Type) SetRXIMR5_MI20(value uint32) {
	volatile.StoreUint32(&o.RXIMR5.Reg, volatile.LoadUint32(&o.RXIMR5.Reg)&^(0x100000)|value<<20)
}
func (o *CAN0_Type) GetRXIMR5_MI20() uint32 {
	return (volatile.LoadUint32(&o.RXIMR5.Reg) & 0x100000) >> 20
}
func (o *CAN0_Type) SetRXIMR5_MI21(value uint32) {
	volatile.StoreUint32(&o.RXIMR5.Reg, volatile.LoadUint32(&o.RXIMR5.Reg)&^(0x200000)|value<<21)
}
func (o *CAN0_Type) GetRXIMR5_MI21() uint32 {
	return (volatile.LoadUint32(&o.RXIMR5.Reg) & 0x200000) >> 21
}
func (o *CAN0_Type) SetRXIMR5_MI22(value uint32) {
	volatile.StoreUint32(&o.RXIMR5.Reg, volatile.LoadUint32(&o.RXIMR5.Reg)&^(0x400000)|value<<22)
}
func (o *CAN0_Type) GetRXIMR5_MI22() uint32 {
	return (volatile.LoadUint32(&o.RXIMR5.Reg) & 0x400000) >> 22
}
func (o *CAN0_Type) SetRXIMR5_MI23(value uint32) {
	volatile.StoreUint32(&o.RXIMR5.Reg, volatile.LoadUint32(&o.RXIMR5.Reg)&^(0x800000)|value<<23)
}
func (o *CAN0_Type) GetRXIMR5_MI23() uint32 {
	return (volatile.LoadUint32(&o.RXIMR5.Reg) & 0x800000) >> 23
}
func (o *CAN0_Type) SetRXIMR5_MI24(value uint32) {
	volatile.StoreUint32(&o.RXIMR5.Reg, volatile.LoadUint32(&o.RXIMR5.Reg)&^(0x1000000)|value<<24)
}
func (o *CAN0_Type) GetRXIMR5_MI24() uint32 {
	return (volatile.LoadUint32(&o.RXIMR5.Reg) & 0x1000000) >> 24
}
func (o *CAN0_Type) SetRXIMR5_MI25(value uint32) {
	volatile.StoreUint32(&o.RXIMR5.Reg, volatile.LoadUint32(&o.RXIMR5.Reg)&^(0x2000000)|value<<25)
}
func (o *CAN0_Type) GetRXIMR5_MI25() uint32 {
	return (volatile.LoadUint32(&o.RXIMR5.Reg) & 0x2000000) >> 25
}
func (o *CAN0_Type) SetRXIMR5_MI26(value uint32) {
	volatile.StoreUint32(&o.RXIMR5.Reg, volatile.LoadUint32(&o.RXIMR5.Reg)&^(0x4000000)|value<<26)
}
func (o *CAN0_Type) GetRXIMR5_MI26() uint32 {
	return (volatile.LoadUint32(&o.RXIMR5.Reg) & 0x4000000) >> 26
}
func (o *CAN0_Type) SetRXIMR5_MI27(value uint32) {
	volatile.StoreUint32(&o.RXIMR5.Reg, volatile.LoadUint32(&o.RXIMR5.Reg)&^(0x8000000)|value<<27)
}
func (o *CAN0_Type) GetRXIMR5_MI27() uint32 {
	return (volatile.LoadUint32(&o.RXIMR5.Reg) & 0x8000000) >> 27
}
func (o *CAN0_Type) SetRXIMR5_MI28(value uint32) {
	volatile.StoreUint32(&o.RXIMR5.Reg, volatile.LoadUint32(&o.RXIMR5.Reg)&^(0x10000000)|value<<28)
}
func (o *CAN0_Type) GetRXIMR5_MI28() uint32 {
	return (volatile.LoadUint32(&o.RXIMR5.Reg) & 0x10000000) >> 28
}
func (o *CAN0_Type) SetRXIMR5_MI29(value uint32) {
	volatile.StoreUint32(&o.RXIMR5.Reg, volatile.LoadUint32(&o.RXIMR5.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetRXIMR5_MI29() uint32 {
	return (volatile.LoadUint32(&o.RXIMR5.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetRXIMR5_MI30(value uint32) {
	volatile.StoreUint32(&o.RXIMR5.Reg, volatile.LoadUint32(&o.RXIMR5.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetRXIMR5_MI30() uint32 {
	return (volatile.LoadUint32(&o.RXIMR5.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetRXIMR5_MI31(value uint32) {
	volatile.StoreUint32(&o.RXIMR5.Reg, volatile.LoadUint32(&o.RXIMR5.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetRXIMR5_MI31() uint32 {
	return (volatile.LoadUint32(&o.RXIMR5.Reg) & 0x80000000) >> 31
}

// CAN0.RXIMR6: Rx Individual Mask Registers
func (o *CAN0_Type) SetRXIMR6_MI0(value uint32) {
	volatile.StoreUint32(&o.RXIMR6.Reg, volatile.LoadUint32(&o.RXIMR6.Reg)&^(0x1)|value)
}
func (o *CAN0_Type) GetRXIMR6_MI0() uint32 {
	return volatile.LoadUint32(&o.RXIMR6.Reg) & 0x1
}
func (o *CAN0_Type) SetRXIMR6_MI1(value uint32) {
	volatile.StoreUint32(&o.RXIMR6.Reg, volatile.LoadUint32(&o.RXIMR6.Reg)&^(0x2)|value<<1)
}
func (o *CAN0_Type) GetRXIMR6_MI1() uint32 {
	return (volatile.LoadUint32(&o.RXIMR6.Reg) & 0x2) >> 1
}
func (o *CAN0_Type) SetRXIMR6_MI2(value uint32) {
	volatile.StoreUint32(&o.RXIMR6.Reg, volatile.LoadUint32(&o.RXIMR6.Reg)&^(0x4)|value<<2)
}
func (o *CAN0_Type) GetRXIMR6_MI2() uint32 {
	return (volatile.LoadUint32(&o.RXIMR6.Reg) & 0x4) >> 2
}
func (o *CAN0_Type) SetRXIMR6_MI3(value uint32) {
	volatile.StoreUint32(&o.RXIMR6.Reg, volatile.LoadUint32(&o.RXIMR6.Reg)&^(0x8)|value<<3)
}
func (o *CAN0_Type) GetRXIMR6_MI3() uint32 {
	return (volatile.LoadUint32(&o.RXIMR6.Reg) & 0x8) >> 3
}
func (o *CAN0_Type) SetRXIMR6_MI4(value uint32) {
	volatile.StoreUint32(&o.RXIMR6.Reg, volatile.LoadUint32(&o.RXIMR6.Reg)&^(0x10)|value<<4)
}
func (o *CAN0_Type) GetRXIMR6_MI4() uint32 {
	return (volatile.LoadUint32(&o.RXIMR6.Reg) & 0x10) >> 4
}
func (o *CAN0_Type) SetRXIMR6_MI5(value uint32) {
	volatile.StoreUint32(&o.RXIMR6.Reg, volatile.LoadUint32(&o.RXIMR6.Reg)&^(0x20)|value<<5)
}
func (o *CAN0_Type) GetRXIMR6_MI5() uint32 {
	return (volatile.LoadUint32(&o.RXIMR6.Reg) & 0x20) >> 5
}
func (o *CAN0_Type) SetRXIMR6_MI6(value uint32) {
	volatile.StoreUint32(&o.RXIMR6.Reg, volatile.LoadUint32(&o.RXIMR6.Reg)&^(0x40)|value<<6)
}
func (o *CAN0_Type) GetRXIMR6_MI6() uint32 {
	return (volatile.LoadUint32(&o.RXIMR6.Reg) & 0x40) >> 6
}
func (o *CAN0_Type) SetRXIMR6_MI7(value uint32) {
	volatile.StoreUint32(&o.RXIMR6.Reg, volatile.LoadUint32(&o.RXIMR6.Reg)&^(0x80)|value<<7)
}
func (o *CAN0_Type) GetRXIMR6_MI7() uint32 {
	return (volatile.LoadUint32(&o.RXIMR6.Reg) & 0x80) >> 7
}
func (o *CAN0_Type) SetRXIMR6_MI8(value uint32) {
	volatile.StoreUint32(&o.RXIMR6.Reg, volatile.LoadUint32(&o.RXIMR6.Reg)&^(0x100)|value<<8)
}
func (o *CAN0_Type) GetRXIMR6_MI8() uint32 {
	return (volatile.LoadUint32(&o.RXIMR6.Reg) & 0x100) >> 8
}
func (o *CAN0_Type) SetRXIMR6_MI9(value uint32) {
	volatile.StoreUint32(&o.RXIMR6.Reg, volatile.LoadUint32(&o.RXIMR6.Reg)&^(0x200)|value<<9)
}
func (o *CAN0_Type) GetRXIMR6_MI9() uint32 {
	return (volatile.LoadUint32(&o.RXIMR6.Reg) & 0x200) >> 9
}
func (o *CAN0_Type) SetRXIMR6_MI10(value uint32) {
	volatile.StoreUint32(&o.RXIMR6.Reg, volatile.LoadUint32(&o.RXIMR6.Reg)&^(0x400)|value<<10)
}
func (o *CAN0_Type) GetRXIMR6_MI10() uint32 {
	return (volatile.LoadUint32(&o.RXIMR6.Reg) & 0x400) >> 10
}
func (o *CAN0_Type) SetRXIMR6_MI11(value uint32) {
	volatile.StoreUint32(&o.RXIMR6.Reg, volatile.LoadUint32(&o.RXIMR6.Reg)&^(0x800)|value<<11)
}
func (o *CAN0_Type) GetRXIMR6_MI11() uint32 {
	return (volatile.LoadUint32(&o.RXIMR6.Reg) & 0x800) >> 11
}
func (o *CAN0_Type) SetRXIMR6_MI12(value uint32) {
	volatile.StoreUint32(&o.RXIMR6.Reg, volatile.LoadUint32(&o.RXIMR6.Reg)&^(0x1000)|value<<12)
}
func (o *CAN0_Type) GetRXIMR6_MI12() uint32 {
	return (volatile.LoadUint32(&o.RXIMR6.Reg) & 0x1000) >> 12
}
func (o *CAN0_Type) SetRXIMR6_MI13(value uint32) {
	volatile.StoreUint32(&o.RXIMR6.Reg, volatile.LoadUint32(&o.RXIMR6.Reg)&^(0x2000)|value<<13)
}
func (o *CAN0_Type) GetRXIMR6_MI13() uint32 {
	return (volatile.LoadUint32(&o.RXIMR6.Reg) & 0x2000) >> 13
}
func (o *CAN0_Type) SetRXIMR6_MI14(value uint32) {
	volatile.StoreUint32(&o.RXIMR6.Reg, volatile.LoadUint32(&o.RXIMR6.Reg)&^(0x4000)|value<<14)
}
func (o *CAN0_Type) GetRXIMR6_MI14() uint32 {
	return (volatile.LoadUint32(&o.RXIMR6.Reg) & 0x4000) >> 14
}
func (o *CAN0_Type) SetRXIMR6_MI15(value uint32) {
	volatile.StoreUint32(&o.RXIMR6.Reg, volatile.LoadUint32(&o.RXIMR6.Reg)&^(0x8000)|value<<15)
}
func (o *CAN0_Type) GetRXIMR6_MI15() uint32 {
	return (volatile.LoadUint32(&o.RXIMR6.Reg) & 0x8000) >> 15
}
func (o *CAN0_Type) SetRXIMR6_MI16(value uint32) {
	volatile.StoreUint32(&o.RXIMR6.Reg, volatile.LoadUint32(&o.RXIMR6.Reg)&^(0x10000)|value<<16)
}
func (o *CAN0_Type) GetRXIMR6_MI16() uint32 {
	return (volatile.LoadUint32(&o.RXIMR6.Reg) & 0x10000) >> 16
}
func (o *CAN0_Type) SetRXIMR6_MI17(value uint32) {
	volatile.StoreUint32(&o.RXIMR6.Reg, volatile.LoadUint32(&o.RXIMR6.Reg)&^(0x20000)|value<<17)
}
func (o *CAN0_Type) GetRXIMR6_MI17() uint32 {
	return (volatile.LoadUint32(&o.RXIMR6.Reg) & 0x20000) >> 17
}
func (o *CAN0_Type) SetRXIMR6_MI18(value uint32) {
	volatile.StoreUint32(&o.RXIMR6.Reg, volatile.LoadUint32(&o.RXIMR6.Reg)&^(0x40000)|value<<18)
}
func (o *CAN0_Type) GetRXIMR6_MI18() uint32 {
	return (volatile.LoadUint32(&o.RXIMR6.Reg) & 0x40000) >> 18
}
func (o *CAN0_Type) SetRXIMR6_MI19(value uint32) {
	volatile.StoreUint32(&o.RXIMR6.Reg, volatile.LoadUint32(&o.RXIMR6.Reg)&^(0x80000)|value<<19)
}
func (o *CAN0_Type) GetRXIMR6_MI19() uint32 {
	return (volatile.LoadUint32(&o.RXIMR6.Reg) & 0x80000) >> 19
}
func (o *CAN0_Type) SetRXIMR6_MI20(value uint32) {
	volatile.StoreUint32(&o.RXIMR6.Reg, volatile.LoadUint32(&o.RXIMR6.Reg)&^(0x100000)|value<<20)
}
func (o *CAN0_Type) GetRXIMR6_MI20() uint32 {
	return (volatile.LoadUint32(&o.RXIMR6.Reg) & 0x100000) >> 20
}
func (o *CAN0_Type) SetRXIMR6_MI21(value uint32) {
	volatile.StoreUint32(&o.RXIMR6.Reg, volatile.LoadUint32(&o.RXIMR6.Reg)&^(0x200000)|value<<21)
}
func (o *CAN0_Type) GetRXIMR6_MI21() uint32 {
	return (volatile.LoadUint32(&o.RXIMR6.Reg) & 0x200000) >> 21
}
func (o *CAN0_Type) SetRXIMR6_MI22(value uint32) {
	volatile.StoreUint32(&o.RXIMR6.Reg, volatile.LoadUint32(&o.RXIMR6.Reg)&^(0x400000)|value<<22)
}
func (o *CAN0_Type) GetRXIMR6_MI22() uint32 {
	return (volatile.LoadUint32(&o.RXIMR6.Reg) & 0x400000) >> 22
}
func (o *CAN0_Type) SetRXIMR6_MI23(value uint32) {
	volatile.StoreUint32(&o.RXIMR6.Reg, volatile.LoadUint32(&o.RXIMR6.Reg)&^(0x800000)|value<<23)
}
func (o *CAN0_Type) GetRXIMR6_MI23() uint32 {
	return (volatile.LoadUint32(&o.RXIMR6.Reg) & 0x800000) >> 23
}
func (o *CAN0_Type) SetRXIMR6_MI24(value uint32) {
	volatile.StoreUint32(&o.RXIMR6.Reg, volatile.LoadUint32(&o.RXIMR6.Reg)&^(0x1000000)|value<<24)
}
func (o *CAN0_Type) GetRXIMR6_MI24() uint32 {
	return (volatile.LoadUint32(&o.RXIMR6.Reg) & 0x1000000) >> 24
}
func (o *CAN0_Type) SetRXIMR6_MI25(value uint32) {
	volatile.StoreUint32(&o.RXIMR6.Reg, volatile.LoadUint32(&o.RXIMR6.Reg)&^(0x2000000)|value<<25)
}
func (o *CAN0_Type) GetRXIMR6_MI25() uint32 {
	return (volatile.LoadUint32(&o.RXIMR6.Reg) & 0x2000000) >> 25
}
func (o *CAN0_Type) SetRXIMR6_MI26(value uint32) {
	volatile.StoreUint32(&o.RXIMR6.Reg, volatile.LoadUint32(&o.RXIMR6.Reg)&^(0x4000000)|value<<26)
}
func (o *CAN0_Type) GetRXIMR6_MI26() uint32 {
	return (volatile.LoadUint32(&o.RXIMR6.Reg) & 0x4000000) >> 26
}
func (o *CAN0_Type) SetRXIMR6_MI27(value uint32) {
	volatile.StoreUint32(&o.RXIMR6.Reg, volatile.LoadUint32(&o.RXIMR6.Reg)&^(0x8000000)|value<<27)
}
func (o *CAN0_Type) GetRXIMR6_MI27() uint32 {
	return (volatile.LoadUint32(&o.RXIMR6.Reg) & 0x8000000) >> 27
}
func (o *CAN0_Type) SetRXIMR6_MI28(value uint32) {
	volatile.StoreUint32(&o.RXIMR6.Reg, volatile.LoadUint32(&o.RXIMR6.Reg)&^(0x10000000)|value<<28)
}
func (o *CAN0_Type) GetRXIMR6_MI28() uint32 {
	return (volatile.LoadUint32(&o.RXIMR6.Reg) & 0x10000000) >> 28
}
func (o *CAN0_Type) SetRXIMR6_MI29(value uint32) {
	volatile.StoreUint32(&o.RXIMR6.Reg, volatile.LoadUint32(&o.RXIMR6.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetRXIMR6_MI29() uint32 {
	return (volatile.LoadUint32(&o.RXIMR6.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetRXIMR6_MI30(value uint32) {
	volatile.StoreUint32(&o.RXIMR6.Reg, volatile.LoadUint32(&o.RXIMR6.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetRXIMR6_MI30() uint32 {
	return (volatile.LoadUint32(&o.RXIMR6.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetRXIMR6_MI31(value uint32) {
	volatile.StoreUint32(&o.RXIMR6.Reg, volatile.LoadUint32(&o.RXIMR6.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetRXIMR6_MI31() uint32 {
	return (volatile.LoadUint32(&o.RXIMR6.Reg) & 0x80000000) >> 31
}

// CAN0.RXIMR7: Rx Individual Mask Registers
func (o *CAN0_Type) SetRXIMR7_MI0(value uint32) {
	volatile.StoreUint32(&o.RXIMR7.Reg, volatile.LoadUint32(&o.RXIMR7.Reg)&^(0x1)|value)
}
func (o *CAN0_Type) GetRXIMR7_MI0() uint32 {
	return volatile.LoadUint32(&o.RXIMR7.Reg) & 0x1
}
func (o *CAN0_Type) SetRXIMR7_MI1(value uint32) {
	volatile.StoreUint32(&o.RXIMR7.Reg, volatile.LoadUint32(&o.RXIMR7.Reg)&^(0x2)|value<<1)
}
func (o *CAN0_Type) GetRXIMR7_MI1() uint32 {
	return (volatile.LoadUint32(&o.RXIMR7.Reg) & 0x2) >> 1
}
func (o *CAN0_Type) SetRXIMR7_MI2(value uint32) {
	volatile.StoreUint32(&o.RXIMR7.Reg, volatile.LoadUint32(&o.RXIMR7.Reg)&^(0x4)|value<<2)
}
func (o *CAN0_Type) GetRXIMR7_MI2() uint32 {
	return (volatile.LoadUint32(&o.RXIMR7.Reg) & 0x4) >> 2
}
func (o *CAN0_Type) SetRXIMR7_MI3(value uint32) {
	volatile.StoreUint32(&o.RXIMR7.Reg, volatile.LoadUint32(&o.RXIMR7.Reg)&^(0x8)|value<<3)
}
func (o *CAN0_Type) GetRXIMR7_MI3() uint32 {
	return (volatile.LoadUint32(&o.RXIMR7.Reg) & 0x8) >> 3
}
func (o *CAN0_Type) SetRXIMR7_MI4(value uint32) {
	volatile.StoreUint32(&o.RXIMR7.Reg, volatile.LoadUint32(&o.RXIMR7.Reg)&^(0x10)|value<<4)
}
func (o *CAN0_Type) GetRXIMR7_MI4() uint32 {
	return (volatile.LoadUint32(&o.RXIMR7.Reg) & 0x10) >> 4
}
func (o *CAN0_Type) SetRXIMR7_MI5(value uint32) {
	volatile.StoreUint32(&o.RXIMR7.Reg, volatile.LoadUint32(&o.RXIMR7.Reg)&^(0x20)|value<<5)
}
func (o *CAN0_Type) GetRXIMR7_MI5() uint32 {
	return (volatile.LoadUint32(&o.RXIMR7.Reg) & 0x20) >> 5
}
func (o *CAN0_Type) SetRXIMR7_MI6(value uint32) {
	volatile.StoreUint32(&o.RXIMR7.Reg, volatile.LoadUint32(&o.RXIMR7.Reg)&^(0x40)|value<<6)
}
func (o *CAN0_Type) GetRXIMR7_MI6() uint32 {
	return (volatile.LoadUint32(&o.RXIMR7.Reg) & 0x40) >> 6
}
func (o *CAN0_Type) SetRXIMR7_MI7(value uint32) {
	volatile.StoreUint32(&o.RXIMR7.Reg, volatile.LoadUint32(&o.RXIMR7.Reg)&^(0x80)|value<<7)
}
func (o *CAN0_Type) GetRXIMR7_MI7() uint32 {
	return (volatile.LoadUint32(&o.RXIMR7.Reg) & 0x80) >> 7
}
func (o *CAN0_Type) SetRXIMR7_MI8(value uint32) {
	volatile.StoreUint32(&o.RXIMR7.Reg, volatile.LoadUint32(&o.RXIMR7.Reg)&^(0x100)|value<<8)
}
func (o *CAN0_Type) GetRXIMR7_MI8() uint32 {
	return (volatile.LoadUint32(&o.RXIMR7.Reg) & 0x100) >> 8
}
func (o *CAN0_Type) SetRXIMR7_MI9(value uint32) {
	volatile.StoreUint32(&o.RXIMR7.Reg, volatile.LoadUint32(&o.RXIMR7.Reg)&^(0x200)|value<<9)
}
func (o *CAN0_Type) GetRXIMR7_MI9() uint32 {
	return (volatile.LoadUint32(&o.RXIMR7.Reg) & 0x200) >> 9
}
func (o *CAN0_Type) SetRXIMR7_MI10(value uint32) {
	volatile.StoreUint32(&o.RXIMR7.Reg, volatile.LoadUint32(&o.RXIMR7.Reg)&^(0x400)|value<<10)
}
func (o *CAN0_Type) GetRXIMR7_MI10() uint32 {
	return (volatile.LoadUint32(&o.RXIMR7.Reg) & 0x400) >> 10
}
func (o *CAN0_Type) SetRXIMR7_MI11(value uint32) {
	volatile.StoreUint32(&o.RXIMR7.Reg, volatile.LoadUint32(&o.RXIMR7.Reg)&^(0x800)|value<<11)
}
func (o *CAN0_Type) GetRXIMR7_MI11() uint32 {
	return (volatile.LoadUint32(&o.RXIMR7.Reg) & 0x800) >> 11
}
func (o *CAN0_Type) SetRXIMR7_MI12(value uint32) {
	volatile.StoreUint32(&o.RXIMR7.Reg, volatile.LoadUint32(&o.RXIMR7.Reg)&^(0x1000)|value<<12)
}
func (o *CAN0_Type) GetRXIMR7_MI12() uint32 {
	return (volatile.LoadUint32(&o.RXIMR7.Reg) & 0x1000) >> 12
}
func (o *CAN0_Type) SetRXIMR7_MI13(value uint32) {
	volatile.StoreUint32(&o.RXIMR7.Reg, volatile.LoadUint32(&o.RXIMR7.Reg)&^(0x2000)|value<<13)
}
func (o *CAN0_Type) GetRXIMR7_MI13() uint32 {
	return (volatile.LoadUint32(&o.RXIMR7.Reg) & 0x2000) >> 13
}
func (o *CAN0_Type) SetRXIMR7_MI14(value uint32) {
	volatile.StoreUint32(&o.RXIMR7.Reg, volatile.LoadUint32(&o.RXIMR7.Reg)&^(0x4000)|value<<14)
}
func (o *CAN0_Type) GetRXIMR7_MI14() uint32 {
	return (volatile.LoadUint32(&o.RXIMR7.Reg) & 0x4000) >> 14
}
func (o *CAN0_Type) SetRXIMR7_MI15(value uint32) {
	volatile.StoreUint32(&o.RXIMR7.Reg, volatile.LoadUint32(&o.RXIMR7.Reg)&^(0x8000)|value<<15)
}
func (o *CAN0_Type) GetRXIMR7_MI15() uint32 {
	return (volatile.LoadUint32(&o.RXIMR7.Reg) & 0x8000) >> 15
}
func (o *CAN0_Type) SetRXIMR7_MI16(value uint32) {
	volatile.StoreUint32(&o.RXIMR7.Reg, volatile.LoadUint32(&o.RXIMR7.Reg)&^(0x10000)|value<<16)
}
func (o *CAN0_Type) GetRXIMR7_MI16() uint32 {
	return (volatile.LoadUint32(&o.RXIMR7.Reg) & 0x10000) >> 16
}
func (o *CAN0_Type) SetRXIMR7_MI17(value uint32) {
	volatile.StoreUint32(&o.RXIMR7.Reg, volatile.LoadUint32(&o.RXIMR7.Reg)&^(0x20000)|value<<17)
}
func (o *CAN0_Type) GetRXIMR7_MI17() uint32 {
	return (volatile.LoadUint32(&o.RXIMR7.Reg) & 0x20000) >> 17
}
func (o *CAN0_Type) SetRXIMR7_MI18(value uint32) {
	volatile.StoreUint32(&o.RXIMR7.Reg, volatile.LoadUint32(&o.RXIMR7.Reg)&^(0x40000)|value<<18)
}
func (o *CAN0_Type) GetRXIMR7_MI18() uint32 {
	return (volatile.LoadUint32(&o.RXIMR7.Reg) & 0x40000) >> 18
}
func (o *CAN0_Type) SetRXIMR7_MI19(value uint32) {
	volatile.StoreUint32(&o.RXIMR7.Reg, volatile.LoadUint32(&o.RXIMR7.Reg)&^(0x80000)|value<<19)
}
func (o *CAN0_Type) GetRXIMR7_MI19() uint32 {
	return (volatile.LoadUint32(&o.RXIMR7.Reg) & 0x80000) >> 19
}
func (o *CAN0_Type) SetRXIMR7_MI20(value uint32) {
	volatile.StoreUint32(&o.RXIMR7.Reg, volatile.LoadUint32(&o.RXIMR7.Reg)&^(0x100000)|value<<20)
}
func (o *CAN0_Type) GetRXIMR7_MI20() uint32 {
	return (volatile.LoadUint32(&o.RXIMR7.Reg) & 0x100000) >> 20
}
func (o *CAN0_Type) SetRXIMR7_MI21(value uint32) {
	volatile.StoreUint32(&o.RXIMR7.Reg, volatile.LoadUint32(&o.RXIMR7.Reg)&^(0x200000)|value<<21)
}
func (o *CAN0_Type) GetRXIMR7_MI21() uint32 {
	return (volatile.LoadUint32(&o.RXIMR7.Reg) & 0x200000) >> 21
}
func (o *CAN0_Type) SetRXIMR7_MI22(value uint32) {
	volatile.StoreUint32(&o.RXIMR7.Reg, volatile.LoadUint32(&o.RXIMR7.Reg)&^(0x400000)|value<<22)
}
func (o *CAN0_Type) GetRXIMR7_MI22() uint32 {
	return (volatile.LoadUint32(&o.RXIMR7.Reg) & 0x400000) >> 22
}
func (o *CAN0_Type) SetRXIMR7_MI23(value uint32) {
	volatile.StoreUint32(&o.RXIMR7.Reg, volatile.LoadUint32(&o.RXIMR7.Reg)&^(0x800000)|value<<23)
}
func (o *CAN0_Type) GetRXIMR7_MI23() uint32 {
	return (volatile.LoadUint32(&o.RXIMR7.Reg) & 0x800000) >> 23
}
func (o *CAN0_Type) SetRXIMR7_MI24(value uint32) {
	volatile.StoreUint32(&o.RXIMR7.Reg, volatile.LoadUint32(&o.RXIMR7.Reg)&^(0x1000000)|value<<24)
}
func (o *CAN0_Type) GetRXIMR7_MI24() uint32 {
	return (volatile.LoadUint32(&o.RXIMR7.Reg) & 0x1000000) >> 24
}
func (o *CAN0_Type) SetRXIMR7_MI25(value uint32) {
	volatile.StoreUint32(&o.RXIMR7.Reg, volatile.LoadUint32(&o.RXIMR7.Reg)&^(0x2000000)|value<<25)
}
func (o *CAN0_Type) GetRXIMR7_MI25() uint32 {
	return (volatile.LoadUint32(&o.RXIMR7.Reg) & 0x2000000) >> 25
}
func (o *CAN0_Type) SetRXIMR7_MI26(value uint32) {
	volatile.StoreUint32(&o.RXIMR7.Reg, volatile.LoadUint32(&o.RXIMR7.Reg)&^(0x4000000)|value<<26)
}
func (o *CAN0_Type) GetRXIMR7_MI26() uint32 {
	return (volatile.LoadUint32(&o.RXIMR7.Reg) & 0x4000000) >> 26
}
func (o *CAN0_Type) SetRXIMR7_MI27(value uint32) {
	volatile.StoreUint32(&o.RXIMR7.Reg, volatile.LoadUint32(&o.RXIMR7.Reg)&^(0x8000000)|value<<27)
}
func (o *CAN0_Type) GetRXIMR7_MI27() uint32 {
	return (volatile.LoadUint32(&o.RXIMR7.Reg) & 0x8000000) >> 27
}
func (o *CAN0_Type) SetRXIMR7_MI28(value uint32) {
	volatile.StoreUint32(&o.RXIMR7.Reg, volatile.LoadUint32(&o.RXIMR7.Reg)&^(0x10000000)|value<<28)
}
func (o *CAN0_Type) GetRXIMR7_MI28() uint32 {
	return (volatile.LoadUint32(&o.RXIMR7.Reg) & 0x10000000) >> 28
}
func (o *CAN0_Type) SetRXIMR7_MI29(value uint32) {
	volatile.StoreUint32(&o.RXIMR7.Reg, volatile.LoadUint32(&o.RXIMR7.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetRXIMR7_MI29() uint32 {
	return (volatile.LoadUint32(&o.RXIMR7.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetRXIMR7_MI30(value uint32) {
	volatile.StoreUint32(&o.RXIMR7.Reg, volatile.LoadUint32(&o.RXIMR7.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetRXIMR7_MI30() uint32 {
	return (volatile.LoadUint32(&o.RXIMR7.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetRXIMR7_MI31(value uint32) {
	volatile.StoreUint32(&o.RXIMR7.Reg, volatile.LoadUint32(&o.RXIMR7.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetRXIMR7_MI31() uint32 {
	return (volatile.LoadUint32(&o.RXIMR7.Reg) & 0x80000000) >> 31
}

// CAN0.RXIMR8: Rx Individual Mask Registers
func (o *CAN0_Type) SetRXIMR8_MI0(value uint32) {
	volatile.StoreUint32(&o.RXIMR8.Reg, volatile.LoadUint32(&o.RXIMR8.Reg)&^(0x1)|value)
}
func (o *CAN0_Type) GetRXIMR8_MI0() uint32 {
	return volatile.LoadUint32(&o.RXIMR8.Reg) & 0x1
}
func (o *CAN0_Type) SetRXIMR8_MI1(value uint32) {
	volatile.StoreUint32(&o.RXIMR8.Reg, volatile.LoadUint32(&o.RXIMR8.Reg)&^(0x2)|value<<1)
}
func (o *CAN0_Type) GetRXIMR8_MI1() uint32 {
	return (volatile.LoadUint32(&o.RXIMR8.Reg) & 0x2) >> 1
}
func (o *CAN0_Type) SetRXIMR8_MI2(value uint32) {
	volatile.StoreUint32(&o.RXIMR8.Reg, volatile.LoadUint32(&o.RXIMR8.Reg)&^(0x4)|value<<2)
}
func (o *CAN0_Type) GetRXIMR8_MI2() uint32 {
	return (volatile.LoadUint32(&o.RXIMR8.Reg) & 0x4) >> 2
}
func (o *CAN0_Type) SetRXIMR8_MI3(value uint32) {
	volatile.StoreUint32(&o.RXIMR8.Reg, volatile.LoadUint32(&o.RXIMR8.Reg)&^(0x8)|value<<3)
}
func (o *CAN0_Type) GetRXIMR8_MI3() uint32 {
	return (volatile.LoadUint32(&o.RXIMR8.Reg) & 0x8) >> 3
}
func (o *CAN0_Type) SetRXIMR8_MI4(value uint32) {
	volatile.StoreUint32(&o.RXIMR8.Reg, volatile.LoadUint32(&o.RXIMR8.Reg)&^(0x10)|value<<4)
}
func (o *CAN0_Type) GetRXIMR8_MI4() uint32 {
	return (volatile.LoadUint32(&o.RXIMR8.Reg) & 0x10) >> 4
}
func (o *CAN0_Type) SetRXIMR8_MI5(value uint32) {
	volatile.StoreUint32(&o.RXIMR8.Reg, volatile.LoadUint32(&o.RXIMR8.Reg)&^(0x20)|value<<5)
}
func (o *CAN0_Type) GetRXIMR8_MI5() uint32 {
	return (volatile.LoadUint32(&o.RXIMR8.Reg) & 0x20) >> 5
}
func (o *CAN0_Type) SetRXIMR8_MI6(value uint32) {
	volatile.StoreUint32(&o.RXIMR8.Reg, volatile.LoadUint32(&o.RXIMR8.Reg)&^(0x40)|value<<6)
}
func (o *CAN0_Type) GetRXIMR8_MI6() uint32 {
	return (volatile.LoadUint32(&o.RXIMR8.Reg) & 0x40) >> 6
}
func (o *CAN0_Type) SetRXIMR8_MI7(value uint32) {
	volatile.StoreUint32(&o.RXIMR8.Reg, volatile.LoadUint32(&o.RXIMR8.Reg)&^(0x80)|value<<7)
}
func (o *CAN0_Type) GetRXIMR8_MI7() uint32 {
	return (volatile.LoadUint32(&o.RXIMR8.Reg) & 0x80) >> 7
}
func (o *CAN0_Type) SetRXIMR8_MI8(value uint32) {
	volatile.StoreUint32(&o.RXIMR8.Reg, volatile.LoadUint32(&o.RXIMR8.Reg)&^(0x100)|value<<8)
}
func (o *CAN0_Type) GetRXIMR8_MI8() uint32 {
	return (volatile.LoadUint32(&o.RXIMR8.Reg) & 0x100) >> 8
}
func (o *CAN0_Type) SetRXIMR8_MI9(value uint32) {
	volatile.StoreUint32(&o.RXIMR8.Reg, volatile.LoadUint32(&o.RXIMR8.Reg)&^(0x200)|value<<9)
}
func (o *CAN0_Type) GetRXIMR8_MI9() uint32 {
	return (volatile.LoadUint32(&o.RXIMR8.Reg) & 0x200) >> 9
}
func (o *CAN0_Type) SetRXIMR8_MI10(value uint32) {
	volatile.StoreUint32(&o.RXIMR8.Reg, volatile.LoadUint32(&o.RXIMR8.Reg)&^(0x400)|value<<10)
}
func (o *CAN0_Type) GetRXIMR8_MI10() uint32 {
	return (volatile.LoadUint32(&o.RXIMR8.Reg) & 0x400) >> 10
}
func (o *CAN0_Type) SetRXIMR8_MI11(value uint32) {
	volatile.StoreUint32(&o.RXIMR8.Reg, volatile.LoadUint32(&o.RXIMR8.Reg)&^(0x800)|value<<11)
}
func (o *CAN0_Type) GetRXIMR8_MI11() uint32 {
	return (volatile.LoadUint32(&o.RXIMR8.Reg) & 0x800) >> 11
}
func (o *CAN0_Type) SetRXIMR8_MI12(value uint32) {
	volatile.StoreUint32(&o.RXIMR8.Reg, volatile.LoadUint32(&o.RXIMR8.Reg)&^(0x1000)|value<<12)
}
func (o *CAN0_Type) GetRXIMR8_MI12() uint32 {
	return (volatile.LoadUint32(&o.RXIMR8.Reg) & 0x1000) >> 12
}
func (o *CAN0_Type) SetRXIMR8_MI13(value uint32) {
	volatile.StoreUint32(&o.RXIMR8.Reg, volatile.LoadUint32(&o.RXIMR8.Reg)&^(0x2000)|value<<13)
}
func (o *CAN0_Type) GetRXIMR8_MI13() uint32 {
	return (volatile.LoadUint32(&o.RXIMR8.Reg) & 0x2000) >> 13
}
func (o *CAN0_Type) SetRXIMR8_MI14(value uint32) {
	volatile.StoreUint32(&o.RXIMR8.Reg, volatile.LoadUint32(&o.RXIMR8.Reg)&^(0x4000)|value<<14)
}
func (o *CAN0_Type) GetRXIMR8_MI14() uint32 {
	return (volatile.LoadUint32(&o.RXIMR8.Reg) & 0x4000) >> 14
}
func (o *CAN0_Type) SetRXIMR8_MI15(value uint32) {
	volatile.StoreUint32(&o.RXIMR8.Reg, volatile.LoadUint32(&o.RXIMR8.Reg)&^(0x8000)|value<<15)
}
func (o *CAN0_Type) GetRXIMR8_MI15() uint32 {
	return (volatile.LoadUint32(&o.RXIMR8.Reg) & 0x8000) >> 15
}
func (o *CAN0_Type) SetRXIMR8_MI16(value uint32) {
	volatile.StoreUint32(&o.RXIMR8.Reg, volatile.LoadUint32(&o.RXIMR8.Reg)&^(0x10000)|value<<16)
}
func (o *CAN0_Type) GetRXIMR8_MI16() uint32 {
	return (volatile.LoadUint32(&o.RXIMR8.Reg) & 0x10000) >> 16
}
func (o *CAN0_Type) SetRXIMR8_MI17(value uint32) {
	volatile.StoreUint32(&o.RXIMR8.Reg, volatile.LoadUint32(&o.RXIMR8.Reg)&^(0x20000)|value<<17)
}
func (o *CAN0_Type) GetRXIMR8_MI17() uint32 {
	return (volatile.LoadUint32(&o.RXIMR8.Reg) & 0x20000) >> 17
}
func (o *CAN0_Type) SetRXIMR8_MI18(value uint32) {
	volatile.StoreUint32(&o.RXIMR8.Reg, volatile.LoadUint32(&o.RXIMR8.Reg)&^(0x40000)|value<<18)
}
func (o *CAN0_Type) GetRXIMR8_MI18() uint32 {
	return (volatile.LoadUint32(&o.RXIMR8.Reg) & 0x40000) >> 18
}
func (o *CAN0_Type) SetRXIMR8_MI19(value uint32) {
	volatile.StoreUint32(&o.RXIMR8.Reg, volatile.LoadUint32(&o.RXIMR8.Reg)&^(0x80000)|value<<19)
}
func (o *CAN0_Type) GetRXIMR8_MI19() uint32 {
	return (volatile.LoadUint32(&o.RXIMR8.Reg) & 0x80000) >> 19
}
func (o *CAN0_Type) SetRXIMR8_MI20(value uint32) {
	volatile.StoreUint32(&o.RXIMR8.Reg, volatile.LoadUint32(&o.RXIMR8.Reg)&^(0x100000)|value<<20)
}
func (o *CAN0_Type) GetRXIMR8_MI20() uint32 {
	return (volatile.LoadUint32(&o.RXIMR8.Reg) & 0x100000) >> 20
}
func (o *CAN0_Type) SetRXIMR8_MI21(value uint32) {
	volatile.StoreUint32(&o.RXIMR8.Reg, volatile.LoadUint32(&o.RXIMR8.Reg)&^(0x200000)|value<<21)
}
func (o *CAN0_Type) GetRXIMR8_MI21() uint32 {
	return (volatile.LoadUint32(&o.RXIMR8.Reg) & 0x200000) >> 21
}
func (o *CAN0_Type) SetRXIMR8_MI22(value uint32) {
	volatile.StoreUint32(&o.RXIMR8.Reg, volatile.LoadUint32(&o.RXIMR8.Reg)&^(0x400000)|value<<22)
}
func (o *CAN0_Type) GetRXIMR8_MI22() uint32 {
	return (volatile.LoadUint32(&o.RXIMR8.Reg) & 0x400000) >> 22
}
func (o *CAN0_Type) SetRXIMR8_MI23(value uint32) {
	volatile.StoreUint32(&o.RXIMR8.Reg, volatile.LoadUint32(&o.RXIMR8.Reg)&^(0x800000)|value<<23)
}
func (o *CAN0_Type) GetRXIMR8_MI23() uint32 {
	return (volatile.LoadUint32(&o.RXIMR8.Reg) & 0x800000) >> 23
}
func (o *CAN0_Type) SetRXIMR8_MI24(value uint32) {
	volatile.StoreUint32(&o.RXIMR8.Reg, volatile.LoadUint32(&o.RXIMR8.Reg)&^(0x1000000)|value<<24)
}
func (o *CAN0_Type) GetRXIMR8_MI24() uint32 {
	return (volatile.LoadUint32(&o.RXIMR8.Reg) & 0x1000000) >> 24
}
func (o *CAN0_Type) SetRXIMR8_MI25(value uint32) {
	volatile.StoreUint32(&o.RXIMR8.Reg, volatile.LoadUint32(&o.RXIMR8.Reg)&^(0x2000000)|value<<25)
}
func (o *CAN0_Type) GetRXIMR8_MI25() uint32 {
	return (volatile.LoadUint32(&o.RXIMR8.Reg) & 0x2000000) >> 25
}
func (o *CAN0_Type) SetRXIMR8_MI26(value uint32) {
	volatile.StoreUint32(&o.RXIMR8.Reg, volatile.LoadUint32(&o.RXIMR8.Reg)&^(0x4000000)|value<<26)
}
func (o *CAN0_Type) GetRXIMR8_MI26() uint32 {
	return (volatile.LoadUint32(&o.RXIMR8.Reg) & 0x4000000) >> 26
}
func (o *CAN0_Type) SetRXIMR8_MI27(value uint32) {
	volatile.StoreUint32(&o.RXIMR8.Reg, volatile.LoadUint32(&o.RXIMR8.Reg)&^(0x8000000)|value<<27)
}
func (o *CAN0_Type) GetRXIMR8_MI27() uint32 {
	return (volatile.LoadUint32(&o.RXIMR8.Reg) & 0x8000000) >> 27
}
func (o *CAN0_Type) SetRXIMR8_MI28(value uint32) {
	volatile.StoreUint32(&o.RXIMR8.Reg, volatile.LoadUint32(&o.RXIMR8.Reg)&^(0x10000000)|value<<28)
}
func (o *CAN0_Type) GetRXIMR8_MI28() uint32 {
	return (volatile.LoadUint32(&o.RXIMR8.Reg) & 0x10000000) >> 28
}
func (o *CAN0_Type) SetRXIMR8_MI29(value uint32) {
	volatile.StoreUint32(&o.RXIMR8.Reg, volatile.LoadUint32(&o.RXIMR8.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetRXIMR8_MI29() uint32 {
	return (volatile.LoadUint32(&o.RXIMR8.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetRXIMR8_MI30(value uint32) {
	volatile.StoreUint32(&o.RXIMR8.Reg, volatile.LoadUint32(&o.RXIMR8.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetRXIMR8_MI30() uint32 {
	return (volatile.LoadUint32(&o.RXIMR8.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetRXIMR8_MI31(value uint32) {
	volatile.StoreUint32(&o.RXIMR8.Reg, volatile.LoadUint32(&o.RXIMR8.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetRXIMR8_MI31() uint32 {
	return (volatile.LoadUint32(&o.RXIMR8.Reg) & 0x80000000) >> 31
}

// CAN0.RXIMR9: Rx Individual Mask Registers
func (o *CAN0_Type) SetRXIMR9_MI0(value uint32) {
	volatile.StoreUint32(&o.RXIMR9.Reg, volatile.LoadUint32(&o.RXIMR9.Reg)&^(0x1)|value)
}
func (o *CAN0_Type) GetRXIMR9_MI0() uint32 {
	return volatile.LoadUint32(&o.RXIMR9.Reg) & 0x1
}
func (o *CAN0_Type) SetRXIMR9_MI1(value uint32) {
	volatile.StoreUint32(&o.RXIMR9.Reg, volatile.LoadUint32(&o.RXIMR9.Reg)&^(0x2)|value<<1)
}
func (o *CAN0_Type) GetRXIMR9_MI1() uint32 {
	return (volatile.LoadUint32(&o.RXIMR9.Reg) & 0x2) >> 1
}
func (o *CAN0_Type) SetRXIMR9_MI2(value uint32) {
	volatile.StoreUint32(&o.RXIMR9.Reg, volatile.LoadUint32(&o.RXIMR9.Reg)&^(0x4)|value<<2)
}
func (o *CAN0_Type) GetRXIMR9_MI2() uint32 {
	return (volatile.LoadUint32(&o.RXIMR9.Reg) & 0x4) >> 2
}
func (o *CAN0_Type) SetRXIMR9_MI3(value uint32) {
	volatile.StoreUint32(&o.RXIMR9.Reg, volatile.LoadUint32(&o.RXIMR9.Reg)&^(0x8)|value<<3)
}
func (o *CAN0_Type) GetRXIMR9_MI3() uint32 {
	return (volatile.LoadUint32(&o.RXIMR9.Reg) & 0x8) >> 3
}
func (o *CAN0_Type) SetRXIMR9_MI4(value uint32) {
	volatile.StoreUint32(&o.RXIMR9.Reg, volatile.LoadUint32(&o.RXIMR9.Reg)&^(0x10)|value<<4)
}
func (o *CAN0_Type) GetRXIMR9_MI4() uint32 {
	return (volatile.LoadUint32(&o.RXIMR9.Reg) & 0x10) >> 4
}
func (o *CAN0_Type) SetRXIMR9_MI5(value uint32) {
	volatile.StoreUint32(&o.RXIMR9.Reg, volatile.LoadUint32(&o.RXIMR9.Reg)&^(0x20)|value<<5)
}
func (o *CAN0_Type) GetRXIMR9_MI5() uint32 {
	return (volatile.LoadUint32(&o.RXIMR9.Reg) & 0x20) >> 5
}
func (o *CAN0_Type) SetRXIMR9_MI6(value uint32) {
	volatile.StoreUint32(&o.RXIMR9.Reg, volatile.LoadUint32(&o.RXIMR9.Reg)&^(0x40)|value<<6)
}
func (o *CAN0_Type) GetRXIMR9_MI6() uint32 {
	return (volatile.LoadUint32(&o.RXIMR9.Reg) & 0x40) >> 6
}
func (o *CAN0_Type) SetRXIMR9_MI7(value uint32) {
	volatile.StoreUint32(&o.RXIMR9.Reg, volatile.LoadUint32(&o.RXIMR9.Reg)&^(0x80)|value<<7)
}
func (o *CAN0_Type) GetRXIMR9_MI7() uint32 {
	return (volatile.LoadUint32(&o.RXIMR9.Reg) & 0x80) >> 7
}
func (o *CAN0_Type) SetRXIMR9_MI8(value uint32) {
	volatile.StoreUint32(&o.RXIMR9.Reg, volatile.LoadUint32(&o.RXIMR9.Reg)&^(0x100)|value<<8)
}
func (o *CAN0_Type) GetRXIMR9_MI8() uint32 {
	return (volatile.LoadUint32(&o.RXIMR9.Reg) & 0x100) >> 8
}
func (o *CAN0_Type) SetRXIMR9_MI9(value uint32) {
	volatile.StoreUint32(&o.RXIMR9.Reg, volatile.LoadUint32(&o.RXIMR9.Reg)&^(0x200)|value<<9)
}
func (o *CAN0_Type) GetRXIMR9_MI9() uint32 {
	return (volatile.LoadUint32(&o.RXIMR9.Reg) & 0x200) >> 9
}
func (o *CAN0_Type) SetRXIMR9_MI10(value uint32) {
	volatile.StoreUint32(&o.RXIMR9.Reg, volatile.LoadUint32(&o.RXIMR9.Reg)&^(0x400)|value<<10)
}
func (o *CAN0_Type) GetRXIMR9_MI10() uint32 {
	return (volatile.LoadUint32(&o.RXIMR9.Reg) & 0x400) >> 10
}
func (o *CAN0_Type) SetRXIMR9_MI11(value uint32) {
	volatile.StoreUint32(&o.RXIMR9.Reg, volatile.LoadUint32(&o.RXIMR9.Reg)&^(0x800)|value<<11)
}
func (o *CAN0_Type) GetRXIMR9_MI11() uint32 {
	return (volatile.LoadUint32(&o.RXIMR9.Reg) & 0x800) >> 11
}
func (o *CAN0_Type) SetRXIMR9_MI12(value uint32) {
	volatile.StoreUint32(&o.RXIMR9.Reg, volatile.LoadUint32(&o.RXIMR9.Reg)&^(0x1000)|value<<12)
}
func (o *CAN0_Type) GetRXIMR9_MI12() uint32 {
	return (volatile.LoadUint32(&o.RXIMR9.Reg) & 0x1000) >> 12
}
func (o *CAN0_Type) SetRXIMR9_MI13(value uint32) {
	volatile.StoreUint32(&o.RXIMR9.Reg, volatile.LoadUint32(&o.RXIMR9.Reg)&^(0x2000)|value<<13)
}
func (o *CAN0_Type) GetRXIMR9_MI13() uint32 {
	return (volatile.LoadUint32(&o.RXIMR9.Reg) & 0x2000) >> 13
}
func (o *CAN0_Type) SetRXIMR9_MI14(value uint32) {
	volatile.StoreUint32(&o.RXIMR9.Reg, volatile.LoadUint32(&o.RXIMR9.Reg)&^(0x4000)|value<<14)
}
func (o *CAN0_Type) GetRXIMR9_MI14() uint32 {
	return (volatile.LoadUint32(&o.RXIMR9.Reg) & 0x4000) >> 14
}
func (o *CAN0_Type) SetRXIMR9_MI15(value uint32) {
	volatile.StoreUint32(&o.RXIMR9.Reg, volatile.LoadUint32(&o.RXIMR9.Reg)&^(0x8000)|value<<15)
}
func (o *CAN0_Type) GetRXIMR9_MI15() uint32 {
	return (volatile.LoadUint32(&o.RXIMR9.Reg) & 0x8000) >> 15
}
func (o *CAN0_Type) SetRXIMR9_MI16(value uint32) {
	volatile.StoreUint32(&o.RXIMR9.Reg, volatile.LoadUint32(&o.RXIMR9.Reg)&^(0x10000)|value<<16)
}
func (o *CAN0_Type) GetRXIMR9_MI16() uint32 {
	return (volatile.LoadUint32(&o.RXIMR9.Reg) & 0x10000) >> 16
}
func (o *CAN0_Type) SetRXIMR9_MI17(value uint32) {
	volatile.StoreUint32(&o.RXIMR9.Reg, volatile.LoadUint32(&o.RXIMR9.Reg)&^(0x20000)|value<<17)
}
func (o *CAN0_Type) GetRXIMR9_MI17() uint32 {
	return (volatile.LoadUint32(&o.RXIMR9.Reg) & 0x20000) >> 17
}
func (o *CAN0_Type) SetRXIMR9_MI18(value uint32) {
	volatile.StoreUint32(&o.RXIMR9.Reg, volatile.LoadUint32(&o.RXIMR9.Reg)&^(0x40000)|value<<18)
}
func (o *CAN0_Type) GetRXIMR9_MI18() uint32 {
	return (volatile.LoadUint32(&o.RXIMR9.Reg) & 0x40000) >> 18
}
func (o *CAN0_Type) SetRXIMR9_MI19(value uint32) {
	volatile.StoreUint32(&o.RXIMR9.Reg, volatile.LoadUint32(&o.RXIMR9.Reg)&^(0x80000)|value<<19)
}
func (o *CAN0_Type) GetRXIMR9_MI19() uint32 {
	return (volatile.LoadUint32(&o.RXIMR9.Reg) & 0x80000) >> 19
}
func (o *CAN0_Type) SetRXIMR9_MI20(value uint32) {
	volatile.StoreUint32(&o.RXIMR9.Reg, volatile.LoadUint32(&o.RXIMR9.Reg)&^(0x100000)|value<<20)
}
func (o *CAN0_Type) GetRXIMR9_MI20() uint32 {
	return (volatile.LoadUint32(&o.RXIMR9.Reg) & 0x100000) >> 20
}
func (o *CAN0_Type) SetRXIMR9_MI21(value uint32) {
	volatile.StoreUint32(&o.RXIMR9.Reg, volatile.LoadUint32(&o.RXIMR9.Reg)&^(0x200000)|value<<21)
}
func (o *CAN0_Type) GetRXIMR9_MI21() uint32 {
	return (volatile.LoadUint32(&o.RXIMR9.Reg) & 0x200000) >> 21
}
func (o *CAN0_Type) SetRXIMR9_MI22(value uint32) {
	volatile.StoreUint32(&o.RXIMR9.Reg, volatile.LoadUint32(&o.RXIMR9.Reg)&^(0x400000)|value<<22)
}
func (o *CAN0_Type) GetRXIMR9_MI22() uint32 {
	return (volatile.LoadUint32(&o.RXIMR9.Reg) & 0x400000) >> 22
}
func (o *CAN0_Type) SetRXIMR9_MI23(value uint32) {
	volatile.StoreUint32(&o.RXIMR9.Reg, volatile.LoadUint32(&o.RXIMR9.Reg)&^(0x800000)|value<<23)
}
func (o *CAN0_Type) GetRXIMR9_MI23() uint32 {
	return (volatile.LoadUint32(&o.RXIMR9.Reg) & 0x800000) >> 23
}
func (o *CAN0_Type) SetRXIMR9_MI24(value uint32) {
	volatile.StoreUint32(&o.RXIMR9.Reg, volatile.LoadUint32(&o.RXIMR9.Reg)&^(0x1000000)|value<<24)
}
func (o *CAN0_Type) GetRXIMR9_MI24() uint32 {
	return (volatile.LoadUint32(&o.RXIMR9.Reg) & 0x1000000) >> 24
}
func (o *CAN0_Type) SetRXIMR9_MI25(value uint32) {
	volatile.StoreUint32(&o.RXIMR9.Reg, volatile.LoadUint32(&o.RXIMR9.Reg)&^(0x2000000)|value<<25)
}
func (o *CAN0_Type) GetRXIMR9_MI25() uint32 {
	return (volatile.LoadUint32(&o.RXIMR9.Reg) & 0x2000000) >> 25
}
func (o *CAN0_Type) SetRXIMR9_MI26(value uint32) {
	volatile.StoreUint32(&o.RXIMR9.Reg, volatile.LoadUint32(&o.RXIMR9.Reg)&^(0x4000000)|value<<26)
}
func (o *CAN0_Type) GetRXIMR9_MI26() uint32 {
	return (volatile.LoadUint32(&o.RXIMR9.Reg) & 0x4000000) >> 26
}
func (o *CAN0_Type) SetRXIMR9_MI27(value uint32) {
	volatile.StoreUint32(&o.RXIMR9.Reg, volatile.LoadUint32(&o.RXIMR9.Reg)&^(0x8000000)|value<<27)
}
func (o *CAN0_Type) GetRXIMR9_MI27() uint32 {
	return (volatile.LoadUint32(&o.RXIMR9.Reg) & 0x8000000) >> 27
}
func (o *CAN0_Type) SetRXIMR9_MI28(value uint32) {
	volatile.StoreUint32(&o.RXIMR9.Reg, volatile.LoadUint32(&o.RXIMR9.Reg)&^(0x10000000)|value<<28)
}
func (o *CAN0_Type) GetRXIMR9_MI28() uint32 {
	return (volatile.LoadUint32(&o.RXIMR9.Reg) & 0x10000000) >> 28
}
func (o *CAN0_Type) SetRXIMR9_MI29(value uint32) {
	volatile.StoreUint32(&o.RXIMR9.Reg, volatile.LoadUint32(&o.RXIMR9.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetRXIMR9_MI29() uint32 {
	return (volatile.LoadUint32(&o.RXIMR9.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetRXIMR9_MI30(value uint32) {
	volatile.StoreUint32(&o.RXIMR9.Reg, volatile.LoadUint32(&o.RXIMR9.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetRXIMR9_MI30() uint32 {
	return (volatile.LoadUint32(&o.RXIMR9.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetRXIMR9_MI31(value uint32) {
	volatile.StoreUint32(&o.RXIMR9.Reg, volatile.LoadUint32(&o.RXIMR9.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetRXIMR9_MI31() uint32 {
	return (volatile.LoadUint32(&o.RXIMR9.Reg) & 0x80000000) >> 31
}

// CAN0.RXIMR10: Rx Individual Mask Registers
func (o *CAN0_Type) SetRXIMR10_MI0(value uint32) {
	volatile.StoreUint32(&o.RXIMR10.Reg, volatile.LoadUint32(&o.RXIMR10.Reg)&^(0x1)|value)
}
func (o *CAN0_Type) GetRXIMR10_MI0() uint32 {
	return volatile.LoadUint32(&o.RXIMR10.Reg) & 0x1
}
func (o *CAN0_Type) SetRXIMR10_MI1(value uint32) {
	volatile.StoreUint32(&o.RXIMR10.Reg, volatile.LoadUint32(&o.RXIMR10.Reg)&^(0x2)|value<<1)
}
func (o *CAN0_Type) GetRXIMR10_MI1() uint32 {
	return (volatile.LoadUint32(&o.RXIMR10.Reg) & 0x2) >> 1
}
func (o *CAN0_Type) SetRXIMR10_MI2(value uint32) {
	volatile.StoreUint32(&o.RXIMR10.Reg, volatile.LoadUint32(&o.RXIMR10.Reg)&^(0x4)|value<<2)
}
func (o *CAN0_Type) GetRXIMR10_MI2() uint32 {
	return (volatile.LoadUint32(&o.RXIMR10.Reg) & 0x4) >> 2
}
func (o *CAN0_Type) SetRXIMR10_MI3(value uint32) {
	volatile.StoreUint32(&o.RXIMR10.Reg, volatile.LoadUint32(&o.RXIMR10.Reg)&^(0x8)|value<<3)
}
func (o *CAN0_Type) GetRXIMR10_MI3() uint32 {
	return (volatile.LoadUint32(&o.RXIMR10.Reg) & 0x8) >> 3
}
func (o *CAN0_Type) SetRXIMR10_MI4(value uint32) {
	volatile.StoreUint32(&o.RXIMR10.Reg, volatile.LoadUint32(&o.RXIMR10.Reg)&^(0x10)|value<<4)
}
func (o *CAN0_Type) GetRXIMR10_MI4() uint32 {
	return (volatile.LoadUint32(&o.RXIMR10.Reg) & 0x10) >> 4
}
func (o *CAN0_Type) SetRXIMR10_MI5(value uint32) {
	volatile.StoreUint32(&o.RXIMR10.Reg, volatile.LoadUint32(&o.RXIMR10.Reg)&^(0x20)|value<<5)
}
func (o *CAN0_Type) GetRXIMR10_MI5() uint32 {
	return (volatile.LoadUint32(&o.RXIMR10.Reg) & 0x20) >> 5
}
func (o *CAN0_Type) SetRXIMR10_MI6(value uint32) {
	volatile.StoreUint32(&o.RXIMR10.Reg, volatile.LoadUint32(&o.RXIMR10.Reg)&^(0x40)|value<<6)
}
func (o *CAN0_Type) GetRXIMR10_MI6() uint32 {
	return (volatile.LoadUint32(&o.RXIMR10.Reg) & 0x40) >> 6
}
func (o *CAN0_Type) SetRXIMR10_MI7(value uint32) {
	volatile.StoreUint32(&o.RXIMR10.Reg, volatile.LoadUint32(&o.RXIMR10.Reg)&^(0x80)|value<<7)
}
func (o *CAN0_Type) GetRXIMR10_MI7() uint32 {
	return (volatile.LoadUint32(&o.RXIMR10.Reg) & 0x80) >> 7
}
func (o *CAN0_Type) SetRXIMR10_MI8(value uint32) {
	volatile.StoreUint32(&o.RXIMR10.Reg, volatile.LoadUint32(&o.RXIMR10.Reg)&^(0x100)|value<<8)
}
func (o *CAN0_Type) GetRXIMR10_MI8() uint32 {
	return (volatile.LoadUint32(&o.RXIMR10.Reg) & 0x100) >> 8
}
func (o *CAN0_Type) SetRXIMR10_MI9(value uint32) {
	volatile.StoreUint32(&o.RXIMR10.Reg, volatile.LoadUint32(&o.RXIMR10.Reg)&^(0x200)|value<<9)
}
func (o *CAN0_Type) GetRXIMR10_MI9() uint32 {
	return (volatile.LoadUint32(&o.RXIMR10.Reg) & 0x200) >> 9
}
func (o *CAN0_Type) SetRXIMR10_MI10(value uint32) {
	volatile.StoreUint32(&o.RXIMR10.Reg, volatile.LoadUint32(&o.RXIMR10.Reg)&^(0x400)|value<<10)
}
func (o *CAN0_Type) GetRXIMR10_MI10() uint32 {
	return (volatile.LoadUint32(&o.RXIMR10.Reg) & 0x400) >> 10
}
func (o *CAN0_Type) SetRXIMR10_MI11(value uint32) {
	volatile.StoreUint32(&o.RXIMR10.Reg, volatile.LoadUint32(&o.RXIMR10.Reg)&^(0x800)|value<<11)
}
func (o *CAN0_Type) GetRXIMR10_MI11() uint32 {
	return (volatile.LoadUint32(&o.RXIMR10.Reg) & 0x800) >> 11
}
func (o *CAN0_Type) SetRXIMR10_MI12(value uint32) {
	volatile.StoreUint32(&o.RXIMR10.Reg, volatile.LoadUint32(&o.RXIMR10.Reg)&^(0x1000)|value<<12)
}
func (o *CAN0_Type) GetRXIMR10_MI12() uint32 {
	return (volatile.LoadUint32(&o.RXIMR10.Reg) & 0x1000) >> 12
}
func (o *CAN0_Type) SetRXIMR10_MI13(value uint32) {
	volatile.StoreUint32(&o.RXIMR10.Reg, volatile.LoadUint32(&o.RXIMR10.Reg)&^(0x2000)|value<<13)
}
func (o *CAN0_Type) GetRXIMR10_MI13() uint32 {
	return (volatile.LoadUint32(&o.RXIMR10.Reg) & 0x2000) >> 13
}
func (o *CAN0_Type) SetRXIMR10_MI14(value uint32) {
	volatile.StoreUint32(&o.RXIMR10.Reg, volatile.LoadUint32(&o.RXIMR10.Reg)&^(0x4000)|value<<14)
}
func (o *CAN0_Type) GetRXIMR10_MI14() uint32 {
	return (volatile.LoadUint32(&o.RXIMR10.Reg) & 0x4000) >> 14
}
func (o *CAN0_Type) SetRXIMR10_MI15(value uint32) {
	volatile.StoreUint32(&o.RXIMR10.Reg, volatile.LoadUint32(&o.RXIMR10.Reg)&^(0x8000)|value<<15)
}
func (o *CAN0_Type) GetRXIMR10_MI15() uint32 {
	return (volatile.LoadUint32(&o.RXIMR10.Reg) & 0x8000) >> 15
}
func (o *CAN0_Type) SetRXIMR10_MI16(value uint32) {
	volatile.StoreUint32(&o.RXIMR10.Reg, volatile.LoadUint32(&o.RXIMR10.Reg)&^(0x10000)|value<<16)
}
func (o *CAN0_Type) GetRXIMR10_MI16() uint32 {
	return (volatile.LoadUint32(&o.RXIMR10.Reg) & 0x10000) >> 16
}
func (o *CAN0_Type) SetRXIMR10_MI17(value uint32) {
	volatile.StoreUint32(&o.RXIMR10.Reg, volatile.LoadUint32(&o.RXIMR10.Reg)&^(0x20000)|value<<17)
}
func (o *CAN0_Type) GetRXIMR10_MI17() uint32 {
	return (volatile.LoadUint32(&o.RXIMR10.Reg) & 0x20000) >> 17
}
func (o *CAN0_Type) SetRXIMR10_MI18(value uint32) {
	volatile.StoreUint32(&o.RXIMR10.Reg, volatile.LoadUint32(&o.RXIMR10.Reg)&^(0x40000)|value<<18)
}
func (o *CAN0_Type) GetRXIMR10_MI18() uint32 {
	return (volatile.LoadUint32(&o.RXIMR10.Reg) & 0x40000) >> 18
}
func (o *CAN0_Type) SetRXIMR10_MI19(value uint32) {
	volatile.StoreUint32(&o.RXIMR10.Reg, volatile.LoadUint32(&o.RXIMR10.Reg)&^(0x80000)|value<<19)
}
func (o *CAN0_Type) GetRXIMR10_MI19() uint32 {
	return (volatile.LoadUint32(&o.RXIMR10.Reg) & 0x80000) >> 19
}
func (o *CAN0_Type) SetRXIMR10_MI20(value uint32) {
	volatile.StoreUint32(&o.RXIMR10.Reg, volatile.LoadUint32(&o.RXIMR10.Reg)&^(0x100000)|value<<20)
}
func (o *CAN0_Type) GetRXIMR10_MI20() uint32 {
	return (volatile.LoadUint32(&o.RXIMR10.Reg) & 0x100000) >> 20
}
func (o *CAN0_Type) SetRXIMR10_MI21(value uint32) {
	volatile.StoreUint32(&o.RXIMR10.Reg, volatile.LoadUint32(&o.RXIMR10.Reg)&^(0x200000)|value<<21)
}
func (o *CAN0_Type) GetRXIMR10_MI21() uint32 {
	return (volatile.LoadUint32(&o.RXIMR10.Reg) & 0x200000) >> 21
}
func (o *CAN0_Type) SetRXIMR10_MI22(value uint32) {
	volatile.StoreUint32(&o.RXIMR10.Reg, volatile.LoadUint32(&o.RXIMR10.Reg)&^(0x400000)|value<<22)
}
func (o *CAN0_Type) GetRXIMR10_MI22() uint32 {
	return (volatile.LoadUint32(&o.RXIMR10.Reg) & 0x400000) >> 22
}
func (o *CAN0_Type) SetRXIMR10_MI23(value uint32) {
	volatile.StoreUint32(&o.RXIMR10.Reg, volatile.LoadUint32(&o.RXIMR10.Reg)&^(0x800000)|value<<23)
}
func (o *CAN0_Type) GetRXIMR10_MI23() uint32 {
	return (volatile.LoadUint32(&o.RXIMR10.Reg) & 0x800000) >> 23
}
func (o *CAN0_Type) SetRXIMR10_MI24(value uint32) {
	volatile.StoreUint32(&o.RXIMR10.Reg, volatile.LoadUint32(&o.RXIMR10.Reg)&^(0x1000000)|value<<24)
}
func (o *CAN0_Type) GetRXIMR10_MI24() uint32 {
	return (volatile.LoadUint32(&o.RXIMR10.Reg) & 0x1000000) >> 24
}
func (o *CAN0_Type) SetRXIMR10_MI25(value uint32) {
	volatile.StoreUint32(&o.RXIMR10.Reg, volatile.LoadUint32(&o.RXIMR10.Reg)&^(0x2000000)|value<<25)
}
func (o *CAN0_Type) GetRXIMR10_MI25() uint32 {
	return (volatile.LoadUint32(&o.RXIMR10.Reg) & 0x2000000) >> 25
}
func (o *CAN0_Type) SetRXIMR10_MI26(value uint32) {
	volatile.StoreUint32(&o.RXIMR10.Reg, volatile.LoadUint32(&o.RXIMR10.Reg)&^(0x4000000)|value<<26)
}
func (o *CAN0_Type) GetRXIMR10_MI26() uint32 {
	return (volatile.LoadUint32(&o.RXIMR10.Reg) & 0x4000000) >> 26
}
func (o *CAN0_Type) SetRXIMR10_MI27(value uint32) {
	volatile.StoreUint32(&o.RXIMR10.Reg, volatile.LoadUint32(&o.RXIMR10.Reg)&^(0x8000000)|value<<27)
}
func (o *CAN0_Type) GetRXIMR10_MI27() uint32 {
	return (volatile.LoadUint32(&o.RXIMR10.Reg) & 0x8000000) >> 27
}
func (o *CAN0_Type) SetRXIMR10_MI28(value uint32) {
	volatile.StoreUint32(&o.RXIMR10.Reg, volatile.LoadUint32(&o.RXIMR10.Reg)&^(0x10000000)|value<<28)
}
func (o *CAN0_Type) GetRXIMR10_MI28() uint32 {
	return (volatile.LoadUint32(&o.RXIMR10.Reg) & 0x10000000) >> 28
}
func (o *CAN0_Type) SetRXIMR10_MI29(value uint32) {
	volatile.StoreUint32(&o.RXIMR10.Reg, volatile.LoadUint32(&o.RXIMR10.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetRXIMR10_MI29() uint32 {
	return (volatile.LoadUint32(&o.RXIMR10.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetRXIMR10_MI30(value uint32) {
	volatile.StoreUint32(&o.RXIMR10.Reg, volatile.LoadUint32(&o.RXIMR10.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetRXIMR10_MI30() uint32 {
	return (volatile.LoadUint32(&o.RXIMR10.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetRXIMR10_MI31(value uint32) {
	volatile.StoreUint32(&o.RXIMR10.Reg, volatile.LoadUint32(&o.RXIMR10.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetRXIMR10_MI31() uint32 {
	return (volatile.LoadUint32(&o.RXIMR10.Reg) & 0x80000000) >> 31
}

// CAN0.RXIMR11: Rx Individual Mask Registers
func (o *CAN0_Type) SetRXIMR11_MI0(value uint32) {
	volatile.StoreUint32(&o.RXIMR11.Reg, volatile.LoadUint32(&o.RXIMR11.Reg)&^(0x1)|value)
}
func (o *CAN0_Type) GetRXIMR11_MI0() uint32 {
	return volatile.LoadUint32(&o.RXIMR11.Reg) & 0x1
}
func (o *CAN0_Type) SetRXIMR11_MI1(value uint32) {
	volatile.StoreUint32(&o.RXIMR11.Reg, volatile.LoadUint32(&o.RXIMR11.Reg)&^(0x2)|value<<1)
}
func (o *CAN0_Type) GetRXIMR11_MI1() uint32 {
	return (volatile.LoadUint32(&o.RXIMR11.Reg) & 0x2) >> 1
}
func (o *CAN0_Type) SetRXIMR11_MI2(value uint32) {
	volatile.StoreUint32(&o.RXIMR11.Reg, volatile.LoadUint32(&o.RXIMR11.Reg)&^(0x4)|value<<2)
}
func (o *CAN0_Type) GetRXIMR11_MI2() uint32 {
	return (volatile.LoadUint32(&o.RXIMR11.Reg) & 0x4) >> 2
}
func (o *CAN0_Type) SetRXIMR11_MI3(value uint32) {
	volatile.StoreUint32(&o.RXIMR11.Reg, volatile.LoadUint32(&o.RXIMR11.Reg)&^(0x8)|value<<3)
}
func (o *CAN0_Type) GetRXIMR11_MI3() uint32 {
	return (volatile.LoadUint32(&o.RXIMR11.Reg) & 0x8) >> 3
}
func (o *CAN0_Type) SetRXIMR11_MI4(value uint32) {
	volatile.StoreUint32(&o.RXIMR11.Reg, volatile.LoadUint32(&o.RXIMR11.Reg)&^(0x10)|value<<4)
}
func (o *CAN0_Type) GetRXIMR11_MI4() uint32 {
	return (volatile.LoadUint32(&o.RXIMR11.Reg) & 0x10) >> 4
}
func (o *CAN0_Type) SetRXIMR11_MI5(value uint32) {
	volatile.StoreUint32(&o.RXIMR11.Reg, volatile.LoadUint32(&o.RXIMR11.Reg)&^(0x20)|value<<5)
}
func (o *CAN0_Type) GetRXIMR11_MI5() uint32 {
	return (volatile.LoadUint32(&o.RXIMR11.Reg) & 0x20) >> 5
}
func (o *CAN0_Type) SetRXIMR11_MI6(value uint32) {
	volatile.StoreUint32(&o.RXIMR11.Reg, volatile.LoadUint32(&o.RXIMR11.Reg)&^(0x40)|value<<6)
}
func (o *CAN0_Type) GetRXIMR11_MI6() uint32 {
	return (volatile.LoadUint32(&o.RXIMR11.Reg) & 0x40) >> 6
}
func (o *CAN0_Type) SetRXIMR11_MI7(value uint32) {
	volatile.StoreUint32(&o.RXIMR11.Reg, volatile.LoadUint32(&o.RXIMR11.Reg)&^(0x80)|value<<7)
}
func (o *CAN0_Type) GetRXIMR11_MI7() uint32 {
	return (volatile.LoadUint32(&o.RXIMR11.Reg) & 0x80) >> 7
}
func (o *CAN0_Type) SetRXIMR11_MI8(value uint32) {
	volatile.StoreUint32(&o.RXIMR11.Reg, volatile.LoadUint32(&o.RXIMR11.Reg)&^(0x100)|value<<8)
}
func (o *CAN0_Type) GetRXIMR11_MI8() uint32 {
	return (volatile.LoadUint32(&o.RXIMR11.Reg) & 0x100) >> 8
}
func (o *CAN0_Type) SetRXIMR11_MI9(value uint32) {
	volatile.StoreUint32(&o.RXIMR11.Reg, volatile.LoadUint32(&o.RXIMR11.Reg)&^(0x200)|value<<9)
}
func (o *CAN0_Type) GetRXIMR11_MI9() uint32 {
	return (volatile.LoadUint32(&o.RXIMR11.Reg) & 0x200) >> 9
}
func (o *CAN0_Type) SetRXIMR11_MI10(value uint32) {
	volatile.StoreUint32(&o.RXIMR11.Reg, volatile.LoadUint32(&o.RXIMR11.Reg)&^(0x400)|value<<10)
}
func (o *CAN0_Type) GetRXIMR11_MI10() uint32 {
	return (volatile.LoadUint32(&o.RXIMR11.Reg) & 0x400) >> 10
}
func (o *CAN0_Type) SetRXIMR11_MI11(value uint32) {
	volatile.StoreUint32(&o.RXIMR11.Reg, volatile.LoadUint32(&o.RXIMR11.Reg)&^(0x800)|value<<11)
}
func (o *CAN0_Type) GetRXIMR11_MI11() uint32 {
	return (volatile.LoadUint32(&o.RXIMR11.Reg) & 0x800) >> 11
}
func (o *CAN0_Type) SetRXIMR11_MI12(value uint32) {
	volatile.StoreUint32(&o.RXIMR11.Reg, volatile.LoadUint32(&o.RXIMR11.Reg)&^(0x1000)|value<<12)
}
func (o *CAN0_Type) GetRXIMR11_MI12() uint32 {
	return (volatile.LoadUint32(&o.RXIMR11.Reg) & 0x1000) >> 12
}
func (o *CAN0_Type) SetRXIMR11_MI13(value uint32) {
	volatile.StoreUint32(&o.RXIMR11.Reg, volatile.LoadUint32(&o.RXIMR11.Reg)&^(0x2000)|value<<13)
}
func (o *CAN0_Type) GetRXIMR11_MI13() uint32 {
	return (volatile.LoadUint32(&o.RXIMR11.Reg) & 0x2000) >> 13
}
func (o *CAN0_Type) SetRXIMR11_MI14(value uint32) {
	volatile.StoreUint32(&o.RXIMR11.Reg, volatile.LoadUint32(&o.RXIMR11.Reg)&^(0x4000)|value<<14)
}
func (o *CAN0_Type) GetRXIMR11_MI14() uint32 {
	return (volatile.LoadUint32(&o.RXIMR11.Reg) & 0x4000) >> 14
}
func (o *CAN0_Type) SetRXIMR11_MI15(value uint32) {
	volatile.StoreUint32(&o.RXIMR11.Reg, volatile.LoadUint32(&o.RXIMR11.Reg)&^(0x8000)|value<<15)
}
func (o *CAN0_Type) GetRXIMR11_MI15() uint32 {
	return (volatile.LoadUint32(&o.RXIMR11.Reg) & 0x8000) >> 15
}
func (o *CAN0_Type) SetRXIMR11_MI16(value uint32) {
	volatile.StoreUint32(&o.RXIMR11.Reg, volatile.LoadUint32(&o.RXIMR11.Reg)&^(0x10000)|value<<16)
}
func (o *CAN0_Type) GetRXIMR11_MI16() uint32 {
	return (volatile.LoadUint32(&o.RXIMR11.Reg) & 0x10000) >> 16
}
func (o *CAN0_Type) SetRXIMR11_MI17(value uint32) {
	volatile.StoreUint32(&o.RXIMR11.Reg, volatile.LoadUint32(&o.RXIMR11.Reg)&^(0x20000)|value<<17)
}
func (o *CAN0_Type) GetRXIMR11_MI17() uint32 {
	return (volatile.LoadUint32(&o.RXIMR11.Reg) & 0x20000) >> 17
}
func (o *CAN0_Type) SetRXIMR11_MI18(value uint32) {
	volatile.StoreUint32(&o.RXIMR11.Reg, volatile.LoadUint32(&o.RXIMR11.Reg)&^(0x40000)|value<<18)
}
func (o *CAN0_Type) GetRXIMR11_MI18() uint32 {
	return (volatile.LoadUint32(&o.RXIMR11.Reg) & 0x40000) >> 18
}
func (o *CAN0_Type) SetRXIMR11_MI19(value uint32) {
	volatile.StoreUint32(&o.RXIMR11.Reg, volatile.LoadUint32(&o.RXIMR11.Reg)&^(0x80000)|value<<19)
}
func (o *CAN0_Type) GetRXIMR11_MI19() uint32 {
	return (volatile.LoadUint32(&o.RXIMR11.Reg) & 0x80000) >> 19
}
func (o *CAN0_Type) SetRXIMR11_MI20(value uint32) {
	volatile.StoreUint32(&o.RXIMR11.Reg, volatile.LoadUint32(&o.RXIMR11.Reg)&^(0x100000)|value<<20)
}
func (o *CAN0_Type) GetRXIMR11_MI20() uint32 {
	return (volatile.LoadUint32(&o.RXIMR11.Reg) & 0x100000) >> 20
}
func (o *CAN0_Type) SetRXIMR11_MI21(value uint32) {
	volatile.StoreUint32(&o.RXIMR11.Reg, volatile.LoadUint32(&o.RXIMR11.Reg)&^(0x200000)|value<<21)
}
func (o *CAN0_Type) GetRXIMR11_MI21() uint32 {
	return (volatile.LoadUint32(&o.RXIMR11.Reg) & 0x200000) >> 21
}
func (o *CAN0_Type) SetRXIMR11_MI22(value uint32) {
	volatile.StoreUint32(&o.RXIMR11.Reg, volatile.LoadUint32(&o.RXIMR11.Reg)&^(0x400000)|value<<22)
}
func (o *CAN0_Type) GetRXIMR11_MI22() uint32 {
	return (volatile.LoadUint32(&o.RXIMR11.Reg) & 0x400000) >> 22
}
func (o *CAN0_Type) SetRXIMR11_MI23(value uint32) {
	volatile.StoreUint32(&o.RXIMR11.Reg, volatile.LoadUint32(&o.RXIMR11.Reg)&^(0x800000)|value<<23)
}
func (o *CAN0_Type) GetRXIMR11_MI23() uint32 {
	return (volatile.LoadUint32(&o.RXIMR11.Reg) & 0x800000) >> 23
}
func (o *CAN0_Type) SetRXIMR11_MI24(value uint32) {
	volatile.StoreUint32(&o.RXIMR11.Reg, volatile.LoadUint32(&o.RXIMR11.Reg)&^(0x1000000)|value<<24)
}
func (o *CAN0_Type) GetRXIMR11_MI24() uint32 {
	return (volatile.LoadUint32(&o.RXIMR11.Reg) & 0x1000000) >> 24
}
func (o *CAN0_Type) SetRXIMR11_MI25(value uint32) {
	volatile.StoreUint32(&o.RXIMR11.Reg, volatile.LoadUint32(&o.RXIMR11.Reg)&^(0x2000000)|value<<25)
}
func (o *CAN0_Type) GetRXIMR11_MI25() uint32 {
	return (volatile.LoadUint32(&o.RXIMR11.Reg) & 0x2000000) >> 25
}
func (o *CAN0_Type) SetRXIMR11_MI26(value uint32) {
	volatile.StoreUint32(&o.RXIMR11.Reg, volatile.LoadUint32(&o.RXIMR11.Reg)&^(0x4000000)|value<<26)
}
func (o *CAN0_Type) GetRXIMR11_MI26() uint32 {
	return (volatile.LoadUint32(&o.RXIMR11.Reg) & 0x4000000) >> 26
}
func (o *CAN0_Type) SetRXIMR11_MI27(value uint32) {
	volatile.StoreUint32(&o.RXIMR11.Reg, volatile.LoadUint32(&o.RXIMR11.Reg)&^(0x8000000)|value<<27)
}
func (o *CAN0_Type) GetRXIMR11_MI27() uint32 {
	return (volatile.LoadUint32(&o.RXIMR11.Reg) & 0x8000000) >> 27
}
func (o *CAN0_Type) SetRXIMR11_MI28(value uint32) {
	volatile.StoreUint32(&o.RXIMR11.Reg, volatile.LoadUint32(&o.RXIMR11.Reg)&^(0x10000000)|value<<28)
}
func (o *CAN0_Type) GetRXIMR11_MI28() uint32 {
	return (volatile.LoadUint32(&o.RXIMR11.Reg) & 0x10000000) >> 28
}
func (o *CAN0_Type) SetRXIMR11_MI29(value uint32) {
	volatile.StoreUint32(&o.RXIMR11.Reg, volatile.LoadUint32(&o.RXIMR11.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetRXIMR11_MI29() uint32 {
	return (volatile.LoadUint32(&o.RXIMR11.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetRXIMR11_MI30(value uint32) {
	volatile.StoreUint32(&o.RXIMR11.Reg, volatile.LoadUint32(&o.RXIMR11.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetRXIMR11_MI30() uint32 {
	return (volatile.LoadUint32(&o.RXIMR11.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetRXIMR11_MI31(value uint32) {
	volatile.StoreUint32(&o.RXIMR11.Reg, volatile.LoadUint32(&o.RXIMR11.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetRXIMR11_MI31() uint32 {
	return (volatile.LoadUint32(&o.RXIMR11.Reg) & 0x80000000) >> 31
}

// CAN0.RXIMR12: Rx Individual Mask Registers
func (o *CAN0_Type) SetRXIMR12_MI0(value uint32) {
	volatile.StoreUint32(&o.RXIMR12.Reg, volatile.LoadUint32(&o.RXIMR12.Reg)&^(0x1)|value)
}
func (o *CAN0_Type) GetRXIMR12_MI0() uint32 {
	return volatile.LoadUint32(&o.RXIMR12.Reg) & 0x1
}
func (o *CAN0_Type) SetRXIMR12_MI1(value uint32) {
	volatile.StoreUint32(&o.RXIMR12.Reg, volatile.LoadUint32(&o.RXIMR12.Reg)&^(0x2)|value<<1)
}
func (o *CAN0_Type) GetRXIMR12_MI1() uint32 {
	return (volatile.LoadUint32(&o.RXIMR12.Reg) & 0x2) >> 1
}
func (o *CAN0_Type) SetRXIMR12_MI2(value uint32) {
	volatile.StoreUint32(&o.RXIMR12.Reg, volatile.LoadUint32(&o.RXIMR12.Reg)&^(0x4)|value<<2)
}
func (o *CAN0_Type) GetRXIMR12_MI2() uint32 {
	return (volatile.LoadUint32(&o.RXIMR12.Reg) & 0x4) >> 2
}
func (o *CAN0_Type) SetRXIMR12_MI3(value uint32) {
	volatile.StoreUint32(&o.RXIMR12.Reg, volatile.LoadUint32(&o.RXIMR12.Reg)&^(0x8)|value<<3)
}
func (o *CAN0_Type) GetRXIMR12_MI3() uint32 {
	return (volatile.LoadUint32(&o.RXIMR12.Reg) & 0x8) >> 3
}
func (o *CAN0_Type) SetRXIMR12_MI4(value uint32) {
	volatile.StoreUint32(&o.RXIMR12.Reg, volatile.LoadUint32(&o.RXIMR12.Reg)&^(0x10)|value<<4)
}
func (o *CAN0_Type) GetRXIMR12_MI4() uint32 {
	return (volatile.LoadUint32(&o.RXIMR12.Reg) & 0x10) >> 4
}
func (o *CAN0_Type) SetRXIMR12_MI5(value uint32) {
	volatile.StoreUint32(&o.RXIMR12.Reg, volatile.LoadUint32(&o.RXIMR12.Reg)&^(0x20)|value<<5)
}
func (o *CAN0_Type) GetRXIMR12_MI5() uint32 {
	return (volatile.LoadUint32(&o.RXIMR12.Reg) & 0x20) >> 5
}
func (o *CAN0_Type) SetRXIMR12_MI6(value uint32) {
	volatile.StoreUint32(&o.RXIMR12.Reg, volatile.LoadUint32(&o.RXIMR12.Reg)&^(0x40)|value<<6)
}
func (o *CAN0_Type) GetRXIMR12_MI6() uint32 {
	return (volatile.LoadUint32(&o.RXIMR12.Reg) & 0x40) >> 6
}
func (o *CAN0_Type) SetRXIMR12_MI7(value uint32) {
	volatile.StoreUint32(&o.RXIMR12.Reg, volatile.LoadUint32(&o.RXIMR12.Reg)&^(0x80)|value<<7)
}
func (o *CAN0_Type) GetRXIMR12_MI7() uint32 {
	return (volatile.LoadUint32(&o.RXIMR12.Reg) & 0x80) >> 7
}
func (o *CAN0_Type) SetRXIMR12_MI8(value uint32) {
	volatile.StoreUint32(&o.RXIMR12.Reg, volatile.LoadUint32(&o.RXIMR12.Reg)&^(0x100)|value<<8)
}
func (o *CAN0_Type) GetRXIMR12_MI8() uint32 {
	return (volatile.LoadUint32(&o.RXIMR12.Reg) & 0x100) >> 8
}
func (o *CAN0_Type) SetRXIMR12_MI9(value uint32) {
	volatile.StoreUint32(&o.RXIMR12.Reg, volatile.LoadUint32(&o.RXIMR12.Reg)&^(0x200)|value<<9)
}
func (o *CAN0_Type) GetRXIMR12_MI9() uint32 {
	return (volatile.LoadUint32(&o.RXIMR12.Reg) & 0x200) >> 9
}
func (o *CAN0_Type) SetRXIMR12_MI10(value uint32) {
	volatile.StoreUint32(&o.RXIMR12.Reg, volatile.LoadUint32(&o.RXIMR12.Reg)&^(0x400)|value<<10)
}
func (o *CAN0_Type) GetRXIMR12_MI10() uint32 {
	return (volatile.LoadUint32(&o.RXIMR12.Reg) & 0x400) >> 10
}
func (o *CAN0_Type) SetRXIMR12_MI11(value uint32) {
	volatile.StoreUint32(&o.RXIMR12.Reg, volatile.LoadUint32(&o.RXIMR12.Reg)&^(0x800)|value<<11)
}
func (o *CAN0_Type) GetRXIMR12_MI11() uint32 {
	return (volatile.LoadUint32(&o.RXIMR12.Reg) & 0x800) >> 11
}
func (o *CAN0_Type) SetRXIMR12_MI12(value uint32) {
	volatile.StoreUint32(&o.RXIMR12.Reg, volatile.LoadUint32(&o.RXIMR12.Reg)&^(0x1000)|value<<12)
}
func (o *CAN0_Type) GetRXIMR12_MI12() uint32 {
	return (volatile.LoadUint32(&o.RXIMR12.Reg) & 0x1000) >> 12
}
func (o *CAN0_Type) SetRXIMR12_MI13(value uint32) {
	volatile.StoreUint32(&o.RXIMR12.Reg, volatile.LoadUint32(&o.RXIMR12.Reg)&^(0x2000)|value<<13)
}
func (o *CAN0_Type) GetRXIMR12_MI13() uint32 {
	return (volatile.LoadUint32(&o.RXIMR12.Reg) & 0x2000) >> 13
}
func (o *CAN0_Type) SetRXIMR12_MI14(value uint32) {
	volatile.StoreUint32(&o.RXIMR12.Reg, volatile.LoadUint32(&o.RXIMR12.Reg)&^(0x4000)|value<<14)
}
func (o *CAN0_Type) GetRXIMR12_MI14() uint32 {
	return (volatile.LoadUint32(&o.RXIMR12.Reg) & 0x4000) >> 14
}
func (o *CAN0_Type) SetRXIMR12_MI15(value uint32) {
	volatile.StoreUint32(&o.RXIMR12.Reg, volatile.LoadUint32(&o.RXIMR12.Reg)&^(0x8000)|value<<15)
}
func (o *CAN0_Type) GetRXIMR12_MI15() uint32 {
	return (volatile.LoadUint32(&o.RXIMR12.Reg) & 0x8000) >> 15
}
func (o *CAN0_Type) SetRXIMR12_MI16(value uint32) {
	volatile.StoreUint32(&o.RXIMR12.Reg, volatile.LoadUint32(&o.RXIMR12.Reg)&^(0x10000)|value<<16)
}
func (o *CAN0_Type) GetRXIMR12_MI16() uint32 {
	return (volatile.LoadUint32(&o.RXIMR12.Reg) & 0x10000) >> 16
}
func (o *CAN0_Type) SetRXIMR12_MI17(value uint32) {
	volatile.StoreUint32(&o.RXIMR12.Reg, volatile.LoadUint32(&o.RXIMR12.Reg)&^(0x20000)|value<<17)
}
func (o *CAN0_Type) GetRXIMR12_MI17() uint32 {
	return (volatile.LoadUint32(&o.RXIMR12.Reg) & 0x20000) >> 17
}
func (o *CAN0_Type) SetRXIMR12_MI18(value uint32) {
	volatile.StoreUint32(&o.RXIMR12.Reg, volatile.LoadUint32(&o.RXIMR12.Reg)&^(0x40000)|value<<18)
}
func (o *CAN0_Type) GetRXIMR12_MI18() uint32 {
	return (volatile.LoadUint32(&o.RXIMR12.Reg) & 0x40000) >> 18
}
func (o *CAN0_Type) SetRXIMR12_MI19(value uint32) {
	volatile.StoreUint32(&o.RXIMR12.Reg, volatile.LoadUint32(&o.RXIMR12.Reg)&^(0x80000)|value<<19)
}
func (o *CAN0_Type) GetRXIMR12_MI19() uint32 {
	return (volatile.LoadUint32(&o.RXIMR12.Reg) & 0x80000) >> 19
}
func (o *CAN0_Type) SetRXIMR12_MI20(value uint32) {
	volatile.StoreUint32(&o.RXIMR12.Reg, volatile.LoadUint32(&o.RXIMR12.Reg)&^(0x100000)|value<<20)
}
func (o *CAN0_Type) GetRXIMR12_MI20() uint32 {
	return (volatile.LoadUint32(&o.RXIMR12.Reg) & 0x100000) >> 20
}
func (o *CAN0_Type) SetRXIMR12_MI21(value uint32) {
	volatile.StoreUint32(&o.RXIMR12.Reg, volatile.LoadUint32(&o.RXIMR12.Reg)&^(0x200000)|value<<21)
}
func (o *CAN0_Type) GetRXIMR12_MI21() uint32 {
	return (volatile.LoadUint32(&o.RXIMR12.Reg) & 0x200000) >> 21
}
func (o *CAN0_Type) SetRXIMR12_MI22(value uint32) {
	volatile.StoreUint32(&o.RXIMR12.Reg, volatile.LoadUint32(&o.RXIMR12.Reg)&^(0x400000)|value<<22)
}
func (o *CAN0_Type) GetRXIMR12_MI22() uint32 {
	return (volatile.LoadUint32(&o.RXIMR12.Reg) & 0x400000) >> 22
}
func (o *CAN0_Type) SetRXIMR12_MI23(value uint32) {
	volatile.StoreUint32(&o.RXIMR12.Reg, volatile.LoadUint32(&o.RXIMR12.Reg)&^(0x800000)|value<<23)
}
func (o *CAN0_Type) GetRXIMR12_MI23() uint32 {
	return (volatile.LoadUint32(&o.RXIMR12.Reg) & 0x800000) >> 23
}
func (o *CAN0_Type) SetRXIMR12_MI24(value uint32) {
	volatile.StoreUint32(&o.RXIMR12.Reg, volatile.LoadUint32(&o.RXIMR12.Reg)&^(0x1000000)|value<<24)
}
func (o *CAN0_Type) GetRXIMR12_MI24() uint32 {
	return (volatile.LoadUint32(&o.RXIMR12.Reg) & 0x1000000) >> 24
}
func (o *CAN0_Type) SetRXIMR12_MI25(value uint32) {
	volatile.StoreUint32(&o.RXIMR12.Reg, volatile.LoadUint32(&o.RXIMR12.Reg)&^(0x2000000)|value<<25)
}
func (o *CAN0_Type) GetRXIMR12_MI25() uint32 {
	return (volatile.LoadUint32(&o.RXIMR12.Reg) & 0x2000000) >> 25
}
func (o *CAN0_Type) SetRXIMR12_MI26(value uint32) {
	volatile.StoreUint32(&o.RXIMR12.Reg, volatile.LoadUint32(&o.RXIMR12.Reg)&^(0x4000000)|value<<26)
}
func (o *CAN0_Type) GetRXIMR12_MI26() uint32 {
	return (volatile.LoadUint32(&o.RXIMR12.Reg) & 0x4000000) >> 26
}
func (o *CAN0_Type) SetRXIMR12_MI27(value uint32) {
	volatile.StoreUint32(&o.RXIMR12.Reg, volatile.LoadUint32(&o.RXIMR12.Reg)&^(0x8000000)|value<<27)
}
func (o *CAN0_Type) GetRXIMR12_MI27() uint32 {
	return (volatile.LoadUint32(&o.RXIMR12.Reg) & 0x8000000) >> 27
}
func (o *CAN0_Type) SetRXIMR12_MI28(value uint32) {
	volatile.StoreUint32(&o.RXIMR12.Reg, volatile.LoadUint32(&o.RXIMR12.Reg)&^(0x10000000)|value<<28)
}
func (o *CAN0_Type) GetRXIMR12_MI28() uint32 {
	return (volatile.LoadUint32(&o.RXIMR12.Reg) & 0x10000000) >> 28
}
func (o *CAN0_Type) SetRXIMR12_MI29(value uint32) {
	volatile.StoreUint32(&o.RXIMR12.Reg, volatile.LoadUint32(&o.RXIMR12.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetRXIMR12_MI29() uint32 {
	return (volatile.LoadUint32(&o.RXIMR12.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetRXIMR12_MI30(value uint32) {
	volatile.StoreUint32(&o.RXIMR12.Reg, volatile.LoadUint32(&o.RXIMR12.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetRXIMR12_MI30() uint32 {
	return (volatile.LoadUint32(&o.RXIMR12.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetRXIMR12_MI31(value uint32) {
	volatile.StoreUint32(&o.RXIMR12.Reg, volatile.LoadUint32(&o.RXIMR12.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetRXIMR12_MI31() uint32 {
	return (volatile.LoadUint32(&o.RXIMR12.Reg) & 0x80000000) >> 31
}

// CAN0.RXIMR13: Rx Individual Mask Registers
func (o *CAN0_Type) SetRXIMR13_MI0(value uint32) {
	volatile.StoreUint32(&o.RXIMR13.Reg, volatile.LoadUint32(&o.RXIMR13.Reg)&^(0x1)|value)
}
func (o *CAN0_Type) GetRXIMR13_MI0() uint32 {
	return volatile.LoadUint32(&o.RXIMR13.Reg) & 0x1
}
func (o *CAN0_Type) SetRXIMR13_MI1(value uint32) {
	volatile.StoreUint32(&o.RXIMR13.Reg, volatile.LoadUint32(&o.RXIMR13.Reg)&^(0x2)|value<<1)
}
func (o *CAN0_Type) GetRXIMR13_MI1() uint32 {
	return (volatile.LoadUint32(&o.RXIMR13.Reg) & 0x2) >> 1
}
func (o *CAN0_Type) SetRXIMR13_MI2(value uint32) {
	volatile.StoreUint32(&o.RXIMR13.Reg, volatile.LoadUint32(&o.RXIMR13.Reg)&^(0x4)|value<<2)
}
func (o *CAN0_Type) GetRXIMR13_MI2() uint32 {
	return (volatile.LoadUint32(&o.RXIMR13.Reg) & 0x4) >> 2
}
func (o *CAN0_Type) SetRXIMR13_MI3(value uint32) {
	volatile.StoreUint32(&o.RXIMR13.Reg, volatile.LoadUint32(&o.RXIMR13.Reg)&^(0x8)|value<<3)
}
func (o *CAN0_Type) GetRXIMR13_MI3() uint32 {
	return (volatile.LoadUint32(&o.RXIMR13.Reg) & 0x8) >> 3
}
func (o *CAN0_Type) SetRXIMR13_MI4(value uint32) {
	volatile.StoreUint32(&o.RXIMR13.Reg, volatile.LoadUint32(&o.RXIMR13.Reg)&^(0x10)|value<<4)
}
func (o *CAN0_Type) GetRXIMR13_MI4() uint32 {
	return (volatile.LoadUint32(&o.RXIMR13.Reg) & 0x10) >> 4
}
func (o *CAN0_Type) SetRXIMR13_MI5(value uint32) {
	volatile.StoreUint32(&o.RXIMR13.Reg, volatile.LoadUint32(&o.RXIMR13.Reg)&^(0x20)|value<<5)
}
func (o *CAN0_Type) GetRXIMR13_MI5() uint32 {
	return (volatile.LoadUint32(&o.RXIMR13.Reg) & 0x20) >> 5
}
func (o *CAN0_Type) SetRXIMR13_MI6(value uint32) {
	volatile.StoreUint32(&o.RXIMR13.Reg, volatile.LoadUint32(&o.RXIMR13.Reg)&^(0x40)|value<<6)
}
func (o *CAN0_Type) GetRXIMR13_MI6() uint32 {
	return (volatile.LoadUint32(&o.RXIMR13.Reg) & 0x40) >> 6
}
func (o *CAN0_Type) SetRXIMR13_MI7(value uint32) {
	volatile.StoreUint32(&o.RXIMR13.Reg, volatile.LoadUint32(&o.RXIMR13.Reg)&^(0x80)|value<<7)
}
func (o *CAN0_Type) GetRXIMR13_MI7() uint32 {
	return (volatile.LoadUint32(&o.RXIMR13.Reg) & 0x80) >> 7
}
func (o *CAN0_Type) SetRXIMR13_MI8(value uint32) {
	volatile.StoreUint32(&o.RXIMR13.Reg, volatile.LoadUint32(&o.RXIMR13.Reg)&^(0x100)|value<<8)
}
func (o *CAN0_Type) GetRXIMR13_MI8() uint32 {
	return (volatile.LoadUint32(&o.RXIMR13.Reg) & 0x100) >> 8
}
func (o *CAN0_Type) SetRXIMR13_MI9(value uint32) {
	volatile.StoreUint32(&o.RXIMR13.Reg, volatile.LoadUint32(&o.RXIMR13.Reg)&^(0x200)|value<<9)
}
func (o *CAN0_Type) GetRXIMR13_MI9() uint32 {
	return (volatile.LoadUint32(&o.RXIMR13.Reg) & 0x200) >> 9
}
func (o *CAN0_Type) SetRXIMR13_MI10(value uint32) {
	volatile.StoreUint32(&o.RXIMR13.Reg, volatile.LoadUint32(&o.RXIMR13.Reg)&^(0x400)|value<<10)
}
func (o *CAN0_Type) GetRXIMR13_MI10() uint32 {
	return (volatile.LoadUint32(&o.RXIMR13.Reg) & 0x400) >> 10
}
func (o *CAN0_Type) SetRXIMR13_MI11(value uint32) {
	volatile.StoreUint32(&o.RXIMR13.Reg, volatile.LoadUint32(&o.RXIMR13.Reg)&^(0x800)|value<<11)
}
func (o *CAN0_Type) GetRXIMR13_MI11() uint32 {
	return (volatile.LoadUint32(&o.RXIMR13.Reg) & 0x800) >> 11
}
func (o *CAN0_Type) SetRXIMR13_MI12(value uint32) {
	volatile.StoreUint32(&o.RXIMR13.Reg, volatile.LoadUint32(&o.RXIMR13.Reg)&^(0x1000)|value<<12)
}
func (o *CAN0_Type) GetRXIMR13_MI12() uint32 {
	return (volatile.LoadUint32(&o.RXIMR13.Reg) & 0x1000) >> 12
}
func (o *CAN0_Type) SetRXIMR13_MI13(value uint32) {
	volatile.StoreUint32(&o.RXIMR13.Reg, volatile.LoadUint32(&o.RXIMR13.Reg)&^(0x2000)|value<<13)
}
func (o *CAN0_Type) GetRXIMR13_MI13() uint32 {
	return (volatile.LoadUint32(&o.RXIMR13.Reg) & 0x2000) >> 13
}
func (o *CAN0_Type) SetRXIMR13_MI14(value uint32) {
	volatile.StoreUint32(&o.RXIMR13.Reg, volatile.LoadUint32(&o.RXIMR13.Reg)&^(0x4000)|value<<14)
}
func (o *CAN0_Type) GetRXIMR13_MI14() uint32 {
	return (volatile.LoadUint32(&o.RXIMR13.Reg) & 0x4000) >> 14
}
func (o *CAN0_Type) SetRXIMR13_MI15(value uint32) {
	volatile.StoreUint32(&o.RXIMR13.Reg, volatile.LoadUint32(&o.RXIMR13.Reg)&^(0x8000)|value<<15)
}
func (o *CAN0_Type) GetRXIMR13_MI15() uint32 {
	return (volatile.LoadUint32(&o.RXIMR13.Reg) & 0x8000) >> 15
}
func (o *CAN0_Type) SetRXIMR13_MI16(value uint32) {
	volatile.StoreUint32(&o.RXIMR13.Reg, volatile.LoadUint32(&o.RXIMR13.Reg)&^(0x10000)|value<<16)
}
func (o *CAN0_Type) GetRXIMR13_MI16() uint32 {
	return (volatile.LoadUint32(&o.RXIMR13.Reg) & 0x10000) >> 16
}
func (o *CAN0_Type) SetRXIMR13_MI17(value uint32) {
	volatile.StoreUint32(&o.RXIMR13.Reg, volatile.LoadUint32(&o.RXIMR13.Reg)&^(0x20000)|value<<17)
}
func (o *CAN0_Type) GetRXIMR13_MI17() uint32 {
	return (volatile.LoadUint32(&o.RXIMR13.Reg) & 0x20000) >> 17
}
func (o *CAN0_Type) SetRXIMR13_MI18(value uint32) {
	volatile.StoreUint32(&o.RXIMR13.Reg, volatile.LoadUint32(&o.RXIMR13.Reg)&^(0x40000)|value<<18)
}
func (o *CAN0_Type) GetRXIMR13_MI18() uint32 {
	return (volatile.LoadUint32(&o.RXIMR13.Reg) & 0x40000) >> 18
}
func (o *CAN0_Type) SetRXIMR13_MI19(value uint32) {
	volatile.StoreUint32(&o.RXIMR13.Reg, volatile.LoadUint32(&o.RXIMR13.Reg)&^(0x80000)|value<<19)
}
func (o *CAN0_Type) GetRXIMR13_MI19() uint32 {
	return (volatile.LoadUint32(&o.RXIMR13.Reg) & 0x80000) >> 19
}
func (o *CAN0_Type) SetRXIMR13_MI20(value uint32) {
	volatile.StoreUint32(&o.RXIMR13.Reg, volatile.LoadUint32(&o.RXIMR13.Reg)&^(0x100000)|value<<20)
}
func (o *CAN0_Type) GetRXIMR13_MI20() uint32 {
	return (volatile.LoadUint32(&o.RXIMR13.Reg) & 0x100000) >> 20
}
func (o *CAN0_Type) SetRXIMR13_MI21(value uint32) {
	volatile.StoreUint32(&o.RXIMR13.Reg, volatile.LoadUint32(&o.RXIMR13.Reg)&^(0x200000)|value<<21)
}
func (o *CAN0_Type) GetRXIMR13_MI21() uint32 {
	return (volatile.LoadUint32(&o.RXIMR13.Reg) & 0x200000) >> 21
}
func (o *CAN0_Type) SetRXIMR13_MI22(value uint32) {
	volatile.StoreUint32(&o.RXIMR13.Reg, volatile.LoadUint32(&o.RXIMR13.Reg)&^(0x400000)|value<<22)
}
func (o *CAN0_Type) GetRXIMR13_MI22() uint32 {
	return (volatile.LoadUint32(&o.RXIMR13.Reg) & 0x400000) >> 22
}
func (o *CAN0_Type) SetRXIMR13_MI23(value uint32) {
	volatile.StoreUint32(&o.RXIMR13.Reg, volatile.LoadUint32(&o.RXIMR13.Reg)&^(0x800000)|value<<23)
}
func (o *CAN0_Type) GetRXIMR13_MI23() uint32 {
	return (volatile.LoadUint32(&o.RXIMR13.Reg) & 0x800000) >> 23
}
func (o *CAN0_Type) SetRXIMR13_MI24(value uint32) {
	volatile.StoreUint32(&o.RXIMR13.Reg, volatile.LoadUint32(&o.RXIMR13.Reg)&^(0x1000000)|value<<24)
}
func (o *CAN0_Type) GetRXIMR13_MI24() uint32 {
	return (volatile.LoadUint32(&o.RXIMR13.Reg) & 0x1000000) >> 24
}
func (o *CAN0_Type) SetRXIMR13_MI25(value uint32) {
	volatile.StoreUint32(&o.RXIMR13.Reg, volatile.LoadUint32(&o.RXIMR13.Reg)&^(0x2000000)|value<<25)
}
func (o *CAN0_Type) GetRXIMR13_MI25() uint32 {
	return (volatile.LoadUint32(&o.RXIMR13.Reg) & 0x2000000) >> 25
}
func (o *CAN0_Type) SetRXIMR13_MI26(value uint32) {
	volatile.StoreUint32(&o.RXIMR13.Reg, volatile.LoadUint32(&o.RXIMR13.Reg)&^(0x4000000)|value<<26)
}
func (o *CAN0_Type) GetRXIMR13_MI26() uint32 {
	return (volatile.LoadUint32(&o.RXIMR13.Reg) & 0x4000000) >> 26
}
func (o *CAN0_Type) SetRXIMR13_MI27(value uint32) {
	volatile.StoreUint32(&o.RXIMR13.Reg, volatile.LoadUint32(&o.RXIMR13.Reg)&^(0x8000000)|value<<27)
}
func (o *CAN0_Type) GetRXIMR13_MI27() uint32 {
	return (volatile.LoadUint32(&o.RXIMR13.Reg) & 0x8000000) >> 27
}
func (o *CAN0_Type) SetRXIMR13_MI28(value uint32) {
	volatile.StoreUint32(&o.RXIMR13.Reg, volatile.LoadUint32(&o.RXIMR13.Reg)&^(0x10000000)|value<<28)
}
func (o *CAN0_Type) GetRXIMR13_MI28() uint32 {
	return (volatile.LoadUint32(&o.RXIMR13.Reg) & 0x10000000) >> 28
}
func (o *CAN0_Type) SetRXIMR13_MI29(value uint32) {
	volatile.StoreUint32(&o.RXIMR13.Reg, volatile.LoadUint32(&o.RXIMR13.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetRXIMR13_MI29() uint32 {
	return (volatile.LoadUint32(&o.RXIMR13.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetRXIMR13_MI30(value uint32) {
	volatile.StoreUint32(&o.RXIMR13.Reg, volatile.LoadUint32(&o.RXIMR13.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetRXIMR13_MI30() uint32 {
	return (volatile.LoadUint32(&o.RXIMR13.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetRXIMR13_MI31(value uint32) {
	volatile.StoreUint32(&o.RXIMR13.Reg, volatile.LoadUint32(&o.RXIMR13.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetRXIMR13_MI31() uint32 {
	return (volatile.LoadUint32(&o.RXIMR13.Reg) & 0x80000000) >> 31
}

// CAN0.RXIMR14: Rx Individual Mask Registers
func (o *CAN0_Type) SetRXIMR14_MI0(value uint32) {
	volatile.StoreUint32(&o.RXIMR14.Reg, volatile.LoadUint32(&o.RXIMR14.Reg)&^(0x1)|value)
}
func (o *CAN0_Type) GetRXIMR14_MI0() uint32 {
	return volatile.LoadUint32(&o.RXIMR14.Reg) & 0x1
}
func (o *CAN0_Type) SetRXIMR14_MI1(value uint32) {
	volatile.StoreUint32(&o.RXIMR14.Reg, volatile.LoadUint32(&o.RXIMR14.Reg)&^(0x2)|value<<1)
}
func (o *CAN0_Type) GetRXIMR14_MI1() uint32 {
	return (volatile.LoadUint32(&o.RXIMR14.Reg) & 0x2) >> 1
}
func (o *CAN0_Type) SetRXIMR14_MI2(value uint32) {
	volatile.StoreUint32(&o.RXIMR14.Reg, volatile.LoadUint32(&o.RXIMR14.Reg)&^(0x4)|value<<2)
}
func (o *CAN0_Type) GetRXIMR14_MI2() uint32 {
	return (volatile.LoadUint32(&o.RXIMR14.Reg) & 0x4) >> 2
}
func (o *CAN0_Type) SetRXIMR14_MI3(value uint32) {
	volatile.StoreUint32(&o.RXIMR14.Reg, volatile.LoadUint32(&o.RXIMR14.Reg)&^(0x8)|value<<3)
}
func (o *CAN0_Type) GetRXIMR14_MI3() uint32 {
	return (volatile.LoadUint32(&o.RXIMR14.Reg) & 0x8) >> 3
}
func (o *CAN0_Type) SetRXIMR14_MI4(value uint32) {
	volatile.StoreUint32(&o.RXIMR14.Reg, volatile.LoadUint32(&o.RXIMR14.Reg)&^(0x10)|value<<4)
}
func (o *CAN0_Type) GetRXIMR14_MI4() uint32 {
	return (volatile.LoadUint32(&o.RXIMR14.Reg) & 0x10) >> 4
}
func (o *CAN0_Type) SetRXIMR14_MI5(value uint32) {
	volatile.StoreUint32(&o.RXIMR14.Reg, volatile.LoadUint32(&o.RXIMR14.Reg)&^(0x20)|value<<5)
}
func (o *CAN0_Type) GetRXIMR14_MI5() uint32 {
	return (volatile.LoadUint32(&o.RXIMR14.Reg) & 0x20) >> 5
}
func (o *CAN0_Type) SetRXIMR14_MI6(value uint32) {
	volatile.StoreUint32(&o.RXIMR14.Reg, volatile.LoadUint32(&o.RXIMR14.Reg)&^(0x40)|value<<6)
}
func (o *CAN0_Type) GetRXIMR14_MI6() uint32 {
	return (volatile.LoadUint32(&o.RXIMR14.Reg) & 0x40) >> 6
}
func (o *CAN0_Type) SetRXIMR14_MI7(value uint32) {
	volatile.StoreUint32(&o.RXIMR14.Reg, volatile.LoadUint32(&o.RXIMR14.Reg)&^(0x80)|value<<7)
}
func (o *CAN0_Type) GetRXIMR14_MI7() uint32 {
	return (volatile.LoadUint32(&o.RXIMR14.Reg) & 0x80) >> 7
}
func (o *CAN0_Type) SetRXIMR14_MI8(value uint32) {
	volatile.StoreUint32(&o.RXIMR14.Reg, volatile.LoadUint32(&o.RXIMR14.Reg)&^(0x100)|value<<8)
}
func (o *CAN0_Type) GetRXIMR14_MI8() uint32 {
	return (volatile.LoadUint32(&o.RXIMR14.Reg) & 0x100) >> 8
}
func (o *CAN0_Type) SetRXIMR14_MI9(value uint32) {
	volatile.StoreUint32(&o.RXIMR14.Reg, volatile.LoadUint32(&o.RXIMR14.Reg)&^(0x200)|value<<9)
}
func (o *CAN0_Type) GetRXIMR14_MI9() uint32 {
	return (volatile.LoadUint32(&o.RXIMR14.Reg) & 0x200) >> 9
}
func (o *CAN0_Type) SetRXIMR14_MI10(value uint32) {
	volatile.StoreUint32(&o.RXIMR14.Reg, volatile.LoadUint32(&o.RXIMR14.Reg)&^(0x400)|value<<10)
}
func (o *CAN0_Type) GetRXIMR14_MI10() uint32 {
	return (volatile.LoadUint32(&o.RXIMR14.Reg) & 0x400) >> 10
}
func (o *CAN0_Type) SetRXIMR14_MI11(value uint32) {
	volatile.StoreUint32(&o.RXIMR14.Reg, volatile.LoadUint32(&o.RXIMR14.Reg)&^(0x800)|value<<11)
}
func (o *CAN0_Type) GetRXIMR14_MI11() uint32 {
	return (volatile.LoadUint32(&o.RXIMR14.Reg) & 0x800) >> 11
}
func (o *CAN0_Type) SetRXIMR14_MI12(value uint32) {
	volatile.StoreUint32(&o.RXIMR14.Reg, volatile.LoadUint32(&o.RXIMR14.Reg)&^(0x1000)|value<<12)
}
func (o *CAN0_Type) GetRXIMR14_MI12() uint32 {
	return (volatile.LoadUint32(&o.RXIMR14.Reg) & 0x1000) >> 12
}
func (o *CAN0_Type) SetRXIMR14_MI13(value uint32) {
	volatile.StoreUint32(&o.RXIMR14.Reg, volatile.LoadUint32(&o.RXIMR14.Reg)&^(0x2000)|value<<13)
}
func (o *CAN0_Type) GetRXIMR14_MI13() uint32 {
	return (volatile.LoadUint32(&o.RXIMR14.Reg) & 0x2000) >> 13
}
func (o *CAN0_Type) SetRXIMR14_MI14(value uint32) {
	volatile.StoreUint32(&o.RXIMR14.Reg, volatile.LoadUint32(&o.RXIMR14.Reg)&^(0x4000)|value<<14)
}
func (o *CAN0_Type) GetRXIMR14_MI14() uint32 {
	return (volatile.LoadUint32(&o.RXIMR14.Reg) & 0x4000) >> 14
}
func (o *CAN0_Type) SetRXIMR14_MI15(value uint32) {
	volatile.StoreUint32(&o.RXIMR14.Reg, volatile.LoadUint32(&o.RXIMR14.Reg)&^(0x8000)|value<<15)
}
func (o *CAN0_Type) GetRXIMR14_MI15() uint32 {
	return (volatile.LoadUint32(&o.RXIMR14.Reg) & 0x8000) >> 15
}
func (o *CAN0_Type) SetRXIMR14_MI16(value uint32) {
	volatile.StoreUint32(&o.RXIMR14.Reg, volatile.LoadUint32(&o.RXIMR14.Reg)&^(0x10000)|value<<16)
}
func (o *CAN0_Type) GetRXIMR14_MI16() uint32 {
	return (volatile.LoadUint32(&o.RXIMR14.Reg) & 0x10000) >> 16
}
func (o *CAN0_Type) SetRXIMR14_MI17(value uint32) {
	volatile.StoreUint32(&o.RXIMR14.Reg, volatile.LoadUint32(&o.RXIMR14.Reg)&^(0x20000)|value<<17)
}
func (o *CAN0_Type) GetRXIMR14_MI17() uint32 {
	return (volatile.LoadUint32(&o.RXIMR14.Reg) & 0x20000) >> 17
}
func (o *CAN0_Type) SetRXIMR14_MI18(value uint32) {
	volatile.StoreUint32(&o.RXIMR14.Reg, volatile.LoadUint32(&o.RXIMR14.Reg)&^(0x40000)|value<<18)
}
func (o *CAN0_Type) GetRXIMR14_MI18() uint32 {
	return (volatile.LoadUint32(&o.RXIMR14.Reg) & 0x40000) >> 18
}
func (o *CAN0_Type) SetRXIMR14_MI19(value uint32) {
	volatile.StoreUint32(&o.RXIMR14.Reg, volatile.LoadUint32(&o.RXIMR14.Reg)&^(0x80000)|value<<19)
}
func (o *CAN0_Type) GetRXIMR14_MI19() uint32 {
	return (volatile.LoadUint32(&o.RXIMR14.Reg) & 0x80000) >> 19
}
func (o *CAN0_Type) SetRXIMR14_MI20(value uint32) {
	volatile.StoreUint32(&o.RXIMR14.Reg, volatile.LoadUint32(&o.RXIMR14.Reg)&^(0x100000)|value<<20)
}
func (o *CAN0_Type) GetRXIMR14_MI20() uint32 {
	return (volatile.LoadUint32(&o.RXIMR14.Reg) & 0x100000) >> 20
}
func (o *CAN0_Type) SetRXIMR14_MI21(value uint32) {
	volatile.StoreUint32(&o.RXIMR14.Reg, volatile.LoadUint32(&o.RXIMR14.Reg)&^(0x200000)|value<<21)
}
func (o *CAN0_Type) GetRXIMR14_MI21() uint32 {
	return (volatile.LoadUint32(&o.RXIMR14.Reg) & 0x200000) >> 21
}
func (o *CAN0_Type) SetRXIMR14_MI22(value uint32) {
	volatile.StoreUint32(&o.RXIMR14.Reg, volatile.LoadUint32(&o.RXIMR14.Reg)&^(0x400000)|value<<22)
}
func (o *CAN0_Type) GetRXIMR14_MI22() uint32 {
	return (volatile.LoadUint32(&o.RXIMR14.Reg) & 0x400000) >> 22
}
func (o *CAN0_Type) SetRXIMR14_MI23(value uint32) {
	volatile.StoreUint32(&o.RXIMR14.Reg, volatile.LoadUint32(&o.RXIMR14.Reg)&^(0x800000)|value<<23)
}
func (o *CAN0_Type) GetRXIMR14_MI23() uint32 {
	return (volatile.LoadUint32(&o.RXIMR14.Reg) & 0x800000) >> 23
}
func (o *CAN0_Type) SetRXIMR14_MI24(value uint32) {
	volatile.StoreUint32(&o.RXIMR14.Reg, volatile.LoadUint32(&o.RXIMR14.Reg)&^(0x1000000)|value<<24)
}
func (o *CAN0_Type) GetRXIMR14_MI24() uint32 {
	return (volatile.LoadUint32(&o.RXIMR14.Reg) & 0x1000000) >> 24
}
func (o *CAN0_Type) SetRXIMR14_MI25(value uint32) {
	volatile.StoreUint32(&o.RXIMR14.Reg, volatile.LoadUint32(&o.RXIMR14.Reg)&^(0x2000000)|value<<25)
}
func (o *CAN0_Type) GetRXIMR14_MI25() uint32 {
	return (volatile.LoadUint32(&o.RXIMR14.Reg) & 0x2000000) >> 25
}
func (o *CAN0_Type) SetRXIMR14_MI26(value uint32) {
	volatile.StoreUint32(&o.RXIMR14.Reg, volatile.LoadUint32(&o.RXIMR14.Reg)&^(0x4000000)|value<<26)
}
func (o *CAN0_Type) GetRXIMR14_MI26() uint32 {
	return (volatile.LoadUint32(&o.RXIMR14.Reg) & 0x4000000) >> 26
}
func (o *CAN0_Type) SetRXIMR14_MI27(value uint32) {
	volatile.StoreUint32(&o.RXIMR14.Reg, volatile.LoadUint32(&o.RXIMR14.Reg)&^(0x8000000)|value<<27)
}
func (o *CAN0_Type) GetRXIMR14_MI27() uint32 {
	return (volatile.LoadUint32(&o.RXIMR14.Reg) & 0x8000000) >> 27
}
func (o *CAN0_Type) SetRXIMR14_MI28(value uint32) {
	volatile.StoreUint32(&o.RXIMR14.Reg, volatile.LoadUint32(&o.RXIMR14.Reg)&^(0x10000000)|value<<28)
}
func (o *CAN0_Type) GetRXIMR14_MI28() uint32 {
	return (volatile.LoadUint32(&o.RXIMR14.Reg) & 0x10000000) >> 28
}
func (o *CAN0_Type) SetRXIMR14_MI29(value uint32) {
	volatile.StoreUint32(&o.RXIMR14.Reg, volatile.LoadUint32(&o.RXIMR14.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetRXIMR14_MI29() uint32 {
	return (volatile.LoadUint32(&o.RXIMR14.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetRXIMR14_MI30(value uint32) {
	volatile.StoreUint32(&o.RXIMR14.Reg, volatile.LoadUint32(&o.RXIMR14.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetRXIMR14_MI30() uint32 {
	return (volatile.LoadUint32(&o.RXIMR14.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetRXIMR14_MI31(value uint32) {
	volatile.StoreUint32(&o.RXIMR14.Reg, volatile.LoadUint32(&o.RXIMR14.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetRXIMR14_MI31() uint32 {
	return (volatile.LoadUint32(&o.RXIMR14.Reg) & 0x80000000) >> 31
}

// CAN0.RXIMR15: Rx Individual Mask Registers
func (o *CAN0_Type) SetRXIMR15_MI0(value uint32) {
	volatile.StoreUint32(&o.RXIMR15.Reg, volatile.LoadUint32(&o.RXIMR15.Reg)&^(0x1)|value)
}
func (o *CAN0_Type) GetRXIMR15_MI0() uint32 {
	return volatile.LoadUint32(&o.RXIMR15.Reg) & 0x1
}
func (o *CAN0_Type) SetRXIMR15_MI1(value uint32) {
	volatile.StoreUint32(&o.RXIMR15.Reg, volatile.LoadUint32(&o.RXIMR15.Reg)&^(0x2)|value<<1)
}
func (o *CAN0_Type) GetRXIMR15_MI1() uint32 {
	return (volatile.LoadUint32(&o.RXIMR15.Reg) & 0x2) >> 1
}
func (o *CAN0_Type) SetRXIMR15_MI2(value uint32) {
	volatile.StoreUint32(&o.RXIMR15.Reg, volatile.LoadUint32(&o.RXIMR15.Reg)&^(0x4)|value<<2)
}
func (o *CAN0_Type) GetRXIMR15_MI2() uint32 {
	return (volatile.LoadUint32(&o.RXIMR15.Reg) & 0x4) >> 2
}
func (o *CAN0_Type) SetRXIMR15_MI3(value uint32) {
	volatile.StoreUint32(&o.RXIMR15.Reg, volatile.LoadUint32(&o.RXIMR15.Reg)&^(0x8)|value<<3)
}
func (o *CAN0_Type) GetRXIMR15_MI3() uint32 {
	return (volatile.LoadUint32(&o.RXIMR15.Reg) & 0x8) >> 3
}
func (o *CAN0_Type) SetRXIMR15_MI4(value uint32) {
	volatile.StoreUint32(&o.RXIMR15.Reg, volatile.LoadUint32(&o.RXIMR15.Reg)&^(0x10)|value<<4)
}
func (o *CAN0_Type) GetRXIMR15_MI4() uint32 {
	return (volatile.LoadUint32(&o.RXIMR15.Reg) & 0x10) >> 4
}
func (o *CAN0_Type) SetRXIMR15_MI5(value uint32) {
	volatile.StoreUint32(&o.RXIMR15.Reg, volatile.LoadUint32(&o.RXIMR15.Reg)&^(0x20)|value<<5)
}
func (o *CAN0_Type) GetRXIMR15_MI5() uint32 {
	return (volatile.LoadUint32(&o.RXIMR15.Reg) & 0x20) >> 5
}
func (o *CAN0_Type) SetRXIMR15_MI6(value uint32) {
	volatile.StoreUint32(&o.RXIMR15.Reg, volatile.LoadUint32(&o.RXIMR15.Reg)&^(0x40)|value<<6)
}
func (o *CAN0_Type) GetRXIMR15_MI6() uint32 {
	return (volatile.LoadUint32(&o.RXIMR15.Reg) & 0x40) >> 6
}
func (o *CAN0_Type) SetRXIMR15_MI7(value uint32) {
	volatile.StoreUint32(&o.RXIMR15.Reg, volatile.LoadUint32(&o.RXIMR15.Reg)&^(0x80)|value<<7)
}
func (o *CAN0_Type) GetRXIMR15_MI7() uint32 {
	return (volatile.LoadUint32(&o.RXIMR15.Reg) & 0x80) >> 7
}
func (o *CAN0_Type) SetRXIMR15_MI8(value uint32) {
	volatile.StoreUint32(&o.RXIMR15.Reg, volatile.LoadUint32(&o.RXIMR15.Reg)&^(0x100)|value<<8)
}
func (o *CAN0_Type) GetRXIMR15_MI8() uint32 {
	return (volatile.LoadUint32(&o.RXIMR15.Reg) & 0x100) >> 8
}
func (o *CAN0_Type) SetRXIMR15_MI9(value uint32) {
	volatile.StoreUint32(&o.RXIMR15.Reg, volatile.LoadUint32(&o.RXIMR15.Reg)&^(0x200)|value<<9)
}
func (o *CAN0_Type) GetRXIMR15_MI9() uint32 {
	return (volatile.LoadUint32(&o.RXIMR15.Reg) & 0x200) >> 9
}
func (o *CAN0_Type) SetRXIMR15_MI10(value uint32) {
	volatile.StoreUint32(&o.RXIMR15.Reg, volatile.LoadUint32(&o.RXIMR15.Reg)&^(0x400)|value<<10)
}
func (o *CAN0_Type) GetRXIMR15_MI10() uint32 {
	return (volatile.LoadUint32(&o.RXIMR15.Reg) & 0x400) >> 10
}
func (o *CAN0_Type) SetRXIMR15_MI11(value uint32) {
	volatile.StoreUint32(&o.RXIMR15.Reg, volatile.LoadUint32(&o.RXIMR15.Reg)&^(0x800)|value<<11)
}
func (o *CAN0_Type) GetRXIMR15_MI11() uint32 {
	return (volatile.LoadUint32(&o.RXIMR15.Reg) & 0x800) >> 11
}
func (o *CAN0_Type) SetRXIMR15_MI12(value uint32) {
	volatile.StoreUint32(&o.RXIMR15.Reg, volatile.LoadUint32(&o.RXIMR15.Reg)&^(0x1000)|value<<12)
}
func (o *CAN0_Type) GetRXIMR15_MI12() uint32 {
	return (volatile.LoadUint32(&o.RXIMR15.Reg) & 0x1000) >> 12
}
func (o *CAN0_Type) SetRXIMR15_MI13(value uint32) {
	volatile.StoreUint32(&o.RXIMR15.Reg, volatile.LoadUint32(&o.RXIMR15.Reg)&^(0x2000)|value<<13)
}
func (o *CAN0_Type) GetRXIMR15_MI13() uint32 {
	return (volatile.LoadUint32(&o.RXIMR15.Reg) & 0x2000) >> 13
}
func (o *CAN0_Type) SetRXIMR15_MI14(value uint32) {
	volatile.StoreUint32(&o.RXIMR15.Reg, volatile.LoadUint32(&o.RXIMR15.Reg)&^(0x4000)|value<<14)
}
func (o *CAN0_Type) GetRXIMR15_MI14() uint32 {
	return (volatile.LoadUint32(&o.RXIMR15.Reg) & 0x4000) >> 14
}
func (o *CAN0_Type) SetRXIMR15_MI15(value uint32) {
	volatile.StoreUint32(&o.RXIMR15.Reg, volatile.LoadUint32(&o.RXIMR15.Reg)&^(0x8000)|value<<15)
}
func (o *CAN0_Type) GetRXIMR15_MI15() uint32 {
	return (volatile.LoadUint32(&o.RXIMR15.Reg) & 0x8000) >> 15
}
func (o *CAN0_Type) SetRXIMR15_MI16(value uint32) {
	volatile.StoreUint32(&o.RXIMR15.Reg, volatile.LoadUint32(&o.RXIMR15.Reg)&^(0x10000)|value<<16)
}
func (o *CAN0_Type) GetRXIMR15_MI16() uint32 {
	return (volatile.LoadUint32(&o.RXIMR15.Reg) & 0x10000) >> 16
}
func (o *CAN0_Type) SetRXIMR15_MI17(value uint32) {
	volatile.StoreUint32(&o.RXIMR15.Reg, volatile.LoadUint32(&o.RXIMR15.Reg)&^(0x20000)|value<<17)
}
func (o *CAN0_Type) GetRXIMR15_MI17() uint32 {
	return (volatile.LoadUint32(&o.RXIMR15.Reg) & 0x20000) >> 17
}
func (o *CAN0_Type) SetRXIMR15_MI18(value uint32) {
	volatile.StoreUint32(&o.RXIMR15.Reg, volatile.LoadUint32(&o.RXIMR15.Reg)&^(0x40000)|value<<18)
}
func (o *CAN0_Type) GetRXIMR15_MI18() uint32 {
	return (volatile.LoadUint32(&o.RXIMR15.Reg) & 0x40000) >> 18
}
func (o *CAN0_Type) SetRXIMR15_MI19(value uint32) {
	volatile.StoreUint32(&o.RXIMR15.Reg, volatile.LoadUint32(&o.RXIMR15.Reg)&^(0x80000)|value<<19)
}
func (o *CAN0_Type) GetRXIMR15_MI19() uint32 {
	return (volatile.LoadUint32(&o.RXIMR15.Reg) & 0x80000) >> 19
}
func (o *CAN0_Type) SetRXIMR15_MI20(value uint32) {
	volatile.StoreUint32(&o.RXIMR15.Reg, volatile.LoadUint32(&o.RXIMR15.Reg)&^(0x100000)|value<<20)
}
func (o *CAN0_Type) GetRXIMR15_MI20() uint32 {
	return (volatile.LoadUint32(&o.RXIMR15.Reg) & 0x100000) >> 20
}
func (o *CAN0_Type) SetRXIMR15_MI21(value uint32) {
	volatile.StoreUint32(&o.RXIMR15.Reg, volatile.LoadUint32(&o.RXIMR15.Reg)&^(0x200000)|value<<21)
}
func (o *CAN0_Type) GetRXIMR15_MI21() uint32 {
	return (volatile.LoadUint32(&o.RXIMR15.Reg) & 0x200000) >> 21
}
func (o *CAN0_Type) SetRXIMR15_MI22(value uint32) {
	volatile.StoreUint32(&o.RXIMR15.Reg, volatile.LoadUint32(&o.RXIMR15.Reg)&^(0x400000)|value<<22)
}
func (o *CAN0_Type) GetRXIMR15_MI22() uint32 {
	return (volatile.LoadUint32(&o.RXIMR15.Reg) & 0x400000) >> 22
}
func (o *CAN0_Type) SetRXIMR15_MI23(value uint32) {
	volatile.StoreUint32(&o.RXIMR15.Reg, volatile.LoadUint32(&o.RXIMR15.Reg)&^(0x800000)|value<<23)
}
func (o *CAN0_Type) GetRXIMR15_MI23() uint32 {
	return (volatile.LoadUint32(&o.RXIMR15.Reg) & 0x800000) >> 23
}
func (o *CAN0_Type) SetRXIMR15_MI24(value uint32) {
	volatile.StoreUint32(&o.RXIMR15.Reg, volatile.LoadUint32(&o.RXIMR15.Reg)&^(0x1000000)|value<<24)
}
func (o *CAN0_Type) GetRXIMR15_MI24() uint32 {
	return (volatile.LoadUint32(&o.RXIMR15.Reg) & 0x1000000) >> 24
}
func (o *CAN0_Type) SetRXIMR15_MI25(value uint32) {
	volatile.StoreUint32(&o.RXIMR15.Reg, volatile.LoadUint32(&o.RXIMR15.Reg)&^(0x2000000)|value<<25)
}
func (o *CAN0_Type) GetRXIMR15_MI25() uint32 {
	return (volatile.LoadUint32(&o.RXIMR15.Reg) & 0x2000000) >> 25
}
func (o *CAN0_Type) SetRXIMR15_MI26(value uint32) {
	volatile.StoreUint32(&o.RXIMR15.Reg, volatile.LoadUint32(&o.RXIMR15.Reg)&^(0x4000000)|value<<26)
}
func (o *CAN0_Type) GetRXIMR15_MI26() uint32 {
	return (volatile.LoadUint32(&o.RXIMR15.Reg) & 0x4000000) >> 26
}
func (o *CAN0_Type) SetRXIMR15_MI27(value uint32) {
	volatile.StoreUint32(&o.RXIMR15.Reg, volatile.LoadUint32(&o.RXIMR15.Reg)&^(0x8000000)|value<<27)
}
func (o *CAN0_Type) GetRXIMR15_MI27() uint32 {
	return (volatile.LoadUint32(&o.RXIMR15.Reg) & 0x8000000) >> 27
}
func (o *CAN0_Type) SetRXIMR15_MI28(value uint32) {
	volatile.StoreUint32(&o.RXIMR15.Reg, volatile.LoadUint32(&o.RXIMR15.Reg)&^(0x10000000)|value<<28)
}
func (o *CAN0_Type) GetRXIMR15_MI28() uint32 {
	return (volatile.LoadUint32(&o.RXIMR15.Reg) & 0x10000000) >> 28
}
func (o *CAN0_Type) SetRXIMR15_MI29(value uint32) {
	volatile.StoreUint32(&o.RXIMR15.Reg, volatile.LoadUint32(&o.RXIMR15.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetRXIMR15_MI29() uint32 {
	return (volatile.LoadUint32(&o.RXIMR15.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetRXIMR15_MI30(value uint32) {
	volatile.StoreUint32(&o.RXIMR15.Reg, volatile.LoadUint32(&o.RXIMR15.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetRXIMR15_MI30() uint32 {
	return (volatile.LoadUint32(&o.RXIMR15.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetRXIMR15_MI31(value uint32) {
	volatile.StoreUint32(&o.RXIMR15.Reg, volatile.LoadUint32(&o.RXIMR15.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetRXIMR15_MI31() uint32 {
	return (volatile.LoadUint32(&o.RXIMR15.Reg) & 0x80000000) >> 31
}

// Random Number Generator Accelerator
type RNG_Type struct {
	CR volatile.Register32 // 0x0
	SR volatile.Register32 // 0x4
	ER volatile.Register32 // 0x8
	OR volatile.Register32 // 0xC
}

// RNG.CR: RNGA Control Register
func (o *RNG_Type) SetCR_GO(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *RNG_Type) GetCR_GO() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}
func (o *RNG_Type) SetCR_HA(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *RNG_Type) GetCR_HA() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *RNG_Type) SetCR_INTM(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *RNG_Type) GetCR_INTM() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *RNG_Type) SetCR_CLRI(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8)|value<<3)
}
func (o *RNG_Type) GetCR_CLRI() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8) >> 3
}
func (o *RNG_Type) SetCR_SLP(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10)|value<<4)
}
func (o *RNG_Type) GetCR_SLP() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10) >> 4
}

// RNG.SR: RNGA Status Register
func (o *RNG_Type) SetSR_SECV(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *RNG_Type) GetSR_SECV() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}
func (o *RNG_Type) SetSR_LRS(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *RNG_Type) GetSR_LRS() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *RNG_Type) SetSR_ORU(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *RNG_Type) GetSR_ORU() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}
func (o *RNG_Type) SetSR_ERRI(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8)|value<<3)
}
func (o *RNG_Type) GetSR_ERRI() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8) >> 3
}
func (o *RNG_Type) SetSR_SLP(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10)|value<<4)
}
func (o *RNG_Type) GetSR_SLP() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10) >> 4
}
func (o *RNG_Type) SetSR_OREG_LVL(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0xff00)|value<<8)
}
func (o *RNG_Type) GetSR_OREG_LVL() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0xff00) >> 8
}
func (o *RNG_Type) SetSR_OREG_SIZE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0xff0000)|value<<16)
}
func (o *RNG_Type) GetSR_OREG_SIZE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0xff0000) >> 16
}

// RNG.ER: RNGA Entropy Register
func (o *RNG_Type) SetER(value uint32) {
	volatile.StoreUint32(&o.ER.Reg, value)
}
func (o *RNG_Type) GetER() uint32 {
	return volatile.LoadUint32(&o.ER.Reg)
}

// RNG.OR: RNGA Output Register
func (o *RNG_Type) SetOR(value uint32) {
	volatile.StoreUint32(&o.OR.Reg, value)
}
func (o *RNG_Type) GetOR() uint32 {
	return volatile.LoadUint32(&o.OR.Reg)
}

// Serial Peripheral Interface
type SPI_Type struct {
	MCR   volatile.Register32 // 0x0
	_     [4]byte
	TCR   volatile.Register32 // 0x8
	CTAR0 volatile.Register32 // 0xC
	CTAR1 volatile.Register32 // 0x10
	_     [24]byte
	SR    volatile.Register32 // 0x2C
	RSER  volatile.Register32 // 0x30
	PUSHR volatile.Register32 // 0x34
	POPR  volatile.Register32 // 0x38
	TXFR0 volatile.Register32 // 0x3C
	TXFR1 volatile.Register32 // 0x40
	TXFR2 volatile.Register32 // 0x44
	TXFR3 volatile.Register32 // 0x48
	_     [48]byte
	RXFR0 volatile.Register32 // 0x7C
	RXFR1 volatile.Register32 // 0x80
	RXFR2 volatile.Register32 // 0x84
	RXFR3 volatile.Register32 // 0x88
}

// SPI.MCR: Module Configuration Register
func (o *SPI_Type) SetMCR_HALT(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x1)|value)
}
func (o *SPI_Type) GetMCR_HALT() uint32 {
	return volatile.LoadUint32(&o.MCR.Reg) & 0x1
}
func (o *SPI_Type) SetMCR_SMPL_PT(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x300)|value<<8)
}
func (o *SPI_Type) GetMCR_SMPL_PT() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x300) >> 8
}
func (o *SPI_Type) SetMCR_CLR_RXF(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x400)|value<<10)
}
func (o *SPI_Type) GetMCR_CLR_RXF() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x400) >> 10
}
func (o *SPI_Type) SetMCR_CLR_TXF(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x800)|value<<11)
}
func (o *SPI_Type) GetMCR_CLR_TXF() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x800) >> 11
}
func (o *SPI_Type) SetMCR_DIS_RXF(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x1000)|value<<12)
}
func (o *SPI_Type) GetMCR_DIS_RXF() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x1000) >> 12
}
func (o *SPI_Type) SetMCR_DIS_TXF(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x2000)|value<<13)
}
func (o *SPI_Type) GetMCR_DIS_TXF() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x2000) >> 13
}
func (o *SPI_Type) SetMCR_MDIS(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x4000)|value<<14)
}
func (o *SPI_Type) GetMCR_MDIS() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x4000) >> 14
}
func (o *SPI_Type) SetMCR_DOZE(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x8000)|value<<15)
}
func (o *SPI_Type) GetMCR_DOZE() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x8000) >> 15
}
func (o *SPI_Type) SetMCR_PCSIS0(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x10000)|value<<16)
}
func (o *SPI_Type) GetMCR_PCSIS0() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x10000) >> 16
}
func (o *SPI_Type) SetMCR_PCSIS1(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x20000)|value<<17)
}
func (o *SPI_Type) GetMCR_PCSIS1() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x20000) >> 17
}
func (o *SPI_Type) SetMCR_PCSIS2(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x40000)|value<<18)
}
func (o *SPI_Type) GetMCR_PCSIS2() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x40000) >> 18
}
func (o *SPI_Type) SetMCR_PCSIS3(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x80000)|value<<19)
}
func (o *SPI_Type) GetMCR_PCSIS3() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x80000) >> 19
}
func (o *SPI_Type) SetMCR_PCSIS4(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x100000)|value<<20)
}
func (o *SPI_Type) GetMCR_PCSIS4() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x100000) >> 20
}
func (o *SPI_Type) SetMCR_PCSIS5(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x200000)|value<<21)
}
func (o *SPI_Type) GetMCR_PCSIS5() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x200000) >> 21
}
func (o *SPI_Type) SetMCR_ROOE(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x1000000)|value<<24)
}
func (o *SPI_Type) GetMCR_ROOE() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x1000000) >> 24
}
func (o *SPI_Type) SetMCR_PCSSE(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x2000000)|value<<25)
}
func (o *SPI_Type) GetMCR_PCSSE() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x2000000) >> 25
}
func (o *SPI_Type) SetMCR_MTFE(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x4000000)|value<<26)
}
func (o *SPI_Type) GetMCR_MTFE() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x4000000) >> 26
}
func (o *SPI_Type) SetMCR_FRZ(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x8000000)|value<<27)
}
func (o *SPI_Type) GetMCR_FRZ() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x8000000) >> 27
}
func (o *SPI_Type) SetMCR_DCONF(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x30000000)|value<<28)
}
func (o *SPI_Type) GetMCR_DCONF() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x30000000) >> 28
}
func (o *SPI_Type) SetMCR_CONT_SCKE(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x40000000)|value<<30)
}
func (o *SPI_Type) GetMCR_CONT_SCKE() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x40000000) >> 30
}
func (o *SPI_Type) SetMCR_MSTR(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x80000000)|value<<31)
}
func (o *SPI_Type) GetMCR_MSTR() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x80000000) >> 31
}

// SPI.TCR: Transfer Count Register
func (o *SPI_Type) SetTCR_SPI_TCNT(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0xffff0000)|value<<16)
}
func (o *SPI_Type) GetTCR_SPI_TCNT() uint32 {
	return (volatile.LoadUint32(&o.TCR.Reg) & 0xffff0000) >> 16
}

// SPI.CTAR0: Clock and Transfer Attributes Register (In Master Mode)
func (o *SPI_Type) SetCTAR0_BR(value uint32) {
	volatile.StoreUint32(&o.CTAR0.Reg, volatile.LoadUint32(&o.CTAR0.Reg)&^(0xf)|value)
}
func (o *SPI_Type) GetCTAR0_BR() uint32 {
	return volatile.LoadUint32(&o.CTAR0.Reg) & 0xf
}
func (o *SPI_Type) SetCTAR0_DT(value uint32) {
	volatile.StoreUint32(&o.CTAR0.Reg, volatile.LoadUint32(&o.CTAR0.Reg)&^(0xf0)|value<<4)
}
func (o *SPI_Type) GetCTAR0_DT() uint32 {
	return (volatile.LoadUint32(&o.CTAR0.Reg) & 0xf0) >> 4
}
func (o *SPI_Type) SetCTAR0_ASC(value uint32) {
	volatile.StoreUint32(&o.CTAR0.Reg, volatile.LoadUint32(&o.CTAR0.Reg)&^(0xf00)|value<<8)
}
func (o *SPI_Type) GetCTAR0_ASC() uint32 {
	return (volatile.LoadUint32(&o.CTAR0.Reg) & 0xf00) >> 8
}
func (o *SPI_Type) SetCTAR0_CSSCK(value uint32) {
	volatile.StoreUint32(&o.CTAR0.Reg, volatile.LoadUint32(&o.CTAR0.Reg)&^(0xf000)|value<<12)
}
func (o *SPI_Type) GetCTAR0_CSSCK() uint32 {
	return (volatile.LoadUint32(&o.CTAR0.Reg) & 0xf000) >> 12
}
func (o *SPI_Type) SetCTAR0_PBR(value uint32) {
	volatile.StoreUint32(&o.CTAR0.Reg, volatile.LoadUint32(&o.CTAR0.Reg)&^(0x30000)|value<<16)
}
func (o *SPI_Type) GetCTAR0_PBR() uint32 {
	return (volatile.LoadUint32(&o.CTAR0.Reg) & 0x30000) >> 16
}
func (o *SPI_Type) SetCTAR0_PDT(value uint32) {
	volatile.StoreUint32(&o.CTAR0.Reg, volatile.LoadUint32(&o.CTAR0.Reg)&^(0xc0000)|value<<18)
}
func (o *SPI_Type) GetCTAR0_PDT() uint32 {
	return (volatile.LoadUint32(&o.CTAR0.Reg) & 0xc0000) >> 18
}
func (o *SPI_Type) SetCTAR0_PASC(value uint32) {
	volatile.StoreUint32(&o.CTAR0.Reg, volatile.LoadUint32(&o.CTAR0.Reg)&^(0x300000)|value<<20)
}
func (o *SPI_Type) GetCTAR0_PASC() uint32 {
	return (volatile.LoadUint32(&o.CTAR0.Reg) & 0x300000) >> 20
}
func (o *SPI_Type) SetCTAR0_PCSSCK(value uint32) {
	volatile.StoreUint32(&o.CTAR0.Reg, volatile.LoadUint32(&o.CTAR0.Reg)&^(0xc00000)|value<<22)
}
func (o *SPI_Type) GetCTAR0_PCSSCK() uint32 {
	return (volatile.LoadUint32(&o.CTAR0.Reg) & 0xc00000) >> 22
}
func (o *SPI_Type) SetCTAR0_LSBFE(value uint32) {
	volatile.StoreUint32(&o.CTAR0.Reg, volatile.LoadUint32(&o.CTAR0.Reg)&^(0x1000000)|value<<24)
}
func (o *SPI_Type) GetCTAR0_LSBFE() uint32 {
	return (volatile.LoadUint32(&o.CTAR0.Reg) & 0x1000000) >> 24
}
func (o *SPI_Type) SetCTAR0_CPHA(value uint32) {
	volatile.StoreUint32(&o.CTAR0.Reg, volatile.LoadUint32(&o.CTAR0.Reg)&^(0x2000000)|value<<25)
}
func (o *SPI_Type) GetCTAR0_CPHA() uint32 {
	return (volatile.LoadUint32(&o.CTAR0.Reg) & 0x2000000) >> 25
}
func (o *SPI_Type) SetCTAR0_CPOL(value uint32) {
	volatile.StoreUint32(&o.CTAR0.Reg, volatile.LoadUint32(&o.CTAR0.Reg)&^(0x4000000)|value<<26)
}
func (o *SPI_Type) GetCTAR0_CPOL() uint32 {
	return (volatile.LoadUint32(&o.CTAR0.Reg) & 0x4000000) >> 26
}
func (o *SPI_Type) SetCTAR0_FMSZ(value uint32) {
	volatile.StoreUint32(&o.CTAR0.Reg, volatile.LoadUint32(&o.CTAR0.Reg)&^(0x78000000)|value<<27)
}
func (o *SPI_Type) GetCTAR0_FMSZ() uint32 {
	return (volatile.LoadUint32(&o.CTAR0.Reg) & 0x78000000) >> 27
}
func (o *SPI_Type) SetCTAR0_DBR(value uint32) {
	volatile.StoreUint32(&o.CTAR0.Reg, volatile.LoadUint32(&o.CTAR0.Reg)&^(0x80000000)|value<<31)
}
func (o *SPI_Type) GetCTAR0_DBR() uint32 {
	return (volatile.LoadUint32(&o.CTAR0.Reg) & 0x80000000) >> 31
}

// SPI.CTAR1: Clock and Transfer Attributes Register (In Master Mode)
func (o *SPI_Type) SetCTAR1_BR(value uint32) {
	volatile.StoreUint32(&o.CTAR1.Reg, volatile.LoadUint32(&o.CTAR1.Reg)&^(0xf)|value)
}
func (o *SPI_Type) GetCTAR1_BR() uint32 {
	return volatile.LoadUint32(&o.CTAR1.Reg) & 0xf
}
func (o *SPI_Type) SetCTAR1_DT(value uint32) {
	volatile.StoreUint32(&o.CTAR1.Reg, volatile.LoadUint32(&o.CTAR1.Reg)&^(0xf0)|value<<4)
}
func (o *SPI_Type) GetCTAR1_DT() uint32 {
	return (volatile.LoadUint32(&o.CTAR1.Reg) & 0xf0) >> 4
}
func (o *SPI_Type) SetCTAR1_ASC(value uint32) {
	volatile.StoreUint32(&o.CTAR1.Reg, volatile.LoadUint32(&o.CTAR1.Reg)&^(0xf00)|value<<8)
}
func (o *SPI_Type) GetCTAR1_ASC() uint32 {
	return (volatile.LoadUint32(&o.CTAR1.Reg) & 0xf00) >> 8
}
func (o *SPI_Type) SetCTAR1_CSSCK(value uint32) {
	volatile.StoreUint32(&o.CTAR1.Reg, volatile.LoadUint32(&o.CTAR1.Reg)&^(0xf000)|value<<12)
}
func (o *SPI_Type) GetCTAR1_CSSCK() uint32 {
	return (volatile.LoadUint32(&o.CTAR1.Reg) & 0xf000) >> 12
}
func (o *SPI_Type) SetCTAR1_PBR(value uint32) {
	volatile.StoreUint32(&o.CTAR1.Reg, volatile.LoadUint32(&o.CTAR1.Reg)&^(0x30000)|value<<16)
}
func (o *SPI_Type) GetCTAR1_PBR() uint32 {
	return (volatile.LoadUint32(&o.CTAR1.Reg) & 0x30000) >> 16
}
func (o *SPI_Type) SetCTAR1_PDT(value uint32) {
	volatile.StoreUint32(&o.CTAR1.Reg, volatile.LoadUint32(&o.CTAR1.Reg)&^(0xc0000)|value<<18)
}
func (o *SPI_Type) GetCTAR1_PDT() uint32 {
	return (volatile.LoadUint32(&o.CTAR1.Reg) & 0xc0000) >> 18
}
func (o *SPI_Type) SetCTAR1_PASC(value uint32) {
	volatile.StoreUint32(&o.CTAR1.Reg, volatile.LoadUint32(&o.CTAR1.Reg)&^(0x300000)|value<<20)
}
func (o *SPI_Type) GetCTAR1_PASC() uint32 {
	return (volatile.LoadUint32(&o.CTAR1.Reg) & 0x300000) >> 20
}
func (o *SPI_Type) SetCTAR1_PCSSCK(value uint32) {
	volatile.StoreUint32(&o.CTAR1.Reg, volatile.LoadUint32(&o.CTAR1.Reg)&^(0xc00000)|value<<22)
}
func (o *SPI_Type) GetCTAR1_PCSSCK() uint32 {
	return (volatile.LoadUint32(&o.CTAR1.Reg) & 0xc00000) >> 22
}
func (o *SPI_Type) SetCTAR1_LSBFE(value uint32) {
	volatile.StoreUint32(&o.CTAR1.Reg, volatile.LoadUint32(&o.CTAR1.Reg)&^(0x1000000)|value<<24)
}
func (o *SPI_Type) GetCTAR1_LSBFE() uint32 {
	return (volatile.LoadUint32(&o.CTAR1.Reg) & 0x1000000) >> 24
}
func (o *SPI_Type) SetCTAR1_CPHA(value uint32) {
	volatile.StoreUint32(&o.CTAR1.Reg, volatile.LoadUint32(&o.CTAR1.Reg)&^(0x2000000)|value<<25)
}
func (o *SPI_Type) GetCTAR1_CPHA() uint32 {
	return (volatile.LoadUint32(&o.CTAR1.Reg) & 0x2000000) >> 25
}
func (o *SPI_Type) SetCTAR1_CPOL(value uint32) {
	volatile.StoreUint32(&o.CTAR1.Reg, volatile.LoadUint32(&o.CTAR1.Reg)&^(0x4000000)|value<<26)
}
func (o *SPI_Type) GetCTAR1_CPOL() uint32 {
	return (volatile.LoadUint32(&o.CTAR1.Reg) & 0x4000000) >> 26
}
func (o *SPI_Type) SetCTAR1_FMSZ(value uint32) {
	volatile.StoreUint32(&o.CTAR1.Reg, volatile.LoadUint32(&o.CTAR1.Reg)&^(0x78000000)|value<<27)
}
func (o *SPI_Type) GetCTAR1_FMSZ() uint32 {
	return (volatile.LoadUint32(&o.CTAR1.Reg) & 0x78000000) >> 27
}
func (o *SPI_Type) SetCTAR1_DBR(value uint32) {
	volatile.StoreUint32(&o.CTAR1.Reg, volatile.LoadUint32(&o.CTAR1.Reg)&^(0x80000000)|value<<31)
}
func (o *SPI_Type) GetCTAR1_DBR() uint32 {
	return (volatile.LoadUint32(&o.CTAR1.Reg) & 0x80000000) >> 31
}

// SPI.SR: Status Register
func (o *SPI_Type) SetSR_POPNXTPTR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0xf)|value)
}
func (o *SPI_Type) GetSR_POPNXTPTR() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0xf
}
func (o *SPI_Type) SetSR_RXCTR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0xf0)|value<<4)
}
func (o *SPI_Type) GetSR_RXCTR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0xf0) >> 4
}
func (o *SPI_Type) SetSR_TXNXTPTR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0xf00)|value<<8)
}
func (o *SPI_Type) GetSR_TXNXTPTR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0xf00) >> 8
}
func (o *SPI_Type) SetSR_TXCTR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0xf000)|value<<12)
}
func (o *SPI_Type) GetSR_TXCTR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0xf000) >> 12
}
func (o *SPI_Type) SetSR_RFDF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20000)|value<<17)
}
func (o *SPI_Type) GetSR_RFDF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20000) >> 17
}
func (o *SPI_Type) SetSR_RFOF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x80000)|value<<19)
}
func (o *SPI_Type) GetSR_RFOF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x80000) >> 19
}
func (o *SPI_Type) SetSR_TFFF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2000000)|value<<25)
}
func (o *SPI_Type) GetSR_TFFF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2000000) >> 25
}
func (o *SPI_Type) SetSR_TFUF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8000000)|value<<27)
}
func (o *SPI_Type) GetSR_TFUF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8000000) >> 27
}
func (o *SPI_Type) SetSR_EOQF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10000000)|value<<28)
}
func (o *SPI_Type) GetSR_EOQF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10000000) >> 28
}
func (o *SPI_Type) SetSR_TXRXS(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x40000000)|value<<30)
}
func (o *SPI_Type) GetSR_TXRXS() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x40000000) >> 30
}
func (o *SPI_Type) SetSR_TCF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x80000000)|value<<31)
}
func (o *SPI_Type) GetSR_TCF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x80000000) >> 31
}

// SPI.RSER: DMA/Interrupt Request Select and Enable Register
func (o *SPI_Type) SetRSER_RFDF_DIRS(value uint32) {
	volatile.StoreUint32(&o.RSER.Reg, volatile.LoadUint32(&o.RSER.Reg)&^(0x10000)|value<<16)
}
func (o *SPI_Type) GetRSER_RFDF_DIRS() uint32 {
	return (volatile.LoadUint32(&o.RSER.Reg) & 0x10000) >> 16
}
func (o *SPI_Type) SetRSER_RFDF_RE(value uint32) {
	volatile.StoreUint32(&o.RSER.Reg, volatile.LoadUint32(&o.RSER.Reg)&^(0x20000)|value<<17)
}
func (o *SPI_Type) GetRSER_RFDF_RE() uint32 {
	return (volatile.LoadUint32(&o.RSER.Reg) & 0x20000) >> 17
}
func (o *SPI_Type) SetRSER_RFOF_RE(value uint32) {
	volatile.StoreUint32(&o.RSER.Reg, volatile.LoadUint32(&o.RSER.Reg)&^(0x80000)|value<<19)
}
func (o *SPI_Type) GetRSER_RFOF_RE() uint32 {
	return (volatile.LoadUint32(&o.RSER.Reg) & 0x80000) >> 19
}
func (o *SPI_Type) SetRSER_TFFF_DIRS(value uint32) {
	volatile.StoreUint32(&o.RSER.Reg, volatile.LoadUint32(&o.RSER.Reg)&^(0x1000000)|value<<24)
}
func (o *SPI_Type) GetRSER_TFFF_DIRS() uint32 {
	return (volatile.LoadUint32(&o.RSER.Reg) & 0x1000000) >> 24
}
func (o *SPI_Type) SetRSER_TFFF_RE(value uint32) {
	volatile.StoreUint32(&o.RSER.Reg, volatile.LoadUint32(&o.RSER.Reg)&^(0x2000000)|value<<25)
}
func (o *SPI_Type) GetRSER_TFFF_RE() uint32 {
	return (volatile.LoadUint32(&o.RSER.Reg) & 0x2000000) >> 25
}
func (o *SPI_Type) SetRSER_TFUF_RE(value uint32) {
	volatile.StoreUint32(&o.RSER.Reg, volatile.LoadUint32(&o.RSER.Reg)&^(0x8000000)|value<<27)
}
func (o *SPI_Type) GetRSER_TFUF_RE() uint32 {
	return (volatile.LoadUint32(&o.RSER.Reg) & 0x8000000) >> 27
}
func (o *SPI_Type) SetRSER_EOQF_RE(value uint32) {
	volatile.StoreUint32(&o.RSER.Reg, volatile.LoadUint32(&o.RSER.Reg)&^(0x10000000)|value<<28)
}
func (o *SPI_Type) GetRSER_EOQF_RE() uint32 {
	return (volatile.LoadUint32(&o.RSER.Reg) & 0x10000000) >> 28
}
func (o *SPI_Type) SetRSER_TCF_RE(value uint32) {
	volatile.StoreUint32(&o.RSER.Reg, volatile.LoadUint32(&o.RSER.Reg)&^(0x80000000)|value<<31)
}
func (o *SPI_Type) GetRSER_TCF_RE() uint32 {
	return (volatile.LoadUint32(&o.RSER.Reg) & 0x80000000) >> 31
}

// SPI.PUSHR: PUSH TX FIFO Register In Master Mode
func (o *SPI_Type) SetPUSHR_TXDATA(value uint32) {
	volatile.StoreUint32(&o.PUSHR.Reg, volatile.LoadUint32(&o.PUSHR.Reg)&^(0xffff)|value)
}
func (o *SPI_Type) GetPUSHR_TXDATA() uint32 {
	return volatile.LoadUint32(&o.PUSHR.Reg) & 0xffff
}
func (o *SPI_Type) SetPUSHR_PCS0(value uint32) {
	volatile.StoreUint32(&o.PUSHR.Reg, volatile.LoadUint32(&o.PUSHR.Reg)&^(0x10000)|value<<16)
}
func (o *SPI_Type) GetPUSHR_PCS0() uint32 {
	return (volatile.LoadUint32(&o.PUSHR.Reg) & 0x10000) >> 16
}
func (o *SPI_Type) SetPUSHR_PCS1(value uint32) {
	volatile.StoreUint32(&o.PUSHR.Reg, volatile.LoadUint32(&o.PUSHR.Reg)&^(0x20000)|value<<17)
}
func (o *SPI_Type) GetPUSHR_PCS1() uint32 {
	return (volatile.LoadUint32(&o.PUSHR.Reg) & 0x20000) >> 17
}
func (o *SPI_Type) SetPUSHR_PCS2(value uint32) {
	volatile.StoreUint32(&o.PUSHR.Reg, volatile.LoadUint32(&o.PUSHR.Reg)&^(0x40000)|value<<18)
}
func (o *SPI_Type) GetPUSHR_PCS2() uint32 {
	return (volatile.LoadUint32(&o.PUSHR.Reg) & 0x40000) >> 18
}
func (o *SPI_Type) SetPUSHR_PCS3(value uint32) {
	volatile.StoreUint32(&o.PUSHR.Reg, volatile.LoadUint32(&o.PUSHR.Reg)&^(0x80000)|value<<19)
}
func (o *SPI_Type) GetPUSHR_PCS3() uint32 {
	return (volatile.LoadUint32(&o.PUSHR.Reg) & 0x80000) >> 19
}
func (o *SPI_Type) SetPUSHR_PCS4(value uint32) {
	volatile.StoreUint32(&o.PUSHR.Reg, volatile.LoadUint32(&o.PUSHR.Reg)&^(0x100000)|value<<20)
}
func (o *SPI_Type) GetPUSHR_PCS4() uint32 {
	return (volatile.LoadUint32(&o.PUSHR.Reg) & 0x100000) >> 20
}
func (o *SPI_Type) SetPUSHR_PCS5(value uint32) {
	volatile.StoreUint32(&o.PUSHR.Reg, volatile.LoadUint32(&o.PUSHR.Reg)&^(0x200000)|value<<21)
}
func (o *SPI_Type) GetPUSHR_PCS5() uint32 {
	return (volatile.LoadUint32(&o.PUSHR.Reg) & 0x200000) >> 21
}
func (o *SPI_Type) SetPUSHR_CTCNT(value uint32) {
	volatile.StoreUint32(&o.PUSHR.Reg, volatile.LoadUint32(&o.PUSHR.Reg)&^(0x4000000)|value<<26)
}
func (o *SPI_Type) GetPUSHR_CTCNT() uint32 {
	return (volatile.LoadUint32(&o.PUSHR.Reg) & 0x4000000) >> 26
}
func (o *SPI_Type) SetPUSHR_EOQ(value uint32) {
	volatile.StoreUint32(&o.PUSHR.Reg, volatile.LoadUint32(&o.PUSHR.Reg)&^(0x8000000)|value<<27)
}
func (o *SPI_Type) GetPUSHR_EOQ() uint32 {
	return (volatile.LoadUint32(&o.PUSHR.Reg) & 0x8000000) >> 27
}
func (o *SPI_Type) SetPUSHR_CTAS(value uint32) {
	volatile.StoreUint32(&o.PUSHR.Reg, volatile.LoadUint32(&o.PUSHR.Reg)&^(0x70000000)|value<<28)
}
func (o *SPI_Type) GetPUSHR_CTAS() uint32 {
	return (volatile.LoadUint32(&o.PUSHR.Reg) & 0x70000000) >> 28
}
func (o *SPI_Type) SetPUSHR_CONT(value uint32) {
	volatile.StoreUint32(&o.PUSHR.Reg, volatile.LoadUint32(&o.PUSHR.Reg)&^(0x80000000)|value<<31)
}
func (o *SPI_Type) GetPUSHR_CONT() uint32 {
	return (volatile.LoadUint32(&o.PUSHR.Reg) & 0x80000000) >> 31
}

// SPI.POPR: POP RX FIFO Register
func (o *SPI_Type) SetPOPR(value uint32) {
	volatile.StoreUint32(&o.POPR.Reg, value)
}
func (o *SPI_Type) GetPOPR() uint32 {
	return volatile.LoadUint32(&o.POPR.Reg)
}

// SPI.TXFR0: Transmit FIFO Registers
func (o *SPI_Type) SetTXFR0_TXDATA(value uint32) {
	volatile.StoreUint32(&o.TXFR0.Reg, volatile.LoadUint32(&o.TXFR0.Reg)&^(0xffff)|value)
}
func (o *SPI_Type) GetTXFR0_TXDATA() uint32 {
	return volatile.LoadUint32(&o.TXFR0.Reg) & 0xffff
}
func (o *SPI_Type) SetTXFR0_TXCMD_TXDATA(value uint32) {
	volatile.StoreUint32(&o.TXFR0.Reg, volatile.LoadUint32(&o.TXFR0.Reg)&^(0xffff0000)|value<<16)
}
func (o *SPI_Type) GetTXFR0_TXCMD_TXDATA() uint32 {
	return (volatile.LoadUint32(&o.TXFR0.Reg) & 0xffff0000) >> 16
}

// SPI.TXFR1: Transmit FIFO Registers
func (o *SPI_Type) SetTXFR1_TXDATA(value uint32) {
	volatile.StoreUint32(&o.TXFR1.Reg, volatile.LoadUint32(&o.TXFR1.Reg)&^(0xffff)|value)
}
func (o *SPI_Type) GetTXFR1_TXDATA() uint32 {
	return volatile.LoadUint32(&o.TXFR1.Reg) & 0xffff
}
func (o *SPI_Type) SetTXFR1_TXCMD_TXDATA(value uint32) {
	volatile.StoreUint32(&o.TXFR1.Reg, volatile.LoadUint32(&o.TXFR1.Reg)&^(0xffff0000)|value<<16)
}
func (o *SPI_Type) GetTXFR1_TXCMD_TXDATA() uint32 {
	return (volatile.LoadUint32(&o.TXFR1.Reg) & 0xffff0000) >> 16
}

// SPI.TXFR2: Transmit FIFO Registers
func (o *SPI_Type) SetTXFR2_TXDATA(value uint32) {
	volatile.StoreUint32(&o.TXFR2.Reg, volatile.LoadUint32(&o.TXFR2.Reg)&^(0xffff)|value)
}
func (o *SPI_Type) GetTXFR2_TXDATA() uint32 {
	return volatile.LoadUint32(&o.TXFR2.Reg) & 0xffff
}
func (o *SPI_Type) SetTXFR2_TXCMD_TXDATA(value uint32) {
	volatile.StoreUint32(&o.TXFR2.Reg, volatile.LoadUint32(&o.TXFR2.Reg)&^(0xffff0000)|value<<16)
}
func (o *SPI_Type) GetTXFR2_TXCMD_TXDATA() uint32 {
	return (volatile.LoadUint32(&o.TXFR2.Reg) & 0xffff0000) >> 16
}

// SPI.TXFR3: Transmit FIFO Registers
func (o *SPI_Type) SetTXFR3_TXDATA(value uint32) {
	volatile.StoreUint32(&o.TXFR3.Reg, volatile.LoadUint32(&o.TXFR3.Reg)&^(0xffff)|value)
}
func (o *SPI_Type) GetTXFR3_TXDATA() uint32 {
	return volatile.LoadUint32(&o.TXFR3.Reg) & 0xffff
}
func (o *SPI_Type) SetTXFR3_TXCMD_TXDATA(value uint32) {
	volatile.StoreUint32(&o.TXFR3.Reg, volatile.LoadUint32(&o.TXFR3.Reg)&^(0xffff0000)|value<<16)
}
func (o *SPI_Type) GetTXFR3_TXCMD_TXDATA() uint32 {
	return (volatile.LoadUint32(&o.TXFR3.Reg) & 0xffff0000) >> 16
}

// SPI.RXFR0: Receive FIFO Registers
func (o *SPI_Type) SetRXFR0(value uint32) {
	volatile.StoreUint32(&o.RXFR0.Reg, value)
}
func (o *SPI_Type) GetRXFR0() uint32 {
	return volatile.LoadUint32(&o.RXFR0.Reg)
}

// SPI.RXFR1: Receive FIFO Registers
func (o *SPI_Type) SetRXFR1(value uint32) {
	volatile.StoreUint32(&o.RXFR1.Reg, value)
}
func (o *SPI_Type) GetRXFR1() uint32 {
	return volatile.LoadUint32(&o.RXFR1.Reg)
}

// SPI.RXFR2: Receive FIFO Registers
func (o *SPI_Type) SetRXFR2(value uint32) {
	volatile.StoreUint32(&o.RXFR2.Reg, value)
}
func (o *SPI_Type) GetRXFR2() uint32 {
	return volatile.LoadUint32(&o.RXFR2.Reg)
}

// SPI.RXFR3: Receive FIFO Registers
func (o *SPI_Type) SetRXFR3(value uint32) {
	volatile.StoreUint32(&o.RXFR3.Reg, value)
}
func (o *SPI_Type) GetRXFR3() uint32 {
	return volatile.LoadUint32(&o.RXFR3.Reg)
}

// Inter-IC Sound / Synchronous Audio Interface
type I2S0_Type struct {
	TCSR volatile.Register32 // 0x0
	TCR1 volatile.Register32 // 0x4
	TCR2 volatile.Register32 // 0x8
	TCR3 volatile.Register32 // 0xC
	TCR4 volatile.Register32 // 0x10
	TCR5 volatile.Register32 // 0x14
	_    [8]byte
	TDR0 volatile.Register32 // 0x20
	TDR1 volatile.Register32 // 0x24
	_    [24]byte
	TFR0 volatile.Register32 // 0x40
	TFR1 volatile.Register32 // 0x44
	_    [24]byte
	TMR  volatile.Register32 // 0x60
	_    [28]byte
	RCSR volatile.Register32 // 0x80
	RCR1 volatile.Register32 // 0x84
	RCR2 volatile.Register32 // 0x88
	RCR3 volatile.Register32 // 0x8C
	RCR4 volatile.Register32 // 0x90
	RCR5 volatile.Register32 // 0x94
	_    [8]byte
	RDR0 volatile.Register32 // 0xA0
	RDR1 volatile.Register32 // 0xA4
	_    [24]byte
	RFR0 volatile.Register32 // 0xC0
	RFR1 volatile.Register32 // 0xC4
	_    [24]byte
	RMR  volatile.Register32 // 0xE0
	_    [28]byte
	MCR  volatile.Register32 // 0x100
	MDR  volatile.Register32 // 0x104
}

// I2S0.TCSR: SAI Transmit Control Register
func (o *I2S0_Type) SetTCSR_FRDE(value uint32) {
	volatile.StoreUint32(&o.TCSR.Reg, volatile.LoadUint32(&o.TCSR.Reg)&^(0x1)|value)
}
func (o *I2S0_Type) GetTCSR_FRDE() uint32 {
	return volatile.LoadUint32(&o.TCSR.Reg) & 0x1
}
func (o *I2S0_Type) SetTCSR_FWDE(value uint32) {
	volatile.StoreUint32(&o.TCSR.Reg, volatile.LoadUint32(&o.TCSR.Reg)&^(0x2)|value<<1)
}
func (o *I2S0_Type) GetTCSR_FWDE() uint32 {
	return (volatile.LoadUint32(&o.TCSR.Reg) & 0x2) >> 1
}
func (o *I2S0_Type) SetTCSR_FRIE(value uint32) {
	volatile.StoreUint32(&o.TCSR.Reg, volatile.LoadUint32(&o.TCSR.Reg)&^(0x100)|value<<8)
}
func (o *I2S0_Type) GetTCSR_FRIE() uint32 {
	return (volatile.LoadUint32(&o.TCSR.Reg) & 0x100) >> 8
}
func (o *I2S0_Type) SetTCSR_FWIE(value uint32) {
	volatile.StoreUint32(&o.TCSR.Reg, volatile.LoadUint32(&o.TCSR.Reg)&^(0x200)|value<<9)
}
func (o *I2S0_Type) GetTCSR_FWIE() uint32 {
	return (volatile.LoadUint32(&o.TCSR.Reg) & 0x200) >> 9
}
func (o *I2S0_Type) SetTCSR_FEIE(value uint32) {
	volatile.StoreUint32(&o.TCSR.Reg, volatile.LoadUint32(&o.TCSR.Reg)&^(0x400)|value<<10)
}
func (o *I2S0_Type) GetTCSR_FEIE() uint32 {
	return (volatile.LoadUint32(&o.TCSR.Reg) & 0x400) >> 10
}
func (o *I2S0_Type) SetTCSR_SEIE(value uint32) {
	volatile.StoreUint32(&o.TCSR.Reg, volatile.LoadUint32(&o.TCSR.Reg)&^(0x800)|value<<11)
}
func (o *I2S0_Type) GetTCSR_SEIE() uint32 {
	return (volatile.LoadUint32(&o.TCSR.Reg) & 0x800) >> 11
}
func (o *I2S0_Type) SetTCSR_WSIE(value uint32) {
	volatile.StoreUint32(&o.TCSR.Reg, volatile.LoadUint32(&o.TCSR.Reg)&^(0x1000)|value<<12)
}
func (o *I2S0_Type) GetTCSR_WSIE() uint32 {
	return (volatile.LoadUint32(&o.TCSR.Reg) & 0x1000) >> 12
}
func (o *I2S0_Type) SetTCSR_FRF(value uint32) {
	volatile.StoreUint32(&o.TCSR.Reg, volatile.LoadUint32(&o.TCSR.Reg)&^(0x10000)|value<<16)
}
func (o *I2S0_Type) GetTCSR_FRF() uint32 {
	return (volatile.LoadUint32(&o.TCSR.Reg) & 0x10000) >> 16
}
func (o *I2S0_Type) SetTCSR_FWF(value uint32) {
	volatile.StoreUint32(&o.TCSR.Reg, volatile.LoadUint32(&o.TCSR.Reg)&^(0x20000)|value<<17)
}
func (o *I2S0_Type) GetTCSR_FWF() uint32 {
	return (volatile.LoadUint32(&o.TCSR.Reg) & 0x20000) >> 17
}
func (o *I2S0_Type) SetTCSR_FEF(value uint32) {
	volatile.StoreUint32(&o.TCSR.Reg, volatile.LoadUint32(&o.TCSR.Reg)&^(0x40000)|value<<18)
}
func (o *I2S0_Type) GetTCSR_FEF() uint32 {
	return (volatile.LoadUint32(&o.TCSR.Reg) & 0x40000) >> 18
}
func (o *I2S0_Type) SetTCSR_SEF(value uint32) {
	volatile.StoreUint32(&o.TCSR.Reg, volatile.LoadUint32(&o.TCSR.Reg)&^(0x80000)|value<<19)
}
func (o *I2S0_Type) GetTCSR_SEF() uint32 {
	return (volatile.LoadUint32(&o.TCSR.Reg) & 0x80000) >> 19
}
func (o *I2S0_Type) SetTCSR_WSF(value uint32) {
	volatile.StoreUint32(&o.TCSR.Reg, volatile.LoadUint32(&o.TCSR.Reg)&^(0x100000)|value<<20)
}
func (o *I2S0_Type) GetTCSR_WSF() uint32 {
	return (volatile.LoadUint32(&o.TCSR.Reg) & 0x100000) >> 20
}
func (o *I2S0_Type) SetTCSR_SR(value uint32) {
	volatile.StoreUint32(&o.TCSR.Reg, volatile.LoadUint32(&o.TCSR.Reg)&^(0x1000000)|value<<24)
}
func (o *I2S0_Type) GetTCSR_SR() uint32 {
	return (volatile.LoadUint32(&o.TCSR.Reg) & 0x1000000) >> 24
}
func (o *I2S0_Type) SetTCSR_FR(value uint32) {
	volatile.StoreUint32(&o.TCSR.Reg, volatile.LoadUint32(&o.TCSR.Reg)&^(0x2000000)|value<<25)
}
func (o *I2S0_Type) GetTCSR_FR() uint32 {
	return (volatile.LoadUint32(&o.TCSR.Reg) & 0x2000000) >> 25
}
func (o *I2S0_Type) SetTCSR_BCE(value uint32) {
	volatile.StoreUint32(&o.TCSR.Reg, volatile.LoadUint32(&o.TCSR.Reg)&^(0x10000000)|value<<28)
}
func (o *I2S0_Type) GetTCSR_BCE() uint32 {
	return (volatile.LoadUint32(&o.TCSR.Reg) & 0x10000000) >> 28
}
func (o *I2S0_Type) SetTCSR_DBGE(value uint32) {
	volatile.StoreUint32(&o.TCSR.Reg, volatile.LoadUint32(&o.TCSR.Reg)&^(0x20000000)|value<<29)
}
func (o *I2S0_Type) GetTCSR_DBGE() uint32 {
	return (volatile.LoadUint32(&o.TCSR.Reg) & 0x20000000) >> 29
}
func (o *I2S0_Type) SetTCSR_STOPE(value uint32) {
	volatile.StoreUint32(&o.TCSR.Reg, volatile.LoadUint32(&o.TCSR.Reg)&^(0x40000000)|value<<30)
}
func (o *I2S0_Type) GetTCSR_STOPE() uint32 {
	return (volatile.LoadUint32(&o.TCSR.Reg) & 0x40000000) >> 30
}
func (o *I2S0_Type) SetTCSR_TE(value uint32) {
	volatile.StoreUint32(&o.TCSR.Reg, volatile.LoadUint32(&o.TCSR.Reg)&^(0x80000000)|value<<31)
}
func (o *I2S0_Type) GetTCSR_TE() uint32 {
	return (volatile.LoadUint32(&o.TCSR.Reg) & 0x80000000) >> 31
}

// I2S0.TCR1: SAI Transmit Configuration 1 Register
func (o *I2S0_Type) SetTCR1_TFW(value uint32) {
	volatile.StoreUint32(&o.TCR1.Reg, volatile.LoadUint32(&o.TCR1.Reg)&^(0x7)|value)
}
func (o *I2S0_Type) GetTCR1_TFW() uint32 {
	return volatile.LoadUint32(&o.TCR1.Reg) & 0x7
}

// I2S0.TCR2: SAI Transmit Configuration 2 Register
func (o *I2S0_Type) SetTCR2_DIV(value uint32) {
	volatile.StoreUint32(&o.TCR2.Reg, volatile.LoadUint32(&o.TCR2.Reg)&^(0xff)|value)
}
func (o *I2S0_Type) GetTCR2_DIV() uint32 {
	return volatile.LoadUint32(&o.TCR2.Reg) & 0xff
}
func (o *I2S0_Type) SetTCR2_BCD(value uint32) {
	volatile.StoreUint32(&o.TCR2.Reg, volatile.LoadUint32(&o.TCR2.Reg)&^(0x1000000)|value<<24)
}
func (o *I2S0_Type) GetTCR2_BCD() uint32 {
	return (volatile.LoadUint32(&o.TCR2.Reg) & 0x1000000) >> 24
}
func (o *I2S0_Type) SetTCR2_BCP(value uint32) {
	volatile.StoreUint32(&o.TCR2.Reg, volatile.LoadUint32(&o.TCR2.Reg)&^(0x2000000)|value<<25)
}
func (o *I2S0_Type) GetTCR2_BCP() uint32 {
	return (volatile.LoadUint32(&o.TCR2.Reg) & 0x2000000) >> 25
}
func (o *I2S0_Type) SetTCR2_MSEL(value uint32) {
	volatile.StoreUint32(&o.TCR2.Reg, volatile.LoadUint32(&o.TCR2.Reg)&^(0xc000000)|value<<26)
}
func (o *I2S0_Type) GetTCR2_MSEL() uint32 {
	return (volatile.LoadUint32(&o.TCR2.Reg) & 0xc000000) >> 26
}
func (o *I2S0_Type) SetTCR2_BCI(value uint32) {
	volatile.StoreUint32(&o.TCR2.Reg, volatile.LoadUint32(&o.TCR2.Reg)&^(0x10000000)|value<<28)
}
func (o *I2S0_Type) GetTCR2_BCI() uint32 {
	return (volatile.LoadUint32(&o.TCR2.Reg) & 0x10000000) >> 28
}
func (o *I2S0_Type) SetTCR2_BCS(value uint32) {
	volatile.StoreUint32(&o.TCR2.Reg, volatile.LoadUint32(&o.TCR2.Reg)&^(0x20000000)|value<<29)
}
func (o *I2S0_Type) GetTCR2_BCS() uint32 {
	return (volatile.LoadUint32(&o.TCR2.Reg) & 0x20000000) >> 29
}
func (o *I2S0_Type) SetTCR2_SYNC(value uint32) {
	volatile.StoreUint32(&o.TCR2.Reg, volatile.LoadUint32(&o.TCR2.Reg)&^(0xc0000000)|value<<30)
}
func (o *I2S0_Type) GetTCR2_SYNC() uint32 {
	return (volatile.LoadUint32(&o.TCR2.Reg) & 0xc0000000) >> 30
}

// I2S0.TCR3: SAI Transmit Configuration 3 Register
func (o *I2S0_Type) SetTCR3_WDFL(value uint32) {
	volatile.StoreUint32(&o.TCR3.Reg, volatile.LoadUint32(&o.TCR3.Reg)&^(0x1f)|value)
}
func (o *I2S0_Type) GetTCR3_WDFL() uint32 {
	return volatile.LoadUint32(&o.TCR3.Reg) & 0x1f
}
func (o *I2S0_Type) SetTCR3_TCE0(value uint32) {
	volatile.StoreUint32(&o.TCR3.Reg, volatile.LoadUint32(&o.TCR3.Reg)&^(0x10000)|value<<16)
}
func (o *I2S0_Type) GetTCR3_TCE0() uint32 {
	return (volatile.LoadUint32(&o.TCR3.Reg) & 0x10000) >> 16
}
func (o *I2S0_Type) SetTCR3_TCE1(value uint32) {
	volatile.StoreUint32(&o.TCR3.Reg, volatile.LoadUint32(&o.TCR3.Reg)&^(0x20000)|value<<17)
}
func (o *I2S0_Type) GetTCR3_TCE1() uint32 {
	return (volatile.LoadUint32(&o.TCR3.Reg) & 0x20000) >> 17
}

// I2S0.TCR4: SAI Transmit Configuration 4 Register
func (o *I2S0_Type) SetTCR4_FSD(value uint32) {
	volatile.StoreUint32(&o.TCR4.Reg, volatile.LoadUint32(&o.TCR4.Reg)&^(0x1)|value)
}
func (o *I2S0_Type) GetTCR4_FSD() uint32 {
	return volatile.LoadUint32(&o.TCR4.Reg) & 0x1
}
func (o *I2S0_Type) SetTCR4_FSP(value uint32) {
	volatile.StoreUint32(&o.TCR4.Reg, volatile.LoadUint32(&o.TCR4.Reg)&^(0x2)|value<<1)
}
func (o *I2S0_Type) GetTCR4_FSP() uint32 {
	return (volatile.LoadUint32(&o.TCR4.Reg) & 0x2) >> 1
}
func (o *I2S0_Type) SetTCR4_FSE(value uint32) {
	volatile.StoreUint32(&o.TCR4.Reg, volatile.LoadUint32(&o.TCR4.Reg)&^(0x8)|value<<3)
}
func (o *I2S0_Type) GetTCR4_FSE() uint32 {
	return (volatile.LoadUint32(&o.TCR4.Reg) & 0x8) >> 3
}
func (o *I2S0_Type) SetTCR4_MF(value uint32) {
	volatile.StoreUint32(&o.TCR4.Reg, volatile.LoadUint32(&o.TCR4.Reg)&^(0x10)|value<<4)
}
func (o *I2S0_Type) GetTCR4_MF() uint32 {
	return (volatile.LoadUint32(&o.TCR4.Reg) & 0x10) >> 4
}
func (o *I2S0_Type) SetTCR4_SYWD(value uint32) {
	volatile.StoreUint32(&o.TCR4.Reg, volatile.LoadUint32(&o.TCR4.Reg)&^(0x1f00)|value<<8)
}
func (o *I2S0_Type) GetTCR4_SYWD() uint32 {
	return (volatile.LoadUint32(&o.TCR4.Reg) & 0x1f00) >> 8
}
func (o *I2S0_Type) SetTCR4_FRSZ(value uint32) {
	volatile.StoreUint32(&o.TCR4.Reg, volatile.LoadUint32(&o.TCR4.Reg)&^(0x1f0000)|value<<16)
}
func (o *I2S0_Type) GetTCR4_FRSZ() uint32 {
	return (volatile.LoadUint32(&o.TCR4.Reg) & 0x1f0000) >> 16
}

// I2S0.TCR5: SAI Transmit Configuration 5 Register
func (o *I2S0_Type) SetTCR5_FBT(value uint32) {
	volatile.StoreUint32(&o.TCR5.Reg, volatile.LoadUint32(&o.TCR5.Reg)&^(0x1f00)|value<<8)
}
func (o *I2S0_Type) GetTCR5_FBT() uint32 {
	return (volatile.LoadUint32(&o.TCR5.Reg) & 0x1f00) >> 8
}
func (o *I2S0_Type) SetTCR5_W0W(value uint32) {
	volatile.StoreUint32(&o.TCR5.Reg, volatile.LoadUint32(&o.TCR5.Reg)&^(0x1f0000)|value<<16)
}
func (o *I2S0_Type) GetTCR5_W0W() uint32 {
	return (volatile.LoadUint32(&o.TCR5.Reg) & 0x1f0000) >> 16
}
func (o *I2S0_Type) SetTCR5_WNW(value uint32) {
	volatile.StoreUint32(&o.TCR5.Reg, volatile.LoadUint32(&o.TCR5.Reg)&^(0x1f000000)|value<<24)
}
func (o *I2S0_Type) GetTCR5_WNW() uint32 {
	return (volatile.LoadUint32(&o.TCR5.Reg) & 0x1f000000) >> 24
}

// I2S0.TDR0: SAI Transmit Data Register
func (o *I2S0_Type) SetTDR0(value uint32) {
	volatile.StoreUint32(&o.TDR0.Reg, value)
}
func (o *I2S0_Type) GetTDR0() uint32 {
	return volatile.LoadUint32(&o.TDR0.Reg)
}

// I2S0.TDR1: SAI Transmit Data Register
func (o *I2S0_Type) SetTDR1(value uint32) {
	volatile.StoreUint32(&o.TDR1.Reg, value)
}
func (o *I2S0_Type) GetTDR1() uint32 {
	return volatile.LoadUint32(&o.TDR1.Reg)
}

// I2S0.TFR0: SAI Transmit FIFO Register
func (o *I2S0_Type) SetTFR0_RFP(value uint32) {
	volatile.StoreUint32(&o.TFR0.Reg, volatile.LoadUint32(&o.TFR0.Reg)&^(0xf)|value)
}
func (o *I2S0_Type) GetTFR0_RFP() uint32 {
	return volatile.LoadUint32(&o.TFR0.Reg) & 0xf
}
func (o *I2S0_Type) SetTFR0_WFP(value uint32) {
	volatile.StoreUint32(&o.TFR0.Reg, volatile.LoadUint32(&o.TFR0.Reg)&^(0xf0000)|value<<16)
}
func (o *I2S0_Type) GetTFR0_WFP() uint32 {
	return (volatile.LoadUint32(&o.TFR0.Reg) & 0xf0000) >> 16
}

// I2S0.TFR1: SAI Transmit FIFO Register
func (o *I2S0_Type) SetTFR1_RFP(value uint32) {
	volatile.StoreUint32(&o.TFR1.Reg, volatile.LoadUint32(&o.TFR1.Reg)&^(0xf)|value)
}
func (o *I2S0_Type) GetTFR1_RFP() uint32 {
	return volatile.LoadUint32(&o.TFR1.Reg) & 0xf
}
func (o *I2S0_Type) SetTFR1_WFP(value uint32) {
	volatile.StoreUint32(&o.TFR1.Reg, volatile.LoadUint32(&o.TFR1.Reg)&^(0xf0000)|value<<16)
}
func (o *I2S0_Type) GetTFR1_WFP() uint32 {
	return (volatile.LoadUint32(&o.TFR1.Reg) & 0xf0000) >> 16
}

// I2S0.TMR: SAI Transmit Mask Register
func (o *I2S0_Type) SetTMR_TWM0(value uint32) {
	volatile.StoreUint32(&o.TMR.Reg, volatile.LoadUint32(&o.TMR.Reg)&^(0x1)|value)
}
func (o *I2S0_Type) GetTMR_TWM0() uint32 {
	return volatile.LoadUint32(&o.TMR.Reg) & 0x1
}
func (o *I2S0_Type) SetTMR_TWM1(value uint32) {
	volatile.StoreUint32(&o.TMR.Reg, volatile.LoadUint32(&o.TMR.Reg)&^(0x2)|value<<1)
}
func (o *I2S0_Type) GetTMR_TWM1() uint32 {
	return (volatile.LoadUint32(&o.TMR.Reg) & 0x2) >> 1
}
func (o *I2S0_Type) SetTMR_TWM2(value uint32) {
	volatile.StoreUint32(&o.TMR.Reg, volatile.LoadUint32(&o.TMR.Reg)&^(0x4)|value<<2)
}
func (o *I2S0_Type) GetTMR_TWM2() uint32 {
	return (volatile.LoadUint32(&o.TMR.Reg) & 0x4) >> 2
}
func (o *I2S0_Type) SetTMR_TWM3(value uint32) {
	volatile.StoreUint32(&o.TMR.Reg, volatile.LoadUint32(&o.TMR.Reg)&^(0x8)|value<<3)
}
func (o *I2S0_Type) GetTMR_TWM3() uint32 {
	return (volatile.LoadUint32(&o.TMR.Reg) & 0x8) >> 3
}
func (o *I2S0_Type) SetTMR_TWM4(value uint32) {
	volatile.StoreUint32(&o.TMR.Reg, volatile.LoadUint32(&o.TMR.Reg)&^(0x10)|value<<4)
}
func (o *I2S0_Type) GetTMR_TWM4() uint32 {
	return (volatile.LoadUint32(&o.TMR.Reg) & 0x10) >> 4
}
func (o *I2S0_Type) SetTMR_TWM5(value uint32) {
	volatile.StoreUint32(&o.TMR.Reg, volatile.LoadUint32(&o.TMR.Reg)&^(0x20)|value<<5)
}
func (o *I2S0_Type) GetTMR_TWM5() uint32 {
	return (volatile.LoadUint32(&o.TMR.Reg) & 0x20) >> 5
}
func (o *I2S0_Type) SetTMR_TWM6(value uint32) {
	volatile.StoreUint32(&o.TMR.Reg, volatile.LoadUint32(&o.TMR.Reg)&^(0x40)|value<<6)
}
func (o *I2S0_Type) GetTMR_TWM6() uint32 {
	return (volatile.LoadUint32(&o.TMR.Reg) & 0x40) >> 6
}
func (o *I2S0_Type) SetTMR_TWM7(value uint32) {
	volatile.StoreUint32(&o.TMR.Reg, volatile.LoadUint32(&o.TMR.Reg)&^(0x80)|value<<7)
}
func (o *I2S0_Type) GetTMR_TWM7() uint32 {
	return (volatile.LoadUint32(&o.TMR.Reg) & 0x80) >> 7
}
func (o *I2S0_Type) SetTMR_TWM8(value uint32) {
	volatile.StoreUint32(&o.TMR.Reg, volatile.LoadUint32(&o.TMR.Reg)&^(0x100)|value<<8)
}
func (o *I2S0_Type) GetTMR_TWM8() uint32 {
	return (volatile.LoadUint32(&o.TMR.Reg) & 0x100) >> 8
}
func (o *I2S0_Type) SetTMR_TWM9(value uint32) {
	volatile.StoreUint32(&o.TMR.Reg, volatile.LoadUint32(&o.TMR.Reg)&^(0x200)|value<<9)
}
func (o *I2S0_Type) GetTMR_TWM9() uint32 {
	return (volatile.LoadUint32(&o.TMR.Reg) & 0x200) >> 9
}
func (o *I2S0_Type) SetTMR_TWM10(value uint32) {
	volatile.StoreUint32(&o.TMR.Reg, volatile.LoadUint32(&o.TMR.Reg)&^(0x400)|value<<10)
}
func (o *I2S0_Type) GetTMR_TWM10() uint32 {
	return (volatile.LoadUint32(&o.TMR.Reg) & 0x400) >> 10
}
func (o *I2S0_Type) SetTMR_TWM11(value uint32) {
	volatile.StoreUint32(&o.TMR.Reg, volatile.LoadUint32(&o.TMR.Reg)&^(0x800)|value<<11)
}
func (o *I2S0_Type) GetTMR_TWM11() uint32 {
	return (volatile.LoadUint32(&o.TMR.Reg) & 0x800) >> 11
}
func (o *I2S0_Type) SetTMR_TWM12(value uint32) {
	volatile.StoreUint32(&o.TMR.Reg, volatile.LoadUint32(&o.TMR.Reg)&^(0x1000)|value<<12)
}
func (o *I2S0_Type) GetTMR_TWM12() uint32 {
	return (volatile.LoadUint32(&o.TMR.Reg) & 0x1000) >> 12
}
func (o *I2S0_Type) SetTMR_TWM13(value uint32) {
	volatile.StoreUint32(&o.TMR.Reg, volatile.LoadUint32(&o.TMR.Reg)&^(0x2000)|value<<13)
}
func (o *I2S0_Type) GetTMR_TWM13() uint32 {
	return (volatile.LoadUint32(&o.TMR.Reg) & 0x2000) >> 13
}
func (o *I2S0_Type) SetTMR_TWM14(value uint32) {
	volatile.StoreUint32(&o.TMR.Reg, volatile.LoadUint32(&o.TMR.Reg)&^(0x4000)|value<<14)
}
func (o *I2S0_Type) GetTMR_TWM14() uint32 {
	return (volatile.LoadUint32(&o.TMR.Reg) & 0x4000) >> 14
}
func (o *I2S0_Type) SetTMR_TWM15(value uint32) {
	volatile.StoreUint32(&o.TMR.Reg, volatile.LoadUint32(&o.TMR.Reg)&^(0x8000)|value<<15)
}
func (o *I2S0_Type) GetTMR_TWM15() uint32 {
	return (volatile.LoadUint32(&o.TMR.Reg) & 0x8000) >> 15
}
func (o *I2S0_Type) SetTMR_TWM16(value uint32) {
	volatile.StoreUint32(&o.TMR.Reg, volatile.LoadUint32(&o.TMR.Reg)&^(0x10000)|value<<16)
}
func (o *I2S0_Type) GetTMR_TWM16() uint32 {
	return (volatile.LoadUint32(&o.TMR.Reg) & 0x10000) >> 16
}
func (o *I2S0_Type) SetTMR_TWM17(value uint32) {
	volatile.StoreUint32(&o.TMR.Reg, volatile.LoadUint32(&o.TMR.Reg)&^(0x20000)|value<<17)
}
func (o *I2S0_Type) GetTMR_TWM17() uint32 {
	return (volatile.LoadUint32(&o.TMR.Reg) & 0x20000) >> 17
}
func (o *I2S0_Type) SetTMR_TWM18(value uint32) {
	volatile.StoreUint32(&o.TMR.Reg, volatile.LoadUint32(&o.TMR.Reg)&^(0x40000)|value<<18)
}
func (o *I2S0_Type) GetTMR_TWM18() uint32 {
	return (volatile.LoadUint32(&o.TMR.Reg) & 0x40000) >> 18
}
func (o *I2S0_Type) SetTMR_TWM19(value uint32) {
	volatile.StoreUint32(&o.TMR.Reg, volatile.LoadUint32(&o.TMR.Reg)&^(0x80000)|value<<19)
}
func (o *I2S0_Type) GetTMR_TWM19() uint32 {
	return (volatile.LoadUint32(&o.TMR.Reg) & 0x80000) >> 19
}
func (o *I2S0_Type) SetTMR_TWM20(value uint32) {
	volatile.StoreUint32(&o.TMR.Reg, volatile.LoadUint32(&o.TMR.Reg)&^(0x100000)|value<<20)
}
func (o *I2S0_Type) GetTMR_TWM20() uint32 {
	return (volatile.LoadUint32(&o.TMR.Reg) & 0x100000) >> 20
}
func (o *I2S0_Type) SetTMR_TWM21(value uint32) {
	volatile.StoreUint32(&o.TMR.Reg, volatile.LoadUint32(&o.TMR.Reg)&^(0x200000)|value<<21)
}
func (o *I2S0_Type) GetTMR_TWM21() uint32 {
	return (volatile.LoadUint32(&o.TMR.Reg) & 0x200000) >> 21
}
func (o *I2S0_Type) SetTMR_TWM22(value uint32) {
	volatile.StoreUint32(&o.TMR.Reg, volatile.LoadUint32(&o.TMR.Reg)&^(0x400000)|value<<22)
}
func (o *I2S0_Type) GetTMR_TWM22() uint32 {
	return (volatile.LoadUint32(&o.TMR.Reg) & 0x400000) >> 22
}
func (o *I2S0_Type) SetTMR_TWM23(value uint32) {
	volatile.StoreUint32(&o.TMR.Reg, volatile.LoadUint32(&o.TMR.Reg)&^(0x800000)|value<<23)
}
func (o *I2S0_Type) GetTMR_TWM23() uint32 {
	return (volatile.LoadUint32(&o.TMR.Reg) & 0x800000) >> 23
}
func (o *I2S0_Type) SetTMR_TWM24(value uint32) {
	volatile.StoreUint32(&o.TMR.Reg, volatile.LoadUint32(&o.TMR.Reg)&^(0x1000000)|value<<24)
}
func (o *I2S0_Type) GetTMR_TWM24() uint32 {
	return (volatile.LoadUint32(&o.TMR.Reg) & 0x1000000) >> 24
}
func (o *I2S0_Type) SetTMR_TWM25(value uint32) {
	volatile.StoreUint32(&o.TMR.Reg, volatile.LoadUint32(&o.TMR.Reg)&^(0x2000000)|value<<25)
}
func (o *I2S0_Type) GetTMR_TWM25() uint32 {
	return (volatile.LoadUint32(&o.TMR.Reg) & 0x2000000) >> 25
}
func (o *I2S0_Type) SetTMR_TWM26(value uint32) {
	volatile.StoreUint32(&o.TMR.Reg, volatile.LoadUint32(&o.TMR.Reg)&^(0x4000000)|value<<26)
}
func (o *I2S0_Type) GetTMR_TWM26() uint32 {
	return (volatile.LoadUint32(&o.TMR.Reg) & 0x4000000) >> 26
}
func (o *I2S0_Type) SetTMR_TWM27(value uint32) {
	volatile.StoreUint32(&o.TMR.Reg, volatile.LoadUint32(&o.TMR.Reg)&^(0x8000000)|value<<27)
}
func (o *I2S0_Type) GetTMR_TWM27() uint32 {
	return (volatile.LoadUint32(&o.TMR.Reg) & 0x8000000) >> 27
}
func (o *I2S0_Type) SetTMR_TWM28(value uint32) {
	volatile.StoreUint32(&o.TMR.Reg, volatile.LoadUint32(&o.TMR.Reg)&^(0x10000000)|value<<28)
}
func (o *I2S0_Type) GetTMR_TWM28() uint32 {
	return (volatile.LoadUint32(&o.TMR.Reg) & 0x10000000) >> 28
}
func (o *I2S0_Type) SetTMR_TWM29(value uint32) {
	volatile.StoreUint32(&o.TMR.Reg, volatile.LoadUint32(&o.TMR.Reg)&^(0x20000000)|value<<29)
}
func (o *I2S0_Type) GetTMR_TWM29() uint32 {
	return (volatile.LoadUint32(&o.TMR.Reg) & 0x20000000) >> 29
}
func (o *I2S0_Type) SetTMR_TWM30(value uint32) {
	volatile.StoreUint32(&o.TMR.Reg, volatile.LoadUint32(&o.TMR.Reg)&^(0x40000000)|value<<30)
}
func (o *I2S0_Type) GetTMR_TWM30() uint32 {
	return (volatile.LoadUint32(&o.TMR.Reg) & 0x40000000) >> 30
}
func (o *I2S0_Type) SetTMR_TWM31(value uint32) {
	volatile.StoreUint32(&o.TMR.Reg, volatile.LoadUint32(&o.TMR.Reg)&^(0x80000000)|value<<31)
}
func (o *I2S0_Type) GetTMR_TWM31() uint32 {
	return (volatile.LoadUint32(&o.TMR.Reg) & 0x80000000) >> 31
}

// I2S0.RCSR: SAI Receive Control Register
func (o *I2S0_Type) SetRCSR_FRDE(value uint32) {
	volatile.StoreUint32(&o.RCSR.Reg, volatile.LoadUint32(&o.RCSR.Reg)&^(0x1)|value)
}
func (o *I2S0_Type) GetRCSR_FRDE() uint32 {
	return volatile.LoadUint32(&o.RCSR.Reg) & 0x1
}
func (o *I2S0_Type) SetRCSR_FWDE(value uint32) {
	volatile.StoreUint32(&o.RCSR.Reg, volatile.LoadUint32(&o.RCSR.Reg)&^(0x2)|value<<1)
}
func (o *I2S0_Type) GetRCSR_FWDE() uint32 {
	return (volatile.LoadUint32(&o.RCSR.Reg) & 0x2) >> 1
}
func (o *I2S0_Type) SetRCSR_FRIE(value uint32) {
	volatile.StoreUint32(&o.RCSR.Reg, volatile.LoadUint32(&o.RCSR.Reg)&^(0x100)|value<<8)
}
func (o *I2S0_Type) GetRCSR_FRIE() uint32 {
	return (volatile.LoadUint32(&o.RCSR.Reg) & 0x100) >> 8
}
func (o *I2S0_Type) SetRCSR_FWIE(value uint32) {
	volatile.StoreUint32(&o.RCSR.Reg, volatile.LoadUint32(&o.RCSR.Reg)&^(0x200)|value<<9)
}
func (o *I2S0_Type) GetRCSR_FWIE() uint32 {
	return (volatile.LoadUint32(&o.RCSR.Reg) & 0x200) >> 9
}
func (o *I2S0_Type) SetRCSR_FEIE(value uint32) {
	volatile.StoreUint32(&o.RCSR.Reg, volatile.LoadUint32(&o.RCSR.Reg)&^(0x400)|value<<10)
}
func (o *I2S0_Type) GetRCSR_FEIE() uint32 {
	return (volatile.LoadUint32(&o.RCSR.Reg) & 0x400) >> 10
}
func (o *I2S0_Type) SetRCSR_SEIE(value uint32) {
	volatile.StoreUint32(&o.RCSR.Reg, volatile.LoadUint32(&o.RCSR.Reg)&^(0x800)|value<<11)
}
func (o *I2S0_Type) GetRCSR_SEIE() uint32 {
	return (volatile.LoadUint32(&o.RCSR.Reg) & 0x800) >> 11
}
func (o *I2S0_Type) SetRCSR_WSIE(value uint32) {
	volatile.StoreUint32(&o.RCSR.Reg, volatile.LoadUint32(&o.RCSR.Reg)&^(0x1000)|value<<12)
}
func (o *I2S0_Type) GetRCSR_WSIE() uint32 {
	return (volatile.LoadUint32(&o.RCSR.Reg) & 0x1000) >> 12
}
func (o *I2S0_Type) SetRCSR_FRF(value uint32) {
	volatile.StoreUint32(&o.RCSR.Reg, volatile.LoadUint32(&o.RCSR.Reg)&^(0x10000)|value<<16)
}
func (o *I2S0_Type) GetRCSR_FRF() uint32 {
	return (volatile.LoadUint32(&o.RCSR.Reg) & 0x10000) >> 16
}
func (o *I2S0_Type) SetRCSR_FWF(value uint32) {
	volatile.StoreUint32(&o.RCSR.Reg, volatile.LoadUint32(&o.RCSR.Reg)&^(0x20000)|value<<17)
}
func (o *I2S0_Type) GetRCSR_FWF() uint32 {
	return (volatile.LoadUint32(&o.RCSR.Reg) & 0x20000) >> 17
}
func (o *I2S0_Type) SetRCSR_FEF(value uint32) {
	volatile.StoreUint32(&o.RCSR.Reg, volatile.LoadUint32(&o.RCSR.Reg)&^(0x40000)|value<<18)
}
func (o *I2S0_Type) GetRCSR_FEF() uint32 {
	return (volatile.LoadUint32(&o.RCSR.Reg) & 0x40000) >> 18
}
func (o *I2S0_Type) SetRCSR_SEF(value uint32) {
	volatile.StoreUint32(&o.RCSR.Reg, volatile.LoadUint32(&o.RCSR.Reg)&^(0x80000)|value<<19)
}
func (o *I2S0_Type) GetRCSR_SEF() uint32 {
	return (volatile.LoadUint32(&o.RCSR.Reg) & 0x80000) >> 19
}
func (o *I2S0_Type) SetRCSR_WSF(value uint32) {
	volatile.StoreUint32(&o.RCSR.Reg, volatile.LoadUint32(&o.RCSR.Reg)&^(0x100000)|value<<20)
}
func (o *I2S0_Type) GetRCSR_WSF() uint32 {
	return (volatile.LoadUint32(&o.RCSR.Reg) & 0x100000) >> 20
}
func (o *I2S0_Type) SetRCSR_SR(value uint32) {
	volatile.StoreUint32(&o.RCSR.Reg, volatile.LoadUint32(&o.RCSR.Reg)&^(0x1000000)|value<<24)
}
func (o *I2S0_Type) GetRCSR_SR() uint32 {
	return (volatile.LoadUint32(&o.RCSR.Reg) & 0x1000000) >> 24
}
func (o *I2S0_Type) SetRCSR_FR(value uint32) {
	volatile.StoreUint32(&o.RCSR.Reg, volatile.LoadUint32(&o.RCSR.Reg)&^(0x2000000)|value<<25)
}
func (o *I2S0_Type) GetRCSR_FR() uint32 {
	return (volatile.LoadUint32(&o.RCSR.Reg) & 0x2000000) >> 25
}
func (o *I2S0_Type) SetRCSR_BCE(value uint32) {
	volatile.StoreUint32(&o.RCSR.Reg, volatile.LoadUint32(&o.RCSR.Reg)&^(0x10000000)|value<<28)
}
func (o *I2S0_Type) GetRCSR_BCE() uint32 {
	return (volatile.LoadUint32(&o.RCSR.Reg) & 0x10000000) >> 28
}
func (o *I2S0_Type) SetRCSR_DBGE(value uint32) {
	volatile.StoreUint32(&o.RCSR.Reg, volatile.LoadUint32(&o.RCSR.Reg)&^(0x20000000)|value<<29)
}
func (o *I2S0_Type) GetRCSR_DBGE() uint32 {
	return (volatile.LoadUint32(&o.RCSR.Reg) & 0x20000000) >> 29
}
func (o *I2S0_Type) SetRCSR_STOPE(value uint32) {
	volatile.StoreUint32(&o.RCSR.Reg, volatile.LoadUint32(&o.RCSR.Reg)&^(0x40000000)|value<<30)
}
func (o *I2S0_Type) GetRCSR_STOPE() uint32 {
	return (volatile.LoadUint32(&o.RCSR.Reg) & 0x40000000) >> 30
}
func (o *I2S0_Type) SetRCSR_RE(value uint32) {
	volatile.StoreUint32(&o.RCSR.Reg, volatile.LoadUint32(&o.RCSR.Reg)&^(0x80000000)|value<<31)
}
func (o *I2S0_Type) GetRCSR_RE() uint32 {
	return (volatile.LoadUint32(&o.RCSR.Reg) & 0x80000000) >> 31
}

// I2S0.RCR1: SAI Receive Configuration 1 Register
func (o *I2S0_Type) SetRCR1_RFW(value uint32) {
	volatile.StoreUint32(&o.RCR1.Reg, volatile.LoadUint32(&o.RCR1.Reg)&^(0x7)|value)
}
func (o *I2S0_Type) GetRCR1_RFW() uint32 {
	return volatile.LoadUint32(&o.RCR1.Reg) & 0x7
}

// I2S0.RCR2: SAI Receive Configuration 2 Register
func (o *I2S0_Type) SetRCR2_DIV(value uint32) {
	volatile.StoreUint32(&o.RCR2.Reg, volatile.LoadUint32(&o.RCR2.Reg)&^(0xff)|value)
}
func (o *I2S0_Type) GetRCR2_DIV() uint32 {
	return volatile.LoadUint32(&o.RCR2.Reg) & 0xff
}
func (o *I2S0_Type) SetRCR2_BCD(value uint32) {
	volatile.StoreUint32(&o.RCR2.Reg, volatile.LoadUint32(&o.RCR2.Reg)&^(0x1000000)|value<<24)
}
func (o *I2S0_Type) GetRCR2_BCD() uint32 {
	return (volatile.LoadUint32(&o.RCR2.Reg) & 0x1000000) >> 24
}
func (o *I2S0_Type) SetRCR2_BCP(value uint32) {
	volatile.StoreUint32(&o.RCR2.Reg, volatile.LoadUint32(&o.RCR2.Reg)&^(0x2000000)|value<<25)
}
func (o *I2S0_Type) GetRCR2_BCP() uint32 {
	return (volatile.LoadUint32(&o.RCR2.Reg) & 0x2000000) >> 25
}
func (o *I2S0_Type) SetRCR2_MSEL(value uint32) {
	volatile.StoreUint32(&o.RCR2.Reg, volatile.LoadUint32(&o.RCR2.Reg)&^(0xc000000)|value<<26)
}
func (o *I2S0_Type) GetRCR2_MSEL() uint32 {
	return (volatile.LoadUint32(&o.RCR2.Reg) & 0xc000000) >> 26
}
func (o *I2S0_Type) SetRCR2_BCI(value uint32) {
	volatile.StoreUint32(&o.RCR2.Reg, volatile.LoadUint32(&o.RCR2.Reg)&^(0x10000000)|value<<28)
}
func (o *I2S0_Type) GetRCR2_BCI() uint32 {
	return (volatile.LoadUint32(&o.RCR2.Reg) & 0x10000000) >> 28
}
func (o *I2S0_Type) SetRCR2_BCS(value uint32) {
	volatile.StoreUint32(&o.RCR2.Reg, volatile.LoadUint32(&o.RCR2.Reg)&^(0x20000000)|value<<29)
}
func (o *I2S0_Type) GetRCR2_BCS() uint32 {
	return (volatile.LoadUint32(&o.RCR2.Reg) & 0x20000000) >> 29
}
func (o *I2S0_Type) SetRCR2_SYNC(value uint32) {
	volatile.StoreUint32(&o.RCR2.Reg, volatile.LoadUint32(&o.RCR2.Reg)&^(0xc0000000)|value<<30)
}
func (o *I2S0_Type) GetRCR2_SYNC() uint32 {
	return (volatile.LoadUint32(&o.RCR2.Reg) & 0xc0000000) >> 30
}

// I2S0.RCR3: SAI Receive Configuration 3 Register
func (o *I2S0_Type) SetRCR3_WDFL(value uint32) {
	volatile.StoreUint32(&o.RCR3.Reg, volatile.LoadUint32(&o.RCR3.Reg)&^(0x1f)|value)
}
func (o *I2S0_Type) GetRCR3_WDFL() uint32 {
	return volatile.LoadUint32(&o.RCR3.Reg) & 0x1f
}
func (o *I2S0_Type) SetRCR3_RCE0(value uint32) {
	volatile.StoreUint32(&o.RCR3.Reg, volatile.LoadUint32(&o.RCR3.Reg)&^(0x10000)|value<<16)
}
func (o *I2S0_Type) GetRCR3_RCE0() uint32 {
	return (volatile.LoadUint32(&o.RCR3.Reg) & 0x10000) >> 16
}
func (o *I2S0_Type) SetRCR3_RCE1(value uint32) {
	volatile.StoreUint32(&o.RCR3.Reg, volatile.LoadUint32(&o.RCR3.Reg)&^(0x20000)|value<<17)
}
func (o *I2S0_Type) GetRCR3_RCE1() uint32 {
	return (volatile.LoadUint32(&o.RCR3.Reg) & 0x20000) >> 17
}

// I2S0.RCR4: SAI Receive Configuration 4 Register
func (o *I2S0_Type) SetRCR4_FSD(value uint32) {
	volatile.StoreUint32(&o.RCR4.Reg, volatile.LoadUint32(&o.RCR4.Reg)&^(0x1)|value)
}
func (o *I2S0_Type) GetRCR4_FSD() uint32 {
	return volatile.LoadUint32(&o.RCR4.Reg) & 0x1
}
func (o *I2S0_Type) SetRCR4_FSP(value uint32) {
	volatile.StoreUint32(&o.RCR4.Reg, volatile.LoadUint32(&o.RCR4.Reg)&^(0x2)|value<<1)
}
func (o *I2S0_Type) GetRCR4_FSP() uint32 {
	return (volatile.LoadUint32(&o.RCR4.Reg) & 0x2) >> 1
}
func (o *I2S0_Type) SetRCR4_FSE(value uint32) {
	volatile.StoreUint32(&o.RCR4.Reg, volatile.LoadUint32(&o.RCR4.Reg)&^(0x8)|value<<3)
}
func (o *I2S0_Type) GetRCR4_FSE() uint32 {
	return (volatile.LoadUint32(&o.RCR4.Reg) & 0x8) >> 3
}
func (o *I2S0_Type) SetRCR4_MF(value uint32) {
	volatile.StoreUint32(&o.RCR4.Reg, volatile.LoadUint32(&o.RCR4.Reg)&^(0x10)|value<<4)
}
func (o *I2S0_Type) GetRCR4_MF() uint32 {
	return (volatile.LoadUint32(&o.RCR4.Reg) & 0x10) >> 4
}
func (o *I2S0_Type) SetRCR4_SYWD(value uint32) {
	volatile.StoreUint32(&o.RCR4.Reg, volatile.LoadUint32(&o.RCR4.Reg)&^(0x1f00)|value<<8)
}
func (o *I2S0_Type) GetRCR4_SYWD() uint32 {
	return (volatile.LoadUint32(&o.RCR4.Reg) & 0x1f00) >> 8
}
func (o *I2S0_Type) SetRCR4_FRSZ(value uint32) {
	volatile.StoreUint32(&o.RCR4.Reg, volatile.LoadUint32(&o.RCR4.Reg)&^(0x1f0000)|value<<16)
}
func (o *I2S0_Type) GetRCR4_FRSZ() uint32 {
	return (volatile.LoadUint32(&o.RCR4.Reg) & 0x1f0000) >> 16
}

// I2S0.RCR5: SAI Receive Configuration 5 Register
func (o *I2S0_Type) SetRCR5_FBT(value uint32) {
	volatile.StoreUint32(&o.RCR5.Reg, volatile.LoadUint32(&o.RCR5.Reg)&^(0x1f00)|value<<8)
}
func (o *I2S0_Type) GetRCR5_FBT() uint32 {
	return (volatile.LoadUint32(&o.RCR5.Reg) & 0x1f00) >> 8
}
func (o *I2S0_Type) SetRCR5_W0W(value uint32) {
	volatile.StoreUint32(&o.RCR5.Reg, volatile.LoadUint32(&o.RCR5.Reg)&^(0x1f0000)|value<<16)
}
func (o *I2S0_Type) GetRCR5_W0W() uint32 {
	return (volatile.LoadUint32(&o.RCR5.Reg) & 0x1f0000) >> 16
}
func (o *I2S0_Type) SetRCR5_WNW(value uint32) {
	volatile.StoreUint32(&o.RCR5.Reg, volatile.LoadUint32(&o.RCR5.Reg)&^(0x1f000000)|value<<24)
}
func (o *I2S0_Type) GetRCR5_WNW() uint32 {
	return (volatile.LoadUint32(&o.RCR5.Reg) & 0x1f000000) >> 24
}

// I2S0.RDR0: SAI Receive Data Register
func (o *I2S0_Type) SetRDR0(value uint32) {
	volatile.StoreUint32(&o.RDR0.Reg, value)
}
func (o *I2S0_Type) GetRDR0() uint32 {
	return volatile.LoadUint32(&o.RDR0.Reg)
}

// I2S0.RDR1: SAI Receive Data Register
func (o *I2S0_Type) SetRDR1(value uint32) {
	volatile.StoreUint32(&o.RDR1.Reg, value)
}
func (o *I2S0_Type) GetRDR1() uint32 {
	return volatile.LoadUint32(&o.RDR1.Reg)
}

// I2S0.RFR0: SAI Receive FIFO Register
func (o *I2S0_Type) SetRFR0_RFP(value uint32) {
	volatile.StoreUint32(&o.RFR0.Reg, volatile.LoadUint32(&o.RFR0.Reg)&^(0xf)|value)
}
func (o *I2S0_Type) GetRFR0_RFP() uint32 {
	return volatile.LoadUint32(&o.RFR0.Reg) & 0xf
}
func (o *I2S0_Type) SetRFR0_WFP(value uint32) {
	volatile.StoreUint32(&o.RFR0.Reg, volatile.LoadUint32(&o.RFR0.Reg)&^(0xf0000)|value<<16)
}
func (o *I2S0_Type) GetRFR0_WFP() uint32 {
	return (volatile.LoadUint32(&o.RFR0.Reg) & 0xf0000) >> 16
}

// I2S0.RFR1: SAI Receive FIFO Register
func (o *I2S0_Type) SetRFR1_RFP(value uint32) {
	volatile.StoreUint32(&o.RFR1.Reg, volatile.LoadUint32(&o.RFR1.Reg)&^(0xf)|value)
}
func (o *I2S0_Type) GetRFR1_RFP() uint32 {
	return volatile.LoadUint32(&o.RFR1.Reg) & 0xf
}
func (o *I2S0_Type) SetRFR1_WFP(value uint32) {
	volatile.StoreUint32(&o.RFR1.Reg, volatile.LoadUint32(&o.RFR1.Reg)&^(0xf0000)|value<<16)
}
func (o *I2S0_Type) GetRFR1_WFP() uint32 {
	return (volatile.LoadUint32(&o.RFR1.Reg) & 0xf0000) >> 16
}

// I2S0.RMR: SAI Receive Mask Register
func (o *I2S0_Type) SetRMR_RWM0(value uint32) {
	volatile.StoreUint32(&o.RMR.Reg, volatile.LoadUint32(&o.RMR.Reg)&^(0x1)|value)
}
func (o *I2S0_Type) GetRMR_RWM0() uint32 {
	return volatile.LoadUint32(&o.RMR.Reg) & 0x1
}
func (o *I2S0_Type) SetRMR_RWM1(value uint32) {
	volatile.StoreUint32(&o.RMR.Reg, volatile.LoadUint32(&o.RMR.Reg)&^(0x2)|value<<1)
}
func (o *I2S0_Type) GetRMR_RWM1() uint32 {
	return (volatile.LoadUint32(&o.RMR.Reg) & 0x2) >> 1
}
func (o *I2S0_Type) SetRMR_RWM2(value uint32) {
	volatile.StoreUint32(&o.RMR.Reg, volatile.LoadUint32(&o.RMR.Reg)&^(0x4)|value<<2)
}
func (o *I2S0_Type) GetRMR_RWM2() uint32 {
	return (volatile.LoadUint32(&o.RMR.Reg) & 0x4) >> 2
}
func (o *I2S0_Type) SetRMR_RWM3(value uint32) {
	volatile.StoreUint32(&o.RMR.Reg, volatile.LoadUint32(&o.RMR.Reg)&^(0x8)|value<<3)
}
func (o *I2S0_Type) GetRMR_RWM3() uint32 {
	return (volatile.LoadUint32(&o.RMR.Reg) & 0x8) >> 3
}
func (o *I2S0_Type) SetRMR_RWM4(value uint32) {
	volatile.StoreUint32(&o.RMR.Reg, volatile.LoadUint32(&o.RMR.Reg)&^(0x10)|value<<4)
}
func (o *I2S0_Type) GetRMR_RWM4() uint32 {
	return (volatile.LoadUint32(&o.RMR.Reg) & 0x10) >> 4
}
func (o *I2S0_Type) SetRMR_RWM5(value uint32) {
	volatile.StoreUint32(&o.RMR.Reg, volatile.LoadUint32(&o.RMR.Reg)&^(0x20)|value<<5)
}
func (o *I2S0_Type) GetRMR_RWM5() uint32 {
	return (volatile.LoadUint32(&o.RMR.Reg) & 0x20) >> 5
}
func (o *I2S0_Type) SetRMR_RWM6(value uint32) {
	volatile.StoreUint32(&o.RMR.Reg, volatile.LoadUint32(&o.RMR.Reg)&^(0x40)|value<<6)
}
func (o *I2S0_Type) GetRMR_RWM6() uint32 {
	return (volatile.LoadUint32(&o.RMR.Reg) & 0x40) >> 6
}
func (o *I2S0_Type) SetRMR_RWM7(value uint32) {
	volatile.StoreUint32(&o.RMR.Reg, volatile.LoadUint32(&o.RMR.Reg)&^(0x80)|value<<7)
}
func (o *I2S0_Type) GetRMR_RWM7() uint32 {
	return (volatile.LoadUint32(&o.RMR.Reg) & 0x80) >> 7
}
func (o *I2S0_Type) SetRMR_RWM8(value uint32) {
	volatile.StoreUint32(&o.RMR.Reg, volatile.LoadUint32(&o.RMR.Reg)&^(0x100)|value<<8)
}
func (o *I2S0_Type) GetRMR_RWM8() uint32 {
	return (volatile.LoadUint32(&o.RMR.Reg) & 0x100) >> 8
}
func (o *I2S0_Type) SetRMR_RWM9(value uint32) {
	volatile.StoreUint32(&o.RMR.Reg, volatile.LoadUint32(&o.RMR.Reg)&^(0x200)|value<<9)
}
func (o *I2S0_Type) GetRMR_RWM9() uint32 {
	return (volatile.LoadUint32(&o.RMR.Reg) & 0x200) >> 9
}
func (o *I2S0_Type) SetRMR_RWM10(value uint32) {
	volatile.StoreUint32(&o.RMR.Reg, volatile.LoadUint32(&o.RMR.Reg)&^(0x400)|value<<10)
}
func (o *I2S0_Type) GetRMR_RWM10() uint32 {
	return (volatile.LoadUint32(&o.RMR.Reg) & 0x400) >> 10
}
func (o *I2S0_Type) SetRMR_RWM11(value uint32) {
	volatile.StoreUint32(&o.RMR.Reg, volatile.LoadUint32(&o.RMR.Reg)&^(0x800)|value<<11)
}
func (o *I2S0_Type) GetRMR_RWM11() uint32 {
	return (volatile.LoadUint32(&o.RMR.Reg) & 0x800) >> 11
}
func (o *I2S0_Type) SetRMR_RWM12(value uint32) {
	volatile.StoreUint32(&o.RMR.Reg, volatile.LoadUint32(&o.RMR.Reg)&^(0x1000)|value<<12)
}
func (o *I2S0_Type) GetRMR_RWM12() uint32 {
	return (volatile.LoadUint32(&o.RMR.Reg) & 0x1000) >> 12
}
func (o *I2S0_Type) SetRMR_RWM13(value uint32) {
	volatile.StoreUint32(&o.RMR.Reg, volatile.LoadUint32(&o.RMR.Reg)&^(0x2000)|value<<13)
}
func (o *I2S0_Type) GetRMR_RWM13() uint32 {
	return (volatile.LoadUint32(&o.RMR.Reg) & 0x2000) >> 13
}
func (o *I2S0_Type) SetRMR_RWM14(value uint32) {
	volatile.StoreUint32(&o.RMR.Reg, volatile.LoadUint32(&o.RMR.Reg)&^(0x4000)|value<<14)
}
func (o *I2S0_Type) GetRMR_RWM14() uint32 {
	return (volatile.LoadUint32(&o.RMR.Reg) & 0x4000) >> 14
}
func (o *I2S0_Type) SetRMR_RWM15(value uint32) {
	volatile.StoreUint32(&o.RMR.Reg, volatile.LoadUint32(&o.RMR.Reg)&^(0x8000)|value<<15)
}
func (o *I2S0_Type) GetRMR_RWM15() uint32 {
	return (volatile.LoadUint32(&o.RMR.Reg) & 0x8000) >> 15
}
func (o *I2S0_Type) SetRMR_RWM16(value uint32) {
	volatile.StoreUint32(&o.RMR.Reg, volatile.LoadUint32(&o.RMR.Reg)&^(0x10000)|value<<16)
}
func (o *I2S0_Type) GetRMR_RWM16() uint32 {
	return (volatile.LoadUint32(&o.RMR.Reg) & 0x10000) >> 16
}
func (o *I2S0_Type) SetRMR_RWM17(value uint32) {
	volatile.StoreUint32(&o.RMR.Reg, volatile.LoadUint32(&o.RMR.Reg)&^(0x20000)|value<<17)
}
func (o *I2S0_Type) GetRMR_RWM17() uint32 {
	return (volatile.LoadUint32(&o.RMR.Reg) & 0x20000) >> 17
}
func (o *I2S0_Type) SetRMR_RWM18(value uint32) {
	volatile.StoreUint32(&o.RMR.Reg, volatile.LoadUint32(&o.RMR.Reg)&^(0x40000)|value<<18)
}
func (o *I2S0_Type) GetRMR_RWM18() uint32 {
	return (volatile.LoadUint32(&o.RMR.Reg) & 0x40000) >> 18
}
func (o *I2S0_Type) SetRMR_RWM19(value uint32) {
	volatile.StoreUint32(&o.RMR.Reg, volatile.LoadUint32(&o.RMR.Reg)&^(0x80000)|value<<19)
}
func (o *I2S0_Type) GetRMR_RWM19() uint32 {
	return (volatile.LoadUint32(&o.RMR.Reg) & 0x80000) >> 19
}
func (o *I2S0_Type) SetRMR_RWM20(value uint32) {
	volatile.StoreUint32(&o.RMR.Reg, volatile.LoadUint32(&o.RMR.Reg)&^(0x100000)|value<<20)
}
func (o *I2S0_Type) GetRMR_RWM20() uint32 {
	return (volatile.LoadUint32(&o.RMR.Reg) & 0x100000) >> 20
}
func (o *I2S0_Type) SetRMR_RWM21(value uint32) {
	volatile.StoreUint32(&o.RMR.Reg, volatile.LoadUint32(&o.RMR.Reg)&^(0x200000)|value<<21)
}
func (o *I2S0_Type) GetRMR_RWM21() uint32 {
	return (volatile.LoadUint32(&o.RMR.Reg) & 0x200000) >> 21
}
func (o *I2S0_Type) SetRMR_RWM22(value uint32) {
	volatile.StoreUint32(&o.RMR.Reg, volatile.LoadUint32(&o.RMR.Reg)&^(0x400000)|value<<22)
}
func (o *I2S0_Type) GetRMR_RWM22() uint32 {
	return (volatile.LoadUint32(&o.RMR.Reg) & 0x400000) >> 22
}
func (o *I2S0_Type) SetRMR_RWM23(value uint32) {
	volatile.StoreUint32(&o.RMR.Reg, volatile.LoadUint32(&o.RMR.Reg)&^(0x800000)|value<<23)
}
func (o *I2S0_Type) GetRMR_RWM23() uint32 {
	return (volatile.LoadUint32(&o.RMR.Reg) & 0x800000) >> 23
}
func (o *I2S0_Type) SetRMR_RWM24(value uint32) {
	volatile.StoreUint32(&o.RMR.Reg, volatile.LoadUint32(&o.RMR.Reg)&^(0x1000000)|value<<24)
}
func (o *I2S0_Type) GetRMR_RWM24() uint32 {
	return (volatile.LoadUint32(&o.RMR.Reg) & 0x1000000) >> 24
}
func (o *I2S0_Type) SetRMR_RWM25(value uint32) {
	volatile.StoreUint32(&o.RMR.Reg, volatile.LoadUint32(&o.RMR.Reg)&^(0x2000000)|value<<25)
}
func (o *I2S0_Type) GetRMR_RWM25() uint32 {
	return (volatile.LoadUint32(&o.RMR.Reg) & 0x2000000) >> 25
}
func (o *I2S0_Type) SetRMR_RWM26(value uint32) {
	volatile.StoreUint32(&o.RMR.Reg, volatile.LoadUint32(&o.RMR.Reg)&^(0x4000000)|value<<26)
}
func (o *I2S0_Type) GetRMR_RWM26() uint32 {
	return (volatile.LoadUint32(&o.RMR.Reg) & 0x4000000) >> 26
}
func (o *I2S0_Type) SetRMR_RWM27(value uint32) {
	volatile.StoreUint32(&o.RMR.Reg, volatile.LoadUint32(&o.RMR.Reg)&^(0x8000000)|value<<27)
}
func (o *I2S0_Type) GetRMR_RWM27() uint32 {
	return (volatile.LoadUint32(&o.RMR.Reg) & 0x8000000) >> 27
}
func (o *I2S0_Type) SetRMR_RWM28(value uint32) {
	volatile.StoreUint32(&o.RMR.Reg, volatile.LoadUint32(&o.RMR.Reg)&^(0x10000000)|value<<28)
}
func (o *I2S0_Type) GetRMR_RWM28() uint32 {
	return (volatile.LoadUint32(&o.RMR.Reg) & 0x10000000) >> 28
}
func (o *I2S0_Type) SetRMR_RWM29(value uint32) {
	volatile.StoreUint32(&o.RMR.Reg, volatile.LoadUint32(&o.RMR.Reg)&^(0x20000000)|value<<29)
}
func (o *I2S0_Type) GetRMR_RWM29() uint32 {
	return (volatile.LoadUint32(&o.RMR.Reg) & 0x20000000) >> 29
}
func (o *I2S0_Type) SetRMR_RWM30(value uint32) {
	volatile.StoreUint32(&o.RMR.Reg, volatile.LoadUint32(&o.RMR.Reg)&^(0x40000000)|value<<30)
}
func (o *I2S0_Type) GetRMR_RWM30() uint32 {
	return (volatile.LoadUint32(&o.RMR.Reg) & 0x40000000) >> 30
}
func (o *I2S0_Type) SetRMR_RWM31(value uint32) {
	volatile.StoreUint32(&o.RMR.Reg, volatile.LoadUint32(&o.RMR.Reg)&^(0x80000000)|value<<31)
}
func (o *I2S0_Type) GetRMR_RWM31() uint32 {
	return (volatile.LoadUint32(&o.RMR.Reg) & 0x80000000) >> 31
}

// I2S0.MCR: SAI MCLK Control Register
func (o *I2S0_Type) SetMCR_MICS(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x3000000)|value<<24)
}
func (o *I2S0_Type) GetMCR_MICS() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x3000000) >> 24
}
func (o *I2S0_Type) SetMCR_MOE(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x40000000)|value<<30)
}
func (o *I2S0_Type) GetMCR_MOE() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x40000000) >> 30
}
func (o *I2S0_Type) SetMCR_DUF(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x80000000)|value<<31)
}
func (o *I2S0_Type) GetMCR_DUF() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x80000000) >> 31
}

// I2S0.MDR: SAI MCLK Divide Register
func (o *I2S0_Type) SetMDR_DIVIDE(value uint32) {
	volatile.StoreUint32(&o.MDR.Reg, volatile.LoadUint32(&o.MDR.Reg)&^(0xfff)|value)
}
func (o *I2S0_Type) GetMDR_DIVIDE() uint32 {
	return volatile.LoadUint32(&o.MDR.Reg) & 0xfff
}
func (o *I2S0_Type) SetMDR_FRACT(value uint32) {
	volatile.StoreUint32(&o.MDR.Reg, volatile.LoadUint32(&o.MDR.Reg)&^(0xff000)|value<<12)
}
func (o *I2S0_Type) GetMDR_FRACT() uint32 {
	return (volatile.LoadUint32(&o.MDR.Reg) & 0xff000) >> 12
}

// Cyclic Redundancy Check
type CRC_Type struct {
	DATA  volatile.Register32 // 0x0
	GPOLY volatile.Register32 // 0x4
	CTRL  volatile.Register32 // 0x8
}

// CRC.DATA: CRC Data register
func (o *CRC_Type) SetDATA_LL(value uint32) {
	volatile.StoreUint32(&o.DATA.Reg, volatile.LoadUint32(&o.DATA.Reg)&^(0xff)|value)
}
func (o *CRC_Type) GetDATA_LL() uint32 {
	return volatile.LoadUint32(&o.DATA.Reg) & 0xff
}
func (o *CRC_Type) SetDATA_LU(value uint32) {
	volatile.StoreUint32(&o.DATA.Reg, volatile.LoadUint32(&o.DATA.Reg)&^(0xff00)|value<<8)
}
func (o *CRC_Type) GetDATA_LU() uint32 {
	return (volatile.LoadUint32(&o.DATA.Reg) & 0xff00) >> 8
}
func (o *CRC_Type) SetDATA_HL(value uint32) {
	volatile.StoreUint32(&o.DATA.Reg, volatile.LoadUint32(&o.DATA.Reg)&^(0xff0000)|value<<16)
}
func (o *CRC_Type) GetDATA_HL() uint32 {
	return (volatile.LoadUint32(&o.DATA.Reg) & 0xff0000) >> 16
}
func (o *CRC_Type) SetDATA_HU(value uint32) {
	volatile.StoreUint32(&o.DATA.Reg, volatile.LoadUint32(&o.DATA.Reg)&^(0xff000000)|value<<24)
}
func (o *CRC_Type) GetDATA_HU() uint32 {
	return (volatile.LoadUint32(&o.DATA.Reg) & 0xff000000) >> 24
}

// CRC.GPOLY: CRC Polynomial register
func (o *CRC_Type) SetGPOLY_LOW(value uint32) {
	volatile.StoreUint32(&o.GPOLY.Reg, volatile.LoadUint32(&o.GPOLY.Reg)&^(0xffff)|value)
}
func (o *CRC_Type) GetGPOLY_LOW() uint32 {
	return volatile.LoadUint32(&o.GPOLY.Reg) & 0xffff
}
func (o *CRC_Type) SetGPOLY_HIGH(value uint32) {
	volatile.StoreUint32(&o.GPOLY.Reg, volatile.LoadUint32(&o.GPOLY.Reg)&^(0xffff0000)|value<<16)
}
func (o *CRC_Type) GetGPOLY_HIGH() uint32 {
	return (volatile.LoadUint32(&o.GPOLY.Reg) & 0xffff0000) >> 16
}

// CRC.CTRL: CRC Control register
func (o *CRC_Type) SetCTRL_TCRC(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x1000000)|value<<24)
}
func (o *CRC_Type) GetCTRL_TCRC() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x1000000) >> 24
}
func (o *CRC_Type) SetCTRL_WAS(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x2000000)|value<<25)
}
func (o *CRC_Type) GetCTRL_WAS() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x2000000) >> 25
}
func (o *CRC_Type) SetCTRL_FXOR(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x4000000)|value<<26)
}
func (o *CRC_Type) GetCTRL_FXOR() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x4000000) >> 26
}
func (o *CRC_Type) SetCTRL_TOTR(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x30000000)|value<<28)
}
func (o *CRC_Type) GetCTRL_TOTR() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x30000000) >> 28
}
func (o *CRC_Type) SetCTRL_TOT(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0xc0000000)|value<<30)
}
func (o *CRC_Type) GetCTRL_TOT() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0xc0000000) >> 30
}

// USB Device Charger Detection module
type USBDCD_Type struct {
	CONTROL     volatile.Register32 // 0x0
	CLOCK       volatile.Register32 // 0x4
	STATUS      volatile.Register32 // 0x8
	_           [4]byte
	TIMER0      volatile.Register32 // 0x10
	TIMER1      volatile.Register32 // 0x14
	TIMER2_BC11 volatile.Register32 // 0x18
}

// USBDCD.CONTROL: Control register
func (o *USBDCD_Type) SetCONTROL_IACK(value uint32) {
	volatile.StoreUint32(&o.CONTROL.Reg, volatile.LoadUint32(&o.CONTROL.Reg)&^(0x1)|value)
}
func (o *USBDCD_Type) GetCONTROL_IACK() uint32 {
	return volatile.LoadUint32(&o.CONTROL.Reg) & 0x1
}
func (o *USBDCD_Type) SetCONTROL_IF(value uint32) {
	volatile.StoreUint32(&o.CONTROL.Reg, volatile.LoadUint32(&o.CONTROL.Reg)&^(0x100)|value<<8)
}
func (o *USBDCD_Type) GetCONTROL_IF() uint32 {
	return (volatile.LoadUint32(&o.CONTROL.Reg) & 0x100) >> 8
}
func (o *USBDCD_Type) SetCONTROL_IE(value uint32) {
	volatile.StoreUint32(&o.CONTROL.Reg, volatile.LoadUint32(&o.CONTROL.Reg)&^(0x10000)|value<<16)
}
func (o *USBDCD_Type) GetCONTROL_IE() uint32 {
	return (volatile.LoadUint32(&o.CONTROL.Reg) & 0x10000) >> 16
}
func (o *USBDCD_Type) SetCONTROL_BC12(value uint32) {
	volatile.StoreUint32(&o.CONTROL.Reg, volatile.LoadUint32(&o.CONTROL.Reg)&^(0x20000)|value<<17)
}
func (o *USBDCD_Type) GetCONTROL_BC12() uint32 {
	return (volatile.LoadUint32(&o.CONTROL.Reg) & 0x20000) >> 17
}
func (o *USBDCD_Type) SetCONTROL_START(value uint32) {
	volatile.StoreUint32(&o.CONTROL.Reg, volatile.LoadUint32(&o.CONTROL.Reg)&^(0x1000000)|value<<24)
}
func (o *USBDCD_Type) GetCONTROL_START() uint32 {
	return (volatile.LoadUint32(&o.CONTROL.Reg) & 0x1000000) >> 24
}
func (o *USBDCD_Type) SetCONTROL_SR(value uint32) {
	volatile.StoreUint32(&o.CONTROL.Reg, volatile.LoadUint32(&o.CONTROL.Reg)&^(0x2000000)|value<<25)
}
func (o *USBDCD_Type) GetCONTROL_SR() uint32 {
	return (volatile.LoadUint32(&o.CONTROL.Reg) & 0x2000000) >> 25
}

// USBDCD.CLOCK: Clock register
func (o *USBDCD_Type) SetCLOCK_CLOCK_UNIT(value uint32) {
	volatile.StoreUint32(&o.CLOCK.Reg, volatile.LoadUint32(&o.CLOCK.Reg)&^(0x1)|value)
}
func (o *USBDCD_Type) GetCLOCK_CLOCK_UNIT() uint32 {
	return volatile.LoadUint32(&o.CLOCK.Reg) & 0x1
}
func (o *USBDCD_Type) SetCLOCK_CLOCK_SPEED(value uint32) {
	volatile.StoreUint32(&o.CLOCK.Reg, volatile.LoadUint32(&o.CLOCK.Reg)&^(0xffc)|value<<2)
}
func (o *USBDCD_Type) GetCLOCK_CLOCK_SPEED() uint32 {
	return (volatile.LoadUint32(&o.CLOCK.Reg) & 0xffc) >> 2
}

// USBDCD.STATUS: Status register
func (o *USBDCD_Type) SetSTATUS_SEQ_RES(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x30000)|value<<16)
}
func (o *USBDCD_Type) GetSTATUS_SEQ_RES() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x30000) >> 16
}
func (o *USBDCD_Type) SetSTATUS_SEQ_STAT(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0xc0000)|value<<18)
}
func (o *USBDCD_Type) GetSTATUS_SEQ_STAT() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0xc0000) >> 18
}
func (o *USBDCD_Type) SetSTATUS_ERR(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x100000)|value<<20)
}
func (o *USBDCD_Type) GetSTATUS_ERR() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x100000) >> 20
}
func (o *USBDCD_Type) SetSTATUS_TO(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x200000)|value<<21)
}
func (o *USBDCD_Type) GetSTATUS_TO() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x200000) >> 21
}
func (o *USBDCD_Type) SetSTATUS_ACTIVE(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x400000)|value<<22)
}
func (o *USBDCD_Type) GetSTATUS_ACTIVE() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x400000) >> 22
}

// USBDCD.TIMER0: TIMER0 register
func (o *USBDCD_Type) SetTIMER0_TUNITCON(value uint32) {
	volatile.StoreUint32(&o.TIMER0.Reg, volatile.LoadUint32(&o.TIMER0.Reg)&^(0xfff)|value)
}
func (o *USBDCD_Type) GetTIMER0_TUNITCON() uint32 {
	return volatile.LoadUint32(&o.TIMER0.Reg) & 0xfff
}
func (o *USBDCD_Type) SetTIMER0_TSEQ_INIT(value uint32) {
	volatile.StoreUint32(&o.TIMER0.Reg, volatile.LoadUint32(&o.TIMER0.Reg)&^(0x3ff0000)|value<<16)
}
func (o *USBDCD_Type) GetTIMER0_TSEQ_INIT() uint32 {
	return (volatile.LoadUint32(&o.TIMER0.Reg) & 0x3ff0000) >> 16
}

// USBDCD.TIMER1: TIMER1 register
func (o *USBDCD_Type) SetTIMER1_TVDPSRC_ON(value uint32) {
	volatile.StoreUint32(&o.TIMER1.Reg, volatile.LoadUint32(&o.TIMER1.Reg)&^(0x3ff)|value)
}
func (o *USBDCD_Type) GetTIMER1_TVDPSRC_ON() uint32 {
	return volatile.LoadUint32(&o.TIMER1.Reg) & 0x3ff
}
func (o *USBDCD_Type) SetTIMER1_TDCD_DBNC(value uint32) {
	volatile.StoreUint32(&o.TIMER1.Reg, volatile.LoadUint32(&o.TIMER1.Reg)&^(0x3ff0000)|value<<16)
}
func (o *USBDCD_Type) GetTIMER1_TDCD_DBNC() uint32 {
	return (volatile.LoadUint32(&o.TIMER1.Reg) & 0x3ff0000) >> 16
}

// USBDCD.TIMER2_BC11: TIMER2_BC11 register
func (o *USBDCD_Type) SetTIMER2_BC11_CHECK_DM(value uint32) {
	volatile.StoreUint32(&o.TIMER2_BC11.Reg, volatile.LoadUint32(&o.TIMER2_BC11.Reg)&^(0xf)|value)
}
func (o *USBDCD_Type) GetTIMER2_BC11_CHECK_DM() uint32 {
	return volatile.LoadUint32(&o.TIMER2_BC11.Reg) & 0xf
}
func (o *USBDCD_Type) SetTIMER2_BC11_TVDPSRC_CON(value uint32) {
	volatile.StoreUint32(&o.TIMER2_BC11.Reg, volatile.LoadUint32(&o.TIMER2_BC11.Reg)&^(0x3ff0000)|value<<16)
}
func (o *USBDCD_Type) GetTIMER2_BC11_TVDPSRC_CON() uint32 {
	return (volatile.LoadUint32(&o.TIMER2_BC11.Reg) & 0x3ff0000) >> 16
}

// Programmable Delay Block
type PDB0_Type struct {
	SC       volatile.Register32 // 0x0
	MOD      volatile.Register32 // 0x4
	CNT      volatile.Register32 // 0x8
	IDLY     volatile.Register32 // 0xC
	CH0C1    volatile.Register32 // 0x10
	CH0S     volatile.Register32 // 0x14
	CH0DLY0  volatile.Register32 // 0x18
	CH0DLY1  volatile.Register32 // 0x1C
	_        [24]byte
	CH1C1    volatile.Register32 // 0x38
	CH1S     volatile.Register32 // 0x3C
	CH1DLY0  volatile.Register32 // 0x40
	CH1DLY1  volatile.Register32 // 0x44
	_        [264]byte
	DACINTC0 volatile.Register32 // 0x150
	DACINT0  volatile.Register32 // 0x154
	DACINTC1 volatile.Register32 // 0x158
	DACINT1  volatile.Register32 // 0x15C
	_        [48]byte
	POEN     volatile.Register32 // 0x190
	PO0DLY   volatile.Register32 // 0x194
	PO1DLY   volatile.Register32 // 0x198
	PO2DLY   volatile.Register32 // 0x19C
}

// PDB0.SC: Status and Control register
func (o *PDB0_Type) SetSC_LDOK(value uint32) {
	volatile.StoreUint32(&o.SC.Reg, volatile.LoadUint32(&o.SC.Reg)&^(0x1)|value)
}
func (o *PDB0_Type) GetSC_LDOK() uint32 {
	return volatile.LoadUint32(&o.SC.Reg) & 0x1
}
func (o *PDB0_Type) SetSC_CONT(value uint32) {
	volatile.StoreUint32(&o.SC.Reg, volatile.LoadUint32(&o.SC.Reg)&^(0x2)|value<<1)
}
func (o *PDB0_Type) GetSC_CONT() uint32 {
	return (volatile.LoadUint32(&o.SC.Reg) & 0x2) >> 1
}
func (o *PDB0_Type) SetSC_MULT(value uint32) {
	volatile.StoreUint32(&o.SC.Reg, volatile.LoadUint32(&o.SC.Reg)&^(0xc)|value<<2)
}
func (o *PDB0_Type) GetSC_MULT() uint32 {
	return (volatile.LoadUint32(&o.SC.Reg) & 0xc) >> 2
}
func (o *PDB0_Type) SetSC_PDBIE(value uint32) {
	volatile.StoreUint32(&o.SC.Reg, volatile.LoadUint32(&o.SC.Reg)&^(0x20)|value<<5)
}
func (o *PDB0_Type) GetSC_PDBIE() uint32 {
	return (volatile.LoadUint32(&o.SC.Reg) & 0x20) >> 5
}
func (o *PDB0_Type) SetSC_PDBIF(value uint32) {
	volatile.StoreUint32(&o.SC.Reg, volatile.LoadUint32(&o.SC.Reg)&^(0x40)|value<<6)
}
func (o *PDB0_Type) GetSC_PDBIF() uint32 {
	return (volatile.LoadUint32(&o.SC.Reg) & 0x40) >> 6
}
func (o *PDB0_Type) SetSC_PDBEN(value uint32) {
	volatile.StoreUint32(&o.SC.Reg, volatile.LoadUint32(&o.SC.Reg)&^(0x80)|value<<7)
}
func (o *PDB0_Type) GetSC_PDBEN() uint32 {
	return (volatile.LoadUint32(&o.SC.Reg) & 0x80) >> 7
}
func (o *PDB0_Type) SetSC_TRGSEL(value uint32) {
	volatile.StoreUint32(&o.SC.Reg, volatile.LoadUint32(&o.SC.Reg)&^(0xf00)|value<<8)
}
func (o *PDB0_Type) GetSC_TRGSEL() uint32 {
	return (volatile.LoadUint32(&o.SC.Reg) & 0xf00) >> 8
}
func (o *PDB0_Type) SetSC_PRESCALER(value uint32) {
	volatile.StoreUint32(&o.SC.Reg, volatile.LoadUint32(&o.SC.Reg)&^(0x7000)|value<<12)
}
func (o *PDB0_Type) GetSC_PRESCALER() uint32 {
	return (volatile.LoadUint32(&o.SC.Reg) & 0x7000) >> 12
}
func (o *PDB0_Type) SetSC_DMAEN(value uint32) {
	volatile.StoreUint32(&o.SC.Reg, volatile.LoadUint32(&o.SC.Reg)&^(0x8000)|value<<15)
}
func (o *PDB0_Type) GetSC_DMAEN() uint32 {
	return (volatile.LoadUint32(&o.SC.Reg) & 0x8000) >> 15
}
func (o *PDB0_Type) SetSC_SWTRIG(value uint32) {
	volatile.StoreUint32(&o.SC.Reg, volatile.LoadUint32(&o.SC.Reg)&^(0x10000)|value<<16)
}
func (o *PDB0_Type) GetSC_SWTRIG() uint32 {
	return (volatile.LoadUint32(&o.SC.Reg) & 0x10000) >> 16
}
func (o *PDB0_Type) SetSC_PDBEIE(value uint32) {
	volatile.StoreUint32(&o.SC.Reg, volatile.LoadUint32(&o.SC.Reg)&^(0x20000)|value<<17)
}
func (o *PDB0_Type) GetSC_PDBEIE() uint32 {
	return (volatile.LoadUint32(&o.SC.Reg) & 0x20000) >> 17
}
func (o *PDB0_Type) SetSC_LDMOD(value uint32) {
	volatile.StoreUint32(&o.SC.Reg, volatile.LoadUint32(&o.SC.Reg)&^(0xc0000)|value<<18)
}
func (o *PDB0_Type) GetSC_LDMOD() uint32 {
	return (volatile.LoadUint32(&o.SC.Reg) & 0xc0000) >> 18
}

// PDB0.MOD: Modulus register
func (o *PDB0_Type) SetMOD(value uint32) {
	volatile.StoreUint32(&o.MOD.Reg, volatile.LoadUint32(&o.MOD.Reg)&^(0xffff)|value)
}
func (o *PDB0_Type) GetMOD() uint32 {
	return volatile.LoadUint32(&o.MOD.Reg) & 0xffff
}

// PDB0.CNT: Counter register
func (o *PDB0_Type) SetCNT(value uint32) {
	volatile.StoreUint32(&o.CNT.Reg, volatile.LoadUint32(&o.CNT.Reg)&^(0xffff)|value)
}
func (o *PDB0_Type) GetCNT() uint32 {
	return volatile.LoadUint32(&o.CNT.Reg) & 0xffff
}

// PDB0.IDLY: Interrupt Delay register
func (o *PDB0_Type) SetIDLY(value uint32) {
	volatile.StoreUint32(&o.IDLY.Reg, volatile.LoadUint32(&o.IDLY.Reg)&^(0xffff)|value)
}
func (o *PDB0_Type) GetIDLY() uint32 {
	return volatile.LoadUint32(&o.IDLY.Reg) & 0xffff
}

// PDB0.CH0C1: Channel n Control register 1
func (o *PDB0_Type) SetCH0C1_EN0(value uint32) {
	volatile.StoreUint32(&o.CH0C1.Reg, volatile.LoadUint32(&o.CH0C1.Reg)&^(0x1)|value)
}
func (o *PDB0_Type) GetCH0C1_EN0() uint32 {
	return volatile.LoadUint32(&o.CH0C1.Reg) & 0x1
}
func (o *PDB0_Type) SetCH0C1_EN1(value uint32) {
	volatile.StoreUint32(&o.CH0C1.Reg, volatile.LoadUint32(&o.CH0C1.Reg)&^(0x2)|value<<1)
}
func (o *PDB0_Type) GetCH0C1_EN1() uint32 {
	return (volatile.LoadUint32(&o.CH0C1.Reg) & 0x2) >> 1
}
func (o *PDB0_Type) SetCH0C1_EN2(value uint32) {
	volatile.StoreUint32(&o.CH0C1.Reg, volatile.LoadUint32(&o.CH0C1.Reg)&^(0x4)|value<<2)
}
func (o *PDB0_Type) GetCH0C1_EN2() uint32 {
	return (volatile.LoadUint32(&o.CH0C1.Reg) & 0x4) >> 2
}
func (o *PDB0_Type) SetCH0C1_EN3(value uint32) {
	volatile.StoreUint32(&o.CH0C1.Reg, volatile.LoadUint32(&o.CH0C1.Reg)&^(0x8)|value<<3)
}
func (o *PDB0_Type) GetCH0C1_EN3() uint32 {
	return (volatile.LoadUint32(&o.CH0C1.Reg) & 0x8) >> 3
}
func (o *PDB0_Type) SetCH0C1_EN4(value uint32) {
	volatile.StoreUint32(&o.CH0C1.Reg, volatile.LoadUint32(&o.CH0C1.Reg)&^(0x10)|value<<4)
}
func (o *PDB0_Type) GetCH0C1_EN4() uint32 {
	return (volatile.LoadUint32(&o.CH0C1.Reg) & 0x10) >> 4
}
func (o *PDB0_Type) SetCH0C1_EN5(value uint32) {
	volatile.StoreUint32(&o.CH0C1.Reg, volatile.LoadUint32(&o.CH0C1.Reg)&^(0x20)|value<<5)
}
func (o *PDB0_Type) GetCH0C1_EN5() uint32 {
	return (volatile.LoadUint32(&o.CH0C1.Reg) & 0x20) >> 5
}
func (o *PDB0_Type) SetCH0C1_EN6(value uint32) {
	volatile.StoreUint32(&o.CH0C1.Reg, volatile.LoadUint32(&o.CH0C1.Reg)&^(0x40)|value<<6)
}
func (o *PDB0_Type) GetCH0C1_EN6() uint32 {
	return (volatile.LoadUint32(&o.CH0C1.Reg) & 0x40) >> 6
}
func (o *PDB0_Type) SetCH0C1_EN7(value uint32) {
	volatile.StoreUint32(&o.CH0C1.Reg, volatile.LoadUint32(&o.CH0C1.Reg)&^(0x80)|value<<7)
}
func (o *PDB0_Type) GetCH0C1_EN7() uint32 {
	return (volatile.LoadUint32(&o.CH0C1.Reg) & 0x80) >> 7
}
func (o *PDB0_Type) SetCH0C1_TOS0(value uint32) {
	volatile.StoreUint32(&o.CH0C1.Reg, volatile.LoadUint32(&o.CH0C1.Reg)&^(0x100)|value<<8)
}
func (o *PDB0_Type) GetCH0C1_TOS0() uint32 {
	return (volatile.LoadUint32(&o.CH0C1.Reg) & 0x100) >> 8
}
func (o *PDB0_Type) SetCH0C1_TOS1(value uint32) {
	volatile.StoreUint32(&o.CH0C1.Reg, volatile.LoadUint32(&o.CH0C1.Reg)&^(0x200)|value<<9)
}
func (o *PDB0_Type) GetCH0C1_TOS1() uint32 {
	return (volatile.LoadUint32(&o.CH0C1.Reg) & 0x200) >> 9
}
func (o *PDB0_Type) SetCH0C1_TOS2(value uint32) {
	volatile.StoreUint32(&o.CH0C1.Reg, volatile.LoadUint32(&o.CH0C1.Reg)&^(0x400)|value<<10)
}
func (o *PDB0_Type) GetCH0C1_TOS2() uint32 {
	return (volatile.LoadUint32(&o.CH0C1.Reg) & 0x400) >> 10
}
func (o *PDB0_Type) SetCH0C1_TOS3(value uint32) {
	volatile.StoreUint32(&o.CH0C1.Reg, volatile.LoadUint32(&o.CH0C1.Reg)&^(0x800)|value<<11)
}
func (o *PDB0_Type) GetCH0C1_TOS3() uint32 {
	return (volatile.LoadUint32(&o.CH0C1.Reg) & 0x800) >> 11
}
func (o *PDB0_Type) SetCH0C1_TOS4(value uint32) {
	volatile.StoreUint32(&o.CH0C1.Reg, volatile.LoadUint32(&o.CH0C1.Reg)&^(0x1000)|value<<12)
}
func (o *PDB0_Type) GetCH0C1_TOS4() uint32 {
	return (volatile.LoadUint32(&o.CH0C1.Reg) & 0x1000) >> 12
}
func (o *PDB0_Type) SetCH0C1_TOS5(value uint32) {
	volatile.StoreUint32(&o.CH0C1.Reg, volatile.LoadUint32(&o.CH0C1.Reg)&^(0x2000)|value<<13)
}
func (o *PDB0_Type) GetCH0C1_TOS5() uint32 {
	return (volatile.LoadUint32(&o.CH0C1.Reg) & 0x2000) >> 13
}
func (o *PDB0_Type) SetCH0C1_TOS6(value uint32) {
	volatile.StoreUint32(&o.CH0C1.Reg, volatile.LoadUint32(&o.CH0C1.Reg)&^(0x4000)|value<<14)
}
func (o *PDB0_Type) GetCH0C1_TOS6() uint32 {
	return (volatile.LoadUint32(&o.CH0C1.Reg) & 0x4000) >> 14
}
func (o *PDB0_Type) SetCH0C1_TOS7(value uint32) {
	volatile.StoreUint32(&o.CH0C1.Reg, volatile.LoadUint32(&o.CH0C1.Reg)&^(0x8000)|value<<15)
}
func (o *PDB0_Type) GetCH0C1_TOS7() uint32 {
	return (volatile.LoadUint32(&o.CH0C1.Reg) & 0x8000) >> 15
}
func (o *PDB0_Type) SetCH0C1_BB0(value uint32) {
	volatile.StoreUint32(&o.CH0C1.Reg, volatile.LoadUint32(&o.CH0C1.Reg)&^(0x10000)|value<<16)
}
func (o *PDB0_Type) GetCH0C1_BB0() uint32 {
	return (volatile.LoadUint32(&o.CH0C1.Reg) & 0x10000) >> 16
}
func (o *PDB0_Type) SetCH0C1_BB1(value uint32) {
	volatile.StoreUint32(&o.CH0C1.Reg, volatile.LoadUint32(&o.CH0C1.Reg)&^(0x20000)|value<<17)
}
func (o *PDB0_Type) GetCH0C1_BB1() uint32 {
	return (volatile.LoadUint32(&o.CH0C1.Reg) & 0x20000) >> 17
}
func (o *PDB0_Type) SetCH0C1_BB2(value uint32) {
	volatile.StoreUint32(&o.CH0C1.Reg, volatile.LoadUint32(&o.CH0C1.Reg)&^(0x40000)|value<<18)
}
func (o *PDB0_Type) GetCH0C1_BB2() uint32 {
	return (volatile.LoadUint32(&o.CH0C1.Reg) & 0x40000) >> 18
}
func (o *PDB0_Type) SetCH0C1_BB3(value uint32) {
	volatile.StoreUint32(&o.CH0C1.Reg, volatile.LoadUint32(&o.CH0C1.Reg)&^(0x80000)|value<<19)
}
func (o *PDB0_Type) GetCH0C1_BB3() uint32 {
	return (volatile.LoadUint32(&o.CH0C1.Reg) & 0x80000) >> 19
}
func (o *PDB0_Type) SetCH0C1_BB4(value uint32) {
	volatile.StoreUint32(&o.CH0C1.Reg, volatile.LoadUint32(&o.CH0C1.Reg)&^(0x100000)|value<<20)
}
func (o *PDB0_Type) GetCH0C1_BB4() uint32 {
	return (volatile.LoadUint32(&o.CH0C1.Reg) & 0x100000) >> 20
}
func (o *PDB0_Type) SetCH0C1_BB5(value uint32) {
	volatile.StoreUint32(&o.CH0C1.Reg, volatile.LoadUint32(&o.CH0C1.Reg)&^(0x200000)|value<<21)
}
func (o *PDB0_Type) GetCH0C1_BB5() uint32 {
	return (volatile.LoadUint32(&o.CH0C1.Reg) & 0x200000) >> 21
}
func (o *PDB0_Type) SetCH0C1_BB6(value uint32) {
	volatile.StoreUint32(&o.CH0C1.Reg, volatile.LoadUint32(&o.CH0C1.Reg)&^(0x400000)|value<<22)
}
func (o *PDB0_Type) GetCH0C1_BB6() uint32 {
	return (volatile.LoadUint32(&o.CH0C1.Reg) & 0x400000) >> 22
}
func (o *PDB0_Type) SetCH0C1_BB7(value uint32) {
	volatile.StoreUint32(&o.CH0C1.Reg, volatile.LoadUint32(&o.CH0C1.Reg)&^(0x800000)|value<<23)
}
func (o *PDB0_Type) GetCH0C1_BB7() uint32 {
	return (volatile.LoadUint32(&o.CH0C1.Reg) & 0x800000) >> 23
}

// PDB0.CH0S: Channel n Status register
func (o *PDB0_Type) SetCH0S_ERR0(value uint32) {
	volatile.StoreUint32(&o.CH0S.Reg, volatile.LoadUint32(&o.CH0S.Reg)&^(0x1)|value)
}
func (o *PDB0_Type) GetCH0S_ERR0() uint32 {
	return volatile.LoadUint32(&o.CH0S.Reg) & 0x1
}
func (o *PDB0_Type) SetCH0S_ERR1(value uint32) {
	volatile.StoreUint32(&o.CH0S.Reg, volatile.LoadUint32(&o.CH0S.Reg)&^(0x2)|value<<1)
}
func (o *PDB0_Type) GetCH0S_ERR1() uint32 {
	return (volatile.LoadUint32(&o.CH0S.Reg) & 0x2) >> 1
}
func (o *PDB0_Type) SetCH0S_ERR2(value uint32) {
	volatile.StoreUint32(&o.CH0S.Reg, volatile.LoadUint32(&o.CH0S.Reg)&^(0x4)|value<<2)
}
func (o *PDB0_Type) GetCH0S_ERR2() uint32 {
	return (volatile.LoadUint32(&o.CH0S.Reg) & 0x4) >> 2
}
func (o *PDB0_Type) SetCH0S_ERR3(value uint32) {
	volatile.StoreUint32(&o.CH0S.Reg, volatile.LoadUint32(&o.CH0S.Reg)&^(0x8)|value<<3)
}
func (o *PDB0_Type) GetCH0S_ERR3() uint32 {
	return (volatile.LoadUint32(&o.CH0S.Reg) & 0x8) >> 3
}
func (o *PDB0_Type) SetCH0S_ERR4(value uint32) {
	volatile.StoreUint32(&o.CH0S.Reg, volatile.LoadUint32(&o.CH0S.Reg)&^(0x10)|value<<4)
}
func (o *PDB0_Type) GetCH0S_ERR4() uint32 {
	return (volatile.LoadUint32(&o.CH0S.Reg) & 0x10) >> 4
}
func (o *PDB0_Type) SetCH0S_ERR5(value uint32) {
	volatile.StoreUint32(&o.CH0S.Reg, volatile.LoadUint32(&o.CH0S.Reg)&^(0x20)|value<<5)
}
func (o *PDB0_Type) GetCH0S_ERR5() uint32 {
	return (volatile.LoadUint32(&o.CH0S.Reg) & 0x20) >> 5
}
func (o *PDB0_Type) SetCH0S_ERR6(value uint32) {
	volatile.StoreUint32(&o.CH0S.Reg, volatile.LoadUint32(&o.CH0S.Reg)&^(0x40)|value<<6)
}
func (o *PDB0_Type) GetCH0S_ERR6() uint32 {
	return (volatile.LoadUint32(&o.CH0S.Reg) & 0x40) >> 6
}
func (o *PDB0_Type) SetCH0S_ERR7(value uint32) {
	volatile.StoreUint32(&o.CH0S.Reg, volatile.LoadUint32(&o.CH0S.Reg)&^(0x80)|value<<7)
}
func (o *PDB0_Type) GetCH0S_ERR7() uint32 {
	return (volatile.LoadUint32(&o.CH0S.Reg) & 0x80) >> 7
}
func (o *PDB0_Type) SetCH0S_CF(value uint32) {
	volatile.StoreUint32(&o.CH0S.Reg, volatile.LoadUint32(&o.CH0S.Reg)&^(0xff0000)|value<<16)
}
func (o *PDB0_Type) GetCH0S_CF() uint32 {
	return (volatile.LoadUint32(&o.CH0S.Reg) & 0xff0000) >> 16
}

// PDB0.CH0DLY0: Channel n Delay 0 register
func (o *PDB0_Type) SetCH0DLY0_DLY(value uint32) {
	volatile.StoreUint32(&o.CH0DLY0.Reg, volatile.LoadUint32(&o.CH0DLY0.Reg)&^(0xffff)|value)
}
func (o *PDB0_Type) GetCH0DLY0_DLY() uint32 {
	return volatile.LoadUint32(&o.CH0DLY0.Reg) & 0xffff
}

// PDB0.CH0DLY1: Channel n Delay 1 register
func (o *PDB0_Type) SetCH0DLY1_DLY(value uint32) {
	volatile.StoreUint32(&o.CH0DLY1.Reg, volatile.LoadUint32(&o.CH0DLY1.Reg)&^(0xffff)|value)
}
func (o *PDB0_Type) GetCH0DLY1_DLY() uint32 {
	return volatile.LoadUint32(&o.CH0DLY1.Reg) & 0xffff
}

// PDB0.CH1C1: Channel n Control register 1
func (o *PDB0_Type) SetCH1C1_EN0(value uint32) {
	volatile.StoreUint32(&o.CH1C1.Reg, volatile.LoadUint32(&o.CH1C1.Reg)&^(0x1)|value)
}
func (o *PDB0_Type) GetCH1C1_EN0() uint32 {
	return volatile.LoadUint32(&o.CH1C1.Reg) & 0x1
}
func (o *PDB0_Type) SetCH1C1_EN1(value uint32) {
	volatile.StoreUint32(&o.CH1C1.Reg, volatile.LoadUint32(&o.CH1C1.Reg)&^(0x2)|value<<1)
}
func (o *PDB0_Type) GetCH1C1_EN1() uint32 {
	return (volatile.LoadUint32(&o.CH1C1.Reg) & 0x2) >> 1
}
func (o *PDB0_Type) SetCH1C1_EN2(value uint32) {
	volatile.StoreUint32(&o.CH1C1.Reg, volatile.LoadUint32(&o.CH1C1.Reg)&^(0x4)|value<<2)
}
func (o *PDB0_Type) GetCH1C1_EN2() uint32 {
	return (volatile.LoadUint32(&o.CH1C1.Reg) & 0x4) >> 2
}
func (o *PDB0_Type) SetCH1C1_EN3(value uint32) {
	volatile.StoreUint32(&o.CH1C1.Reg, volatile.LoadUint32(&o.CH1C1.Reg)&^(0x8)|value<<3)
}
func (o *PDB0_Type) GetCH1C1_EN3() uint32 {
	return (volatile.LoadUint32(&o.CH1C1.Reg) & 0x8) >> 3
}
func (o *PDB0_Type) SetCH1C1_EN4(value uint32) {
	volatile.StoreUint32(&o.CH1C1.Reg, volatile.LoadUint32(&o.CH1C1.Reg)&^(0x10)|value<<4)
}
func (o *PDB0_Type) GetCH1C1_EN4() uint32 {
	return (volatile.LoadUint32(&o.CH1C1.Reg) & 0x10) >> 4
}
func (o *PDB0_Type) SetCH1C1_EN5(value uint32) {
	volatile.StoreUint32(&o.CH1C1.Reg, volatile.LoadUint32(&o.CH1C1.Reg)&^(0x20)|value<<5)
}
func (o *PDB0_Type) GetCH1C1_EN5() uint32 {
	return (volatile.LoadUint32(&o.CH1C1.Reg) & 0x20) >> 5
}
func (o *PDB0_Type) SetCH1C1_EN6(value uint32) {
	volatile.StoreUint32(&o.CH1C1.Reg, volatile.LoadUint32(&o.CH1C1.Reg)&^(0x40)|value<<6)
}
func (o *PDB0_Type) GetCH1C1_EN6() uint32 {
	return (volatile.LoadUint32(&o.CH1C1.Reg) & 0x40) >> 6
}
func (o *PDB0_Type) SetCH1C1_EN7(value uint32) {
	volatile.StoreUint32(&o.CH1C1.Reg, volatile.LoadUint32(&o.CH1C1.Reg)&^(0x80)|value<<7)
}
func (o *PDB0_Type) GetCH1C1_EN7() uint32 {
	return (volatile.LoadUint32(&o.CH1C1.Reg) & 0x80) >> 7
}
func (o *PDB0_Type) SetCH1C1_TOS0(value uint32) {
	volatile.StoreUint32(&o.CH1C1.Reg, volatile.LoadUint32(&o.CH1C1.Reg)&^(0x100)|value<<8)
}
func (o *PDB0_Type) GetCH1C1_TOS0() uint32 {
	return (volatile.LoadUint32(&o.CH1C1.Reg) & 0x100) >> 8
}
func (o *PDB0_Type) SetCH1C1_TOS1(value uint32) {
	volatile.StoreUint32(&o.CH1C1.Reg, volatile.LoadUint32(&o.CH1C1.Reg)&^(0x200)|value<<9)
}
func (o *PDB0_Type) GetCH1C1_TOS1() uint32 {
	return (volatile.LoadUint32(&o.CH1C1.Reg) & 0x200) >> 9
}
func (o *PDB0_Type) SetCH1C1_TOS2(value uint32) {
	volatile.StoreUint32(&o.CH1C1.Reg, volatile.LoadUint32(&o.CH1C1.Reg)&^(0x400)|value<<10)
}
func (o *PDB0_Type) GetCH1C1_TOS2() uint32 {
	return (volatile.LoadUint32(&o.CH1C1.Reg) & 0x400) >> 10
}
func (o *PDB0_Type) SetCH1C1_TOS3(value uint32) {
	volatile.StoreUint32(&o.CH1C1.Reg, volatile.LoadUint32(&o.CH1C1.Reg)&^(0x800)|value<<11)
}
func (o *PDB0_Type) GetCH1C1_TOS3() uint32 {
	return (volatile.LoadUint32(&o.CH1C1.Reg) & 0x800) >> 11
}
func (o *PDB0_Type) SetCH1C1_TOS4(value uint32) {
	volatile.StoreUint32(&o.CH1C1.Reg, volatile.LoadUint32(&o.CH1C1.Reg)&^(0x1000)|value<<12)
}
func (o *PDB0_Type) GetCH1C1_TOS4() uint32 {
	return (volatile.LoadUint32(&o.CH1C1.Reg) & 0x1000) >> 12
}
func (o *PDB0_Type) SetCH1C1_TOS5(value uint32) {
	volatile.StoreUint32(&o.CH1C1.Reg, volatile.LoadUint32(&o.CH1C1.Reg)&^(0x2000)|value<<13)
}
func (o *PDB0_Type) GetCH1C1_TOS5() uint32 {
	return (volatile.LoadUint32(&o.CH1C1.Reg) & 0x2000) >> 13
}
func (o *PDB0_Type) SetCH1C1_TOS6(value uint32) {
	volatile.StoreUint32(&o.CH1C1.Reg, volatile.LoadUint32(&o.CH1C1.Reg)&^(0x4000)|value<<14)
}
func (o *PDB0_Type) GetCH1C1_TOS6() uint32 {
	return (volatile.LoadUint32(&o.CH1C1.Reg) & 0x4000) >> 14
}
func (o *PDB0_Type) SetCH1C1_TOS7(value uint32) {
	volatile.StoreUint32(&o.CH1C1.Reg, volatile.LoadUint32(&o.CH1C1.Reg)&^(0x8000)|value<<15)
}
func (o *PDB0_Type) GetCH1C1_TOS7() uint32 {
	return (volatile.LoadUint32(&o.CH1C1.Reg) & 0x8000) >> 15
}
func (o *PDB0_Type) SetCH1C1_BB0(value uint32) {
	volatile.StoreUint32(&o.CH1C1.Reg, volatile.LoadUint32(&o.CH1C1.Reg)&^(0x10000)|value<<16)
}
func (o *PDB0_Type) GetCH1C1_BB0() uint32 {
	return (volatile.LoadUint32(&o.CH1C1.Reg) & 0x10000) >> 16
}
func (o *PDB0_Type) SetCH1C1_BB1(value uint32) {
	volatile.StoreUint32(&o.CH1C1.Reg, volatile.LoadUint32(&o.CH1C1.Reg)&^(0x20000)|value<<17)
}
func (o *PDB0_Type) GetCH1C1_BB1() uint32 {
	return (volatile.LoadUint32(&o.CH1C1.Reg) & 0x20000) >> 17
}
func (o *PDB0_Type) SetCH1C1_BB2(value uint32) {
	volatile.StoreUint32(&o.CH1C1.Reg, volatile.LoadUint32(&o.CH1C1.Reg)&^(0x40000)|value<<18)
}
func (o *PDB0_Type) GetCH1C1_BB2() uint32 {
	return (volatile.LoadUint32(&o.CH1C1.Reg) & 0x40000) >> 18
}
func (o *PDB0_Type) SetCH1C1_BB3(value uint32) {
	volatile.StoreUint32(&o.CH1C1.Reg, volatile.LoadUint32(&o.CH1C1.Reg)&^(0x80000)|value<<19)
}
func (o *PDB0_Type) GetCH1C1_BB3() uint32 {
	return (volatile.LoadUint32(&o.CH1C1.Reg) & 0x80000) >> 19
}
func (o *PDB0_Type) SetCH1C1_BB4(value uint32) {
	volatile.StoreUint32(&o.CH1C1.Reg, volatile.LoadUint32(&o.CH1C1.Reg)&^(0x100000)|value<<20)
}
func (o *PDB0_Type) GetCH1C1_BB4() uint32 {
	return (volatile.LoadUint32(&o.CH1C1.Reg) & 0x100000) >> 20
}
func (o *PDB0_Type) SetCH1C1_BB5(value uint32) {
	volatile.StoreUint32(&o.CH1C1.Reg, volatile.LoadUint32(&o.CH1C1.Reg)&^(0x200000)|value<<21)
}
func (o *PDB0_Type) GetCH1C1_BB5() uint32 {
	return (volatile.LoadUint32(&o.CH1C1.Reg) & 0x200000) >> 21
}
func (o *PDB0_Type) SetCH1C1_BB6(value uint32) {
	volatile.StoreUint32(&o.CH1C1.Reg, volatile.LoadUint32(&o.CH1C1.Reg)&^(0x400000)|value<<22)
}
func (o *PDB0_Type) GetCH1C1_BB6() uint32 {
	return (volatile.LoadUint32(&o.CH1C1.Reg) & 0x400000) >> 22
}
func (o *PDB0_Type) SetCH1C1_BB7(value uint32) {
	volatile.StoreUint32(&o.CH1C1.Reg, volatile.LoadUint32(&o.CH1C1.Reg)&^(0x800000)|value<<23)
}
func (o *PDB0_Type) GetCH1C1_BB7() uint32 {
	return (volatile.LoadUint32(&o.CH1C1.Reg) & 0x800000) >> 23
}

// PDB0.CH1S: Channel n Status register
func (o *PDB0_Type) SetCH1S_ERR0(value uint32) {
	volatile.StoreUint32(&o.CH1S.Reg, volatile.LoadUint32(&o.CH1S.Reg)&^(0x1)|value)
}
func (o *PDB0_Type) GetCH1S_ERR0() uint32 {
	return volatile.LoadUint32(&o.CH1S.Reg) & 0x1
}
func (o *PDB0_Type) SetCH1S_ERR1(value uint32) {
	volatile.StoreUint32(&o.CH1S.Reg, volatile.LoadUint32(&o.CH1S.Reg)&^(0x2)|value<<1)
}
func (o *PDB0_Type) GetCH1S_ERR1() uint32 {
	return (volatile.LoadUint32(&o.CH1S.Reg) & 0x2) >> 1
}
func (o *PDB0_Type) SetCH1S_ERR2(value uint32) {
	volatile.StoreUint32(&o.CH1S.Reg, volatile.LoadUint32(&o.CH1S.Reg)&^(0x4)|value<<2)
}
func (o *PDB0_Type) GetCH1S_ERR2() uint32 {
	return (volatile.LoadUint32(&o.CH1S.Reg) & 0x4) >> 2
}
func (o *PDB0_Type) SetCH1S_ERR3(value uint32) {
	volatile.StoreUint32(&o.CH1S.Reg, volatile.LoadUint32(&o.CH1S.Reg)&^(0x8)|value<<3)
}
func (o *PDB0_Type) GetCH1S_ERR3() uint32 {
	return (volatile.LoadUint32(&o.CH1S.Reg) & 0x8) >> 3
}
func (o *PDB0_Type) SetCH1S_ERR4(value uint32) {
	volatile.StoreUint32(&o.CH1S.Reg, volatile.LoadUint32(&o.CH1S.Reg)&^(0x10)|value<<4)
}
func (o *PDB0_Type) GetCH1S_ERR4() uint32 {
	return (volatile.LoadUint32(&o.CH1S.Reg) & 0x10) >> 4
}
func (o *PDB0_Type) SetCH1S_ERR5(value uint32) {
	volatile.StoreUint32(&o.CH1S.Reg, volatile.LoadUint32(&o.CH1S.Reg)&^(0x20)|value<<5)
}
func (o *PDB0_Type) GetCH1S_ERR5() uint32 {
	return (volatile.LoadUint32(&o.CH1S.Reg) & 0x20) >> 5
}
func (o *PDB0_Type) SetCH1S_ERR6(value uint32) {
	volatile.StoreUint32(&o.CH1S.Reg, volatile.LoadUint32(&o.CH1S.Reg)&^(0x40)|value<<6)
}
func (o *PDB0_Type) GetCH1S_ERR6() uint32 {
	return (volatile.LoadUint32(&o.CH1S.Reg) & 0x40) >> 6
}
func (o *PDB0_Type) SetCH1S_ERR7(value uint32) {
	volatile.StoreUint32(&o.CH1S.Reg, volatile.LoadUint32(&o.CH1S.Reg)&^(0x80)|value<<7)
}
func (o *PDB0_Type) GetCH1S_ERR7() uint32 {
	return (volatile.LoadUint32(&o.CH1S.Reg) & 0x80) >> 7
}
func (o *PDB0_Type) SetCH1S_CF(value uint32) {
	volatile.StoreUint32(&o.CH1S.Reg, volatile.LoadUint32(&o.CH1S.Reg)&^(0xff0000)|value<<16)
}
func (o *PDB0_Type) GetCH1S_CF() uint32 {
	return (volatile.LoadUint32(&o.CH1S.Reg) & 0xff0000) >> 16
}

// PDB0.CH1DLY0: Channel n Delay 0 register
func (o *PDB0_Type) SetCH1DLY0_DLY(value uint32) {
	volatile.StoreUint32(&o.CH1DLY0.Reg, volatile.LoadUint32(&o.CH1DLY0.Reg)&^(0xffff)|value)
}
func (o *PDB0_Type) GetCH1DLY0_DLY() uint32 {
	return volatile.LoadUint32(&o.CH1DLY0.Reg) & 0xffff
}

// PDB0.CH1DLY1: Channel n Delay 1 register
func (o *PDB0_Type) SetCH1DLY1_DLY(value uint32) {
	volatile.StoreUint32(&o.CH1DLY1.Reg, volatile.LoadUint32(&o.CH1DLY1.Reg)&^(0xffff)|value)
}
func (o *PDB0_Type) GetCH1DLY1_DLY() uint32 {
	return volatile.LoadUint32(&o.CH1DLY1.Reg) & 0xffff
}

// PDB0.DACINTC0: DAC Interval Trigger n Control register
func (o *PDB0_Type) SetDACINTC0_TOE(value uint32) {
	volatile.StoreUint32(&o.DACINTC0.Reg, volatile.LoadUint32(&o.DACINTC0.Reg)&^(0x1)|value)
}
func (o *PDB0_Type) GetDACINTC0_TOE() uint32 {
	return volatile.LoadUint32(&o.DACINTC0.Reg) & 0x1
}
func (o *PDB0_Type) SetDACINTC0_EXT(value uint32) {
	volatile.StoreUint32(&o.DACINTC0.Reg, volatile.LoadUint32(&o.DACINTC0.Reg)&^(0x2)|value<<1)
}
func (o *PDB0_Type) GetDACINTC0_EXT() uint32 {
	return (volatile.LoadUint32(&o.DACINTC0.Reg) & 0x2) >> 1
}

// PDB0.DACINT0: DAC Interval n register
func (o *PDB0_Type) SetDACINT0_INT(value uint32) {
	volatile.StoreUint32(&o.DACINT0.Reg, volatile.LoadUint32(&o.DACINT0.Reg)&^(0xffff)|value)
}
func (o *PDB0_Type) GetDACINT0_INT() uint32 {
	return volatile.LoadUint32(&o.DACINT0.Reg) & 0xffff
}

// PDB0.DACINTC1: DAC Interval Trigger n Control register
func (o *PDB0_Type) SetDACINTC1_TOE(value uint32) {
	volatile.StoreUint32(&o.DACINTC1.Reg, volatile.LoadUint32(&o.DACINTC1.Reg)&^(0x1)|value)
}
func (o *PDB0_Type) GetDACINTC1_TOE() uint32 {
	return volatile.LoadUint32(&o.DACINTC1.Reg) & 0x1
}
func (o *PDB0_Type) SetDACINTC1_EXT(value uint32) {
	volatile.StoreUint32(&o.DACINTC1.Reg, volatile.LoadUint32(&o.DACINTC1.Reg)&^(0x2)|value<<1)
}
func (o *PDB0_Type) GetDACINTC1_EXT() uint32 {
	return (volatile.LoadUint32(&o.DACINTC1.Reg) & 0x2) >> 1
}

// PDB0.DACINT1: DAC Interval n register
func (o *PDB0_Type) SetDACINT1_INT(value uint32) {
	volatile.StoreUint32(&o.DACINT1.Reg, volatile.LoadUint32(&o.DACINT1.Reg)&^(0xffff)|value)
}
func (o *PDB0_Type) GetDACINT1_INT() uint32 {
	return volatile.LoadUint32(&o.DACINT1.Reg) & 0xffff
}

// PDB0.POEN: Pulse-Out n Enable register
func (o *PDB0_Type) SetPOEN_POEN0(value uint32) {
	volatile.StoreUint32(&o.POEN.Reg, volatile.LoadUint32(&o.POEN.Reg)&^(0x1)|value)
}
func (o *PDB0_Type) GetPOEN_POEN0() uint32 {
	return volatile.LoadUint32(&o.POEN.Reg) & 0x1
}
func (o *PDB0_Type) SetPOEN_POEN1(value uint32) {
	volatile.StoreUint32(&o.POEN.Reg, volatile.LoadUint32(&o.POEN.Reg)&^(0x2)|value<<1)
}
func (o *PDB0_Type) GetPOEN_POEN1() uint32 {
	return (volatile.LoadUint32(&o.POEN.Reg) & 0x2) >> 1
}
func (o *PDB0_Type) SetPOEN_POEN2(value uint32) {
	volatile.StoreUint32(&o.POEN.Reg, volatile.LoadUint32(&o.POEN.Reg)&^(0x4)|value<<2)
}
func (o *PDB0_Type) GetPOEN_POEN2() uint32 {
	return (volatile.LoadUint32(&o.POEN.Reg) & 0x4) >> 2
}
func (o *PDB0_Type) SetPOEN_POEN3(value uint32) {
	volatile.StoreUint32(&o.POEN.Reg, volatile.LoadUint32(&o.POEN.Reg)&^(0x8)|value<<3)
}
func (o *PDB0_Type) GetPOEN_POEN3() uint32 {
	return (volatile.LoadUint32(&o.POEN.Reg) & 0x8) >> 3
}
func (o *PDB0_Type) SetPOEN_POEN4(value uint32) {
	volatile.StoreUint32(&o.POEN.Reg, volatile.LoadUint32(&o.POEN.Reg)&^(0x10)|value<<4)
}
func (o *PDB0_Type) GetPOEN_POEN4() uint32 {
	return (volatile.LoadUint32(&o.POEN.Reg) & 0x10) >> 4
}
func (o *PDB0_Type) SetPOEN_POEN5(value uint32) {
	volatile.StoreUint32(&o.POEN.Reg, volatile.LoadUint32(&o.POEN.Reg)&^(0x20)|value<<5)
}
func (o *PDB0_Type) GetPOEN_POEN5() uint32 {
	return (volatile.LoadUint32(&o.POEN.Reg) & 0x20) >> 5
}
func (o *PDB0_Type) SetPOEN_POEN6(value uint32) {
	volatile.StoreUint32(&o.POEN.Reg, volatile.LoadUint32(&o.POEN.Reg)&^(0x40)|value<<6)
}
func (o *PDB0_Type) GetPOEN_POEN6() uint32 {
	return (volatile.LoadUint32(&o.POEN.Reg) & 0x40) >> 6
}
func (o *PDB0_Type) SetPOEN_POEN7(value uint32) {
	volatile.StoreUint32(&o.POEN.Reg, volatile.LoadUint32(&o.POEN.Reg)&^(0x80)|value<<7)
}
func (o *PDB0_Type) GetPOEN_POEN7() uint32 {
	return (volatile.LoadUint32(&o.POEN.Reg) & 0x80) >> 7
}

// PDB0.PO0DLY: Pulse-Out n Delay register
func (o *PDB0_Type) SetPO0DLY_DLY2(value uint32) {
	volatile.StoreUint32(&o.PO0DLY.Reg, volatile.LoadUint32(&o.PO0DLY.Reg)&^(0xffff)|value)
}
func (o *PDB0_Type) GetPO0DLY_DLY2() uint32 {
	return volatile.LoadUint32(&o.PO0DLY.Reg) & 0xffff
}
func (o *PDB0_Type) SetPO0DLY_DLY1(value uint32) {
	volatile.StoreUint32(&o.PO0DLY.Reg, volatile.LoadUint32(&o.PO0DLY.Reg)&^(0xffff0000)|value<<16)
}
func (o *PDB0_Type) GetPO0DLY_DLY1() uint32 {
	return (volatile.LoadUint32(&o.PO0DLY.Reg) & 0xffff0000) >> 16
}

// PDB0.PO1DLY: Pulse-Out n Delay register
func (o *PDB0_Type) SetPO1DLY_DLY2(value uint32) {
	volatile.StoreUint32(&o.PO1DLY.Reg, volatile.LoadUint32(&o.PO1DLY.Reg)&^(0xffff)|value)
}
func (o *PDB0_Type) GetPO1DLY_DLY2() uint32 {
	return volatile.LoadUint32(&o.PO1DLY.Reg) & 0xffff
}
func (o *PDB0_Type) SetPO1DLY_DLY1(value uint32) {
	volatile.StoreUint32(&o.PO1DLY.Reg, volatile.LoadUint32(&o.PO1DLY.Reg)&^(0xffff0000)|value<<16)
}
func (o *PDB0_Type) GetPO1DLY_DLY1() uint32 {
	return (volatile.LoadUint32(&o.PO1DLY.Reg) & 0xffff0000) >> 16
}

// PDB0.PO2DLY: Pulse-Out n Delay register
func (o *PDB0_Type) SetPO2DLY_DLY2(value uint32) {
	volatile.StoreUint32(&o.PO2DLY.Reg, volatile.LoadUint32(&o.PO2DLY.Reg)&^(0xffff)|value)
}
func (o *PDB0_Type) GetPO2DLY_DLY2() uint32 {
	return volatile.LoadUint32(&o.PO2DLY.Reg) & 0xffff
}
func (o *PDB0_Type) SetPO2DLY_DLY1(value uint32) {
	volatile.StoreUint32(&o.PO2DLY.Reg, volatile.LoadUint32(&o.PO2DLY.Reg)&^(0xffff0000)|value<<16)
}
func (o *PDB0_Type) GetPO2DLY_DLY1() uint32 {
	return (volatile.LoadUint32(&o.PO2DLY.Reg) & 0xffff0000) >> 16
}

// Periodic Interrupt Timer
type PIT_Type struct {
	MCR    volatile.Register32 // 0x0
	_      [252]byte
	LDVAL0 volatile.Register32 // 0x100
	CVAL0  volatile.Register32 // 0x104
	TCTRL0 volatile.Register32 // 0x108
	TFLG0  volatile.Register32 // 0x10C
	LDVAL1 volatile.Register32 // 0x110
	CVAL1  volatile.Register32 // 0x114
	TCTRL1 volatile.Register32 // 0x118
	TFLG1  volatile.Register32 // 0x11C
	LDVAL2 volatile.Register32 // 0x120
	CVAL2  volatile.Register32 // 0x124
	TCTRL2 volatile.Register32 // 0x128
	TFLG2  volatile.Register32 // 0x12C
	LDVAL3 volatile.Register32 // 0x130
	CVAL3  volatile.Register32 // 0x134
	TCTRL3 volatile.Register32 // 0x138
	TFLG3  volatile.Register32 // 0x13C
}

// PIT.MCR: PIT Module Control Register
func (o *PIT_Type) SetMCR_FRZ(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x1)|value)
}
func (o *PIT_Type) GetMCR_FRZ() uint32 {
	return volatile.LoadUint32(&o.MCR.Reg) & 0x1
}
func (o *PIT_Type) SetMCR_MDIS(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x2)|value<<1)
}
func (o *PIT_Type) GetMCR_MDIS() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x2) >> 1
}

// PIT.LDVAL0: Timer Load Value Register
func (o *PIT_Type) SetLDVAL0(value uint32) {
	volatile.StoreUint32(&o.LDVAL0.Reg, value)
}
func (o *PIT_Type) GetLDVAL0() uint32 {
	return volatile.LoadUint32(&o.LDVAL0.Reg)
}

// PIT.CVAL0: Current Timer Value Register
func (o *PIT_Type) SetCVAL0(value uint32) {
	volatile.StoreUint32(&o.CVAL0.Reg, value)
}
func (o *PIT_Type) GetCVAL0() uint32 {
	return volatile.LoadUint32(&o.CVAL0.Reg)
}

// PIT.TCTRL0: Timer Control Register
func (o *PIT_Type) SetTCTRL0_TEN(value uint32) {
	volatile.StoreUint32(&o.TCTRL0.Reg, volatile.LoadUint32(&o.TCTRL0.Reg)&^(0x1)|value)
}
func (o *PIT_Type) GetTCTRL0_TEN() uint32 {
	return volatile.LoadUint32(&o.TCTRL0.Reg) & 0x1
}
func (o *PIT_Type) SetTCTRL0_TIE(value uint32) {
	volatile.StoreUint32(&o.TCTRL0.Reg, volatile.LoadUint32(&o.TCTRL0.Reg)&^(0x2)|value<<1)
}
func (o *PIT_Type) GetTCTRL0_TIE() uint32 {
	return (volatile.LoadUint32(&o.TCTRL0.Reg) & 0x2) >> 1
}
func (o *PIT_Type) SetTCTRL0_CHN(value uint32) {
	volatile.StoreUint32(&o.TCTRL0.Reg, volatile.LoadUint32(&o.TCTRL0.Reg)&^(0x4)|value<<2)
}
func (o *PIT_Type) GetTCTRL0_CHN() uint32 {
	return (volatile.LoadUint32(&o.TCTRL0.Reg) & 0x4) >> 2
}

// PIT.TFLG0: Timer Flag Register
func (o *PIT_Type) SetTFLG0_TIF(value uint32) {
	volatile.StoreUint32(&o.TFLG0.Reg, volatile.LoadUint32(&o.TFLG0.Reg)&^(0x1)|value)
}
func (o *PIT_Type) GetTFLG0_TIF() uint32 {
	return volatile.LoadUint32(&o.TFLG0.Reg) & 0x1
}

// PIT.LDVAL1: Timer Load Value Register
func (o *PIT_Type) SetLDVAL1(value uint32) {
	volatile.StoreUint32(&o.LDVAL1.Reg, value)
}
func (o *PIT_Type) GetLDVAL1() uint32 {
	return volatile.LoadUint32(&o.LDVAL1.Reg)
}

// PIT.CVAL1: Current Timer Value Register
func (o *PIT_Type) SetCVAL1(value uint32) {
	volatile.StoreUint32(&o.CVAL1.Reg, value)
}
func (o *PIT_Type) GetCVAL1() uint32 {
	return volatile.LoadUint32(&o.CVAL1.Reg)
}

// PIT.TCTRL1: Timer Control Register
func (o *PIT_Type) SetTCTRL1_TEN(value uint32) {
	volatile.StoreUint32(&o.TCTRL1.Reg, volatile.LoadUint32(&o.TCTRL1.Reg)&^(0x1)|value)
}
func (o *PIT_Type) GetTCTRL1_TEN() uint32 {
	return volatile.LoadUint32(&o.TCTRL1.Reg) & 0x1
}
func (o *PIT_Type) SetTCTRL1_TIE(value uint32) {
	volatile.StoreUint32(&o.TCTRL1.Reg, volatile.LoadUint32(&o.TCTRL1.Reg)&^(0x2)|value<<1)
}
func (o *PIT_Type) GetTCTRL1_TIE() uint32 {
	return (volatile.LoadUint32(&o.TCTRL1.Reg) & 0x2) >> 1
}
func (o *PIT_Type) SetTCTRL1_CHN(value uint32) {
	volatile.StoreUint32(&o.TCTRL1.Reg, volatile.LoadUint32(&o.TCTRL1.Reg)&^(0x4)|value<<2)
}
func (o *PIT_Type) GetTCTRL1_CHN() uint32 {
	return (volatile.LoadUint32(&o.TCTRL1.Reg) & 0x4) >> 2
}

// PIT.TFLG1: Timer Flag Register
func (o *PIT_Type) SetTFLG1_TIF(value uint32) {
	volatile.StoreUint32(&o.TFLG1.Reg, volatile.LoadUint32(&o.TFLG1.Reg)&^(0x1)|value)
}
func (o *PIT_Type) GetTFLG1_TIF() uint32 {
	return volatile.LoadUint32(&o.TFLG1.Reg) & 0x1
}

// PIT.LDVAL2: Timer Load Value Register
func (o *PIT_Type) SetLDVAL2(value uint32) {
	volatile.StoreUint32(&o.LDVAL2.Reg, value)
}
func (o *PIT_Type) GetLDVAL2() uint32 {
	return volatile.LoadUint32(&o.LDVAL2.Reg)
}

// PIT.CVAL2: Current Timer Value Register
func (o *PIT_Type) SetCVAL2(value uint32) {
	volatile.StoreUint32(&o.CVAL2.Reg, value)
}
func (o *PIT_Type) GetCVAL2() uint32 {
	return volatile.LoadUint32(&o.CVAL2.Reg)
}

// PIT.TCTRL2: Timer Control Register
func (o *PIT_Type) SetTCTRL2_TEN(value uint32) {
	volatile.StoreUint32(&o.TCTRL2.Reg, volatile.LoadUint32(&o.TCTRL2.Reg)&^(0x1)|value)
}
func (o *PIT_Type) GetTCTRL2_TEN() uint32 {
	return volatile.LoadUint32(&o.TCTRL2.Reg) & 0x1
}
func (o *PIT_Type) SetTCTRL2_TIE(value uint32) {
	volatile.StoreUint32(&o.TCTRL2.Reg, volatile.LoadUint32(&o.TCTRL2.Reg)&^(0x2)|value<<1)
}
func (o *PIT_Type) GetTCTRL2_TIE() uint32 {
	return (volatile.LoadUint32(&o.TCTRL2.Reg) & 0x2) >> 1
}
func (o *PIT_Type) SetTCTRL2_CHN(value uint32) {
	volatile.StoreUint32(&o.TCTRL2.Reg, volatile.LoadUint32(&o.TCTRL2.Reg)&^(0x4)|value<<2)
}
func (o *PIT_Type) GetTCTRL2_CHN() uint32 {
	return (volatile.LoadUint32(&o.TCTRL2.Reg) & 0x4) >> 2
}

// PIT.TFLG2: Timer Flag Register
func (o *PIT_Type) SetTFLG2_TIF(value uint32) {
	volatile.StoreUint32(&o.TFLG2.Reg, volatile.LoadUint32(&o.TFLG2.Reg)&^(0x1)|value)
}
func (o *PIT_Type) GetTFLG2_TIF() uint32 {
	return volatile.LoadUint32(&o.TFLG2.Reg) & 0x1
}

// PIT.LDVAL3: Timer Load Value Register
func (o *PIT_Type) SetLDVAL3(value uint32) {
	volatile.StoreUint32(&o.LDVAL3.Reg, value)
}
func (o *PIT_Type) GetLDVAL3() uint32 {
	return volatile.LoadUint32(&o.LDVAL3.Reg)
}

// PIT.CVAL3: Current Timer Value Register
func (o *PIT_Type) SetCVAL3(value uint32) {
	volatile.StoreUint32(&o.CVAL3.Reg, value)
}
func (o *PIT_Type) GetCVAL3() uint32 {
	return volatile.LoadUint32(&o.CVAL3.Reg)
}

// PIT.TCTRL3: Timer Control Register
func (o *PIT_Type) SetTCTRL3_TEN(value uint32) {
	volatile.StoreUint32(&o.TCTRL3.Reg, volatile.LoadUint32(&o.TCTRL3.Reg)&^(0x1)|value)
}
func (o *PIT_Type) GetTCTRL3_TEN() uint32 {
	return volatile.LoadUint32(&o.TCTRL3.Reg) & 0x1
}
func (o *PIT_Type) SetTCTRL3_TIE(value uint32) {
	volatile.StoreUint32(&o.TCTRL3.Reg, volatile.LoadUint32(&o.TCTRL3.Reg)&^(0x2)|value<<1)
}
func (o *PIT_Type) GetTCTRL3_TIE() uint32 {
	return (volatile.LoadUint32(&o.TCTRL3.Reg) & 0x2) >> 1
}
func (o *PIT_Type) SetTCTRL3_CHN(value uint32) {
	volatile.StoreUint32(&o.TCTRL3.Reg, volatile.LoadUint32(&o.TCTRL3.Reg)&^(0x4)|value<<2)
}
func (o *PIT_Type) GetTCTRL3_CHN() uint32 {
	return (volatile.LoadUint32(&o.TCTRL3.Reg) & 0x4) >> 2
}

// PIT.TFLG3: Timer Flag Register
func (o *PIT_Type) SetTFLG3_TIF(value uint32) {
	volatile.StoreUint32(&o.TFLG3.Reg, volatile.LoadUint32(&o.TFLG3.Reg)&^(0x1)|value)
}
func (o *PIT_Type) GetTFLG3_TIF() uint32 {
	return volatile.LoadUint32(&o.TFLG3.Reg) & 0x1
}

// FlexTimer Module
type FTM_Type struct {
	SC       volatile.Register32 // 0x0
	CNT      volatile.Register32 // 0x4
	MOD      volatile.Register32 // 0x8
	C0SC     volatile.Register32 // 0xC
	C0V      volatile.Register32 // 0x10
	C1SC     volatile.Register32 // 0x14
	C1V      volatile.Register32 // 0x18
	C2SC     volatile.Register32 // 0x1C
	C2V      volatile.Register32 // 0x20
	C3SC     volatile.Register32 // 0x24
	C3V      volatile.Register32 // 0x28
	C4SC     volatile.Register32 // 0x2C
	C4V      volatile.Register32 // 0x30
	C5SC     volatile.Register32 // 0x34
	C5V      volatile.Register32 // 0x38
	C6SC     volatile.Register32 // 0x3C
	C6V      volatile.Register32 // 0x40
	C7SC     volatile.Register32 // 0x44
	C7V      volatile.Register32 // 0x48
	CNTIN    volatile.Register32 // 0x4C
	STATUS   volatile.Register32 // 0x50
	MODE     volatile.Register32 // 0x54
	SYNC     volatile.Register32 // 0x58
	OUTINIT  volatile.Register32 // 0x5C
	OUTMASK  volatile.Register32 // 0x60
	COMBINE  volatile.Register32 // 0x64
	DEADTIME volatile.Register32 // 0x68
	EXTTRIG  volatile.Register32 // 0x6C
	POL      volatile.Register32 // 0x70
	FMS      volatile.Register32 // 0x74
	FILTER   volatile.Register32 // 0x78
	FLTCTRL  volatile.Register32 // 0x7C
	QDCTRL   volatile.Register32 // 0x80
	CONF     volatile.Register32 // 0x84
	FLTPOL   volatile.Register32 // 0x88
	SYNCONF  volatile.Register32 // 0x8C
	INVCTRL  volatile.Register32 // 0x90
	SWOCTRL  volatile.Register32 // 0x94
	PWMLOAD  volatile.Register32 // 0x98
}

// FTM.SC: Status And Control
func (o *FTM_Type) SetSC_PS(value uint32) {
	volatile.StoreUint32(&o.SC.Reg, volatile.LoadUint32(&o.SC.Reg)&^(0x7)|value)
}
func (o *FTM_Type) GetSC_PS() uint32 {
	return volatile.LoadUint32(&o.SC.Reg) & 0x7
}
func (o *FTM_Type) SetSC_CLKS(value uint32) {
	volatile.StoreUint32(&o.SC.Reg, volatile.LoadUint32(&o.SC.Reg)&^(0x18)|value<<3)
}
func (o *FTM_Type) GetSC_CLKS() uint32 {
	return (volatile.LoadUint32(&o.SC.Reg) & 0x18) >> 3
}
func (o *FTM_Type) SetSC_CPWMS(value uint32) {
	volatile.StoreUint32(&o.SC.Reg, volatile.LoadUint32(&o.SC.Reg)&^(0x20)|value<<5)
}
func (o *FTM_Type) GetSC_CPWMS() uint32 {
	return (volatile.LoadUint32(&o.SC.Reg) & 0x20) >> 5
}
func (o *FTM_Type) SetSC_TOIE(value uint32) {
	volatile.StoreUint32(&o.SC.Reg, volatile.LoadUint32(&o.SC.Reg)&^(0x40)|value<<6)
}
func (o *FTM_Type) GetSC_TOIE() uint32 {
	return (volatile.LoadUint32(&o.SC.Reg) & 0x40) >> 6
}
func (o *FTM_Type) SetSC_TOF(value uint32) {
	volatile.StoreUint32(&o.SC.Reg, volatile.LoadUint32(&o.SC.Reg)&^(0x80)|value<<7)
}
func (o *FTM_Type) GetSC_TOF() uint32 {
	return (volatile.LoadUint32(&o.SC.Reg) & 0x80) >> 7
}

// FTM.CNT: Counter
func (o *FTM_Type) SetCNT_COUNT(value uint32) {
	volatile.StoreUint32(&o.CNT.Reg, volatile.LoadUint32(&o.CNT.Reg)&^(0xffff)|value)
}
func (o *FTM_Type) GetCNT_COUNT() uint32 {
	return volatile.LoadUint32(&o.CNT.Reg) & 0xffff
}

// FTM.MOD: Modulo
func (o *FTM_Type) SetMOD(value uint32) {
	volatile.StoreUint32(&o.MOD.Reg, volatile.LoadUint32(&o.MOD.Reg)&^(0xffff)|value)
}
func (o *FTM_Type) GetMOD() uint32 {
	return volatile.LoadUint32(&o.MOD.Reg) & 0xffff
}

// FTM.C0SC: Channel (n) Status And Control
func (o *FTM_Type) SetC0SC_DMA(value uint32) {
	volatile.StoreUint32(&o.C0SC.Reg, volatile.LoadUint32(&o.C0SC.Reg)&^(0x1)|value)
}
func (o *FTM_Type) GetC0SC_DMA() uint32 {
	return volatile.LoadUint32(&o.C0SC.Reg) & 0x1
}
func (o *FTM_Type) SetC0SC_ELSA(value uint32) {
	volatile.StoreUint32(&o.C0SC.Reg, volatile.LoadUint32(&o.C0SC.Reg)&^(0x4)|value<<2)
}
func (o *FTM_Type) GetC0SC_ELSA() uint32 {
	return (volatile.LoadUint32(&o.C0SC.Reg) & 0x4) >> 2
}
func (o *FTM_Type) SetC0SC_ELSB(value uint32) {
	volatile.StoreUint32(&o.C0SC.Reg, volatile.LoadUint32(&o.C0SC.Reg)&^(0x8)|value<<3)
}
func (o *FTM_Type) GetC0SC_ELSB() uint32 {
	return (volatile.LoadUint32(&o.C0SC.Reg) & 0x8) >> 3
}
func (o *FTM_Type) SetC0SC_MSA(value uint32) {
	volatile.StoreUint32(&o.C0SC.Reg, volatile.LoadUint32(&o.C0SC.Reg)&^(0x10)|value<<4)
}
func (o *FTM_Type) GetC0SC_MSA() uint32 {
	return (volatile.LoadUint32(&o.C0SC.Reg) & 0x10) >> 4
}
func (o *FTM_Type) SetC0SC_MSB(value uint32) {
	volatile.StoreUint32(&o.C0SC.Reg, volatile.LoadUint32(&o.C0SC.Reg)&^(0x20)|value<<5)
}
func (o *FTM_Type) GetC0SC_MSB() uint32 {
	return (volatile.LoadUint32(&o.C0SC.Reg) & 0x20) >> 5
}
func (o *FTM_Type) SetC0SC_CHIE(value uint32) {
	volatile.StoreUint32(&o.C0SC.Reg, volatile.LoadUint32(&o.C0SC.Reg)&^(0x40)|value<<6)
}
func (o *FTM_Type) GetC0SC_CHIE() uint32 {
	return (volatile.LoadUint32(&o.C0SC.Reg) & 0x40) >> 6
}
func (o *FTM_Type) SetC0SC_CHF(value uint32) {
	volatile.StoreUint32(&o.C0SC.Reg, volatile.LoadUint32(&o.C0SC.Reg)&^(0x80)|value<<7)
}
func (o *FTM_Type) GetC0SC_CHF() uint32 {
	return (volatile.LoadUint32(&o.C0SC.Reg) & 0x80) >> 7
}

// FTM.C0V: Channel (n) Value
func (o *FTM_Type) SetC0V_VAL(value uint32) {
	volatile.StoreUint32(&o.C0V.Reg, volatile.LoadUint32(&o.C0V.Reg)&^(0xffff)|value)
}
func (o *FTM_Type) GetC0V_VAL() uint32 {
	return volatile.LoadUint32(&o.C0V.Reg) & 0xffff
}

// FTM.C1SC: Channel (n) Status And Control
func (o *FTM_Type) SetC1SC_DMA(value uint32) {
	volatile.StoreUint32(&o.C1SC.Reg, volatile.LoadUint32(&o.C1SC.Reg)&^(0x1)|value)
}
func (o *FTM_Type) GetC1SC_DMA() uint32 {
	return volatile.LoadUint32(&o.C1SC.Reg) & 0x1
}
func (o *FTM_Type) SetC1SC_ELSA(value uint32) {
	volatile.StoreUint32(&o.C1SC.Reg, volatile.LoadUint32(&o.C1SC.Reg)&^(0x4)|value<<2)
}
func (o *FTM_Type) GetC1SC_ELSA() uint32 {
	return (volatile.LoadUint32(&o.C1SC.Reg) & 0x4) >> 2
}
func (o *FTM_Type) SetC1SC_ELSB(value uint32) {
	volatile.StoreUint32(&o.C1SC.Reg, volatile.LoadUint32(&o.C1SC.Reg)&^(0x8)|value<<3)
}
func (o *FTM_Type) GetC1SC_ELSB() uint32 {
	return (volatile.LoadUint32(&o.C1SC.Reg) & 0x8) >> 3
}
func (o *FTM_Type) SetC1SC_MSA(value uint32) {
	volatile.StoreUint32(&o.C1SC.Reg, volatile.LoadUint32(&o.C1SC.Reg)&^(0x10)|value<<4)
}
func (o *FTM_Type) GetC1SC_MSA() uint32 {
	return (volatile.LoadUint32(&o.C1SC.Reg) & 0x10) >> 4
}
func (o *FTM_Type) SetC1SC_MSB(value uint32) {
	volatile.StoreUint32(&o.C1SC.Reg, volatile.LoadUint32(&o.C1SC.Reg)&^(0x20)|value<<5)
}
func (o *FTM_Type) GetC1SC_MSB() uint32 {
	return (volatile.LoadUint32(&o.C1SC.Reg) & 0x20) >> 5
}
func (o *FTM_Type) SetC1SC_CHIE(value uint32) {
	volatile.StoreUint32(&o.C1SC.Reg, volatile.LoadUint32(&o.C1SC.Reg)&^(0x40)|value<<6)
}
func (o *FTM_Type) GetC1SC_CHIE() uint32 {
	return (volatile.LoadUint32(&o.C1SC.Reg) & 0x40) >> 6
}
func (o *FTM_Type) SetC1SC_CHF(value uint32) {
	volatile.StoreUint32(&o.C1SC.Reg, volatile.LoadUint32(&o.C1SC.Reg)&^(0x80)|value<<7)
}
func (o *FTM_Type) GetC1SC_CHF() uint32 {
	return (volatile.LoadUint32(&o.C1SC.Reg) & 0x80) >> 7
}

// FTM.C1V: Channel (n) Value
func (o *FTM_Type) SetC1V_VAL(value uint32) {
	volatile.StoreUint32(&o.C1V.Reg, volatile.LoadUint32(&o.C1V.Reg)&^(0xffff)|value)
}
func (o *FTM_Type) GetC1V_VAL() uint32 {
	return volatile.LoadUint32(&o.C1V.Reg) & 0xffff
}

// FTM.C2SC: Channel (n) Status And Control
func (o *FTM_Type) SetC2SC_DMA(value uint32) {
	volatile.StoreUint32(&o.C2SC.Reg, volatile.LoadUint32(&o.C2SC.Reg)&^(0x1)|value)
}
func (o *FTM_Type) GetC2SC_DMA() uint32 {
	return volatile.LoadUint32(&o.C2SC.Reg) & 0x1
}
func (o *FTM_Type) SetC2SC_ELSA(value uint32) {
	volatile.StoreUint32(&o.C2SC.Reg, volatile.LoadUint32(&o.C2SC.Reg)&^(0x4)|value<<2)
}
func (o *FTM_Type) GetC2SC_ELSA() uint32 {
	return (volatile.LoadUint32(&o.C2SC.Reg) & 0x4) >> 2
}
func (o *FTM_Type) SetC2SC_ELSB(value uint32) {
	volatile.StoreUint32(&o.C2SC.Reg, volatile.LoadUint32(&o.C2SC.Reg)&^(0x8)|value<<3)
}
func (o *FTM_Type) GetC2SC_ELSB() uint32 {
	return (volatile.LoadUint32(&o.C2SC.Reg) & 0x8) >> 3
}
func (o *FTM_Type) SetC2SC_MSA(value uint32) {
	volatile.StoreUint32(&o.C2SC.Reg, volatile.LoadUint32(&o.C2SC.Reg)&^(0x10)|value<<4)
}
func (o *FTM_Type) GetC2SC_MSA() uint32 {
	return (volatile.LoadUint32(&o.C2SC.Reg) & 0x10) >> 4
}
func (o *FTM_Type) SetC2SC_MSB(value uint32) {
	volatile.StoreUint32(&o.C2SC.Reg, volatile.LoadUint32(&o.C2SC.Reg)&^(0x20)|value<<5)
}
func (o *FTM_Type) GetC2SC_MSB() uint32 {
	return (volatile.LoadUint32(&o.C2SC.Reg) & 0x20) >> 5
}
func (o *FTM_Type) SetC2SC_CHIE(value uint32) {
	volatile.StoreUint32(&o.C2SC.Reg, volatile.LoadUint32(&o.C2SC.Reg)&^(0x40)|value<<6)
}
func (o *FTM_Type) GetC2SC_CHIE() uint32 {
	return (volatile.LoadUint32(&o.C2SC.Reg) & 0x40) >> 6
}
func (o *FTM_Type) SetC2SC_CHF(value uint32) {
	volatile.StoreUint32(&o.C2SC.Reg, volatile.LoadUint32(&o.C2SC.Reg)&^(0x80)|value<<7)
}
func (o *FTM_Type) GetC2SC_CHF() uint32 {
	return (volatile.LoadUint32(&o.C2SC.Reg) & 0x80) >> 7
}

// FTM.C2V: Channel (n) Value
func (o *FTM_Type) SetC2V_VAL(value uint32) {
	volatile.StoreUint32(&o.C2V.Reg, volatile.LoadUint32(&o.C2V.Reg)&^(0xffff)|value)
}
func (o *FTM_Type) GetC2V_VAL() uint32 {
	return volatile.LoadUint32(&o.C2V.Reg) & 0xffff
}

// FTM.C3SC: Channel (n) Status And Control
func (o *FTM_Type) SetC3SC_DMA(value uint32) {
	volatile.StoreUint32(&o.C3SC.Reg, volatile.LoadUint32(&o.C3SC.Reg)&^(0x1)|value)
}
func (o *FTM_Type) GetC3SC_DMA() uint32 {
	return volatile.LoadUint32(&o.C3SC.Reg) & 0x1
}
func (o *FTM_Type) SetC3SC_ELSA(value uint32) {
	volatile.StoreUint32(&o.C3SC.Reg, volatile.LoadUint32(&o.C3SC.Reg)&^(0x4)|value<<2)
}
func (o *FTM_Type) GetC3SC_ELSA() uint32 {
	return (volatile.LoadUint32(&o.C3SC.Reg) & 0x4) >> 2
}
func (o *FTM_Type) SetC3SC_ELSB(value uint32) {
	volatile.StoreUint32(&o.C3SC.Reg, volatile.LoadUint32(&o.C3SC.Reg)&^(0x8)|value<<3)
}
func (o *FTM_Type) GetC3SC_ELSB() uint32 {
	return (volatile.LoadUint32(&o.C3SC.Reg) & 0x8) >> 3
}
func (o *FTM_Type) SetC3SC_MSA(value uint32) {
	volatile.StoreUint32(&o.C3SC.Reg, volatile.LoadUint32(&o.C3SC.Reg)&^(0x10)|value<<4)
}
func (o *FTM_Type) GetC3SC_MSA() uint32 {
	return (volatile.LoadUint32(&o.C3SC.Reg) & 0x10) >> 4
}
func (o *FTM_Type) SetC3SC_MSB(value uint32) {
	volatile.StoreUint32(&o.C3SC.Reg, volatile.LoadUint32(&o.C3SC.Reg)&^(0x20)|value<<5)
}
func (o *FTM_Type) GetC3SC_MSB() uint32 {
	return (volatile.LoadUint32(&o.C3SC.Reg) & 0x20) >> 5
}
func (o *FTM_Type) SetC3SC_CHIE(value uint32) {
	volatile.StoreUint32(&o.C3SC.Reg, volatile.LoadUint32(&o.C3SC.Reg)&^(0x40)|value<<6)
}
func (o *FTM_Type) GetC3SC_CHIE() uint32 {
	return (volatile.LoadUint32(&o.C3SC.Reg) & 0x40) >> 6
}
func (o *FTM_Type) SetC3SC_CHF(value uint32) {
	volatile.StoreUint32(&o.C3SC.Reg, volatile.LoadUint32(&o.C3SC.Reg)&^(0x80)|value<<7)
}
func (o *FTM_Type) GetC3SC_CHF() uint32 {
	return (volatile.LoadUint32(&o.C3SC.Reg) & 0x80) >> 7
}

// FTM.C3V: Channel (n) Value
func (o *FTM_Type) SetC3V_VAL(value uint32) {
	volatile.StoreUint32(&o.C3V.Reg, volatile.LoadUint32(&o.C3V.Reg)&^(0xffff)|value)
}
func (o *FTM_Type) GetC3V_VAL() uint32 {
	return volatile.LoadUint32(&o.C3V.Reg) & 0xffff
}

// FTM.C4SC: Channel (n) Status And Control
func (o *FTM_Type) SetC4SC_DMA(value uint32) {
	volatile.StoreUint32(&o.C4SC.Reg, volatile.LoadUint32(&o.C4SC.Reg)&^(0x1)|value)
}
func (o *FTM_Type) GetC4SC_DMA() uint32 {
	return volatile.LoadUint32(&o.C4SC.Reg) & 0x1
}
func (o *FTM_Type) SetC4SC_ELSA(value uint32) {
	volatile.StoreUint32(&o.C4SC.Reg, volatile.LoadUint32(&o.C4SC.Reg)&^(0x4)|value<<2)
}
func (o *FTM_Type) GetC4SC_ELSA() uint32 {
	return (volatile.LoadUint32(&o.C4SC.Reg) & 0x4) >> 2
}
func (o *FTM_Type) SetC4SC_ELSB(value uint32) {
	volatile.StoreUint32(&o.C4SC.Reg, volatile.LoadUint32(&o.C4SC.Reg)&^(0x8)|value<<3)
}
func (o *FTM_Type) GetC4SC_ELSB() uint32 {
	return (volatile.LoadUint32(&o.C4SC.Reg) & 0x8) >> 3
}
func (o *FTM_Type) SetC4SC_MSA(value uint32) {
	volatile.StoreUint32(&o.C4SC.Reg, volatile.LoadUint32(&o.C4SC.Reg)&^(0x10)|value<<4)
}
func (o *FTM_Type) GetC4SC_MSA() uint32 {
	return (volatile.LoadUint32(&o.C4SC.Reg) & 0x10) >> 4
}
func (o *FTM_Type) SetC4SC_MSB(value uint32) {
	volatile.StoreUint32(&o.C4SC.Reg, volatile.LoadUint32(&o.C4SC.Reg)&^(0x20)|value<<5)
}
func (o *FTM_Type) GetC4SC_MSB() uint32 {
	return (volatile.LoadUint32(&o.C4SC.Reg) & 0x20) >> 5
}
func (o *FTM_Type) SetC4SC_CHIE(value uint32) {
	volatile.StoreUint32(&o.C4SC.Reg, volatile.LoadUint32(&o.C4SC.Reg)&^(0x40)|value<<6)
}
func (o *FTM_Type) GetC4SC_CHIE() uint32 {
	return (volatile.LoadUint32(&o.C4SC.Reg) & 0x40) >> 6
}
func (o *FTM_Type) SetC4SC_CHF(value uint32) {
	volatile.StoreUint32(&o.C4SC.Reg, volatile.LoadUint32(&o.C4SC.Reg)&^(0x80)|value<<7)
}
func (o *FTM_Type) GetC4SC_CHF() uint32 {
	return (volatile.LoadUint32(&o.C4SC.Reg) & 0x80) >> 7
}

// FTM.C4V: Channel (n) Value
func (o *FTM_Type) SetC4V_VAL(value uint32) {
	volatile.StoreUint32(&o.C4V.Reg, volatile.LoadUint32(&o.C4V.Reg)&^(0xffff)|value)
}
func (o *FTM_Type) GetC4V_VAL() uint32 {
	return volatile.LoadUint32(&o.C4V.Reg) & 0xffff
}

// FTM.C5SC: Channel (n) Status And Control
func (o *FTM_Type) SetC5SC_DMA(value uint32) {
	volatile.StoreUint32(&o.C5SC.Reg, volatile.LoadUint32(&o.C5SC.Reg)&^(0x1)|value)
}
func (o *FTM_Type) GetC5SC_DMA() uint32 {
	return volatile.LoadUint32(&o.C5SC.Reg) & 0x1
}
func (o *FTM_Type) SetC5SC_ELSA(value uint32) {
	volatile.StoreUint32(&o.C5SC.Reg, volatile.LoadUint32(&o.C5SC.Reg)&^(0x4)|value<<2)
}
func (o *FTM_Type) GetC5SC_ELSA() uint32 {
	return (volatile.LoadUint32(&o.C5SC.Reg) & 0x4) >> 2
}
func (o *FTM_Type) SetC5SC_ELSB(value uint32) {
	volatile.StoreUint32(&o.C5SC.Reg, volatile.LoadUint32(&o.C5SC.Reg)&^(0x8)|value<<3)
}
func (o *FTM_Type) GetC5SC_ELSB() uint32 {
	return (volatile.LoadUint32(&o.C5SC.Reg) & 0x8) >> 3
}
func (o *FTM_Type) SetC5SC_MSA(value uint32) {
	volatile.StoreUint32(&o.C5SC.Reg, volatile.LoadUint32(&o.C5SC.Reg)&^(0x10)|value<<4)
}
func (o *FTM_Type) GetC5SC_MSA() uint32 {
	return (volatile.LoadUint32(&o.C5SC.Reg) & 0x10) >> 4
}
func (o *FTM_Type) SetC5SC_MSB(value uint32) {
	volatile.StoreUint32(&o.C5SC.Reg, volatile.LoadUint32(&o.C5SC.Reg)&^(0x20)|value<<5)
}
func (o *FTM_Type) GetC5SC_MSB() uint32 {
	return (volatile.LoadUint32(&o.C5SC.Reg) & 0x20) >> 5
}
func (o *FTM_Type) SetC5SC_CHIE(value uint32) {
	volatile.StoreUint32(&o.C5SC.Reg, volatile.LoadUint32(&o.C5SC.Reg)&^(0x40)|value<<6)
}
func (o *FTM_Type) GetC5SC_CHIE() uint32 {
	return (volatile.LoadUint32(&o.C5SC.Reg) & 0x40) >> 6
}
func (o *FTM_Type) SetC5SC_CHF(value uint32) {
	volatile.StoreUint32(&o.C5SC.Reg, volatile.LoadUint32(&o.C5SC.Reg)&^(0x80)|value<<7)
}
func (o *FTM_Type) GetC5SC_CHF() uint32 {
	return (volatile.LoadUint32(&o.C5SC.Reg) & 0x80) >> 7
}

// FTM.C5V: Channel (n) Value
func (o *FTM_Type) SetC5V_VAL(value uint32) {
	volatile.StoreUint32(&o.C5V.Reg, volatile.LoadUint32(&o.C5V.Reg)&^(0xffff)|value)
}
func (o *FTM_Type) GetC5V_VAL() uint32 {
	return volatile.LoadUint32(&o.C5V.Reg) & 0xffff
}

// FTM.C6SC: Channel (n) Status And Control
func (o *FTM_Type) SetC6SC_DMA(value uint32) {
	volatile.StoreUint32(&o.C6SC.Reg, volatile.LoadUint32(&o.C6SC.Reg)&^(0x1)|value)
}
func (o *FTM_Type) GetC6SC_DMA() uint32 {
	return volatile.LoadUint32(&o.C6SC.Reg) & 0x1
}
func (o *FTM_Type) SetC6SC_ELSA(value uint32) {
	volatile.StoreUint32(&o.C6SC.Reg, volatile.LoadUint32(&o.C6SC.Reg)&^(0x4)|value<<2)
}
func (o *FTM_Type) GetC6SC_ELSA() uint32 {
	return (volatile.LoadUint32(&o.C6SC.Reg) & 0x4) >> 2
}
func (o *FTM_Type) SetC6SC_ELSB(value uint32) {
	volatile.StoreUint32(&o.C6SC.Reg, volatile.LoadUint32(&o.C6SC.Reg)&^(0x8)|value<<3)
}
func (o *FTM_Type) GetC6SC_ELSB() uint32 {
	return (volatile.LoadUint32(&o.C6SC.Reg) & 0x8) >> 3
}
func (o *FTM_Type) SetC6SC_MSA(value uint32) {
	volatile.StoreUint32(&o.C6SC.Reg, volatile.LoadUint32(&o.C6SC.Reg)&^(0x10)|value<<4)
}
func (o *FTM_Type) GetC6SC_MSA() uint32 {
	return (volatile.LoadUint32(&o.C6SC.Reg) & 0x10) >> 4
}
func (o *FTM_Type) SetC6SC_MSB(value uint32) {
	volatile.StoreUint32(&o.C6SC.Reg, volatile.LoadUint32(&o.C6SC.Reg)&^(0x20)|value<<5)
}
func (o *FTM_Type) GetC6SC_MSB() uint32 {
	return (volatile.LoadUint32(&o.C6SC.Reg) & 0x20) >> 5
}
func (o *FTM_Type) SetC6SC_CHIE(value uint32) {
	volatile.StoreUint32(&o.C6SC.Reg, volatile.LoadUint32(&o.C6SC.Reg)&^(0x40)|value<<6)
}
func (o *FTM_Type) GetC6SC_CHIE() uint32 {
	return (volatile.LoadUint32(&o.C6SC.Reg) & 0x40) >> 6
}
func (o *FTM_Type) SetC6SC_CHF(value uint32) {
	volatile.StoreUint32(&o.C6SC.Reg, volatile.LoadUint32(&o.C6SC.Reg)&^(0x80)|value<<7)
}
func (o *FTM_Type) GetC6SC_CHF() uint32 {
	return (volatile.LoadUint32(&o.C6SC.Reg) & 0x80) >> 7
}

// FTM.C6V: Channel (n) Value
func (o *FTM_Type) SetC6V_VAL(value uint32) {
	volatile.StoreUint32(&o.C6V.Reg, volatile.LoadUint32(&o.C6V.Reg)&^(0xffff)|value)
}
func (o *FTM_Type) GetC6V_VAL() uint32 {
	return volatile.LoadUint32(&o.C6V.Reg) & 0xffff
}

// FTM.C7SC: Channel (n) Status And Control
func (o *FTM_Type) SetC7SC_DMA(value uint32) {
	volatile.StoreUint32(&o.C7SC.Reg, volatile.LoadUint32(&o.C7SC.Reg)&^(0x1)|value)
}
func (o *FTM_Type) GetC7SC_DMA() uint32 {
	return volatile.LoadUint32(&o.C7SC.Reg) & 0x1
}
func (o *FTM_Type) SetC7SC_ELSA(value uint32) {
	volatile.StoreUint32(&o.C7SC.Reg, volatile.LoadUint32(&o.C7SC.Reg)&^(0x4)|value<<2)
}
func (o *FTM_Type) GetC7SC_ELSA() uint32 {
	return (volatile.LoadUint32(&o.C7SC.Reg) & 0x4) >> 2
}
func (o *FTM_Type) SetC7SC_ELSB(value uint32) {
	volatile.StoreUint32(&o.C7SC.Reg, volatile.LoadUint32(&o.C7SC.Reg)&^(0x8)|value<<3)
}
func (o *FTM_Type) GetC7SC_ELSB() uint32 {
	return (volatile.LoadUint32(&o.C7SC.Reg) & 0x8) >> 3
}
func (o *FTM_Type) SetC7SC_MSA(value uint32) {
	volatile.StoreUint32(&o.C7SC.Reg, volatile.LoadUint32(&o.C7SC.Reg)&^(0x10)|value<<4)
}
func (o *FTM_Type) GetC7SC_MSA() uint32 {
	return (volatile.LoadUint32(&o.C7SC.Reg) & 0x10) >> 4
}
func (o *FTM_Type) SetC7SC_MSB(value uint32) {
	volatile.StoreUint32(&o.C7SC.Reg, volatile.LoadUint32(&o.C7SC.Reg)&^(0x20)|value<<5)
}
func (o *FTM_Type) GetC7SC_MSB() uint32 {
	return (volatile.LoadUint32(&o.C7SC.Reg) & 0x20) >> 5
}
func (o *FTM_Type) SetC7SC_CHIE(value uint32) {
	volatile.StoreUint32(&o.C7SC.Reg, volatile.LoadUint32(&o.C7SC.Reg)&^(0x40)|value<<6)
}
func (o *FTM_Type) GetC7SC_CHIE() uint32 {
	return (volatile.LoadUint32(&o.C7SC.Reg) & 0x40) >> 6
}
func (o *FTM_Type) SetC7SC_CHF(value uint32) {
	volatile.StoreUint32(&o.C7SC.Reg, volatile.LoadUint32(&o.C7SC.Reg)&^(0x80)|value<<7)
}
func (o *FTM_Type) GetC7SC_CHF() uint32 {
	return (volatile.LoadUint32(&o.C7SC.Reg) & 0x80) >> 7
}

// FTM.C7V: Channel (n) Value
func (o *FTM_Type) SetC7V_VAL(value uint32) {
	volatile.StoreUint32(&o.C7V.Reg, volatile.LoadUint32(&o.C7V.Reg)&^(0xffff)|value)
}
func (o *FTM_Type) GetC7V_VAL() uint32 {
	return volatile.LoadUint32(&o.C7V.Reg) & 0xffff
}

// FTM.CNTIN: Counter Initial Value
func (o *FTM_Type) SetCNTIN_INIT(value uint32) {
	volatile.StoreUint32(&o.CNTIN.Reg, volatile.LoadUint32(&o.CNTIN.Reg)&^(0xffff)|value)
}
func (o *FTM_Type) GetCNTIN_INIT() uint32 {
	return volatile.LoadUint32(&o.CNTIN.Reg) & 0xffff
}

// FTM.STATUS: Capture And Compare Status
func (o *FTM_Type) SetSTATUS_CH0F(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x1)|value)
}
func (o *FTM_Type) GetSTATUS_CH0F() uint32 {
	return volatile.LoadUint32(&o.STATUS.Reg) & 0x1
}
func (o *FTM_Type) SetSTATUS_CH1F(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x2)|value<<1)
}
func (o *FTM_Type) GetSTATUS_CH1F() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x2) >> 1
}
func (o *FTM_Type) SetSTATUS_CH2F(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x4)|value<<2)
}
func (o *FTM_Type) GetSTATUS_CH2F() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x4) >> 2
}
func (o *FTM_Type) SetSTATUS_CH3F(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x8)|value<<3)
}
func (o *FTM_Type) GetSTATUS_CH3F() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x8) >> 3
}
func (o *FTM_Type) SetSTATUS_CH4F(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x10)|value<<4)
}
func (o *FTM_Type) GetSTATUS_CH4F() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x10) >> 4
}
func (o *FTM_Type) SetSTATUS_CH5F(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x20)|value<<5)
}
func (o *FTM_Type) GetSTATUS_CH5F() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x20) >> 5
}
func (o *FTM_Type) SetSTATUS_CH6F(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x40)|value<<6)
}
func (o *FTM_Type) GetSTATUS_CH6F() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x40) >> 6
}
func (o *FTM_Type) SetSTATUS_CH7F(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x80)|value<<7)
}
func (o *FTM_Type) GetSTATUS_CH7F() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x80) >> 7
}

// FTM.MODE: Features Mode Selection
func (o *FTM_Type) SetMODE_FTMEN(value uint32) {
	volatile.StoreUint32(&o.MODE.Reg, volatile.LoadUint32(&o.MODE.Reg)&^(0x1)|value)
}
func (o *FTM_Type) GetMODE_FTMEN() uint32 {
	return volatile.LoadUint32(&o.MODE.Reg) & 0x1
}
func (o *FTM_Type) SetMODE_INIT(value uint32) {
	volatile.StoreUint32(&o.MODE.Reg, volatile.LoadUint32(&o.MODE.Reg)&^(0x2)|value<<1)
}
func (o *FTM_Type) GetMODE_INIT() uint32 {
	return (volatile.LoadUint32(&o.MODE.Reg) & 0x2) >> 1
}
func (o *FTM_Type) SetMODE_WPDIS(value uint32) {
	volatile.StoreUint32(&o.MODE.Reg, volatile.LoadUint32(&o.MODE.Reg)&^(0x4)|value<<2)
}
func (o *FTM_Type) GetMODE_WPDIS() uint32 {
	return (volatile.LoadUint32(&o.MODE.Reg) & 0x4) >> 2
}
func (o *FTM_Type) SetMODE_PWMSYNC(value uint32) {
	volatile.StoreUint32(&o.MODE.Reg, volatile.LoadUint32(&o.MODE.Reg)&^(0x8)|value<<3)
}
func (o *FTM_Type) GetMODE_PWMSYNC() uint32 {
	return (volatile.LoadUint32(&o.MODE.Reg) & 0x8) >> 3
}
func (o *FTM_Type) SetMODE_CAPTEST(value uint32) {
	volatile.StoreUint32(&o.MODE.Reg, volatile.LoadUint32(&o.MODE.Reg)&^(0x10)|value<<4)
}
func (o *FTM_Type) GetMODE_CAPTEST() uint32 {
	return (volatile.LoadUint32(&o.MODE.Reg) & 0x10) >> 4
}
func (o *FTM_Type) SetMODE_FAULTM(value uint32) {
	volatile.StoreUint32(&o.MODE.Reg, volatile.LoadUint32(&o.MODE.Reg)&^(0x60)|value<<5)
}
func (o *FTM_Type) GetMODE_FAULTM() uint32 {
	return (volatile.LoadUint32(&o.MODE.Reg) & 0x60) >> 5
}
func (o *FTM_Type) SetMODE_FAULTIE(value uint32) {
	volatile.StoreUint32(&o.MODE.Reg, volatile.LoadUint32(&o.MODE.Reg)&^(0x80)|value<<7)
}
func (o *FTM_Type) GetMODE_FAULTIE() uint32 {
	return (volatile.LoadUint32(&o.MODE.Reg) & 0x80) >> 7
}

// FTM.SYNC: Synchronization
func (o *FTM_Type) SetSYNC_CNTMIN(value uint32) {
	volatile.StoreUint32(&o.SYNC.Reg, volatile.LoadUint32(&o.SYNC.Reg)&^(0x1)|value)
}
func (o *FTM_Type) GetSYNC_CNTMIN() uint32 {
	return volatile.LoadUint32(&o.SYNC.Reg) & 0x1
}
func (o *FTM_Type) SetSYNC_CNTMAX(value uint32) {
	volatile.StoreUint32(&o.SYNC.Reg, volatile.LoadUint32(&o.SYNC.Reg)&^(0x2)|value<<1)
}
func (o *FTM_Type) GetSYNC_CNTMAX() uint32 {
	return (volatile.LoadUint32(&o.SYNC.Reg) & 0x2) >> 1
}
func (o *FTM_Type) SetSYNC_REINIT(value uint32) {
	volatile.StoreUint32(&o.SYNC.Reg, volatile.LoadUint32(&o.SYNC.Reg)&^(0x4)|value<<2)
}
func (o *FTM_Type) GetSYNC_REINIT() uint32 {
	return (volatile.LoadUint32(&o.SYNC.Reg) & 0x4) >> 2
}
func (o *FTM_Type) SetSYNC_SYNCHOM(value uint32) {
	volatile.StoreUint32(&o.SYNC.Reg, volatile.LoadUint32(&o.SYNC.Reg)&^(0x8)|value<<3)
}
func (o *FTM_Type) GetSYNC_SYNCHOM() uint32 {
	return (volatile.LoadUint32(&o.SYNC.Reg) & 0x8) >> 3
}
func (o *FTM_Type) SetSYNC_TRIG0(value uint32) {
	volatile.StoreUint32(&o.SYNC.Reg, volatile.LoadUint32(&o.SYNC.Reg)&^(0x10)|value<<4)
}
func (o *FTM_Type) GetSYNC_TRIG0() uint32 {
	return (volatile.LoadUint32(&o.SYNC.Reg) & 0x10) >> 4
}
func (o *FTM_Type) SetSYNC_TRIG1(value uint32) {
	volatile.StoreUint32(&o.SYNC.Reg, volatile.LoadUint32(&o.SYNC.Reg)&^(0x20)|value<<5)
}
func (o *FTM_Type) GetSYNC_TRIG1() uint32 {
	return (volatile.LoadUint32(&o.SYNC.Reg) & 0x20) >> 5
}
func (o *FTM_Type) SetSYNC_TRIG2(value uint32) {
	volatile.StoreUint32(&o.SYNC.Reg, volatile.LoadUint32(&o.SYNC.Reg)&^(0x40)|value<<6)
}
func (o *FTM_Type) GetSYNC_TRIG2() uint32 {
	return (volatile.LoadUint32(&o.SYNC.Reg) & 0x40) >> 6
}
func (o *FTM_Type) SetSYNC_SWSYNC(value uint32) {
	volatile.StoreUint32(&o.SYNC.Reg, volatile.LoadUint32(&o.SYNC.Reg)&^(0x80)|value<<7)
}
func (o *FTM_Type) GetSYNC_SWSYNC() uint32 {
	return (volatile.LoadUint32(&o.SYNC.Reg) & 0x80) >> 7
}

// FTM.OUTINIT: Initial State For Channels Output
func (o *FTM_Type) SetOUTINIT_CH0OI(value uint32) {
	volatile.StoreUint32(&o.OUTINIT.Reg, volatile.LoadUint32(&o.OUTINIT.Reg)&^(0x1)|value)
}
func (o *FTM_Type) GetOUTINIT_CH0OI() uint32 {
	return volatile.LoadUint32(&o.OUTINIT.Reg) & 0x1
}
func (o *FTM_Type) SetOUTINIT_CH1OI(value uint32) {
	volatile.StoreUint32(&o.OUTINIT.Reg, volatile.LoadUint32(&o.OUTINIT.Reg)&^(0x2)|value<<1)
}
func (o *FTM_Type) GetOUTINIT_CH1OI() uint32 {
	return (volatile.LoadUint32(&o.OUTINIT.Reg) & 0x2) >> 1
}
func (o *FTM_Type) SetOUTINIT_CH2OI(value uint32) {
	volatile.StoreUint32(&o.OUTINIT.Reg, volatile.LoadUint32(&o.OUTINIT.Reg)&^(0x4)|value<<2)
}
func (o *FTM_Type) GetOUTINIT_CH2OI() uint32 {
	return (volatile.LoadUint32(&o.OUTINIT.Reg) & 0x4) >> 2
}
func (o *FTM_Type) SetOUTINIT_CH3OI(value uint32) {
	volatile.StoreUint32(&o.OUTINIT.Reg, volatile.LoadUint32(&o.OUTINIT.Reg)&^(0x8)|value<<3)
}
func (o *FTM_Type) GetOUTINIT_CH3OI() uint32 {
	return (volatile.LoadUint32(&o.OUTINIT.Reg) & 0x8) >> 3
}
func (o *FTM_Type) SetOUTINIT_CH4OI(value uint32) {
	volatile.StoreUint32(&o.OUTINIT.Reg, volatile.LoadUint32(&o.OUTINIT.Reg)&^(0x10)|value<<4)
}
func (o *FTM_Type) GetOUTINIT_CH4OI() uint32 {
	return (volatile.LoadUint32(&o.OUTINIT.Reg) & 0x10) >> 4
}
func (o *FTM_Type) SetOUTINIT_CH5OI(value uint32) {
	volatile.StoreUint32(&o.OUTINIT.Reg, volatile.LoadUint32(&o.OUTINIT.Reg)&^(0x20)|value<<5)
}
func (o *FTM_Type) GetOUTINIT_CH5OI() uint32 {
	return (volatile.LoadUint32(&o.OUTINIT.Reg) & 0x20) >> 5
}
func (o *FTM_Type) SetOUTINIT_CH6OI(value uint32) {
	volatile.StoreUint32(&o.OUTINIT.Reg, volatile.LoadUint32(&o.OUTINIT.Reg)&^(0x40)|value<<6)
}
func (o *FTM_Type) GetOUTINIT_CH6OI() uint32 {
	return (volatile.LoadUint32(&o.OUTINIT.Reg) & 0x40) >> 6
}
func (o *FTM_Type) SetOUTINIT_CH7OI(value uint32) {
	volatile.StoreUint32(&o.OUTINIT.Reg, volatile.LoadUint32(&o.OUTINIT.Reg)&^(0x80)|value<<7)
}
func (o *FTM_Type) GetOUTINIT_CH7OI() uint32 {
	return (volatile.LoadUint32(&o.OUTINIT.Reg) & 0x80) >> 7
}

// FTM.OUTMASK: Output Mask
func (o *FTM_Type) SetOUTMASK_CH0OM(value uint32) {
	volatile.StoreUint32(&o.OUTMASK.Reg, volatile.LoadUint32(&o.OUTMASK.Reg)&^(0x1)|value)
}
func (o *FTM_Type) GetOUTMASK_CH0OM() uint32 {
	return volatile.LoadUint32(&o.OUTMASK.Reg) & 0x1
}
func (o *FTM_Type) SetOUTMASK_CH1OM(value uint32) {
	volatile.StoreUint32(&o.OUTMASK.Reg, volatile.LoadUint32(&o.OUTMASK.Reg)&^(0x2)|value<<1)
}
func (o *FTM_Type) GetOUTMASK_CH1OM() uint32 {
	return (volatile.LoadUint32(&o.OUTMASK.Reg) & 0x2) >> 1
}
func (o *FTM_Type) SetOUTMASK_CH2OM(value uint32) {
	volatile.StoreUint32(&o.OUTMASK.Reg, volatile.LoadUint32(&o.OUTMASK.Reg)&^(0x4)|value<<2)
}
func (o *FTM_Type) GetOUTMASK_CH2OM() uint32 {
	return (volatile.LoadUint32(&o.OUTMASK.Reg) & 0x4) >> 2
}
func (o *FTM_Type) SetOUTMASK_CH3OM(value uint32) {
	volatile.StoreUint32(&o.OUTMASK.Reg, volatile.LoadUint32(&o.OUTMASK.Reg)&^(0x8)|value<<3)
}
func (o *FTM_Type) GetOUTMASK_CH3OM() uint32 {
	return (volatile.LoadUint32(&o.OUTMASK.Reg) & 0x8) >> 3
}
func (o *FTM_Type) SetOUTMASK_CH4OM(value uint32) {
	volatile.StoreUint32(&o.OUTMASK.Reg, volatile.LoadUint32(&o.OUTMASK.Reg)&^(0x10)|value<<4)
}
func (o *FTM_Type) GetOUTMASK_CH4OM() uint32 {
	return (volatile.LoadUint32(&o.OUTMASK.Reg) & 0x10) >> 4
}
func (o *FTM_Type) SetOUTMASK_CH5OM(value uint32) {
	volatile.StoreUint32(&o.OUTMASK.Reg, volatile.LoadUint32(&o.OUTMASK.Reg)&^(0x20)|value<<5)
}
func (o *FTM_Type) GetOUTMASK_CH5OM() uint32 {
	return (volatile.LoadUint32(&o.OUTMASK.Reg) & 0x20) >> 5
}
func (o *FTM_Type) SetOUTMASK_CH6OM(value uint32) {
	volatile.StoreUint32(&o.OUTMASK.Reg, volatile.LoadUint32(&o.OUTMASK.Reg)&^(0x40)|value<<6)
}
func (o *FTM_Type) GetOUTMASK_CH6OM() uint32 {
	return (volatile.LoadUint32(&o.OUTMASK.Reg) & 0x40) >> 6
}
func (o *FTM_Type) SetOUTMASK_CH7OM(value uint32) {
	volatile.StoreUint32(&o.OUTMASK.Reg, volatile.LoadUint32(&o.OUTMASK.Reg)&^(0x80)|value<<7)
}
func (o *FTM_Type) GetOUTMASK_CH7OM() uint32 {
	return (volatile.LoadUint32(&o.OUTMASK.Reg) & 0x80) >> 7
}

// FTM.COMBINE: Function For Linked Channels
func (o *FTM_Type) SetCOMBINE_COMBINE0(value uint32) {
	volatile.StoreUint32(&o.COMBINE.Reg, volatile.LoadUint32(&o.COMBINE.Reg)&^(0x1)|value)
}
func (o *FTM_Type) GetCOMBINE_COMBINE0() uint32 {
	return volatile.LoadUint32(&o.COMBINE.Reg) & 0x1
}
func (o *FTM_Type) SetCOMBINE_COMP0(value uint32) {
	volatile.StoreUint32(&o.COMBINE.Reg, volatile.LoadUint32(&o.COMBINE.Reg)&^(0x2)|value<<1)
}
func (o *FTM_Type) GetCOMBINE_COMP0() uint32 {
	return (volatile.LoadUint32(&o.COMBINE.Reg) & 0x2) >> 1
}
func (o *FTM_Type) SetCOMBINE_DECAPEN0(value uint32) {
	volatile.StoreUint32(&o.COMBINE.Reg, volatile.LoadUint32(&o.COMBINE.Reg)&^(0x4)|value<<2)
}
func (o *FTM_Type) GetCOMBINE_DECAPEN0() uint32 {
	return (volatile.LoadUint32(&o.COMBINE.Reg) & 0x4) >> 2
}
func (o *FTM_Type) SetCOMBINE_DECAP0(value uint32) {
	volatile.StoreUint32(&o.COMBINE.Reg, volatile.LoadUint32(&o.COMBINE.Reg)&^(0x8)|value<<3)
}
func (o *FTM_Type) GetCOMBINE_DECAP0() uint32 {
	return (volatile.LoadUint32(&o.COMBINE.Reg) & 0x8) >> 3
}
func (o *FTM_Type) SetCOMBINE_DTEN0(value uint32) {
	volatile.StoreUint32(&o.COMBINE.Reg, volatile.LoadUint32(&o.COMBINE.Reg)&^(0x10)|value<<4)
}
func (o *FTM_Type) GetCOMBINE_DTEN0() uint32 {
	return (volatile.LoadUint32(&o.COMBINE.Reg) & 0x10) >> 4
}
func (o *FTM_Type) SetCOMBINE_SYNCEN0(value uint32) {
	volatile.StoreUint32(&o.COMBINE.Reg, volatile.LoadUint32(&o.COMBINE.Reg)&^(0x20)|value<<5)
}
func (o *FTM_Type) GetCOMBINE_SYNCEN0() uint32 {
	return (volatile.LoadUint32(&o.COMBINE.Reg) & 0x20) >> 5
}
func (o *FTM_Type) SetCOMBINE_FAULTEN0(value uint32) {
	volatile.StoreUint32(&o.COMBINE.Reg, volatile.LoadUint32(&o.COMBINE.Reg)&^(0x40)|value<<6)
}
func (o *FTM_Type) GetCOMBINE_FAULTEN0() uint32 {
	return (volatile.LoadUint32(&o.COMBINE.Reg) & 0x40) >> 6
}
func (o *FTM_Type) SetCOMBINE_COMBINE1(value uint32) {
	volatile.StoreUint32(&o.COMBINE.Reg, volatile.LoadUint32(&o.COMBINE.Reg)&^(0x100)|value<<8)
}
func (o *FTM_Type) GetCOMBINE_COMBINE1() uint32 {
	return (volatile.LoadUint32(&o.COMBINE.Reg) & 0x100) >> 8
}
func (o *FTM_Type) SetCOMBINE_COMP1(value uint32) {
	volatile.StoreUint32(&o.COMBINE.Reg, volatile.LoadUint32(&o.COMBINE.Reg)&^(0x200)|value<<9)
}
func (o *FTM_Type) GetCOMBINE_COMP1() uint32 {
	return (volatile.LoadUint32(&o.COMBINE.Reg) & 0x200) >> 9
}
func (o *FTM_Type) SetCOMBINE_DECAPEN1(value uint32) {
	volatile.StoreUint32(&o.COMBINE.Reg, volatile.LoadUint32(&o.COMBINE.Reg)&^(0x400)|value<<10)
}
func (o *FTM_Type) GetCOMBINE_DECAPEN1() uint32 {
	return (volatile.LoadUint32(&o.COMBINE.Reg) & 0x400) >> 10
}
func (o *FTM_Type) SetCOMBINE_DECAP1(value uint32) {
	volatile.StoreUint32(&o.COMBINE.Reg, volatile.LoadUint32(&o.COMBINE.Reg)&^(0x800)|value<<11)
}
func (o *FTM_Type) GetCOMBINE_DECAP1() uint32 {
	return (volatile.LoadUint32(&o.COMBINE.Reg) & 0x800) >> 11
}
func (o *FTM_Type) SetCOMBINE_DTEN1(value uint32) {
	volatile.StoreUint32(&o.COMBINE.Reg, volatile.LoadUint32(&o.COMBINE.Reg)&^(0x1000)|value<<12)
}
func (o *FTM_Type) GetCOMBINE_DTEN1() uint32 {
	return (volatile.LoadUint32(&o.COMBINE.Reg) & 0x1000) >> 12
}
func (o *FTM_Type) SetCOMBINE_SYNCEN1(value uint32) {
	volatile.StoreUint32(&o.COMBINE.Reg, volatile.LoadUint32(&o.COMBINE.Reg)&^(0x2000)|value<<13)
}
func (o *FTM_Type) GetCOMBINE_SYNCEN1() uint32 {
	return (volatile.LoadUint32(&o.COMBINE.Reg) & 0x2000) >> 13
}
func (o *FTM_Type) SetCOMBINE_FAULTEN1(value uint32) {
	volatile.StoreUint32(&o.COMBINE.Reg, volatile.LoadUint32(&o.COMBINE.Reg)&^(0x4000)|value<<14)
}
func (o *FTM_Type) GetCOMBINE_FAULTEN1() uint32 {
	return (volatile.LoadUint32(&o.COMBINE.Reg) & 0x4000) >> 14
}
func (o *FTM_Type) SetCOMBINE_COMBINE2(value uint32) {
	volatile.StoreUint32(&o.COMBINE.Reg, volatile.LoadUint32(&o.COMBINE.Reg)&^(0x10000)|value<<16)
}
func (o *FTM_Type) GetCOMBINE_COMBINE2() uint32 {
	return (volatile.LoadUint32(&o.COMBINE.Reg) & 0x10000) >> 16
}
func (o *FTM_Type) SetCOMBINE_COMP2(value uint32) {
	volatile.StoreUint32(&o.COMBINE.Reg, volatile.LoadUint32(&o.COMBINE.Reg)&^(0x20000)|value<<17)
}
func (o *FTM_Type) GetCOMBINE_COMP2() uint32 {
	return (volatile.LoadUint32(&o.COMBINE.Reg) & 0x20000) >> 17
}
func (o *FTM_Type) SetCOMBINE_DECAPEN2(value uint32) {
	volatile.StoreUint32(&o.COMBINE.Reg, volatile.LoadUint32(&o.COMBINE.Reg)&^(0x40000)|value<<18)
}
func (o *FTM_Type) GetCOMBINE_DECAPEN2() uint32 {
	return (volatile.LoadUint32(&o.COMBINE.Reg) & 0x40000) >> 18
}
func (o *FTM_Type) SetCOMBINE_DECAP2(value uint32) {
	volatile.StoreUint32(&o.COMBINE.Reg, volatile.LoadUint32(&o.COMBINE.Reg)&^(0x80000)|value<<19)
}
func (o *FTM_Type) GetCOMBINE_DECAP2() uint32 {
	return (volatile.LoadUint32(&o.COMBINE.Reg) & 0x80000) >> 19
}
func (o *FTM_Type) SetCOMBINE_DTEN2(value uint32) {
	volatile.StoreUint32(&o.COMBINE.Reg, volatile.LoadUint32(&o.COMBINE.Reg)&^(0x100000)|value<<20)
}
func (o *FTM_Type) GetCOMBINE_DTEN2() uint32 {
	return (volatile.LoadUint32(&o.COMBINE.Reg) & 0x100000) >> 20
}
func (o *FTM_Type) SetCOMBINE_SYNCEN2(value uint32) {
	volatile.StoreUint32(&o.COMBINE.Reg, volatile.LoadUint32(&o.COMBINE.Reg)&^(0x200000)|value<<21)
}
func (o *FTM_Type) GetCOMBINE_SYNCEN2() uint32 {
	return (volatile.LoadUint32(&o.COMBINE.Reg) & 0x200000) >> 21
}
func (o *FTM_Type) SetCOMBINE_FAULTEN2(value uint32) {
	volatile.StoreUint32(&o.COMBINE.Reg, volatile.LoadUint32(&o.COMBINE.Reg)&^(0x400000)|value<<22)
}
func (o *FTM_Type) GetCOMBINE_FAULTEN2() uint32 {
	return (volatile.LoadUint32(&o.COMBINE.Reg) & 0x400000) >> 22
}
func (o *FTM_Type) SetCOMBINE_COMBINE3(value uint32) {
	volatile.StoreUint32(&o.COMBINE.Reg, volatile.LoadUint32(&o.COMBINE.Reg)&^(0x1000000)|value<<24)
}
func (o *FTM_Type) GetCOMBINE_COMBINE3() uint32 {
	return (volatile.LoadUint32(&o.COMBINE.Reg) & 0x1000000) >> 24
}
func (o *FTM_Type) SetCOMBINE_COMP3(value uint32) {
	volatile.StoreUint32(&o.COMBINE.Reg, volatile.LoadUint32(&o.COMBINE.Reg)&^(0x2000000)|value<<25)
}
func (o *FTM_Type) GetCOMBINE_COMP3() uint32 {
	return (volatile.LoadUint32(&o.COMBINE.Reg) & 0x2000000) >> 25
}
func (o *FTM_Type) SetCOMBINE_DECAPEN3(value uint32) {
	volatile.StoreUint32(&o.COMBINE.Reg, volatile.LoadUint32(&o.COMBINE.Reg)&^(0x4000000)|value<<26)
}
func (o *FTM_Type) GetCOMBINE_DECAPEN3() uint32 {
	return (volatile.LoadUint32(&o.COMBINE.Reg) & 0x4000000) >> 26
}
func (o *FTM_Type) SetCOMBINE_DECAP3(value uint32) {
	volatile.StoreUint32(&o.COMBINE.Reg, volatile.LoadUint32(&o.COMBINE.Reg)&^(0x8000000)|value<<27)
}
func (o *FTM_Type) GetCOMBINE_DECAP3() uint32 {
	return (volatile.LoadUint32(&o.COMBINE.Reg) & 0x8000000) >> 27
}
func (o *FTM_Type) SetCOMBINE_DTEN3(value uint32) {
	volatile.StoreUint32(&o.COMBINE.Reg, volatile.LoadUint32(&o.COMBINE.Reg)&^(0x10000000)|value<<28)
}
func (o *FTM_Type) GetCOMBINE_DTEN3() uint32 {
	return (volatile.LoadUint32(&o.COMBINE.Reg) & 0x10000000) >> 28
}
func (o *FTM_Type) SetCOMBINE_SYNCEN3(value uint32) {
	volatile.StoreUint32(&o.COMBINE.Reg, volatile.LoadUint32(&o.COMBINE.Reg)&^(0x20000000)|value<<29)
}
func (o *FTM_Type) GetCOMBINE_SYNCEN3() uint32 {
	return (volatile.LoadUint32(&o.COMBINE.Reg) & 0x20000000) >> 29
}
func (o *FTM_Type) SetCOMBINE_FAULTEN3(value uint32) {
	volatile.StoreUint32(&o.COMBINE.Reg, volatile.LoadUint32(&o.COMBINE.Reg)&^(0x40000000)|value<<30)
}
func (o *FTM_Type) GetCOMBINE_FAULTEN3() uint32 {
	return (volatile.LoadUint32(&o.COMBINE.Reg) & 0x40000000) >> 30
}

// FTM.DEADTIME: Deadtime Insertion Control
func (o *FTM_Type) SetDEADTIME_DTVAL(value uint32) {
	volatile.StoreUint32(&o.DEADTIME.Reg, volatile.LoadUint32(&o.DEADTIME.Reg)&^(0x3f)|value)
}
func (o *FTM_Type) GetDEADTIME_DTVAL() uint32 {
	return volatile.LoadUint32(&o.DEADTIME.Reg) & 0x3f
}
func (o *FTM_Type) SetDEADTIME_DTPS(value uint32) {
	volatile.StoreUint32(&o.DEADTIME.Reg, volatile.LoadUint32(&o.DEADTIME.Reg)&^(0xc0)|value<<6)
}
func (o *FTM_Type) GetDEADTIME_DTPS() uint32 {
	return (volatile.LoadUint32(&o.DEADTIME.Reg) & 0xc0) >> 6
}

// FTM.EXTTRIG: FTM External Trigger
func (o *FTM_Type) SetEXTTRIG_CH2TRIG(value uint32) {
	volatile.StoreUint32(&o.EXTTRIG.Reg, volatile.LoadUint32(&o.EXTTRIG.Reg)&^(0x1)|value)
}
func (o *FTM_Type) GetEXTTRIG_CH2TRIG() uint32 {
	return volatile.LoadUint32(&o.EXTTRIG.Reg) & 0x1
}
func (o *FTM_Type) SetEXTTRIG_CH3TRIG(value uint32) {
	volatile.StoreUint32(&o.EXTTRIG.Reg, volatile.LoadUint32(&o.EXTTRIG.Reg)&^(0x2)|value<<1)
}
func (o *FTM_Type) GetEXTTRIG_CH3TRIG() uint32 {
	return (volatile.LoadUint32(&o.EXTTRIG.Reg) & 0x2) >> 1
}
func (o *FTM_Type) SetEXTTRIG_CH4TRIG(value uint32) {
	volatile.StoreUint32(&o.EXTTRIG.Reg, volatile.LoadUint32(&o.EXTTRIG.Reg)&^(0x4)|value<<2)
}
func (o *FTM_Type) GetEXTTRIG_CH4TRIG() uint32 {
	return (volatile.LoadUint32(&o.EXTTRIG.Reg) & 0x4) >> 2
}
func (o *FTM_Type) SetEXTTRIG_CH5TRIG(value uint32) {
	volatile.StoreUint32(&o.EXTTRIG.Reg, volatile.LoadUint32(&o.EXTTRIG.Reg)&^(0x8)|value<<3)
}
func (o *FTM_Type) GetEXTTRIG_CH5TRIG() uint32 {
	return (volatile.LoadUint32(&o.EXTTRIG.Reg) & 0x8) >> 3
}
func (o *FTM_Type) SetEXTTRIG_CH0TRIG(value uint32) {
	volatile.StoreUint32(&o.EXTTRIG.Reg, volatile.LoadUint32(&o.EXTTRIG.Reg)&^(0x10)|value<<4)
}
func (o *FTM_Type) GetEXTTRIG_CH0TRIG() uint32 {
	return (volatile.LoadUint32(&o.EXTTRIG.Reg) & 0x10) >> 4
}
func (o *FTM_Type) SetEXTTRIG_CH1TRIG(value uint32) {
	volatile.StoreUint32(&o.EXTTRIG.Reg, volatile.LoadUint32(&o.EXTTRIG.Reg)&^(0x20)|value<<5)
}
func (o *FTM_Type) GetEXTTRIG_CH1TRIG() uint32 {
	return (volatile.LoadUint32(&o.EXTTRIG.Reg) & 0x20) >> 5
}
func (o *FTM_Type) SetEXTTRIG_INITTRIGEN(value uint32) {
	volatile.StoreUint32(&o.EXTTRIG.Reg, volatile.LoadUint32(&o.EXTTRIG.Reg)&^(0x40)|value<<6)
}
func (o *FTM_Type) GetEXTTRIG_INITTRIGEN() uint32 {
	return (volatile.LoadUint32(&o.EXTTRIG.Reg) & 0x40) >> 6
}
func (o *FTM_Type) SetEXTTRIG_TRIGF(value uint32) {
	volatile.StoreUint32(&o.EXTTRIG.Reg, volatile.LoadUint32(&o.EXTTRIG.Reg)&^(0x80)|value<<7)
}
func (o *FTM_Type) GetEXTTRIG_TRIGF() uint32 {
	return (volatile.LoadUint32(&o.EXTTRIG.Reg) & 0x80) >> 7
}

// FTM.POL: Channels Polarity
func (o *FTM_Type) SetPOL_POL0(value uint32) {
	volatile.StoreUint32(&o.POL.Reg, volatile.LoadUint32(&o.POL.Reg)&^(0x1)|value)
}
func (o *FTM_Type) GetPOL_POL0() uint32 {
	return volatile.LoadUint32(&o.POL.Reg) & 0x1
}
func (o *FTM_Type) SetPOL_POL1(value uint32) {
	volatile.StoreUint32(&o.POL.Reg, volatile.LoadUint32(&o.POL.Reg)&^(0x2)|value<<1)
}
func (o *FTM_Type) GetPOL_POL1() uint32 {
	return (volatile.LoadUint32(&o.POL.Reg) & 0x2) >> 1
}
func (o *FTM_Type) SetPOL_POL2(value uint32) {
	volatile.StoreUint32(&o.POL.Reg, volatile.LoadUint32(&o.POL.Reg)&^(0x4)|value<<2)
}
func (o *FTM_Type) GetPOL_POL2() uint32 {
	return (volatile.LoadUint32(&o.POL.Reg) & 0x4) >> 2
}
func (o *FTM_Type) SetPOL_POL3(value uint32) {
	volatile.StoreUint32(&o.POL.Reg, volatile.LoadUint32(&o.POL.Reg)&^(0x8)|value<<3)
}
func (o *FTM_Type) GetPOL_POL3() uint32 {
	return (volatile.LoadUint32(&o.POL.Reg) & 0x8) >> 3
}
func (o *FTM_Type) SetPOL_POL4(value uint32) {
	volatile.StoreUint32(&o.POL.Reg, volatile.LoadUint32(&o.POL.Reg)&^(0x10)|value<<4)
}
func (o *FTM_Type) GetPOL_POL4() uint32 {
	return (volatile.LoadUint32(&o.POL.Reg) & 0x10) >> 4
}
func (o *FTM_Type) SetPOL_POL5(value uint32) {
	volatile.StoreUint32(&o.POL.Reg, volatile.LoadUint32(&o.POL.Reg)&^(0x20)|value<<5)
}
func (o *FTM_Type) GetPOL_POL5() uint32 {
	return (volatile.LoadUint32(&o.POL.Reg) & 0x20) >> 5
}
func (o *FTM_Type) SetPOL_POL6(value uint32) {
	volatile.StoreUint32(&o.POL.Reg, volatile.LoadUint32(&o.POL.Reg)&^(0x40)|value<<6)
}
func (o *FTM_Type) GetPOL_POL6() uint32 {
	return (volatile.LoadUint32(&o.POL.Reg) & 0x40) >> 6
}
func (o *FTM_Type) SetPOL_POL7(value uint32) {
	volatile.StoreUint32(&o.POL.Reg, volatile.LoadUint32(&o.POL.Reg)&^(0x80)|value<<7)
}
func (o *FTM_Type) GetPOL_POL7() uint32 {
	return (volatile.LoadUint32(&o.POL.Reg) & 0x80) >> 7
}

// FTM.FMS: Fault Mode Status
func (o *FTM_Type) SetFMS_FAULTF0(value uint32) {
	volatile.StoreUint32(&o.FMS.Reg, volatile.LoadUint32(&o.FMS.Reg)&^(0x1)|value)
}
func (o *FTM_Type) GetFMS_FAULTF0() uint32 {
	return volatile.LoadUint32(&o.FMS.Reg) & 0x1
}
func (o *FTM_Type) SetFMS_FAULTF1(value uint32) {
	volatile.StoreUint32(&o.FMS.Reg, volatile.LoadUint32(&o.FMS.Reg)&^(0x2)|value<<1)
}
func (o *FTM_Type) GetFMS_FAULTF1() uint32 {
	return (volatile.LoadUint32(&o.FMS.Reg) & 0x2) >> 1
}
func (o *FTM_Type) SetFMS_FAULTF2(value uint32) {
	volatile.StoreUint32(&o.FMS.Reg, volatile.LoadUint32(&o.FMS.Reg)&^(0x4)|value<<2)
}
func (o *FTM_Type) GetFMS_FAULTF2() uint32 {
	return (volatile.LoadUint32(&o.FMS.Reg) & 0x4) >> 2
}
func (o *FTM_Type) SetFMS_FAULTF3(value uint32) {
	volatile.StoreUint32(&o.FMS.Reg, volatile.LoadUint32(&o.FMS.Reg)&^(0x8)|value<<3)
}
func (o *FTM_Type) GetFMS_FAULTF3() uint32 {
	return (volatile.LoadUint32(&o.FMS.Reg) & 0x8) >> 3
}
func (o *FTM_Type) SetFMS_FAULTIN(value uint32) {
	volatile.StoreUint32(&o.FMS.Reg, volatile.LoadUint32(&o.FMS.Reg)&^(0x20)|value<<5)
}
func (o *FTM_Type) GetFMS_FAULTIN() uint32 {
	return (volatile.LoadUint32(&o.FMS.Reg) & 0x20) >> 5
}
func (o *FTM_Type) SetFMS_WPEN(value uint32) {
	volatile.StoreUint32(&o.FMS.Reg, volatile.LoadUint32(&o.FMS.Reg)&^(0x40)|value<<6)
}
func (o *FTM_Type) GetFMS_WPEN() uint32 {
	return (volatile.LoadUint32(&o.FMS.Reg) & 0x40) >> 6
}
func (o *FTM_Type) SetFMS_FAULTF(value uint32) {
	volatile.StoreUint32(&o.FMS.Reg, volatile.LoadUint32(&o.FMS.Reg)&^(0x80)|value<<7)
}
func (o *FTM_Type) GetFMS_FAULTF() uint32 {
	return (volatile.LoadUint32(&o.FMS.Reg) & 0x80) >> 7
}

// FTM.FILTER: Input Capture Filter Control
func (o *FTM_Type) SetFILTER_CH0FVAL(value uint32) {
	volatile.StoreUint32(&o.FILTER.Reg, volatile.LoadUint32(&o.FILTER.Reg)&^(0xf)|value)
}
func (o *FTM_Type) GetFILTER_CH0FVAL() uint32 {
	return volatile.LoadUint32(&o.FILTER.Reg) & 0xf
}
func (o *FTM_Type) SetFILTER_CH1FVAL(value uint32) {
	volatile.StoreUint32(&o.FILTER.Reg, volatile.LoadUint32(&o.FILTER.Reg)&^(0xf0)|value<<4)
}
func (o *FTM_Type) GetFILTER_CH1FVAL() uint32 {
	return (volatile.LoadUint32(&o.FILTER.Reg) & 0xf0) >> 4
}
func (o *FTM_Type) SetFILTER_CH2FVAL(value uint32) {
	volatile.StoreUint32(&o.FILTER.Reg, volatile.LoadUint32(&o.FILTER.Reg)&^(0xf00)|value<<8)
}
func (o *FTM_Type) GetFILTER_CH2FVAL() uint32 {
	return (volatile.LoadUint32(&o.FILTER.Reg) & 0xf00) >> 8
}
func (o *FTM_Type) SetFILTER_CH3FVAL(value uint32) {
	volatile.StoreUint32(&o.FILTER.Reg, volatile.LoadUint32(&o.FILTER.Reg)&^(0xf000)|value<<12)
}
func (o *FTM_Type) GetFILTER_CH3FVAL() uint32 {
	return (volatile.LoadUint32(&o.FILTER.Reg) & 0xf000) >> 12
}

// FTM.FLTCTRL: Fault Control
func (o *FTM_Type) SetFLTCTRL_FAULT0EN(value uint32) {
	volatile.StoreUint32(&o.FLTCTRL.Reg, volatile.LoadUint32(&o.FLTCTRL.Reg)&^(0x1)|value)
}
func (o *FTM_Type) GetFLTCTRL_FAULT0EN() uint32 {
	return volatile.LoadUint32(&o.FLTCTRL.Reg) & 0x1
}
func (o *FTM_Type) SetFLTCTRL_FAULT1EN(value uint32) {
	volatile.StoreUint32(&o.FLTCTRL.Reg, volatile.LoadUint32(&o.FLTCTRL.Reg)&^(0x2)|value<<1)
}
func (o *FTM_Type) GetFLTCTRL_FAULT1EN() uint32 {
	return (volatile.LoadUint32(&o.FLTCTRL.Reg) & 0x2) >> 1
}
func (o *FTM_Type) SetFLTCTRL_FAULT2EN(value uint32) {
	volatile.StoreUint32(&o.FLTCTRL.Reg, volatile.LoadUint32(&o.FLTCTRL.Reg)&^(0x4)|value<<2)
}
func (o *FTM_Type) GetFLTCTRL_FAULT2EN() uint32 {
	return (volatile.LoadUint32(&o.FLTCTRL.Reg) & 0x4) >> 2
}
func (o *FTM_Type) SetFLTCTRL_FAULT3EN(value uint32) {
	volatile.StoreUint32(&o.FLTCTRL.Reg, volatile.LoadUint32(&o.FLTCTRL.Reg)&^(0x8)|value<<3)
}
func (o *FTM_Type) GetFLTCTRL_FAULT3EN() uint32 {
	return (volatile.LoadUint32(&o.FLTCTRL.Reg) & 0x8) >> 3
}
func (o *FTM_Type) SetFLTCTRL_FFLTR0EN(value uint32) {
	volatile.StoreUint32(&o.FLTCTRL.Reg, volatile.LoadUint32(&o.FLTCTRL.Reg)&^(0x10)|value<<4)
}
func (o *FTM_Type) GetFLTCTRL_FFLTR0EN() uint32 {
	return (volatile.LoadUint32(&o.FLTCTRL.Reg) & 0x10) >> 4
}
func (o *FTM_Type) SetFLTCTRL_FFLTR1EN(value uint32) {
	volatile.StoreUint32(&o.FLTCTRL.Reg, volatile.LoadUint32(&o.FLTCTRL.Reg)&^(0x20)|value<<5)
}
func (o *FTM_Type) GetFLTCTRL_FFLTR1EN() uint32 {
	return (volatile.LoadUint32(&o.FLTCTRL.Reg) & 0x20) >> 5
}
func (o *FTM_Type) SetFLTCTRL_FFLTR2EN(value uint32) {
	volatile.StoreUint32(&o.FLTCTRL.Reg, volatile.LoadUint32(&o.FLTCTRL.Reg)&^(0x40)|value<<6)
}
func (o *FTM_Type) GetFLTCTRL_FFLTR2EN() uint32 {
	return (volatile.LoadUint32(&o.FLTCTRL.Reg) & 0x40) >> 6
}
func (o *FTM_Type) SetFLTCTRL_FFLTR3EN(value uint32) {
	volatile.StoreUint32(&o.FLTCTRL.Reg, volatile.LoadUint32(&o.FLTCTRL.Reg)&^(0x80)|value<<7)
}
func (o *FTM_Type) GetFLTCTRL_FFLTR3EN() uint32 {
	return (volatile.LoadUint32(&o.FLTCTRL.Reg) & 0x80) >> 7
}
func (o *FTM_Type) SetFLTCTRL_FFVAL(value uint32) {
	volatile.StoreUint32(&o.FLTCTRL.Reg, volatile.LoadUint32(&o.FLTCTRL.Reg)&^(0xf00)|value<<8)
}
func (o *FTM_Type) GetFLTCTRL_FFVAL() uint32 {
	return (volatile.LoadUint32(&o.FLTCTRL.Reg) & 0xf00) >> 8
}

// FTM.QDCTRL: Quadrature Decoder Control And Status
func (o *FTM_Type) SetQDCTRL_QUADEN(value uint32) {
	volatile.StoreUint32(&o.QDCTRL.Reg, volatile.LoadUint32(&o.QDCTRL.Reg)&^(0x1)|value)
}
func (o *FTM_Type) GetQDCTRL_QUADEN() uint32 {
	return volatile.LoadUint32(&o.QDCTRL.Reg) & 0x1
}
func (o *FTM_Type) SetQDCTRL_TOFDIR(value uint32) {
	volatile.StoreUint32(&o.QDCTRL.Reg, volatile.LoadUint32(&o.QDCTRL.Reg)&^(0x2)|value<<1)
}
func (o *FTM_Type) GetQDCTRL_TOFDIR() uint32 {
	return (volatile.LoadUint32(&o.QDCTRL.Reg) & 0x2) >> 1
}
func (o *FTM_Type) SetQDCTRL_QUADIR(value uint32) {
	volatile.StoreUint32(&o.QDCTRL.Reg, volatile.LoadUint32(&o.QDCTRL.Reg)&^(0x4)|value<<2)
}
func (o *FTM_Type) GetQDCTRL_QUADIR() uint32 {
	return (volatile.LoadUint32(&o.QDCTRL.Reg) & 0x4) >> 2
}
func (o *FTM_Type) SetQDCTRL_QUADMODE(value uint32) {
	volatile.StoreUint32(&o.QDCTRL.Reg, volatile.LoadUint32(&o.QDCTRL.Reg)&^(0x8)|value<<3)
}
func (o *FTM_Type) GetQDCTRL_QUADMODE() uint32 {
	return (volatile.LoadUint32(&o.QDCTRL.Reg) & 0x8) >> 3
}
func (o *FTM_Type) SetQDCTRL_PHBPOL(value uint32) {
	volatile.StoreUint32(&o.QDCTRL.Reg, volatile.LoadUint32(&o.QDCTRL.Reg)&^(0x10)|value<<4)
}
func (o *FTM_Type) GetQDCTRL_PHBPOL() uint32 {
	return (volatile.LoadUint32(&o.QDCTRL.Reg) & 0x10) >> 4
}
func (o *FTM_Type) SetQDCTRL_PHAPOL(value uint32) {
	volatile.StoreUint32(&o.QDCTRL.Reg, volatile.LoadUint32(&o.QDCTRL.Reg)&^(0x20)|value<<5)
}
func (o *FTM_Type) GetQDCTRL_PHAPOL() uint32 {
	return (volatile.LoadUint32(&o.QDCTRL.Reg) & 0x20) >> 5
}
func (o *FTM_Type) SetQDCTRL_PHBFLTREN(value uint32) {
	volatile.StoreUint32(&o.QDCTRL.Reg, volatile.LoadUint32(&o.QDCTRL.Reg)&^(0x40)|value<<6)
}
func (o *FTM_Type) GetQDCTRL_PHBFLTREN() uint32 {
	return (volatile.LoadUint32(&o.QDCTRL.Reg) & 0x40) >> 6
}
func (o *FTM_Type) SetQDCTRL_PHAFLTREN(value uint32) {
	volatile.StoreUint32(&o.QDCTRL.Reg, volatile.LoadUint32(&o.QDCTRL.Reg)&^(0x80)|value<<7)
}
func (o *FTM_Type) GetQDCTRL_PHAFLTREN() uint32 {
	return (volatile.LoadUint32(&o.QDCTRL.Reg) & 0x80) >> 7
}

// FTM.CONF: Configuration
func (o *FTM_Type) SetCONF_NUMTOF(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x1f)|value)
}
func (o *FTM_Type) GetCONF_NUMTOF() uint32 {
	return volatile.LoadUint32(&o.CONF.Reg) & 0x1f
}
func (o *FTM_Type) SetCONF_BDMMODE(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0xc0)|value<<6)
}
func (o *FTM_Type) GetCONF_BDMMODE() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0xc0) >> 6
}
func (o *FTM_Type) SetCONF_GTBEEN(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x200)|value<<9)
}
func (o *FTM_Type) GetCONF_GTBEEN() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x200) >> 9
}
func (o *FTM_Type) SetCONF_GTBEOUT(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x400)|value<<10)
}
func (o *FTM_Type) GetCONF_GTBEOUT() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x400) >> 10
}

// FTM.FLTPOL: FTM Fault Input Polarity
func (o *FTM_Type) SetFLTPOL_FLT0POL(value uint32) {
	volatile.StoreUint32(&o.FLTPOL.Reg, volatile.LoadUint32(&o.FLTPOL.Reg)&^(0x1)|value)
}
func (o *FTM_Type) GetFLTPOL_FLT0POL() uint32 {
	return volatile.LoadUint32(&o.FLTPOL.Reg) & 0x1
}
func (o *FTM_Type) SetFLTPOL_FLT1POL(value uint32) {
	volatile.StoreUint32(&o.FLTPOL.Reg, volatile.LoadUint32(&o.FLTPOL.Reg)&^(0x2)|value<<1)
}
func (o *FTM_Type) GetFLTPOL_FLT1POL() uint32 {
	return (volatile.LoadUint32(&o.FLTPOL.Reg) & 0x2) >> 1
}
func (o *FTM_Type) SetFLTPOL_FLT2POL(value uint32) {
	volatile.StoreUint32(&o.FLTPOL.Reg, volatile.LoadUint32(&o.FLTPOL.Reg)&^(0x4)|value<<2)
}
func (o *FTM_Type) GetFLTPOL_FLT2POL() uint32 {
	return (volatile.LoadUint32(&o.FLTPOL.Reg) & 0x4) >> 2
}
func (o *FTM_Type) SetFLTPOL_FLT3POL(value uint32) {
	volatile.StoreUint32(&o.FLTPOL.Reg, volatile.LoadUint32(&o.FLTPOL.Reg)&^(0x8)|value<<3)
}
func (o *FTM_Type) GetFLTPOL_FLT3POL() uint32 {
	return (volatile.LoadUint32(&o.FLTPOL.Reg) & 0x8) >> 3
}

// FTM.SYNCONF: Synchronization Configuration
func (o *FTM_Type) SetSYNCONF_HWTRIGMODE(value uint32) {
	volatile.StoreUint32(&o.SYNCONF.Reg, volatile.LoadUint32(&o.SYNCONF.Reg)&^(0x1)|value)
}
func (o *FTM_Type) GetSYNCONF_HWTRIGMODE() uint32 {
	return volatile.LoadUint32(&o.SYNCONF.Reg) & 0x1
}
func (o *FTM_Type) SetSYNCONF_CNTINC(value uint32) {
	volatile.StoreUint32(&o.SYNCONF.Reg, volatile.LoadUint32(&o.SYNCONF.Reg)&^(0x4)|value<<2)
}
func (o *FTM_Type) GetSYNCONF_CNTINC() uint32 {
	return (volatile.LoadUint32(&o.SYNCONF.Reg) & 0x4) >> 2
}
func (o *FTM_Type) SetSYNCONF_INVC(value uint32) {
	volatile.StoreUint32(&o.SYNCONF.Reg, volatile.LoadUint32(&o.SYNCONF.Reg)&^(0x10)|value<<4)
}
func (o *FTM_Type) GetSYNCONF_INVC() uint32 {
	return (volatile.LoadUint32(&o.SYNCONF.Reg) & 0x10) >> 4
}
func (o *FTM_Type) SetSYNCONF_SWOC(value uint32) {
	volatile.StoreUint32(&o.SYNCONF.Reg, volatile.LoadUint32(&o.SYNCONF.Reg)&^(0x20)|value<<5)
}
func (o *FTM_Type) GetSYNCONF_SWOC() uint32 {
	return (volatile.LoadUint32(&o.SYNCONF.Reg) & 0x20) >> 5
}
func (o *FTM_Type) SetSYNCONF_SYNCMODE(value uint32) {
	volatile.StoreUint32(&o.SYNCONF.Reg, volatile.LoadUint32(&o.SYNCONF.Reg)&^(0x80)|value<<7)
}
func (o *FTM_Type) GetSYNCONF_SYNCMODE() uint32 {
	return (volatile.LoadUint32(&o.SYNCONF.Reg) & 0x80) >> 7
}
func (o *FTM_Type) SetSYNCONF_SWRSTCNT(value uint32) {
	volatile.StoreUint32(&o.SYNCONF.Reg, volatile.LoadUint32(&o.SYNCONF.Reg)&^(0x100)|value<<8)
}
func (o *FTM_Type) GetSYNCONF_SWRSTCNT() uint32 {
	return (volatile.LoadUint32(&o.SYNCONF.Reg) & 0x100) >> 8
}
func (o *FTM_Type) SetSYNCONF_SWWRBUF(value uint32) {
	volatile.StoreUint32(&o.SYNCONF.Reg, volatile.LoadUint32(&o.SYNCONF.Reg)&^(0x200)|value<<9)
}
func (o *FTM_Type) GetSYNCONF_SWWRBUF() uint32 {
	return (volatile.LoadUint32(&o.SYNCONF.Reg) & 0x200) >> 9
}
func (o *FTM_Type) SetSYNCONF_SWOM(value uint32) {
	volatile.StoreUint32(&o.SYNCONF.Reg, volatile.LoadUint32(&o.SYNCONF.Reg)&^(0x400)|value<<10)
}
func (o *FTM_Type) GetSYNCONF_SWOM() uint32 {
	return (volatile.LoadUint32(&o.SYNCONF.Reg) & 0x400) >> 10
}
func (o *FTM_Type) SetSYNCONF_SWINVC(value uint32) {
	volatile.StoreUint32(&o.SYNCONF.Reg, volatile.LoadUint32(&o.SYNCONF.Reg)&^(0x800)|value<<11)
}
func (o *FTM_Type) GetSYNCONF_SWINVC() uint32 {
	return (volatile.LoadUint32(&o.SYNCONF.Reg) & 0x800) >> 11
}
func (o *FTM_Type) SetSYNCONF_SWSOC(value uint32) {
	volatile.StoreUint32(&o.SYNCONF.Reg, volatile.LoadUint32(&o.SYNCONF.Reg)&^(0x1000)|value<<12)
}
func (o *FTM_Type) GetSYNCONF_SWSOC() uint32 {
	return (volatile.LoadUint32(&o.SYNCONF.Reg) & 0x1000) >> 12
}
func (o *FTM_Type) SetSYNCONF_HWRSTCNT(value uint32) {
	volatile.StoreUint32(&o.SYNCONF.Reg, volatile.LoadUint32(&o.SYNCONF.Reg)&^(0x10000)|value<<16)
}
func (o *FTM_Type) GetSYNCONF_HWRSTCNT() uint32 {
	return (volatile.LoadUint32(&o.SYNCONF.Reg) & 0x10000) >> 16
}
func (o *FTM_Type) SetSYNCONF_HWWRBUF(value uint32) {
	volatile.StoreUint32(&o.SYNCONF.Reg, volatile.LoadUint32(&o.SYNCONF.Reg)&^(0x20000)|value<<17)
}
func (o *FTM_Type) GetSYNCONF_HWWRBUF() uint32 {
	return (volatile.LoadUint32(&o.SYNCONF.Reg) & 0x20000) >> 17
}
func (o *FTM_Type) SetSYNCONF_HWOM(value uint32) {
	volatile.StoreUint32(&o.SYNCONF.Reg, volatile.LoadUint32(&o.SYNCONF.Reg)&^(0x40000)|value<<18)
}
func (o *FTM_Type) GetSYNCONF_HWOM() uint32 {
	return (volatile.LoadUint32(&o.SYNCONF.Reg) & 0x40000) >> 18
}
func (o *FTM_Type) SetSYNCONF_HWINVC(value uint32) {
	volatile.StoreUint32(&o.SYNCONF.Reg, volatile.LoadUint32(&o.SYNCONF.Reg)&^(0x80000)|value<<19)
}
func (o *FTM_Type) GetSYNCONF_HWINVC() uint32 {
	return (volatile.LoadUint32(&o.SYNCONF.Reg) & 0x80000) >> 19
}
func (o *FTM_Type) SetSYNCONF_HWSOC(value uint32) {
	volatile.StoreUint32(&o.SYNCONF.Reg, volatile.LoadUint32(&o.SYNCONF.Reg)&^(0x100000)|value<<20)
}
func (o *FTM_Type) GetSYNCONF_HWSOC() uint32 {
	return (volatile.LoadUint32(&o.SYNCONF.Reg) & 0x100000) >> 20
}

// FTM.INVCTRL: FTM Inverting Control
func (o *FTM_Type) SetINVCTRL_INV0EN(value uint32) {
	volatile.StoreUint32(&o.INVCTRL.Reg, volatile.LoadUint32(&o.INVCTRL.Reg)&^(0x1)|value)
}
func (o *FTM_Type) GetINVCTRL_INV0EN() uint32 {
	return volatile.LoadUint32(&o.INVCTRL.Reg) & 0x1
}
func (o *FTM_Type) SetINVCTRL_INV1EN(value uint32) {
	volatile.StoreUint32(&o.INVCTRL.Reg, volatile.LoadUint32(&o.INVCTRL.Reg)&^(0x2)|value<<1)
}
func (o *FTM_Type) GetINVCTRL_INV1EN() uint32 {
	return (volatile.LoadUint32(&o.INVCTRL.Reg) & 0x2) >> 1
}
func (o *FTM_Type) SetINVCTRL_INV2EN(value uint32) {
	volatile.StoreUint32(&o.INVCTRL.Reg, volatile.LoadUint32(&o.INVCTRL.Reg)&^(0x4)|value<<2)
}
func (o *FTM_Type) GetINVCTRL_INV2EN() uint32 {
	return (volatile.LoadUint32(&o.INVCTRL.Reg) & 0x4) >> 2
}
func (o *FTM_Type) SetINVCTRL_INV3EN(value uint32) {
	volatile.StoreUint32(&o.INVCTRL.Reg, volatile.LoadUint32(&o.INVCTRL.Reg)&^(0x8)|value<<3)
}
func (o *FTM_Type) GetINVCTRL_INV3EN() uint32 {
	return (volatile.LoadUint32(&o.INVCTRL.Reg) & 0x8) >> 3
}

// FTM.SWOCTRL: FTM Software Output Control
func (o *FTM_Type) SetSWOCTRL_CH0OC(value uint32) {
	volatile.StoreUint32(&o.SWOCTRL.Reg, volatile.LoadUint32(&o.SWOCTRL.Reg)&^(0x1)|value)
}
func (o *FTM_Type) GetSWOCTRL_CH0OC() uint32 {
	return volatile.LoadUint32(&o.SWOCTRL.Reg) & 0x1
}
func (o *FTM_Type) SetSWOCTRL_CH1OC(value uint32) {
	volatile.StoreUint32(&o.SWOCTRL.Reg, volatile.LoadUint32(&o.SWOCTRL.Reg)&^(0x2)|value<<1)
}
func (o *FTM_Type) GetSWOCTRL_CH1OC() uint32 {
	return (volatile.LoadUint32(&o.SWOCTRL.Reg) & 0x2) >> 1
}
func (o *FTM_Type) SetSWOCTRL_CH2OC(value uint32) {
	volatile.StoreUint32(&o.SWOCTRL.Reg, volatile.LoadUint32(&o.SWOCTRL.Reg)&^(0x4)|value<<2)
}
func (o *FTM_Type) GetSWOCTRL_CH2OC() uint32 {
	return (volatile.LoadUint32(&o.SWOCTRL.Reg) & 0x4) >> 2
}
func (o *FTM_Type) SetSWOCTRL_CH3OC(value uint32) {
	volatile.StoreUint32(&o.SWOCTRL.Reg, volatile.LoadUint32(&o.SWOCTRL.Reg)&^(0x8)|value<<3)
}
func (o *FTM_Type) GetSWOCTRL_CH3OC() uint32 {
	return (volatile.LoadUint32(&o.SWOCTRL.Reg) & 0x8) >> 3
}
func (o *FTM_Type) SetSWOCTRL_CH4OC(value uint32) {
	volatile.StoreUint32(&o.SWOCTRL.Reg, volatile.LoadUint32(&o.SWOCTRL.Reg)&^(0x10)|value<<4)
}
func (o *FTM_Type) GetSWOCTRL_CH4OC() uint32 {
	return (volatile.LoadUint32(&o.SWOCTRL.Reg) & 0x10) >> 4
}
func (o *FTM_Type) SetSWOCTRL_CH5OC(value uint32) {
	volatile.StoreUint32(&o.SWOCTRL.Reg, volatile.LoadUint32(&o.SWOCTRL.Reg)&^(0x20)|value<<5)
}
func (o *FTM_Type) GetSWOCTRL_CH5OC() uint32 {
	return (volatile.LoadUint32(&o.SWOCTRL.Reg) & 0x20) >> 5
}
func (o *FTM_Type) SetSWOCTRL_CH6OC(value uint32) {
	volatile.StoreUint32(&o.SWOCTRL.Reg, volatile.LoadUint32(&o.SWOCTRL.Reg)&^(0x40)|value<<6)
}
func (o *FTM_Type) GetSWOCTRL_CH6OC() uint32 {
	return (volatile.LoadUint32(&o.SWOCTRL.Reg) & 0x40) >> 6
}
func (o *FTM_Type) SetSWOCTRL_CH7OC(value uint32) {
	volatile.StoreUint32(&o.SWOCTRL.Reg, volatile.LoadUint32(&o.SWOCTRL.Reg)&^(0x80)|value<<7)
}
func (o *FTM_Type) GetSWOCTRL_CH7OC() uint32 {
	return (volatile.LoadUint32(&o.SWOCTRL.Reg) & 0x80) >> 7
}
func (o *FTM_Type) SetSWOCTRL_CH0OCV(value uint32) {
	volatile.StoreUint32(&o.SWOCTRL.Reg, volatile.LoadUint32(&o.SWOCTRL.Reg)&^(0x100)|value<<8)
}
func (o *FTM_Type) GetSWOCTRL_CH0OCV() uint32 {
	return (volatile.LoadUint32(&o.SWOCTRL.Reg) & 0x100) >> 8
}
func (o *FTM_Type) SetSWOCTRL_CH1OCV(value uint32) {
	volatile.StoreUint32(&o.SWOCTRL.Reg, volatile.LoadUint32(&o.SWOCTRL.Reg)&^(0x200)|value<<9)
}
func (o *FTM_Type) GetSWOCTRL_CH1OCV() uint32 {
	return (volatile.LoadUint32(&o.SWOCTRL.Reg) & 0x200) >> 9
}
func (o *FTM_Type) SetSWOCTRL_CH2OCV(value uint32) {
	volatile.StoreUint32(&o.SWOCTRL.Reg, volatile.LoadUint32(&o.SWOCTRL.Reg)&^(0x400)|value<<10)
}
func (o *FTM_Type) GetSWOCTRL_CH2OCV() uint32 {
	return (volatile.LoadUint32(&o.SWOCTRL.Reg) & 0x400) >> 10
}
func (o *FTM_Type) SetSWOCTRL_CH3OCV(value uint32) {
	volatile.StoreUint32(&o.SWOCTRL.Reg, volatile.LoadUint32(&o.SWOCTRL.Reg)&^(0x800)|value<<11)
}
func (o *FTM_Type) GetSWOCTRL_CH3OCV() uint32 {
	return (volatile.LoadUint32(&o.SWOCTRL.Reg) & 0x800) >> 11
}
func (o *FTM_Type) SetSWOCTRL_CH4OCV(value uint32) {
	volatile.StoreUint32(&o.SWOCTRL.Reg, volatile.LoadUint32(&o.SWOCTRL.Reg)&^(0x1000)|value<<12)
}
func (o *FTM_Type) GetSWOCTRL_CH4OCV() uint32 {
	return (volatile.LoadUint32(&o.SWOCTRL.Reg) & 0x1000) >> 12
}
func (o *FTM_Type) SetSWOCTRL_CH5OCV(value uint32) {
	volatile.StoreUint32(&o.SWOCTRL.Reg, volatile.LoadUint32(&o.SWOCTRL.Reg)&^(0x2000)|value<<13)
}
func (o *FTM_Type) GetSWOCTRL_CH5OCV() uint32 {
	return (volatile.LoadUint32(&o.SWOCTRL.Reg) & 0x2000) >> 13
}
func (o *FTM_Type) SetSWOCTRL_CH6OCV(value uint32) {
	volatile.StoreUint32(&o.SWOCTRL.Reg, volatile.LoadUint32(&o.SWOCTRL.Reg)&^(0x4000)|value<<14)
}
func (o *FTM_Type) GetSWOCTRL_CH6OCV() uint32 {
	return (volatile.LoadUint32(&o.SWOCTRL.Reg) & 0x4000) >> 14
}
func (o *FTM_Type) SetSWOCTRL_CH7OCV(value uint32) {
	volatile.StoreUint32(&o.SWOCTRL.Reg, volatile.LoadUint32(&o.SWOCTRL.Reg)&^(0x8000)|value<<15)
}
func (o *FTM_Type) GetSWOCTRL_CH7OCV() uint32 {
	return (volatile.LoadUint32(&o.SWOCTRL.Reg) & 0x8000) >> 15
}

// FTM.PWMLOAD: FTM PWM Load
func (o *FTM_Type) SetPWMLOAD_CH0SEL(value uint32) {
	volatile.StoreUint32(&o.PWMLOAD.Reg, volatile.LoadUint32(&o.PWMLOAD.Reg)&^(0x1)|value)
}
func (o *FTM_Type) GetPWMLOAD_CH0SEL() uint32 {
	return volatile.LoadUint32(&o.PWMLOAD.Reg) & 0x1
}
func (o *FTM_Type) SetPWMLOAD_CH1SEL(value uint32) {
	volatile.StoreUint32(&o.PWMLOAD.Reg, volatile.LoadUint32(&o.PWMLOAD.Reg)&^(0x2)|value<<1)
}
func (o *FTM_Type) GetPWMLOAD_CH1SEL() uint32 {
	return (volatile.LoadUint32(&o.PWMLOAD.Reg) & 0x2) >> 1
}
func (o *FTM_Type) SetPWMLOAD_CH2SEL(value uint32) {
	volatile.StoreUint32(&o.PWMLOAD.Reg, volatile.LoadUint32(&o.PWMLOAD.Reg)&^(0x4)|value<<2)
}
func (o *FTM_Type) GetPWMLOAD_CH2SEL() uint32 {
	return (volatile.LoadUint32(&o.PWMLOAD.Reg) & 0x4) >> 2
}
func (o *FTM_Type) SetPWMLOAD_CH3SEL(value uint32) {
	volatile.StoreUint32(&o.PWMLOAD.Reg, volatile.LoadUint32(&o.PWMLOAD.Reg)&^(0x8)|value<<3)
}
func (o *FTM_Type) GetPWMLOAD_CH3SEL() uint32 {
	return (volatile.LoadUint32(&o.PWMLOAD.Reg) & 0x8) >> 3
}
func (o *FTM_Type) SetPWMLOAD_CH4SEL(value uint32) {
	volatile.StoreUint32(&o.PWMLOAD.Reg, volatile.LoadUint32(&o.PWMLOAD.Reg)&^(0x10)|value<<4)
}
func (o *FTM_Type) GetPWMLOAD_CH4SEL() uint32 {
	return (volatile.LoadUint32(&o.PWMLOAD.Reg) & 0x10) >> 4
}
func (o *FTM_Type) SetPWMLOAD_CH5SEL(value uint32) {
	volatile.StoreUint32(&o.PWMLOAD.Reg, volatile.LoadUint32(&o.PWMLOAD.Reg)&^(0x20)|value<<5)
}
func (o *FTM_Type) GetPWMLOAD_CH5SEL() uint32 {
	return (volatile.LoadUint32(&o.PWMLOAD.Reg) & 0x20) >> 5
}
func (o *FTM_Type) SetPWMLOAD_CH6SEL(value uint32) {
	volatile.StoreUint32(&o.PWMLOAD.Reg, volatile.LoadUint32(&o.PWMLOAD.Reg)&^(0x40)|value<<6)
}
func (o *FTM_Type) GetPWMLOAD_CH6SEL() uint32 {
	return (volatile.LoadUint32(&o.PWMLOAD.Reg) & 0x40) >> 6
}
func (o *FTM_Type) SetPWMLOAD_CH7SEL(value uint32) {
	volatile.StoreUint32(&o.PWMLOAD.Reg, volatile.LoadUint32(&o.PWMLOAD.Reg)&^(0x80)|value<<7)
}
func (o *FTM_Type) GetPWMLOAD_CH7SEL() uint32 {
	return (volatile.LoadUint32(&o.PWMLOAD.Reg) & 0x80) >> 7
}
func (o *FTM_Type) SetPWMLOAD_LDOK(value uint32) {
	volatile.StoreUint32(&o.PWMLOAD.Reg, volatile.LoadUint32(&o.PWMLOAD.Reg)&^(0x200)|value<<9)
}
func (o *FTM_Type) GetPWMLOAD_LDOK() uint32 {
	return (volatile.LoadUint32(&o.PWMLOAD.Reg) & 0x200) >> 9
}

// Analog-to-Digital Converter
type ADC_Type struct {
	SC1A volatile.Register32 // 0x0
	SC1B volatile.Register32 // 0x4
	CFG1 volatile.Register32 // 0x8
	CFG2 volatile.Register32 // 0xC
	RA   volatile.Register32 // 0x10
	RB   volatile.Register32 // 0x14
	CV1  volatile.Register32 // 0x18
	CV2  volatile.Register32 // 0x1C
	SC2  volatile.Register32 // 0x20
	SC3  volatile.Register32 // 0x24
	OFS  volatile.Register32 // 0x28
	PG   volatile.Register32 // 0x2C
	MG   volatile.Register32 // 0x30
	CLPD volatile.Register32 // 0x34
	CLPS volatile.Register32 // 0x38
	CLP4 volatile.Register32 // 0x3C
	CLP3 volatile.Register32 // 0x40
	CLP2 volatile.Register32 // 0x44
	CLP1 volatile.Register32 // 0x48
	CLP0 volatile.Register32 // 0x4C
	_    [4]byte
	CLMD volatile.Register32 // 0x54
	CLMS volatile.Register32 // 0x58
	CLM4 volatile.Register32 // 0x5C
	CLM3 volatile.Register32 // 0x60
	CLM2 volatile.Register32 // 0x64
	CLM1 volatile.Register32 // 0x68
	CLM0 volatile.Register32 // 0x6C
}

// ADC.SC1A: ADC Status and Control Registers 1
func (o *ADC_Type) SetSC1A_ADCH(value uint32) {
	volatile.StoreUint32(&o.SC1A.Reg, volatile.LoadUint32(&o.SC1A.Reg)&^(0x1f)|value)
}
func (o *ADC_Type) GetSC1A_ADCH() uint32 {
	return volatile.LoadUint32(&o.SC1A.Reg) & 0x1f
}
func (o *ADC_Type) SetSC1A_DIFF(value uint32) {
	volatile.StoreUint32(&o.SC1A.Reg, volatile.LoadUint32(&o.SC1A.Reg)&^(0x20)|value<<5)
}
func (o *ADC_Type) GetSC1A_DIFF() uint32 {
	return (volatile.LoadUint32(&o.SC1A.Reg) & 0x20) >> 5
}
func (o *ADC_Type) SetSC1A_AIEN(value uint32) {
	volatile.StoreUint32(&o.SC1A.Reg, volatile.LoadUint32(&o.SC1A.Reg)&^(0x40)|value<<6)
}
func (o *ADC_Type) GetSC1A_AIEN() uint32 {
	return (volatile.LoadUint32(&o.SC1A.Reg) & 0x40) >> 6
}
func (o *ADC_Type) SetSC1A_COCO(value uint32) {
	volatile.StoreUint32(&o.SC1A.Reg, volatile.LoadUint32(&o.SC1A.Reg)&^(0x80)|value<<7)
}
func (o *ADC_Type) GetSC1A_COCO() uint32 {
	return (volatile.LoadUint32(&o.SC1A.Reg) & 0x80) >> 7
}

// ADC.SC1B: ADC Status and Control Registers 1
func (o *ADC_Type) SetSC1B_ADCH(value uint32) {
	volatile.StoreUint32(&o.SC1B.Reg, volatile.LoadUint32(&o.SC1B.Reg)&^(0x1f)|value)
}
func (o *ADC_Type) GetSC1B_ADCH() uint32 {
	return volatile.LoadUint32(&o.SC1B.Reg) & 0x1f
}
func (o *ADC_Type) SetSC1B_DIFF(value uint32) {
	volatile.StoreUint32(&o.SC1B.Reg, volatile.LoadUint32(&o.SC1B.Reg)&^(0x20)|value<<5)
}
func (o *ADC_Type) GetSC1B_DIFF() uint32 {
	return (volatile.LoadUint32(&o.SC1B.Reg) & 0x20) >> 5
}
func (o *ADC_Type) SetSC1B_AIEN(value uint32) {
	volatile.StoreUint32(&o.SC1B.Reg, volatile.LoadUint32(&o.SC1B.Reg)&^(0x40)|value<<6)
}
func (o *ADC_Type) GetSC1B_AIEN() uint32 {
	return (volatile.LoadUint32(&o.SC1B.Reg) & 0x40) >> 6
}
func (o *ADC_Type) SetSC1B_COCO(value uint32) {
	volatile.StoreUint32(&o.SC1B.Reg, volatile.LoadUint32(&o.SC1B.Reg)&^(0x80)|value<<7)
}
func (o *ADC_Type) GetSC1B_COCO() uint32 {
	return (volatile.LoadUint32(&o.SC1B.Reg) & 0x80) >> 7
}

// ADC.CFG1: ADC Configuration Register 1
func (o *ADC_Type) SetCFG1_ADICLK(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0x3)|value)
}
func (o *ADC_Type) GetCFG1_ADICLK() uint32 {
	return volatile.LoadUint32(&o.CFG1.Reg) & 0x3
}
func (o *ADC_Type) SetCFG1_MODE(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0xc)|value<<2)
}
func (o *ADC_Type) GetCFG1_MODE() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0xc) >> 2
}
func (o *ADC_Type) SetCFG1_ADLSMP(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0x10)|value<<4)
}
func (o *ADC_Type) GetCFG1_ADLSMP() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0x10) >> 4
}
func (o *ADC_Type) SetCFG1_ADIV(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0x60)|value<<5)
}
func (o *ADC_Type) GetCFG1_ADIV() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0x60) >> 5
}
func (o *ADC_Type) SetCFG1_ADLPC(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0x80)|value<<7)
}
func (o *ADC_Type) GetCFG1_ADLPC() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0x80) >> 7
}

// ADC.CFG2: ADC Configuration Register 2
func (o *ADC_Type) SetCFG2_ADLSTS(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0x3)|value)
}
func (o *ADC_Type) GetCFG2_ADLSTS() uint32 {
	return volatile.LoadUint32(&o.CFG2.Reg) & 0x3
}
func (o *ADC_Type) SetCFG2_ADHSC(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0x4)|value<<2)
}
func (o *ADC_Type) GetCFG2_ADHSC() uint32 {
	return (volatile.LoadUint32(&o.CFG2.Reg) & 0x4) >> 2
}
func (o *ADC_Type) SetCFG2_ADACKEN(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0x8)|value<<3)
}
func (o *ADC_Type) GetCFG2_ADACKEN() uint32 {
	return (volatile.LoadUint32(&o.CFG2.Reg) & 0x8) >> 3
}
func (o *ADC_Type) SetCFG2_MUXSEL(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0x10)|value<<4)
}
func (o *ADC_Type) GetCFG2_MUXSEL() uint32 {
	return (volatile.LoadUint32(&o.CFG2.Reg) & 0x10) >> 4
}

// ADC.RA: ADC Data Result Register
func (o *ADC_Type) SetRA_D(value uint32) {
	volatile.StoreUint32(&o.RA.Reg, volatile.LoadUint32(&o.RA.Reg)&^(0xffff)|value)
}
func (o *ADC_Type) GetRA_D() uint32 {
	return volatile.LoadUint32(&o.RA.Reg) & 0xffff
}

// ADC.RB: ADC Data Result Register
func (o *ADC_Type) SetRB_D(value uint32) {
	volatile.StoreUint32(&o.RB.Reg, volatile.LoadUint32(&o.RB.Reg)&^(0xffff)|value)
}
func (o *ADC_Type) GetRB_D() uint32 {
	return volatile.LoadUint32(&o.RB.Reg) & 0xffff
}

// ADC.CV1: Compare Value Registers
func (o *ADC_Type) SetCV1_CV(value uint32) {
	volatile.StoreUint32(&o.CV1.Reg, volatile.LoadUint32(&o.CV1.Reg)&^(0xffff)|value)
}
func (o *ADC_Type) GetCV1_CV() uint32 {
	return volatile.LoadUint32(&o.CV1.Reg) & 0xffff
}

// ADC.CV2: Compare Value Registers
func (o *ADC_Type) SetCV2_CV(value uint32) {
	volatile.StoreUint32(&o.CV2.Reg, volatile.LoadUint32(&o.CV2.Reg)&^(0xffff)|value)
}
func (o *ADC_Type) GetCV2_CV() uint32 {
	return volatile.LoadUint32(&o.CV2.Reg) & 0xffff
}

// ADC.SC2: Status and Control Register 2
func (o *ADC_Type) SetSC2_REFSEL(value uint32) {
	volatile.StoreUint32(&o.SC2.Reg, volatile.LoadUint32(&o.SC2.Reg)&^(0x3)|value)
}
func (o *ADC_Type) GetSC2_REFSEL() uint32 {
	return volatile.LoadUint32(&o.SC2.Reg) & 0x3
}
func (o *ADC_Type) SetSC2_DMAEN(value uint32) {
	volatile.StoreUint32(&o.SC2.Reg, volatile.LoadUint32(&o.SC2.Reg)&^(0x4)|value<<2)
}
func (o *ADC_Type) GetSC2_DMAEN() uint32 {
	return (volatile.LoadUint32(&o.SC2.Reg) & 0x4) >> 2
}
func (o *ADC_Type) SetSC2_ACREN(value uint32) {
	volatile.StoreUint32(&o.SC2.Reg, volatile.LoadUint32(&o.SC2.Reg)&^(0x8)|value<<3)
}
func (o *ADC_Type) GetSC2_ACREN() uint32 {
	return (volatile.LoadUint32(&o.SC2.Reg) & 0x8) >> 3
}
func (o *ADC_Type) SetSC2_ACFGT(value uint32) {
	volatile.StoreUint32(&o.SC2.Reg, volatile.LoadUint32(&o.SC2.Reg)&^(0x10)|value<<4)
}
func (o *ADC_Type) GetSC2_ACFGT() uint32 {
	return (volatile.LoadUint32(&o.SC2.Reg) & 0x10) >> 4
}
func (o *ADC_Type) SetSC2_ACFE(value uint32) {
	volatile.StoreUint32(&o.SC2.Reg, volatile.LoadUint32(&o.SC2.Reg)&^(0x20)|value<<5)
}
func (o *ADC_Type) GetSC2_ACFE() uint32 {
	return (volatile.LoadUint32(&o.SC2.Reg) & 0x20) >> 5
}
func (o *ADC_Type) SetSC2_ADTRG(value uint32) {
	volatile.StoreUint32(&o.SC2.Reg, volatile.LoadUint32(&o.SC2.Reg)&^(0x40)|value<<6)
}
func (o *ADC_Type) GetSC2_ADTRG() uint32 {
	return (volatile.LoadUint32(&o.SC2.Reg) & 0x40) >> 6
}
func (o *ADC_Type) SetSC2_ADACT(value uint32) {
	volatile.StoreUint32(&o.SC2.Reg, volatile.LoadUint32(&o.SC2.Reg)&^(0x80)|value<<7)
}
func (o *ADC_Type) GetSC2_ADACT() uint32 {
	return (volatile.LoadUint32(&o.SC2.Reg) & 0x80) >> 7
}

// ADC.SC3: Status and Control Register 3
func (o *ADC_Type) SetSC3_AVGS(value uint32) {
	volatile.StoreUint32(&o.SC3.Reg, volatile.LoadUint32(&o.SC3.Reg)&^(0x3)|value)
}
func (o *ADC_Type) GetSC3_AVGS() uint32 {
	return volatile.LoadUint32(&o.SC3.Reg) & 0x3
}
func (o *ADC_Type) SetSC3_AVGE(value uint32) {
	volatile.StoreUint32(&o.SC3.Reg, volatile.LoadUint32(&o.SC3.Reg)&^(0x4)|value<<2)
}
func (o *ADC_Type) GetSC3_AVGE() uint32 {
	return (volatile.LoadUint32(&o.SC3.Reg) & 0x4) >> 2
}
func (o *ADC_Type) SetSC3_ADCO(value uint32) {
	volatile.StoreUint32(&o.SC3.Reg, volatile.LoadUint32(&o.SC3.Reg)&^(0x8)|value<<3)
}
func (o *ADC_Type) GetSC3_ADCO() uint32 {
	return (volatile.LoadUint32(&o.SC3.Reg) & 0x8) >> 3
}
func (o *ADC_Type) SetSC3_CALF(value uint32) {
	volatile.StoreUint32(&o.SC3.Reg, volatile.LoadUint32(&o.SC3.Reg)&^(0x40)|value<<6)
}
func (o *ADC_Type) GetSC3_CALF() uint32 {
	return (volatile.LoadUint32(&o.SC3.Reg) & 0x40) >> 6
}
func (o *ADC_Type) SetSC3_CAL(value uint32) {
	volatile.StoreUint32(&o.SC3.Reg, volatile.LoadUint32(&o.SC3.Reg)&^(0x80)|value<<7)
}
func (o *ADC_Type) GetSC3_CAL() uint32 {
	return (volatile.LoadUint32(&o.SC3.Reg) & 0x80) >> 7
}

// ADC.OFS: ADC Offset Correction Register
func (o *ADC_Type) SetOFS(value uint32) {
	volatile.StoreUint32(&o.OFS.Reg, volatile.LoadUint32(&o.OFS.Reg)&^(0xffff)|value)
}
func (o *ADC_Type) GetOFS() uint32 {
	return volatile.LoadUint32(&o.OFS.Reg) & 0xffff
}

// ADC.PG: ADC Plus-Side Gain Register
func (o *ADC_Type) SetPG(value uint32) {
	volatile.StoreUint32(&o.PG.Reg, volatile.LoadUint32(&o.PG.Reg)&^(0xffff)|value)
}
func (o *ADC_Type) GetPG() uint32 {
	return volatile.LoadUint32(&o.PG.Reg) & 0xffff
}

// ADC.MG: ADC Minus-Side Gain Register
func (o *ADC_Type) SetMG(value uint32) {
	volatile.StoreUint32(&o.MG.Reg, volatile.LoadUint32(&o.MG.Reg)&^(0xffff)|value)
}
func (o *ADC_Type) GetMG() uint32 {
	return volatile.LoadUint32(&o.MG.Reg) & 0xffff
}

// ADC.CLPD: ADC Plus-Side General Calibration Value Register
func (o *ADC_Type) SetCLPD(value uint32) {
	volatile.StoreUint32(&o.CLPD.Reg, volatile.LoadUint32(&o.CLPD.Reg)&^(0x3f)|value)
}
func (o *ADC_Type) GetCLPD() uint32 {
	return volatile.LoadUint32(&o.CLPD.Reg) & 0x3f
}

// ADC.CLPS: ADC Plus-Side General Calibration Value Register
func (o *ADC_Type) SetCLPS(value uint32) {
	volatile.StoreUint32(&o.CLPS.Reg, volatile.LoadUint32(&o.CLPS.Reg)&^(0x3f)|value)
}
func (o *ADC_Type) GetCLPS() uint32 {
	return volatile.LoadUint32(&o.CLPS.Reg) & 0x3f
}

// ADC.CLP4: ADC Plus-Side General Calibration Value Register
func (o *ADC_Type) SetCLP4(value uint32) {
	volatile.StoreUint32(&o.CLP4.Reg, volatile.LoadUint32(&o.CLP4.Reg)&^(0x3ff)|value)
}
func (o *ADC_Type) GetCLP4() uint32 {
	return volatile.LoadUint32(&o.CLP4.Reg) & 0x3ff
}

// ADC.CLP3: ADC Plus-Side General Calibration Value Register
func (o *ADC_Type) SetCLP3(value uint32) {
	volatile.StoreUint32(&o.CLP3.Reg, volatile.LoadUint32(&o.CLP3.Reg)&^(0x1ff)|value)
}
func (o *ADC_Type) GetCLP3() uint32 {
	return volatile.LoadUint32(&o.CLP3.Reg) & 0x1ff
}

// ADC.CLP2: ADC Plus-Side General Calibration Value Register
func (o *ADC_Type) SetCLP2(value uint32) {
	volatile.StoreUint32(&o.CLP2.Reg, volatile.LoadUint32(&o.CLP2.Reg)&^(0xff)|value)
}
func (o *ADC_Type) GetCLP2() uint32 {
	return volatile.LoadUint32(&o.CLP2.Reg) & 0xff
}

// ADC.CLP1: ADC Plus-Side General Calibration Value Register
func (o *ADC_Type) SetCLP1(value uint32) {
	volatile.StoreUint32(&o.CLP1.Reg, volatile.LoadUint32(&o.CLP1.Reg)&^(0x7f)|value)
}
func (o *ADC_Type) GetCLP1() uint32 {
	return volatile.LoadUint32(&o.CLP1.Reg) & 0x7f
}

// ADC.CLP0: ADC Plus-Side General Calibration Value Register
func (o *ADC_Type) SetCLP0(value uint32) {
	volatile.StoreUint32(&o.CLP0.Reg, volatile.LoadUint32(&o.CLP0.Reg)&^(0x3f)|value)
}
func (o *ADC_Type) GetCLP0() uint32 {
	return volatile.LoadUint32(&o.CLP0.Reg) & 0x3f
}

// ADC.CLMD: ADC Minus-Side General Calibration Value Register
func (o *ADC_Type) SetCLMD(value uint32) {
	volatile.StoreUint32(&o.CLMD.Reg, volatile.LoadUint32(&o.CLMD.Reg)&^(0x3f)|value)
}
func (o *ADC_Type) GetCLMD() uint32 {
	return volatile.LoadUint32(&o.CLMD.Reg) & 0x3f
}

// ADC.CLMS: ADC Minus-Side General Calibration Value Register
func (o *ADC_Type) SetCLMS(value uint32) {
	volatile.StoreUint32(&o.CLMS.Reg, volatile.LoadUint32(&o.CLMS.Reg)&^(0x3f)|value)
}
func (o *ADC_Type) GetCLMS() uint32 {
	return volatile.LoadUint32(&o.CLMS.Reg) & 0x3f
}

// ADC.CLM4: ADC Minus-Side General Calibration Value Register
func (o *ADC_Type) SetCLM4(value uint32) {
	volatile.StoreUint32(&o.CLM4.Reg, volatile.LoadUint32(&o.CLM4.Reg)&^(0x3ff)|value)
}
func (o *ADC_Type) GetCLM4() uint32 {
	return volatile.LoadUint32(&o.CLM4.Reg) & 0x3ff
}

// ADC.CLM3: ADC Minus-Side General Calibration Value Register
func (o *ADC_Type) SetCLM3(value uint32) {
	volatile.StoreUint32(&o.CLM3.Reg, volatile.LoadUint32(&o.CLM3.Reg)&^(0x1ff)|value)
}
func (o *ADC_Type) GetCLM3() uint32 {
	return volatile.LoadUint32(&o.CLM3.Reg) & 0x1ff
}

// ADC.CLM2: ADC Minus-Side General Calibration Value Register
func (o *ADC_Type) SetCLM2(value uint32) {
	volatile.StoreUint32(&o.CLM2.Reg, volatile.LoadUint32(&o.CLM2.Reg)&^(0xff)|value)
}
func (o *ADC_Type) GetCLM2() uint32 {
	return volatile.LoadUint32(&o.CLM2.Reg) & 0xff
}

// ADC.CLM1: ADC Minus-Side General Calibration Value Register
func (o *ADC_Type) SetCLM1(value uint32) {
	volatile.StoreUint32(&o.CLM1.Reg, volatile.LoadUint32(&o.CLM1.Reg)&^(0x7f)|value)
}
func (o *ADC_Type) GetCLM1() uint32 {
	return volatile.LoadUint32(&o.CLM1.Reg) & 0x7f
}

// ADC.CLM0: ADC Minus-Side General Calibration Value Register
func (o *ADC_Type) SetCLM0(value uint32) {
	volatile.StoreUint32(&o.CLM0.Reg, volatile.LoadUint32(&o.CLM0.Reg)&^(0x3f)|value)
}
func (o *ADC_Type) GetCLM0() uint32 {
	return volatile.LoadUint32(&o.CLM0.Reg) & 0x3f
}

// Secure Real Time Clock
type RTC_Type struct {
	TSR volatile.Register32 // 0x0
	TPR volatile.Register32 // 0x4
	TAR volatile.Register32 // 0x8
	TCR volatile.Register32 // 0xC
	CR  volatile.Register32 // 0x10
	SR  volatile.Register32 // 0x14
	LR  volatile.Register32 // 0x18
	IER volatile.Register32 // 0x1C
	_   [2016]byte
	WAR volatile.Register32 // 0x800
	RAR volatile.Register32 // 0x804
}

// RTC.TSR: RTC Time Seconds Register
func (o *RTC_Type) SetTSR(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, value)
}
func (o *RTC_Type) GetTSR() uint32 {
	return volatile.LoadUint32(&o.TSR.Reg)
}

// RTC.TPR: RTC Time Prescaler Register
func (o *RTC_Type) SetTPR(value uint32) {
	volatile.StoreUint32(&o.TPR.Reg, volatile.LoadUint32(&o.TPR.Reg)&^(0xffff)|value)
}
func (o *RTC_Type) GetTPR() uint32 {
	return volatile.LoadUint32(&o.TPR.Reg) & 0xffff
}

// RTC.TAR: RTC Time Alarm Register
func (o *RTC_Type) SetTAR(value uint32) {
	volatile.StoreUint32(&o.TAR.Reg, value)
}
func (o *RTC_Type) GetTAR() uint32 {
	return volatile.LoadUint32(&o.TAR.Reg)
}

// RTC.TCR: RTC Time Compensation Register
func (o *RTC_Type) SetTCR(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0xff)|value)
}
func (o *RTC_Type) GetTCR() uint32 {
	return volatile.LoadUint32(&o.TCR.Reg) & 0xff
}
func (o *RTC_Type) SetTCR_CIR(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0xff00)|value<<8)
}
func (o *RTC_Type) GetTCR_CIR() uint32 {
	return (volatile.LoadUint32(&o.TCR.Reg) & 0xff00) >> 8
}
func (o *RTC_Type) SetTCR_TCV(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0xff0000)|value<<16)
}
func (o *RTC_Type) GetTCR_TCV() uint32 {
	return (volatile.LoadUint32(&o.TCR.Reg) & 0xff0000) >> 16
}
func (o *RTC_Type) SetTCR_CIC(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0xff000000)|value<<24)
}
func (o *RTC_Type) GetTCR_CIC() uint32 {
	return (volatile.LoadUint32(&o.TCR.Reg) & 0xff000000) >> 24
}

// RTC.CR: RTC Control Register
func (o *RTC_Type) SetCR_SWR(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetCR_SWR() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}
func (o *RTC_Type) SetCR_WPE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetCR_WPE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *RTC_Type) SetCR_SUP(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *RTC_Type) GetCR_SUP() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *RTC_Type) SetCR_UM(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8)|value<<3)
}
func (o *RTC_Type) GetCR_UM() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8) >> 3
}
func (o *RTC_Type) SetCR_WPS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10)|value<<4)
}
func (o *RTC_Type) GetCR_WPS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10) >> 4
}
func (o *RTC_Type) SetCR_OSCE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x100)|value<<8)
}
func (o *RTC_Type) GetCR_OSCE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x100) >> 8
}
func (o *RTC_Type) SetCR_CLKO(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x200)|value<<9)
}
func (o *RTC_Type) GetCR_CLKO() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x200) >> 9
}
func (o *RTC_Type) SetCR_SC16P(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x400)|value<<10)
}
func (o *RTC_Type) GetCR_SC16P() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x400) >> 10
}
func (o *RTC_Type) SetCR_SC8P(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x800)|value<<11)
}
func (o *RTC_Type) GetCR_SC8P() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x800) >> 11
}
func (o *RTC_Type) SetCR_SC4P(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1000)|value<<12)
}
func (o *RTC_Type) GetCR_SC4P() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x1000) >> 12
}
func (o *RTC_Type) SetCR_SC2P(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2000)|value<<13)
}
func (o *RTC_Type) GetCR_SC2P() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2000) >> 13
}

// RTC.SR: RTC Status Register
func (o *RTC_Type) SetSR_TIF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetSR_TIF() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}
func (o *RTC_Type) SetSR_TOF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetSR_TOF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *RTC_Type) SetSR_TAF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *RTC_Type) GetSR_TAF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}
func (o *RTC_Type) SetSR_TCE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10)|value<<4)
}
func (o *RTC_Type) GetSR_TCE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10) >> 4
}

// RTC.LR: RTC Lock Register
func (o *RTC_Type) SetLR_TCL(value uint32) {
	volatile.StoreUint32(&o.LR.Reg, volatile.LoadUint32(&o.LR.Reg)&^(0x8)|value<<3)
}
func (o *RTC_Type) GetLR_TCL() uint32 {
	return (volatile.LoadUint32(&o.LR.Reg) & 0x8) >> 3
}
func (o *RTC_Type) SetLR_CRL(value uint32) {
	volatile.StoreUint32(&o.LR.Reg, volatile.LoadUint32(&o.LR.Reg)&^(0x10)|value<<4)
}
func (o *RTC_Type) GetLR_CRL() uint32 {
	return (volatile.LoadUint32(&o.LR.Reg) & 0x10) >> 4
}
func (o *RTC_Type) SetLR_SRL(value uint32) {
	volatile.StoreUint32(&o.LR.Reg, volatile.LoadUint32(&o.LR.Reg)&^(0x20)|value<<5)
}
func (o *RTC_Type) GetLR_SRL() uint32 {
	return (volatile.LoadUint32(&o.LR.Reg) & 0x20) >> 5
}
func (o *RTC_Type) SetLR_LRL(value uint32) {
	volatile.StoreUint32(&o.LR.Reg, volatile.LoadUint32(&o.LR.Reg)&^(0x40)|value<<6)
}
func (o *RTC_Type) GetLR_LRL() uint32 {
	return (volatile.LoadUint32(&o.LR.Reg) & 0x40) >> 6
}

// RTC.IER: RTC Interrupt Enable Register
func (o *RTC_Type) SetIER_TIIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetIER_TIIE() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}
func (o *RTC_Type) SetIER_TOIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetIER_TOIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2) >> 1
}
func (o *RTC_Type) SetIER_TAIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4)|value<<2)
}
func (o *RTC_Type) GetIER_TAIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4) >> 2
}
func (o *RTC_Type) SetIER_TSIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10)|value<<4)
}
func (o *RTC_Type) GetIER_TSIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10) >> 4
}
func (o *RTC_Type) SetIER_WPON(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x80)|value<<7)
}
func (o *RTC_Type) GetIER_WPON() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x80) >> 7
}

// RTC.WAR: RTC Write Access Register
func (o *RTC_Type) SetWAR_TSRW(value uint32) {
	volatile.StoreUint32(&o.WAR.Reg, volatile.LoadUint32(&o.WAR.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetWAR_TSRW() uint32 {
	return volatile.LoadUint32(&o.WAR.Reg) & 0x1
}
func (o *RTC_Type) SetWAR_TPRW(value uint32) {
	volatile.StoreUint32(&o.WAR.Reg, volatile.LoadUint32(&o.WAR.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetWAR_TPRW() uint32 {
	return (volatile.LoadUint32(&o.WAR.Reg) & 0x2) >> 1
}
func (o *RTC_Type) SetWAR_TARW(value uint32) {
	volatile.StoreUint32(&o.WAR.Reg, volatile.LoadUint32(&o.WAR.Reg)&^(0x4)|value<<2)
}
func (o *RTC_Type) GetWAR_TARW() uint32 {
	return (volatile.LoadUint32(&o.WAR.Reg) & 0x4) >> 2
}
func (o *RTC_Type) SetWAR_TCRW(value uint32) {
	volatile.StoreUint32(&o.WAR.Reg, volatile.LoadUint32(&o.WAR.Reg)&^(0x8)|value<<3)
}
func (o *RTC_Type) GetWAR_TCRW() uint32 {
	return (volatile.LoadUint32(&o.WAR.Reg) & 0x8) >> 3
}
func (o *RTC_Type) SetWAR_CRW(value uint32) {
	volatile.StoreUint32(&o.WAR.Reg, volatile.LoadUint32(&o.WAR.Reg)&^(0x10)|value<<4)
}
func (o *RTC_Type) GetWAR_CRW() uint32 {
	return (volatile.LoadUint32(&o.WAR.Reg) & 0x10) >> 4
}
func (o *RTC_Type) SetWAR_SRW(value uint32) {
	volatile.StoreUint32(&o.WAR.Reg, volatile.LoadUint32(&o.WAR.Reg)&^(0x20)|value<<5)
}
func (o *RTC_Type) GetWAR_SRW() uint32 {
	return (volatile.LoadUint32(&o.WAR.Reg) & 0x20) >> 5
}
func (o *RTC_Type) SetWAR_LRW(value uint32) {
	volatile.StoreUint32(&o.WAR.Reg, volatile.LoadUint32(&o.WAR.Reg)&^(0x40)|value<<6)
}
func (o *RTC_Type) GetWAR_LRW() uint32 {
	return (volatile.LoadUint32(&o.WAR.Reg) & 0x40) >> 6
}
func (o *RTC_Type) SetWAR_IERW(value uint32) {
	volatile.StoreUint32(&o.WAR.Reg, volatile.LoadUint32(&o.WAR.Reg)&^(0x80)|value<<7)
}
func (o *RTC_Type) GetWAR_IERW() uint32 {
	return (volatile.LoadUint32(&o.WAR.Reg) & 0x80) >> 7
}

// RTC.RAR: RTC Read Access Register
func (o *RTC_Type) SetRAR_TSRR(value uint32) {
	volatile.StoreUint32(&o.RAR.Reg, volatile.LoadUint32(&o.RAR.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetRAR_TSRR() uint32 {
	return volatile.LoadUint32(&o.RAR.Reg) & 0x1
}
func (o *RTC_Type) SetRAR_TPRR(value uint32) {
	volatile.StoreUint32(&o.RAR.Reg, volatile.LoadUint32(&o.RAR.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetRAR_TPRR() uint32 {
	return (volatile.LoadUint32(&o.RAR.Reg) & 0x2) >> 1
}
func (o *RTC_Type) SetRAR_TARR(value uint32) {
	volatile.StoreUint32(&o.RAR.Reg, volatile.LoadUint32(&o.RAR.Reg)&^(0x4)|value<<2)
}
func (o *RTC_Type) GetRAR_TARR() uint32 {
	return (volatile.LoadUint32(&o.RAR.Reg) & 0x4) >> 2
}
func (o *RTC_Type) SetRAR_TCRR(value uint32) {
	volatile.StoreUint32(&o.RAR.Reg, volatile.LoadUint32(&o.RAR.Reg)&^(0x8)|value<<3)
}
func (o *RTC_Type) GetRAR_TCRR() uint32 {
	return (volatile.LoadUint32(&o.RAR.Reg) & 0x8) >> 3
}
func (o *RTC_Type) SetRAR_CRR(value uint32) {
	volatile.StoreUint32(&o.RAR.Reg, volatile.LoadUint32(&o.RAR.Reg)&^(0x10)|value<<4)
}
func (o *RTC_Type) GetRAR_CRR() uint32 {
	return (volatile.LoadUint32(&o.RAR.Reg) & 0x10) >> 4
}
func (o *RTC_Type) SetRAR_SRR(value uint32) {
	volatile.StoreUint32(&o.RAR.Reg, volatile.LoadUint32(&o.RAR.Reg)&^(0x20)|value<<5)
}
func (o *RTC_Type) GetRAR_SRR() uint32 {
	return (volatile.LoadUint32(&o.RAR.Reg) & 0x20) >> 5
}
func (o *RTC_Type) SetRAR_LRR(value uint32) {
	volatile.StoreUint32(&o.RAR.Reg, volatile.LoadUint32(&o.RAR.Reg)&^(0x40)|value<<6)
}
func (o *RTC_Type) GetRAR_LRR() uint32 {
	return (volatile.LoadUint32(&o.RAR.Reg) & 0x40) >> 6
}
func (o *RTC_Type) SetRAR_IERR(value uint32) {
	volatile.StoreUint32(&o.RAR.Reg, volatile.LoadUint32(&o.RAR.Reg)&^(0x80)|value<<7)
}
func (o *RTC_Type) GetRAR_IERR() uint32 {
	return (volatile.LoadUint32(&o.RAR.Reg) & 0x80) >> 7
}

// VBAT register file
type RFVBAT_Type struct {
	REG0 volatile.Register32 // 0x0
	REG1 volatile.Register32 // 0x4
	REG2 volatile.Register32 // 0x8
	REG3 volatile.Register32 // 0xC
	REG4 volatile.Register32 // 0x10
	REG5 volatile.Register32 // 0x14
	REG6 volatile.Register32 // 0x18
	REG7 volatile.Register32 // 0x1C
}

// RFVBAT.REG0: VBAT register file register
func (o *RFVBAT_Type) SetREG0_LL(value uint32) {
	volatile.StoreUint32(&o.REG0.Reg, volatile.LoadUint32(&o.REG0.Reg)&^(0xff)|value)
}
func (o *RFVBAT_Type) GetREG0_LL() uint32 {
	return volatile.LoadUint32(&o.REG0.Reg) & 0xff
}
func (o *RFVBAT_Type) SetREG0_LH(value uint32) {
	volatile.StoreUint32(&o.REG0.Reg, volatile.LoadUint32(&o.REG0.Reg)&^(0xff00)|value<<8)
}
func (o *RFVBAT_Type) GetREG0_LH() uint32 {
	return (volatile.LoadUint32(&o.REG0.Reg) & 0xff00) >> 8
}
func (o *RFVBAT_Type) SetREG0_HL(value uint32) {
	volatile.StoreUint32(&o.REG0.Reg, volatile.LoadUint32(&o.REG0.Reg)&^(0xff0000)|value<<16)
}
func (o *RFVBAT_Type) GetREG0_HL() uint32 {
	return (volatile.LoadUint32(&o.REG0.Reg) & 0xff0000) >> 16
}
func (o *RFVBAT_Type) SetREG0_HH(value uint32) {
	volatile.StoreUint32(&o.REG0.Reg, volatile.LoadUint32(&o.REG0.Reg)&^(0xff000000)|value<<24)
}
func (o *RFVBAT_Type) GetREG0_HH() uint32 {
	return (volatile.LoadUint32(&o.REG0.Reg) & 0xff000000) >> 24
}

// RFVBAT.REG1: VBAT register file register
func (o *RFVBAT_Type) SetREG1_LL(value uint32) {
	volatile.StoreUint32(&o.REG1.Reg, volatile.LoadUint32(&o.REG1.Reg)&^(0xff)|value)
}
func (o *RFVBAT_Type) GetREG1_LL() uint32 {
	return volatile.LoadUint32(&o.REG1.Reg) & 0xff
}
func (o *RFVBAT_Type) SetREG1_LH(value uint32) {
	volatile.StoreUint32(&o.REG1.Reg, volatile.LoadUint32(&o.REG1.Reg)&^(0xff00)|value<<8)
}
func (o *RFVBAT_Type) GetREG1_LH() uint32 {
	return (volatile.LoadUint32(&o.REG1.Reg) & 0xff00) >> 8
}
func (o *RFVBAT_Type) SetREG1_HL(value uint32) {
	volatile.StoreUint32(&o.REG1.Reg, volatile.LoadUint32(&o.REG1.Reg)&^(0xff0000)|value<<16)
}
func (o *RFVBAT_Type) GetREG1_HL() uint32 {
	return (volatile.LoadUint32(&o.REG1.Reg) & 0xff0000) >> 16
}
func (o *RFVBAT_Type) SetREG1_HH(value uint32) {
	volatile.StoreUint32(&o.REG1.Reg, volatile.LoadUint32(&o.REG1.Reg)&^(0xff000000)|value<<24)
}
func (o *RFVBAT_Type) GetREG1_HH() uint32 {
	return (volatile.LoadUint32(&o.REG1.Reg) & 0xff000000) >> 24
}

// RFVBAT.REG2: VBAT register file register
func (o *RFVBAT_Type) SetREG2_LL(value uint32) {
	volatile.StoreUint32(&o.REG2.Reg, volatile.LoadUint32(&o.REG2.Reg)&^(0xff)|value)
}
func (o *RFVBAT_Type) GetREG2_LL() uint32 {
	return volatile.LoadUint32(&o.REG2.Reg) & 0xff
}
func (o *RFVBAT_Type) SetREG2_LH(value uint32) {
	volatile.StoreUint32(&o.REG2.Reg, volatile.LoadUint32(&o.REG2.Reg)&^(0xff00)|value<<8)
}
func (o *RFVBAT_Type) GetREG2_LH() uint32 {
	return (volatile.LoadUint32(&o.REG2.Reg) & 0xff00) >> 8
}
func (o *RFVBAT_Type) SetREG2_HL(value uint32) {
	volatile.StoreUint32(&o.REG2.Reg, volatile.LoadUint32(&o.REG2.Reg)&^(0xff0000)|value<<16)
}
func (o *RFVBAT_Type) GetREG2_HL() uint32 {
	return (volatile.LoadUint32(&o.REG2.Reg) & 0xff0000) >> 16
}
func (o *RFVBAT_Type) SetREG2_HH(value uint32) {
	volatile.StoreUint32(&o.REG2.Reg, volatile.LoadUint32(&o.REG2.Reg)&^(0xff000000)|value<<24)
}
func (o *RFVBAT_Type) GetREG2_HH() uint32 {
	return (volatile.LoadUint32(&o.REG2.Reg) & 0xff000000) >> 24
}

// RFVBAT.REG3: VBAT register file register
func (o *RFVBAT_Type) SetREG3_LL(value uint32) {
	volatile.StoreUint32(&o.REG3.Reg, volatile.LoadUint32(&o.REG3.Reg)&^(0xff)|value)
}
func (o *RFVBAT_Type) GetREG3_LL() uint32 {
	return volatile.LoadUint32(&o.REG3.Reg) & 0xff
}
func (o *RFVBAT_Type) SetREG3_LH(value uint32) {
	volatile.StoreUint32(&o.REG3.Reg, volatile.LoadUint32(&o.REG3.Reg)&^(0xff00)|value<<8)
}
func (o *RFVBAT_Type) GetREG3_LH() uint32 {
	return (volatile.LoadUint32(&o.REG3.Reg) & 0xff00) >> 8
}
func (o *RFVBAT_Type) SetREG3_HL(value uint32) {
	volatile.StoreUint32(&o.REG3.Reg, volatile.LoadUint32(&o.REG3.Reg)&^(0xff0000)|value<<16)
}
func (o *RFVBAT_Type) GetREG3_HL() uint32 {
	return (volatile.LoadUint32(&o.REG3.Reg) & 0xff0000) >> 16
}
func (o *RFVBAT_Type) SetREG3_HH(value uint32) {
	volatile.StoreUint32(&o.REG3.Reg, volatile.LoadUint32(&o.REG3.Reg)&^(0xff000000)|value<<24)
}
func (o *RFVBAT_Type) GetREG3_HH() uint32 {
	return (volatile.LoadUint32(&o.REG3.Reg) & 0xff000000) >> 24
}

// RFVBAT.REG4: VBAT register file register
func (o *RFVBAT_Type) SetREG4_LL(value uint32) {
	volatile.StoreUint32(&o.REG4.Reg, volatile.LoadUint32(&o.REG4.Reg)&^(0xff)|value)
}
func (o *RFVBAT_Type) GetREG4_LL() uint32 {
	return volatile.LoadUint32(&o.REG4.Reg) & 0xff
}
func (o *RFVBAT_Type) SetREG4_LH(value uint32) {
	volatile.StoreUint32(&o.REG4.Reg, volatile.LoadUint32(&o.REG4.Reg)&^(0xff00)|value<<8)
}
func (o *RFVBAT_Type) GetREG4_LH() uint32 {
	return (volatile.LoadUint32(&o.REG4.Reg) & 0xff00) >> 8
}
func (o *RFVBAT_Type) SetREG4_HL(value uint32) {
	volatile.StoreUint32(&o.REG4.Reg, volatile.LoadUint32(&o.REG4.Reg)&^(0xff0000)|value<<16)
}
func (o *RFVBAT_Type) GetREG4_HL() uint32 {
	return (volatile.LoadUint32(&o.REG4.Reg) & 0xff0000) >> 16
}
func (o *RFVBAT_Type) SetREG4_HH(value uint32) {
	volatile.StoreUint32(&o.REG4.Reg, volatile.LoadUint32(&o.REG4.Reg)&^(0xff000000)|value<<24)
}
func (o *RFVBAT_Type) GetREG4_HH() uint32 {
	return (volatile.LoadUint32(&o.REG4.Reg) & 0xff000000) >> 24
}

// RFVBAT.REG5: VBAT register file register
func (o *RFVBAT_Type) SetREG5_LL(value uint32) {
	volatile.StoreUint32(&o.REG5.Reg, volatile.LoadUint32(&o.REG5.Reg)&^(0xff)|value)
}
func (o *RFVBAT_Type) GetREG5_LL() uint32 {
	return volatile.LoadUint32(&o.REG5.Reg) & 0xff
}
func (o *RFVBAT_Type) SetREG5_LH(value uint32) {
	volatile.StoreUint32(&o.REG5.Reg, volatile.LoadUint32(&o.REG5.Reg)&^(0xff00)|value<<8)
}
func (o *RFVBAT_Type) GetREG5_LH() uint32 {
	return (volatile.LoadUint32(&o.REG5.Reg) & 0xff00) >> 8
}
func (o *RFVBAT_Type) SetREG5_HL(value uint32) {
	volatile.StoreUint32(&o.REG5.Reg, volatile.LoadUint32(&o.REG5.Reg)&^(0xff0000)|value<<16)
}
func (o *RFVBAT_Type) GetREG5_HL() uint32 {
	return (volatile.LoadUint32(&o.REG5.Reg) & 0xff0000) >> 16
}
func (o *RFVBAT_Type) SetREG5_HH(value uint32) {
	volatile.StoreUint32(&o.REG5.Reg, volatile.LoadUint32(&o.REG5.Reg)&^(0xff000000)|value<<24)
}
func (o *RFVBAT_Type) GetREG5_HH() uint32 {
	return (volatile.LoadUint32(&o.REG5.Reg) & 0xff000000) >> 24
}

// RFVBAT.REG6: VBAT register file register
func (o *RFVBAT_Type) SetREG6_LL(value uint32) {
	volatile.StoreUint32(&o.REG6.Reg, volatile.LoadUint32(&o.REG6.Reg)&^(0xff)|value)
}
func (o *RFVBAT_Type) GetREG6_LL() uint32 {
	return volatile.LoadUint32(&o.REG6.Reg) & 0xff
}
func (o *RFVBAT_Type) SetREG6_LH(value uint32) {
	volatile.StoreUint32(&o.REG6.Reg, volatile.LoadUint32(&o.REG6.Reg)&^(0xff00)|value<<8)
}
func (o *RFVBAT_Type) GetREG6_LH() uint32 {
	return (volatile.LoadUint32(&o.REG6.Reg) & 0xff00) >> 8
}
func (o *RFVBAT_Type) SetREG6_HL(value uint32) {
	volatile.StoreUint32(&o.REG6.Reg, volatile.LoadUint32(&o.REG6.Reg)&^(0xff0000)|value<<16)
}
func (o *RFVBAT_Type) GetREG6_HL() uint32 {
	return (volatile.LoadUint32(&o.REG6.Reg) & 0xff0000) >> 16
}
func (o *RFVBAT_Type) SetREG6_HH(value uint32) {
	volatile.StoreUint32(&o.REG6.Reg, volatile.LoadUint32(&o.REG6.Reg)&^(0xff000000)|value<<24)
}
func (o *RFVBAT_Type) GetREG6_HH() uint32 {
	return (volatile.LoadUint32(&o.REG6.Reg) & 0xff000000) >> 24
}

// RFVBAT.REG7: VBAT register file register
func (o *RFVBAT_Type) SetREG7_LL(value uint32) {
	volatile.StoreUint32(&o.REG7.Reg, volatile.LoadUint32(&o.REG7.Reg)&^(0xff)|value)
}
func (o *RFVBAT_Type) GetREG7_LL() uint32 {
	return volatile.LoadUint32(&o.REG7.Reg) & 0xff
}
func (o *RFVBAT_Type) SetREG7_LH(value uint32) {
	volatile.StoreUint32(&o.REG7.Reg, volatile.LoadUint32(&o.REG7.Reg)&^(0xff00)|value<<8)
}
func (o *RFVBAT_Type) GetREG7_LH() uint32 {
	return (volatile.LoadUint32(&o.REG7.Reg) & 0xff00) >> 8
}
func (o *RFVBAT_Type) SetREG7_HL(value uint32) {
	volatile.StoreUint32(&o.REG7.Reg, volatile.LoadUint32(&o.REG7.Reg)&^(0xff0000)|value<<16)
}
func (o *RFVBAT_Type) GetREG7_HL() uint32 {
	return (volatile.LoadUint32(&o.REG7.Reg) & 0xff0000) >> 16
}
func (o *RFVBAT_Type) SetREG7_HH(value uint32) {
	volatile.StoreUint32(&o.REG7.Reg, volatile.LoadUint32(&o.REG7.Reg)&^(0xff000000)|value<<24)
}
func (o *RFVBAT_Type) GetREG7_HH() uint32 {
	return (volatile.LoadUint32(&o.REG7.Reg) & 0xff000000) >> 24
}

// Low Power Timer
type LPTMR0_Type struct {
	CSR volatile.Register32 // 0x0
	PSR volatile.Register32 // 0x4
	CMR volatile.Register32 // 0x8
	CNR volatile.Register32 // 0xC
}

// LPTMR0.CSR: Low Power Timer Control Status Register
func (o *LPTMR0_Type) SetCSR_TEN(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x1)|value)
}
func (o *LPTMR0_Type) GetCSR_TEN() uint32 {
	return volatile.LoadUint32(&o.CSR.Reg) & 0x1
}
func (o *LPTMR0_Type) SetCSR_TMS(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x2)|value<<1)
}
func (o *LPTMR0_Type) GetCSR_TMS() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x2) >> 1
}
func (o *LPTMR0_Type) SetCSR_TFC(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x4)|value<<2)
}
func (o *LPTMR0_Type) GetCSR_TFC() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x4) >> 2
}
func (o *LPTMR0_Type) SetCSR_TPP(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x8)|value<<3)
}
func (o *LPTMR0_Type) GetCSR_TPP() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x8) >> 3
}
func (o *LPTMR0_Type) SetCSR_TPS(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x30)|value<<4)
}
func (o *LPTMR0_Type) GetCSR_TPS() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x30) >> 4
}
func (o *LPTMR0_Type) SetCSR_TIE(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x40)|value<<6)
}
func (o *LPTMR0_Type) GetCSR_TIE() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x40) >> 6
}
func (o *LPTMR0_Type) SetCSR_TCF(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x80)|value<<7)
}
func (o *LPTMR0_Type) GetCSR_TCF() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x80) >> 7
}

// LPTMR0.PSR: Low Power Timer Prescale Register
func (o *LPTMR0_Type) SetPSR_PCS(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x3)|value)
}
func (o *LPTMR0_Type) GetPSR_PCS() uint32 {
	return volatile.LoadUint32(&o.PSR.Reg) & 0x3
}
func (o *LPTMR0_Type) SetPSR_PBYP(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x4)|value<<2)
}
func (o *LPTMR0_Type) GetPSR_PBYP() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x4) >> 2
}
func (o *LPTMR0_Type) SetPSR_PRESCALE(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x78)|value<<3)
}
func (o *LPTMR0_Type) GetPSR_PRESCALE() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x78) >> 3
}

// LPTMR0.CMR: Low Power Timer Compare Register
func (o *LPTMR0_Type) SetCMR_COMPARE(value uint32) {
	volatile.StoreUint32(&o.CMR.Reg, volatile.LoadUint32(&o.CMR.Reg)&^(0xffff)|value)
}
func (o *LPTMR0_Type) GetCMR_COMPARE() uint32 {
	return volatile.LoadUint32(&o.CMR.Reg) & 0xffff
}

// LPTMR0.CNR: Low Power Timer Counter Register
func (o *LPTMR0_Type) SetCNR_COUNTER(value uint32) {
	volatile.StoreUint32(&o.CNR.Reg, volatile.LoadUint32(&o.CNR.Reg)&^(0xffff)|value)
}
func (o *LPTMR0_Type) GetCNR_COUNTER() uint32 {
	return volatile.LoadUint32(&o.CNR.Reg) & 0xffff
}

// System register file
type RFSYS_Type struct {
	REG0 volatile.Register32 // 0x0
	REG1 volatile.Register32 // 0x4
	REG2 volatile.Register32 // 0x8
	REG3 volatile.Register32 // 0xC
	REG4 volatile.Register32 // 0x10
	REG5 volatile.Register32 // 0x14
	REG6 volatile.Register32 // 0x18
	REG7 volatile.Register32 // 0x1C
}

// RFSYS.REG0: Register file register
func (o *RFSYS_Type) SetREG0_LL(value uint32) {
	volatile.StoreUint32(&o.REG0.Reg, volatile.LoadUint32(&o.REG0.Reg)&^(0xff)|value)
}
func (o *RFSYS_Type) GetREG0_LL() uint32 {
	return volatile.LoadUint32(&o.REG0.Reg) & 0xff
}
func (o *RFSYS_Type) SetREG0_LH(value uint32) {
	volatile.StoreUint32(&o.REG0.Reg, volatile.LoadUint32(&o.REG0.Reg)&^(0xff00)|value<<8)
}
func (o *RFSYS_Type) GetREG0_LH() uint32 {
	return (volatile.LoadUint32(&o.REG0.Reg) & 0xff00) >> 8
}
func (o *RFSYS_Type) SetREG0_HL(value uint32) {
	volatile.StoreUint32(&o.REG0.Reg, volatile.LoadUint32(&o.REG0.Reg)&^(0xff0000)|value<<16)
}
func (o *RFSYS_Type) GetREG0_HL() uint32 {
	return (volatile.LoadUint32(&o.REG0.Reg) & 0xff0000) >> 16
}
func (o *RFSYS_Type) SetREG0_HH(value uint32) {
	volatile.StoreUint32(&o.REG0.Reg, volatile.LoadUint32(&o.REG0.Reg)&^(0xff000000)|value<<24)
}
func (o *RFSYS_Type) GetREG0_HH() uint32 {
	return (volatile.LoadUint32(&o.REG0.Reg) & 0xff000000) >> 24
}

// RFSYS.REG1: Register file register
func (o *RFSYS_Type) SetREG1_LL(value uint32) {
	volatile.StoreUint32(&o.REG1.Reg, volatile.LoadUint32(&o.REG1.Reg)&^(0xff)|value)
}
func (o *RFSYS_Type) GetREG1_LL() uint32 {
	return volatile.LoadUint32(&o.REG1.Reg) & 0xff
}
func (o *RFSYS_Type) SetREG1_LH(value uint32) {
	volatile.StoreUint32(&o.REG1.Reg, volatile.LoadUint32(&o.REG1.Reg)&^(0xff00)|value<<8)
}
func (o *RFSYS_Type) GetREG1_LH() uint32 {
	return (volatile.LoadUint32(&o.REG1.Reg) & 0xff00) >> 8
}
func (o *RFSYS_Type) SetREG1_HL(value uint32) {
	volatile.StoreUint32(&o.REG1.Reg, volatile.LoadUint32(&o.REG1.Reg)&^(0xff0000)|value<<16)
}
func (o *RFSYS_Type) GetREG1_HL() uint32 {
	return (volatile.LoadUint32(&o.REG1.Reg) & 0xff0000) >> 16
}
func (o *RFSYS_Type) SetREG1_HH(value uint32) {
	volatile.StoreUint32(&o.REG1.Reg, volatile.LoadUint32(&o.REG1.Reg)&^(0xff000000)|value<<24)
}
func (o *RFSYS_Type) GetREG1_HH() uint32 {
	return (volatile.LoadUint32(&o.REG1.Reg) & 0xff000000) >> 24
}

// RFSYS.REG2: Register file register
func (o *RFSYS_Type) SetREG2_LL(value uint32) {
	volatile.StoreUint32(&o.REG2.Reg, volatile.LoadUint32(&o.REG2.Reg)&^(0xff)|value)
}
func (o *RFSYS_Type) GetREG2_LL() uint32 {
	return volatile.LoadUint32(&o.REG2.Reg) & 0xff
}
func (o *RFSYS_Type) SetREG2_LH(value uint32) {
	volatile.StoreUint32(&o.REG2.Reg, volatile.LoadUint32(&o.REG2.Reg)&^(0xff00)|value<<8)
}
func (o *RFSYS_Type) GetREG2_LH() uint32 {
	return (volatile.LoadUint32(&o.REG2.Reg) & 0xff00) >> 8
}
func (o *RFSYS_Type) SetREG2_HL(value uint32) {
	volatile.StoreUint32(&o.REG2.Reg, volatile.LoadUint32(&o.REG2.Reg)&^(0xff0000)|value<<16)
}
func (o *RFSYS_Type) GetREG2_HL() uint32 {
	return (volatile.LoadUint32(&o.REG2.Reg) & 0xff0000) >> 16
}
func (o *RFSYS_Type) SetREG2_HH(value uint32) {
	volatile.StoreUint32(&o.REG2.Reg, volatile.LoadUint32(&o.REG2.Reg)&^(0xff000000)|value<<24)
}
func (o *RFSYS_Type) GetREG2_HH() uint32 {
	return (volatile.LoadUint32(&o.REG2.Reg) & 0xff000000) >> 24
}

// RFSYS.REG3: Register file register
func (o *RFSYS_Type) SetREG3_LL(value uint32) {
	volatile.StoreUint32(&o.REG3.Reg, volatile.LoadUint32(&o.REG3.Reg)&^(0xff)|value)
}
func (o *RFSYS_Type) GetREG3_LL() uint32 {
	return volatile.LoadUint32(&o.REG3.Reg) & 0xff
}
func (o *RFSYS_Type) SetREG3_LH(value uint32) {
	volatile.StoreUint32(&o.REG3.Reg, volatile.LoadUint32(&o.REG3.Reg)&^(0xff00)|value<<8)
}
func (o *RFSYS_Type) GetREG3_LH() uint32 {
	return (volatile.LoadUint32(&o.REG3.Reg) & 0xff00) >> 8
}
func (o *RFSYS_Type) SetREG3_HL(value uint32) {
	volatile.StoreUint32(&o.REG3.Reg, volatile.LoadUint32(&o.REG3.Reg)&^(0xff0000)|value<<16)
}
func (o *RFSYS_Type) GetREG3_HL() uint32 {
	return (volatile.LoadUint32(&o.REG3.Reg) & 0xff0000) >> 16
}
func (o *RFSYS_Type) SetREG3_HH(value uint32) {
	volatile.StoreUint32(&o.REG3.Reg, volatile.LoadUint32(&o.REG3.Reg)&^(0xff000000)|value<<24)
}
func (o *RFSYS_Type) GetREG3_HH() uint32 {
	return (volatile.LoadUint32(&o.REG3.Reg) & 0xff000000) >> 24
}

// RFSYS.REG4: Register file register
func (o *RFSYS_Type) SetREG4_LL(value uint32) {
	volatile.StoreUint32(&o.REG4.Reg, volatile.LoadUint32(&o.REG4.Reg)&^(0xff)|value)
}
func (o *RFSYS_Type) GetREG4_LL() uint32 {
	return volatile.LoadUint32(&o.REG4.Reg) & 0xff
}
func (o *RFSYS_Type) SetREG4_LH(value uint32) {
	volatile.StoreUint32(&o.REG4.Reg, volatile.LoadUint32(&o.REG4.Reg)&^(0xff00)|value<<8)
}
func (o *RFSYS_Type) GetREG4_LH() uint32 {
	return (volatile.LoadUint32(&o.REG4.Reg) & 0xff00) >> 8
}
func (o *RFSYS_Type) SetREG4_HL(value uint32) {
	volatile.StoreUint32(&o.REG4.Reg, volatile.LoadUint32(&o.REG4.Reg)&^(0xff0000)|value<<16)
}
func (o *RFSYS_Type) GetREG4_HL() uint32 {
	return (volatile.LoadUint32(&o.REG4.Reg) & 0xff0000) >> 16
}
func (o *RFSYS_Type) SetREG4_HH(value uint32) {
	volatile.StoreUint32(&o.REG4.Reg, volatile.LoadUint32(&o.REG4.Reg)&^(0xff000000)|value<<24)
}
func (o *RFSYS_Type) GetREG4_HH() uint32 {
	return (volatile.LoadUint32(&o.REG4.Reg) & 0xff000000) >> 24
}

// RFSYS.REG5: Register file register
func (o *RFSYS_Type) SetREG5_LL(value uint32) {
	volatile.StoreUint32(&o.REG5.Reg, volatile.LoadUint32(&o.REG5.Reg)&^(0xff)|value)
}
func (o *RFSYS_Type) GetREG5_LL() uint32 {
	return volatile.LoadUint32(&o.REG5.Reg) & 0xff
}
func (o *RFSYS_Type) SetREG5_LH(value uint32) {
	volatile.StoreUint32(&o.REG5.Reg, volatile.LoadUint32(&o.REG5.Reg)&^(0xff00)|value<<8)
}
func (o *RFSYS_Type) GetREG5_LH() uint32 {
	return (volatile.LoadUint32(&o.REG5.Reg) & 0xff00) >> 8
}
func (o *RFSYS_Type) SetREG5_HL(value uint32) {
	volatile.StoreUint32(&o.REG5.Reg, volatile.LoadUint32(&o.REG5.Reg)&^(0xff0000)|value<<16)
}
func (o *RFSYS_Type) GetREG5_HL() uint32 {
	return (volatile.LoadUint32(&o.REG5.Reg) & 0xff0000) >> 16
}
func (o *RFSYS_Type) SetREG5_HH(value uint32) {
	volatile.StoreUint32(&o.REG5.Reg, volatile.LoadUint32(&o.REG5.Reg)&^(0xff000000)|value<<24)
}
func (o *RFSYS_Type) GetREG5_HH() uint32 {
	return (volatile.LoadUint32(&o.REG5.Reg) & 0xff000000) >> 24
}

// RFSYS.REG6: Register file register
func (o *RFSYS_Type) SetREG6_LL(value uint32) {
	volatile.StoreUint32(&o.REG6.Reg, volatile.LoadUint32(&o.REG6.Reg)&^(0xff)|value)
}
func (o *RFSYS_Type) GetREG6_LL() uint32 {
	return volatile.LoadUint32(&o.REG6.Reg) & 0xff
}
func (o *RFSYS_Type) SetREG6_LH(value uint32) {
	volatile.StoreUint32(&o.REG6.Reg, volatile.LoadUint32(&o.REG6.Reg)&^(0xff00)|value<<8)
}
func (o *RFSYS_Type) GetREG6_LH() uint32 {
	return (volatile.LoadUint32(&o.REG6.Reg) & 0xff00) >> 8
}
func (o *RFSYS_Type) SetREG6_HL(value uint32) {
	volatile.StoreUint32(&o.REG6.Reg, volatile.LoadUint32(&o.REG6.Reg)&^(0xff0000)|value<<16)
}
func (o *RFSYS_Type) GetREG6_HL() uint32 {
	return (volatile.LoadUint32(&o.REG6.Reg) & 0xff0000) >> 16
}
func (o *RFSYS_Type) SetREG6_HH(value uint32) {
	volatile.StoreUint32(&o.REG6.Reg, volatile.LoadUint32(&o.REG6.Reg)&^(0xff000000)|value<<24)
}
func (o *RFSYS_Type) GetREG6_HH() uint32 {
	return (volatile.LoadUint32(&o.REG6.Reg) & 0xff000000) >> 24
}

// RFSYS.REG7: Register file register
func (o *RFSYS_Type) SetREG7_LL(value uint32) {
	volatile.StoreUint32(&o.REG7.Reg, volatile.LoadUint32(&o.REG7.Reg)&^(0xff)|value)
}
func (o *RFSYS_Type) GetREG7_LL() uint32 {
	return volatile.LoadUint32(&o.REG7.Reg) & 0xff
}
func (o *RFSYS_Type) SetREG7_LH(value uint32) {
	volatile.StoreUint32(&o.REG7.Reg, volatile.LoadUint32(&o.REG7.Reg)&^(0xff00)|value<<8)
}
func (o *RFSYS_Type) GetREG7_LH() uint32 {
	return (volatile.LoadUint32(&o.REG7.Reg) & 0xff00) >> 8
}
func (o *RFSYS_Type) SetREG7_HL(value uint32) {
	volatile.StoreUint32(&o.REG7.Reg, volatile.LoadUint32(&o.REG7.Reg)&^(0xff0000)|value<<16)
}
func (o *RFSYS_Type) GetREG7_HL() uint32 {
	return (volatile.LoadUint32(&o.REG7.Reg) & 0xff0000) >> 16
}
func (o *RFSYS_Type) SetREG7_HH(value uint32) {
	volatile.StoreUint32(&o.REG7.Reg, volatile.LoadUint32(&o.REG7.Reg)&^(0xff000000)|value<<24)
}
func (o *RFSYS_Type) GetREG7_HH() uint32 {
	return (volatile.LoadUint32(&o.REG7.Reg) & 0xff000000) >> 24
}

// System Integration Module
type SIM_Type struct {
	SOPT1    volatile.Register32 // 0x0
	SOPT1CFG volatile.Register32 // 0x4
	_        [4092]byte
	SOPT2    volatile.Register32 // 0x1004
	_        [4]byte
	SOPT4    volatile.Register32 // 0x100C
	SOPT5    volatile.Register32 // 0x1010
	_        [4]byte
	SOPT7    volatile.Register32 // 0x1018
	_        [8]byte
	SDID     volatile.Register32 // 0x1024
	SCGC1    volatile.Register32 // 0x1028
	SCGC2    volatile.Register32 // 0x102C
	SCGC3    volatile.Register32 // 0x1030
	SCGC4    volatile.Register32 // 0x1034
	SCGC5    volatile.Register32 // 0x1038
	SCGC6    volatile.Register32 // 0x103C
	SCGC7    volatile.Register32 // 0x1040
	CLKDIV1  volatile.Register32 // 0x1044
	CLKDIV2  volatile.Register32 // 0x1048
	FCFG1    volatile.Register32 // 0x104C
	FCFG2    volatile.Register32 // 0x1050
	UIDH     volatile.Register32 // 0x1054
	UIDMH    volatile.Register32 // 0x1058
	UIDML    volatile.Register32 // 0x105C
	UIDL     volatile.Register32 // 0x1060
}

// SIM.SOPT1: System Options Register 1
func (o *SIM_Type) SetSOPT1_RAMSIZE(value uint32) {
	volatile.StoreUint32(&o.SOPT1.Reg, volatile.LoadUint32(&o.SOPT1.Reg)&^(0xf000)|value<<12)
}
func (o *SIM_Type) GetSOPT1_RAMSIZE() uint32 {
	return (volatile.LoadUint32(&o.SOPT1.Reg) & 0xf000) >> 12
}
func (o *SIM_Type) SetSOPT1_OSC32KSEL(value uint32) {
	volatile.StoreUint32(&o.SOPT1.Reg, volatile.LoadUint32(&o.SOPT1.Reg)&^(0xc0000)|value<<18)
}
func (o *SIM_Type) GetSOPT1_OSC32KSEL() uint32 {
	return (volatile.LoadUint32(&o.SOPT1.Reg) & 0xc0000) >> 18
}
func (o *SIM_Type) SetSOPT1_USBVSTBY(value uint32) {
	volatile.StoreUint32(&o.SOPT1.Reg, volatile.LoadUint32(&o.SOPT1.Reg)&^(0x20000000)|value<<29)
}
func (o *SIM_Type) GetSOPT1_USBVSTBY() uint32 {
	return (volatile.LoadUint32(&o.SOPT1.Reg) & 0x20000000) >> 29
}
func (o *SIM_Type) SetSOPT1_USBSSTBY(value uint32) {
	volatile.StoreUint32(&o.SOPT1.Reg, volatile.LoadUint32(&o.SOPT1.Reg)&^(0x40000000)|value<<30)
}
func (o *SIM_Type) GetSOPT1_USBSSTBY() uint32 {
	return (volatile.LoadUint32(&o.SOPT1.Reg) & 0x40000000) >> 30
}
func (o *SIM_Type) SetSOPT1_USBREGEN(value uint32) {
	volatile.StoreUint32(&o.SOPT1.Reg, volatile.LoadUint32(&o.SOPT1.Reg)&^(0x80000000)|value<<31)
}
func (o *SIM_Type) GetSOPT1_USBREGEN() uint32 {
	return (volatile.LoadUint32(&o.SOPT1.Reg) & 0x80000000) >> 31
}

// SIM.SOPT1CFG: SOPT1 Configuration Register
func (o *SIM_Type) SetSOPT1CFG_URWE(value uint32) {
	volatile.StoreUint32(&o.SOPT1CFG.Reg, volatile.LoadUint32(&o.SOPT1CFG.Reg)&^(0x1000000)|value<<24)
}
func (o *SIM_Type) GetSOPT1CFG_URWE() uint32 {
	return (volatile.LoadUint32(&o.SOPT1CFG.Reg) & 0x1000000) >> 24
}
func (o *SIM_Type) SetSOPT1CFG_UVSWE(value uint32) {
	volatile.StoreUint32(&o.SOPT1CFG.Reg, volatile.LoadUint32(&o.SOPT1CFG.Reg)&^(0x2000000)|value<<25)
}
func (o *SIM_Type) GetSOPT1CFG_UVSWE() uint32 {
	return (volatile.LoadUint32(&o.SOPT1CFG.Reg) & 0x2000000) >> 25
}
func (o *SIM_Type) SetSOPT1CFG_USSWE(value uint32) {
	volatile.StoreUint32(&o.SOPT1CFG.Reg, volatile.LoadUint32(&o.SOPT1CFG.Reg)&^(0x4000000)|value<<26)
}
func (o *SIM_Type) GetSOPT1CFG_USSWE() uint32 {
	return (volatile.LoadUint32(&o.SOPT1CFG.Reg) & 0x4000000) >> 26
}

// SIM.SOPT2: System Options Register 2
func (o *SIM_Type) SetSOPT2_RTCCLKOUTSEL(value uint32) {
	volatile.StoreUint32(&o.SOPT2.Reg, volatile.LoadUint32(&o.SOPT2.Reg)&^(0x10)|value<<4)
}
func (o *SIM_Type) GetSOPT2_RTCCLKOUTSEL() uint32 {
	return (volatile.LoadUint32(&o.SOPT2.Reg) & 0x10) >> 4
}
func (o *SIM_Type) SetSOPT2_CLKOUTSEL(value uint32) {
	volatile.StoreUint32(&o.SOPT2.Reg, volatile.LoadUint32(&o.SOPT2.Reg)&^(0xe0)|value<<5)
}
func (o *SIM_Type) GetSOPT2_CLKOUTSEL() uint32 {
	return (volatile.LoadUint32(&o.SOPT2.Reg) & 0xe0) >> 5
}
func (o *SIM_Type) SetSOPT2_FBSL(value uint32) {
	volatile.StoreUint32(&o.SOPT2.Reg, volatile.LoadUint32(&o.SOPT2.Reg)&^(0x300)|value<<8)
}
func (o *SIM_Type) GetSOPT2_FBSL() uint32 {
	return (volatile.LoadUint32(&o.SOPT2.Reg) & 0x300) >> 8
}
func (o *SIM_Type) SetSOPT2_PTD7PAD(value uint32) {
	volatile.StoreUint32(&o.SOPT2.Reg, volatile.LoadUint32(&o.SOPT2.Reg)&^(0x800)|value<<11)
}
func (o *SIM_Type) GetSOPT2_PTD7PAD() uint32 {
	return (volatile.LoadUint32(&o.SOPT2.Reg) & 0x800) >> 11
}
func (o *SIM_Type) SetSOPT2_TRACECLKSEL(value uint32) {
	volatile.StoreUint32(&o.SOPT2.Reg, volatile.LoadUint32(&o.SOPT2.Reg)&^(0x1000)|value<<12)
}
func (o *SIM_Type) GetSOPT2_TRACECLKSEL() uint32 {
	return (volatile.LoadUint32(&o.SOPT2.Reg) & 0x1000) >> 12
}
func (o *SIM_Type) SetSOPT2_PLLFLLSEL(value uint32) {
	volatile.StoreUint32(&o.SOPT2.Reg, volatile.LoadUint32(&o.SOPT2.Reg)&^(0x30000)|value<<16)
}
func (o *SIM_Type) GetSOPT2_PLLFLLSEL() uint32 {
	return (volatile.LoadUint32(&o.SOPT2.Reg) & 0x30000) >> 16
}
func (o *SIM_Type) SetSOPT2_USBSRC(value uint32) {
	volatile.StoreUint32(&o.SOPT2.Reg, volatile.LoadUint32(&o.SOPT2.Reg)&^(0x40000)|value<<18)
}
func (o *SIM_Type) GetSOPT2_USBSRC() uint32 {
	return (volatile.LoadUint32(&o.SOPT2.Reg) & 0x40000) >> 18
}
func (o *SIM_Type) SetSOPT2_RMIISRC(value uint32) {
	volatile.StoreUint32(&o.SOPT2.Reg, volatile.LoadUint32(&o.SOPT2.Reg)&^(0x80000)|value<<19)
}
func (o *SIM_Type) GetSOPT2_RMIISRC() uint32 {
	return (volatile.LoadUint32(&o.SOPT2.Reg) & 0x80000) >> 19
}
func (o *SIM_Type) SetSOPT2_TIMESRC(value uint32) {
	volatile.StoreUint32(&o.SOPT2.Reg, volatile.LoadUint32(&o.SOPT2.Reg)&^(0x300000)|value<<20)
}
func (o *SIM_Type) GetSOPT2_TIMESRC() uint32 {
	return (volatile.LoadUint32(&o.SOPT2.Reg) & 0x300000) >> 20
}
func (o *SIM_Type) SetSOPT2_SDHCSRC(value uint32) {
	volatile.StoreUint32(&o.SOPT2.Reg, volatile.LoadUint32(&o.SOPT2.Reg)&^(0x30000000)|value<<28)
}
func (o *SIM_Type) GetSOPT2_SDHCSRC() uint32 {
	return (volatile.LoadUint32(&o.SOPT2.Reg) & 0x30000000) >> 28
}

// SIM.SOPT4: System Options Register 4
func (o *SIM_Type) SetSOPT4_FTM0FLT0(value uint32) {
	volatile.StoreUint32(&o.SOPT4.Reg, volatile.LoadUint32(&o.SOPT4.Reg)&^(0x1)|value)
}
func (o *SIM_Type) GetSOPT4_FTM0FLT0() uint32 {
	return volatile.LoadUint32(&o.SOPT4.Reg) & 0x1
}
func (o *SIM_Type) SetSOPT4_FTM0FLT1(value uint32) {
	volatile.StoreUint32(&o.SOPT4.Reg, volatile.LoadUint32(&o.SOPT4.Reg)&^(0x2)|value<<1)
}
func (o *SIM_Type) GetSOPT4_FTM0FLT1() uint32 {
	return (volatile.LoadUint32(&o.SOPT4.Reg) & 0x2) >> 1
}
func (o *SIM_Type) SetSOPT4_FTM0FLT2(value uint32) {
	volatile.StoreUint32(&o.SOPT4.Reg, volatile.LoadUint32(&o.SOPT4.Reg)&^(0x4)|value<<2)
}
func (o *SIM_Type) GetSOPT4_FTM0FLT2() uint32 {
	return (volatile.LoadUint32(&o.SOPT4.Reg) & 0x4) >> 2
}
func (o *SIM_Type) SetSOPT4_FTM1FLT0(value uint32) {
	volatile.StoreUint32(&o.SOPT4.Reg, volatile.LoadUint32(&o.SOPT4.Reg)&^(0x10)|value<<4)
}
func (o *SIM_Type) GetSOPT4_FTM1FLT0() uint32 {
	return (volatile.LoadUint32(&o.SOPT4.Reg) & 0x10) >> 4
}
func (o *SIM_Type) SetSOPT4_FTM2FLT0(value uint32) {
	volatile.StoreUint32(&o.SOPT4.Reg, volatile.LoadUint32(&o.SOPT4.Reg)&^(0x100)|value<<8)
}
func (o *SIM_Type) GetSOPT4_FTM2FLT0() uint32 {
	return (volatile.LoadUint32(&o.SOPT4.Reg) & 0x100) >> 8
}
func (o *SIM_Type) SetSOPT4_FTM3FLT0(value uint32) {
	volatile.StoreUint32(&o.SOPT4.Reg, volatile.LoadUint32(&o.SOPT4.Reg)&^(0x1000)|value<<12)
}
func (o *SIM_Type) GetSOPT4_FTM3FLT0() uint32 {
	return (volatile.LoadUint32(&o.SOPT4.Reg) & 0x1000) >> 12
}
func (o *SIM_Type) SetSOPT4_FTM1CH0SRC(value uint32) {
	volatile.StoreUint32(&o.SOPT4.Reg, volatile.LoadUint32(&o.SOPT4.Reg)&^(0xc0000)|value<<18)
}
func (o *SIM_Type) GetSOPT4_FTM1CH0SRC() uint32 {
	return (volatile.LoadUint32(&o.SOPT4.Reg) & 0xc0000) >> 18
}
func (o *SIM_Type) SetSOPT4_FTM2CH0SRC(value uint32) {
	volatile.StoreUint32(&o.SOPT4.Reg, volatile.LoadUint32(&o.SOPT4.Reg)&^(0x300000)|value<<20)
}
func (o *SIM_Type) GetSOPT4_FTM2CH0SRC() uint32 {
	return (volatile.LoadUint32(&o.SOPT4.Reg) & 0x300000) >> 20
}
func (o *SIM_Type) SetSOPT4_FTM0CLKSEL(value uint32) {
	volatile.StoreUint32(&o.SOPT4.Reg, volatile.LoadUint32(&o.SOPT4.Reg)&^(0x1000000)|value<<24)
}
func (o *SIM_Type) GetSOPT4_FTM0CLKSEL() uint32 {
	return (volatile.LoadUint32(&o.SOPT4.Reg) & 0x1000000) >> 24
}
func (o *SIM_Type) SetSOPT4_FTM1CLKSEL(value uint32) {
	volatile.StoreUint32(&o.SOPT4.Reg, volatile.LoadUint32(&o.SOPT4.Reg)&^(0x2000000)|value<<25)
}
func (o *SIM_Type) GetSOPT4_FTM1CLKSEL() uint32 {
	return (volatile.LoadUint32(&o.SOPT4.Reg) & 0x2000000) >> 25
}
func (o *SIM_Type) SetSOPT4_FTM2CLKSEL(value uint32) {
	volatile.StoreUint32(&o.SOPT4.Reg, volatile.LoadUint32(&o.SOPT4.Reg)&^(0x4000000)|value<<26)
}
func (o *SIM_Type) GetSOPT4_FTM2CLKSEL() uint32 {
	return (volatile.LoadUint32(&o.SOPT4.Reg) & 0x4000000) >> 26
}
func (o *SIM_Type) SetSOPT4_FTM3CLKSEL(value uint32) {
	volatile.StoreUint32(&o.SOPT4.Reg, volatile.LoadUint32(&o.SOPT4.Reg)&^(0x8000000)|value<<27)
}
func (o *SIM_Type) GetSOPT4_FTM3CLKSEL() uint32 {
	return (volatile.LoadUint32(&o.SOPT4.Reg) & 0x8000000) >> 27
}
func (o *SIM_Type) SetSOPT4_FTM0TRG0SRC(value uint32) {
	volatile.StoreUint32(&o.SOPT4.Reg, volatile.LoadUint32(&o.SOPT4.Reg)&^(0x10000000)|value<<28)
}
func (o *SIM_Type) GetSOPT4_FTM0TRG0SRC() uint32 {
	return (volatile.LoadUint32(&o.SOPT4.Reg) & 0x10000000) >> 28
}
func (o *SIM_Type) SetSOPT4_FTM0TRG1SRC(value uint32) {
	volatile.StoreUint32(&o.SOPT4.Reg, volatile.LoadUint32(&o.SOPT4.Reg)&^(0x20000000)|value<<29)
}
func (o *SIM_Type) GetSOPT4_FTM0TRG1SRC() uint32 {
	return (volatile.LoadUint32(&o.SOPT4.Reg) & 0x20000000) >> 29
}
func (o *SIM_Type) SetSOPT4_FTM3TRG0SRC(value uint32) {
	volatile.StoreUint32(&o.SOPT4.Reg, volatile.LoadUint32(&o.SOPT4.Reg)&^(0x40000000)|value<<30)
}
func (o *SIM_Type) GetSOPT4_FTM3TRG0SRC() uint32 {
	return (volatile.LoadUint32(&o.SOPT4.Reg) & 0x40000000) >> 30
}
func (o *SIM_Type) SetSOPT4_FTM3TRG1SRC(value uint32) {
	volatile.StoreUint32(&o.SOPT4.Reg, volatile.LoadUint32(&o.SOPT4.Reg)&^(0x80000000)|value<<31)
}
func (o *SIM_Type) GetSOPT4_FTM3TRG1SRC() uint32 {
	return (volatile.LoadUint32(&o.SOPT4.Reg) & 0x80000000) >> 31
}

// SIM.SOPT5: System Options Register 5
func (o *SIM_Type) SetSOPT5_UART0TXSRC(value uint32) {
	volatile.StoreUint32(&o.SOPT5.Reg, volatile.LoadUint32(&o.SOPT5.Reg)&^(0x3)|value)
}
func (o *SIM_Type) GetSOPT5_UART0TXSRC() uint32 {
	return volatile.LoadUint32(&o.SOPT5.Reg) & 0x3
}
func (o *SIM_Type) SetSOPT5_UART0RXSRC(value uint32) {
	volatile.StoreUint32(&o.SOPT5.Reg, volatile.LoadUint32(&o.SOPT5.Reg)&^(0xc)|value<<2)
}
func (o *SIM_Type) GetSOPT5_UART0RXSRC() uint32 {
	return (volatile.LoadUint32(&o.SOPT5.Reg) & 0xc) >> 2
}
func (o *SIM_Type) SetSOPT5_UART1TXSRC(value uint32) {
	volatile.StoreUint32(&o.SOPT5.Reg, volatile.LoadUint32(&o.SOPT5.Reg)&^(0x30)|value<<4)
}
func (o *SIM_Type) GetSOPT5_UART1TXSRC() uint32 {
	return (volatile.LoadUint32(&o.SOPT5.Reg) & 0x30) >> 4
}
func (o *SIM_Type) SetSOPT5_UART1RXSRC(value uint32) {
	volatile.StoreUint32(&o.SOPT5.Reg, volatile.LoadUint32(&o.SOPT5.Reg)&^(0xc0)|value<<6)
}
func (o *SIM_Type) GetSOPT5_UART1RXSRC() uint32 {
	return (volatile.LoadUint32(&o.SOPT5.Reg) & 0xc0) >> 6
}

// SIM.SOPT7: System Options Register 7
func (o *SIM_Type) SetSOPT7_ADC0TRGSEL(value uint32) {
	volatile.StoreUint32(&o.SOPT7.Reg, volatile.LoadUint32(&o.SOPT7.Reg)&^(0xf)|value)
}
func (o *SIM_Type) GetSOPT7_ADC0TRGSEL() uint32 {
	return volatile.LoadUint32(&o.SOPT7.Reg) & 0xf
}
func (o *SIM_Type) SetSOPT7_ADC0PRETRGSEL(value uint32) {
	volatile.StoreUint32(&o.SOPT7.Reg, volatile.LoadUint32(&o.SOPT7.Reg)&^(0x10)|value<<4)
}
func (o *SIM_Type) GetSOPT7_ADC0PRETRGSEL() uint32 {
	return (volatile.LoadUint32(&o.SOPT7.Reg) & 0x10) >> 4
}
func (o *SIM_Type) SetSOPT7_ADC0ALTTRGEN(value uint32) {
	volatile.StoreUint32(&o.SOPT7.Reg, volatile.LoadUint32(&o.SOPT7.Reg)&^(0x80)|value<<7)
}
func (o *SIM_Type) GetSOPT7_ADC0ALTTRGEN() uint32 {
	return (volatile.LoadUint32(&o.SOPT7.Reg) & 0x80) >> 7
}
func (o *SIM_Type) SetSOPT7_ADC1TRGSEL(value uint32) {
	volatile.StoreUint32(&o.SOPT7.Reg, volatile.LoadUint32(&o.SOPT7.Reg)&^(0xf00)|value<<8)
}
func (o *SIM_Type) GetSOPT7_ADC1TRGSEL() uint32 {
	return (volatile.LoadUint32(&o.SOPT7.Reg) & 0xf00) >> 8
}
func (o *SIM_Type) SetSOPT7_ADC1PRETRGSEL(value uint32) {
	volatile.StoreUint32(&o.SOPT7.Reg, volatile.LoadUint32(&o.SOPT7.Reg)&^(0x1000)|value<<12)
}
func (o *SIM_Type) GetSOPT7_ADC1PRETRGSEL() uint32 {
	return (volatile.LoadUint32(&o.SOPT7.Reg) & 0x1000) >> 12
}
func (o *SIM_Type) SetSOPT7_ADC1ALTTRGEN(value uint32) {
	volatile.StoreUint32(&o.SOPT7.Reg, volatile.LoadUint32(&o.SOPT7.Reg)&^(0x8000)|value<<15)
}
func (o *SIM_Type) GetSOPT7_ADC1ALTTRGEN() uint32 {
	return (volatile.LoadUint32(&o.SOPT7.Reg) & 0x8000) >> 15
}

// SIM.SDID: System Device Identification Register
func (o *SIM_Type) SetSDID_PINID(value uint32) {
	volatile.StoreUint32(&o.SDID.Reg, volatile.LoadUint32(&o.SDID.Reg)&^(0xf)|value)
}
func (o *SIM_Type) GetSDID_PINID() uint32 {
	return volatile.LoadUint32(&o.SDID.Reg) & 0xf
}
func (o *SIM_Type) SetSDID_FAMID(value uint32) {
	volatile.StoreUint32(&o.SDID.Reg, volatile.LoadUint32(&o.SDID.Reg)&^(0x70)|value<<4)
}
func (o *SIM_Type) GetSDID_FAMID() uint32 {
	return (volatile.LoadUint32(&o.SDID.Reg) & 0x70) >> 4
}
func (o *SIM_Type) SetSDID_DIEID(value uint32) {
	volatile.StoreUint32(&o.SDID.Reg, volatile.LoadUint32(&o.SDID.Reg)&^(0xf80)|value<<7)
}
func (o *SIM_Type) GetSDID_DIEID() uint32 {
	return (volatile.LoadUint32(&o.SDID.Reg) & 0xf80) >> 7
}
func (o *SIM_Type) SetSDID_REVID(value uint32) {
	volatile.StoreUint32(&o.SDID.Reg, volatile.LoadUint32(&o.SDID.Reg)&^(0xf000)|value<<12)
}
func (o *SIM_Type) GetSDID_REVID() uint32 {
	return (volatile.LoadUint32(&o.SDID.Reg) & 0xf000) >> 12
}
func (o *SIM_Type) SetSDID_SERIESID(value uint32) {
	volatile.StoreUint32(&o.SDID.Reg, volatile.LoadUint32(&o.SDID.Reg)&^(0xf00000)|value<<20)
}
func (o *SIM_Type) GetSDID_SERIESID() uint32 {
	return (volatile.LoadUint32(&o.SDID.Reg) & 0xf00000) >> 20
}
func (o *SIM_Type) SetSDID_SUBFAMID(value uint32) {
	volatile.StoreUint32(&o.SDID.Reg, volatile.LoadUint32(&o.SDID.Reg)&^(0xf000000)|value<<24)
}
func (o *SIM_Type) GetSDID_SUBFAMID() uint32 {
	return (volatile.LoadUint32(&o.SDID.Reg) & 0xf000000) >> 24
}
func (o *SIM_Type) SetSDID_FAMILYID(value uint32) {
	volatile.StoreUint32(&o.SDID.Reg, volatile.LoadUint32(&o.SDID.Reg)&^(0xf0000000)|value<<28)
}
func (o *SIM_Type) GetSDID_FAMILYID() uint32 {
	return (volatile.LoadUint32(&o.SDID.Reg) & 0xf0000000) >> 28
}

// SIM.SCGC1: System Clock Gating Control Register 1
func (o *SIM_Type) SetSCGC1_I2C2(value uint32) {
	volatile.StoreUint32(&o.SCGC1.Reg, volatile.LoadUint32(&o.SCGC1.Reg)&^(0x40)|value<<6)
}
func (o *SIM_Type) GetSCGC1_I2C2() uint32 {
	return (volatile.LoadUint32(&o.SCGC1.Reg) & 0x40) >> 6
}
func (o *SIM_Type) SetSCGC1_UART4(value uint32) {
	volatile.StoreUint32(&o.SCGC1.Reg, volatile.LoadUint32(&o.SCGC1.Reg)&^(0x400)|value<<10)
}
func (o *SIM_Type) GetSCGC1_UART4() uint32 {
	return (volatile.LoadUint32(&o.SCGC1.Reg) & 0x400) >> 10
}
func (o *SIM_Type) SetSCGC1_UART5(value uint32) {
	volatile.StoreUint32(&o.SCGC1.Reg, volatile.LoadUint32(&o.SCGC1.Reg)&^(0x800)|value<<11)
}
func (o *SIM_Type) GetSCGC1_UART5() uint32 {
	return (volatile.LoadUint32(&o.SCGC1.Reg) & 0x800) >> 11
}

// SIM.SCGC2: System Clock Gating Control Register 2
func (o *SIM_Type) SetSCGC2_ENET(value uint32) {
	volatile.StoreUint32(&o.SCGC2.Reg, volatile.LoadUint32(&o.SCGC2.Reg)&^(0x1)|value)
}
func (o *SIM_Type) GetSCGC2_ENET() uint32 {
	return volatile.LoadUint32(&o.SCGC2.Reg) & 0x1
}
func (o *SIM_Type) SetSCGC2_DAC0(value uint32) {
	volatile.StoreUint32(&o.SCGC2.Reg, volatile.LoadUint32(&o.SCGC2.Reg)&^(0x1000)|value<<12)
}
func (o *SIM_Type) GetSCGC2_DAC0() uint32 {
	return (volatile.LoadUint32(&o.SCGC2.Reg) & 0x1000) >> 12
}
func (o *SIM_Type) SetSCGC2_DAC1(value uint32) {
	volatile.StoreUint32(&o.SCGC2.Reg, volatile.LoadUint32(&o.SCGC2.Reg)&^(0x2000)|value<<13)
}
func (o *SIM_Type) GetSCGC2_DAC1() uint32 {
	return (volatile.LoadUint32(&o.SCGC2.Reg) & 0x2000) >> 13
}

// SIM.SCGC3: System Clock Gating Control Register 3
func (o *SIM_Type) SetSCGC3_RNGA(value uint32) {
	volatile.StoreUint32(&o.SCGC3.Reg, volatile.LoadUint32(&o.SCGC3.Reg)&^(0x1)|value)
}
func (o *SIM_Type) GetSCGC3_RNGA() uint32 {
	return volatile.LoadUint32(&o.SCGC3.Reg) & 0x1
}
func (o *SIM_Type) SetSCGC3_SPI2(value uint32) {
	volatile.StoreUint32(&o.SCGC3.Reg, volatile.LoadUint32(&o.SCGC3.Reg)&^(0x1000)|value<<12)
}
func (o *SIM_Type) GetSCGC3_SPI2() uint32 {
	return (volatile.LoadUint32(&o.SCGC3.Reg) & 0x1000) >> 12
}
func (o *SIM_Type) SetSCGC3_SDHC(value uint32) {
	volatile.StoreUint32(&o.SCGC3.Reg, volatile.LoadUint32(&o.SCGC3.Reg)&^(0x20000)|value<<17)
}
func (o *SIM_Type) GetSCGC3_SDHC() uint32 {
	return (volatile.LoadUint32(&o.SCGC3.Reg) & 0x20000) >> 17
}
func (o *SIM_Type) SetSCGC3_FTM2(value uint32) {
	volatile.StoreUint32(&o.SCGC3.Reg, volatile.LoadUint32(&o.SCGC3.Reg)&^(0x1000000)|value<<24)
}
func (o *SIM_Type) GetSCGC3_FTM2() uint32 {
	return (volatile.LoadUint32(&o.SCGC3.Reg) & 0x1000000) >> 24
}
func (o *SIM_Type) SetSCGC3_FTM3(value uint32) {
	volatile.StoreUint32(&o.SCGC3.Reg, volatile.LoadUint32(&o.SCGC3.Reg)&^(0x2000000)|value<<25)
}
func (o *SIM_Type) GetSCGC3_FTM3() uint32 {
	return (volatile.LoadUint32(&o.SCGC3.Reg) & 0x2000000) >> 25
}
func (o *SIM_Type) SetSCGC3_ADC1(value uint32) {
	volatile.StoreUint32(&o.SCGC3.Reg, volatile.LoadUint32(&o.SCGC3.Reg)&^(0x8000000)|value<<27)
}
func (o *SIM_Type) GetSCGC3_ADC1() uint32 {
	return (volatile.LoadUint32(&o.SCGC3.Reg) & 0x8000000) >> 27
}

// SIM.SCGC4: System Clock Gating Control Register 4
func (o *SIM_Type) SetSCGC4_EWM(value uint32) {
	volatile.StoreUint32(&o.SCGC4.Reg, volatile.LoadUint32(&o.SCGC4.Reg)&^(0x2)|value<<1)
}
func (o *SIM_Type) GetSCGC4_EWM() uint32 {
	return (volatile.LoadUint32(&o.SCGC4.Reg) & 0x2) >> 1
}
func (o *SIM_Type) SetSCGC4_CMT(value uint32) {
	volatile.StoreUint32(&o.SCGC4.Reg, volatile.LoadUint32(&o.SCGC4.Reg)&^(0x4)|value<<2)
}
func (o *SIM_Type) GetSCGC4_CMT() uint32 {
	return (volatile.LoadUint32(&o.SCGC4.Reg) & 0x4) >> 2
}
func (o *SIM_Type) SetSCGC4_I2C0(value uint32) {
	volatile.StoreUint32(&o.SCGC4.Reg, volatile.LoadUint32(&o.SCGC4.Reg)&^(0x40)|value<<6)
}
func (o *SIM_Type) GetSCGC4_I2C0() uint32 {
	return (volatile.LoadUint32(&o.SCGC4.Reg) & 0x40) >> 6
}
func (o *SIM_Type) SetSCGC4_I2C1(value uint32) {
	volatile.StoreUint32(&o.SCGC4.Reg, volatile.LoadUint32(&o.SCGC4.Reg)&^(0x80)|value<<7)
}
func (o *SIM_Type) GetSCGC4_I2C1() uint32 {
	return (volatile.LoadUint32(&o.SCGC4.Reg) & 0x80) >> 7
}
func (o *SIM_Type) SetSCGC4_UART0(value uint32) {
	volatile.StoreUint32(&o.SCGC4.Reg, volatile.LoadUint32(&o.SCGC4.Reg)&^(0x400)|value<<10)
}
func (o *SIM_Type) GetSCGC4_UART0() uint32 {
	return (volatile.LoadUint32(&o.SCGC4.Reg) & 0x400) >> 10
}
func (o *SIM_Type) SetSCGC4_UART1(value uint32) {
	volatile.StoreUint32(&o.SCGC4.Reg, volatile.LoadUint32(&o.SCGC4.Reg)&^(0x800)|value<<11)
}
func (o *SIM_Type) GetSCGC4_UART1() uint32 {
	return (volatile.LoadUint32(&o.SCGC4.Reg) & 0x800) >> 11
}
func (o *SIM_Type) SetSCGC4_UART2(value uint32) {
	volatile.StoreUint32(&o.SCGC4.Reg, volatile.LoadUint32(&o.SCGC4.Reg)&^(0x1000)|value<<12)
}
func (o *SIM_Type) GetSCGC4_UART2() uint32 {
	return (volatile.LoadUint32(&o.SCGC4.Reg) & 0x1000) >> 12
}
func (o *SIM_Type) SetSCGC4_UART3(value uint32) {
	volatile.StoreUint32(&o.SCGC4.Reg, volatile.LoadUint32(&o.SCGC4.Reg)&^(0x2000)|value<<13)
}
func (o *SIM_Type) GetSCGC4_UART3() uint32 {
	return (volatile.LoadUint32(&o.SCGC4.Reg) & 0x2000) >> 13
}
func (o *SIM_Type) SetSCGC4_USBOTG(value uint32) {
	volatile.StoreUint32(&o.SCGC4.Reg, volatile.LoadUint32(&o.SCGC4.Reg)&^(0x40000)|value<<18)
}
func (o *SIM_Type) GetSCGC4_USBOTG() uint32 {
	return (volatile.LoadUint32(&o.SCGC4.Reg) & 0x40000) >> 18
}
func (o *SIM_Type) SetSCGC4_CMP(value uint32) {
	volatile.StoreUint32(&o.SCGC4.Reg, volatile.LoadUint32(&o.SCGC4.Reg)&^(0x80000)|value<<19)
}
func (o *SIM_Type) GetSCGC4_CMP() uint32 {
	return (volatile.LoadUint32(&o.SCGC4.Reg) & 0x80000) >> 19
}
func (o *SIM_Type) SetSCGC4_VREF(value uint32) {
	volatile.StoreUint32(&o.SCGC4.Reg, volatile.LoadUint32(&o.SCGC4.Reg)&^(0x100000)|value<<20)
}
func (o *SIM_Type) GetSCGC4_VREF() uint32 {
	return (volatile.LoadUint32(&o.SCGC4.Reg) & 0x100000) >> 20
}

// SIM.SCGC5: System Clock Gating Control Register 5
func (o *SIM_Type) SetSCGC5_LPTMR(value uint32) {
	volatile.StoreUint32(&o.SCGC5.Reg, volatile.LoadUint32(&o.SCGC5.Reg)&^(0x1)|value)
}
func (o *SIM_Type) GetSCGC5_LPTMR() uint32 {
	return volatile.LoadUint32(&o.SCGC5.Reg) & 0x1
}
func (o *SIM_Type) SetSCGC5_PORTA(value uint32) {
	volatile.StoreUint32(&o.SCGC5.Reg, volatile.LoadUint32(&o.SCGC5.Reg)&^(0x200)|value<<9)
}
func (o *SIM_Type) GetSCGC5_PORTA() uint32 {
	return (volatile.LoadUint32(&o.SCGC5.Reg) & 0x200) >> 9
}
func (o *SIM_Type) SetSCGC5_PORTB(value uint32) {
	volatile.StoreUint32(&o.SCGC5.Reg, volatile.LoadUint32(&o.SCGC5.Reg)&^(0x400)|value<<10)
}
func (o *SIM_Type) GetSCGC5_PORTB() uint32 {
	return (volatile.LoadUint32(&o.SCGC5.Reg) & 0x400) >> 10
}
func (o *SIM_Type) SetSCGC5_PORTC(value uint32) {
	volatile.StoreUint32(&o.SCGC5.Reg, volatile.LoadUint32(&o.SCGC5.Reg)&^(0x800)|value<<11)
}
func (o *SIM_Type) GetSCGC5_PORTC() uint32 {
	return (volatile.LoadUint32(&o.SCGC5.Reg) & 0x800) >> 11
}
func (o *SIM_Type) SetSCGC5_PORTD(value uint32) {
	volatile.StoreUint32(&o.SCGC5.Reg, volatile.LoadUint32(&o.SCGC5.Reg)&^(0x1000)|value<<12)
}
func (o *SIM_Type) GetSCGC5_PORTD() uint32 {
	return (volatile.LoadUint32(&o.SCGC5.Reg) & 0x1000) >> 12
}
func (o *SIM_Type) SetSCGC5_PORTE(value uint32) {
	volatile.StoreUint32(&o.SCGC5.Reg, volatile.LoadUint32(&o.SCGC5.Reg)&^(0x2000)|value<<13)
}
func (o *SIM_Type) GetSCGC5_PORTE() uint32 {
	return (volatile.LoadUint32(&o.SCGC5.Reg) & 0x2000) >> 13
}

// SIM.SCGC6: System Clock Gating Control Register 6
func (o *SIM_Type) SetSCGC6_FTF(value uint32) {
	volatile.StoreUint32(&o.SCGC6.Reg, volatile.LoadUint32(&o.SCGC6.Reg)&^(0x1)|value)
}
func (o *SIM_Type) GetSCGC6_FTF() uint32 {
	return volatile.LoadUint32(&o.SCGC6.Reg) & 0x1
}
func (o *SIM_Type) SetSCGC6_DMAMUX(value uint32) {
	volatile.StoreUint32(&o.SCGC6.Reg, volatile.LoadUint32(&o.SCGC6.Reg)&^(0x2)|value<<1)
}
func (o *SIM_Type) GetSCGC6_DMAMUX() uint32 {
	return (volatile.LoadUint32(&o.SCGC6.Reg) & 0x2) >> 1
}
func (o *SIM_Type) SetSCGC6_FLEXCAN0(value uint32) {
	volatile.StoreUint32(&o.SCGC6.Reg, volatile.LoadUint32(&o.SCGC6.Reg)&^(0x10)|value<<4)
}
func (o *SIM_Type) GetSCGC6_FLEXCAN0() uint32 {
	return (volatile.LoadUint32(&o.SCGC6.Reg) & 0x10) >> 4
}
func (o *SIM_Type) SetSCGC6_RNGA(value uint32) {
	volatile.StoreUint32(&o.SCGC6.Reg, volatile.LoadUint32(&o.SCGC6.Reg)&^(0x200)|value<<9)
}
func (o *SIM_Type) GetSCGC6_RNGA() uint32 {
	return (volatile.LoadUint32(&o.SCGC6.Reg) & 0x200) >> 9
}
func (o *SIM_Type) SetSCGC6_SPI0(value uint32) {
	volatile.StoreUint32(&o.SCGC6.Reg, volatile.LoadUint32(&o.SCGC6.Reg)&^(0x1000)|value<<12)
}
func (o *SIM_Type) GetSCGC6_SPI0() uint32 {
	return (volatile.LoadUint32(&o.SCGC6.Reg) & 0x1000) >> 12
}
func (o *SIM_Type) SetSCGC6_SPI1(value uint32) {
	volatile.StoreUint32(&o.SCGC6.Reg, volatile.LoadUint32(&o.SCGC6.Reg)&^(0x2000)|value<<13)
}
func (o *SIM_Type) GetSCGC6_SPI1() uint32 {
	return (volatile.LoadUint32(&o.SCGC6.Reg) & 0x2000) >> 13
}
func (o *SIM_Type) SetSCGC6_I2S(value uint32) {
	volatile.StoreUint32(&o.SCGC6.Reg, volatile.LoadUint32(&o.SCGC6.Reg)&^(0x8000)|value<<15)
}
func (o *SIM_Type) GetSCGC6_I2S() uint32 {
	return (volatile.LoadUint32(&o.SCGC6.Reg) & 0x8000) >> 15
}
func (o *SIM_Type) SetSCGC6_CRC(value uint32) {
	volatile.StoreUint32(&o.SCGC6.Reg, volatile.LoadUint32(&o.SCGC6.Reg)&^(0x40000)|value<<18)
}
func (o *SIM_Type) GetSCGC6_CRC() uint32 {
	return (volatile.LoadUint32(&o.SCGC6.Reg) & 0x40000) >> 18
}
func (o *SIM_Type) SetSCGC6_USBDCD(value uint32) {
	volatile.StoreUint32(&o.SCGC6.Reg, volatile.LoadUint32(&o.SCGC6.Reg)&^(0x200000)|value<<21)
}
func (o *SIM_Type) GetSCGC6_USBDCD() uint32 {
	return (volatile.LoadUint32(&o.SCGC6.Reg) & 0x200000) >> 21
}
func (o *SIM_Type) SetSCGC6_PDB(value uint32) {
	volatile.StoreUint32(&o.SCGC6.Reg, volatile.LoadUint32(&o.SCGC6.Reg)&^(0x400000)|value<<22)
}
func (o *SIM_Type) GetSCGC6_PDB() uint32 {
	return (volatile.LoadUint32(&o.SCGC6.Reg) & 0x400000) >> 22
}
func (o *SIM_Type) SetSCGC6_PIT(value uint32) {
	volatile.StoreUint32(&o.SCGC6.Reg, volatile.LoadUint32(&o.SCGC6.Reg)&^(0x800000)|value<<23)
}
func (o *SIM_Type) GetSCGC6_PIT() uint32 {
	return (volatile.LoadUint32(&o.SCGC6.Reg) & 0x800000) >> 23
}
func (o *SIM_Type) SetSCGC6_FTM0(value uint32) {
	volatile.StoreUint32(&o.SCGC6.Reg, volatile.LoadUint32(&o.SCGC6.Reg)&^(0x1000000)|value<<24)
}
func (o *SIM_Type) GetSCGC6_FTM0() uint32 {
	return (volatile.LoadUint32(&o.SCGC6.Reg) & 0x1000000) >> 24
}
func (o *SIM_Type) SetSCGC6_FTM1(value uint32) {
	volatile.StoreUint32(&o.SCGC6.Reg, volatile.LoadUint32(&o.SCGC6.Reg)&^(0x2000000)|value<<25)
}
func (o *SIM_Type) GetSCGC6_FTM1() uint32 {
	return (volatile.LoadUint32(&o.SCGC6.Reg) & 0x2000000) >> 25
}
func (o *SIM_Type) SetSCGC6_FTM2(value uint32) {
	volatile.StoreUint32(&o.SCGC6.Reg, volatile.LoadUint32(&o.SCGC6.Reg)&^(0x4000000)|value<<26)
}
func (o *SIM_Type) GetSCGC6_FTM2() uint32 {
	return (volatile.LoadUint32(&o.SCGC6.Reg) & 0x4000000) >> 26
}
func (o *SIM_Type) SetSCGC6_ADC0(value uint32) {
	volatile.StoreUint32(&o.SCGC6.Reg, volatile.LoadUint32(&o.SCGC6.Reg)&^(0x8000000)|value<<27)
}
func (o *SIM_Type) GetSCGC6_ADC0() uint32 {
	return (volatile.LoadUint32(&o.SCGC6.Reg) & 0x8000000) >> 27
}
func (o *SIM_Type) SetSCGC6_RTC(value uint32) {
	volatile.StoreUint32(&o.SCGC6.Reg, volatile.LoadUint32(&o.SCGC6.Reg)&^(0x20000000)|value<<29)
}
func (o *SIM_Type) GetSCGC6_RTC() uint32 {
	return (volatile.LoadUint32(&o.SCGC6.Reg) & 0x20000000) >> 29
}
func (o *SIM_Type) SetSCGC6_DAC0(value uint32) {
	volatile.StoreUint32(&o.SCGC6.Reg, volatile.LoadUint32(&o.SCGC6.Reg)&^(0x80000000)|value<<31)
}
func (o *SIM_Type) GetSCGC6_DAC0() uint32 {
	return (volatile.LoadUint32(&o.SCGC6.Reg) & 0x80000000) >> 31
}

// SIM.SCGC7: System Clock Gating Control Register 7
func (o *SIM_Type) SetSCGC7_FLEXBUS(value uint32) {
	volatile.StoreUint32(&o.SCGC7.Reg, volatile.LoadUint32(&o.SCGC7.Reg)&^(0x1)|value)
}
func (o *SIM_Type) GetSCGC7_FLEXBUS() uint32 {
	return volatile.LoadUint32(&o.SCGC7.Reg) & 0x1
}
func (o *SIM_Type) SetSCGC7_DMA(value uint32) {
	volatile.StoreUint32(&o.SCGC7.Reg, volatile.LoadUint32(&o.SCGC7.Reg)&^(0x2)|value<<1)
}
func (o *SIM_Type) GetSCGC7_DMA() uint32 {
	return (volatile.LoadUint32(&o.SCGC7.Reg) & 0x2) >> 1
}
func (o *SIM_Type) SetSCGC7_MPU(value uint32) {
	volatile.StoreUint32(&o.SCGC7.Reg, volatile.LoadUint32(&o.SCGC7.Reg)&^(0x4)|value<<2)
}
func (o *SIM_Type) GetSCGC7_MPU() uint32 {
	return (volatile.LoadUint32(&o.SCGC7.Reg) & 0x4) >> 2
}

// SIM.CLKDIV1: System Clock Divider Register 1
func (o *SIM_Type) SetCLKDIV1_OUTDIV4(value uint32) {
	volatile.StoreUint32(&o.CLKDIV1.Reg, volatile.LoadUint32(&o.CLKDIV1.Reg)&^(0xf0000)|value<<16)
}
func (o *SIM_Type) GetCLKDIV1_OUTDIV4() uint32 {
	return (volatile.LoadUint32(&o.CLKDIV1.Reg) & 0xf0000) >> 16
}
func (o *SIM_Type) SetCLKDIV1_OUTDIV3(value uint32) {
	volatile.StoreUint32(&o.CLKDIV1.Reg, volatile.LoadUint32(&o.CLKDIV1.Reg)&^(0xf00000)|value<<20)
}
func (o *SIM_Type) GetCLKDIV1_OUTDIV3() uint32 {
	return (volatile.LoadUint32(&o.CLKDIV1.Reg) & 0xf00000) >> 20
}
func (o *SIM_Type) SetCLKDIV1_OUTDIV2(value uint32) {
	volatile.StoreUint32(&o.CLKDIV1.Reg, volatile.LoadUint32(&o.CLKDIV1.Reg)&^(0xf000000)|value<<24)
}
func (o *SIM_Type) GetCLKDIV1_OUTDIV2() uint32 {
	return (volatile.LoadUint32(&o.CLKDIV1.Reg) & 0xf000000) >> 24
}
func (o *SIM_Type) SetCLKDIV1_OUTDIV1(value uint32) {
	volatile.StoreUint32(&o.CLKDIV1.Reg, volatile.LoadUint32(&o.CLKDIV1.Reg)&^(0xf0000000)|value<<28)
}
func (o *SIM_Type) GetCLKDIV1_OUTDIV1() uint32 {
	return (volatile.LoadUint32(&o.CLKDIV1.Reg) & 0xf0000000) >> 28
}

// SIM.CLKDIV2: System Clock Divider Register 2
func (o *SIM_Type) SetCLKDIV2_USBFRAC(value uint32) {
	volatile.StoreUint32(&o.CLKDIV2.Reg, volatile.LoadUint32(&o.CLKDIV2.Reg)&^(0x1)|value)
}
func (o *SIM_Type) GetCLKDIV2_USBFRAC() uint32 {
	return volatile.LoadUint32(&o.CLKDIV2.Reg) & 0x1
}
func (o *SIM_Type) SetCLKDIV2_USBDIV(value uint32) {
	volatile.StoreUint32(&o.CLKDIV2.Reg, volatile.LoadUint32(&o.CLKDIV2.Reg)&^(0xe)|value<<1)
}
func (o *SIM_Type) GetCLKDIV2_USBDIV() uint32 {
	return (volatile.LoadUint32(&o.CLKDIV2.Reg) & 0xe) >> 1
}

// SIM.FCFG1: Flash Configuration Register 1
func (o *SIM_Type) SetFCFG1_FLASHDIS(value uint32) {
	volatile.StoreUint32(&o.FCFG1.Reg, volatile.LoadUint32(&o.FCFG1.Reg)&^(0x1)|value)
}
func (o *SIM_Type) GetFCFG1_FLASHDIS() uint32 {
	return volatile.LoadUint32(&o.FCFG1.Reg) & 0x1
}
func (o *SIM_Type) SetFCFG1_FLASHDOZE(value uint32) {
	volatile.StoreUint32(&o.FCFG1.Reg, volatile.LoadUint32(&o.FCFG1.Reg)&^(0x2)|value<<1)
}
func (o *SIM_Type) GetFCFG1_FLASHDOZE() uint32 {
	return (volatile.LoadUint32(&o.FCFG1.Reg) & 0x2) >> 1
}
func (o *SIM_Type) SetFCFG1_DEPART(value uint32) {
	volatile.StoreUint32(&o.FCFG1.Reg, volatile.LoadUint32(&o.FCFG1.Reg)&^(0xf00)|value<<8)
}
func (o *SIM_Type) GetFCFG1_DEPART() uint32 {
	return (volatile.LoadUint32(&o.FCFG1.Reg) & 0xf00) >> 8
}
func (o *SIM_Type) SetFCFG1_EESIZE(value uint32) {
	volatile.StoreUint32(&o.FCFG1.Reg, volatile.LoadUint32(&o.FCFG1.Reg)&^(0xf0000)|value<<16)
}
func (o *SIM_Type) GetFCFG1_EESIZE() uint32 {
	return (volatile.LoadUint32(&o.FCFG1.Reg) & 0xf0000) >> 16
}
func (o *SIM_Type) SetFCFG1_PFSIZE(value uint32) {
	volatile.StoreUint32(&o.FCFG1.Reg, volatile.LoadUint32(&o.FCFG1.Reg)&^(0xf000000)|value<<24)
}
func (o *SIM_Type) GetFCFG1_PFSIZE() uint32 {
	return (volatile.LoadUint32(&o.FCFG1.Reg) & 0xf000000) >> 24
}
func (o *SIM_Type) SetFCFG1_NVMSIZE(value uint32) {
	volatile.StoreUint32(&o.FCFG1.Reg, volatile.LoadUint32(&o.FCFG1.Reg)&^(0xf0000000)|value<<28)
}
func (o *SIM_Type) GetFCFG1_NVMSIZE() uint32 {
	return (volatile.LoadUint32(&o.FCFG1.Reg) & 0xf0000000) >> 28
}

// SIM.FCFG2: Flash Configuration Register 2
func (o *SIM_Type) SetFCFG2_MAXADDR1(value uint32) {
	volatile.StoreUint32(&o.FCFG2.Reg, volatile.LoadUint32(&o.FCFG2.Reg)&^(0x7f0000)|value<<16)
}
func (o *SIM_Type) GetFCFG2_MAXADDR1() uint32 {
	return (volatile.LoadUint32(&o.FCFG2.Reg) & 0x7f0000) >> 16
}
func (o *SIM_Type) SetFCFG2_PFLSH(value uint32) {
	volatile.StoreUint32(&o.FCFG2.Reg, volatile.LoadUint32(&o.FCFG2.Reg)&^(0x800000)|value<<23)
}
func (o *SIM_Type) GetFCFG2_PFLSH() uint32 {
	return (volatile.LoadUint32(&o.FCFG2.Reg) & 0x800000) >> 23
}
func (o *SIM_Type) SetFCFG2_MAXADDR0(value uint32) {
	volatile.StoreUint32(&o.FCFG2.Reg, volatile.LoadUint32(&o.FCFG2.Reg)&^(0x7f000000)|value<<24)
}
func (o *SIM_Type) GetFCFG2_MAXADDR0() uint32 {
	return (volatile.LoadUint32(&o.FCFG2.Reg) & 0x7f000000) >> 24
}

// SIM.UIDH: Unique Identification Register High
func (o *SIM_Type) SetUIDH(value uint32) {
	volatile.StoreUint32(&o.UIDH.Reg, value)
}
func (o *SIM_Type) GetUIDH() uint32 {
	return volatile.LoadUint32(&o.UIDH.Reg)
}

// SIM.UIDMH: Unique Identification Register Mid-High
func (o *SIM_Type) SetUIDMH(value uint32) {
	volatile.StoreUint32(&o.UIDMH.Reg, value)
}
func (o *SIM_Type) GetUIDMH() uint32 {
	return volatile.LoadUint32(&o.UIDMH.Reg)
}

// SIM.UIDML: Unique Identification Register Mid Low
func (o *SIM_Type) SetUIDML(value uint32) {
	volatile.StoreUint32(&o.UIDML.Reg, value)
}
func (o *SIM_Type) GetUIDML() uint32 {
	return volatile.LoadUint32(&o.UIDML.Reg)
}

// SIM.UIDL: Unique Identification Register Low
func (o *SIM_Type) SetUIDL(value uint32) {
	volatile.StoreUint32(&o.UIDL.Reg, value)
}
func (o *SIM_Type) GetUIDL() uint32 {
	return volatile.LoadUint32(&o.UIDL.Reg)
}

// Pin Control and Interrupts
type PORT_Type struct {
	PCR0  volatile.Register32 // 0x0
	PCR1  volatile.Register32 // 0x4
	PCR2  volatile.Register32 // 0x8
	PCR3  volatile.Register32 // 0xC
	PCR4  volatile.Register32 // 0x10
	PCR5  volatile.Register32 // 0x14
	PCR6  volatile.Register32 // 0x18
	PCR7  volatile.Register32 // 0x1C
	PCR8  volatile.Register32 // 0x20
	PCR9  volatile.Register32 // 0x24
	PCR10 volatile.Register32 // 0x28
	PCR11 volatile.Register32 // 0x2C
	PCR12 volatile.Register32 // 0x30
	PCR13 volatile.Register32 // 0x34
	PCR14 volatile.Register32 // 0x38
	PCR15 volatile.Register32 // 0x3C
	PCR16 volatile.Register32 // 0x40
	PCR17 volatile.Register32 // 0x44
	PCR18 volatile.Register32 // 0x48
	PCR19 volatile.Register32 // 0x4C
	PCR20 volatile.Register32 // 0x50
	PCR21 volatile.Register32 // 0x54
	PCR22 volatile.Register32 // 0x58
	PCR23 volatile.Register32 // 0x5C
	PCR24 volatile.Register32 // 0x60
	PCR25 volatile.Register32 // 0x64
	PCR26 volatile.Register32 // 0x68
	PCR27 volatile.Register32 // 0x6C
	PCR28 volatile.Register32 // 0x70
	PCR29 volatile.Register32 // 0x74
	PCR30 volatile.Register32 // 0x78
	PCR31 volatile.Register32 // 0x7C
	GPCLR volatile.Register32 // 0x80
	GPCHR volatile.Register32 // 0x84
	_     [24]byte
	ISFR  volatile.Register32 // 0xA0
}

// PORT.PCR0: Pin Control Register n
func (o *PORT_Type) SetPCR0_PS(value uint32) {
	volatile.StoreUint32(&o.PCR0.Reg, volatile.LoadUint32(&o.PCR0.Reg)&^(0x1)|value)
}
func (o *PORT_Type) GetPCR0_PS() uint32 {
	return volatile.LoadUint32(&o.PCR0.Reg) & 0x1
}
func (o *PORT_Type) SetPCR0_PE(value uint32) {
	volatile.StoreUint32(&o.PCR0.Reg, volatile.LoadUint32(&o.PCR0.Reg)&^(0x2)|value<<1)
}
func (o *PORT_Type) GetPCR0_PE() uint32 {
	return (volatile.LoadUint32(&o.PCR0.Reg) & 0x2) >> 1
}
func (o *PORT_Type) SetPCR0_SRE(value uint32) {
	volatile.StoreUint32(&o.PCR0.Reg, volatile.LoadUint32(&o.PCR0.Reg)&^(0x4)|value<<2)
}
func (o *PORT_Type) GetPCR0_SRE() uint32 {
	return (volatile.LoadUint32(&o.PCR0.Reg) & 0x4) >> 2
}
func (o *PORT_Type) SetPCR0_PFE(value uint32) {
	volatile.StoreUint32(&o.PCR0.Reg, volatile.LoadUint32(&o.PCR0.Reg)&^(0x10)|value<<4)
}
func (o *PORT_Type) GetPCR0_PFE() uint32 {
	return (volatile.LoadUint32(&o.PCR0.Reg) & 0x10) >> 4
}
func (o *PORT_Type) SetPCR0_ODE(value uint32) {
	volatile.StoreUint32(&o.PCR0.Reg, volatile.LoadUint32(&o.PCR0.Reg)&^(0x20)|value<<5)
}
func (o *PORT_Type) GetPCR0_ODE() uint32 {
	return (volatile.LoadUint32(&o.PCR0.Reg) & 0x20) >> 5
}
func (o *PORT_Type) SetPCR0_DSE(value uint32) {
	volatile.StoreUint32(&o.PCR0.Reg, volatile.LoadUint32(&o.PCR0.Reg)&^(0x40)|value<<6)
}
func (o *PORT_Type) GetPCR0_DSE() uint32 {
	return (volatile.LoadUint32(&o.PCR0.Reg) & 0x40) >> 6
}
func (o *PORT_Type) SetPCR0_MUX(value uint32) {
	volatile.StoreUint32(&o.PCR0.Reg, volatile.LoadUint32(&o.PCR0.Reg)&^(0x700)|value<<8)
}
func (o *PORT_Type) GetPCR0_MUX() uint32 {
	return (volatile.LoadUint32(&o.PCR0.Reg) & 0x700) >> 8
}
func (o *PORT_Type) SetPCR0_LK(value uint32) {
	volatile.StoreUint32(&o.PCR0.Reg, volatile.LoadUint32(&o.PCR0.Reg)&^(0x8000)|value<<15)
}
func (o *PORT_Type) GetPCR0_LK() uint32 {
	return (volatile.LoadUint32(&o.PCR0.Reg) & 0x8000) >> 15
}
func (o *PORT_Type) SetPCR0_IRQC(value uint32) {
	volatile.StoreUint32(&o.PCR0.Reg, volatile.LoadUint32(&o.PCR0.Reg)&^(0xf0000)|value<<16)
}
func (o *PORT_Type) GetPCR0_IRQC() uint32 {
	return (volatile.LoadUint32(&o.PCR0.Reg) & 0xf0000) >> 16
}
func (o *PORT_Type) SetPCR0_ISF(value uint32) {
	volatile.StoreUint32(&o.PCR0.Reg, volatile.LoadUint32(&o.PCR0.Reg)&^(0x1000000)|value<<24)
}
func (o *PORT_Type) GetPCR0_ISF() uint32 {
	return (volatile.LoadUint32(&o.PCR0.Reg) & 0x1000000) >> 24
}

// PORT.PCR1: Pin Control Register n
func (o *PORT_Type) SetPCR1_PS(value uint32) {
	volatile.StoreUint32(&o.PCR1.Reg, volatile.LoadUint32(&o.PCR1.Reg)&^(0x1)|value)
}
func (o *PORT_Type) GetPCR1_PS() uint32 {
	return volatile.LoadUint32(&o.PCR1.Reg) & 0x1
}
func (o *PORT_Type) SetPCR1_PE(value uint32) {
	volatile.StoreUint32(&o.PCR1.Reg, volatile.LoadUint32(&o.PCR1.Reg)&^(0x2)|value<<1)
}
func (o *PORT_Type) GetPCR1_PE() uint32 {
	return (volatile.LoadUint32(&o.PCR1.Reg) & 0x2) >> 1
}
func (o *PORT_Type) SetPCR1_SRE(value uint32) {
	volatile.StoreUint32(&o.PCR1.Reg, volatile.LoadUint32(&o.PCR1.Reg)&^(0x4)|value<<2)
}
func (o *PORT_Type) GetPCR1_SRE() uint32 {
	return (volatile.LoadUint32(&o.PCR1.Reg) & 0x4) >> 2
}
func (o *PORT_Type) SetPCR1_PFE(value uint32) {
	volatile.StoreUint32(&o.PCR1.Reg, volatile.LoadUint32(&o.PCR1.Reg)&^(0x10)|value<<4)
}
func (o *PORT_Type) GetPCR1_PFE() uint32 {
	return (volatile.LoadUint32(&o.PCR1.Reg) & 0x10) >> 4
}
func (o *PORT_Type) SetPCR1_ODE(value uint32) {
	volatile.StoreUint32(&o.PCR1.Reg, volatile.LoadUint32(&o.PCR1.Reg)&^(0x20)|value<<5)
}
func (o *PORT_Type) GetPCR1_ODE() uint32 {
	return (volatile.LoadUint32(&o.PCR1.Reg) & 0x20) >> 5
}
func (o *PORT_Type) SetPCR1_DSE(value uint32) {
	volatile.StoreUint32(&o.PCR1.Reg, volatile.LoadUint32(&o.PCR1.Reg)&^(0x40)|value<<6)
}
func (o *PORT_Type) GetPCR1_DSE() uint32 {
	return (volatile.LoadUint32(&o.PCR1.Reg) & 0x40) >> 6
}
func (o *PORT_Type) SetPCR1_MUX(value uint32) {
	volatile.StoreUint32(&o.PCR1.Reg, volatile.LoadUint32(&o.PCR1.Reg)&^(0x700)|value<<8)
}
func (o *PORT_Type) GetPCR1_MUX() uint32 {
	return (volatile.LoadUint32(&o.PCR1.Reg) & 0x700) >> 8
}
func (o *PORT_Type) SetPCR1_LK(value uint32) {
	volatile.StoreUint32(&o.PCR1.Reg, volatile.LoadUint32(&o.PCR1.Reg)&^(0x8000)|value<<15)
}
func (o *PORT_Type) GetPCR1_LK() uint32 {
	return (volatile.LoadUint32(&o.PCR1.Reg) & 0x8000) >> 15
}
func (o *PORT_Type) SetPCR1_IRQC(value uint32) {
	volatile.StoreUint32(&o.PCR1.Reg, volatile.LoadUint32(&o.PCR1.Reg)&^(0xf0000)|value<<16)
}
func (o *PORT_Type) GetPCR1_IRQC() uint32 {
	return (volatile.LoadUint32(&o.PCR1.Reg) & 0xf0000) >> 16
}
func (o *PORT_Type) SetPCR1_ISF(value uint32) {
	volatile.StoreUint32(&o.PCR1.Reg, volatile.LoadUint32(&o.PCR1.Reg)&^(0x1000000)|value<<24)
}
func (o *PORT_Type) GetPCR1_ISF() uint32 {
	return (volatile.LoadUint32(&o.PCR1.Reg) & 0x1000000) >> 24
}

// PORT.PCR2: Pin Control Register n
func (o *PORT_Type) SetPCR2_PS(value uint32) {
	volatile.StoreUint32(&o.PCR2.Reg, volatile.LoadUint32(&o.PCR2.Reg)&^(0x1)|value)
}
func (o *PORT_Type) GetPCR2_PS() uint32 {
	return volatile.LoadUint32(&o.PCR2.Reg) & 0x1
}
func (o *PORT_Type) SetPCR2_PE(value uint32) {
	volatile.StoreUint32(&o.PCR2.Reg, volatile.LoadUint32(&o.PCR2.Reg)&^(0x2)|value<<1)
}
func (o *PORT_Type) GetPCR2_PE() uint32 {
	return (volatile.LoadUint32(&o.PCR2.Reg) & 0x2) >> 1
}
func (o *PORT_Type) SetPCR2_SRE(value uint32) {
	volatile.StoreUint32(&o.PCR2.Reg, volatile.LoadUint32(&o.PCR2.Reg)&^(0x4)|value<<2)
}
func (o *PORT_Type) GetPCR2_SRE() uint32 {
	return (volatile.LoadUint32(&o.PCR2.Reg) & 0x4) >> 2
}
func (o *PORT_Type) SetPCR2_PFE(value uint32) {
	volatile.StoreUint32(&o.PCR2.Reg, volatile.LoadUint32(&o.PCR2.Reg)&^(0x10)|value<<4)
}
func (o *PORT_Type) GetPCR2_PFE() uint32 {
	return (volatile.LoadUint32(&o.PCR2.Reg) & 0x10) >> 4
}
func (o *PORT_Type) SetPCR2_ODE(value uint32) {
	volatile.StoreUint32(&o.PCR2.Reg, volatile.LoadUint32(&o.PCR2.Reg)&^(0x20)|value<<5)
}
func (o *PORT_Type) GetPCR2_ODE() uint32 {
	return (volatile.LoadUint32(&o.PCR2.Reg) & 0x20) >> 5
}
func (o *PORT_Type) SetPCR2_DSE(value uint32) {
	volatile.StoreUint32(&o.PCR2.Reg, volatile.LoadUint32(&o.PCR2.Reg)&^(0x40)|value<<6)
}
func (o *PORT_Type) GetPCR2_DSE() uint32 {
	return (volatile.LoadUint32(&o.PCR2.Reg) & 0x40) >> 6
}
func (o *PORT_Type) SetPCR2_MUX(value uint32) {
	volatile.StoreUint32(&o.PCR2.Reg, volatile.LoadUint32(&o.PCR2.Reg)&^(0x700)|value<<8)
}
func (o *PORT_Type) GetPCR2_MUX() uint32 {
	return (volatile.LoadUint32(&o.PCR2.Reg) & 0x700) >> 8
}
func (o *PORT_Type) SetPCR2_LK(value uint32) {
	volatile.StoreUint32(&o.PCR2.Reg, volatile.LoadUint32(&o.PCR2.Reg)&^(0x8000)|value<<15)
}
func (o *PORT_Type) GetPCR2_LK() uint32 {
	return (volatile.LoadUint32(&o.PCR2.Reg) & 0x8000) >> 15
}
func (o *PORT_Type) SetPCR2_IRQC(value uint32) {
	volatile.StoreUint32(&o.PCR2.Reg, volatile.LoadUint32(&o.PCR2.Reg)&^(0xf0000)|value<<16)
}
func (o *PORT_Type) GetPCR2_IRQC() uint32 {
	return (volatile.LoadUint32(&o.PCR2.Reg) & 0xf0000) >> 16
}
func (o *PORT_Type) SetPCR2_ISF(value uint32) {
	volatile.StoreUint32(&o.PCR2.Reg, volatile.LoadUint32(&o.PCR2.Reg)&^(0x1000000)|value<<24)
}
func (o *PORT_Type) GetPCR2_ISF() uint32 {
	return (volatile.LoadUint32(&o.PCR2.Reg) & 0x1000000) >> 24
}

// PORT.PCR3: Pin Control Register n
func (o *PORT_Type) SetPCR3_PS(value uint32) {
	volatile.StoreUint32(&o.PCR3.Reg, volatile.LoadUint32(&o.PCR3.Reg)&^(0x1)|value)
}
func (o *PORT_Type) GetPCR3_PS() uint32 {
	return volatile.LoadUint32(&o.PCR3.Reg) & 0x1
}
func (o *PORT_Type) SetPCR3_PE(value uint32) {
	volatile.StoreUint32(&o.PCR3.Reg, volatile.LoadUint32(&o.PCR3.Reg)&^(0x2)|value<<1)
}
func (o *PORT_Type) GetPCR3_PE() uint32 {
	return (volatile.LoadUint32(&o.PCR3.Reg) & 0x2) >> 1
}
func (o *PORT_Type) SetPCR3_SRE(value uint32) {
	volatile.StoreUint32(&o.PCR3.Reg, volatile.LoadUint32(&o.PCR3.Reg)&^(0x4)|value<<2)
}
func (o *PORT_Type) GetPCR3_SRE() uint32 {
	return (volatile.LoadUint32(&o.PCR3.Reg) & 0x4) >> 2
}
func (o *PORT_Type) SetPCR3_PFE(value uint32) {
	volatile.StoreUint32(&o.PCR3.Reg, volatile.LoadUint32(&o.PCR3.Reg)&^(0x10)|value<<4)
}
func (o *PORT_Type) GetPCR3_PFE() uint32 {
	return (volatile.LoadUint32(&o.PCR3.Reg) & 0x10) >> 4
}
func (o *PORT_Type) SetPCR3_ODE(value uint32) {
	volatile.StoreUint32(&o.PCR3.Reg, volatile.LoadUint32(&o.PCR3.Reg)&^(0x20)|value<<5)
}
func (o *PORT_Type) GetPCR3_ODE() uint32 {
	return (volatile.LoadUint32(&o.PCR3.Reg) & 0x20) >> 5
}
func (o *PORT_Type) SetPCR3_DSE(value uint32) {
	volatile.StoreUint32(&o.PCR3.Reg, volatile.LoadUint32(&o.PCR3.Reg)&^(0x40)|value<<6)
}
func (o *PORT_Type) GetPCR3_DSE() uint32 {
	return (volatile.LoadUint32(&o.PCR3.Reg) & 0x40) >> 6
}
func (o *PORT_Type) SetPCR3_MUX(value uint32) {
	volatile.StoreUint32(&o.PCR3.Reg, volatile.LoadUint32(&o.PCR3.Reg)&^(0x700)|value<<8)
}
func (o *PORT_Type) GetPCR3_MUX() uint32 {
	return (volatile.LoadUint32(&o.PCR3.Reg) & 0x700) >> 8
}
func (o *PORT_Type) SetPCR3_LK(value uint32) {
	volatile.StoreUint32(&o.PCR3.Reg, volatile.LoadUint32(&o.PCR3.Reg)&^(0x8000)|value<<15)
}
func (o *PORT_Type) GetPCR3_LK() uint32 {
	return (volatile.LoadUint32(&o.PCR3.Reg) & 0x8000) >> 15
}
func (o *PORT_Type) SetPCR3_IRQC(value uint32) {
	volatile.StoreUint32(&o.PCR3.Reg, volatile.LoadUint32(&o.PCR3.Reg)&^(0xf0000)|value<<16)
}
func (o *PORT_Type) GetPCR3_IRQC() uint32 {
	return (volatile.LoadUint32(&o.PCR3.Reg) & 0xf0000) >> 16
}
func (o *PORT_Type) SetPCR3_ISF(value uint32) {
	volatile.StoreUint32(&o.PCR3.Reg, volatile.LoadUint32(&o.PCR3.Reg)&^(0x1000000)|value<<24)
}
func (o *PORT_Type) GetPCR3_ISF() uint32 {
	return (volatile.LoadUint32(&o.PCR3.Reg) & 0x1000000) >> 24
}

// PORT.PCR4: Pin Control Register n
func (o *PORT_Type) SetPCR4_PS(value uint32) {
	volatile.StoreUint32(&o.PCR4.Reg, volatile.LoadUint32(&o.PCR4.Reg)&^(0x1)|value)
}
func (o *PORT_Type) GetPCR4_PS() uint32 {
	return volatile.LoadUint32(&o.PCR4.Reg) & 0x1
}
func (o *PORT_Type) SetPCR4_PE(value uint32) {
	volatile.StoreUint32(&o.PCR4.Reg, volatile.LoadUint32(&o.PCR4.Reg)&^(0x2)|value<<1)
}
func (o *PORT_Type) GetPCR4_PE() uint32 {
	return (volatile.LoadUint32(&o.PCR4.Reg) & 0x2) >> 1
}
func (o *PORT_Type) SetPCR4_SRE(value uint32) {
	volatile.StoreUint32(&o.PCR4.Reg, volatile.LoadUint32(&o.PCR4.Reg)&^(0x4)|value<<2)
}
func (o *PORT_Type) GetPCR4_SRE() uint32 {
	return (volatile.LoadUint32(&o.PCR4.Reg) & 0x4) >> 2
}
func (o *PORT_Type) SetPCR4_PFE(value uint32) {
	volatile.StoreUint32(&o.PCR4.Reg, volatile.LoadUint32(&o.PCR4.Reg)&^(0x10)|value<<4)
}
func (o *PORT_Type) GetPCR4_PFE() uint32 {
	return (volatile.LoadUint32(&o.PCR4.Reg) & 0x10) >> 4
}
func (o *PORT_Type) SetPCR4_ODE(value uint32) {
	volatile.StoreUint32(&o.PCR4.Reg, volatile.LoadUint32(&o.PCR4.Reg)&^(0x20)|value<<5)
}
func (o *PORT_Type) GetPCR4_ODE() uint32 {
	return (volatile.LoadUint32(&o.PCR4.Reg) & 0x20) >> 5
}
func (o *PORT_Type) SetPCR4_DSE(value uint32) {
	volatile.StoreUint32(&o.PCR4.Reg, volatile.LoadUint32(&o.PCR4.Reg)&^(0x40)|value<<6)
}
func (o *PORT_Type) GetPCR4_DSE() uint32 {
	return (volatile.LoadUint32(&o.PCR4.Reg) & 0x40) >> 6
}
func (o *PORT_Type) SetPCR4_MUX(value uint32) {
	volatile.StoreUint32(&o.PCR4.Reg, volatile.LoadUint32(&o.PCR4.Reg)&^(0x700)|value<<8)
}
func (o *PORT_Type) GetPCR4_MUX() uint32 {
	return (volatile.LoadUint32(&o.PCR4.Reg) & 0x700) >> 8
}
func (o *PORT_Type) SetPCR4_LK(value uint32) {
	volatile.StoreUint32(&o.PCR4.Reg, volatile.LoadUint32(&o.PCR4.Reg)&^(0x8000)|value<<15)
}
func (o *PORT_Type) GetPCR4_LK() uint32 {
	return (volatile.LoadUint32(&o.PCR4.Reg) & 0x8000) >> 15
}
func (o *PORT_Type) SetPCR4_IRQC(value uint32) {
	volatile.StoreUint32(&o.PCR4.Reg, volatile.LoadUint32(&o.PCR4.Reg)&^(0xf0000)|value<<16)
}
func (o *PORT_Type) GetPCR4_IRQC() uint32 {
	return (volatile.LoadUint32(&o.PCR4.Reg) & 0xf0000) >> 16
}
func (o *PORT_Type) SetPCR4_ISF(value uint32) {
	volatile.StoreUint32(&o.PCR4.Reg, volatile.LoadUint32(&o.PCR4.Reg)&^(0x1000000)|value<<24)
}
func (o *PORT_Type) GetPCR4_ISF() uint32 {
	return (volatile.LoadUint32(&o.PCR4.Reg) & 0x1000000) >> 24
}

// PORT.PCR5: Pin Control Register n
func (o *PORT_Type) SetPCR5_PS(value uint32) {
	volatile.StoreUint32(&o.PCR5.Reg, volatile.LoadUint32(&o.PCR5.Reg)&^(0x1)|value)
}
func (o *PORT_Type) GetPCR5_PS() uint32 {
	return volatile.LoadUint32(&o.PCR5.Reg) & 0x1
}
func (o *PORT_Type) SetPCR5_PE(value uint32) {
	volatile.StoreUint32(&o.PCR5.Reg, volatile.LoadUint32(&o.PCR5.Reg)&^(0x2)|value<<1)
}
func (o *PORT_Type) GetPCR5_PE() uint32 {
	return (volatile.LoadUint32(&o.PCR5.Reg) & 0x2) >> 1
}
func (o *PORT_Type) SetPCR5_SRE(value uint32) {
	volatile.StoreUint32(&o.PCR5.Reg, volatile.LoadUint32(&o.PCR5.Reg)&^(0x4)|value<<2)
}
func (o *PORT_Type) GetPCR5_SRE() uint32 {
	return (volatile.LoadUint32(&o.PCR5.Reg) & 0x4) >> 2
}
func (o *PORT_Type) SetPCR5_PFE(value uint32) {
	volatile.StoreUint32(&o.PCR5.Reg, volatile.LoadUint32(&o.PCR5.Reg)&^(0x10)|value<<4)
}
func (o *PORT_Type) GetPCR5_PFE() uint32 {
	return (volatile.LoadUint32(&o.PCR5.Reg) & 0x10) >> 4
}
func (o *PORT_Type) SetPCR5_ODE(value uint32) {
	volatile.StoreUint32(&o.PCR5.Reg, volatile.LoadUint32(&o.PCR5.Reg)&^(0x20)|value<<5)
}
func (o *PORT_Type) GetPCR5_ODE() uint32 {
	return (volatile.LoadUint32(&o.PCR5.Reg) & 0x20) >> 5
}
func (o *PORT_Type) SetPCR5_DSE(value uint32) {
	volatile.StoreUint32(&o.PCR5.Reg, volatile.LoadUint32(&o.PCR5.Reg)&^(0x40)|value<<6)
}
func (o *PORT_Type) GetPCR5_DSE() uint32 {
	return (volatile.LoadUint32(&o.PCR5.Reg) & 0x40) >> 6
}
func (o *PORT_Type) SetPCR5_MUX(value uint32) {
	volatile.StoreUint32(&o.PCR5.Reg, volatile.LoadUint32(&o.PCR5.Reg)&^(0x700)|value<<8)
}
func (o *PORT_Type) GetPCR5_MUX() uint32 {
	return (volatile.LoadUint32(&o.PCR5.Reg) & 0x700) >> 8
}
func (o *PORT_Type) SetPCR5_LK(value uint32) {
	volatile.StoreUint32(&o.PCR5.Reg, volatile.LoadUint32(&o.PCR5.Reg)&^(0x8000)|value<<15)
}
func (o *PORT_Type) GetPCR5_LK() uint32 {
	return (volatile.LoadUint32(&o.PCR5.Reg) & 0x8000) >> 15
}
func (o *PORT_Type) SetPCR5_IRQC(value uint32) {
	volatile.StoreUint32(&o.PCR5.Reg, volatile.LoadUint32(&o.PCR5.Reg)&^(0xf0000)|value<<16)
}
func (o *PORT_Type) GetPCR5_IRQC() uint32 {
	return (volatile.LoadUint32(&o.PCR5.Reg) & 0xf0000) >> 16
}
func (o *PORT_Type) SetPCR5_ISF(value uint32) {
	volatile.StoreUint32(&o.PCR5.Reg, volatile.LoadUint32(&o.PCR5.Reg)&^(0x1000000)|value<<24)
}
func (o *PORT_Type) GetPCR5_ISF() uint32 {
	return (volatile.LoadUint32(&o.PCR5.Reg) & 0x1000000) >> 24
}

// PORT.PCR6: Pin Control Register n
func (o *PORT_Type) SetPCR6_PS(value uint32) {
	volatile.StoreUint32(&o.PCR6.Reg, volatile.LoadUint32(&o.PCR6.Reg)&^(0x1)|value)
}
func (o *PORT_Type) GetPCR6_PS() uint32 {
	return volatile.LoadUint32(&o.PCR6.Reg) & 0x1
}
func (o *PORT_Type) SetPCR6_PE(value uint32) {
	volatile.StoreUint32(&o.PCR6.Reg, volatile.LoadUint32(&o.PCR6.Reg)&^(0x2)|value<<1)
}
func (o *PORT_Type) GetPCR6_PE() uint32 {
	return (volatile.LoadUint32(&o.PCR6.Reg) & 0x2) >> 1
}
func (o *PORT_Type) SetPCR6_SRE(value uint32) {
	volatile.StoreUint32(&o.PCR6.Reg, volatile.LoadUint32(&o.PCR6.Reg)&^(0x4)|value<<2)
}
func (o *PORT_Type) GetPCR6_SRE() uint32 {
	return (volatile.LoadUint32(&o.PCR6.Reg) & 0x4) >> 2
}
func (o *PORT_Type) SetPCR6_PFE(value uint32) {
	volatile.StoreUint32(&o.PCR6.Reg, volatile.LoadUint32(&o.PCR6.Reg)&^(0x10)|value<<4)
}
func (o *PORT_Type) GetPCR6_PFE() uint32 {
	return (volatile.LoadUint32(&o.PCR6.Reg) & 0x10) >> 4
}
func (o *PORT_Type) SetPCR6_ODE(value uint32) {
	volatile.StoreUint32(&o.PCR6.Reg, volatile.LoadUint32(&o.PCR6.Reg)&^(0x20)|value<<5)
}
func (o *PORT_Type) GetPCR6_ODE() uint32 {
	return (volatile.LoadUint32(&o.PCR6.Reg) & 0x20) >> 5
}
func (o *PORT_Type) SetPCR6_DSE(value uint32) {
	volatile.StoreUint32(&o.PCR6.Reg, volatile.LoadUint32(&o.PCR6.Reg)&^(0x40)|value<<6)
}
func (o *PORT_Type) GetPCR6_DSE() uint32 {
	return (volatile.LoadUint32(&o.PCR6.Reg) & 0x40) >> 6
}
func (o *PORT_Type) SetPCR6_MUX(value uint32) {
	volatile.StoreUint32(&o.PCR6.Reg, volatile.LoadUint32(&o.PCR6.Reg)&^(0x700)|value<<8)
}
func (o *PORT_Type) GetPCR6_MUX() uint32 {
	return (volatile.LoadUint32(&o.PCR6.Reg) & 0x700) >> 8
}
func (o *PORT_Type) SetPCR6_LK(value uint32) {
	volatile.StoreUint32(&o.PCR6.Reg, volatile.LoadUint32(&o.PCR6.Reg)&^(0x8000)|value<<15)
}
func (o *PORT_Type) GetPCR6_LK() uint32 {
	return (volatile.LoadUint32(&o.PCR6.Reg) & 0x8000) >> 15
}
func (o *PORT_Type) SetPCR6_IRQC(value uint32) {
	volatile.StoreUint32(&o.PCR6.Reg, volatile.LoadUint32(&o.PCR6.Reg)&^(0xf0000)|value<<16)
}
func (o *PORT_Type) GetPCR6_IRQC() uint32 {
	return (volatile.LoadUint32(&o.PCR6.Reg) & 0xf0000) >> 16
}
func (o *PORT_Type) SetPCR6_ISF(value uint32) {
	volatile.StoreUint32(&o.PCR6.Reg, volatile.LoadUint32(&o.PCR6.Reg)&^(0x1000000)|value<<24)
}
func (o *PORT_Type) GetPCR6_ISF() uint32 {
	return (volatile.LoadUint32(&o.PCR6.Reg) & 0x1000000) >> 24
}

// PORT.PCR7: Pin Control Register n
func (o *PORT_Type) SetPCR7_PS(value uint32) {
	volatile.StoreUint32(&o.PCR7.Reg, volatile.LoadUint32(&o.PCR7.Reg)&^(0x1)|value)
}
func (o *PORT_Type) GetPCR7_PS() uint32 {
	return volatile.LoadUint32(&o.PCR7.Reg) & 0x1
}
func (o *PORT_Type) SetPCR7_PE(value uint32) {
	volatile.StoreUint32(&o.PCR7.Reg, volatile.LoadUint32(&o.PCR7.Reg)&^(0x2)|value<<1)
}
func (o *PORT_Type) GetPCR7_PE() uint32 {
	return (volatile.LoadUint32(&o.PCR7.Reg) & 0x2) >> 1
}
func (o *PORT_Type) SetPCR7_SRE(value uint32) {
	volatile.StoreUint32(&o.PCR7.Reg, volatile.LoadUint32(&o.PCR7.Reg)&^(0x4)|value<<2)
}
func (o *PORT_Type) GetPCR7_SRE() uint32 {
	return (volatile.LoadUint32(&o.PCR7.Reg) & 0x4) >> 2
}
func (o *PORT_Type) SetPCR7_PFE(value uint32) {
	volatile.StoreUint32(&o.PCR7.Reg, volatile.LoadUint32(&o.PCR7.Reg)&^(0x10)|value<<4)
}
func (o *PORT_Type) GetPCR7_PFE() uint32 {
	return (volatile.LoadUint32(&o.PCR7.Reg) & 0x10) >> 4
}
func (o *PORT_Type) SetPCR7_ODE(value uint32) {
	volatile.StoreUint32(&o.PCR7.Reg, volatile.LoadUint32(&o.PCR7.Reg)&^(0x20)|value<<5)
}
func (o *PORT_Type) GetPCR7_ODE() uint32 {
	return (volatile.LoadUint32(&o.PCR7.Reg) & 0x20) >> 5
}
func (o *PORT_Type) SetPCR7_DSE(value uint32) {
	volatile.StoreUint32(&o.PCR7.Reg, volatile.LoadUint32(&o.PCR7.Reg)&^(0x40)|value<<6)
}
func (o *PORT_Type) GetPCR7_DSE() uint32 {
	return (volatile.LoadUint32(&o.PCR7.Reg) & 0x40) >> 6
}
func (o *PORT_Type) SetPCR7_MUX(value uint32) {
	volatile.StoreUint32(&o.PCR7.Reg, volatile.LoadUint32(&o.PCR7.Reg)&^(0x700)|value<<8)
}
func (o *PORT_Type) GetPCR7_MUX() uint32 {
	return (volatile.LoadUint32(&o.PCR7.Reg) & 0x700) >> 8
}
func (o *PORT_Type) SetPCR7_LK(value uint32) {
	volatile.StoreUint32(&o.PCR7.Reg, volatile.LoadUint32(&o.PCR7.Reg)&^(0x8000)|value<<15)
}
func (o *PORT_Type) GetPCR7_LK() uint32 {
	return (volatile.LoadUint32(&o.PCR7.Reg) & 0x8000) >> 15
}
func (o *PORT_Type) SetPCR7_IRQC(value uint32) {
	volatile.StoreUint32(&o.PCR7.Reg, volatile.LoadUint32(&o.PCR7.Reg)&^(0xf0000)|value<<16)
}
func (o *PORT_Type) GetPCR7_IRQC() uint32 {
	return (volatile.LoadUint32(&o.PCR7.Reg) & 0xf0000) >> 16
}
func (o *PORT_Type) SetPCR7_ISF(value uint32) {
	volatile.StoreUint32(&o.PCR7.Reg, volatile.LoadUint32(&o.PCR7.Reg)&^(0x1000000)|value<<24)
}
func (o *PORT_Type) GetPCR7_ISF() uint32 {
	return (volatile.LoadUint32(&o.PCR7.Reg) & 0x1000000) >> 24
}

// PORT.PCR8: Pin Control Register n
func (o *PORT_Type) SetPCR8_PS(value uint32) {
	volatile.StoreUint32(&o.PCR8.Reg, volatile.LoadUint32(&o.PCR8.Reg)&^(0x1)|value)
}
func (o *PORT_Type) GetPCR8_PS() uint32 {
	return volatile.LoadUint32(&o.PCR8.Reg) & 0x1
}
func (o *PORT_Type) SetPCR8_PE(value uint32) {
	volatile.StoreUint32(&o.PCR8.Reg, volatile.LoadUint32(&o.PCR8.Reg)&^(0x2)|value<<1)
}
func (o *PORT_Type) GetPCR8_PE() uint32 {
	return (volatile.LoadUint32(&o.PCR8.Reg) & 0x2) >> 1
}
func (o *PORT_Type) SetPCR8_SRE(value uint32) {
	volatile.StoreUint32(&o.PCR8.Reg, volatile.LoadUint32(&o.PCR8.Reg)&^(0x4)|value<<2)
}
func (o *PORT_Type) GetPCR8_SRE() uint32 {
	return (volatile.LoadUint32(&o.PCR8.Reg) & 0x4) >> 2
}
func (o *PORT_Type) SetPCR8_PFE(value uint32) {
	volatile.StoreUint32(&o.PCR8.Reg, volatile.LoadUint32(&o.PCR8.Reg)&^(0x10)|value<<4)
}
func (o *PORT_Type) GetPCR8_PFE() uint32 {
	return (volatile.LoadUint32(&o.PCR8.Reg) & 0x10) >> 4
}
func (o *PORT_Type) SetPCR8_ODE(value uint32) {
	volatile.StoreUint32(&o.PCR8.Reg, volatile.LoadUint32(&o.PCR8.Reg)&^(0x20)|value<<5)
}
func (o *PORT_Type) GetPCR8_ODE() uint32 {
	return (volatile.LoadUint32(&o.PCR8.Reg) & 0x20) >> 5
}
func (o *PORT_Type) SetPCR8_DSE(value uint32) {
	volatile.StoreUint32(&o.PCR8.Reg, volatile.LoadUint32(&o.PCR8.Reg)&^(0x40)|value<<6)
}
func (o *PORT_Type) GetPCR8_DSE() uint32 {
	return (volatile.LoadUint32(&o.PCR8.Reg) & 0x40) >> 6
}
func (o *PORT_Type) SetPCR8_MUX(value uint32) {
	volatile.StoreUint32(&o.PCR8.Reg, volatile.LoadUint32(&o.PCR8.Reg)&^(0x700)|value<<8)
}
func (o *PORT_Type) GetPCR8_MUX() uint32 {
	return (volatile.LoadUint32(&o.PCR8.Reg) & 0x700) >> 8
}
func (o *PORT_Type) SetPCR8_LK(value uint32) {
	volatile.StoreUint32(&o.PCR8.Reg, volatile.LoadUint32(&o.PCR8.Reg)&^(0x8000)|value<<15)
}
func (o *PORT_Type) GetPCR8_LK() uint32 {
	return (volatile.LoadUint32(&o.PCR8.Reg) & 0x8000) >> 15
}
func (o *PORT_Type) SetPCR8_IRQC(value uint32) {
	volatile.StoreUint32(&o.PCR8.Reg, volatile.LoadUint32(&o.PCR8.Reg)&^(0xf0000)|value<<16)
}
func (o *PORT_Type) GetPCR8_IRQC() uint32 {
	return (volatile.LoadUint32(&o.PCR8.Reg) & 0xf0000) >> 16
}
func (o *PORT_Type) SetPCR8_ISF(value uint32) {
	volatile.StoreUint32(&o.PCR8.Reg, volatile.LoadUint32(&o.PCR8.Reg)&^(0x1000000)|value<<24)
}
func (o *PORT_Type) GetPCR8_ISF() uint32 {
	return (volatile.LoadUint32(&o.PCR8.Reg) & 0x1000000) >> 24
}

// PORT.PCR9: Pin Control Register n
func (o *PORT_Type) SetPCR9_PS(value uint32) {
	volatile.StoreUint32(&o.PCR9.Reg, volatile.LoadUint32(&o.PCR9.Reg)&^(0x1)|value)
}
func (o *PORT_Type) GetPCR9_PS() uint32 {
	return volatile.LoadUint32(&o.PCR9.Reg) & 0x1
}
func (o *PORT_Type) SetPCR9_PE(value uint32) {
	volatile.StoreUint32(&o.PCR9.Reg, volatile.LoadUint32(&o.PCR9.Reg)&^(0x2)|value<<1)
}
func (o *PORT_Type) GetPCR9_PE() uint32 {
	return (volatile.LoadUint32(&o.PCR9.Reg) & 0x2) >> 1
}
func (o *PORT_Type) SetPCR9_SRE(value uint32) {
	volatile.StoreUint32(&o.PCR9.Reg, volatile.LoadUint32(&o.PCR9.Reg)&^(0x4)|value<<2)
}
func (o *PORT_Type) GetPCR9_SRE() uint32 {
	return (volatile.LoadUint32(&o.PCR9.Reg) & 0x4) >> 2
}
func (o *PORT_Type) SetPCR9_PFE(value uint32) {
	volatile.StoreUint32(&o.PCR9.Reg, volatile.LoadUint32(&o.PCR9.Reg)&^(0x10)|value<<4)
}
func (o *PORT_Type) GetPCR9_PFE() uint32 {
	return (volatile.LoadUint32(&o.PCR9.Reg) & 0x10) >> 4
}
func (o *PORT_Type) SetPCR9_ODE(value uint32) {
	volatile.StoreUint32(&o.PCR9.Reg, volatile.LoadUint32(&o.PCR9.Reg)&^(0x20)|value<<5)
}
func (o *PORT_Type) GetPCR9_ODE() uint32 {
	return (volatile.LoadUint32(&o.PCR9.Reg) & 0x20) >> 5
}
func (o *PORT_Type) SetPCR9_DSE(value uint32) {
	volatile.StoreUint32(&o.PCR9.Reg, volatile.LoadUint32(&o.PCR9.Reg)&^(0x40)|value<<6)
}
func (o *PORT_Type) GetPCR9_DSE() uint32 {
	return (volatile.LoadUint32(&o.PCR9.Reg) & 0x40) >> 6
}
func (o *PORT_Type) SetPCR9_MUX(value uint32) {
	volatile.StoreUint32(&o.PCR9.Reg, volatile.LoadUint32(&o.PCR9.Reg)&^(0x700)|value<<8)
}
func (o *PORT_Type) GetPCR9_MUX() uint32 {
	return (volatile.LoadUint32(&o.PCR9.Reg) & 0x700) >> 8
}
func (o *PORT_Type) SetPCR9_LK(value uint32) {
	volatile.StoreUint32(&o.PCR9.Reg, volatile.LoadUint32(&o.PCR9.Reg)&^(0x8000)|value<<15)
}
func (o *PORT_Type) GetPCR9_LK() uint32 {
	return (volatile.LoadUint32(&o.PCR9.Reg) & 0x8000) >> 15
}
func (o *PORT_Type) SetPCR9_IRQC(value uint32) {
	volatile.StoreUint32(&o.PCR9.Reg, volatile.LoadUint32(&o.PCR9.Reg)&^(0xf0000)|value<<16)
}
func (o *PORT_Type) GetPCR9_IRQC() uint32 {
	return (volatile.LoadUint32(&o.PCR9.Reg) & 0xf0000) >> 16
}
func (o *PORT_Type) SetPCR9_ISF(value uint32) {
	volatile.StoreUint32(&o.PCR9.Reg, volatile.LoadUint32(&o.PCR9.Reg)&^(0x1000000)|value<<24)
}
func (o *PORT_Type) GetPCR9_ISF() uint32 {
	return (volatile.LoadUint32(&o.PCR9.Reg) & 0x1000000) >> 24
}

// PORT.PCR10: Pin Control Register n
func (o *PORT_Type) SetPCR10_PS(value uint32) {
	volatile.StoreUint32(&o.PCR10.Reg, volatile.LoadUint32(&o.PCR10.Reg)&^(0x1)|value)
}
func (o *PORT_Type) GetPCR10_PS() uint32 {
	return volatile.LoadUint32(&o.PCR10.Reg) & 0x1
}
func (o *PORT_Type) SetPCR10_PE(value uint32) {
	volatile.StoreUint32(&o.PCR10.Reg, volatile.LoadUint32(&o.PCR10.Reg)&^(0x2)|value<<1)
}
func (o *PORT_Type) GetPCR10_PE() uint32 {
	return (volatile.LoadUint32(&o.PCR10.Reg) & 0x2) >> 1
}
func (o *PORT_Type) SetPCR10_SRE(value uint32) {
	volatile.StoreUint32(&o.PCR10.Reg, volatile.LoadUint32(&o.PCR10.Reg)&^(0x4)|value<<2)
}
func (o *PORT_Type) GetPCR10_SRE() uint32 {
	return (volatile.LoadUint32(&o.PCR10.Reg) & 0x4) >> 2
}
func (o *PORT_Type) SetPCR10_PFE(value uint32) {
	volatile.StoreUint32(&o.PCR10.Reg, volatile.LoadUint32(&o.PCR10.Reg)&^(0x10)|value<<4)
}
func (o *PORT_Type) GetPCR10_PFE() uint32 {
	return (volatile.LoadUint32(&o.PCR10.Reg) & 0x10) >> 4
}
func (o *PORT_Type) SetPCR10_ODE(value uint32) {
	volatile.StoreUint32(&o.PCR10.Reg, volatile.LoadUint32(&o.PCR10.Reg)&^(0x20)|value<<5)
}
func (o *PORT_Type) GetPCR10_ODE() uint32 {
	return (volatile.LoadUint32(&o.PCR10.Reg) & 0x20) >> 5
}
func (o *PORT_Type) SetPCR10_DSE(value uint32) {
	volatile.StoreUint32(&o.PCR10.Reg, volatile.LoadUint32(&o.PCR10.Reg)&^(0x40)|value<<6)
}
func (o *PORT_Type) GetPCR10_DSE() uint32 {
	return (volatile.LoadUint32(&o.PCR10.Reg) & 0x40) >> 6
}
func (o *PORT_Type) SetPCR10_MUX(value uint32) {
	volatile.StoreUint32(&o.PCR10.Reg, volatile.LoadUint32(&o.PCR10.Reg)&^(0x700)|value<<8)
}
func (o *PORT_Type) GetPCR10_MUX() uint32 {
	return (volatile.LoadUint32(&o.PCR10.Reg) & 0x700) >> 8
}
func (o *PORT_Type) SetPCR10_LK(value uint32) {
	volatile.StoreUint32(&o.PCR10.Reg, volatile.LoadUint32(&o.PCR10.Reg)&^(0x8000)|value<<15)
}
func (o *PORT_Type) GetPCR10_LK() uint32 {
	return (volatile.LoadUint32(&o.PCR10.Reg) & 0x8000) >> 15
}
func (o *PORT_Type) SetPCR10_IRQC(value uint32) {
	volatile.StoreUint32(&o.PCR10.Reg, volatile.LoadUint32(&o.PCR10.Reg)&^(0xf0000)|value<<16)
}
func (o *PORT_Type) GetPCR10_IRQC() uint32 {
	return (volatile.LoadUint32(&o.PCR10.Reg) & 0xf0000) >> 16
}
func (o *PORT_Type) SetPCR10_ISF(value uint32) {
	volatile.StoreUint32(&o.PCR10.Reg, volatile.LoadUint32(&o.PCR10.Reg)&^(0x1000000)|value<<24)
}
func (o *PORT_Type) GetPCR10_ISF() uint32 {
	return (volatile.LoadUint32(&o.PCR10.Reg) & 0x1000000) >> 24
}

// PORT.PCR11: Pin Control Register n
func (o *PORT_Type) SetPCR11_PS(value uint32) {
	volatile.StoreUint32(&o.PCR11.Reg, volatile.LoadUint32(&o.PCR11.Reg)&^(0x1)|value)
}
func (o *PORT_Type) GetPCR11_PS() uint32 {
	return volatile.LoadUint32(&o.PCR11.Reg) & 0x1
}
func (o *PORT_Type) SetPCR11_PE(value uint32) {
	volatile.StoreUint32(&o.PCR11.Reg, volatile.LoadUint32(&o.PCR11.Reg)&^(0x2)|value<<1)
}
func (o *PORT_Type) GetPCR11_PE() uint32 {
	return (volatile.LoadUint32(&o.PCR11.Reg) & 0x2) >> 1
}
func (o *PORT_Type) SetPCR11_SRE(value uint32) {
	volatile.StoreUint32(&o.PCR11.Reg, volatile.LoadUint32(&o.PCR11.Reg)&^(0x4)|value<<2)
}
func (o *PORT_Type) GetPCR11_SRE() uint32 {
	return (volatile.LoadUint32(&o.PCR11.Reg) & 0x4) >> 2
}
func (o *PORT_Type) SetPCR11_PFE(value uint32) {
	volatile.StoreUint32(&o.PCR11.Reg, volatile.LoadUint32(&o.PCR11.Reg)&^(0x10)|value<<4)
}
func (o *PORT_Type) GetPCR11_PFE() uint32 {
	return (volatile.LoadUint32(&o.PCR11.Reg) & 0x10) >> 4
}
func (o *PORT_Type) SetPCR11_ODE(value uint32) {
	volatile.StoreUint32(&o.PCR11.Reg, volatile.LoadUint32(&o.PCR11.Reg)&^(0x20)|value<<5)
}
func (o *PORT_Type) GetPCR11_ODE() uint32 {
	return (volatile.LoadUint32(&o.PCR11.Reg) & 0x20) >> 5
}
func (o *PORT_Type) SetPCR11_DSE(value uint32) {
	volatile.StoreUint32(&o.PCR11.Reg, volatile.LoadUint32(&o.PCR11.Reg)&^(0x40)|value<<6)
}
func (o *PORT_Type) GetPCR11_DSE() uint32 {
	return (volatile.LoadUint32(&o.PCR11.Reg) & 0x40) >> 6
}
func (o *PORT_Type) SetPCR11_MUX(value uint32) {
	volatile.StoreUint32(&o.PCR11.Reg, volatile.LoadUint32(&o.PCR11.Reg)&^(0x700)|value<<8)
}
func (o *PORT_Type) GetPCR11_MUX() uint32 {
	return (volatile.LoadUint32(&o.PCR11.Reg) & 0x700) >> 8
}
func (o *PORT_Type) SetPCR11_LK(value uint32) {
	volatile.StoreUint32(&o.PCR11.Reg, volatile.LoadUint32(&o.PCR11.Reg)&^(0x8000)|value<<15)
}
func (o *PORT_Type) GetPCR11_LK() uint32 {
	return (volatile.LoadUint32(&o.PCR11.Reg) & 0x8000) >> 15
}
func (o *PORT_Type) SetPCR11_IRQC(value uint32) {
	volatile.StoreUint32(&o.PCR11.Reg, volatile.LoadUint32(&o.PCR11.Reg)&^(0xf0000)|value<<16)
}
func (o *PORT_Type) GetPCR11_IRQC() uint32 {
	return (volatile.LoadUint32(&o.PCR11.Reg) & 0xf0000) >> 16
}
func (o *PORT_Type) SetPCR11_ISF(value uint32) {
	volatile.StoreUint32(&o.PCR11.Reg, volatile.LoadUint32(&o.PCR11.Reg)&^(0x1000000)|value<<24)
}
func (o *PORT_Type) GetPCR11_ISF() uint32 {
	return (volatile.LoadUint32(&o.PCR11.Reg) & 0x1000000) >> 24
}

// PORT.PCR12: Pin Control Register n
func (o *PORT_Type) SetPCR12_PS(value uint32) {
	volatile.StoreUint32(&o.PCR12.Reg, volatile.LoadUint32(&o.PCR12.Reg)&^(0x1)|value)
}
func (o *PORT_Type) GetPCR12_PS() uint32 {
	return volatile.LoadUint32(&o.PCR12.Reg) & 0x1
}
func (o *PORT_Type) SetPCR12_PE(value uint32) {
	volatile.StoreUint32(&o.PCR12.Reg, volatile.LoadUint32(&o.PCR12.Reg)&^(0x2)|value<<1)
}
func (o *PORT_Type) GetPCR12_PE() uint32 {
	return (volatile.LoadUint32(&o.PCR12.Reg) & 0x2) >> 1
}
func (o *PORT_Type) SetPCR12_SRE(value uint32) {
	volatile.StoreUint32(&o.PCR12.Reg, volatile.LoadUint32(&o.PCR12.Reg)&^(0x4)|value<<2)
}
func (o *PORT_Type) GetPCR12_SRE() uint32 {
	return (volatile.LoadUint32(&o.PCR12.Reg) & 0x4) >> 2
}
func (o *PORT_Type) SetPCR12_PFE(value uint32) {
	volatile.StoreUint32(&o.PCR12.Reg, volatile.LoadUint32(&o.PCR12.Reg)&^(0x10)|value<<4)
}
func (o *PORT_Type) GetPCR12_PFE() uint32 {
	return (volatile.LoadUint32(&o.PCR12.Reg) & 0x10) >> 4
}
func (o *PORT_Type) SetPCR12_ODE(value uint32) {
	volatile.StoreUint32(&o.PCR12.Reg, volatile.LoadUint32(&o.PCR12.Reg)&^(0x20)|value<<5)
}
func (o *PORT_Type) GetPCR12_ODE() uint32 {
	return (volatile.LoadUint32(&o.PCR12.Reg) & 0x20) >> 5
}
func (o *PORT_Type) SetPCR12_DSE(value uint32) {
	volatile.StoreUint32(&o.PCR12.Reg, volatile.LoadUint32(&o.PCR12.Reg)&^(0x40)|value<<6)
}
func (o *PORT_Type) GetPCR12_DSE() uint32 {
	return (volatile.LoadUint32(&o.PCR12.Reg) & 0x40) >> 6
}
func (o *PORT_Type) SetPCR12_MUX(value uint32) {
	volatile.StoreUint32(&o.PCR12.Reg, volatile.LoadUint32(&o.PCR12.Reg)&^(0x700)|value<<8)
}
func (o *PORT_Type) GetPCR12_MUX() uint32 {
	return (volatile.LoadUint32(&o.PCR12.Reg) & 0x700) >> 8
}
func (o *PORT_Type) SetPCR12_LK(value uint32) {
	volatile.StoreUint32(&o.PCR12.Reg, volatile.LoadUint32(&o.PCR12.Reg)&^(0x8000)|value<<15)
}
func (o *PORT_Type) GetPCR12_LK() uint32 {
	return (volatile.LoadUint32(&o.PCR12.Reg) & 0x8000) >> 15
}
func (o *PORT_Type) SetPCR12_IRQC(value uint32) {
	volatile.StoreUint32(&o.PCR12.Reg, volatile.LoadUint32(&o.PCR12.Reg)&^(0xf0000)|value<<16)
}
func (o *PORT_Type) GetPCR12_IRQC() uint32 {
	return (volatile.LoadUint32(&o.PCR12.Reg) & 0xf0000) >> 16
}
func (o *PORT_Type) SetPCR12_ISF(value uint32) {
	volatile.StoreUint32(&o.PCR12.Reg, volatile.LoadUint32(&o.PCR12.Reg)&^(0x1000000)|value<<24)
}
func (o *PORT_Type) GetPCR12_ISF() uint32 {
	return (volatile.LoadUint32(&o.PCR12.Reg) & 0x1000000) >> 24
}

// PORT.PCR13: Pin Control Register n
func (o *PORT_Type) SetPCR13_PS(value uint32) {
	volatile.StoreUint32(&o.PCR13.Reg, volatile.LoadUint32(&o.PCR13.Reg)&^(0x1)|value)
}
func (o *PORT_Type) GetPCR13_PS() uint32 {
	return volatile.LoadUint32(&o.PCR13.Reg) & 0x1
}
func (o *PORT_Type) SetPCR13_PE(value uint32) {
	volatile.StoreUint32(&o.PCR13.Reg, volatile.LoadUint32(&o.PCR13.Reg)&^(0x2)|value<<1)
}
func (o *PORT_Type) GetPCR13_PE() uint32 {
	return (volatile.LoadUint32(&o.PCR13.Reg) & 0x2) >> 1
}
func (o *PORT_Type) SetPCR13_SRE(value uint32) {
	volatile.StoreUint32(&o.PCR13.Reg, volatile.LoadUint32(&o.PCR13.Reg)&^(0x4)|value<<2)
}
func (o *PORT_Type) GetPCR13_SRE() uint32 {
	return (volatile.LoadUint32(&o.PCR13.Reg) & 0x4) >> 2
}
func (o *PORT_Type) SetPCR13_PFE(value uint32) {
	volatile.StoreUint32(&o.PCR13.Reg, volatile.LoadUint32(&o.PCR13.Reg)&^(0x10)|value<<4)
}
func (o *PORT_Type) GetPCR13_PFE() uint32 {
	return (volatile.LoadUint32(&o.PCR13.Reg) & 0x10) >> 4
}
func (o *PORT_Type) SetPCR13_ODE(value uint32) {
	volatile.StoreUint32(&o.PCR13.Reg, volatile.LoadUint32(&o.PCR13.Reg)&^(0x20)|value<<5)
}
func (o *PORT_Type) GetPCR13_ODE() uint32 {
	return (volatile.LoadUint32(&o.PCR13.Reg) & 0x20) >> 5
}
func (o *PORT_Type) SetPCR13_DSE(value uint32) {
	volatile.StoreUint32(&o.PCR13.Reg, volatile.LoadUint32(&o.PCR13.Reg)&^(0x40)|value<<6)
}
func (o *PORT_Type) GetPCR13_DSE() uint32 {
	return (volatile.LoadUint32(&o.PCR13.Reg) & 0x40) >> 6
}
func (o *PORT_Type) SetPCR13_MUX(value uint32) {
	volatile.StoreUint32(&o.PCR13.Reg, volatile.LoadUint32(&o.PCR13.Reg)&^(0x700)|value<<8)
}
func (o *PORT_Type) GetPCR13_MUX() uint32 {
	return (volatile.LoadUint32(&o.PCR13.Reg) & 0x700) >> 8
}
func (o *PORT_Type) SetPCR13_LK(value uint32) {
	volatile.StoreUint32(&o.PCR13.Reg, volatile.LoadUint32(&o.PCR13.Reg)&^(0x8000)|value<<15)
}
func (o *PORT_Type) GetPCR13_LK() uint32 {
	return (volatile.LoadUint32(&o.PCR13.Reg) & 0x8000) >> 15
}
func (o *PORT_Type) SetPCR13_IRQC(value uint32) {
	volatile.StoreUint32(&o.PCR13.Reg, volatile.LoadUint32(&o.PCR13.Reg)&^(0xf0000)|value<<16)
}
func (o *PORT_Type) GetPCR13_IRQC() uint32 {
	return (volatile.LoadUint32(&o.PCR13.Reg) & 0xf0000) >> 16
}
func (o *PORT_Type) SetPCR13_ISF(value uint32) {
	volatile.StoreUint32(&o.PCR13.Reg, volatile.LoadUint32(&o.PCR13.Reg)&^(0x1000000)|value<<24)
}
func (o *PORT_Type) GetPCR13_ISF() uint32 {
	return (volatile.LoadUint32(&o.PCR13.Reg) & 0x1000000) >> 24
}

// PORT.PCR14: Pin Control Register n
func (o *PORT_Type) SetPCR14_PS(value uint32) {
	volatile.StoreUint32(&o.PCR14.Reg, volatile.LoadUint32(&o.PCR14.Reg)&^(0x1)|value)
}
func (o *PORT_Type) GetPCR14_PS() uint32 {
	return volatile.LoadUint32(&o.PCR14.Reg) & 0x1
}
func (o *PORT_Type) SetPCR14_PE(value uint32) {
	volatile.StoreUint32(&o.PCR14.Reg, volatile.LoadUint32(&o.PCR14.Reg)&^(0x2)|value<<1)
}
func (o *PORT_Type) GetPCR14_PE() uint32 {
	return (volatile.LoadUint32(&o.PCR14.Reg) & 0x2) >> 1
}
func (o *PORT_Type) SetPCR14_SRE(value uint32) {
	volatile.StoreUint32(&o.PCR14.Reg, volatile.LoadUint32(&o.PCR14.Reg)&^(0x4)|value<<2)
}
func (o *PORT_Type) GetPCR14_SRE() uint32 {
	return (volatile.LoadUint32(&o.PCR14.Reg) & 0x4) >> 2
}
func (o *PORT_Type) SetPCR14_PFE(value uint32) {
	volatile.StoreUint32(&o.PCR14.Reg, volatile.LoadUint32(&o.PCR14.Reg)&^(0x10)|value<<4)
}
func (o *PORT_Type) GetPCR14_PFE() uint32 {
	return (volatile.LoadUint32(&o.PCR14.Reg) & 0x10) >> 4
}
func (o *PORT_Type) SetPCR14_ODE(value uint32) {
	volatile.StoreUint32(&o.PCR14.Reg, volatile.LoadUint32(&o.PCR14.Reg)&^(0x20)|value<<5)
}
func (o *PORT_Type) GetPCR14_ODE() uint32 {
	return (volatile.LoadUint32(&o.PCR14.Reg) & 0x20) >> 5
}
func (o *PORT_Type) SetPCR14_DSE(value uint32) {
	volatile.StoreUint32(&o.PCR14.Reg, volatile.LoadUint32(&o.PCR14.Reg)&^(0x40)|value<<6)
}
func (o *PORT_Type) GetPCR14_DSE() uint32 {
	return (volatile.LoadUint32(&o.PCR14.Reg) & 0x40) >> 6
}
func (o *PORT_Type) SetPCR14_MUX(value uint32) {
	volatile.StoreUint32(&o.PCR14.Reg, volatile.LoadUint32(&o.PCR14.Reg)&^(0x700)|value<<8)
}
func (o *PORT_Type) GetPCR14_MUX() uint32 {
	return (volatile.LoadUint32(&o.PCR14.Reg) & 0x700) >> 8
}
func (o *PORT_Type) SetPCR14_LK(value uint32) {
	volatile.StoreUint32(&o.PCR14.Reg, volatile.LoadUint32(&o.PCR14.Reg)&^(0x8000)|value<<15)
}
func (o *PORT_Type) GetPCR14_LK() uint32 {
	return (volatile.LoadUint32(&o.PCR14.Reg) & 0x8000) >> 15
}
func (o *PORT_Type) SetPCR14_IRQC(value uint32) {
	volatile.StoreUint32(&o.PCR14.Reg, volatile.LoadUint32(&o.PCR14.Reg)&^(0xf0000)|value<<16)
}
func (o *PORT_Type) GetPCR14_IRQC() uint32 {
	return (volatile.LoadUint32(&o.PCR14.Reg) & 0xf0000) >> 16
}
func (o *PORT_Type) SetPCR14_ISF(value uint32) {
	volatile.StoreUint32(&o.PCR14.Reg, volatile.LoadUint32(&o.PCR14.Reg)&^(0x1000000)|value<<24)
}
func (o *PORT_Type) GetPCR14_ISF() uint32 {
	return (volatile.LoadUint32(&o.PCR14.Reg) & 0x1000000) >> 24
}

// PORT.PCR15: Pin Control Register n
func (o *PORT_Type) SetPCR15_PS(value uint32) {
	volatile.StoreUint32(&o.PCR15.Reg, volatile.LoadUint32(&o.PCR15.Reg)&^(0x1)|value)
}
func (o *PORT_Type) GetPCR15_PS() uint32 {
	return volatile.LoadUint32(&o.PCR15.Reg) & 0x1
}
func (o *PORT_Type) SetPCR15_PE(value uint32) {
	volatile.StoreUint32(&o.PCR15.Reg, volatile.LoadUint32(&o.PCR15.Reg)&^(0x2)|value<<1)
}
func (o *PORT_Type) GetPCR15_PE() uint32 {
	return (volatile.LoadUint32(&o.PCR15.Reg) & 0x2) >> 1
}
func (o *PORT_Type) SetPCR15_SRE(value uint32) {
	volatile.StoreUint32(&o.PCR15.Reg, volatile.LoadUint32(&o.PCR15.Reg)&^(0x4)|value<<2)
}
func (o *PORT_Type) GetPCR15_SRE() uint32 {
	return (volatile.LoadUint32(&o.PCR15.Reg) & 0x4) >> 2
}
func (o *PORT_Type) SetPCR15_PFE(value uint32) {
	volatile.StoreUint32(&o.PCR15.Reg, volatile.LoadUint32(&o.PCR15.Reg)&^(0x10)|value<<4)
}
func (o *PORT_Type) GetPCR15_PFE() uint32 {
	return (volatile.LoadUint32(&o.PCR15.Reg) & 0x10) >> 4
}
func (o *PORT_Type) SetPCR15_ODE(value uint32) {
	volatile.StoreUint32(&o.PCR15.Reg, volatile.LoadUint32(&o.PCR15.Reg)&^(0x20)|value<<5)
}
func (o *PORT_Type) GetPCR15_ODE() uint32 {
	return (volatile.LoadUint32(&o.PCR15.Reg) & 0x20) >> 5
}
func (o *PORT_Type) SetPCR15_DSE(value uint32) {
	volatile.StoreUint32(&o.PCR15.Reg, volatile.LoadUint32(&o.PCR15.Reg)&^(0x40)|value<<6)
}
func (o *PORT_Type) GetPCR15_DSE() uint32 {
	return (volatile.LoadUint32(&o.PCR15.Reg) & 0x40) >> 6
}
func (o *PORT_Type) SetPCR15_MUX(value uint32) {
	volatile.StoreUint32(&o.PCR15.Reg, volatile.LoadUint32(&o.PCR15.Reg)&^(0x700)|value<<8)
}
func (o *PORT_Type) GetPCR15_MUX() uint32 {
	return (volatile.LoadUint32(&o.PCR15.Reg) & 0x700) >> 8
}
func (o *PORT_Type) SetPCR15_LK(value uint32) {
	volatile.StoreUint32(&o.PCR15.Reg, volatile.LoadUint32(&o.PCR15.Reg)&^(0x8000)|value<<15)
}
func (o *PORT_Type) GetPCR15_LK() uint32 {
	return (volatile.LoadUint32(&o.PCR15.Reg) & 0x8000) >> 15
}
func (o *PORT_Type) SetPCR15_IRQC(value uint32) {
	volatile.StoreUint32(&o.PCR15.Reg, volatile.LoadUint32(&o.PCR15.Reg)&^(0xf0000)|value<<16)
}
func (o *PORT_Type) GetPCR15_IRQC() uint32 {
	return (volatile.LoadUint32(&o.PCR15.Reg) & 0xf0000) >> 16
}
func (o *PORT_Type) SetPCR15_ISF(value uint32) {
	volatile.StoreUint32(&o.PCR15.Reg, volatile.LoadUint32(&o.PCR15.Reg)&^(0x1000000)|value<<24)
}
func (o *PORT_Type) GetPCR15_ISF() uint32 {
	return (volatile.LoadUint32(&o.PCR15.Reg) & 0x1000000) >> 24
}

// PORT.PCR16: Pin Control Register n
func (o *PORT_Type) SetPCR16_PS(value uint32) {
	volatile.StoreUint32(&o.PCR16.Reg, volatile.LoadUint32(&o.PCR16.Reg)&^(0x1)|value)
}
func (o *PORT_Type) GetPCR16_PS() uint32 {
	return volatile.LoadUint32(&o.PCR16.Reg) & 0x1
}
func (o *PORT_Type) SetPCR16_PE(value uint32) {
	volatile.StoreUint32(&o.PCR16.Reg, volatile.LoadUint32(&o.PCR16.Reg)&^(0x2)|value<<1)
}
func (o *PORT_Type) GetPCR16_PE() uint32 {
	return (volatile.LoadUint32(&o.PCR16.Reg) & 0x2) >> 1
}
func (o *PORT_Type) SetPCR16_SRE(value uint32) {
	volatile.StoreUint32(&o.PCR16.Reg, volatile.LoadUint32(&o.PCR16.Reg)&^(0x4)|value<<2)
}
func (o *PORT_Type) GetPCR16_SRE() uint32 {
	return (volatile.LoadUint32(&o.PCR16.Reg) & 0x4) >> 2
}
func (o *PORT_Type) SetPCR16_PFE(value uint32) {
	volatile.StoreUint32(&o.PCR16.Reg, volatile.LoadUint32(&o.PCR16.Reg)&^(0x10)|value<<4)
}
func (o *PORT_Type) GetPCR16_PFE() uint32 {
	return (volatile.LoadUint32(&o.PCR16.Reg) & 0x10) >> 4
}
func (o *PORT_Type) SetPCR16_ODE(value uint32) {
	volatile.StoreUint32(&o.PCR16.Reg, volatile.LoadUint32(&o.PCR16.Reg)&^(0x20)|value<<5)
}
func (o *PORT_Type) GetPCR16_ODE() uint32 {
	return (volatile.LoadUint32(&o.PCR16.Reg) & 0x20) >> 5
}
func (o *PORT_Type) SetPCR16_DSE(value uint32) {
	volatile.StoreUint32(&o.PCR16.Reg, volatile.LoadUint32(&o.PCR16.Reg)&^(0x40)|value<<6)
}
func (o *PORT_Type) GetPCR16_DSE() uint32 {
	return (volatile.LoadUint32(&o.PCR16.Reg) & 0x40) >> 6
}
func (o *PORT_Type) SetPCR16_MUX(value uint32) {
	volatile.StoreUint32(&o.PCR16.Reg, volatile.LoadUint32(&o.PCR16.Reg)&^(0x700)|value<<8)
}
func (o *PORT_Type) GetPCR16_MUX() uint32 {
	return (volatile.LoadUint32(&o.PCR16.Reg) & 0x700) >> 8
}
func (o *PORT_Type) SetPCR16_LK(value uint32) {
	volatile.StoreUint32(&o.PCR16.Reg, volatile.LoadUint32(&o.PCR16.Reg)&^(0x8000)|value<<15)
}
func (o *PORT_Type) GetPCR16_LK() uint32 {
	return (volatile.LoadUint32(&o.PCR16.Reg) & 0x8000) >> 15
}
func (o *PORT_Type) SetPCR16_IRQC(value uint32) {
	volatile.StoreUint32(&o.PCR16.Reg, volatile.LoadUint32(&o.PCR16.Reg)&^(0xf0000)|value<<16)
}
func (o *PORT_Type) GetPCR16_IRQC() uint32 {
	return (volatile.LoadUint32(&o.PCR16.Reg) & 0xf0000) >> 16
}
func (o *PORT_Type) SetPCR16_ISF(value uint32) {
	volatile.StoreUint32(&o.PCR16.Reg, volatile.LoadUint32(&o.PCR16.Reg)&^(0x1000000)|value<<24)
}
func (o *PORT_Type) GetPCR16_ISF() uint32 {
	return (volatile.LoadUint32(&o.PCR16.Reg) & 0x1000000) >> 24
}

// PORT.PCR17: Pin Control Register n
func (o *PORT_Type) SetPCR17_PS(value uint32) {
	volatile.StoreUint32(&o.PCR17.Reg, volatile.LoadUint32(&o.PCR17.Reg)&^(0x1)|value)
}
func (o *PORT_Type) GetPCR17_PS() uint32 {
	return volatile.LoadUint32(&o.PCR17.Reg) & 0x1
}
func (o *PORT_Type) SetPCR17_PE(value uint32) {
	volatile.StoreUint32(&o.PCR17.Reg, volatile.LoadUint32(&o.PCR17.Reg)&^(0x2)|value<<1)
}
func (o *PORT_Type) GetPCR17_PE() uint32 {
	return (volatile.LoadUint32(&o.PCR17.Reg) & 0x2) >> 1
}
func (o *PORT_Type) SetPCR17_SRE(value uint32) {
	volatile.StoreUint32(&o.PCR17.Reg, volatile.LoadUint32(&o.PCR17.Reg)&^(0x4)|value<<2)
}
func (o *PORT_Type) GetPCR17_SRE() uint32 {
	return (volatile.LoadUint32(&o.PCR17.Reg) & 0x4) >> 2
}
func (o *PORT_Type) SetPCR17_PFE(value uint32) {
	volatile.StoreUint32(&o.PCR17.Reg, volatile.LoadUint32(&o.PCR17.Reg)&^(0x10)|value<<4)
}
func (o *PORT_Type) GetPCR17_PFE() uint32 {
	return (volatile.LoadUint32(&o.PCR17.Reg) & 0x10) >> 4
}
func (o *PORT_Type) SetPCR17_ODE(value uint32) {
	volatile.StoreUint32(&o.PCR17.Reg, volatile.LoadUint32(&o.PCR17.Reg)&^(0x20)|value<<5)
}
func (o *PORT_Type) GetPCR17_ODE() uint32 {
	return (volatile.LoadUint32(&o.PCR17.Reg) & 0x20) >> 5
}
func (o *PORT_Type) SetPCR17_DSE(value uint32) {
	volatile.StoreUint32(&o.PCR17.Reg, volatile.LoadUint32(&o.PCR17.Reg)&^(0x40)|value<<6)
}
func (o *PORT_Type) GetPCR17_DSE() uint32 {
	return (volatile.LoadUint32(&o.PCR17.Reg) & 0x40) >> 6
}
func (o *PORT_Type) SetPCR17_MUX(value uint32) {
	volatile.StoreUint32(&o.PCR17.Reg, volatile.LoadUint32(&o.PCR17.Reg)&^(0x700)|value<<8)
}
func (o *PORT_Type) GetPCR17_MUX() uint32 {
	return (volatile.LoadUint32(&o.PCR17.Reg) & 0x700) >> 8
}
func (o *PORT_Type) SetPCR17_LK(value uint32) {
	volatile.StoreUint32(&o.PCR17.Reg, volatile.LoadUint32(&o.PCR17.Reg)&^(0x8000)|value<<15)
}
func (o *PORT_Type) GetPCR17_LK() uint32 {
	return (volatile.LoadUint32(&o.PCR17.Reg) & 0x8000) >> 15
}
func (o *PORT_Type) SetPCR17_IRQC(value uint32) {
	volatile.StoreUint32(&o.PCR17.Reg, volatile.LoadUint32(&o.PCR17.Reg)&^(0xf0000)|value<<16)
}
func (o *PORT_Type) GetPCR17_IRQC() uint32 {
	return (volatile.LoadUint32(&o.PCR17.Reg) & 0xf0000) >> 16
}
func (o *PORT_Type) SetPCR17_ISF(value uint32) {
	volatile.StoreUint32(&o.PCR17.Reg, volatile.LoadUint32(&o.PCR17.Reg)&^(0x1000000)|value<<24)
}
func (o *PORT_Type) GetPCR17_ISF() uint32 {
	return (volatile.LoadUint32(&o.PCR17.Reg) & 0x1000000) >> 24
}

// PORT.PCR18: Pin Control Register n
func (o *PORT_Type) SetPCR18_PS(value uint32) {
	volatile.StoreUint32(&o.PCR18.Reg, volatile.LoadUint32(&o.PCR18.Reg)&^(0x1)|value)
}
func (o *PORT_Type) GetPCR18_PS() uint32 {
	return volatile.LoadUint32(&o.PCR18.Reg) & 0x1
}
func (o *PORT_Type) SetPCR18_PE(value uint32) {
	volatile.StoreUint32(&o.PCR18.Reg, volatile.LoadUint32(&o.PCR18.Reg)&^(0x2)|value<<1)
}
func (o *PORT_Type) GetPCR18_PE() uint32 {
	return (volatile.LoadUint32(&o.PCR18.Reg) & 0x2) >> 1
}
func (o *PORT_Type) SetPCR18_SRE(value uint32) {
	volatile.StoreUint32(&o.PCR18.Reg, volatile.LoadUint32(&o.PCR18.Reg)&^(0x4)|value<<2)
}
func (o *PORT_Type) GetPCR18_SRE() uint32 {
	return (volatile.LoadUint32(&o.PCR18.Reg) & 0x4) >> 2
}
func (o *PORT_Type) SetPCR18_PFE(value uint32) {
	volatile.StoreUint32(&o.PCR18.Reg, volatile.LoadUint32(&o.PCR18.Reg)&^(0x10)|value<<4)
}
func (o *PORT_Type) GetPCR18_PFE() uint32 {
	return (volatile.LoadUint32(&o.PCR18.Reg) & 0x10) >> 4
}
func (o *PORT_Type) SetPCR18_ODE(value uint32) {
	volatile.StoreUint32(&o.PCR18.Reg, volatile.LoadUint32(&o.PCR18.Reg)&^(0x20)|value<<5)
}
func (o *PORT_Type) GetPCR18_ODE() uint32 {
	return (volatile.LoadUint32(&o.PCR18.Reg) & 0x20) >> 5
}
func (o *PORT_Type) SetPCR18_DSE(value uint32) {
	volatile.StoreUint32(&o.PCR18.Reg, volatile.LoadUint32(&o.PCR18.Reg)&^(0x40)|value<<6)
}
func (o *PORT_Type) GetPCR18_DSE() uint32 {
	return (volatile.LoadUint32(&o.PCR18.Reg) & 0x40) >> 6
}
func (o *PORT_Type) SetPCR18_MUX(value uint32) {
	volatile.StoreUint32(&o.PCR18.Reg, volatile.LoadUint32(&o.PCR18.Reg)&^(0x700)|value<<8)
}
func (o *PORT_Type) GetPCR18_MUX() uint32 {
	return (volatile.LoadUint32(&o.PCR18.Reg) & 0x700) >> 8
}
func (o *PORT_Type) SetPCR18_LK(value uint32) {
	volatile.StoreUint32(&o.PCR18.Reg, volatile.LoadUint32(&o.PCR18.Reg)&^(0x8000)|value<<15)
}
func (o *PORT_Type) GetPCR18_LK() uint32 {
	return (volatile.LoadUint32(&o.PCR18.Reg) & 0x8000) >> 15
}
func (o *PORT_Type) SetPCR18_IRQC(value uint32) {
	volatile.StoreUint32(&o.PCR18.Reg, volatile.LoadUint32(&o.PCR18.Reg)&^(0xf0000)|value<<16)
}
func (o *PORT_Type) GetPCR18_IRQC() uint32 {
	return (volatile.LoadUint32(&o.PCR18.Reg) & 0xf0000) >> 16
}
func (o *PORT_Type) SetPCR18_ISF(value uint32) {
	volatile.StoreUint32(&o.PCR18.Reg, volatile.LoadUint32(&o.PCR18.Reg)&^(0x1000000)|value<<24)
}
func (o *PORT_Type) GetPCR18_ISF() uint32 {
	return (volatile.LoadUint32(&o.PCR18.Reg) & 0x1000000) >> 24
}

// PORT.PCR19: Pin Control Register n
func (o *PORT_Type) SetPCR19_PS(value uint32) {
	volatile.StoreUint32(&o.PCR19.Reg, volatile.LoadUint32(&o.PCR19.Reg)&^(0x1)|value)
}
func (o *PORT_Type) GetPCR19_PS() uint32 {
	return volatile.LoadUint32(&o.PCR19.Reg) & 0x1
}
func (o *PORT_Type) SetPCR19_PE(value uint32) {
	volatile.StoreUint32(&o.PCR19.Reg, volatile.LoadUint32(&o.PCR19.Reg)&^(0x2)|value<<1)
}
func (o *PORT_Type) GetPCR19_PE() uint32 {
	return (volatile.LoadUint32(&o.PCR19.Reg) & 0x2) >> 1
}
func (o *PORT_Type) SetPCR19_SRE(value uint32) {
	volatile.StoreUint32(&o.PCR19.Reg, volatile.LoadUint32(&o.PCR19.Reg)&^(0x4)|value<<2)
}
func (o *PORT_Type) GetPCR19_SRE() uint32 {
	return (volatile.LoadUint32(&o.PCR19.Reg) & 0x4) >> 2
}
func (o *PORT_Type) SetPCR19_PFE(value uint32) {
	volatile.StoreUint32(&o.PCR19.Reg, volatile.LoadUint32(&o.PCR19.Reg)&^(0x10)|value<<4)
}
func (o *PORT_Type) GetPCR19_PFE() uint32 {
	return (volatile.LoadUint32(&o.PCR19.Reg) & 0x10) >> 4
}
func (o *PORT_Type) SetPCR19_ODE(value uint32) {
	volatile.StoreUint32(&o.PCR19.Reg, volatile.LoadUint32(&o.PCR19.Reg)&^(0x20)|value<<5)
}
func (o *PORT_Type) GetPCR19_ODE() uint32 {
	return (volatile.LoadUint32(&o.PCR19.Reg) & 0x20) >> 5
}
func (o *PORT_Type) SetPCR19_DSE(value uint32) {
	volatile.StoreUint32(&o.PCR19.Reg, volatile.LoadUint32(&o.PCR19.Reg)&^(0x40)|value<<6)
}
func (o *PORT_Type) GetPCR19_DSE() uint32 {
	return (volatile.LoadUint32(&o.PCR19.Reg) & 0x40) >> 6
}
func (o *PORT_Type) SetPCR19_MUX(value uint32) {
	volatile.StoreUint32(&o.PCR19.Reg, volatile.LoadUint32(&o.PCR19.Reg)&^(0x700)|value<<8)
}
func (o *PORT_Type) GetPCR19_MUX() uint32 {
	return (volatile.LoadUint32(&o.PCR19.Reg) & 0x700) >> 8
}
func (o *PORT_Type) SetPCR19_LK(value uint32) {
	volatile.StoreUint32(&o.PCR19.Reg, volatile.LoadUint32(&o.PCR19.Reg)&^(0x8000)|value<<15)
}
func (o *PORT_Type) GetPCR19_LK() uint32 {
	return (volatile.LoadUint32(&o.PCR19.Reg) & 0x8000) >> 15
}
func (o *PORT_Type) SetPCR19_IRQC(value uint32) {
	volatile.StoreUint32(&o.PCR19.Reg, volatile.LoadUint32(&o.PCR19.Reg)&^(0xf0000)|value<<16)
}
func (o *PORT_Type) GetPCR19_IRQC() uint32 {
	return (volatile.LoadUint32(&o.PCR19.Reg) & 0xf0000) >> 16
}
func (o *PORT_Type) SetPCR19_ISF(value uint32) {
	volatile.StoreUint32(&o.PCR19.Reg, volatile.LoadUint32(&o.PCR19.Reg)&^(0x1000000)|value<<24)
}
func (o *PORT_Type) GetPCR19_ISF() uint32 {
	return (volatile.LoadUint32(&o.PCR19.Reg) & 0x1000000) >> 24
}

// PORT.PCR20: Pin Control Register n
func (o *PORT_Type) SetPCR20_PS(value uint32) {
	volatile.StoreUint32(&o.PCR20.Reg, volatile.LoadUint32(&o.PCR20.Reg)&^(0x1)|value)
}
func (o *PORT_Type) GetPCR20_PS() uint32 {
	return volatile.LoadUint32(&o.PCR20.Reg) & 0x1
}
func (o *PORT_Type) SetPCR20_PE(value uint32) {
	volatile.StoreUint32(&o.PCR20.Reg, volatile.LoadUint32(&o.PCR20.Reg)&^(0x2)|value<<1)
}
func (o *PORT_Type) GetPCR20_PE() uint32 {
	return (volatile.LoadUint32(&o.PCR20.Reg) & 0x2) >> 1
}
func (o *PORT_Type) SetPCR20_SRE(value uint32) {
	volatile.StoreUint32(&o.PCR20.Reg, volatile.LoadUint32(&o.PCR20.Reg)&^(0x4)|value<<2)
}
func (o *PORT_Type) GetPCR20_SRE() uint32 {
	return (volatile.LoadUint32(&o.PCR20.Reg) & 0x4) >> 2
}
func (o *PORT_Type) SetPCR20_PFE(value uint32) {
	volatile.StoreUint32(&o.PCR20.Reg, volatile.LoadUint32(&o.PCR20.Reg)&^(0x10)|value<<4)
}
func (o *PORT_Type) GetPCR20_PFE() uint32 {
	return (volatile.LoadUint32(&o.PCR20.Reg) & 0x10) >> 4
}
func (o *PORT_Type) SetPCR20_ODE(value uint32) {
	volatile.StoreUint32(&o.PCR20.Reg, volatile.LoadUint32(&o.PCR20.Reg)&^(0x20)|value<<5)
}
func (o *PORT_Type) GetPCR20_ODE() uint32 {
	return (volatile.LoadUint32(&o.PCR20.Reg) & 0x20) >> 5
}
func (o *PORT_Type) SetPCR20_DSE(value uint32) {
	volatile.StoreUint32(&o.PCR20.Reg, volatile.LoadUint32(&o.PCR20.Reg)&^(0x40)|value<<6)
}
func (o *PORT_Type) GetPCR20_DSE() uint32 {
	return (volatile.LoadUint32(&o.PCR20.Reg) & 0x40) >> 6
}
func (o *PORT_Type) SetPCR20_MUX(value uint32) {
	volatile.StoreUint32(&o.PCR20.Reg, volatile.LoadUint32(&o.PCR20.Reg)&^(0x700)|value<<8)
}
func (o *PORT_Type) GetPCR20_MUX() uint32 {
	return (volatile.LoadUint32(&o.PCR20.Reg) & 0x700) >> 8
}
func (o *PORT_Type) SetPCR20_LK(value uint32) {
	volatile.StoreUint32(&o.PCR20.Reg, volatile.LoadUint32(&o.PCR20.Reg)&^(0x8000)|value<<15)
}
func (o *PORT_Type) GetPCR20_LK() uint32 {
	return (volatile.LoadUint32(&o.PCR20.Reg) & 0x8000) >> 15
}
func (o *PORT_Type) SetPCR20_IRQC(value uint32) {
	volatile.StoreUint32(&o.PCR20.Reg, volatile.LoadUint32(&o.PCR20.Reg)&^(0xf0000)|value<<16)
}
func (o *PORT_Type) GetPCR20_IRQC() uint32 {
	return (volatile.LoadUint32(&o.PCR20.Reg) & 0xf0000) >> 16
}
func (o *PORT_Type) SetPCR20_ISF(value uint32) {
	volatile.StoreUint32(&o.PCR20.Reg, volatile.LoadUint32(&o.PCR20.Reg)&^(0x1000000)|value<<24)
}
func (o *PORT_Type) GetPCR20_ISF() uint32 {
	return (volatile.LoadUint32(&o.PCR20.Reg) & 0x1000000) >> 24
}

// PORT.PCR21: Pin Control Register n
func (o *PORT_Type) SetPCR21_PS(value uint32) {
	volatile.StoreUint32(&o.PCR21.Reg, volatile.LoadUint32(&o.PCR21.Reg)&^(0x1)|value)
}
func (o *PORT_Type) GetPCR21_PS() uint32 {
	return volatile.LoadUint32(&o.PCR21.Reg) & 0x1
}
func (o *PORT_Type) SetPCR21_PE(value uint32) {
	volatile.StoreUint32(&o.PCR21.Reg, volatile.LoadUint32(&o.PCR21.Reg)&^(0x2)|value<<1)
}
func (o *PORT_Type) GetPCR21_PE() uint32 {
	return (volatile.LoadUint32(&o.PCR21.Reg) & 0x2) >> 1
}
func (o *PORT_Type) SetPCR21_SRE(value uint32) {
	volatile.StoreUint32(&o.PCR21.Reg, volatile.LoadUint32(&o.PCR21.Reg)&^(0x4)|value<<2)
}
func (o *PORT_Type) GetPCR21_SRE() uint32 {
	return (volatile.LoadUint32(&o.PCR21.Reg) & 0x4) >> 2
}
func (o *PORT_Type) SetPCR21_PFE(value uint32) {
	volatile.StoreUint32(&o.PCR21.Reg, volatile.LoadUint32(&o.PCR21.Reg)&^(0x10)|value<<4)
}
func (o *PORT_Type) GetPCR21_PFE() uint32 {
	return (volatile.LoadUint32(&o.PCR21.Reg) & 0x10) >> 4
}
func (o *PORT_Type) SetPCR21_ODE(value uint32) {
	volatile.StoreUint32(&o.PCR21.Reg, volatile.LoadUint32(&o.PCR21.Reg)&^(0x20)|value<<5)
}
func (o *PORT_Type) GetPCR21_ODE() uint32 {
	return (volatile.LoadUint32(&o.PCR21.Reg) & 0x20) >> 5
}
func (o *PORT_Type) SetPCR21_DSE(value uint32) {
	volatile.StoreUint32(&o.PCR21.Reg, volatile.LoadUint32(&o.PCR21.Reg)&^(0x40)|value<<6)
}
func (o *PORT_Type) GetPCR21_DSE() uint32 {
	return (volatile.LoadUint32(&o.PCR21.Reg) & 0x40) >> 6
}
func (o *PORT_Type) SetPCR21_MUX(value uint32) {
	volatile.StoreUint32(&o.PCR21.Reg, volatile.LoadUint32(&o.PCR21.Reg)&^(0x700)|value<<8)
}
func (o *PORT_Type) GetPCR21_MUX() uint32 {
	return (volatile.LoadUint32(&o.PCR21.Reg) & 0x700) >> 8
}
func (o *PORT_Type) SetPCR21_LK(value uint32) {
	volatile.StoreUint32(&o.PCR21.Reg, volatile.LoadUint32(&o.PCR21.Reg)&^(0x8000)|value<<15)
}
func (o *PORT_Type) GetPCR21_LK() uint32 {
	return (volatile.LoadUint32(&o.PCR21.Reg) & 0x8000) >> 15
}
func (o *PORT_Type) SetPCR21_IRQC(value uint32) {
	volatile.StoreUint32(&o.PCR21.Reg, volatile.LoadUint32(&o.PCR21.Reg)&^(0xf0000)|value<<16)
}
func (o *PORT_Type) GetPCR21_IRQC() uint32 {
	return (volatile.LoadUint32(&o.PCR21.Reg) & 0xf0000) >> 16
}
func (o *PORT_Type) SetPCR21_ISF(value uint32) {
	volatile.StoreUint32(&o.PCR21.Reg, volatile.LoadUint32(&o.PCR21.Reg)&^(0x1000000)|value<<24)
}
func (o *PORT_Type) GetPCR21_ISF() uint32 {
	return (volatile.LoadUint32(&o.PCR21.Reg) & 0x1000000) >> 24
}

// PORT.PCR22: Pin Control Register n
func (o *PORT_Type) SetPCR22_PS(value uint32) {
	volatile.StoreUint32(&o.PCR22.Reg, volatile.LoadUint32(&o.PCR22.Reg)&^(0x1)|value)
}
func (o *PORT_Type) GetPCR22_PS() uint32 {
	return volatile.LoadUint32(&o.PCR22.Reg) & 0x1
}
func (o *PORT_Type) SetPCR22_PE(value uint32) {
	volatile.StoreUint32(&o.PCR22.Reg, volatile.LoadUint32(&o.PCR22.Reg)&^(0x2)|value<<1)
}
func (o *PORT_Type) GetPCR22_PE() uint32 {
	return (volatile.LoadUint32(&o.PCR22.Reg) & 0x2) >> 1
}
func (o *PORT_Type) SetPCR22_SRE(value uint32) {
	volatile.StoreUint32(&o.PCR22.Reg, volatile.LoadUint32(&o.PCR22.Reg)&^(0x4)|value<<2)
}
func (o *PORT_Type) GetPCR22_SRE() uint32 {
	return (volatile.LoadUint32(&o.PCR22.Reg) & 0x4) >> 2
}
func (o *PORT_Type) SetPCR22_PFE(value uint32) {
	volatile.StoreUint32(&o.PCR22.Reg, volatile.LoadUint32(&o.PCR22.Reg)&^(0x10)|value<<4)
}
func (o *PORT_Type) GetPCR22_PFE() uint32 {
	return (volatile.LoadUint32(&o.PCR22.Reg) & 0x10) >> 4
}
func (o *PORT_Type) SetPCR22_ODE(value uint32) {
	volatile.StoreUint32(&o.PCR22.Reg, volatile.LoadUint32(&o.PCR22.Reg)&^(0x20)|value<<5)
}
func (o *PORT_Type) GetPCR22_ODE() uint32 {
	return (volatile.LoadUint32(&o.PCR22.Reg) & 0x20) >> 5
}
func (o *PORT_Type) SetPCR22_DSE(value uint32) {
	volatile.StoreUint32(&o.PCR22.Reg, volatile.LoadUint32(&o.PCR22.Reg)&^(0x40)|value<<6)
}
func (o *PORT_Type) GetPCR22_DSE() uint32 {
	return (volatile.LoadUint32(&o.PCR22.Reg) & 0x40) >> 6
}
func (o *PORT_Type) SetPCR22_MUX(value uint32) {
	volatile.StoreUint32(&o.PCR22.Reg, volatile.LoadUint32(&o.PCR22.Reg)&^(0x700)|value<<8)
}
func (o *PORT_Type) GetPCR22_MUX() uint32 {
	return (volatile.LoadUint32(&o.PCR22.Reg) & 0x700) >> 8
}
func (o *PORT_Type) SetPCR22_LK(value uint32) {
	volatile.StoreUint32(&o.PCR22.Reg, volatile.LoadUint32(&o.PCR22.Reg)&^(0x8000)|value<<15)
}
func (o *PORT_Type) GetPCR22_LK() uint32 {
	return (volatile.LoadUint32(&o.PCR22.Reg) & 0x8000) >> 15
}
func (o *PORT_Type) SetPCR22_IRQC(value uint32) {
	volatile.StoreUint32(&o.PCR22.Reg, volatile.LoadUint32(&o.PCR22.Reg)&^(0xf0000)|value<<16)
}
func (o *PORT_Type) GetPCR22_IRQC() uint32 {
	return (volatile.LoadUint32(&o.PCR22.Reg) & 0xf0000) >> 16
}
func (o *PORT_Type) SetPCR22_ISF(value uint32) {
	volatile.StoreUint32(&o.PCR22.Reg, volatile.LoadUint32(&o.PCR22.Reg)&^(0x1000000)|value<<24)
}
func (o *PORT_Type) GetPCR22_ISF() uint32 {
	return (volatile.LoadUint32(&o.PCR22.Reg) & 0x1000000) >> 24
}

// PORT.PCR23: Pin Control Register n
func (o *PORT_Type) SetPCR23_PS(value uint32) {
	volatile.StoreUint32(&o.PCR23.Reg, volatile.LoadUint32(&o.PCR23.Reg)&^(0x1)|value)
}
func (o *PORT_Type) GetPCR23_PS() uint32 {
	return volatile.LoadUint32(&o.PCR23.Reg) & 0x1
}
func (o *PORT_Type) SetPCR23_PE(value uint32) {
	volatile.StoreUint32(&o.PCR23.Reg, volatile.LoadUint32(&o.PCR23.Reg)&^(0x2)|value<<1)
}
func (o *PORT_Type) GetPCR23_PE() uint32 {
	return (volatile.LoadUint32(&o.PCR23.Reg) & 0x2) >> 1
}
func (o *PORT_Type) SetPCR23_SRE(value uint32) {
	volatile.StoreUint32(&o.PCR23.Reg, volatile.LoadUint32(&o.PCR23.Reg)&^(0x4)|value<<2)
}
func (o *PORT_Type) GetPCR23_SRE() uint32 {
	return (volatile.LoadUint32(&o.PCR23.Reg) & 0x4) >> 2
}
func (o *PORT_Type) SetPCR23_PFE(value uint32) {
	volatile.StoreUint32(&o.PCR23.Reg, volatile.LoadUint32(&o.PCR23.Reg)&^(0x10)|value<<4)
}
func (o *PORT_Type) GetPCR23_PFE() uint32 {
	return (volatile.LoadUint32(&o.PCR23.Reg) & 0x10) >> 4
}
func (o *PORT_Type) SetPCR23_ODE(value uint32) {
	volatile.StoreUint32(&o.PCR23.Reg, volatile.LoadUint32(&o.PCR23.Reg)&^(0x20)|value<<5)
}
func (o *PORT_Type) GetPCR23_ODE() uint32 {
	return (volatile.LoadUint32(&o.PCR23.Reg) & 0x20) >> 5
}
func (o *PORT_Type) SetPCR23_DSE(value uint32) {
	volatile.StoreUint32(&o.PCR23.Reg, volatile.LoadUint32(&o.PCR23.Reg)&^(0x40)|value<<6)
}
func (o *PORT_Type) GetPCR23_DSE() uint32 {
	return (volatile.LoadUint32(&o.PCR23.Reg) & 0x40) >> 6
}
func (o *PORT_Type) SetPCR23_MUX(value uint32) {
	volatile.StoreUint32(&o.PCR23.Reg, volatile.LoadUint32(&o.PCR23.Reg)&^(0x700)|value<<8)
}
func (o *PORT_Type) GetPCR23_MUX() uint32 {
	return (volatile.LoadUint32(&o.PCR23.Reg) & 0x700) >> 8
}
func (o *PORT_Type) SetPCR23_LK(value uint32) {
	volatile.StoreUint32(&o.PCR23.Reg, volatile.LoadUint32(&o.PCR23.Reg)&^(0x8000)|value<<15)
}
func (o *PORT_Type) GetPCR23_LK() uint32 {
	return (volatile.LoadUint32(&o.PCR23.Reg) & 0x8000) >> 15
}
func (o *PORT_Type) SetPCR23_IRQC(value uint32) {
	volatile.StoreUint32(&o.PCR23.Reg, volatile.LoadUint32(&o.PCR23.Reg)&^(0xf0000)|value<<16)
}
func (o *PORT_Type) GetPCR23_IRQC() uint32 {
	return (volatile.LoadUint32(&o.PCR23.Reg) & 0xf0000) >> 16
}
func (o *PORT_Type) SetPCR23_ISF(value uint32) {
	volatile.StoreUint32(&o.PCR23.Reg, volatile.LoadUint32(&o.PCR23.Reg)&^(0x1000000)|value<<24)
}
func (o *PORT_Type) GetPCR23_ISF() uint32 {
	return (volatile.LoadUint32(&o.PCR23.Reg) & 0x1000000) >> 24
}

// PORT.PCR24: Pin Control Register n
func (o *PORT_Type) SetPCR24_PS(value uint32) {
	volatile.StoreUint32(&o.PCR24.Reg, volatile.LoadUint32(&o.PCR24.Reg)&^(0x1)|value)
}
func (o *PORT_Type) GetPCR24_PS() uint32 {
	return volatile.LoadUint32(&o.PCR24.Reg) & 0x1
}
func (o *PORT_Type) SetPCR24_PE(value uint32) {
	volatile.StoreUint32(&o.PCR24.Reg, volatile.LoadUint32(&o.PCR24.Reg)&^(0x2)|value<<1)
}
func (o *PORT_Type) GetPCR24_PE() uint32 {
	return (volatile.LoadUint32(&o.PCR24.Reg) & 0x2) >> 1
}
func (o *PORT_Type) SetPCR24_SRE(value uint32) {
	volatile.StoreUint32(&o.PCR24.Reg, volatile.LoadUint32(&o.PCR24.Reg)&^(0x4)|value<<2)
}
func (o *PORT_Type) GetPCR24_SRE() uint32 {
	return (volatile.LoadUint32(&o.PCR24.Reg) & 0x4) >> 2
}
func (o *PORT_Type) SetPCR24_PFE(value uint32) {
	volatile.StoreUint32(&o.PCR24.Reg, volatile.LoadUint32(&o.PCR24.Reg)&^(0x10)|value<<4)
}
func (o *PORT_Type) GetPCR24_PFE() uint32 {
	return (volatile.LoadUint32(&o.PCR24.Reg) & 0x10) >> 4
}
func (o *PORT_Type) SetPCR24_ODE(value uint32) {
	volatile.StoreUint32(&o.PCR24.Reg, volatile.LoadUint32(&o.PCR24.Reg)&^(0x20)|value<<5)
}
func (o *PORT_Type) GetPCR24_ODE() uint32 {
	return (volatile.LoadUint32(&o.PCR24.Reg) & 0x20) >> 5
}
func (o *PORT_Type) SetPCR24_DSE(value uint32) {
	volatile.StoreUint32(&o.PCR24.Reg, volatile.LoadUint32(&o.PCR24.Reg)&^(0x40)|value<<6)
}
func (o *PORT_Type) GetPCR24_DSE() uint32 {
	return (volatile.LoadUint32(&o.PCR24.Reg) & 0x40) >> 6
}
func (o *PORT_Type) SetPCR24_MUX(value uint32) {
	volatile.StoreUint32(&o.PCR24.Reg, volatile.LoadUint32(&o.PCR24.Reg)&^(0x700)|value<<8)
}
func (o *PORT_Type) GetPCR24_MUX() uint32 {
	return (volatile.LoadUint32(&o.PCR24.Reg) & 0x700) >> 8
}
func (o *PORT_Type) SetPCR24_LK(value uint32) {
	volatile.StoreUint32(&o.PCR24.Reg, volatile.LoadUint32(&o.PCR24.Reg)&^(0x8000)|value<<15)
}
func (o *PORT_Type) GetPCR24_LK() uint32 {
	return (volatile.LoadUint32(&o.PCR24.Reg) & 0x8000) >> 15
}
func (o *PORT_Type) SetPCR24_IRQC(value uint32) {
	volatile.StoreUint32(&o.PCR24.Reg, volatile.LoadUint32(&o.PCR24.Reg)&^(0xf0000)|value<<16)
}
func (o *PORT_Type) GetPCR24_IRQC() uint32 {
	return (volatile.LoadUint32(&o.PCR24.Reg) & 0xf0000) >> 16
}
func (o *PORT_Type) SetPCR24_ISF(value uint32) {
	volatile.StoreUint32(&o.PCR24.Reg, volatile.LoadUint32(&o.PCR24.Reg)&^(0x1000000)|value<<24)
}
func (o *PORT_Type) GetPCR24_ISF() uint32 {
	return (volatile.LoadUint32(&o.PCR24.Reg) & 0x1000000) >> 24
}

// PORT.PCR25: Pin Control Register n
func (o *PORT_Type) SetPCR25_PS(value uint32) {
	volatile.StoreUint32(&o.PCR25.Reg, volatile.LoadUint32(&o.PCR25.Reg)&^(0x1)|value)
}
func (o *PORT_Type) GetPCR25_PS() uint32 {
	return volatile.LoadUint32(&o.PCR25.Reg) & 0x1
}
func (o *PORT_Type) SetPCR25_PE(value uint32) {
	volatile.StoreUint32(&o.PCR25.Reg, volatile.LoadUint32(&o.PCR25.Reg)&^(0x2)|value<<1)
}
func (o *PORT_Type) GetPCR25_PE() uint32 {
	return (volatile.LoadUint32(&o.PCR25.Reg) & 0x2) >> 1
}
func (o *PORT_Type) SetPCR25_SRE(value uint32) {
	volatile.StoreUint32(&o.PCR25.Reg, volatile.LoadUint32(&o.PCR25.Reg)&^(0x4)|value<<2)
}
func (o *PORT_Type) GetPCR25_SRE() uint32 {
	return (volatile.LoadUint32(&o.PCR25.Reg) & 0x4) >> 2
}
func (o *PORT_Type) SetPCR25_PFE(value uint32) {
	volatile.StoreUint32(&o.PCR25.Reg, volatile.LoadUint32(&o.PCR25.Reg)&^(0x10)|value<<4)
}
func (o *PORT_Type) GetPCR25_PFE() uint32 {
	return (volatile.LoadUint32(&o.PCR25.Reg) & 0x10) >> 4
}
func (o *PORT_Type) SetPCR25_ODE(value uint32) {
	volatile.StoreUint32(&o.PCR25.Reg, volatile.LoadUint32(&o.PCR25.Reg)&^(0x20)|value<<5)
}
func (o *PORT_Type) GetPCR25_ODE() uint32 {
	return (volatile.LoadUint32(&o.PCR25.Reg) & 0x20) >> 5
}
func (o *PORT_Type) SetPCR25_DSE(value uint32) {
	volatile.StoreUint32(&o.PCR25.Reg, volatile.LoadUint32(&o.PCR25.Reg)&^(0x40)|value<<6)
}
func (o *PORT_Type) GetPCR25_DSE() uint32 {
	return (volatile.LoadUint32(&o.PCR25.Reg) & 0x40) >> 6
}
func (o *PORT_Type) SetPCR25_MUX(value uint32) {
	volatile.StoreUint32(&o.PCR25.Reg, volatile.LoadUint32(&o.PCR25.Reg)&^(0x700)|value<<8)
}
func (o *PORT_Type) GetPCR25_MUX() uint32 {
	return (volatile.LoadUint32(&o.PCR25.Reg) & 0x700) >> 8
}
func (o *PORT_Type) SetPCR25_LK(value uint32) {
	volatile.StoreUint32(&o.PCR25.Reg, volatile.LoadUint32(&o.PCR25.Reg)&^(0x8000)|value<<15)
}
func (o *PORT_Type) GetPCR25_LK() uint32 {
	return (volatile.LoadUint32(&o.PCR25.Reg) & 0x8000) >> 15
}
func (o *PORT_Type) SetPCR25_IRQC(value uint32) {
	volatile.StoreUint32(&o.PCR25.Reg, volatile.LoadUint32(&o.PCR25.Reg)&^(0xf0000)|value<<16)
}
func (o *PORT_Type) GetPCR25_IRQC() uint32 {
	return (volatile.LoadUint32(&o.PCR25.Reg) & 0xf0000) >> 16
}
func (o *PORT_Type) SetPCR25_ISF(value uint32) {
	volatile.StoreUint32(&o.PCR25.Reg, volatile.LoadUint32(&o.PCR25.Reg)&^(0x1000000)|value<<24)
}
func (o *PORT_Type) GetPCR25_ISF() uint32 {
	return (volatile.LoadUint32(&o.PCR25.Reg) & 0x1000000) >> 24
}

// PORT.PCR26: Pin Control Register n
func (o *PORT_Type) SetPCR26_PS(value uint32) {
	volatile.StoreUint32(&o.PCR26.Reg, volatile.LoadUint32(&o.PCR26.Reg)&^(0x1)|value)
}
func (o *PORT_Type) GetPCR26_PS() uint32 {
	return volatile.LoadUint32(&o.PCR26.Reg) & 0x1
}
func (o *PORT_Type) SetPCR26_PE(value uint32) {
	volatile.StoreUint32(&o.PCR26.Reg, volatile.LoadUint32(&o.PCR26.Reg)&^(0x2)|value<<1)
}
func (o *PORT_Type) GetPCR26_PE() uint32 {
	return (volatile.LoadUint32(&o.PCR26.Reg) & 0x2) >> 1
}
func (o *PORT_Type) SetPCR26_SRE(value uint32) {
	volatile.StoreUint32(&o.PCR26.Reg, volatile.LoadUint32(&o.PCR26.Reg)&^(0x4)|value<<2)
}
func (o *PORT_Type) GetPCR26_SRE() uint32 {
	return (volatile.LoadUint32(&o.PCR26.Reg) & 0x4) >> 2
}
func (o *PORT_Type) SetPCR26_PFE(value uint32) {
	volatile.StoreUint32(&o.PCR26.Reg, volatile.LoadUint32(&o.PCR26.Reg)&^(0x10)|value<<4)
}
func (o *PORT_Type) GetPCR26_PFE() uint32 {
	return (volatile.LoadUint32(&o.PCR26.Reg) & 0x10) >> 4
}
func (o *PORT_Type) SetPCR26_ODE(value uint32) {
	volatile.StoreUint32(&o.PCR26.Reg, volatile.LoadUint32(&o.PCR26.Reg)&^(0x20)|value<<5)
}
func (o *PORT_Type) GetPCR26_ODE() uint32 {
	return (volatile.LoadUint32(&o.PCR26.Reg) & 0x20) >> 5
}
func (o *PORT_Type) SetPCR26_DSE(value uint32) {
	volatile.StoreUint32(&o.PCR26.Reg, volatile.LoadUint32(&o.PCR26.Reg)&^(0x40)|value<<6)
}
func (o *PORT_Type) GetPCR26_DSE() uint32 {
	return (volatile.LoadUint32(&o.PCR26.Reg) & 0x40) >> 6
}
func (o *PORT_Type) SetPCR26_MUX(value uint32) {
	volatile.StoreUint32(&o.PCR26.Reg, volatile.LoadUint32(&o.PCR26.Reg)&^(0x700)|value<<8)
}
func (o *PORT_Type) GetPCR26_MUX() uint32 {
	return (volatile.LoadUint32(&o.PCR26.Reg) & 0x700) >> 8
}
func (o *PORT_Type) SetPCR26_LK(value uint32) {
	volatile.StoreUint32(&o.PCR26.Reg, volatile.LoadUint32(&o.PCR26.Reg)&^(0x8000)|value<<15)
}
func (o *PORT_Type) GetPCR26_LK() uint32 {
	return (volatile.LoadUint32(&o.PCR26.Reg) & 0x8000) >> 15
}
func (o *PORT_Type) SetPCR26_IRQC(value uint32) {
	volatile.StoreUint32(&o.PCR26.Reg, volatile.LoadUint32(&o.PCR26.Reg)&^(0xf0000)|value<<16)
}
func (o *PORT_Type) GetPCR26_IRQC() uint32 {
	return (volatile.LoadUint32(&o.PCR26.Reg) & 0xf0000) >> 16
}
func (o *PORT_Type) SetPCR26_ISF(value uint32) {
	volatile.StoreUint32(&o.PCR26.Reg, volatile.LoadUint32(&o.PCR26.Reg)&^(0x1000000)|value<<24)
}
func (o *PORT_Type) GetPCR26_ISF() uint32 {
	return (volatile.LoadUint32(&o.PCR26.Reg) & 0x1000000) >> 24
}

// PORT.PCR27: Pin Control Register n
func (o *PORT_Type) SetPCR27_PS(value uint32) {
	volatile.StoreUint32(&o.PCR27.Reg, volatile.LoadUint32(&o.PCR27.Reg)&^(0x1)|value)
}
func (o *PORT_Type) GetPCR27_PS() uint32 {
	return volatile.LoadUint32(&o.PCR27.Reg) & 0x1
}
func (o *PORT_Type) SetPCR27_PE(value uint32) {
	volatile.StoreUint32(&o.PCR27.Reg, volatile.LoadUint32(&o.PCR27.Reg)&^(0x2)|value<<1)
}
func (o *PORT_Type) GetPCR27_PE() uint32 {
	return (volatile.LoadUint32(&o.PCR27.Reg) & 0x2) >> 1
}
func (o *PORT_Type) SetPCR27_SRE(value uint32) {
	volatile.StoreUint32(&o.PCR27.Reg, volatile.LoadUint32(&o.PCR27.Reg)&^(0x4)|value<<2)
}
func (o *PORT_Type) GetPCR27_SRE() uint32 {
	return (volatile.LoadUint32(&o.PCR27.Reg) & 0x4) >> 2
}
func (o *PORT_Type) SetPCR27_PFE(value uint32) {
	volatile.StoreUint32(&o.PCR27.Reg, volatile.LoadUint32(&o.PCR27.Reg)&^(0x10)|value<<4)
}
func (o *PORT_Type) GetPCR27_PFE() uint32 {
	return (volatile.LoadUint32(&o.PCR27.Reg) & 0x10) >> 4
}
func (o *PORT_Type) SetPCR27_ODE(value uint32) {
	volatile.StoreUint32(&o.PCR27.Reg, volatile.LoadUint32(&o.PCR27.Reg)&^(0x20)|value<<5)
}
func (o *PORT_Type) GetPCR27_ODE() uint32 {
	return (volatile.LoadUint32(&o.PCR27.Reg) & 0x20) >> 5
}
func (o *PORT_Type) SetPCR27_DSE(value uint32) {
	volatile.StoreUint32(&o.PCR27.Reg, volatile.LoadUint32(&o.PCR27.Reg)&^(0x40)|value<<6)
}
func (o *PORT_Type) GetPCR27_DSE() uint32 {
	return (volatile.LoadUint32(&o.PCR27.Reg) & 0x40) >> 6
}
func (o *PORT_Type) SetPCR27_MUX(value uint32) {
	volatile.StoreUint32(&o.PCR27.Reg, volatile.LoadUint32(&o.PCR27.Reg)&^(0x700)|value<<8)
}
func (o *PORT_Type) GetPCR27_MUX() uint32 {
	return (volatile.LoadUint32(&o.PCR27.Reg) & 0x700) >> 8
}
func (o *PORT_Type) SetPCR27_LK(value uint32) {
	volatile.StoreUint32(&o.PCR27.Reg, volatile.LoadUint32(&o.PCR27.Reg)&^(0x8000)|value<<15)
}
func (o *PORT_Type) GetPCR27_LK() uint32 {
	return (volatile.LoadUint32(&o.PCR27.Reg) & 0x8000) >> 15
}
func (o *PORT_Type) SetPCR27_IRQC(value uint32) {
	volatile.StoreUint32(&o.PCR27.Reg, volatile.LoadUint32(&o.PCR27.Reg)&^(0xf0000)|value<<16)
}
func (o *PORT_Type) GetPCR27_IRQC() uint32 {
	return (volatile.LoadUint32(&o.PCR27.Reg) & 0xf0000) >> 16
}
func (o *PORT_Type) SetPCR27_ISF(value uint32) {
	volatile.StoreUint32(&o.PCR27.Reg, volatile.LoadUint32(&o.PCR27.Reg)&^(0x1000000)|value<<24)
}
func (o *PORT_Type) GetPCR27_ISF() uint32 {
	return (volatile.LoadUint32(&o.PCR27.Reg) & 0x1000000) >> 24
}

// PORT.PCR28: Pin Control Register n
func (o *PORT_Type) SetPCR28_PS(value uint32) {
	volatile.StoreUint32(&o.PCR28.Reg, volatile.LoadUint32(&o.PCR28.Reg)&^(0x1)|value)
}
func (o *PORT_Type) GetPCR28_PS() uint32 {
	return volatile.LoadUint32(&o.PCR28.Reg) & 0x1
}
func (o *PORT_Type) SetPCR28_PE(value uint32) {
	volatile.StoreUint32(&o.PCR28.Reg, volatile.LoadUint32(&o.PCR28.Reg)&^(0x2)|value<<1)
}
func (o *PORT_Type) GetPCR28_PE() uint32 {
	return (volatile.LoadUint32(&o.PCR28.Reg) & 0x2) >> 1
}
func (o *PORT_Type) SetPCR28_SRE(value uint32) {
	volatile.StoreUint32(&o.PCR28.Reg, volatile.LoadUint32(&o.PCR28.Reg)&^(0x4)|value<<2)
}
func (o *PORT_Type) GetPCR28_SRE() uint32 {
	return (volatile.LoadUint32(&o.PCR28.Reg) & 0x4) >> 2
}
func (o *PORT_Type) SetPCR28_PFE(value uint32) {
	volatile.StoreUint32(&o.PCR28.Reg, volatile.LoadUint32(&o.PCR28.Reg)&^(0x10)|value<<4)
}
func (o *PORT_Type) GetPCR28_PFE() uint32 {
	return (volatile.LoadUint32(&o.PCR28.Reg) & 0x10) >> 4
}
func (o *PORT_Type) SetPCR28_ODE(value uint32) {
	volatile.StoreUint32(&o.PCR28.Reg, volatile.LoadUint32(&o.PCR28.Reg)&^(0x20)|value<<5)
}
func (o *PORT_Type) GetPCR28_ODE() uint32 {
	return (volatile.LoadUint32(&o.PCR28.Reg) & 0x20) >> 5
}
func (o *PORT_Type) SetPCR28_DSE(value uint32) {
	volatile.StoreUint32(&o.PCR28.Reg, volatile.LoadUint32(&o.PCR28.Reg)&^(0x40)|value<<6)
}
func (o *PORT_Type) GetPCR28_DSE() uint32 {
	return (volatile.LoadUint32(&o.PCR28.Reg) & 0x40) >> 6
}
func (o *PORT_Type) SetPCR28_MUX(value uint32) {
	volatile.StoreUint32(&o.PCR28.Reg, volatile.LoadUint32(&o.PCR28.Reg)&^(0x700)|value<<8)
}
func (o *PORT_Type) GetPCR28_MUX() uint32 {
	return (volatile.LoadUint32(&o.PCR28.Reg) & 0x700) >> 8
}
func (o *PORT_Type) SetPCR28_LK(value uint32) {
	volatile.StoreUint32(&o.PCR28.Reg, volatile.LoadUint32(&o.PCR28.Reg)&^(0x8000)|value<<15)
}
func (o *PORT_Type) GetPCR28_LK() uint32 {
	return (volatile.LoadUint32(&o.PCR28.Reg) & 0x8000) >> 15
}
func (o *PORT_Type) SetPCR28_IRQC(value uint32) {
	volatile.StoreUint32(&o.PCR28.Reg, volatile.LoadUint32(&o.PCR28.Reg)&^(0xf0000)|value<<16)
}
func (o *PORT_Type) GetPCR28_IRQC() uint32 {
	return (volatile.LoadUint32(&o.PCR28.Reg) & 0xf0000) >> 16
}
func (o *PORT_Type) SetPCR28_ISF(value uint32) {
	volatile.StoreUint32(&o.PCR28.Reg, volatile.LoadUint32(&o.PCR28.Reg)&^(0x1000000)|value<<24)
}
func (o *PORT_Type) GetPCR28_ISF() uint32 {
	return (volatile.LoadUint32(&o.PCR28.Reg) & 0x1000000) >> 24
}

// PORT.PCR29: Pin Control Register n
func (o *PORT_Type) SetPCR29_PS(value uint32) {
	volatile.StoreUint32(&o.PCR29.Reg, volatile.LoadUint32(&o.PCR29.Reg)&^(0x1)|value)
}
func (o *PORT_Type) GetPCR29_PS() uint32 {
	return volatile.LoadUint32(&o.PCR29.Reg) & 0x1
}
func (o *PORT_Type) SetPCR29_PE(value uint32) {
	volatile.StoreUint32(&o.PCR29.Reg, volatile.LoadUint32(&o.PCR29.Reg)&^(0x2)|value<<1)
}
func (o *PORT_Type) GetPCR29_PE() uint32 {
	return (volatile.LoadUint32(&o.PCR29.Reg) & 0x2) >> 1
}
func (o *PORT_Type) SetPCR29_SRE(value uint32) {
	volatile.StoreUint32(&o.PCR29.Reg, volatile.LoadUint32(&o.PCR29.Reg)&^(0x4)|value<<2)
}
func (o *PORT_Type) GetPCR29_SRE() uint32 {
	return (volatile.LoadUint32(&o.PCR29.Reg) & 0x4) >> 2
}
func (o *PORT_Type) SetPCR29_PFE(value uint32) {
	volatile.StoreUint32(&o.PCR29.Reg, volatile.LoadUint32(&o.PCR29.Reg)&^(0x10)|value<<4)
}
func (o *PORT_Type) GetPCR29_PFE() uint32 {
	return (volatile.LoadUint32(&o.PCR29.Reg) & 0x10) >> 4
}
func (o *PORT_Type) SetPCR29_ODE(value uint32) {
	volatile.StoreUint32(&o.PCR29.Reg, volatile.LoadUint32(&o.PCR29.Reg)&^(0x20)|value<<5)
}
func (o *PORT_Type) GetPCR29_ODE() uint32 {
	return (volatile.LoadUint32(&o.PCR29.Reg) & 0x20) >> 5
}
func (o *PORT_Type) SetPCR29_DSE(value uint32) {
	volatile.StoreUint32(&o.PCR29.Reg, volatile.LoadUint32(&o.PCR29.Reg)&^(0x40)|value<<6)
}
func (o *PORT_Type) GetPCR29_DSE() uint32 {
	return (volatile.LoadUint32(&o.PCR29.Reg) & 0x40) >> 6
}
func (o *PORT_Type) SetPCR29_MUX(value uint32) {
	volatile.StoreUint32(&o.PCR29.Reg, volatile.LoadUint32(&o.PCR29.Reg)&^(0x700)|value<<8)
}
func (o *PORT_Type) GetPCR29_MUX() uint32 {
	return (volatile.LoadUint32(&o.PCR29.Reg) & 0x700) >> 8
}
func (o *PORT_Type) SetPCR29_LK(value uint32) {
	volatile.StoreUint32(&o.PCR29.Reg, volatile.LoadUint32(&o.PCR29.Reg)&^(0x8000)|value<<15)
}
func (o *PORT_Type) GetPCR29_LK() uint32 {
	return (volatile.LoadUint32(&o.PCR29.Reg) & 0x8000) >> 15
}
func (o *PORT_Type) SetPCR29_IRQC(value uint32) {
	volatile.StoreUint32(&o.PCR29.Reg, volatile.LoadUint32(&o.PCR29.Reg)&^(0xf0000)|value<<16)
}
func (o *PORT_Type) GetPCR29_IRQC() uint32 {
	return (volatile.LoadUint32(&o.PCR29.Reg) & 0xf0000) >> 16
}
func (o *PORT_Type) SetPCR29_ISF(value uint32) {
	volatile.StoreUint32(&o.PCR29.Reg, volatile.LoadUint32(&o.PCR29.Reg)&^(0x1000000)|value<<24)
}
func (o *PORT_Type) GetPCR29_ISF() uint32 {
	return (volatile.LoadUint32(&o.PCR29.Reg) & 0x1000000) >> 24
}

// PORT.PCR30: Pin Control Register n
func (o *PORT_Type) SetPCR30_PS(value uint32) {
	volatile.StoreUint32(&o.PCR30.Reg, volatile.LoadUint32(&o.PCR30.Reg)&^(0x1)|value)
}
func (o *PORT_Type) GetPCR30_PS() uint32 {
	return volatile.LoadUint32(&o.PCR30.Reg) & 0x1
}
func (o *PORT_Type) SetPCR30_PE(value uint32) {
	volatile.StoreUint32(&o.PCR30.Reg, volatile.LoadUint32(&o.PCR30.Reg)&^(0x2)|value<<1)
}
func (o *PORT_Type) GetPCR30_PE() uint32 {
	return (volatile.LoadUint32(&o.PCR30.Reg) & 0x2) >> 1
}
func (o *PORT_Type) SetPCR30_SRE(value uint32) {
	volatile.StoreUint32(&o.PCR30.Reg, volatile.LoadUint32(&o.PCR30.Reg)&^(0x4)|value<<2)
}
func (o *PORT_Type) GetPCR30_SRE() uint32 {
	return (volatile.LoadUint32(&o.PCR30.Reg) & 0x4) >> 2
}
func (o *PORT_Type) SetPCR30_PFE(value uint32) {
	volatile.StoreUint32(&o.PCR30.Reg, volatile.LoadUint32(&o.PCR30.Reg)&^(0x10)|value<<4)
}
func (o *PORT_Type) GetPCR30_PFE() uint32 {
	return (volatile.LoadUint32(&o.PCR30.Reg) & 0x10) >> 4
}
func (o *PORT_Type) SetPCR30_ODE(value uint32) {
	volatile.StoreUint32(&o.PCR30.Reg, volatile.LoadUint32(&o.PCR30.Reg)&^(0x20)|value<<5)
}
func (o *PORT_Type) GetPCR30_ODE() uint32 {
	return (volatile.LoadUint32(&o.PCR30.Reg) & 0x20) >> 5
}
func (o *PORT_Type) SetPCR30_DSE(value uint32) {
	volatile.StoreUint32(&o.PCR30.Reg, volatile.LoadUint32(&o.PCR30.Reg)&^(0x40)|value<<6)
}
func (o *PORT_Type) GetPCR30_DSE() uint32 {
	return (volatile.LoadUint32(&o.PCR30.Reg) & 0x40) >> 6
}
func (o *PORT_Type) SetPCR30_MUX(value uint32) {
	volatile.StoreUint32(&o.PCR30.Reg, volatile.LoadUint32(&o.PCR30.Reg)&^(0x700)|value<<8)
}
func (o *PORT_Type) GetPCR30_MUX() uint32 {
	return (volatile.LoadUint32(&o.PCR30.Reg) & 0x700) >> 8
}
func (o *PORT_Type) SetPCR30_LK(value uint32) {
	volatile.StoreUint32(&o.PCR30.Reg, volatile.LoadUint32(&o.PCR30.Reg)&^(0x8000)|value<<15)
}
func (o *PORT_Type) GetPCR30_LK() uint32 {
	return (volatile.LoadUint32(&o.PCR30.Reg) & 0x8000) >> 15
}
func (o *PORT_Type) SetPCR30_IRQC(value uint32) {
	volatile.StoreUint32(&o.PCR30.Reg, volatile.LoadUint32(&o.PCR30.Reg)&^(0xf0000)|value<<16)
}
func (o *PORT_Type) GetPCR30_IRQC() uint32 {
	return (volatile.LoadUint32(&o.PCR30.Reg) & 0xf0000) >> 16
}
func (o *PORT_Type) SetPCR30_ISF(value uint32) {
	volatile.StoreUint32(&o.PCR30.Reg, volatile.LoadUint32(&o.PCR30.Reg)&^(0x1000000)|value<<24)
}
func (o *PORT_Type) GetPCR30_ISF() uint32 {
	return (volatile.LoadUint32(&o.PCR30.Reg) & 0x1000000) >> 24
}

// PORT.PCR31: Pin Control Register n
func (o *PORT_Type) SetPCR31_PS(value uint32) {
	volatile.StoreUint32(&o.PCR31.Reg, volatile.LoadUint32(&o.PCR31.Reg)&^(0x1)|value)
}
func (o *PORT_Type) GetPCR31_PS() uint32 {
	return volatile.LoadUint32(&o.PCR31.Reg) & 0x1
}
func (o *PORT_Type) SetPCR31_PE(value uint32) {
	volatile.StoreUint32(&o.PCR31.Reg, volatile.LoadUint32(&o.PCR31.Reg)&^(0x2)|value<<1)
}
func (o *PORT_Type) GetPCR31_PE() uint32 {
	return (volatile.LoadUint32(&o.PCR31.Reg) & 0x2) >> 1
}
func (o *PORT_Type) SetPCR31_SRE(value uint32) {
	volatile.StoreUint32(&o.PCR31.Reg, volatile.LoadUint32(&o.PCR31.Reg)&^(0x4)|value<<2)
}
func (o *PORT_Type) GetPCR31_SRE() uint32 {
	return (volatile.LoadUint32(&o.PCR31.Reg) & 0x4) >> 2
}
func (o *PORT_Type) SetPCR31_PFE(value uint32) {
	volatile.StoreUint32(&o.PCR31.Reg, volatile.LoadUint32(&o.PCR31.Reg)&^(0x10)|value<<4)
}
func (o *PORT_Type) GetPCR31_PFE() uint32 {
	return (volatile.LoadUint32(&o.PCR31.Reg) & 0x10) >> 4
}
func (o *PORT_Type) SetPCR31_ODE(value uint32) {
	volatile.StoreUint32(&o.PCR31.Reg, volatile.LoadUint32(&o.PCR31.Reg)&^(0x20)|value<<5)
}
func (o *PORT_Type) GetPCR31_ODE() uint32 {
	return (volatile.LoadUint32(&o.PCR31.Reg) & 0x20) >> 5
}
func (o *PORT_Type) SetPCR31_DSE(value uint32) {
	volatile.StoreUint32(&o.PCR31.Reg, volatile.LoadUint32(&o.PCR31.Reg)&^(0x40)|value<<6)
}
func (o *PORT_Type) GetPCR31_DSE() uint32 {
	return (volatile.LoadUint32(&o.PCR31.Reg) & 0x40) >> 6
}
func (o *PORT_Type) SetPCR31_MUX(value uint32) {
	volatile.StoreUint32(&o.PCR31.Reg, volatile.LoadUint32(&o.PCR31.Reg)&^(0x700)|value<<8)
}
func (o *PORT_Type) GetPCR31_MUX() uint32 {
	return (volatile.LoadUint32(&o.PCR31.Reg) & 0x700) >> 8
}
func (o *PORT_Type) SetPCR31_LK(value uint32) {
	volatile.StoreUint32(&o.PCR31.Reg, volatile.LoadUint32(&o.PCR31.Reg)&^(0x8000)|value<<15)
}
func (o *PORT_Type) GetPCR31_LK() uint32 {
	return (volatile.LoadUint32(&o.PCR31.Reg) & 0x8000) >> 15
}
func (o *PORT_Type) SetPCR31_IRQC(value uint32) {
	volatile.StoreUint32(&o.PCR31.Reg, volatile.LoadUint32(&o.PCR31.Reg)&^(0xf0000)|value<<16)
}
func (o *PORT_Type) GetPCR31_IRQC() uint32 {
	return (volatile.LoadUint32(&o.PCR31.Reg) & 0xf0000) >> 16
}
func (o *PORT_Type) SetPCR31_ISF(value uint32) {
	volatile.StoreUint32(&o.PCR31.Reg, volatile.LoadUint32(&o.PCR31.Reg)&^(0x1000000)|value<<24)
}
func (o *PORT_Type) GetPCR31_ISF() uint32 {
	return (volatile.LoadUint32(&o.PCR31.Reg) & 0x1000000) >> 24
}

// PORT.GPCLR: Global Pin Control Low Register
func (o *PORT_Type) SetGPCLR_GPWD(value uint32) {
	volatile.StoreUint32(&o.GPCLR.Reg, volatile.LoadUint32(&o.GPCLR.Reg)&^(0xffff)|value)
}
func (o *PORT_Type) GetGPCLR_GPWD() uint32 {
	return volatile.LoadUint32(&o.GPCLR.Reg) & 0xffff
}
func (o *PORT_Type) SetGPCLR_GPWE0(value uint32) {
	volatile.StoreUint32(&o.GPCLR.Reg, volatile.LoadUint32(&o.GPCLR.Reg)&^(0x10000)|value<<16)
}
func (o *PORT_Type) GetGPCLR_GPWE0() uint32 {
	return (volatile.LoadUint32(&o.GPCLR.Reg) & 0x10000) >> 16
}
func (o *PORT_Type) SetGPCLR_GPWE1(value uint32) {
	volatile.StoreUint32(&o.GPCLR.Reg, volatile.LoadUint32(&o.GPCLR.Reg)&^(0x20000)|value<<17)
}
func (o *PORT_Type) GetGPCLR_GPWE1() uint32 {
	return (volatile.LoadUint32(&o.GPCLR.Reg) & 0x20000) >> 17
}
func (o *PORT_Type) SetGPCLR_GPWE2(value uint32) {
	volatile.StoreUint32(&o.GPCLR.Reg, volatile.LoadUint32(&o.GPCLR.Reg)&^(0x40000)|value<<18)
}
func (o *PORT_Type) GetGPCLR_GPWE2() uint32 {
	return (volatile.LoadUint32(&o.GPCLR.Reg) & 0x40000) >> 18
}
func (o *PORT_Type) SetGPCLR_GPWE3(value uint32) {
	volatile.StoreUint32(&o.GPCLR.Reg, volatile.LoadUint32(&o.GPCLR.Reg)&^(0x80000)|value<<19)
}
func (o *PORT_Type) GetGPCLR_GPWE3() uint32 {
	return (volatile.LoadUint32(&o.GPCLR.Reg) & 0x80000) >> 19
}
func (o *PORT_Type) SetGPCLR_GPWE4(value uint32) {
	volatile.StoreUint32(&o.GPCLR.Reg, volatile.LoadUint32(&o.GPCLR.Reg)&^(0x100000)|value<<20)
}
func (o *PORT_Type) GetGPCLR_GPWE4() uint32 {
	return (volatile.LoadUint32(&o.GPCLR.Reg) & 0x100000) >> 20
}
func (o *PORT_Type) SetGPCLR_GPWE5(value uint32) {
	volatile.StoreUint32(&o.GPCLR.Reg, volatile.LoadUint32(&o.GPCLR.Reg)&^(0x200000)|value<<21)
}
func (o *PORT_Type) GetGPCLR_GPWE5() uint32 {
	return (volatile.LoadUint32(&o.GPCLR.Reg) & 0x200000) >> 21
}
func (o *PORT_Type) SetGPCLR_GPWE6(value uint32) {
	volatile.StoreUint32(&o.GPCLR.Reg, volatile.LoadUint32(&o.GPCLR.Reg)&^(0x400000)|value<<22)
}
func (o *PORT_Type) GetGPCLR_GPWE6() uint32 {
	return (volatile.LoadUint32(&o.GPCLR.Reg) & 0x400000) >> 22
}
func (o *PORT_Type) SetGPCLR_GPWE7(value uint32) {
	volatile.StoreUint32(&o.GPCLR.Reg, volatile.LoadUint32(&o.GPCLR.Reg)&^(0x800000)|value<<23)
}
func (o *PORT_Type) GetGPCLR_GPWE7() uint32 {
	return (volatile.LoadUint32(&o.GPCLR.Reg) & 0x800000) >> 23
}
func (o *PORT_Type) SetGPCLR_GPWE8(value uint32) {
	volatile.StoreUint32(&o.GPCLR.Reg, volatile.LoadUint32(&o.GPCLR.Reg)&^(0x1000000)|value<<24)
}
func (o *PORT_Type) GetGPCLR_GPWE8() uint32 {
	return (volatile.LoadUint32(&o.GPCLR.Reg) & 0x1000000) >> 24
}
func (o *PORT_Type) SetGPCLR_GPWE9(value uint32) {
	volatile.StoreUint32(&o.GPCLR.Reg, volatile.LoadUint32(&o.GPCLR.Reg)&^(0x2000000)|value<<25)
}
func (o *PORT_Type) GetGPCLR_GPWE9() uint32 {
	return (volatile.LoadUint32(&o.GPCLR.Reg) & 0x2000000) >> 25
}
func (o *PORT_Type) SetGPCLR_GPWE10(value uint32) {
	volatile.StoreUint32(&o.GPCLR.Reg, volatile.LoadUint32(&o.GPCLR.Reg)&^(0x4000000)|value<<26)
}
func (o *PORT_Type) GetGPCLR_GPWE10() uint32 {
	return (volatile.LoadUint32(&o.GPCLR.Reg) & 0x4000000) >> 26
}
func (o *PORT_Type) SetGPCLR_GPWE11(value uint32) {
	volatile.StoreUint32(&o.GPCLR.Reg, volatile.LoadUint32(&o.GPCLR.Reg)&^(0x8000000)|value<<27)
}
func (o *PORT_Type) GetGPCLR_GPWE11() uint32 {
	return (volatile.LoadUint32(&o.GPCLR.Reg) & 0x8000000) >> 27
}
func (o *PORT_Type) SetGPCLR_GPWE12(value uint32) {
	volatile.StoreUint32(&o.GPCLR.Reg, volatile.LoadUint32(&o.GPCLR.Reg)&^(0x10000000)|value<<28)
}
func (o *PORT_Type) GetGPCLR_GPWE12() uint32 {
	return (volatile.LoadUint32(&o.GPCLR.Reg) & 0x10000000) >> 28
}
func (o *PORT_Type) SetGPCLR_GPWE13(value uint32) {
	volatile.StoreUint32(&o.GPCLR.Reg, volatile.LoadUint32(&o.GPCLR.Reg)&^(0x20000000)|value<<29)
}
func (o *PORT_Type) GetGPCLR_GPWE13() uint32 {
	return (volatile.LoadUint32(&o.GPCLR.Reg) & 0x20000000) >> 29
}
func (o *PORT_Type) SetGPCLR_GPWE14(value uint32) {
	volatile.StoreUint32(&o.GPCLR.Reg, volatile.LoadUint32(&o.GPCLR.Reg)&^(0x40000000)|value<<30)
}
func (o *PORT_Type) GetGPCLR_GPWE14() uint32 {
	return (volatile.LoadUint32(&o.GPCLR.Reg) & 0x40000000) >> 30
}
func (o *PORT_Type) SetGPCLR_GPWE15(value uint32) {
	volatile.StoreUint32(&o.GPCLR.Reg, volatile.LoadUint32(&o.GPCLR.Reg)&^(0x80000000)|value<<31)
}
func (o *PORT_Type) GetGPCLR_GPWE15() uint32 {
	return (volatile.LoadUint32(&o.GPCLR.Reg) & 0x80000000) >> 31
}

// PORT.GPCHR: Global Pin Control High Register
func (o *PORT_Type) SetGPCHR_GPWD(value uint32) {
	volatile.StoreUint32(&o.GPCHR.Reg, volatile.LoadUint32(&o.GPCHR.Reg)&^(0xffff)|value)
}
func (o *PORT_Type) GetGPCHR_GPWD() uint32 {
	return volatile.LoadUint32(&o.GPCHR.Reg) & 0xffff
}
func (o *PORT_Type) SetGPCHR_GPWE0(value uint32) {
	volatile.StoreUint32(&o.GPCHR.Reg, volatile.LoadUint32(&o.GPCHR.Reg)&^(0x10000)|value<<16)
}
func (o *PORT_Type) GetGPCHR_GPWE0() uint32 {
	return (volatile.LoadUint32(&o.GPCHR.Reg) & 0x10000) >> 16
}
func (o *PORT_Type) SetGPCHR_GPWE1(value uint32) {
	volatile.StoreUint32(&o.GPCHR.Reg, volatile.LoadUint32(&o.GPCHR.Reg)&^(0x20000)|value<<17)
}
func (o *PORT_Type) GetGPCHR_GPWE1() uint32 {
	return (volatile.LoadUint32(&o.GPCHR.Reg) & 0x20000) >> 17
}
func (o *PORT_Type) SetGPCHR_GPWE2(value uint32) {
	volatile.StoreUint32(&o.GPCHR.Reg, volatile.LoadUint32(&o.GPCHR.Reg)&^(0x40000)|value<<18)
}
func (o *PORT_Type) GetGPCHR_GPWE2() uint32 {
	return (volatile.LoadUint32(&o.GPCHR.Reg) & 0x40000) >> 18
}
func (o *PORT_Type) SetGPCHR_GPWE3(value uint32) {
	volatile.StoreUint32(&o.GPCHR.Reg, volatile.LoadUint32(&o.GPCHR.Reg)&^(0x80000)|value<<19)
}
func (o *PORT_Type) GetGPCHR_GPWE3() uint32 {
	return (volatile.LoadUint32(&o.GPCHR.Reg) & 0x80000) >> 19
}
func (o *PORT_Type) SetGPCHR_GPWE4(value uint32) {
	volatile.StoreUint32(&o.GPCHR.Reg, volatile.LoadUint32(&o.GPCHR.Reg)&^(0x100000)|value<<20)
}
func (o *PORT_Type) GetGPCHR_GPWE4() uint32 {
	return (volatile.LoadUint32(&o.GPCHR.Reg) & 0x100000) >> 20
}
func (o *PORT_Type) SetGPCHR_GPWE5(value uint32) {
	volatile.StoreUint32(&o.GPCHR.Reg, volatile.LoadUint32(&o.GPCHR.Reg)&^(0x200000)|value<<21)
}
func (o *PORT_Type) GetGPCHR_GPWE5() uint32 {
	return (volatile.LoadUint32(&o.GPCHR.Reg) & 0x200000) >> 21
}
func (o *PORT_Type) SetGPCHR_GPWE6(value uint32) {
	volatile.StoreUint32(&o.GPCHR.Reg, volatile.LoadUint32(&o.GPCHR.Reg)&^(0x400000)|value<<22)
}
func (o *PORT_Type) GetGPCHR_GPWE6() uint32 {
	return (volatile.LoadUint32(&o.GPCHR.Reg) & 0x400000) >> 22
}
func (o *PORT_Type) SetGPCHR_GPWE7(value uint32) {
	volatile.StoreUint32(&o.GPCHR.Reg, volatile.LoadUint32(&o.GPCHR.Reg)&^(0x800000)|value<<23)
}
func (o *PORT_Type) GetGPCHR_GPWE7() uint32 {
	return (volatile.LoadUint32(&o.GPCHR.Reg) & 0x800000) >> 23
}
func (o *PORT_Type) SetGPCHR_GPWE8(value uint32) {
	volatile.StoreUint32(&o.GPCHR.Reg, volatile.LoadUint32(&o.GPCHR.Reg)&^(0x1000000)|value<<24)
}
func (o *PORT_Type) GetGPCHR_GPWE8() uint32 {
	return (volatile.LoadUint32(&o.GPCHR.Reg) & 0x1000000) >> 24
}
func (o *PORT_Type) SetGPCHR_GPWE9(value uint32) {
	volatile.StoreUint32(&o.GPCHR.Reg, volatile.LoadUint32(&o.GPCHR.Reg)&^(0x2000000)|value<<25)
}
func (o *PORT_Type) GetGPCHR_GPWE9() uint32 {
	return (volatile.LoadUint32(&o.GPCHR.Reg) & 0x2000000) >> 25
}
func (o *PORT_Type) SetGPCHR_GPWE10(value uint32) {
	volatile.StoreUint32(&o.GPCHR.Reg, volatile.LoadUint32(&o.GPCHR.Reg)&^(0x4000000)|value<<26)
}
func (o *PORT_Type) GetGPCHR_GPWE10() uint32 {
	return (volatile.LoadUint32(&o.GPCHR.Reg) & 0x4000000) >> 26
}
func (o *PORT_Type) SetGPCHR_GPWE11(value uint32) {
	volatile.StoreUint32(&o.GPCHR.Reg, volatile.LoadUint32(&o.GPCHR.Reg)&^(0x8000000)|value<<27)
}
func (o *PORT_Type) GetGPCHR_GPWE11() uint32 {
	return (volatile.LoadUint32(&o.GPCHR.Reg) & 0x8000000) >> 27
}
func (o *PORT_Type) SetGPCHR_GPWE12(value uint32) {
	volatile.StoreUint32(&o.GPCHR.Reg, volatile.LoadUint32(&o.GPCHR.Reg)&^(0x10000000)|value<<28)
}
func (o *PORT_Type) GetGPCHR_GPWE12() uint32 {
	return (volatile.LoadUint32(&o.GPCHR.Reg) & 0x10000000) >> 28
}
func (o *PORT_Type) SetGPCHR_GPWE13(value uint32) {
	volatile.StoreUint32(&o.GPCHR.Reg, volatile.LoadUint32(&o.GPCHR.Reg)&^(0x20000000)|value<<29)
}
func (o *PORT_Type) GetGPCHR_GPWE13() uint32 {
	return (volatile.LoadUint32(&o.GPCHR.Reg) & 0x20000000) >> 29
}
func (o *PORT_Type) SetGPCHR_GPWE14(value uint32) {
	volatile.StoreUint32(&o.GPCHR.Reg, volatile.LoadUint32(&o.GPCHR.Reg)&^(0x40000000)|value<<30)
}
func (o *PORT_Type) GetGPCHR_GPWE14() uint32 {
	return (volatile.LoadUint32(&o.GPCHR.Reg) & 0x40000000) >> 30
}
func (o *PORT_Type) SetGPCHR_GPWE15(value uint32) {
	volatile.StoreUint32(&o.GPCHR.Reg, volatile.LoadUint32(&o.GPCHR.Reg)&^(0x80000000)|value<<31)
}
func (o *PORT_Type) GetGPCHR_GPWE15() uint32 {
	return (volatile.LoadUint32(&o.GPCHR.Reg) & 0x80000000) >> 31
}

// PORT.ISFR: Interrupt Status Flag Register
func (o *PORT_Type) SetISFR_ISF0(value uint32) {
	volatile.StoreUint32(&o.ISFR.Reg, volatile.LoadUint32(&o.ISFR.Reg)&^(0x1)|value)
}
func (o *PORT_Type) GetISFR_ISF0() uint32 {
	return volatile.LoadUint32(&o.ISFR.Reg) & 0x1
}
func (o *PORT_Type) SetISFR_ISF1(value uint32) {
	volatile.StoreUint32(&o.ISFR.Reg, volatile.LoadUint32(&o.ISFR.Reg)&^(0x2)|value<<1)
}
func (o *PORT_Type) GetISFR_ISF1() uint32 {
	return (volatile.LoadUint32(&o.ISFR.Reg) & 0x2) >> 1
}
func (o *PORT_Type) SetISFR_ISF2(value uint32) {
	volatile.StoreUint32(&o.ISFR.Reg, volatile.LoadUint32(&o.ISFR.Reg)&^(0x4)|value<<2)
}
func (o *PORT_Type) GetISFR_ISF2() uint32 {
	return (volatile.LoadUint32(&o.ISFR.Reg) & 0x4) >> 2
}
func (o *PORT_Type) SetISFR_ISF3(value uint32) {
	volatile.StoreUint32(&o.ISFR.Reg, volatile.LoadUint32(&o.ISFR.Reg)&^(0x8)|value<<3)
}
func (o *PORT_Type) GetISFR_ISF3() uint32 {
	return (volatile.LoadUint32(&o.ISFR.Reg) & 0x8) >> 3
}
func (o *PORT_Type) SetISFR_ISF4(value uint32) {
	volatile.StoreUint32(&o.ISFR.Reg, volatile.LoadUint32(&o.ISFR.Reg)&^(0x10)|value<<4)
}
func (o *PORT_Type) GetISFR_ISF4() uint32 {
	return (volatile.LoadUint32(&o.ISFR.Reg) & 0x10) >> 4
}
func (o *PORT_Type) SetISFR_ISF5(value uint32) {
	volatile.StoreUint32(&o.ISFR.Reg, volatile.LoadUint32(&o.ISFR.Reg)&^(0x20)|value<<5)
}
func (o *PORT_Type) GetISFR_ISF5() uint32 {
	return (volatile.LoadUint32(&o.ISFR.Reg) & 0x20) >> 5
}
func (o *PORT_Type) SetISFR_ISF6(value uint32) {
	volatile.StoreUint32(&o.ISFR.Reg, volatile.LoadUint32(&o.ISFR.Reg)&^(0x40)|value<<6)
}
func (o *PORT_Type) GetISFR_ISF6() uint32 {
	return (volatile.LoadUint32(&o.ISFR.Reg) & 0x40) >> 6
}
func (o *PORT_Type) SetISFR_ISF7(value uint32) {
	volatile.StoreUint32(&o.ISFR.Reg, volatile.LoadUint32(&o.ISFR.Reg)&^(0x80)|value<<7)
}
func (o *PORT_Type) GetISFR_ISF7() uint32 {
	return (volatile.LoadUint32(&o.ISFR.Reg) & 0x80) >> 7
}
func (o *PORT_Type) SetISFR_ISF8(value uint32) {
	volatile.StoreUint32(&o.ISFR.Reg, volatile.LoadUint32(&o.ISFR.Reg)&^(0x100)|value<<8)
}
func (o *PORT_Type) GetISFR_ISF8() uint32 {
	return (volatile.LoadUint32(&o.ISFR.Reg) & 0x100) >> 8
}
func (o *PORT_Type) SetISFR_ISF9(value uint32) {
	volatile.StoreUint32(&o.ISFR.Reg, volatile.LoadUint32(&o.ISFR.Reg)&^(0x200)|value<<9)
}
func (o *PORT_Type) GetISFR_ISF9() uint32 {
	return (volatile.LoadUint32(&o.ISFR.Reg) & 0x200) >> 9
}
func (o *PORT_Type) SetISFR_ISF10(value uint32) {
	volatile.StoreUint32(&o.ISFR.Reg, volatile.LoadUint32(&o.ISFR.Reg)&^(0x400)|value<<10)
}
func (o *PORT_Type) GetISFR_ISF10() uint32 {
	return (volatile.LoadUint32(&o.ISFR.Reg) & 0x400) >> 10
}
func (o *PORT_Type) SetISFR_ISF11(value uint32) {
	volatile.StoreUint32(&o.ISFR.Reg, volatile.LoadUint32(&o.ISFR.Reg)&^(0x800)|value<<11)
}
func (o *PORT_Type) GetISFR_ISF11() uint32 {
	return (volatile.LoadUint32(&o.ISFR.Reg) & 0x800) >> 11
}
func (o *PORT_Type) SetISFR_ISF12(value uint32) {
	volatile.StoreUint32(&o.ISFR.Reg, volatile.LoadUint32(&o.ISFR.Reg)&^(0x1000)|value<<12)
}
func (o *PORT_Type) GetISFR_ISF12() uint32 {
	return (volatile.LoadUint32(&o.ISFR.Reg) & 0x1000) >> 12
}
func (o *PORT_Type) SetISFR_ISF13(value uint32) {
	volatile.StoreUint32(&o.ISFR.Reg, volatile.LoadUint32(&o.ISFR.Reg)&^(0x2000)|value<<13)
}
func (o *PORT_Type) GetISFR_ISF13() uint32 {
	return (volatile.LoadUint32(&o.ISFR.Reg) & 0x2000) >> 13
}
func (o *PORT_Type) SetISFR_ISF14(value uint32) {
	volatile.StoreUint32(&o.ISFR.Reg, volatile.LoadUint32(&o.ISFR.Reg)&^(0x4000)|value<<14)
}
func (o *PORT_Type) GetISFR_ISF14() uint32 {
	return (volatile.LoadUint32(&o.ISFR.Reg) & 0x4000) >> 14
}
func (o *PORT_Type) SetISFR_ISF15(value uint32) {
	volatile.StoreUint32(&o.ISFR.Reg, volatile.LoadUint32(&o.ISFR.Reg)&^(0x8000)|value<<15)
}
func (o *PORT_Type) GetISFR_ISF15() uint32 {
	return (volatile.LoadUint32(&o.ISFR.Reg) & 0x8000) >> 15
}
func (o *PORT_Type) SetISFR_ISF16(value uint32) {
	volatile.StoreUint32(&o.ISFR.Reg, volatile.LoadUint32(&o.ISFR.Reg)&^(0x10000)|value<<16)
}
func (o *PORT_Type) GetISFR_ISF16() uint32 {
	return (volatile.LoadUint32(&o.ISFR.Reg) & 0x10000) >> 16
}
func (o *PORT_Type) SetISFR_ISF17(value uint32) {
	volatile.StoreUint32(&o.ISFR.Reg, volatile.LoadUint32(&o.ISFR.Reg)&^(0x20000)|value<<17)
}
func (o *PORT_Type) GetISFR_ISF17() uint32 {
	return (volatile.LoadUint32(&o.ISFR.Reg) & 0x20000) >> 17
}
func (o *PORT_Type) SetISFR_ISF18(value uint32) {
	volatile.StoreUint32(&o.ISFR.Reg, volatile.LoadUint32(&o.ISFR.Reg)&^(0x40000)|value<<18)
}
func (o *PORT_Type) GetISFR_ISF18() uint32 {
	return (volatile.LoadUint32(&o.ISFR.Reg) & 0x40000) >> 18
}
func (o *PORT_Type) SetISFR_ISF19(value uint32) {
	volatile.StoreUint32(&o.ISFR.Reg, volatile.LoadUint32(&o.ISFR.Reg)&^(0x80000)|value<<19)
}
func (o *PORT_Type) GetISFR_ISF19() uint32 {
	return (volatile.LoadUint32(&o.ISFR.Reg) & 0x80000) >> 19
}
func (o *PORT_Type) SetISFR_ISF20(value uint32) {
	volatile.StoreUint32(&o.ISFR.Reg, volatile.LoadUint32(&o.ISFR.Reg)&^(0x100000)|value<<20)
}
func (o *PORT_Type) GetISFR_ISF20() uint32 {
	return (volatile.LoadUint32(&o.ISFR.Reg) & 0x100000) >> 20
}
func (o *PORT_Type) SetISFR_ISF21(value uint32) {
	volatile.StoreUint32(&o.ISFR.Reg, volatile.LoadUint32(&o.ISFR.Reg)&^(0x200000)|value<<21)
}
func (o *PORT_Type) GetISFR_ISF21() uint32 {
	return (volatile.LoadUint32(&o.ISFR.Reg) & 0x200000) >> 21
}
func (o *PORT_Type) SetISFR_ISF22(value uint32) {
	volatile.StoreUint32(&o.ISFR.Reg, volatile.LoadUint32(&o.ISFR.Reg)&^(0x400000)|value<<22)
}
func (o *PORT_Type) GetISFR_ISF22() uint32 {
	return (volatile.LoadUint32(&o.ISFR.Reg) & 0x400000) >> 22
}
func (o *PORT_Type) SetISFR_ISF23(value uint32) {
	volatile.StoreUint32(&o.ISFR.Reg, volatile.LoadUint32(&o.ISFR.Reg)&^(0x800000)|value<<23)
}
func (o *PORT_Type) GetISFR_ISF23() uint32 {
	return (volatile.LoadUint32(&o.ISFR.Reg) & 0x800000) >> 23
}
func (o *PORT_Type) SetISFR_ISF24(value uint32) {
	volatile.StoreUint32(&o.ISFR.Reg, volatile.LoadUint32(&o.ISFR.Reg)&^(0x1000000)|value<<24)
}
func (o *PORT_Type) GetISFR_ISF24() uint32 {
	return (volatile.LoadUint32(&o.ISFR.Reg) & 0x1000000) >> 24
}
func (o *PORT_Type) SetISFR_ISF25(value uint32) {
	volatile.StoreUint32(&o.ISFR.Reg, volatile.LoadUint32(&o.ISFR.Reg)&^(0x2000000)|value<<25)
}
func (o *PORT_Type) GetISFR_ISF25() uint32 {
	return (volatile.LoadUint32(&o.ISFR.Reg) & 0x2000000) >> 25
}
func (o *PORT_Type) SetISFR_ISF26(value uint32) {
	volatile.StoreUint32(&o.ISFR.Reg, volatile.LoadUint32(&o.ISFR.Reg)&^(0x4000000)|value<<26)
}
func (o *PORT_Type) GetISFR_ISF26() uint32 {
	return (volatile.LoadUint32(&o.ISFR.Reg) & 0x4000000) >> 26
}
func (o *PORT_Type) SetISFR_ISF27(value uint32) {
	volatile.StoreUint32(&o.ISFR.Reg, volatile.LoadUint32(&o.ISFR.Reg)&^(0x8000000)|value<<27)
}
func (o *PORT_Type) GetISFR_ISF27() uint32 {
	return (volatile.LoadUint32(&o.ISFR.Reg) & 0x8000000) >> 27
}
func (o *PORT_Type) SetISFR_ISF28(value uint32) {
	volatile.StoreUint32(&o.ISFR.Reg, volatile.LoadUint32(&o.ISFR.Reg)&^(0x10000000)|value<<28)
}
func (o *PORT_Type) GetISFR_ISF28() uint32 {
	return (volatile.LoadUint32(&o.ISFR.Reg) & 0x10000000) >> 28
}
func (o *PORT_Type) SetISFR_ISF29(value uint32) {
	volatile.StoreUint32(&o.ISFR.Reg, volatile.LoadUint32(&o.ISFR.Reg)&^(0x20000000)|value<<29)
}
func (o *PORT_Type) GetISFR_ISF29() uint32 {
	return (volatile.LoadUint32(&o.ISFR.Reg) & 0x20000000) >> 29
}
func (o *PORT_Type) SetISFR_ISF30(value uint32) {
	volatile.StoreUint32(&o.ISFR.Reg, volatile.LoadUint32(&o.ISFR.Reg)&^(0x40000000)|value<<30)
}
func (o *PORT_Type) GetISFR_ISF30() uint32 {
	return (volatile.LoadUint32(&o.ISFR.Reg) & 0x40000000) >> 30
}
func (o *PORT_Type) SetISFR_ISF31(value uint32) {
	volatile.StoreUint32(&o.ISFR.Reg, volatile.LoadUint32(&o.ISFR.Reg)&^(0x80000000)|value<<31)
}
func (o *PORT_Type) GetISFR_ISF31() uint32 {
	return (volatile.LoadUint32(&o.ISFR.Reg) & 0x80000000) >> 31
}

// Generation 2008 Watchdog Timer
type WDOG_Type struct {
	STCTRLH volatile.Register16 // 0x0
	STCTRLL volatile.Register16 // 0x2
	TOVALH  volatile.Register16 // 0x4
	TOVALL  volatile.Register16 // 0x6
	WINH    volatile.Register16 // 0x8
	WINL    volatile.Register16 // 0xA
	REFRESH volatile.Register16 // 0xC
	UNLOCK  volatile.Register16 // 0xE
	TMROUTH volatile.Register16 // 0x10
	TMROUTL volatile.Register16 // 0x12
	RSTCNT  volatile.Register16 // 0x14
	PRESC   volatile.Register16 // 0x16
}

// WDOG.STCTRLH: Watchdog Status and Control Register High
func (o *WDOG_Type) SetSTCTRLH_WDOGEN(value uint16) {
	volatile.StoreUint16(&o.STCTRLH.Reg, volatile.LoadUint16(&o.STCTRLH.Reg)&^(0x1)|value)
}
func (o *WDOG_Type) GetSTCTRLH_WDOGEN() uint16 {
	return volatile.LoadUint16(&o.STCTRLH.Reg) & 0x1
}
func (o *WDOG_Type) SetSTCTRLH_CLKSRC(value uint16) {
	volatile.StoreUint16(&o.STCTRLH.Reg, volatile.LoadUint16(&o.STCTRLH.Reg)&^(0x2)|value<<1)
}
func (o *WDOG_Type) GetSTCTRLH_CLKSRC() uint16 {
	return (volatile.LoadUint16(&o.STCTRLH.Reg) & 0x2) >> 1
}
func (o *WDOG_Type) SetSTCTRLH_IRQRSTEN(value uint16) {
	volatile.StoreUint16(&o.STCTRLH.Reg, volatile.LoadUint16(&o.STCTRLH.Reg)&^(0x4)|value<<2)
}
func (o *WDOG_Type) GetSTCTRLH_IRQRSTEN() uint16 {
	return (volatile.LoadUint16(&o.STCTRLH.Reg) & 0x4) >> 2
}
func (o *WDOG_Type) SetSTCTRLH_WINEN(value uint16) {
	volatile.StoreUint16(&o.STCTRLH.Reg, volatile.LoadUint16(&o.STCTRLH.Reg)&^(0x8)|value<<3)
}
func (o *WDOG_Type) GetSTCTRLH_WINEN() uint16 {
	return (volatile.LoadUint16(&o.STCTRLH.Reg) & 0x8) >> 3
}
func (o *WDOG_Type) SetSTCTRLH_ALLOWUPDATE(value uint16) {
	volatile.StoreUint16(&o.STCTRLH.Reg, volatile.LoadUint16(&o.STCTRLH.Reg)&^(0x10)|value<<4)
}
func (o *WDOG_Type) GetSTCTRLH_ALLOWUPDATE() uint16 {
	return (volatile.LoadUint16(&o.STCTRLH.Reg) & 0x10) >> 4
}
func (o *WDOG_Type) SetSTCTRLH_DBGEN(value uint16) {
	volatile.StoreUint16(&o.STCTRLH.Reg, volatile.LoadUint16(&o.STCTRLH.Reg)&^(0x20)|value<<5)
}
func (o *WDOG_Type) GetSTCTRLH_DBGEN() uint16 {
	return (volatile.LoadUint16(&o.STCTRLH.Reg) & 0x20) >> 5
}
func (o *WDOG_Type) SetSTCTRLH_STOPEN(value uint16) {
	volatile.StoreUint16(&o.STCTRLH.Reg, volatile.LoadUint16(&o.STCTRLH.Reg)&^(0x40)|value<<6)
}
func (o *WDOG_Type) GetSTCTRLH_STOPEN() uint16 {
	return (volatile.LoadUint16(&o.STCTRLH.Reg) & 0x40) >> 6
}
func (o *WDOG_Type) SetSTCTRLH_WAITEN(value uint16) {
	volatile.StoreUint16(&o.STCTRLH.Reg, volatile.LoadUint16(&o.STCTRLH.Reg)&^(0x80)|value<<7)
}
func (o *WDOG_Type) GetSTCTRLH_WAITEN() uint16 {
	return (volatile.LoadUint16(&o.STCTRLH.Reg) & 0x80) >> 7
}
func (o *WDOG_Type) SetSTCTRLH_TESTWDOG(value uint16) {
	volatile.StoreUint16(&o.STCTRLH.Reg, volatile.LoadUint16(&o.STCTRLH.Reg)&^(0x400)|value<<10)
}
func (o *WDOG_Type) GetSTCTRLH_TESTWDOG() uint16 {
	return (volatile.LoadUint16(&o.STCTRLH.Reg) & 0x400) >> 10
}
func (o *WDOG_Type) SetSTCTRLH_TESTSEL(value uint16) {
	volatile.StoreUint16(&o.STCTRLH.Reg, volatile.LoadUint16(&o.STCTRLH.Reg)&^(0x800)|value<<11)
}
func (o *WDOG_Type) GetSTCTRLH_TESTSEL() uint16 {
	return (volatile.LoadUint16(&o.STCTRLH.Reg) & 0x800) >> 11
}
func (o *WDOG_Type) SetSTCTRLH_BYTESEL(value uint16) {
	volatile.StoreUint16(&o.STCTRLH.Reg, volatile.LoadUint16(&o.STCTRLH.Reg)&^(0x3000)|value<<12)
}
func (o *WDOG_Type) GetSTCTRLH_BYTESEL() uint16 {
	return (volatile.LoadUint16(&o.STCTRLH.Reg) & 0x3000) >> 12
}
func (o *WDOG_Type) SetSTCTRLH_DISTESTWDOG(value uint16) {
	volatile.StoreUint16(&o.STCTRLH.Reg, volatile.LoadUint16(&o.STCTRLH.Reg)&^(0x4000)|value<<14)
}
func (o *WDOG_Type) GetSTCTRLH_DISTESTWDOG() uint16 {
	return (volatile.LoadUint16(&o.STCTRLH.Reg) & 0x4000) >> 14
}

// WDOG.STCTRLL: Watchdog Status and Control Register Low
func (o *WDOG_Type) SetSTCTRLL_INTFLG(value uint16) {
	volatile.StoreUint16(&o.STCTRLL.Reg, volatile.LoadUint16(&o.STCTRLL.Reg)&^(0x8000)|value<<15)
}
func (o *WDOG_Type) GetSTCTRLL_INTFLG() uint16 {
	return (volatile.LoadUint16(&o.STCTRLL.Reg) & 0x8000) >> 15
}

// WDOG.TOVALH: Watchdog Time-out Value Register High
func (o *WDOG_Type) SetTOVALH(value uint16) {
	volatile.StoreUint16(&o.TOVALH.Reg, value)
}
func (o *WDOG_Type) GetTOVALH() uint16 {
	return volatile.LoadUint16(&o.TOVALH.Reg)
}

// WDOG.TOVALL: Watchdog Time-out Value Register Low
func (o *WDOG_Type) SetTOVALL(value uint16) {
	volatile.StoreUint16(&o.TOVALL.Reg, value)
}
func (o *WDOG_Type) GetTOVALL() uint16 {
	return volatile.LoadUint16(&o.TOVALL.Reg)
}

// WDOG.WINH: Watchdog Window Register High
func (o *WDOG_Type) SetWINH(value uint16) {
	volatile.StoreUint16(&o.WINH.Reg, value)
}
func (o *WDOG_Type) GetWINH() uint16 {
	return volatile.LoadUint16(&o.WINH.Reg)
}

// WDOG.WINL: Watchdog Window Register Low
func (o *WDOG_Type) SetWINL(value uint16) {
	volatile.StoreUint16(&o.WINL.Reg, value)
}
func (o *WDOG_Type) GetWINL() uint16 {
	return volatile.LoadUint16(&o.WINL.Reg)
}

// WDOG.REFRESH: Watchdog Refresh register
func (o *WDOG_Type) SetREFRESH(value uint16) {
	volatile.StoreUint16(&o.REFRESH.Reg, value)
}
func (o *WDOG_Type) GetREFRESH() uint16 {
	return volatile.LoadUint16(&o.REFRESH.Reg)
}

// WDOG.UNLOCK: Watchdog Unlock register
func (o *WDOG_Type) SetUNLOCK(value uint16) {
	volatile.StoreUint16(&o.UNLOCK.Reg, value)
}
func (o *WDOG_Type) GetUNLOCK() uint16 {
	return volatile.LoadUint16(&o.UNLOCK.Reg)
}

// WDOG.TMROUTH: Watchdog Timer Output Register High
func (o *WDOG_Type) SetTMROUTH(value uint16) {
	volatile.StoreUint16(&o.TMROUTH.Reg, value)
}
func (o *WDOG_Type) GetTMROUTH() uint16 {
	return volatile.LoadUint16(&o.TMROUTH.Reg)
}

// WDOG.TMROUTL: Watchdog Timer Output Register Low
func (o *WDOG_Type) SetTMROUTL(value uint16) {
	volatile.StoreUint16(&o.TMROUTL.Reg, value)
}
func (o *WDOG_Type) GetTMROUTL() uint16 {
	return volatile.LoadUint16(&o.TMROUTL.Reg)
}

// WDOG.RSTCNT: Watchdog Reset Count register
func (o *WDOG_Type) SetRSTCNT(value uint16) {
	volatile.StoreUint16(&o.RSTCNT.Reg, value)
}
func (o *WDOG_Type) GetRSTCNT() uint16 {
	return volatile.LoadUint16(&o.RSTCNT.Reg)
}

// WDOG.PRESC: Watchdog Prescaler register
func (o *WDOG_Type) SetPRESC_PRESCVAL(value uint16) {
	volatile.StoreUint16(&o.PRESC.Reg, volatile.LoadUint16(&o.PRESC.Reg)&^(0x700)|value<<8)
}
func (o *WDOG_Type) GetPRESC_PRESCVAL() uint16 {
	return (volatile.LoadUint16(&o.PRESC.Reg) & 0x700) >> 8
}

// External Watchdog Monitor
type EWM_Type struct {
	CTRL volatile.Register8 // 0x0
	SERV volatile.Register8 // 0x1
	CMPL volatile.Register8 // 0x2
	CMPH volatile.Register8 // 0x3
}

// EWM.CTRL: Control Register
func (o *EWM_Type) SetCTRL_EWMEN(value uint8) {
	volatile.StoreUint8(&o.CTRL.Reg, volatile.LoadUint8(&o.CTRL.Reg)&^(0x1)|value)
}
func (o *EWM_Type) GetCTRL_EWMEN() uint8 {
	return volatile.LoadUint8(&o.CTRL.Reg) & 0x1
}
func (o *EWM_Type) SetCTRL_ASSIN(value uint8) {
	volatile.StoreUint8(&o.CTRL.Reg, volatile.LoadUint8(&o.CTRL.Reg)&^(0x2)|value<<1)
}
func (o *EWM_Type) GetCTRL_ASSIN() uint8 {
	return (volatile.LoadUint8(&o.CTRL.Reg) & 0x2) >> 1
}
func (o *EWM_Type) SetCTRL_INEN(value uint8) {
	volatile.StoreUint8(&o.CTRL.Reg, volatile.LoadUint8(&o.CTRL.Reg)&^(0x4)|value<<2)
}
func (o *EWM_Type) GetCTRL_INEN() uint8 {
	return (volatile.LoadUint8(&o.CTRL.Reg) & 0x4) >> 2
}
func (o *EWM_Type) SetCTRL_INTEN(value uint8) {
	volatile.StoreUint8(&o.CTRL.Reg, volatile.LoadUint8(&o.CTRL.Reg)&^(0x8)|value<<3)
}
func (o *EWM_Type) GetCTRL_INTEN() uint8 {
	return (volatile.LoadUint8(&o.CTRL.Reg) & 0x8) >> 3
}

// EWM.SERV: Service Register
func (o *EWM_Type) SetSERV(value uint8) {
	volatile.StoreUint8(&o.SERV.Reg, value)
}
func (o *EWM_Type) GetSERV() uint8 {
	return volatile.LoadUint8(&o.SERV.Reg)
}

// EWM.CMPL: Compare Low Register
func (o *EWM_Type) SetCMPL(value uint8) {
	volatile.StoreUint8(&o.CMPL.Reg, value)
}
func (o *EWM_Type) GetCMPL() uint8 {
	return volatile.LoadUint8(&o.CMPL.Reg)
}

// EWM.CMPH: Compare High Register
func (o *EWM_Type) SetCMPH(value uint8) {
	volatile.StoreUint8(&o.CMPH.Reg, value)
}
func (o *EWM_Type) GetCMPH() uint8 {
	return volatile.LoadUint8(&o.CMPH.Reg)
}

// Carrier Modulator Transmitter
type CMT_Type struct {
	CGH1 volatile.Register8 // 0x0
	CGL1 volatile.Register8 // 0x1
	CGH2 volatile.Register8 // 0x2
	CGL2 volatile.Register8 // 0x3
	OC   volatile.Register8 // 0x4
	MSC  volatile.Register8 // 0x5
	CMD1 volatile.Register8 // 0x6
	CMD2 volatile.Register8 // 0x7
	CMD3 volatile.Register8 // 0x8
	CMD4 volatile.Register8 // 0x9
	PPS  volatile.Register8 // 0xA
	DMA  volatile.Register8 // 0xB
}

// CMT.CGH1: CMT Carrier Generator High Data Register 1
func (o *CMT_Type) SetCGH1(value uint8) {
	volatile.StoreUint8(&o.CGH1.Reg, value)
}
func (o *CMT_Type) GetCGH1() uint8 {
	return volatile.LoadUint8(&o.CGH1.Reg)
}

// CMT.CGL1: CMT Carrier Generator Low Data Register 1
func (o *CMT_Type) SetCGL1(value uint8) {
	volatile.StoreUint8(&o.CGL1.Reg, value)
}
func (o *CMT_Type) GetCGL1() uint8 {
	return volatile.LoadUint8(&o.CGL1.Reg)
}

// CMT.CGH2: CMT Carrier Generator High Data Register 2
func (o *CMT_Type) SetCGH2(value uint8) {
	volatile.StoreUint8(&o.CGH2.Reg, value)
}
func (o *CMT_Type) GetCGH2() uint8 {
	return volatile.LoadUint8(&o.CGH2.Reg)
}

// CMT.CGL2: CMT Carrier Generator Low Data Register 2
func (o *CMT_Type) SetCGL2(value uint8) {
	volatile.StoreUint8(&o.CGL2.Reg, value)
}
func (o *CMT_Type) GetCGL2() uint8 {
	return volatile.LoadUint8(&o.CGL2.Reg)
}

// CMT.OC: CMT Output Control Register
func (o *CMT_Type) SetOC_IROPEN(value uint8) {
	volatile.StoreUint8(&o.OC.Reg, volatile.LoadUint8(&o.OC.Reg)&^(0x20)|value<<5)
}
func (o *CMT_Type) GetOC_IROPEN() uint8 {
	return (volatile.LoadUint8(&o.OC.Reg) & 0x20) >> 5
}
func (o *CMT_Type) SetOC_CMTPOL(value uint8) {
	volatile.StoreUint8(&o.OC.Reg, volatile.LoadUint8(&o.OC.Reg)&^(0x40)|value<<6)
}
func (o *CMT_Type) GetOC_CMTPOL() uint8 {
	return (volatile.LoadUint8(&o.OC.Reg) & 0x40) >> 6
}
func (o *CMT_Type) SetOC_IROL(value uint8) {
	volatile.StoreUint8(&o.OC.Reg, volatile.LoadUint8(&o.OC.Reg)&^(0x80)|value<<7)
}
func (o *CMT_Type) GetOC_IROL() uint8 {
	return (volatile.LoadUint8(&o.OC.Reg) & 0x80) >> 7
}

// CMT.MSC: CMT Modulator Status and Control Register
func (o *CMT_Type) SetMSC_MCGEN(value uint8) {
	volatile.StoreUint8(&o.MSC.Reg, volatile.LoadUint8(&o.MSC.Reg)&^(0x1)|value)
}
func (o *CMT_Type) GetMSC_MCGEN() uint8 {
	return volatile.LoadUint8(&o.MSC.Reg) & 0x1
}
func (o *CMT_Type) SetMSC_EOCIE(value uint8) {
	volatile.StoreUint8(&o.MSC.Reg, volatile.LoadUint8(&o.MSC.Reg)&^(0x2)|value<<1)
}
func (o *CMT_Type) GetMSC_EOCIE() uint8 {
	return (volatile.LoadUint8(&o.MSC.Reg) & 0x2) >> 1
}
func (o *CMT_Type) SetMSC_FSK(value uint8) {
	volatile.StoreUint8(&o.MSC.Reg, volatile.LoadUint8(&o.MSC.Reg)&^(0x4)|value<<2)
}
func (o *CMT_Type) GetMSC_FSK() uint8 {
	return (volatile.LoadUint8(&o.MSC.Reg) & 0x4) >> 2
}
func (o *CMT_Type) SetMSC_BASE(value uint8) {
	volatile.StoreUint8(&o.MSC.Reg, volatile.LoadUint8(&o.MSC.Reg)&^(0x8)|value<<3)
}
func (o *CMT_Type) GetMSC_BASE() uint8 {
	return (volatile.LoadUint8(&o.MSC.Reg) & 0x8) >> 3
}
func (o *CMT_Type) SetMSC_EXSPC(value uint8) {
	volatile.StoreUint8(&o.MSC.Reg, volatile.LoadUint8(&o.MSC.Reg)&^(0x10)|value<<4)
}
func (o *CMT_Type) GetMSC_EXSPC() uint8 {
	return (volatile.LoadUint8(&o.MSC.Reg) & 0x10) >> 4
}
func (o *CMT_Type) SetMSC_CMTDIV(value uint8) {
	volatile.StoreUint8(&o.MSC.Reg, volatile.LoadUint8(&o.MSC.Reg)&^(0x60)|value<<5)
}
func (o *CMT_Type) GetMSC_CMTDIV() uint8 {
	return (volatile.LoadUint8(&o.MSC.Reg) & 0x60) >> 5
}
func (o *CMT_Type) SetMSC_EOCF(value uint8) {
	volatile.StoreUint8(&o.MSC.Reg, volatile.LoadUint8(&o.MSC.Reg)&^(0x80)|value<<7)
}
func (o *CMT_Type) GetMSC_EOCF() uint8 {
	return (volatile.LoadUint8(&o.MSC.Reg) & 0x80) >> 7
}

// CMT.CMD1: CMT Modulator Data Register Mark High
func (o *CMT_Type) SetCMD1(value uint8) {
	volatile.StoreUint8(&o.CMD1.Reg, value)
}
func (o *CMT_Type) GetCMD1() uint8 {
	return volatile.LoadUint8(&o.CMD1.Reg)
}

// CMT.CMD2: CMT Modulator Data Register Mark Low
func (o *CMT_Type) SetCMD2(value uint8) {
	volatile.StoreUint8(&o.CMD2.Reg, value)
}
func (o *CMT_Type) GetCMD2() uint8 {
	return volatile.LoadUint8(&o.CMD2.Reg)
}

// CMT.CMD3: CMT Modulator Data Register Space High
func (o *CMT_Type) SetCMD3(value uint8) {
	volatile.StoreUint8(&o.CMD3.Reg, value)
}
func (o *CMT_Type) GetCMD3() uint8 {
	return volatile.LoadUint8(&o.CMD3.Reg)
}

// CMT.CMD4: CMT Modulator Data Register Space Low
func (o *CMT_Type) SetCMD4(value uint8) {
	volatile.StoreUint8(&o.CMD4.Reg, value)
}
func (o *CMT_Type) GetCMD4() uint8 {
	return volatile.LoadUint8(&o.CMD4.Reg)
}

// CMT.PPS: CMT Primary Prescaler Register
func (o *CMT_Type) SetPPS_PPSDIV(value uint8) {
	volatile.StoreUint8(&o.PPS.Reg, volatile.LoadUint8(&o.PPS.Reg)&^(0xf)|value)
}
func (o *CMT_Type) GetPPS_PPSDIV() uint8 {
	return volatile.LoadUint8(&o.PPS.Reg) & 0xf
}

// CMT.DMA: CMT Direct Memory Access Register
func (o *CMT_Type) SetDMA(value uint8) {
	volatile.StoreUint8(&o.DMA.Reg, volatile.LoadUint8(&o.DMA.Reg)&^(0x1)|value)
}
func (o *CMT_Type) GetDMA() uint8 {
	return volatile.LoadUint8(&o.DMA.Reg) & 0x1
}

// Multipurpose Clock Generator module
type MCG_Type struct {
	C1    volatile.Register8 // 0x0
	C2    volatile.Register8 // 0x1
	C3    volatile.Register8 // 0x2
	C4    volatile.Register8 // 0x3
	C5    volatile.Register8 // 0x4
	C6    volatile.Register8 // 0x5
	S     volatile.Register8 // 0x6
	_     byte
	SC    volatile.Register8 // 0x8
	_     byte
	ATCVH volatile.Register8 // 0xA
	ATCVL volatile.Register8 // 0xB
	C7    volatile.Register8 // 0xC
	C8    volatile.Register8 // 0xD
}

// MCG.C1: MCG Control 1 Register
func (o *MCG_Type) SetC1_IREFSTEN(value uint8) {
	volatile.StoreUint8(&o.C1.Reg, volatile.LoadUint8(&o.C1.Reg)&^(0x1)|value)
}
func (o *MCG_Type) GetC1_IREFSTEN() uint8 {
	return volatile.LoadUint8(&o.C1.Reg) & 0x1
}
func (o *MCG_Type) SetC1_IRCLKEN(value uint8) {
	volatile.StoreUint8(&o.C1.Reg, volatile.LoadUint8(&o.C1.Reg)&^(0x2)|value<<1)
}
func (o *MCG_Type) GetC1_IRCLKEN() uint8 {
	return (volatile.LoadUint8(&o.C1.Reg) & 0x2) >> 1
}
func (o *MCG_Type) SetC1_IREFS(value uint8) {
	volatile.StoreUint8(&o.C1.Reg, volatile.LoadUint8(&o.C1.Reg)&^(0x4)|value<<2)
}
func (o *MCG_Type) GetC1_IREFS() uint8 {
	return (volatile.LoadUint8(&o.C1.Reg) & 0x4) >> 2
}
func (o *MCG_Type) SetC1_FRDIV(value uint8) {
	volatile.StoreUint8(&o.C1.Reg, volatile.LoadUint8(&o.C1.Reg)&^(0x38)|value<<3)
}
func (o *MCG_Type) GetC1_FRDIV() uint8 {
	return (volatile.LoadUint8(&o.C1.Reg) & 0x38) >> 3
}
func (o *MCG_Type) SetC1_CLKS(value uint8) {
	volatile.StoreUint8(&o.C1.Reg, volatile.LoadUint8(&o.C1.Reg)&^(0xc0)|value<<6)
}
func (o *MCG_Type) GetC1_CLKS() uint8 {
	return (volatile.LoadUint8(&o.C1.Reg) & 0xc0) >> 6
}

// MCG.C2: MCG Control 2 Register
func (o *MCG_Type) SetC2_IRCS(value uint8) {
	volatile.StoreUint8(&o.C2.Reg, volatile.LoadUint8(&o.C2.Reg)&^(0x1)|value)
}
func (o *MCG_Type) GetC2_IRCS() uint8 {
	return volatile.LoadUint8(&o.C2.Reg) & 0x1
}
func (o *MCG_Type) SetC2_LP(value uint8) {
	volatile.StoreUint8(&o.C2.Reg, volatile.LoadUint8(&o.C2.Reg)&^(0x2)|value<<1)
}
func (o *MCG_Type) GetC2_LP() uint8 {
	return (volatile.LoadUint8(&o.C2.Reg) & 0x2) >> 1
}
func (o *MCG_Type) SetC2_EREFS(value uint8) {
	volatile.StoreUint8(&o.C2.Reg, volatile.LoadUint8(&o.C2.Reg)&^(0x4)|value<<2)
}
func (o *MCG_Type) GetC2_EREFS() uint8 {
	return (volatile.LoadUint8(&o.C2.Reg) & 0x4) >> 2
}
func (o *MCG_Type) SetC2_HGO(value uint8) {
	volatile.StoreUint8(&o.C2.Reg, volatile.LoadUint8(&o.C2.Reg)&^(0x8)|value<<3)
}
func (o *MCG_Type) GetC2_HGO() uint8 {
	return (volatile.LoadUint8(&o.C2.Reg) & 0x8) >> 3
}
func (o *MCG_Type) SetC2_RANGE(value uint8) {
	volatile.StoreUint8(&o.C2.Reg, volatile.LoadUint8(&o.C2.Reg)&^(0x30)|value<<4)
}
func (o *MCG_Type) GetC2_RANGE() uint8 {
	return (volatile.LoadUint8(&o.C2.Reg) & 0x30) >> 4
}
func (o *MCG_Type) SetC2_FCFTRIM(value uint8) {
	volatile.StoreUint8(&o.C2.Reg, volatile.LoadUint8(&o.C2.Reg)&^(0x40)|value<<6)
}
func (o *MCG_Type) GetC2_FCFTRIM() uint8 {
	return (volatile.LoadUint8(&o.C2.Reg) & 0x40) >> 6
}
func (o *MCG_Type) SetC2_LOCRE0(value uint8) {
	volatile.StoreUint8(&o.C2.Reg, volatile.LoadUint8(&o.C2.Reg)&^(0x80)|value<<7)
}
func (o *MCG_Type) GetC2_LOCRE0() uint8 {
	return (volatile.LoadUint8(&o.C2.Reg) & 0x80) >> 7
}

// MCG.C3: MCG Control 3 Register
func (o *MCG_Type) SetC3(value uint8) {
	volatile.StoreUint8(&o.C3.Reg, value)
}
func (o *MCG_Type) GetC3() uint8 {
	return volatile.LoadUint8(&o.C3.Reg)
}

// MCG.C4: MCG Control 4 Register
func (o *MCG_Type) SetC4_SCFTRIM(value uint8) {
	volatile.StoreUint8(&o.C4.Reg, volatile.LoadUint8(&o.C4.Reg)&^(0x1)|value)
}
func (o *MCG_Type) GetC4_SCFTRIM() uint8 {
	return volatile.LoadUint8(&o.C4.Reg) & 0x1
}
func (o *MCG_Type) SetC4_FCTRIM(value uint8) {
	volatile.StoreUint8(&o.C4.Reg, volatile.LoadUint8(&o.C4.Reg)&^(0x1e)|value<<1)
}
func (o *MCG_Type) GetC4_FCTRIM() uint8 {
	return (volatile.LoadUint8(&o.C4.Reg) & 0x1e) >> 1
}
func (o *MCG_Type) SetC4_DRST_DRS(value uint8) {
	volatile.StoreUint8(&o.C4.Reg, volatile.LoadUint8(&o.C4.Reg)&^(0x60)|value<<5)
}
func (o *MCG_Type) GetC4_DRST_DRS() uint8 {
	return (volatile.LoadUint8(&o.C4.Reg) & 0x60) >> 5
}
func (o *MCG_Type) SetC4_DMX32(value uint8) {
	volatile.StoreUint8(&o.C4.Reg, volatile.LoadUint8(&o.C4.Reg)&^(0x80)|value<<7)
}
func (o *MCG_Type) GetC4_DMX32() uint8 {
	return (volatile.LoadUint8(&o.C4.Reg) & 0x80) >> 7
}

// MCG.C5: MCG Control 5 Register
func (o *MCG_Type) SetC5_PRDIV0(value uint8) {
	volatile.StoreUint8(&o.C5.Reg, volatile.LoadUint8(&o.C5.Reg)&^(0x1f)|value)
}
func (o *MCG_Type) GetC5_PRDIV0() uint8 {
	return volatile.LoadUint8(&o.C5.Reg) & 0x1f
}
func (o *MCG_Type) SetC5_PLLSTEN0(value uint8) {
	volatile.StoreUint8(&o.C5.Reg, volatile.LoadUint8(&o.C5.Reg)&^(0x20)|value<<5)
}
func (o *MCG_Type) GetC5_PLLSTEN0() uint8 {
	return (volatile.LoadUint8(&o.C5.Reg) & 0x20) >> 5
}
func (o *MCG_Type) SetC5_PLLCLKEN0(value uint8) {
	volatile.StoreUint8(&o.C5.Reg, volatile.LoadUint8(&o.C5.Reg)&^(0x40)|value<<6)
}
func (o *MCG_Type) GetC5_PLLCLKEN0() uint8 {
	return (volatile.LoadUint8(&o.C5.Reg) & 0x40) >> 6
}

// MCG.C6: MCG Control 6 Register
func (o *MCG_Type) SetC6_VDIV0(value uint8) {
	volatile.StoreUint8(&o.C6.Reg, volatile.LoadUint8(&o.C6.Reg)&^(0x1f)|value)
}
func (o *MCG_Type) GetC6_VDIV0() uint8 {
	return volatile.LoadUint8(&o.C6.Reg) & 0x1f
}
func (o *MCG_Type) SetC6_CME0(value uint8) {
	volatile.StoreUint8(&o.C6.Reg, volatile.LoadUint8(&o.C6.Reg)&^(0x20)|value<<5)
}
func (o *MCG_Type) GetC6_CME0() uint8 {
	return (volatile.LoadUint8(&o.C6.Reg) & 0x20) >> 5
}
func (o *MCG_Type) SetC6_PLLS(value uint8) {
	volatile.StoreUint8(&o.C6.Reg, volatile.LoadUint8(&o.C6.Reg)&^(0x40)|value<<6)
}
func (o *MCG_Type) GetC6_PLLS() uint8 {
	return (volatile.LoadUint8(&o.C6.Reg) & 0x40) >> 6
}
func (o *MCG_Type) SetC6_LOLIE0(value uint8) {
	volatile.StoreUint8(&o.C6.Reg, volatile.LoadUint8(&o.C6.Reg)&^(0x80)|value<<7)
}
func (o *MCG_Type) GetC6_LOLIE0() uint8 {
	return (volatile.LoadUint8(&o.C6.Reg) & 0x80) >> 7
}

// MCG.S: MCG Status Register
func (o *MCG_Type) SetS_IRCST(value uint8) {
	volatile.StoreUint8(&o.S.Reg, volatile.LoadUint8(&o.S.Reg)&^(0x1)|value)
}
func (o *MCG_Type) GetS_IRCST() uint8 {
	return volatile.LoadUint8(&o.S.Reg) & 0x1
}
func (o *MCG_Type) SetS_OSCINIT0(value uint8) {
	volatile.StoreUint8(&o.S.Reg, volatile.LoadUint8(&o.S.Reg)&^(0x2)|value<<1)
}
func (o *MCG_Type) GetS_OSCINIT0() uint8 {
	return (volatile.LoadUint8(&o.S.Reg) & 0x2) >> 1
}
func (o *MCG_Type) SetS_CLKST(value uint8) {
	volatile.StoreUint8(&o.S.Reg, volatile.LoadUint8(&o.S.Reg)&^(0xc)|value<<2)
}
func (o *MCG_Type) GetS_CLKST() uint8 {
	return (volatile.LoadUint8(&o.S.Reg) & 0xc) >> 2
}
func (o *MCG_Type) SetS_IREFST(value uint8) {
	volatile.StoreUint8(&o.S.Reg, volatile.LoadUint8(&o.S.Reg)&^(0x10)|value<<4)
}
func (o *MCG_Type) GetS_IREFST() uint8 {
	return (volatile.LoadUint8(&o.S.Reg) & 0x10) >> 4
}
func (o *MCG_Type) SetS_PLLST(value uint8) {
	volatile.StoreUint8(&o.S.Reg, volatile.LoadUint8(&o.S.Reg)&^(0x20)|value<<5)
}
func (o *MCG_Type) GetS_PLLST() uint8 {
	return (volatile.LoadUint8(&o.S.Reg) & 0x20) >> 5
}
func (o *MCG_Type) SetS_LOCK0(value uint8) {
	volatile.StoreUint8(&o.S.Reg, volatile.LoadUint8(&o.S.Reg)&^(0x40)|value<<6)
}
func (o *MCG_Type) GetS_LOCK0() uint8 {
	return (volatile.LoadUint8(&o.S.Reg) & 0x40) >> 6
}
func (o *MCG_Type) SetS_LOLS0(value uint8) {
	volatile.StoreUint8(&o.S.Reg, volatile.LoadUint8(&o.S.Reg)&^(0x80)|value<<7)
}
func (o *MCG_Type) GetS_LOLS0() uint8 {
	return (volatile.LoadUint8(&o.S.Reg) & 0x80) >> 7
}

// MCG.SC: MCG Status and Control Register
func (o *MCG_Type) SetSC_LOCS0(value uint8) {
	volatile.StoreUint8(&o.SC.Reg, volatile.LoadUint8(&o.SC.Reg)&^(0x1)|value)
}
func (o *MCG_Type) GetSC_LOCS0() uint8 {
	return volatile.LoadUint8(&o.SC.Reg) & 0x1
}
func (o *MCG_Type) SetSC_FCRDIV(value uint8) {
	volatile.StoreUint8(&o.SC.Reg, volatile.LoadUint8(&o.SC.Reg)&^(0xe)|value<<1)
}
func (o *MCG_Type) GetSC_FCRDIV() uint8 {
	return (volatile.LoadUint8(&o.SC.Reg) & 0xe) >> 1
}
func (o *MCG_Type) SetSC_FLTPRSRV(value uint8) {
	volatile.StoreUint8(&o.SC.Reg, volatile.LoadUint8(&o.SC.Reg)&^(0x10)|value<<4)
}
func (o *MCG_Type) GetSC_FLTPRSRV() uint8 {
	return (volatile.LoadUint8(&o.SC.Reg) & 0x10) >> 4
}
func (o *MCG_Type) SetSC_ATMF(value uint8) {
	volatile.StoreUint8(&o.SC.Reg, volatile.LoadUint8(&o.SC.Reg)&^(0x20)|value<<5)
}
func (o *MCG_Type) GetSC_ATMF() uint8 {
	return (volatile.LoadUint8(&o.SC.Reg) & 0x20) >> 5
}
func (o *MCG_Type) SetSC_ATMS(value uint8) {
	volatile.StoreUint8(&o.SC.Reg, volatile.LoadUint8(&o.SC.Reg)&^(0x40)|value<<6)
}
func (o *MCG_Type) GetSC_ATMS() uint8 {
	return (volatile.LoadUint8(&o.SC.Reg) & 0x40) >> 6
}
func (o *MCG_Type) SetSC_ATME(value uint8) {
	volatile.StoreUint8(&o.SC.Reg, volatile.LoadUint8(&o.SC.Reg)&^(0x80)|value<<7)
}
func (o *MCG_Type) GetSC_ATME() uint8 {
	return (volatile.LoadUint8(&o.SC.Reg) & 0x80) >> 7
}

// MCG.ATCVH: MCG Auto Trim Compare Value High Register
func (o *MCG_Type) SetATCVH(value uint8) {
	volatile.StoreUint8(&o.ATCVH.Reg, value)
}
func (o *MCG_Type) GetATCVH() uint8 {
	return volatile.LoadUint8(&o.ATCVH.Reg)
}

// MCG.ATCVL: MCG Auto Trim Compare Value Low Register
func (o *MCG_Type) SetATCVL(value uint8) {
	volatile.StoreUint8(&o.ATCVL.Reg, value)
}
func (o *MCG_Type) GetATCVL() uint8 {
	return volatile.LoadUint8(&o.ATCVL.Reg)
}

// MCG.C7: MCG Control 7 Register
func (o *MCG_Type) SetC7_OSCSEL(value uint8) {
	volatile.StoreUint8(&o.C7.Reg, volatile.LoadUint8(&o.C7.Reg)&^(0x3)|value)
}
func (o *MCG_Type) GetC7_OSCSEL() uint8 {
	return volatile.LoadUint8(&o.C7.Reg) & 0x3
}

// MCG.C8: MCG Control 8 Register
func (o *MCG_Type) SetC8_LOCS1(value uint8) {
	volatile.StoreUint8(&o.C8.Reg, volatile.LoadUint8(&o.C8.Reg)&^(0x1)|value)
}
func (o *MCG_Type) GetC8_LOCS1() uint8 {
	return volatile.LoadUint8(&o.C8.Reg) & 0x1
}
func (o *MCG_Type) SetC8_CME1(value uint8) {
	volatile.StoreUint8(&o.C8.Reg, volatile.LoadUint8(&o.C8.Reg)&^(0x20)|value<<5)
}
func (o *MCG_Type) GetC8_CME1() uint8 {
	return (volatile.LoadUint8(&o.C8.Reg) & 0x20) >> 5
}
func (o *MCG_Type) SetC8_LOLRE(value uint8) {
	volatile.StoreUint8(&o.C8.Reg, volatile.LoadUint8(&o.C8.Reg)&^(0x40)|value<<6)
}
func (o *MCG_Type) GetC8_LOLRE() uint8 {
	return (volatile.LoadUint8(&o.C8.Reg) & 0x40) >> 6
}
func (o *MCG_Type) SetC8_LOCRE1(value uint8) {
	volatile.StoreUint8(&o.C8.Reg, volatile.LoadUint8(&o.C8.Reg)&^(0x80)|value<<7)
}
func (o *MCG_Type) GetC8_LOCRE1() uint8 {
	return (volatile.LoadUint8(&o.C8.Reg) & 0x80) >> 7
}

// Oscillator
type OSC_Type struct {
	CR volatile.Register8 // 0x0
}

// OSC.CR: OSC Control Register
func (o *OSC_Type) SetCR_SC16P(value uint8) {
	volatile.StoreUint8(&o.CR.Reg, volatile.LoadUint8(&o.CR.Reg)&^(0x1)|value)
}
func (o *OSC_Type) GetCR_SC16P() uint8 {
	return volatile.LoadUint8(&o.CR.Reg) & 0x1
}
func (o *OSC_Type) SetCR_SC8P(value uint8) {
	volatile.StoreUint8(&o.CR.Reg, volatile.LoadUint8(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *OSC_Type) GetCR_SC8P() uint8 {
	return (volatile.LoadUint8(&o.CR.Reg) & 0x2) >> 1
}
func (o *OSC_Type) SetCR_SC4P(value uint8) {
	volatile.StoreUint8(&o.CR.Reg, volatile.LoadUint8(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *OSC_Type) GetCR_SC4P() uint8 {
	return (volatile.LoadUint8(&o.CR.Reg) & 0x4) >> 2
}
func (o *OSC_Type) SetCR_SC2P(value uint8) {
	volatile.StoreUint8(&o.CR.Reg, volatile.LoadUint8(&o.CR.Reg)&^(0x8)|value<<3)
}
func (o *OSC_Type) GetCR_SC2P() uint8 {
	return (volatile.LoadUint8(&o.CR.Reg) & 0x8) >> 3
}
func (o *OSC_Type) SetCR_EREFSTEN(value uint8) {
	volatile.StoreUint8(&o.CR.Reg, volatile.LoadUint8(&o.CR.Reg)&^(0x20)|value<<5)
}
func (o *OSC_Type) GetCR_EREFSTEN() uint8 {
	return (volatile.LoadUint8(&o.CR.Reg) & 0x20) >> 5
}
func (o *OSC_Type) SetCR_ERCLKEN(value uint8) {
	volatile.StoreUint8(&o.CR.Reg, volatile.LoadUint8(&o.CR.Reg)&^(0x80)|value<<7)
}
func (o *OSC_Type) GetCR_ERCLKEN() uint8 {
	return (volatile.LoadUint8(&o.CR.Reg) & 0x80) >> 7
}

// Inter-Integrated Circuit
type I2C_Type struct {
	A1   volatile.Register8 // 0x0
	F    volatile.Register8 // 0x1
	C1   volatile.Register8 // 0x2
	S    volatile.Register8 // 0x3
	D    volatile.Register8 // 0x4
	C2   volatile.Register8 // 0x5
	FLT  volatile.Register8 // 0x6
	RA   volatile.Register8 // 0x7
	SMB  volatile.Register8 // 0x8
	A2   volatile.Register8 // 0x9
	SLTH volatile.Register8 // 0xA
	SLTL volatile.Register8 // 0xB
}

// I2C.A1: I2C Address Register 1
func (o *I2C_Type) SetA1_AD(value uint8) {
	volatile.StoreUint8(&o.A1.Reg, volatile.LoadUint8(&o.A1.Reg)&^(0xfe)|value<<1)
}
func (o *I2C_Type) GetA1_AD() uint8 {
	return (volatile.LoadUint8(&o.A1.Reg) & 0xfe) >> 1
}

// I2C.F: I2C Frequency Divider register
func (o *I2C_Type) SetF_ICR(value uint8) {
	volatile.StoreUint8(&o.F.Reg, volatile.LoadUint8(&o.F.Reg)&^(0x3f)|value)
}
func (o *I2C_Type) GetF_ICR() uint8 {
	return volatile.LoadUint8(&o.F.Reg) & 0x3f
}
func (o *I2C_Type) SetF_MULT(value uint8) {
	volatile.StoreUint8(&o.F.Reg, volatile.LoadUint8(&o.F.Reg)&^(0xc0)|value<<6)
}
func (o *I2C_Type) GetF_MULT() uint8 {
	return (volatile.LoadUint8(&o.F.Reg) & 0xc0) >> 6
}

// I2C.C1: I2C Control Register 1
func (o *I2C_Type) SetC1_DMAEN(value uint8) {
	volatile.StoreUint8(&o.C1.Reg, volatile.LoadUint8(&o.C1.Reg)&^(0x1)|value)
}
func (o *I2C_Type) GetC1_DMAEN() uint8 {
	return volatile.LoadUint8(&o.C1.Reg) & 0x1
}
func (o *I2C_Type) SetC1_WUEN(value uint8) {
	volatile.StoreUint8(&o.C1.Reg, volatile.LoadUint8(&o.C1.Reg)&^(0x2)|value<<1)
}
func (o *I2C_Type) GetC1_WUEN() uint8 {
	return (volatile.LoadUint8(&o.C1.Reg) & 0x2) >> 1
}
func (o *I2C_Type) SetC1_RSTA(value uint8) {
	volatile.StoreUint8(&o.C1.Reg, volatile.LoadUint8(&o.C1.Reg)&^(0x4)|value<<2)
}
func (o *I2C_Type) GetC1_RSTA() uint8 {
	return (volatile.LoadUint8(&o.C1.Reg) & 0x4) >> 2
}
func (o *I2C_Type) SetC1_TXAK(value uint8) {
	volatile.StoreUint8(&o.C1.Reg, volatile.LoadUint8(&o.C1.Reg)&^(0x8)|value<<3)
}
func (o *I2C_Type) GetC1_TXAK() uint8 {
	return (volatile.LoadUint8(&o.C1.Reg) & 0x8) >> 3
}
func (o *I2C_Type) SetC1_TX(value uint8) {
	volatile.StoreUint8(&o.C1.Reg, volatile.LoadUint8(&o.C1.Reg)&^(0x10)|value<<4)
}
func (o *I2C_Type) GetC1_TX() uint8 {
	return (volatile.LoadUint8(&o.C1.Reg) & 0x10) >> 4
}
func (o *I2C_Type) SetC1_MST(value uint8) {
	volatile.StoreUint8(&o.C1.Reg, volatile.LoadUint8(&o.C1.Reg)&^(0x20)|value<<5)
}
func (o *I2C_Type) GetC1_MST() uint8 {
	return (volatile.LoadUint8(&o.C1.Reg) & 0x20) >> 5
}
func (o *I2C_Type) SetC1_IICIE(value uint8) {
	volatile.StoreUint8(&o.C1.Reg, volatile.LoadUint8(&o.C1.Reg)&^(0x40)|value<<6)
}
func (o *I2C_Type) GetC1_IICIE() uint8 {
	return (volatile.LoadUint8(&o.C1.Reg) & 0x40) >> 6
}
func (o *I2C_Type) SetC1_IICEN(value uint8) {
	volatile.StoreUint8(&o.C1.Reg, volatile.LoadUint8(&o.C1.Reg)&^(0x80)|value<<7)
}
func (o *I2C_Type) GetC1_IICEN() uint8 {
	return (volatile.LoadUint8(&o.C1.Reg) & 0x80) >> 7
}

// I2C.S: I2C Status register
func (o *I2C_Type) SetS_RXAK(value uint8) {
	volatile.StoreUint8(&o.S.Reg, volatile.LoadUint8(&o.S.Reg)&^(0x1)|value)
}
func (o *I2C_Type) GetS_RXAK() uint8 {
	return volatile.LoadUint8(&o.S.Reg) & 0x1
}
func (o *I2C_Type) SetS_IICIF(value uint8) {
	volatile.StoreUint8(&o.S.Reg, volatile.LoadUint8(&o.S.Reg)&^(0x2)|value<<1)
}
func (o *I2C_Type) GetS_IICIF() uint8 {
	return (volatile.LoadUint8(&o.S.Reg) & 0x2) >> 1
}
func (o *I2C_Type) SetS_SRW(value uint8) {
	volatile.StoreUint8(&o.S.Reg, volatile.LoadUint8(&o.S.Reg)&^(0x4)|value<<2)
}
func (o *I2C_Type) GetS_SRW() uint8 {
	return (volatile.LoadUint8(&o.S.Reg) & 0x4) >> 2
}
func (o *I2C_Type) SetS_RAM(value uint8) {
	volatile.StoreUint8(&o.S.Reg, volatile.LoadUint8(&o.S.Reg)&^(0x8)|value<<3)
}
func (o *I2C_Type) GetS_RAM() uint8 {
	return (volatile.LoadUint8(&o.S.Reg) & 0x8) >> 3
}
func (o *I2C_Type) SetS_ARBL(value uint8) {
	volatile.StoreUint8(&o.S.Reg, volatile.LoadUint8(&o.S.Reg)&^(0x10)|value<<4)
}
func (o *I2C_Type) GetS_ARBL() uint8 {
	return (volatile.LoadUint8(&o.S.Reg) & 0x10) >> 4
}
func (o *I2C_Type) SetS_BUSY(value uint8) {
	volatile.StoreUint8(&o.S.Reg, volatile.LoadUint8(&o.S.Reg)&^(0x20)|value<<5)
}
func (o *I2C_Type) GetS_BUSY() uint8 {
	return (volatile.LoadUint8(&o.S.Reg) & 0x20) >> 5
}
func (o *I2C_Type) SetS_IAAS(value uint8) {
	volatile.StoreUint8(&o.S.Reg, volatile.LoadUint8(&o.S.Reg)&^(0x40)|value<<6)
}
func (o *I2C_Type) GetS_IAAS() uint8 {
	return (volatile.LoadUint8(&o.S.Reg) & 0x40) >> 6
}
func (o *I2C_Type) SetS_TCF(value uint8) {
	volatile.StoreUint8(&o.S.Reg, volatile.LoadUint8(&o.S.Reg)&^(0x80)|value<<7)
}
func (o *I2C_Type) GetS_TCF() uint8 {
	return (volatile.LoadUint8(&o.S.Reg) & 0x80) >> 7
}

// I2C.D: I2C Data I/O register
func (o *I2C_Type) SetD(value uint8) {
	volatile.StoreUint8(&o.D.Reg, value)
}
func (o *I2C_Type) GetD() uint8 {
	return volatile.LoadUint8(&o.D.Reg)
}

// I2C.C2: I2C Control Register 2
func (o *I2C_Type) SetC2_AD(value uint8) {
	volatile.StoreUint8(&o.C2.Reg, volatile.LoadUint8(&o.C2.Reg)&^(0x7)|value)
}
func (o *I2C_Type) GetC2_AD() uint8 {
	return volatile.LoadUint8(&o.C2.Reg) & 0x7
}
func (o *I2C_Type) SetC2_RMEN(value uint8) {
	volatile.StoreUint8(&o.C2.Reg, volatile.LoadUint8(&o.C2.Reg)&^(0x8)|value<<3)
}
func (o *I2C_Type) GetC2_RMEN() uint8 {
	return (volatile.LoadUint8(&o.C2.Reg) & 0x8) >> 3
}
func (o *I2C_Type) SetC2_SBRC(value uint8) {
	volatile.StoreUint8(&o.C2.Reg, volatile.LoadUint8(&o.C2.Reg)&^(0x10)|value<<4)
}
func (o *I2C_Type) GetC2_SBRC() uint8 {
	return (volatile.LoadUint8(&o.C2.Reg) & 0x10) >> 4
}
func (o *I2C_Type) SetC2_HDRS(value uint8) {
	volatile.StoreUint8(&o.C2.Reg, volatile.LoadUint8(&o.C2.Reg)&^(0x20)|value<<5)
}
func (o *I2C_Type) GetC2_HDRS() uint8 {
	return (volatile.LoadUint8(&o.C2.Reg) & 0x20) >> 5
}
func (o *I2C_Type) SetC2_ADEXT(value uint8) {
	volatile.StoreUint8(&o.C2.Reg, volatile.LoadUint8(&o.C2.Reg)&^(0x40)|value<<6)
}
func (o *I2C_Type) GetC2_ADEXT() uint8 {
	return (volatile.LoadUint8(&o.C2.Reg) & 0x40) >> 6
}
func (o *I2C_Type) SetC2_GCAEN(value uint8) {
	volatile.StoreUint8(&o.C2.Reg, volatile.LoadUint8(&o.C2.Reg)&^(0x80)|value<<7)
}
func (o *I2C_Type) GetC2_GCAEN() uint8 {
	return (volatile.LoadUint8(&o.C2.Reg) & 0x80) >> 7
}

// I2C.FLT: I2C Programmable Input Glitch Filter register
func (o *I2C_Type) SetFLT(value uint8) {
	volatile.StoreUint8(&o.FLT.Reg, volatile.LoadUint8(&o.FLT.Reg)&^(0xf)|value)
}
func (o *I2C_Type) GetFLT() uint8 {
	return volatile.LoadUint8(&o.FLT.Reg) & 0xf
}
func (o *I2C_Type) SetFLT_STARTF(value uint8) {
	volatile.StoreUint8(&o.FLT.Reg, volatile.LoadUint8(&o.FLT.Reg)&^(0x10)|value<<4)
}
func (o *I2C_Type) GetFLT_STARTF() uint8 {
	return (volatile.LoadUint8(&o.FLT.Reg) & 0x10) >> 4
}
func (o *I2C_Type) SetFLT_SSIE(value uint8) {
	volatile.StoreUint8(&o.FLT.Reg, volatile.LoadUint8(&o.FLT.Reg)&^(0x20)|value<<5)
}
func (o *I2C_Type) GetFLT_SSIE() uint8 {
	return (volatile.LoadUint8(&o.FLT.Reg) & 0x20) >> 5
}
func (o *I2C_Type) SetFLT_STOPF(value uint8) {
	volatile.StoreUint8(&o.FLT.Reg, volatile.LoadUint8(&o.FLT.Reg)&^(0x40)|value<<6)
}
func (o *I2C_Type) GetFLT_STOPF() uint8 {
	return (volatile.LoadUint8(&o.FLT.Reg) & 0x40) >> 6
}
func (o *I2C_Type) SetFLT_SHEN(value uint8) {
	volatile.StoreUint8(&o.FLT.Reg, volatile.LoadUint8(&o.FLT.Reg)&^(0x80)|value<<7)
}
func (o *I2C_Type) GetFLT_SHEN() uint8 {
	return (volatile.LoadUint8(&o.FLT.Reg) & 0x80) >> 7
}

// I2C.RA: I2C Range Address register
func (o *I2C_Type) SetRA_RAD(value uint8) {
	volatile.StoreUint8(&o.RA.Reg, volatile.LoadUint8(&o.RA.Reg)&^(0xfe)|value<<1)
}
func (o *I2C_Type) GetRA_RAD() uint8 {
	return (volatile.LoadUint8(&o.RA.Reg) & 0xfe) >> 1
}

// I2C.SMB: I2C SMBus Control and Status register
func (o *I2C_Type) SetSMB_SHTF2IE(value uint8) {
	volatile.StoreUint8(&o.SMB.Reg, volatile.LoadUint8(&o.SMB.Reg)&^(0x1)|value)
}
func (o *I2C_Type) GetSMB_SHTF2IE() uint8 {
	return volatile.LoadUint8(&o.SMB.Reg) & 0x1
}
func (o *I2C_Type) SetSMB_SHTF2(value uint8) {
	volatile.StoreUint8(&o.SMB.Reg, volatile.LoadUint8(&o.SMB.Reg)&^(0x2)|value<<1)
}
func (o *I2C_Type) GetSMB_SHTF2() uint8 {
	return (volatile.LoadUint8(&o.SMB.Reg) & 0x2) >> 1
}
func (o *I2C_Type) SetSMB_SHTF1(value uint8) {
	volatile.StoreUint8(&o.SMB.Reg, volatile.LoadUint8(&o.SMB.Reg)&^(0x4)|value<<2)
}
func (o *I2C_Type) GetSMB_SHTF1() uint8 {
	return (volatile.LoadUint8(&o.SMB.Reg) & 0x4) >> 2
}
func (o *I2C_Type) SetSMB_SLTF(value uint8) {
	volatile.StoreUint8(&o.SMB.Reg, volatile.LoadUint8(&o.SMB.Reg)&^(0x8)|value<<3)
}
func (o *I2C_Type) GetSMB_SLTF() uint8 {
	return (volatile.LoadUint8(&o.SMB.Reg) & 0x8) >> 3
}
func (o *I2C_Type) SetSMB_TCKSEL(value uint8) {
	volatile.StoreUint8(&o.SMB.Reg, volatile.LoadUint8(&o.SMB.Reg)&^(0x10)|value<<4)
}
func (o *I2C_Type) GetSMB_TCKSEL() uint8 {
	return (volatile.LoadUint8(&o.SMB.Reg) & 0x10) >> 4
}
func (o *I2C_Type) SetSMB_SIICAEN(value uint8) {
	volatile.StoreUint8(&o.SMB.Reg, volatile.LoadUint8(&o.SMB.Reg)&^(0x20)|value<<5)
}
func (o *I2C_Type) GetSMB_SIICAEN() uint8 {
	return (volatile.LoadUint8(&o.SMB.Reg) & 0x20) >> 5
}
func (o *I2C_Type) SetSMB_ALERTEN(value uint8) {
	volatile.StoreUint8(&o.SMB.Reg, volatile.LoadUint8(&o.SMB.Reg)&^(0x40)|value<<6)
}
func (o *I2C_Type) GetSMB_ALERTEN() uint8 {
	return (volatile.LoadUint8(&o.SMB.Reg) & 0x40) >> 6
}
func (o *I2C_Type) SetSMB_FACK(value uint8) {
	volatile.StoreUint8(&o.SMB.Reg, volatile.LoadUint8(&o.SMB.Reg)&^(0x80)|value<<7)
}
func (o *I2C_Type) GetSMB_FACK() uint8 {
	return (volatile.LoadUint8(&o.SMB.Reg) & 0x80) >> 7
}

// I2C.A2: I2C Address Register 2
func (o *I2C_Type) SetA2_SAD(value uint8) {
	volatile.StoreUint8(&o.A2.Reg, volatile.LoadUint8(&o.A2.Reg)&^(0xfe)|value<<1)
}
func (o *I2C_Type) GetA2_SAD() uint8 {
	return (volatile.LoadUint8(&o.A2.Reg) & 0xfe) >> 1
}

// I2C.SLTH: I2C SCL Low Timeout Register High
func (o *I2C_Type) SetSLTH(value uint8) {
	volatile.StoreUint8(&o.SLTH.Reg, value)
}
func (o *I2C_Type) GetSLTH() uint8 {
	return volatile.LoadUint8(&o.SLTH.Reg)
}

// I2C.SLTL: I2C SCL Low Timeout Register Low
func (o *I2C_Type) SetSLTL(value uint8) {
	volatile.StoreUint8(&o.SLTL.Reg, value)
}
func (o *I2C_Type) GetSLTL() uint8 {
	return volatile.LoadUint8(&o.SLTL.Reg)
}

// Serial Communication Interface
type UART_Type struct {
	BDH      volatile.Register8 // 0x0
	BDL      volatile.Register8 // 0x1
	C1       volatile.Register8 // 0x2
	C2       volatile.Register8 // 0x3
	S1       volatile.Register8 // 0x4
	S2       volatile.Register8 // 0x5
	C3       volatile.Register8 // 0x6
	D        volatile.Register8 // 0x7
	MA1      volatile.Register8 // 0x8
	MA2      volatile.Register8 // 0x9
	C4       volatile.Register8 // 0xA
	C5       volatile.Register8 // 0xB
	ED       volatile.Register8 // 0xC
	MODEM    volatile.Register8 // 0xD
	IR       volatile.Register8 // 0xE
	_        byte
	PFIFO    volatile.Register8 // 0x10
	CFIFO    volatile.Register8 // 0x11
	SFIFO    volatile.Register8 // 0x12
	TWFIFO   volatile.Register8 // 0x13
	TCFIFO   volatile.Register8 // 0x14
	RWFIFO   volatile.Register8 // 0x15
	RCFIFO   volatile.Register8 // 0x16
	_        byte
	C7816    volatile.Register8 // 0x18
	IE7816   volatile.Register8 // 0x19
	IS7816   volatile.Register8 // 0x1A
	WP7816T0 volatile.Register8 // 0x1B
	WN7816   volatile.Register8 // 0x1C
	WF7816   volatile.Register8 // 0x1D
	ET7816   volatile.Register8 // 0x1E
	TL7816   volatile.Register8 // 0x1F
}

// UART.BDH: UART Baud Rate Registers: High
func (o *UART_Type) SetBDH_SBR(value uint8) {
	volatile.StoreUint8(&o.BDH.Reg, volatile.LoadUint8(&o.BDH.Reg)&^(0x1f)|value)
}
func (o *UART_Type) GetBDH_SBR() uint8 {
	return volatile.LoadUint8(&o.BDH.Reg) & 0x1f
}
func (o *UART_Type) SetBDH_SBNS(value uint8) {
	volatile.StoreUint8(&o.BDH.Reg, volatile.LoadUint8(&o.BDH.Reg)&^(0x20)|value<<5)
}
func (o *UART_Type) GetBDH_SBNS() uint8 {
	return (volatile.LoadUint8(&o.BDH.Reg) & 0x20) >> 5
}
func (o *UART_Type) SetBDH_RXEDGIE(value uint8) {
	volatile.StoreUint8(&o.BDH.Reg, volatile.LoadUint8(&o.BDH.Reg)&^(0x40)|value<<6)
}
func (o *UART_Type) GetBDH_RXEDGIE() uint8 {
	return (volatile.LoadUint8(&o.BDH.Reg) & 0x40) >> 6
}
func (o *UART_Type) SetBDH_LBKDIE(value uint8) {
	volatile.StoreUint8(&o.BDH.Reg, volatile.LoadUint8(&o.BDH.Reg)&^(0x80)|value<<7)
}
func (o *UART_Type) GetBDH_LBKDIE() uint8 {
	return (volatile.LoadUint8(&o.BDH.Reg) & 0x80) >> 7
}

// UART.BDL: UART Baud Rate Registers: Low
func (o *UART_Type) SetBDL(value uint8) {
	volatile.StoreUint8(&o.BDL.Reg, value)
}
func (o *UART_Type) GetBDL() uint8 {
	return volatile.LoadUint8(&o.BDL.Reg)
}

// UART.C1: UART Control Register 1
func (o *UART_Type) SetC1_PT(value uint8) {
	volatile.StoreUint8(&o.C1.Reg, volatile.LoadUint8(&o.C1.Reg)&^(0x1)|value)
}
func (o *UART_Type) GetC1_PT() uint8 {
	return volatile.LoadUint8(&o.C1.Reg) & 0x1
}
func (o *UART_Type) SetC1_PE(value uint8) {
	volatile.StoreUint8(&o.C1.Reg, volatile.LoadUint8(&o.C1.Reg)&^(0x2)|value<<1)
}
func (o *UART_Type) GetC1_PE() uint8 {
	return (volatile.LoadUint8(&o.C1.Reg) & 0x2) >> 1
}
func (o *UART_Type) SetC1_ILT(value uint8) {
	volatile.StoreUint8(&o.C1.Reg, volatile.LoadUint8(&o.C1.Reg)&^(0x4)|value<<2)
}
func (o *UART_Type) GetC1_ILT() uint8 {
	return (volatile.LoadUint8(&o.C1.Reg) & 0x4) >> 2
}
func (o *UART_Type) SetC1_WAKE(value uint8) {
	volatile.StoreUint8(&o.C1.Reg, volatile.LoadUint8(&o.C1.Reg)&^(0x8)|value<<3)
}
func (o *UART_Type) GetC1_WAKE() uint8 {
	return (volatile.LoadUint8(&o.C1.Reg) & 0x8) >> 3
}
func (o *UART_Type) SetC1_M(value uint8) {
	volatile.StoreUint8(&o.C1.Reg, volatile.LoadUint8(&o.C1.Reg)&^(0x10)|value<<4)
}
func (o *UART_Type) GetC1_M() uint8 {
	return (volatile.LoadUint8(&o.C1.Reg) & 0x10) >> 4
}
func (o *UART_Type) SetC1_RSRC(value uint8) {
	volatile.StoreUint8(&o.C1.Reg, volatile.LoadUint8(&o.C1.Reg)&^(0x20)|value<<5)
}
func (o *UART_Type) GetC1_RSRC() uint8 {
	return (volatile.LoadUint8(&o.C1.Reg) & 0x20) >> 5
}
func (o *UART_Type) SetC1_UARTSWAI(value uint8) {
	volatile.StoreUint8(&o.C1.Reg, volatile.LoadUint8(&o.C1.Reg)&^(0x40)|value<<6)
}
func (o *UART_Type) GetC1_UARTSWAI() uint8 {
	return (volatile.LoadUint8(&o.C1.Reg) & 0x40) >> 6
}
func (o *UART_Type) SetC1_LOOPS(value uint8) {
	volatile.StoreUint8(&o.C1.Reg, volatile.LoadUint8(&o.C1.Reg)&^(0x80)|value<<7)
}
func (o *UART_Type) GetC1_LOOPS() uint8 {
	return (volatile.LoadUint8(&o.C1.Reg) & 0x80) >> 7
}

// UART.C2: UART Control Register 2
func (o *UART_Type) SetC2_SBK(value uint8) {
	volatile.StoreUint8(&o.C2.Reg, volatile.LoadUint8(&o.C2.Reg)&^(0x1)|value)
}
func (o *UART_Type) GetC2_SBK() uint8 {
	return volatile.LoadUint8(&o.C2.Reg) & 0x1
}
func (o *UART_Type) SetC2_RWU(value uint8) {
	volatile.StoreUint8(&o.C2.Reg, volatile.LoadUint8(&o.C2.Reg)&^(0x2)|value<<1)
}
func (o *UART_Type) GetC2_RWU() uint8 {
	return (volatile.LoadUint8(&o.C2.Reg) & 0x2) >> 1
}
func (o *UART_Type) SetC2_RE(value uint8) {
	volatile.StoreUint8(&o.C2.Reg, volatile.LoadUint8(&o.C2.Reg)&^(0x4)|value<<2)
}
func (o *UART_Type) GetC2_RE() uint8 {
	return (volatile.LoadUint8(&o.C2.Reg) & 0x4) >> 2
}
func (o *UART_Type) SetC2_TE(value uint8) {
	volatile.StoreUint8(&o.C2.Reg, volatile.LoadUint8(&o.C2.Reg)&^(0x8)|value<<3)
}
func (o *UART_Type) GetC2_TE() uint8 {
	return (volatile.LoadUint8(&o.C2.Reg) & 0x8) >> 3
}
func (o *UART_Type) SetC2_ILIE(value uint8) {
	volatile.StoreUint8(&o.C2.Reg, volatile.LoadUint8(&o.C2.Reg)&^(0x10)|value<<4)
}
func (o *UART_Type) GetC2_ILIE() uint8 {
	return (volatile.LoadUint8(&o.C2.Reg) & 0x10) >> 4
}
func (o *UART_Type) SetC2_RIE(value uint8) {
	volatile.StoreUint8(&o.C2.Reg, volatile.LoadUint8(&o.C2.Reg)&^(0x20)|value<<5)
}
func (o *UART_Type) GetC2_RIE() uint8 {
	return (volatile.LoadUint8(&o.C2.Reg) & 0x20) >> 5
}
func (o *UART_Type) SetC2_TCIE(value uint8) {
	volatile.StoreUint8(&o.C2.Reg, volatile.LoadUint8(&o.C2.Reg)&^(0x40)|value<<6)
}
func (o *UART_Type) GetC2_TCIE() uint8 {
	return (volatile.LoadUint8(&o.C2.Reg) & 0x40) >> 6
}
func (o *UART_Type) SetC2_TIE(value uint8) {
	volatile.StoreUint8(&o.C2.Reg, volatile.LoadUint8(&o.C2.Reg)&^(0x80)|value<<7)
}
func (o *UART_Type) GetC2_TIE() uint8 {
	return (volatile.LoadUint8(&o.C2.Reg) & 0x80) >> 7
}

// UART.S1: UART Status Register 1
func (o *UART_Type) SetS1_PF(value uint8) {
	volatile.StoreUint8(&o.S1.Reg, volatile.LoadUint8(&o.S1.Reg)&^(0x1)|value)
}
func (o *UART_Type) GetS1_PF() uint8 {
	return volatile.LoadUint8(&o.S1.Reg) & 0x1
}
func (o *UART_Type) SetS1_FE(value uint8) {
	volatile.StoreUint8(&o.S1.Reg, volatile.LoadUint8(&o.S1.Reg)&^(0x2)|value<<1)
}
func (o *UART_Type) GetS1_FE() uint8 {
	return (volatile.LoadUint8(&o.S1.Reg) & 0x2) >> 1
}
func (o *UART_Type) SetS1_NF(value uint8) {
	volatile.StoreUint8(&o.S1.Reg, volatile.LoadUint8(&o.S1.Reg)&^(0x4)|value<<2)
}
func (o *UART_Type) GetS1_NF() uint8 {
	return (volatile.LoadUint8(&o.S1.Reg) & 0x4) >> 2
}
func (o *UART_Type) SetS1_OR(value uint8) {
	volatile.StoreUint8(&o.S1.Reg, volatile.LoadUint8(&o.S1.Reg)&^(0x8)|value<<3)
}
func (o *UART_Type) GetS1_OR() uint8 {
	return (volatile.LoadUint8(&o.S1.Reg) & 0x8) >> 3
}
func (o *UART_Type) SetS1_IDLE(value uint8) {
	volatile.StoreUint8(&o.S1.Reg, volatile.LoadUint8(&o.S1.Reg)&^(0x10)|value<<4)
}
func (o *UART_Type) GetS1_IDLE() uint8 {
	return (volatile.LoadUint8(&o.S1.Reg) & 0x10) >> 4
}
func (o *UART_Type) SetS1_RDRF(value uint8) {
	volatile.StoreUint8(&o.S1.Reg, volatile.LoadUint8(&o.S1.Reg)&^(0x20)|value<<5)
}
func (o *UART_Type) GetS1_RDRF() uint8 {
	return (volatile.LoadUint8(&o.S1.Reg) & 0x20) >> 5
}
func (o *UART_Type) SetS1_TC(value uint8) {
	volatile.StoreUint8(&o.S1.Reg, volatile.LoadUint8(&o.S1.Reg)&^(0x40)|value<<6)
}
func (o *UART_Type) GetS1_TC() uint8 {
	return (volatile.LoadUint8(&o.S1.Reg) & 0x40) >> 6
}
func (o *UART_Type) SetS1_TDRE(value uint8) {
	volatile.StoreUint8(&o.S1.Reg, volatile.LoadUint8(&o.S1.Reg)&^(0x80)|value<<7)
}
func (o *UART_Type) GetS1_TDRE() uint8 {
	return (volatile.LoadUint8(&o.S1.Reg) & 0x80) >> 7
}

// UART.S2: UART Status Register 2
func (o *UART_Type) SetS2_RAF(value uint8) {
	volatile.StoreUint8(&o.S2.Reg, volatile.LoadUint8(&o.S2.Reg)&^(0x1)|value)
}
func (o *UART_Type) GetS2_RAF() uint8 {
	return volatile.LoadUint8(&o.S2.Reg) & 0x1
}
func (o *UART_Type) SetS2_LBKDE(value uint8) {
	volatile.StoreUint8(&o.S2.Reg, volatile.LoadUint8(&o.S2.Reg)&^(0x2)|value<<1)
}
func (o *UART_Type) GetS2_LBKDE() uint8 {
	return (volatile.LoadUint8(&o.S2.Reg) & 0x2) >> 1
}
func (o *UART_Type) SetS2_BRK13(value uint8) {
	volatile.StoreUint8(&o.S2.Reg, volatile.LoadUint8(&o.S2.Reg)&^(0x4)|value<<2)
}
func (o *UART_Type) GetS2_BRK13() uint8 {
	return (volatile.LoadUint8(&o.S2.Reg) & 0x4) >> 2
}
func (o *UART_Type) SetS2_RWUID(value uint8) {
	volatile.StoreUint8(&o.S2.Reg, volatile.LoadUint8(&o.S2.Reg)&^(0x8)|value<<3)
}
func (o *UART_Type) GetS2_RWUID() uint8 {
	return (volatile.LoadUint8(&o.S2.Reg) & 0x8) >> 3
}
func (o *UART_Type) SetS2_RXINV(value uint8) {
	volatile.StoreUint8(&o.S2.Reg, volatile.LoadUint8(&o.S2.Reg)&^(0x10)|value<<4)
}
func (o *UART_Type) GetS2_RXINV() uint8 {
	return (volatile.LoadUint8(&o.S2.Reg) & 0x10) >> 4
}
func (o *UART_Type) SetS2_MSBF(value uint8) {
	volatile.StoreUint8(&o.S2.Reg, volatile.LoadUint8(&o.S2.Reg)&^(0x20)|value<<5)
}
func (o *UART_Type) GetS2_MSBF() uint8 {
	return (volatile.LoadUint8(&o.S2.Reg) & 0x20) >> 5
}
func (o *UART_Type) SetS2_RXEDGIF(value uint8) {
	volatile.StoreUint8(&o.S2.Reg, volatile.LoadUint8(&o.S2.Reg)&^(0x40)|value<<6)
}
func (o *UART_Type) GetS2_RXEDGIF() uint8 {
	return (volatile.LoadUint8(&o.S2.Reg) & 0x40) >> 6
}
func (o *UART_Type) SetS2_LBKDIF(value uint8) {
	volatile.StoreUint8(&o.S2.Reg, volatile.LoadUint8(&o.S2.Reg)&^(0x80)|value<<7)
}
func (o *UART_Type) GetS2_LBKDIF() uint8 {
	return (volatile.LoadUint8(&o.S2.Reg) & 0x80) >> 7
}

// UART.C3: UART Control Register 3
func (o *UART_Type) SetC3_PEIE(value uint8) {
	volatile.StoreUint8(&o.C3.Reg, volatile.LoadUint8(&o.C3.Reg)&^(0x1)|value)
}
func (o *UART_Type) GetC3_PEIE() uint8 {
	return volatile.LoadUint8(&o.C3.Reg) & 0x1
}
func (o *UART_Type) SetC3_FEIE(value uint8) {
	volatile.StoreUint8(&o.C3.Reg, volatile.LoadUint8(&o.C3.Reg)&^(0x2)|value<<1)
}
func (o *UART_Type) GetC3_FEIE() uint8 {
	return (volatile.LoadUint8(&o.C3.Reg) & 0x2) >> 1
}
func (o *UART_Type) SetC3_NEIE(value uint8) {
	volatile.StoreUint8(&o.C3.Reg, volatile.LoadUint8(&o.C3.Reg)&^(0x4)|value<<2)
}
func (o *UART_Type) GetC3_NEIE() uint8 {
	return (volatile.LoadUint8(&o.C3.Reg) & 0x4) >> 2
}
func (o *UART_Type) SetC3_ORIE(value uint8) {
	volatile.StoreUint8(&o.C3.Reg, volatile.LoadUint8(&o.C3.Reg)&^(0x8)|value<<3)
}
func (o *UART_Type) GetC3_ORIE() uint8 {
	return (volatile.LoadUint8(&o.C3.Reg) & 0x8) >> 3
}
func (o *UART_Type) SetC3_TXINV(value uint8) {
	volatile.StoreUint8(&o.C3.Reg, volatile.LoadUint8(&o.C3.Reg)&^(0x10)|value<<4)
}
func (o *UART_Type) GetC3_TXINV() uint8 {
	return (volatile.LoadUint8(&o.C3.Reg) & 0x10) >> 4
}
func (o *UART_Type) SetC3_TXDIR(value uint8) {
	volatile.StoreUint8(&o.C3.Reg, volatile.LoadUint8(&o.C3.Reg)&^(0x20)|value<<5)
}
func (o *UART_Type) GetC3_TXDIR() uint8 {
	return (volatile.LoadUint8(&o.C3.Reg) & 0x20) >> 5
}
func (o *UART_Type) SetC3_T8(value uint8) {
	volatile.StoreUint8(&o.C3.Reg, volatile.LoadUint8(&o.C3.Reg)&^(0x40)|value<<6)
}
func (o *UART_Type) GetC3_T8() uint8 {
	return (volatile.LoadUint8(&o.C3.Reg) & 0x40) >> 6
}
func (o *UART_Type) SetC3_R8(value uint8) {
	volatile.StoreUint8(&o.C3.Reg, volatile.LoadUint8(&o.C3.Reg)&^(0x80)|value<<7)
}
func (o *UART_Type) GetC3_R8() uint8 {
	return (volatile.LoadUint8(&o.C3.Reg) & 0x80) >> 7
}

// UART.D: UART Data Register
func (o *UART_Type) SetD(value uint8) {
	volatile.StoreUint8(&o.D.Reg, value)
}
func (o *UART_Type) GetD() uint8 {
	return volatile.LoadUint8(&o.D.Reg)
}

// UART.MA1: UART Match Address Registers 1
func (o *UART_Type) SetMA1(value uint8) {
	volatile.StoreUint8(&o.MA1.Reg, value)
}
func (o *UART_Type) GetMA1() uint8 {
	return volatile.LoadUint8(&o.MA1.Reg)
}

// UART.MA2: UART Match Address Registers 2
func (o *UART_Type) SetMA2(value uint8) {
	volatile.StoreUint8(&o.MA2.Reg, value)
}
func (o *UART_Type) GetMA2() uint8 {
	return volatile.LoadUint8(&o.MA2.Reg)
}

// UART.C4: UART Control Register 4
func (o *UART_Type) SetC4_BRFA(value uint8) {
	volatile.StoreUint8(&o.C4.Reg, volatile.LoadUint8(&o.C4.Reg)&^(0x1f)|value)
}
func (o *UART_Type) GetC4_BRFA() uint8 {
	return volatile.LoadUint8(&o.C4.Reg) & 0x1f
}
func (o *UART_Type) SetC4_M10(value uint8) {
	volatile.StoreUint8(&o.C4.Reg, volatile.LoadUint8(&o.C4.Reg)&^(0x20)|value<<5)
}
func (o *UART_Type) GetC4_M10() uint8 {
	return (volatile.LoadUint8(&o.C4.Reg) & 0x20) >> 5
}
func (o *UART_Type) SetC4_MAEN2(value uint8) {
	volatile.StoreUint8(&o.C4.Reg, volatile.LoadUint8(&o.C4.Reg)&^(0x40)|value<<6)
}
func (o *UART_Type) GetC4_MAEN2() uint8 {
	return (volatile.LoadUint8(&o.C4.Reg) & 0x40) >> 6
}
func (o *UART_Type) SetC4_MAEN1(value uint8) {
	volatile.StoreUint8(&o.C4.Reg, volatile.LoadUint8(&o.C4.Reg)&^(0x80)|value<<7)
}
func (o *UART_Type) GetC4_MAEN1() uint8 {
	return (volatile.LoadUint8(&o.C4.Reg) & 0x80) >> 7
}

// UART.C5: UART Control Register 5
func (o *UART_Type) SetC5_LBKDDMAS(value uint8) {
	volatile.StoreUint8(&o.C5.Reg, volatile.LoadUint8(&o.C5.Reg)&^(0x8)|value<<3)
}
func (o *UART_Type) GetC5_LBKDDMAS() uint8 {
	return (volatile.LoadUint8(&o.C5.Reg) & 0x8) >> 3
}
func (o *UART_Type) SetC5_ILDMAS(value uint8) {
	volatile.StoreUint8(&o.C5.Reg, volatile.LoadUint8(&o.C5.Reg)&^(0x10)|value<<4)
}
func (o *UART_Type) GetC5_ILDMAS() uint8 {
	return (volatile.LoadUint8(&o.C5.Reg) & 0x10) >> 4
}
func (o *UART_Type) SetC5_RDMAS(value uint8) {
	volatile.StoreUint8(&o.C5.Reg, volatile.LoadUint8(&o.C5.Reg)&^(0x20)|value<<5)
}
func (o *UART_Type) GetC5_RDMAS() uint8 {
	return (volatile.LoadUint8(&o.C5.Reg) & 0x20) >> 5
}
func (o *UART_Type) SetC5_TCDMAS(value uint8) {
	volatile.StoreUint8(&o.C5.Reg, volatile.LoadUint8(&o.C5.Reg)&^(0x40)|value<<6)
}
func (o *UART_Type) GetC5_TCDMAS() uint8 {
	return (volatile.LoadUint8(&o.C5.Reg) & 0x40) >> 6
}
func (o *UART_Type) SetC5_TDMAS(value uint8) {
	volatile.StoreUint8(&o.C5.Reg, volatile.LoadUint8(&o.C5.Reg)&^(0x80)|value<<7)
}
func (o *UART_Type) GetC5_TDMAS() uint8 {
	return (volatile.LoadUint8(&o.C5.Reg) & 0x80) >> 7
}

// UART.ED: UART Extended Data Register
func (o *UART_Type) SetED_PARITYE(value uint8) {
	volatile.StoreUint8(&o.ED.Reg, volatile.LoadUint8(&o.ED.Reg)&^(0x40)|value<<6)
}
func (o *UART_Type) GetED_PARITYE() uint8 {
	return (volatile.LoadUint8(&o.ED.Reg) & 0x40) >> 6
}
func (o *UART_Type) SetED_NOISY(value uint8) {
	volatile.StoreUint8(&o.ED.Reg, volatile.LoadUint8(&o.ED.Reg)&^(0x80)|value<<7)
}
func (o *UART_Type) GetED_NOISY() uint8 {
	return (volatile.LoadUint8(&o.ED.Reg) & 0x80) >> 7
}

// UART.MODEM: UART Modem Register
func (o *UART_Type) SetMODEM_TXCTSE(value uint8) {
	volatile.StoreUint8(&o.MODEM.Reg, volatile.LoadUint8(&o.MODEM.Reg)&^(0x1)|value)
}
func (o *UART_Type) GetMODEM_TXCTSE() uint8 {
	return volatile.LoadUint8(&o.MODEM.Reg) & 0x1
}
func (o *UART_Type) SetMODEM_TXRTSE(value uint8) {
	volatile.StoreUint8(&o.MODEM.Reg, volatile.LoadUint8(&o.MODEM.Reg)&^(0x2)|value<<1)
}
func (o *UART_Type) GetMODEM_TXRTSE() uint8 {
	return (volatile.LoadUint8(&o.MODEM.Reg) & 0x2) >> 1
}
func (o *UART_Type) SetMODEM_TXRTSPOL(value uint8) {
	volatile.StoreUint8(&o.MODEM.Reg, volatile.LoadUint8(&o.MODEM.Reg)&^(0x4)|value<<2)
}
func (o *UART_Type) GetMODEM_TXRTSPOL() uint8 {
	return (volatile.LoadUint8(&o.MODEM.Reg) & 0x4) >> 2
}
func (o *UART_Type) SetMODEM_RXRTSE(value uint8) {
	volatile.StoreUint8(&o.MODEM.Reg, volatile.LoadUint8(&o.MODEM.Reg)&^(0x8)|value<<3)
}
func (o *UART_Type) GetMODEM_RXRTSE() uint8 {
	return (volatile.LoadUint8(&o.MODEM.Reg) & 0x8) >> 3
}

// UART.IR: UART Infrared Register
func (o *UART_Type) SetIR_TNP(value uint8) {
	volatile.StoreUint8(&o.IR.Reg, volatile.LoadUint8(&o.IR.Reg)&^(0x3)|value)
}
func (o *UART_Type) GetIR_TNP() uint8 {
	return volatile.LoadUint8(&o.IR.Reg) & 0x3
}
func (o *UART_Type) SetIR_IREN(value uint8) {
	volatile.StoreUint8(&o.IR.Reg, volatile.LoadUint8(&o.IR.Reg)&^(0x4)|value<<2)
}
func (o *UART_Type) GetIR_IREN() uint8 {
	return (volatile.LoadUint8(&o.IR.Reg) & 0x4) >> 2
}

// UART.PFIFO: UART FIFO Parameters
func (o *UART_Type) SetPFIFO_RXFIFOSIZE(value uint8) {
	volatile.StoreUint8(&o.PFIFO.Reg, volatile.LoadUint8(&o.PFIFO.Reg)&^(0x7)|value)
}
func (o *UART_Type) GetPFIFO_RXFIFOSIZE() uint8 {
	return volatile.LoadUint8(&o.PFIFO.Reg) & 0x7
}
func (o *UART_Type) SetPFIFO_RXFE(value uint8) {
	volatile.StoreUint8(&o.PFIFO.Reg, volatile.LoadUint8(&o.PFIFO.Reg)&^(0x8)|value<<3)
}
func (o *UART_Type) GetPFIFO_RXFE() uint8 {
	return (volatile.LoadUint8(&o.PFIFO.Reg) & 0x8) >> 3
}
func (o *UART_Type) SetPFIFO_TXFIFOSIZE(value uint8) {
	volatile.StoreUint8(&o.PFIFO.Reg, volatile.LoadUint8(&o.PFIFO.Reg)&^(0x70)|value<<4)
}
func (o *UART_Type) GetPFIFO_TXFIFOSIZE() uint8 {
	return (volatile.LoadUint8(&o.PFIFO.Reg) & 0x70) >> 4
}
func (o *UART_Type) SetPFIFO_TXFE(value uint8) {
	volatile.StoreUint8(&o.PFIFO.Reg, volatile.LoadUint8(&o.PFIFO.Reg)&^(0x80)|value<<7)
}
func (o *UART_Type) GetPFIFO_TXFE() uint8 {
	return (volatile.LoadUint8(&o.PFIFO.Reg) & 0x80) >> 7
}

// UART.CFIFO: UART FIFO Control Register
func (o *UART_Type) SetCFIFO_RXUFE(value uint8) {
	volatile.StoreUint8(&o.CFIFO.Reg, volatile.LoadUint8(&o.CFIFO.Reg)&^(0x1)|value)
}
func (o *UART_Type) GetCFIFO_RXUFE() uint8 {
	return volatile.LoadUint8(&o.CFIFO.Reg) & 0x1
}
func (o *UART_Type) SetCFIFO_TXOFE(value uint8) {
	volatile.StoreUint8(&o.CFIFO.Reg, volatile.LoadUint8(&o.CFIFO.Reg)&^(0x2)|value<<1)
}
func (o *UART_Type) GetCFIFO_TXOFE() uint8 {
	return (volatile.LoadUint8(&o.CFIFO.Reg) & 0x2) >> 1
}
func (o *UART_Type) SetCFIFO_RXOFE(value uint8) {
	volatile.StoreUint8(&o.CFIFO.Reg, volatile.LoadUint8(&o.CFIFO.Reg)&^(0x4)|value<<2)
}
func (o *UART_Type) GetCFIFO_RXOFE() uint8 {
	return (volatile.LoadUint8(&o.CFIFO.Reg) & 0x4) >> 2
}
func (o *UART_Type) SetCFIFO_RXFLUSH(value uint8) {
	volatile.StoreUint8(&o.CFIFO.Reg, volatile.LoadUint8(&o.CFIFO.Reg)&^(0x40)|value<<6)
}
func (o *UART_Type) GetCFIFO_RXFLUSH() uint8 {
	return (volatile.LoadUint8(&o.CFIFO.Reg) & 0x40) >> 6
}
func (o *UART_Type) SetCFIFO_TXFLUSH(value uint8) {
	volatile.StoreUint8(&o.CFIFO.Reg, volatile.LoadUint8(&o.CFIFO.Reg)&^(0x80)|value<<7)
}
func (o *UART_Type) GetCFIFO_TXFLUSH() uint8 {
	return (volatile.LoadUint8(&o.CFIFO.Reg) & 0x80) >> 7
}

// UART.SFIFO: UART FIFO Status Register
func (o *UART_Type) SetSFIFO_RXUF(value uint8) {
	volatile.StoreUint8(&o.SFIFO.Reg, volatile.LoadUint8(&o.SFIFO.Reg)&^(0x1)|value)
}
func (o *UART_Type) GetSFIFO_RXUF() uint8 {
	return volatile.LoadUint8(&o.SFIFO.Reg) & 0x1
}
func (o *UART_Type) SetSFIFO_TXOF(value uint8) {
	volatile.StoreUint8(&o.SFIFO.Reg, volatile.LoadUint8(&o.SFIFO.Reg)&^(0x2)|value<<1)
}
func (o *UART_Type) GetSFIFO_TXOF() uint8 {
	return (volatile.LoadUint8(&o.SFIFO.Reg) & 0x2) >> 1
}
func (o *UART_Type) SetSFIFO_RXOF(value uint8) {
	volatile.StoreUint8(&o.SFIFO.Reg, volatile.LoadUint8(&o.SFIFO.Reg)&^(0x4)|value<<2)
}
func (o *UART_Type) GetSFIFO_RXOF() uint8 {
	return (volatile.LoadUint8(&o.SFIFO.Reg) & 0x4) >> 2
}
func (o *UART_Type) SetSFIFO_RXEMPT(value uint8) {
	volatile.StoreUint8(&o.SFIFO.Reg, volatile.LoadUint8(&o.SFIFO.Reg)&^(0x40)|value<<6)
}
func (o *UART_Type) GetSFIFO_RXEMPT() uint8 {
	return (volatile.LoadUint8(&o.SFIFO.Reg) & 0x40) >> 6
}
func (o *UART_Type) SetSFIFO_TXEMPT(value uint8) {
	volatile.StoreUint8(&o.SFIFO.Reg, volatile.LoadUint8(&o.SFIFO.Reg)&^(0x80)|value<<7)
}
func (o *UART_Type) GetSFIFO_TXEMPT() uint8 {
	return (volatile.LoadUint8(&o.SFIFO.Reg) & 0x80) >> 7
}

// UART.TWFIFO: UART FIFO Transmit Watermark
func (o *UART_Type) SetTWFIFO(value uint8) {
	volatile.StoreUint8(&o.TWFIFO.Reg, value)
}
func (o *UART_Type) GetTWFIFO() uint8 {
	return volatile.LoadUint8(&o.TWFIFO.Reg)
}

// UART.TCFIFO: UART FIFO Transmit Count
func (o *UART_Type) SetTCFIFO(value uint8) {
	volatile.StoreUint8(&o.TCFIFO.Reg, value)
}
func (o *UART_Type) GetTCFIFO() uint8 {
	return volatile.LoadUint8(&o.TCFIFO.Reg)
}

// UART.RWFIFO: UART FIFO Receive Watermark
func (o *UART_Type) SetRWFIFO(value uint8) {
	volatile.StoreUint8(&o.RWFIFO.Reg, value)
}
func (o *UART_Type) GetRWFIFO() uint8 {
	return volatile.LoadUint8(&o.RWFIFO.Reg)
}

// UART.RCFIFO: UART FIFO Receive Count
func (o *UART_Type) SetRCFIFO(value uint8) {
	volatile.StoreUint8(&o.RCFIFO.Reg, value)
}
func (o *UART_Type) GetRCFIFO() uint8 {
	return volatile.LoadUint8(&o.RCFIFO.Reg)
}

// UART.C7816: UART 7816 Control Register
func (o *UART_Type) SetC7816_ISO_7816E(value uint8) {
	volatile.StoreUint8(&o.C7816.Reg, volatile.LoadUint8(&o.C7816.Reg)&^(0x1)|value)
}
func (o *UART_Type) GetC7816_ISO_7816E() uint8 {
	return volatile.LoadUint8(&o.C7816.Reg) & 0x1
}
func (o *UART_Type) SetC7816_TTYPE(value uint8) {
	volatile.StoreUint8(&o.C7816.Reg, volatile.LoadUint8(&o.C7816.Reg)&^(0x2)|value<<1)
}
func (o *UART_Type) GetC7816_TTYPE() uint8 {
	return (volatile.LoadUint8(&o.C7816.Reg) & 0x2) >> 1
}
func (o *UART_Type) SetC7816_INIT(value uint8) {
	volatile.StoreUint8(&o.C7816.Reg, volatile.LoadUint8(&o.C7816.Reg)&^(0x4)|value<<2)
}
func (o *UART_Type) GetC7816_INIT() uint8 {
	return (volatile.LoadUint8(&o.C7816.Reg) & 0x4) >> 2
}
func (o *UART_Type) SetC7816_ANACK(value uint8) {
	volatile.StoreUint8(&o.C7816.Reg, volatile.LoadUint8(&o.C7816.Reg)&^(0x8)|value<<3)
}
func (o *UART_Type) GetC7816_ANACK() uint8 {
	return (volatile.LoadUint8(&o.C7816.Reg) & 0x8) >> 3
}
func (o *UART_Type) SetC7816_ONACK(value uint8) {
	volatile.StoreUint8(&o.C7816.Reg, volatile.LoadUint8(&o.C7816.Reg)&^(0x10)|value<<4)
}
func (o *UART_Type) GetC7816_ONACK() uint8 {
	return (volatile.LoadUint8(&o.C7816.Reg) & 0x10) >> 4
}

// UART.IE7816: UART 7816 Interrupt Enable Register
func (o *UART_Type) SetIE7816_RXTE(value uint8) {
	volatile.StoreUint8(&o.IE7816.Reg, volatile.LoadUint8(&o.IE7816.Reg)&^(0x1)|value)
}
func (o *UART_Type) GetIE7816_RXTE() uint8 {
	return volatile.LoadUint8(&o.IE7816.Reg) & 0x1
}
func (o *UART_Type) SetIE7816_TXTE(value uint8) {
	volatile.StoreUint8(&o.IE7816.Reg, volatile.LoadUint8(&o.IE7816.Reg)&^(0x2)|value<<1)
}
func (o *UART_Type) GetIE7816_TXTE() uint8 {
	return (volatile.LoadUint8(&o.IE7816.Reg) & 0x2) >> 1
}
func (o *UART_Type) SetIE7816_GTVE(value uint8) {
	volatile.StoreUint8(&o.IE7816.Reg, volatile.LoadUint8(&o.IE7816.Reg)&^(0x4)|value<<2)
}
func (o *UART_Type) GetIE7816_GTVE() uint8 {
	return (volatile.LoadUint8(&o.IE7816.Reg) & 0x4) >> 2
}
func (o *UART_Type) SetIE7816_INITDE(value uint8) {
	volatile.StoreUint8(&o.IE7816.Reg, volatile.LoadUint8(&o.IE7816.Reg)&^(0x10)|value<<4)
}
func (o *UART_Type) GetIE7816_INITDE() uint8 {
	return (volatile.LoadUint8(&o.IE7816.Reg) & 0x10) >> 4
}
func (o *UART_Type) SetIE7816_BWTE(value uint8) {
	volatile.StoreUint8(&o.IE7816.Reg, volatile.LoadUint8(&o.IE7816.Reg)&^(0x20)|value<<5)
}
func (o *UART_Type) GetIE7816_BWTE() uint8 {
	return (volatile.LoadUint8(&o.IE7816.Reg) & 0x20) >> 5
}
func (o *UART_Type) SetIE7816_CWTE(value uint8) {
	volatile.StoreUint8(&o.IE7816.Reg, volatile.LoadUint8(&o.IE7816.Reg)&^(0x40)|value<<6)
}
func (o *UART_Type) GetIE7816_CWTE() uint8 {
	return (volatile.LoadUint8(&o.IE7816.Reg) & 0x40) >> 6
}
func (o *UART_Type) SetIE7816_WTE(value uint8) {
	volatile.StoreUint8(&o.IE7816.Reg, volatile.LoadUint8(&o.IE7816.Reg)&^(0x80)|value<<7)
}
func (o *UART_Type) GetIE7816_WTE() uint8 {
	return (volatile.LoadUint8(&o.IE7816.Reg) & 0x80) >> 7
}

// UART.IS7816: UART 7816 Interrupt Status Register
func (o *UART_Type) SetIS7816_RXT(value uint8) {
	volatile.StoreUint8(&o.IS7816.Reg, volatile.LoadUint8(&o.IS7816.Reg)&^(0x1)|value)
}
func (o *UART_Type) GetIS7816_RXT() uint8 {
	return volatile.LoadUint8(&o.IS7816.Reg) & 0x1
}
func (o *UART_Type) SetIS7816_TXT(value uint8) {
	volatile.StoreUint8(&o.IS7816.Reg, volatile.LoadUint8(&o.IS7816.Reg)&^(0x2)|value<<1)
}
func (o *UART_Type) GetIS7816_TXT() uint8 {
	return (volatile.LoadUint8(&o.IS7816.Reg) & 0x2) >> 1
}
func (o *UART_Type) SetIS7816_GTV(value uint8) {
	volatile.StoreUint8(&o.IS7816.Reg, volatile.LoadUint8(&o.IS7816.Reg)&^(0x4)|value<<2)
}
func (o *UART_Type) GetIS7816_GTV() uint8 {
	return (volatile.LoadUint8(&o.IS7816.Reg) & 0x4) >> 2
}
func (o *UART_Type) SetIS7816_INITD(value uint8) {
	volatile.StoreUint8(&o.IS7816.Reg, volatile.LoadUint8(&o.IS7816.Reg)&^(0x10)|value<<4)
}
func (o *UART_Type) GetIS7816_INITD() uint8 {
	return (volatile.LoadUint8(&o.IS7816.Reg) & 0x10) >> 4
}
func (o *UART_Type) SetIS7816_BWT(value uint8) {
	volatile.StoreUint8(&o.IS7816.Reg, volatile.LoadUint8(&o.IS7816.Reg)&^(0x20)|value<<5)
}
func (o *UART_Type) GetIS7816_BWT() uint8 {
	return (volatile.LoadUint8(&o.IS7816.Reg) & 0x20) >> 5
}
func (o *UART_Type) SetIS7816_CWT(value uint8) {
	volatile.StoreUint8(&o.IS7816.Reg, volatile.LoadUint8(&o.IS7816.Reg)&^(0x40)|value<<6)
}
func (o *UART_Type) GetIS7816_CWT() uint8 {
	return (volatile.LoadUint8(&o.IS7816.Reg) & 0x40) >> 6
}
func (o *UART_Type) SetIS7816_WT(value uint8) {
	volatile.StoreUint8(&o.IS7816.Reg, volatile.LoadUint8(&o.IS7816.Reg)&^(0x80)|value<<7)
}
func (o *UART_Type) GetIS7816_WT() uint8 {
	return (volatile.LoadUint8(&o.IS7816.Reg) & 0x80) >> 7
}

// UART.WP7816T0: UART 7816 Wait Parameter Register
func (o *UART_Type) SetWP7816T0(value uint8) {
	volatile.StoreUint8(&o.WP7816T0.Reg, value)
}
func (o *UART_Type) GetWP7816T0() uint8 {
	return volatile.LoadUint8(&o.WP7816T0.Reg)
}

// UART.WN7816: UART 7816 Wait N Register
func (o *UART_Type) SetWN7816(value uint8) {
	volatile.StoreUint8(&o.WN7816.Reg, value)
}
func (o *UART_Type) GetWN7816() uint8 {
	return volatile.LoadUint8(&o.WN7816.Reg)
}

// UART.WF7816: UART 7816 Wait FD Register
func (o *UART_Type) SetWF7816(value uint8) {
	volatile.StoreUint8(&o.WF7816.Reg, value)
}
func (o *UART_Type) GetWF7816() uint8 {
	return volatile.LoadUint8(&o.WF7816.Reg)
}

// UART.ET7816: UART 7816 Error Threshold Register
func (o *UART_Type) SetET7816_RXTHRESHOLD(value uint8) {
	volatile.StoreUint8(&o.ET7816.Reg, volatile.LoadUint8(&o.ET7816.Reg)&^(0xf)|value)
}
func (o *UART_Type) GetET7816_RXTHRESHOLD() uint8 {
	return volatile.LoadUint8(&o.ET7816.Reg) & 0xf
}
func (o *UART_Type) SetET7816_TXTHRESHOLD(value uint8) {
	volatile.StoreUint8(&o.ET7816.Reg, volatile.LoadUint8(&o.ET7816.Reg)&^(0xf0)|value<<4)
}
func (o *UART_Type) GetET7816_TXTHRESHOLD() uint8 {
	return (volatile.LoadUint8(&o.ET7816.Reg) & 0xf0) >> 4
}

// UART.TL7816: UART 7816 Transmit Length Register
func (o *UART_Type) SetTL7816(value uint8) {
	volatile.StoreUint8(&o.TL7816.Reg, value)
}
func (o *UART_Type) GetTL7816() uint8 {
	return volatile.LoadUint8(&o.TL7816.Reg)
}

// Universal Serial Bus, OTG Capable Controller
type USB0_Type struct {
	PERID                  volatile.Register8 // 0x0
	_                      [3]byte
	IDCOMP                 volatile.Register8 // 0x4
	_                      [3]byte
	REV                    volatile.Register8 // 0x8
	_                      [3]byte
	ADDINFO                volatile.Register8 // 0xC
	_                      [3]byte
	OTGISTAT               volatile.Register8 // 0x10
	_                      [3]byte
	OTGICR                 volatile.Register8 // 0x14
	_                      [3]byte
	OTGSTAT                volatile.Register8 // 0x18
	_                      [3]byte
	OTGCTL                 volatile.Register8 // 0x1C
	_                      [99]byte
	ISTAT                  volatile.Register8 // 0x80
	_                      [3]byte
	INTEN                  volatile.Register8 // 0x84
	_                      [3]byte
	ERRSTAT                volatile.Register8 // 0x88
	_                      [3]byte
	ERREN                  volatile.Register8 // 0x8C
	_                      [3]byte
	STAT                   volatile.Register8 // 0x90
	_                      [3]byte
	CTL                    volatile.Register8 // 0x94
	_                      [3]byte
	ADDR                   volatile.Register8 // 0x98
	_                      [3]byte
	BDTPAGE1               volatile.Register8 // 0x9C
	_                      [3]byte
	FRMNUML                volatile.Register8 // 0xA0
	_                      [3]byte
	FRMNUMH                volatile.Register8 // 0xA4
	_                      [3]byte
	TOKEN                  volatile.Register8 // 0xA8
	_                      [3]byte
	SOFTHLD                volatile.Register8 // 0xAC
	_                      [3]byte
	BDTPAGE2               volatile.Register8 // 0xB0
	_                      [3]byte
	BDTPAGE3               volatile.Register8 // 0xB4
	_                      [11]byte
	ENDPT0                 volatile.Register8 // 0xC0
	_                      [3]byte
	ENDPT1                 volatile.Register8 // 0xC4
	_                      [3]byte
	ENDPT2                 volatile.Register8 // 0xC8
	_                      [3]byte
	ENDPT3                 volatile.Register8 // 0xCC
	_                      [3]byte
	ENDPT4                 volatile.Register8 // 0xD0
	_                      [3]byte
	ENDPT5                 volatile.Register8 // 0xD4
	_                      [3]byte
	ENDPT6                 volatile.Register8 // 0xD8
	_                      [3]byte
	ENDPT7                 volatile.Register8 // 0xDC
	_                      [3]byte
	ENDPT8                 volatile.Register8 // 0xE0
	_                      [3]byte
	ENDPT9                 volatile.Register8 // 0xE4
	_                      [3]byte
	ENDPT10                volatile.Register8 // 0xE8
	_                      [3]byte
	ENDPT11                volatile.Register8 // 0xEC
	_                      [3]byte
	ENDPT12                volatile.Register8 // 0xF0
	_                      [3]byte
	ENDPT13                volatile.Register8 // 0xF4
	_                      [3]byte
	ENDPT14                volatile.Register8 // 0xF8
	_                      [3]byte
	ENDPT15                volatile.Register8 // 0xFC
	_                      [3]byte
	USBCTRL                volatile.Register8 // 0x100
	_                      [3]byte
	OBSERVE                volatile.Register8 // 0x104
	_                      [3]byte
	CONTROL                volatile.Register8 // 0x108
	_                      [3]byte
	USBTRC0                volatile.Register8 // 0x10C
	_                      [7]byte
	USBFRMADJUST           volatile.Register8 // 0x114
	_                      [43]byte
	CLK_RECOVER_CTRL       volatile.Register8 // 0x140
	_                      [3]byte
	CLK_RECOVER_IRC_EN     volatile.Register8 // 0x144
	_                      [23]byte
	CLK_RECOVER_INT_STATUS volatile.Register8 // 0x15C
}

// USB0.PERID: Peripheral ID register
func (o *USB0_Type) SetPERID_ID(value uint8) {
	volatile.StoreUint8(&o.PERID.Reg, volatile.LoadUint8(&o.PERID.Reg)&^(0x3f)|value)
}
func (o *USB0_Type) GetPERID_ID() uint8 {
	return volatile.LoadUint8(&o.PERID.Reg) & 0x3f
}

// USB0.IDCOMP: Peripheral ID Complement register
func (o *USB0_Type) SetIDCOMP_NID(value uint8) {
	volatile.StoreUint8(&o.IDCOMP.Reg, volatile.LoadUint8(&o.IDCOMP.Reg)&^(0x3f)|value)
}
func (o *USB0_Type) GetIDCOMP_NID() uint8 {
	return volatile.LoadUint8(&o.IDCOMP.Reg) & 0x3f
}

// USB0.REV: Peripheral Revision register
func (o *USB0_Type) SetREV(value uint8) {
	volatile.StoreUint8(&o.REV.Reg, value)
}
func (o *USB0_Type) GetREV() uint8 {
	return volatile.LoadUint8(&o.REV.Reg)
}

// USB0.ADDINFO: Peripheral Additional Info register
func (o *USB0_Type) SetADDINFO_IEHOST(value uint8) {
	volatile.StoreUint8(&o.ADDINFO.Reg, volatile.LoadUint8(&o.ADDINFO.Reg)&^(0x1)|value)
}
func (o *USB0_Type) GetADDINFO_IEHOST() uint8 {
	return volatile.LoadUint8(&o.ADDINFO.Reg) & 0x1
}
func (o *USB0_Type) SetADDINFO_IRQNUM(value uint8) {
	volatile.StoreUint8(&o.ADDINFO.Reg, volatile.LoadUint8(&o.ADDINFO.Reg)&^(0xf8)|value<<3)
}
func (o *USB0_Type) GetADDINFO_IRQNUM() uint8 {
	return (volatile.LoadUint8(&o.ADDINFO.Reg) & 0xf8) >> 3
}

// USB0.OTGISTAT: OTG Interrupt Status register
func (o *USB0_Type) SetOTGISTAT_AVBUSCHG(value uint8) {
	volatile.StoreUint8(&o.OTGISTAT.Reg, volatile.LoadUint8(&o.OTGISTAT.Reg)&^(0x1)|value)
}
func (o *USB0_Type) GetOTGISTAT_AVBUSCHG() uint8 {
	return volatile.LoadUint8(&o.OTGISTAT.Reg) & 0x1
}
func (o *USB0_Type) SetOTGISTAT_B_SESS_CHG(value uint8) {
	volatile.StoreUint8(&o.OTGISTAT.Reg, volatile.LoadUint8(&o.OTGISTAT.Reg)&^(0x4)|value<<2)
}
func (o *USB0_Type) GetOTGISTAT_B_SESS_CHG() uint8 {
	return (volatile.LoadUint8(&o.OTGISTAT.Reg) & 0x4) >> 2
}
func (o *USB0_Type) SetOTGISTAT_SESSVLDCHG(value uint8) {
	volatile.StoreUint8(&o.OTGISTAT.Reg, volatile.LoadUint8(&o.OTGISTAT.Reg)&^(0x8)|value<<3)
}
func (o *USB0_Type) GetOTGISTAT_SESSVLDCHG() uint8 {
	return (volatile.LoadUint8(&o.OTGISTAT.Reg) & 0x8) >> 3
}
func (o *USB0_Type) SetOTGISTAT_LINE_STATE_CHG(value uint8) {
	volatile.StoreUint8(&o.OTGISTAT.Reg, volatile.LoadUint8(&o.OTGISTAT.Reg)&^(0x20)|value<<5)
}
func (o *USB0_Type) GetOTGISTAT_LINE_STATE_CHG() uint8 {
	return (volatile.LoadUint8(&o.OTGISTAT.Reg) & 0x20) >> 5
}
func (o *USB0_Type) SetOTGISTAT_ONEMSEC(value uint8) {
	volatile.StoreUint8(&o.OTGISTAT.Reg, volatile.LoadUint8(&o.OTGISTAT.Reg)&^(0x40)|value<<6)
}
func (o *USB0_Type) GetOTGISTAT_ONEMSEC() uint8 {
	return (volatile.LoadUint8(&o.OTGISTAT.Reg) & 0x40) >> 6
}
func (o *USB0_Type) SetOTGISTAT_IDCHG(value uint8) {
	volatile.StoreUint8(&o.OTGISTAT.Reg, volatile.LoadUint8(&o.OTGISTAT.Reg)&^(0x80)|value<<7)
}
func (o *USB0_Type) GetOTGISTAT_IDCHG() uint8 {
	return (volatile.LoadUint8(&o.OTGISTAT.Reg) & 0x80) >> 7
}

// USB0.OTGICR: OTG Interrupt Control register
func (o *USB0_Type) SetOTGICR_AVBUSEN(value uint8) {
	volatile.StoreUint8(&o.OTGICR.Reg, volatile.LoadUint8(&o.OTGICR.Reg)&^(0x1)|value)
}
func (o *USB0_Type) GetOTGICR_AVBUSEN() uint8 {
	return volatile.LoadUint8(&o.OTGICR.Reg) & 0x1
}
func (o *USB0_Type) SetOTGICR_BSESSEN(value uint8) {
	volatile.StoreUint8(&o.OTGICR.Reg, volatile.LoadUint8(&o.OTGICR.Reg)&^(0x4)|value<<2)
}
func (o *USB0_Type) GetOTGICR_BSESSEN() uint8 {
	return (volatile.LoadUint8(&o.OTGICR.Reg) & 0x4) >> 2
}
func (o *USB0_Type) SetOTGICR_SESSVLDEN(value uint8) {
	volatile.StoreUint8(&o.OTGICR.Reg, volatile.LoadUint8(&o.OTGICR.Reg)&^(0x8)|value<<3)
}
func (o *USB0_Type) GetOTGICR_SESSVLDEN() uint8 {
	return (volatile.LoadUint8(&o.OTGICR.Reg) & 0x8) >> 3
}
func (o *USB0_Type) SetOTGICR_LINESTATEEN(value uint8) {
	volatile.StoreUint8(&o.OTGICR.Reg, volatile.LoadUint8(&o.OTGICR.Reg)&^(0x20)|value<<5)
}
func (o *USB0_Type) GetOTGICR_LINESTATEEN() uint8 {
	return (volatile.LoadUint8(&o.OTGICR.Reg) & 0x20) >> 5
}
func (o *USB0_Type) SetOTGICR_ONEMSECEN(value uint8) {
	volatile.StoreUint8(&o.OTGICR.Reg, volatile.LoadUint8(&o.OTGICR.Reg)&^(0x40)|value<<6)
}
func (o *USB0_Type) GetOTGICR_ONEMSECEN() uint8 {
	return (volatile.LoadUint8(&o.OTGICR.Reg) & 0x40) >> 6
}
func (o *USB0_Type) SetOTGICR_IDEN(value uint8) {
	volatile.StoreUint8(&o.OTGICR.Reg, volatile.LoadUint8(&o.OTGICR.Reg)&^(0x80)|value<<7)
}
func (o *USB0_Type) GetOTGICR_IDEN() uint8 {
	return (volatile.LoadUint8(&o.OTGICR.Reg) & 0x80) >> 7
}

// USB0.OTGSTAT: OTG Status register
func (o *USB0_Type) SetOTGSTAT_AVBUSVLD(value uint8) {
	volatile.StoreUint8(&o.OTGSTAT.Reg, volatile.LoadUint8(&o.OTGSTAT.Reg)&^(0x1)|value)
}
func (o *USB0_Type) GetOTGSTAT_AVBUSVLD() uint8 {
	return volatile.LoadUint8(&o.OTGSTAT.Reg) & 0x1
}
func (o *USB0_Type) SetOTGSTAT_BSESSEND(value uint8) {
	volatile.StoreUint8(&o.OTGSTAT.Reg, volatile.LoadUint8(&o.OTGSTAT.Reg)&^(0x4)|value<<2)
}
func (o *USB0_Type) GetOTGSTAT_BSESSEND() uint8 {
	return (volatile.LoadUint8(&o.OTGSTAT.Reg) & 0x4) >> 2
}
func (o *USB0_Type) SetOTGSTAT_SESS_VLD(value uint8) {
	volatile.StoreUint8(&o.OTGSTAT.Reg, volatile.LoadUint8(&o.OTGSTAT.Reg)&^(0x8)|value<<3)
}
func (o *USB0_Type) GetOTGSTAT_SESS_VLD() uint8 {
	return (volatile.LoadUint8(&o.OTGSTAT.Reg) & 0x8) >> 3
}
func (o *USB0_Type) SetOTGSTAT_LINESTATESTABLE(value uint8) {
	volatile.StoreUint8(&o.OTGSTAT.Reg, volatile.LoadUint8(&o.OTGSTAT.Reg)&^(0x20)|value<<5)
}
func (o *USB0_Type) GetOTGSTAT_LINESTATESTABLE() uint8 {
	return (volatile.LoadUint8(&o.OTGSTAT.Reg) & 0x20) >> 5
}
func (o *USB0_Type) SetOTGSTAT_ONEMSECEN(value uint8) {
	volatile.StoreUint8(&o.OTGSTAT.Reg, volatile.LoadUint8(&o.OTGSTAT.Reg)&^(0x40)|value<<6)
}
func (o *USB0_Type) GetOTGSTAT_ONEMSECEN() uint8 {
	return (volatile.LoadUint8(&o.OTGSTAT.Reg) & 0x40) >> 6
}
func (o *USB0_Type) SetOTGSTAT_ID(value uint8) {
	volatile.StoreUint8(&o.OTGSTAT.Reg, volatile.LoadUint8(&o.OTGSTAT.Reg)&^(0x80)|value<<7)
}
func (o *USB0_Type) GetOTGSTAT_ID() uint8 {
	return (volatile.LoadUint8(&o.OTGSTAT.Reg) & 0x80) >> 7
}

// USB0.OTGCTL: OTG Control register
func (o *USB0_Type) SetOTGCTL_OTGEN(value uint8) {
	volatile.StoreUint8(&o.OTGCTL.Reg, volatile.LoadUint8(&o.OTGCTL.Reg)&^(0x4)|value<<2)
}
func (o *USB0_Type) GetOTGCTL_OTGEN() uint8 {
	return (volatile.LoadUint8(&o.OTGCTL.Reg) & 0x4) >> 2
}
func (o *USB0_Type) SetOTGCTL_DMLOW(value uint8) {
	volatile.StoreUint8(&o.OTGCTL.Reg, volatile.LoadUint8(&o.OTGCTL.Reg)&^(0x10)|value<<4)
}
func (o *USB0_Type) GetOTGCTL_DMLOW() uint8 {
	return (volatile.LoadUint8(&o.OTGCTL.Reg) & 0x10) >> 4
}
func (o *USB0_Type) SetOTGCTL_DPLOW(value uint8) {
	volatile.StoreUint8(&o.OTGCTL.Reg, volatile.LoadUint8(&o.OTGCTL.Reg)&^(0x20)|value<<5)
}
func (o *USB0_Type) GetOTGCTL_DPLOW() uint8 {
	return (volatile.LoadUint8(&o.OTGCTL.Reg) & 0x20) >> 5
}
func (o *USB0_Type) SetOTGCTL_DPHIGH(value uint8) {
	volatile.StoreUint8(&o.OTGCTL.Reg, volatile.LoadUint8(&o.OTGCTL.Reg)&^(0x80)|value<<7)
}
func (o *USB0_Type) GetOTGCTL_DPHIGH() uint8 {
	return (volatile.LoadUint8(&o.OTGCTL.Reg) & 0x80) >> 7
}

// USB0.ISTAT: Interrupt Status register
func (o *USB0_Type) SetISTAT_USBRST(value uint8) {
	volatile.StoreUint8(&o.ISTAT.Reg, volatile.LoadUint8(&o.ISTAT.Reg)&^(0x1)|value)
}
func (o *USB0_Type) GetISTAT_USBRST() uint8 {
	return volatile.LoadUint8(&o.ISTAT.Reg) & 0x1
}
func (o *USB0_Type) SetISTAT_ERROR(value uint8) {
	volatile.StoreUint8(&o.ISTAT.Reg, volatile.LoadUint8(&o.ISTAT.Reg)&^(0x2)|value<<1)
}
func (o *USB0_Type) GetISTAT_ERROR() uint8 {
	return (volatile.LoadUint8(&o.ISTAT.Reg) & 0x2) >> 1
}
func (o *USB0_Type) SetISTAT_SOFTOK(value uint8) {
	volatile.StoreUint8(&o.ISTAT.Reg, volatile.LoadUint8(&o.ISTAT.Reg)&^(0x4)|value<<2)
}
func (o *USB0_Type) GetISTAT_SOFTOK() uint8 {
	return (volatile.LoadUint8(&o.ISTAT.Reg) & 0x4) >> 2
}
func (o *USB0_Type) SetISTAT_TOKDNE(value uint8) {
	volatile.StoreUint8(&o.ISTAT.Reg, volatile.LoadUint8(&o.ISTAT.Reg)&^(0x8)|value<<3)
}
func (o *USB0_Type) GetISTAT_TOKDNE() uint8 {
	return (volatile.LoadUint8(&o.ISTAT.Reg) & 0x8) >> 3
}
func (o *USB0_Type) SetISTAT_SLEEP(value uint8) {
	volatile.StoreUint8(&o.ISTAT.Reg, volatile.LoadUint8(&o.ISTAT.Reg)&^(0x10)|value<<4)
}
func (o *USB0_Type) GetISTAT_SLEEP() uint8 {
	return (volatile.LoadUint8(&o.ISTAT.Reg) & 0x10) >> 4
}
func (o *USB0_Type) SetISTAT_RESUME(value uint8) {
	volatile.StoreUint8(&o.ISTAT.Reg, volatile.LoadUint8(&o.ISTAT.Reg)&^(0x20)|value<<5)
}
func (o *USB0_Type) GetISTAT_RESUME() uint8 {
	return (volatile.LoadUint8(&o.ISTAT.Reg) & 0x20) >> 5
}
func (o *USB0_Type) SetISTAT_ATTACH(value uint8) {
	volatile.StoreUint8(&o.ISTAT.Reg, volatile.LoadUint8(&o.ISTAT.Reg)&^(0x40)|value<<6)
}
func (o *USB0_Type) GetISTAT_ATTACH() uint8 {
	return (volatile.LoadUint8(&o.ISTAT.Reg) & 0x40) >> 6
}
func (o *USB0_Type) SetISTAT_STALL(value uint8) {
	volatile.StoreUint8(&o.ISTAT.Reg, volatile.LoadUint8(&o.ISTAT.Reg)&^(0x80)|value<<7)
}
func (o *USB0_Type) GetISTAT_STALL() uint8 {
	return (volatile.LoadUint8(&o.ISTAT.Reg) & 0x80) >> 7
}

// USB0.INTEN: Interrupt Enable register
func (o *USB0_Type) SetINTEN_USBRSTEN(value uint8) {
	volatile.StoreUint8(&o.INTEN.Reg, volatile.LoadUint8(&o.INTEN.Reg)&^(0x1)|value)
}
func (o *USB0_Type) GetINTEN_USBRSTEN() uint8 {
	return volatile.LoadUint8(&o.INTEN.Reg) & 0x1
}
func (o *USB0_Type) SetINTEN_ERROREN(value uint8) {
	volatile.StoreUint8(&o.INTEN.Reg, volatile.LoadUint8(&o.INTEN.Reg)&^(0x2)|value<<1)
}
func (o *USB0_Type) GetINTEN_ERROREN() uint8 {
	return (volatile.LoadUint8(&o.INTEN.Reg) & 0x2) >> 1
}
func (o *USB0_Type) SetINTEN_SOFTOKEN(value uint8) {
	volatile.StoreUint8(&o.INTEN.Reg, volatile.LoadUint8(&o.INTEN.Reg)&^(0x4)|value<<2)
}
func (o *USB0_Type) GetINTEN_SOFTOKEN() uint8 {
	return (volatile.LoadUint8(&o.INTEN.Reg) & 0x4) >> 2
}
func (o *USB0_Type) SetINTEN_TOKDNEEN(value uint8) {
	volatile.StoreUint8(&o.INTEN.Reg, volatile.LoadUint8(&o.INTEN.Reg)&^(0x8)|value<<3)
}
func (o *USB0_Type) GetINTEN_TOKDNEEN() uint8 {
	return (volatile.LoadUint8(&o.INTEN.Reg) & 0x8) >> 3
}
func (o *USB0_Type) SetINTEN_SLEEPEN(value uint8) {
	volatile.StoreUint8(&o.INTEN.Reg, volatile.LoadUint8(&o.INTEN.Reg)&^(0x10)|value<<4)
}
func (o *USB0_Type) GetINTEN_SLEEPEN() uint8 {
	return (volatile.LoadUint8(&o.INTEN.Reg) & 0x10) >> 4
}
func (o *USB0_Type) SetINTEN_RESUMEEN(value uint8) {
	volatile.StoreUint8(&o.INTEN.Reg, volatile.LoadUint8(&o.INTEN.Reg)&^(0x20)|value<<5)
}
func (o *USB0_Type) GetINTEN_RESUMEEN() uint8 {
	return (volatile.LoadUint8(&o.INTEN.Reg) & 0x20) >> 5
}
func (o *USB0_Type) SetINTEN_ATTACHEN(value uint8) {
	volatile.StoreUint8(&o.INTEN.Reg, volatile.LoadUint8(&o.INTEN.Reg)&^(0x40)|value<<6)
}
func (o *USB0_Type) GetINTEN_ATTACHEN() uint8 {
	return (volatile.LoadUint8(&o.INTEN.Reg) & 0x40) >> 6
}
func (o *USB0_Type) SetINTEN_STALLEN(value uint8) {
	volatile.StoreUint8(&o.INTEN.Reg, volatile.LoadUint8(&o.INTEN.Reg)&^(0x80)|value<<7)
}
func (o *USB0_Type) GetINTEN_STALLEN() uint8 {
	return (volatile.LoadUint8(&o.INTEN.Reg) & 0x80) >> 7
}

// USB0.ERRSTAT: Error Interrupt Status register
func (o *USB0_Type) SetERRSTAT_PIDERR(value uint8) {
	volatile.StoreUint8(&o.ERRSTAT.Reg, volatile.LoadUint8(&o.ERRSTAT.Reg)&^(0x1)|value)
}
func (o *USB0_Type) GetERRSTAT_PIDERR() uint8 {
	return volatile.LoadUint8(&o.ERRSTAT.Reg) & 0x1
}
func (o *USB0_Type) SetERRSTAT_CRC5EOF(value uint8) {
	volatile.StoreUint8(&o.ERRSTAT.Reg, volatile.LoadUint8(&o.ERRSTAT.Reg)&^(0x2)|value<<1)
}
func (o *USB0_Type) GetERRSTAT_CRC5EOF() uint8 {
	return (volatile.LoadUint8(&o.ERRSTAT.Reg) & 0x2) >> 1
}
func (o *USB0_Type) SetERRSTAT_CRC16(value uint8) {
	volatile.StoreUint8(&o.ERRSTAT.Reg, volatile.LoadUint8(&o.ERRSTAT.Reg)&^(0x4)|value<<2)
}
func (o *USB0_Type) GetERRSTAT_CRC16() uint8 {
	return (volatile.LoadUint8(&o.ERRSTAT.Reg) & 0x4) >> 2
}
func (o *USB0_Type) SetERRSTAT_DFN8(value uint8) {
	volatile.StoreUint8(&o.ERRSTAT.Reg, volatile.LoadUint8(&o.ERRSTAT.Reg)&^(0x8)|value<<3)
}
func (o *USB0_Type) GetERRSTAT_DFN8() uint8 {
	return (volatile.LoadUint8(&o.ERRSTAT.Reg) & 0x8) >> 3
}
func (o *USB0_Type) SetERRSTAT_BTOERR(value uint8) {
	volatile.StoreUint8(&o.ERRSTAT.Reg, volatile.LoadUint8(&o.ERRSTAT.Reg)&^(0x10)|value<<4)
}
func (o *USB0_Type) GetERRSTAT_BTOERR() uint8 {
	return (volatile.LoadUint8(&o.ERRSTAT.Reg) & 0x10) >> 4
}
func (o *USB0_Type) SetERRSTAT_DMAERR(value uint8) {
	volatile.StoreUint8(&o.ERRSTAT.Reg, volatile.LoadUint8(&o.ERRSTAT.Reg)&^(0x20)|value<<5)
}
func (o *USB0_Type) GetERRSTAT_DMAERR() uint8 {
	return (volatile.LoadUint8(&o.ERRSTAT.Reg) & 0x20) >> 5
}
func (o *USB0_Type) SetERRSTAT_BTSERR(value uint8) {
	volatile.StoreUint8(&o.ERRSTAT.Reg, volatile.LoadUint8(&o.ERRSTAT.Reg)&^(0x80)|value<<7)
}
func (o *USB0_Type) GetERRSTAT_BTSERR() uint8 {
	return (volatile.LoadUint8(&o.ERRSTAT.Reg) & 0x80) >> 7
}

// USB0.ERREN: Error Interrupt Enable register
func (o *USB0_Type) SetERREN_PIDERREN(value uint8) {
	volatile.StoreUint8(&o.ERREN.Reg, volatile.LoadUint8(&o.ERREN.Reg)&^(0x1)|value)
}
func (o *USB0_Type) GetERREN_PIDERREN() uint8 {
	return volatile.LoadUint8(&o.ERREN.Reg) & 0x1
}
func (o *USB0_Type) SetERREN_CRC5EOFEN(value uint8) {
	volatile.StoreUint8(&o.ERREN.Reg, volatile.LoadUint8(&o.ERREN.Reg)&^(0x2)|value<<1)
}
func (o *USB0_Type) GetERREN_CRC5EOFEN() uint8 {
	return (volatile.LoadUint8(&o.ERREN.Reg) & 0x2) >> 1
}
func (o *USB0_Type) SetERREN_CRC16EN(value uint8) {
	volatile.StoreUint8(&o.ERREN.Reg, volatile.LoadUint8(&o.ERREN.Reg)&^(0x4)|value<<2)
}
func (o *USB0_Type) GetERREN_CRC16EN() uint8 {
	return (volatile.LoadUint8(&o.ERREN.Reg) & 0x4) >> 2
}
func (o *USB0_Type) SetERREN_DFN8EN(value uint8) {
	volatile.StoreUint8(&o.ERREN.Reg, volatile.LoadUint8(&o.ERREN.Reg)&^(0x8)|value<<3)
}
func (o *USB0_Type) GetERREN_DFN8EN() uint8 {
	return (volatile.LoadUint8(&o.ERREN.Reg) & 0x8) >> 3
}
func (o *USB0_Type) SetERREN_BTOERREN(value uint8) {
	volatile.StoreUint8(&o.ERREN.Reg, volatile.LoadUint8(&o.ERREN.Reg)&^(0x10)|value<<4)
}
func (o *USB0_Type) GetERREN_BTOERREN() uint8 {
	return (volatile.LoadUint8(&o.ERREN.Reg) & 0x10) >> 4
}
func (o *USB0_Type) SetERREN_DMAERREN(value uint8) {
	volatile.StoreUint8(&o.ERREN.Reg, volatile.LoadUint8(&o.ERREN.Reg)&^(0x20)|value<<5)
}
func (o *USB0_Type) GetERREN_DMAERREN() uint8 {
	return (volatile.LoadUint8(&o.ERREN.Reg) & 0x20) >> 5
}
func (o *USB0_Type) SetERREN_BTSERREN(value uint8) {
	volatile.StoreUint8(&o.ERREN.Reg, volatile.LoadUint8(&o.ERREN.Reg)&^(0x80)|value<<7)
}
func (o *USB0_Type) GetERREN_BTSERREN() uint8 {
	return (volatile.LoadUint8(&o.ERREN.Reg) & 0x80) >> 7
}

// USB0.STAT: Status register
func (o *USB0_Type) SetSTAT_ODD(value uint8) {
	volatile.StoreUint8(&o.STAT.Reg, volatile.LoadUint8(&o.STAT.Reg)&^(0x4)|value<<2)
}
func (o *USB0_Type) GetSTAT_ODD() uint8 {
	return (volatile.LoadUint8(&o.STAT.Reg) & 0x4) >> 2
}
func (o *USB0_Type) SetSTAT_TX(value uint8) {
	volatile.StoreUint8(&o.STAT.Reg, volatile.LoadUint8(&o.STAT.Reg)&^(0x8)|value<<3)
}
func (o *USB0_Type) GetSTAT_TX() uint8 {
	return (volatile.LoadUint8(&o.STAT.Reg) & 0x8) >> 3
}
func (o *USB0_Type) SetSTAT_ENDP(value uint8) {
	volatile.StoreUint8(&o.STAT.Reg, volatile.LoadUint8(&o.STAT.Reg)&^(0xf0)|value<<4)
}
func (o *USB0_Type) GetSTAT_ENDP() uint8 {
	return (volatile.LoadUint8(&o.STAT.Reg) & 0xf0) >> 4
}

// USB0.CTL: Control register
func (o *USB0_Type) SetCTL_USBENSOFEN(value uint8) {
	volatile.StoreUint8(&o.CTL.Reg, volatile.LoadUint8(&o.CTL.Reg)&^(0x1)|value)
}
func (o *USB0_Type) GetCTL_USBENSOFEN() uint8 {
	return volatile.LoadUint8(&o.CTL.Reg) & 0x1
}
func (o *USB0_Type) SetCTL_ODDRST(value uint8) {
	volatile.StoreUint8(&o.CTL.Reg, volatile.LoadUint8(&o.CTL.Reg)&^(0x2)|value<<1)
}
func (o *USB0_Type) GetCTL_ODDRST() uint8 {
	return (volatile.LoadUint8(&o.CTL.Reg) & 0x2) >> 1
}
func (o *USB0_Type) SetCTL_RESUME(value uint8) {
	volatile.StoreUint8(&o.CTL.Reg, volatile.LoadUint8(&o.CTL.Reg)&^(0x4)|value<<2)
}
func (o *USB0_Type) GetCTL_RESUME() uint8 {
	return (volatile.LoadUint8(&o.CTL.Reg) & 0x4) >> 2
}
func (o *USB0_Type) SetCTL_HOSTMODEEN(value uint8) {
	volatile.StoreUint8(&o.CTL.Reg, volatile.LoadUint8(&o.CTL.Reg)&^(0x8)|value<<3)
}
func (o *USB0_Type) GetCTL_HOSTMODEEN() uint8 {
	return (volatile.LoadUint8(&o.CTL.Reg) & 0x8) >> 3
}
func (o *USB0_Type) SetCTL_RESET(value uint8) {
	volatile.StoreUint8(&o.CTL.Reg, volatile.LoadUint8(&o.CTL.Reg)&^(0x10)|value<<4)
}
func (o *USB0_Type) GetCTL_RESET() uint8 {
	return (volatile.LoadUint8(&o.CTL.Reg) & 0x10) >> 4
}
func (o *USB0_Type) SetCTL_TXSUSPENDTOKENBUSY(value uint8) {
	volatile.StoreUint8(&o.CTL.Reg, volatile.LoadUint8(&o.CTL.Reg)&^(0x20)|value<<5)
}
func (o *USB0_Type) GetCTL_TXSUSPENDTOKENBUSY() uint8 {
	return (volatile.LoadUint8(&o.CTL.Reg) & 0x20) >> 5
}
func (o *USB0_Type) SetCTL_SE0(value uint8) {
	volatile.StoreUint8(&o.CTL.Reg, volatile.LoadUint8(&o.CTL.Reg)&^(0x40)|value<<6)
}
func (o *USB0_Type) GetCTL_SE0() uint8 {
	return (volatile.LoadUint8(&o.CTL.Reg) & 0x40) >> 6
}
func (o *USB0_Type) SetCTL_JSTATE(value uint8) {
	volatile.StoreUint8(&o.CTL.Reg, volatile.LoadUint8(&o.CTL.Reg)&^(0x80)|value<<7)
}
func (o *USB0_Type) GetCTL_JSTATE() uint8 {
	return (volatile.LoadUint8(&o.CTL.Reg) & 0x80) >> 7
}

// USB0.ADDR: Address register
func (o *USB0_Type) SetADDR(value uint8) {
	volatile.StoreUint8(&o.ADDR.Reg, volatile.LoadUint8(&o.ADDR.Reg)&^(0x7f)|value)
}
func (o *USB0_Type) GetADDR() uint8 {
	return volatile.LoadUint8(&o.ADDR.Reg) & 0x7f
}
func (o *USB0_Type) SetADDR_LSEN(value uint8) {
	volatile.StoreUint8(&o.ADDR.Reg, volatile.LoadUint8(&o.ADDR.Reg)&^(0x80)|value<<7)
}
func (o *USB0_Type) GetADDR_LSEN() uint8 {
	return (volatile.LoadUint8(&o.ADDR.Reg) & 0x80) >> 7
}

// USB0.BDTPAGE1: BDT Page register 1
func (o *USB0_Type) SetBDTPAGE1_BDTBA(value uint8) {
	volatile.StoreUint8(&o.BDTPAGE1.Reg, volatile.LoadUint8(&o.BDTPAGE1.Reg)&^(0xfe)|value<<1)
}
func (o *USB0_Type) GetBDTPAGE1_BDTBA() uint8 {
	return (volatile.LoadUint8(&o.BDTPAGE1.Reg) & 0xfe) >> 1
}

// USB0.FRMNUML: Frame Number register Low
func (o *USB0_Type) SetFRMNUML(value uint8) {
	volatile.StoreUint8(&o.FRMNUML.Reg, value)
}
func (o *USB0_Type) GetFRMNUML() uint8 {
	return volatile.LoadUint8(&o.FRMNUML.Reg)
}

// USB0.FRMNUMH: Frame Number register High
func (o *USB0_Type) SetFRMNUMH_FRM(value uint8) {
	volatile.StoreUint8(&o.FRMNUMH.Reg, volatile.LoadUint8(&o.FRMNUMH.Reg)&^(0x7)|value)
}
func (o *USB0_Type) GetFRMNUMH_FRM() uint8 {
	return volatile.LoadUint8(&o.FRMNUMH.Reg) & 0x7
}

// USB0.TOKEN: Token register
func (o *USB0_Type) SetTOKEN_TOKENENDPT(value uint8) {
	volatile.StoreUint8(&o.TOKEN.Reg, volatile.LoadUint8(&o.TOKEN.Reg)&^(0xf)|value)
}
func (o *USB0_Type) GetTOKEN_TOKENENDPT() uint8 {
	return volatile.LoadUint8(&o.TOKEN.Reg) & 0xf
}
func (o *USB0_Type) SetTOKEN_TOKENPID(value uint8) {
	volatile.StoreUint8(&o.TOKEN.Reg, volatile.LoadUint8(&o.TOKEN.Reg)&^(0xf0)|value<<4)
}
func (o *USB0_Type) GetTOKEN_TOKENPID() uint8 {
	return (volatile.LoadUint8(&o.TOKEN.Reg) & 0xf0) >> 4
}

// USB0.SOFTHLD: SOF Threshold register
func (o *USB0_Type) SetSOFTHLD(value uint8) {
	volatile.StoreUint8(&o.SOFTHLD.Reg, value)
}
func (o *USB0_Type) GetSOFTHLD() uint8 {
	return volatile.LoadUint8(&o.SOFTHLD.Reg)
}

// USB0.BDTPAGE2: BDT Page Register 2
func (o *USB0_Type) SetBDTPAGE2(value uint8) {
	volatile.StoreUint8(&o.BDTPAGE2.Reg, value)
}
func (o *USB0_Type) GetBDTPAGE2() uint8 {
	return volatile.LoadUint8(&o.BDTPAGE2.Reg)
}

// USB0.BDTPAGE3: BDT Page Register 3
func (o *USB0_Type) SetBDTPAGE3(value uint8) {
	volatile.StoreUint8(&o.BDTPAGE3.Reg, value)
}
func (o *USB0_Type) GetBDTPAGE3() uint8 {
	return volatile.LoadUint8(&o.BDTPAGE3.Reg)
}

// USB0.ENDPT0: Endpoint Control register
func (o *USB0_Type) SetENDPT0_EPHSHK(value uint8) {
	volatile.StoreUint8(&o.ENDPT0.Reg, volatile.LoadUint8(&o.ENDPT0.Reg)&^(0x1)|value)
}
func (o *USB0_Type) GetENDPT0_EPHSHK() uint8 {
	return volatile.LoadUint8(&o.ENDPT0.Reg) & 0x1
}
func (o *USB0_Type) SetENDPT0_EPSTALL(value uint8) {
	volatile.StoreUint8(&o.ENDPT0.Reg, volatile.LoadUint8(&o.ENDPT0.Reg)&^(0x2)|value<<1)
}
func (o *USB0_Type) GetENDPT0_EPSTALL() uint8 {
	return (volatile.LoadUint8(&o.ENDPT0.Reg) & 0x2) >> 1
}
func (o *USB0_Type) SetENDPT0_EPTXEN(value uint8) {
	volatile.StoreUint8(&o.ENDPT0.Reg, volatile.LoadUint8(&o.ENDPT0.Reg)&^(0x4)|value<<2)
}
func (o *USB0_Type) GetENDPT0_EPTXEN() uint8 {
	return (volatile.LoadUint8(&o.ENDPT0.Reg) & 0x4) >> 2
}
func (o *USB0_Type) SetENDPT0_EPRXEN(value uint8) {
	volatile.StoreUint8(&o.ENDPT0.Reg, volatile.LoadUint8(&o.ENDPT0.Reg)&^(0x8)|value<<3)
}
func (o *USB0_Type) GetENDPT0_EPRXEN() uint8 {
	return (volatile.LoadUint8(&o.ENDPT0.Reg) & 0x8) >> 3
}
func (o *USB0_Type) SetENDPT0_EPCTLDIS(value uint8) {
	volatile.StoreUint8(&o.ENDPT0.Reg, volatile.LoadUint8(&o.ENDPT0.Reg)&^(0x10)|value<<4)
}
func (o *USB0_Type) GetENDPT0_EPCTLDIS() uint8 {
	return (volatile.LoadUint8(&o.ENDPT0.Reg) & 0x10) >> 4
}
func (o *USB0_Type) SetENDPT0_RETRYDIS(value uint8) {
	volatile.StoreUint8(&o.ENDPT0.Reg, volatile.LoadUint8(&o.ENDPT0.Reg)&^(0x40)|value<<6)
}
func (o *USB0_Type) GetENDPT0_RETRYDIS() uint8 {
	return (volatile.LoadUint8(&o.ENDPT0.Reg) & 0x40) >> 6
}
func (o *USB0_Type) SetENDPT0_HOSTWOHUB(value uint8) {
	volatile.StoreUint8(&o.ENDPT0.Reg, volatile.LoadUint8(&o.ENDPT0.Reg)&^(0x80)|value<<7)
}
func (o *USB0_Type) GetENDPT0_HOSTWOHUB() uint8 {
	return (volatile.LoadUint8(&o.ENDPT0.Reg) & 0x80) >> 7
}

// USB0.ENDPT1: Endpoint Control register
func (o *USB0_Type) SetENDPT1_EPHSHK(value uint8) {
	volatile.StoreUint8(&o.ENDPT1.Reg, volatile.LoadUint8(&o.ENDPT1.Reg)&^(0x1)|value)
}
func (o *USB0_Type) GetENDPT1_EPHSHK() uint8 {
	return volatile.LoadUint8(&o.ENDPT1.Reg) & 0x1
}
func (o *USB0_Type) SetENDPT1_EPSTALL(value uint8) {
	volatile.StoreUint8(&o.ENDPT1.Reg, volatile.LoadUint8(&o.ENDPT1.Reg)&^(0x2)|value<<1)
}
func (o *USB0_Type) GetENDPT1_EPSTALL() uint8 {
	return (volatile.LoadUint8(&o.ENDPT1.Reg) & 0x2) >> 1
}
func (o *USB0_Type) SetENDPT1_EPTXEN(value uint8) {
	volatile.StoreUint8(&o.ENDPT1.Reg, volatile.LoadUint8(&o.ENDPT1.Reg)&^(0x4)|value<<2)
}
func (o *USB0_Type) GetENDPT1_EPTXEN() uint8 {
	return (volatile.LoadUint8(&o.ENDPT1.Reg) & 0x4) >> 2
}
func (o *USB0_Type) SetENDPT1_EPRXEN(value uint8) {
	volatile.StoreUint8(&o.ENDPT1.Reg, volatile.LoadUint8(&o.ENDPT1.Reg)&^(0x8)|value<<3)
}
func (o *USB0_Type) GetENDPT1_EPRXEN() uint8 {
	return (volatile.LoadUint8(&o.ENDPT1.Reg) & 0x8) >> 3
}
func (o *USB0_Type) SetENDPT1_EPCTLDIS(value uint8) {
	volatile.StoreUint8(&o.ENDPT1.Reg, volatile.LoadUint8(&o.ENDPT1.Reg)&^(0x10)|value<<4)
}
func (o *USB0_Type) GetENDPT1_EPCTLDIS() uint8 {
	return (volatile.LoadUint8(&o.ENDPT1.Reg) & 0x10) >> 4
}
func (o *USB0_Type) SetENDPT1_RETRYDIS(value uint8) {
	volatile.StoreUint8(&o.ENDPT1.Reg, volatile.LoadUint8(&o.ENDPT1.Reg)&^(0x40)|value<<6)
}
func (o *USB0_Type) GetENDPT1_RETRYDIS() uint8 {
	return (volatile.LoadUint8(&o.ENDPT1.Reg) & 0x40) >> 6
}
func (o *USB0_Type) SetENDPT1_HOSTWOHUB(value uint8) {
	volatile.StoreUint8(&o.ENDPT1.Reg, volatile.LoadUint8(&o.ENDPT1.Reg)&^(0x80)|value<<7)
}
func (o *USB0_Type) GetENDPT1_HOSTWOHUB() uint8 {
	return (volatile.LoadUint8(&o.ENDPT1.Reg) & 0x80) >> 7
}

// USB0.ENDPT2: Endpoint Control register
func (o *USB0_Type) SetENDPT2_EPHSHK(value uint8) {
	volatile.StoreUint8(&o.ENDPT2.Reg, volatile.LoadUint8(&o.ENDPT2.Reg)&^(0x1)|value)
}
func (o *USB0_Type) GetENDPT2_EPHSHK() uint8 {
	return volatile.LoadUint8(&o.ENDPT2.Reg) & 0x1
}
func (o *USB0_Type) SetENDPT2_EPSTALL(value uint8) {
	volatile.StoreUint8(&o.ENDPT2.Reg, volatile.LoadUint8(&o.ENDPT2.Reg)&^(0x2)|value<<1)
}
func (o *USB0_Type) GetENDPT2_EPSTALL() uint8 {
	return (volatile.LoadUint8(&o.ENDPT2.Reg) & 0x2) >> 1
}
func (o *USB0_Type) SetENDPT2_EPTXEN(value uint8) {
	volatile.StoreUint8(&o.ENDPT2.Reg, volatile.LoadUint8(&o.ENDPT2.Reg)&^(0x4)|value<<2)
}
func (o *USB0_Type) GetENDPT2_EPTXEN() uint8 {
	return (volatile.LoadUint8(&o.ENDPT2.Reg) & 0x4) >> 2
}
func (o *USB0_Type) SetENDPT2_EPRXEN(value uint8) {
	volatile.StoreUint8(&o.ENDPT2.Reg, volatile.LoadUint8(&o.ENDPT2.Reg)&^(0x8)|value<<3)
}
func (o *USB0_Type) GetENDPT2_EPRXEN() uint8 {
	return (volatile.LoadUint8(&o.ENDPT2.Reg) & 0x8) >> 3
}
func (o *USB0_Type) SetENDPT2_EPCTLDIS(value uint8) {
	volatile.StoreUint8(&o.ENDPT2.Reg, volatile.LoadUint8(&o.ENDPT2.Reg)&^(0x10)|value<<4)
}
func (o *USB0_Type) GetENDPT2_EPCTLDIS() uint8 {
	return (volatile.LoadUint8(&o.ENDPT2.Reg) & 0x10) >> 4
}
func (o *USB0_Type) SetENDPT2_RETRYDIS(value uint8) {
	volatile.StoreUint8(&o.ENDPT2.Reg, volatile.LoadUint8(&o.ENDPT2.Reg)&^(0x40)|value<<6)
}
func (o *USB0_Type) GetENDPT2_RETRYDIS() uint8 {
	return (volatile.LoadUint8(&o.ENDPT2.Reg) & 0x40) >> 6
}
func (o *USB0_Type) SetENDPT2_HOSTWOHUB(value uint8) {
	volatile.StoreUint8(&o.ENDPT2.Reg, volatile.LoadUint8(&o.ENDPT2.Reg)&^(0x80)|value<<7)
}
func (o *USB0_Type) GetENDPT2_HOSTWOHUB() uint8 {
	return (volatile.LoadUint8(&o.ENDPT2.Reg) & 0x80) >> 7
}

// USB0.ENDPT3: Endpoint Control register
func (o *USB0_Type) SetENDPT3_EPHSHK(value uint8) {
	volatile.StoreUint8(&o.ENDPT3.Reg, volatile.LoadUint8(&o.ENDPT3.Reg)&^(0x1)|value)
}
func (o *USB0_Type) GetENDPT3_EPHSHK() uint8 {
	return volatile.LoadUint8(&o.ENDPT3.Reg) & 0x1
}
func (o *USB0_Type) SetENDPT3_EPSTALL(value uint8) {
	volatile.StoreUint8(&o.ENDPT3.Reg, volatile.LoadUint8(&o.ENDPT3.Reg)&^(0x2)|value<<1)
}
func (o *USB0_Type) GetENDPT3_EPSTALL() uint8 {
	return (volatile.LoadUint8(&o.ENDPT3.Reg) & 0x2) >> 1
}
func (o *USB0_Type) SetENDPT3_EPTXEN(value uint8) {
	volatile.StoreUint8(&o.ENDPT3.Reg, volatile.LoadUint8(&o.ENDPT3.Reg)&^(0x4)|value<<2)
}
func (o *USB0_Type) GetENDPT3_EPTXEN() uint8 {
	return (volatile.LoadUint8(&o.ENDPT3.Reg) & 0x4) >> 2
}
func (o *USB0_Type) SetENDPT3_EPRXEN(value uint8) {
	volatile.StoreUint8(&o.ENDPT3.Reg, volatile.LoadUint8(&o.ENDPT3.Reg)&^(0x8)|value<<3)
}
func (o *USB0_Type) GetENDPT3_EPRXEN() uint8 {
	return (volatile.LoadUint8(&o.ENDPT3.Reg) & 0x8) >> 3
}
func (o *USB0_Type) SetENDPT3_EPCTLDIS(value uint8) {
	volatile.StoreUint8(&o.ENDPT3.Reg, volatile.LoadUint8(&o.ENDPT3.Reg)&^(0x10)|value<<4)
}
func (o *USB0_Type) GetENDPT3_EPCTLDIS() uint8 {
	return (volatile.LoadUint8(&o.ENDPT3.Reg) & 0x10) >> 4
}
func (o *USB0_Type) SetENDPT3_RETRYDIS(value uint8) {
	volatile.StoreUint8(&o.ENDPT3.Reg, volatile.LoadUint8(&o.ENDPT3.Reg)&^(0x40)|value<<6)
}
func (o *USB0_Type) GetENDPT3_RETRYDIS() uint8 {
	return (volatile.LoadUint8(&o.ENDPT3.Reg) & 0x40) >> 6
}
func (o *USB0_Type) SetENDPT3_HOSTWOHUB(value uint8) {
	volatile.StoreUint8(&o.ENDPT3.Reg, volatile.LoadUint8(&o.ENDPT3.Reg)&^(0x80)|value<<7)
}
func (o *USB0_Type) GetENDPT3_HOSTWOHUB() uint8 {
	return (volatile.LoadUint8(&o.ENDPT3.Reg) & 0x80) >> 7
}

// USB0.ENDPT4: Endpoint Control register
func (o *USB0_Type) SetENDPT4_EPHSHK(value uint8) {
	volatile.StoreUint8(&o.ENDPT4.Reg, volatile.LoadUint8(&o.ENDPT4.Reg)&^(0x1)|value)
}
func (o *USB0_Type) GetENDPT4_EPHSHK() uint8 {
	return volatile.LoadUint8(&o.ENDPT4.Reg) & 0x1
}
func (o *USB0_Type) SetENDPT4_EPSTALL(value uint8) {
	volatile.StoreUint8(&o.ENDPT4.Reg, volatile.LoadUint8(&o.ENDPT4.Reg)&^(0x2)|value<<1)
}
func (o *USB0_Type) GetENDPT4_EPSTALL() uint8 {
	return (volatile.LoadUint8(&o.ENDPT4.Reg) & 0x2) >> 1
}
func (o *USB0_Type) SetENDPT4_EPTXEN(value uint8) {
	volatile.StoreUint8(&o.ENDPT4.Reg, volatile.LoadUint8(&o.ENDPT4.Reg)&^(0x4)|value<<2)
}
func (o *USB0_Type) GetENDPT4_EPTXEN() uint8 {
	return (volatile.LoadUint8(&o.ENDPT4.Reg) & 0x4) >> 2
}
func (o *USB0_Type) SetENDPT4_EPRXEN(value uint8) {
	volatile.StoreUint8(&o.ENDPT4.Reg, volatile.LoadUint8(&o.ENDPT4.Reg)&^(0x8)|value<<3)
}
func (o *USB0_Type) GetENDPT4_EPRXEN() uint8 {
	return (volatile.LoadUint8(&o.ENDPT4.Reg) & 0x8) >> 3
}
func (o *USB0_Type) SetENDPT4_EPCTLDIS(value uint8) {
	volatile.StoreUint8(&o.ENDPT4.Reg, volatile.LoadUint8(&o.ENDPT4.Reg)&^(0x10)|value<<4)
}
func (o *USB0_Type) GetENDPT4_EPCTLDIS() uint8 {
	return (volatile.LoadUint8(&o.ENDPT4.Reg) & 0x10) >> 4
}
func (o *USB0_Type) SetENDPT4_RETRYDIS(value uint8) {
	volatile.StoreUint8(&o.ENDPT4.Reg, volatile.LoadUint8(&o.ENDPT4.Reg)&^(0x40)|value<<6)
}
func (o *USB0_Type) GetENDPT4_RETRYDIS() uint8 {
	return (volatile.LoadUint8(&o.ENDPT4.Reg) & 0x40) >> 6
}
func (o *USB0_Type) SetENDPT4_HOSTWOHUB(value uint8) {
	volatile.StoreUint8(&o.ENDPT4.Reg, volatile.LoadUint8(&o.ENDPT4.Reg)&^(0x80)|value<<7)
}
func (o *USB0_Type) GetENDPT4_HOSTWOHUB() uint8 {
	return (volatile.LoadUint8(&o.ENDPT4.Reg) & 0x80) >> 7
}

// USB0.ENDPT5: Endpoint Control register
func (o *USB0_Type) SetENDPT5_EPHSHK(value uint8) {
	volatile.StoreUint8(&o.ENDPT5.Reg, volatile.LoadUint8(&o.ENDPT5.Reg)&^(0x1)|value)
}
func (o *USB0_Type) GetENDPT5_EPHSHK() uint8 {
	return volatile.LoadUint8(&o.ENDPT5.Reg) & 0x1
}
func (o *USB0_Type) SetENDPT5_EPSTALL(value uint8) {
	volatile.StoreUint8(&o.ENDPT5.Reg, volatile.LoadUint8(&o.ENDPT5.Reg)&^(0x2)|value<<1)
}
func (o *USB0_Type) GetENDPT5_EPSTALL() uint8 {
	return (volatile.LoadUint8(&o.ENDPT5.Reg) & 0x2) >> 1
}
func (o *USB0_Type) SetENDPT5_EPTXEN(value uint8) {
	volatile.StoreUint8(&o.ENDPT5.Reg, volatile.LoadUint8(&o.ENDPT5.Reg)&^(0x4)|value<<2)
}
func (o *USB0_Type) GetENDPT5_EPTXEN() uint8 {
	return (volatile.LoadUint8(&o.ENDPT5.Reg) & 0x4) >> 2
}
func (o *USB0_Type) SetENDPT5_EPRXEN(value uint8) {
	volatile.StoreUint8(&o.ENDPT5.Reg, volatile.LoadUint8(&o.ENDPT5.Reg)&^(0x8)|value<<3)
}
func (o *USB0_Type) GetENDPT5_EPRXEN() uint8 {
	return (volatile.LoadUint8(&o.ENDPT5.Reg) & 0x8) >> 3
}
func (o *USB0_Type) SetENDPT5_EPCTLDIS(value uint8) {
	volatile.StoreUint8(&o.ENDPT5.Reg, volatile.LoadUint8(&o.ENDPT5.Reg)&^(0x10)|value<<4)
}
func (o *USB0_Type) GetENDPT5_EPCTLDIS() uint8 {
	return (volatile.LoadUint8(&o.ENDPT5.Reg) & 0x10) >> 4
}
func (o *USB0_Type) SetENDPT5_RETRYDIS(value uint8) {
	volatile.StoreUint8(&o.ENDPT5.Reg, volatile.LoadUint8(&o.ENDPT5.Reg)&^(0x40)|value<<6)
}
func (o *USB0_Type) GetENDPT5_RETRYDIS() uint8 {
	return (volatile.LoadUint8(&o.ENDPT5.Reg) & 0x40) >> 6
}
func (o *USB0_Type) SetENDPT5_HOSTWOHUB(value uint8) {
	volatile.StoreUint8(&o.ENDPT5.Reg, volatile.LoadUint8(&o.ENDPT5.Reg)&^(0x80)|value<<7)
}
func (o *USB0_Type) GetENDPT5_HOSTWOHUB() uint8 {
	return (volatile.LoadUint8(&o.ENDPT5.Reg) & 0x80) >> 7
}

// USB0.ENDPT6: Endpoint Control register
func (o *USB0_Type) SetENDPT6_EPHSHK(value uint8) {
	volatile.StoreUint8(&o.ENDPT6.Reg, volatile.LoadUint8(&o.ENDPT6.Reg)&^(0x1)|value)
}
func (o *USB0_Type) GetENDPT6_EPHSHK() uint8 {
	return volatile.LoadUint8(&o.ENDPT6.Reg) & 0x1
}
func (o *USB0_Type) SetENDPT6_EPSTALL(value uint8) {
	volatile.StoreUint8(&o.ENDPT6.Reg, volatile.LoadUint8(&o.ENDPT6.Reg)&^(0x2)|value<<1)
}
func (o *USB0_Type) GetENDPT6_EPSTALL() uint8 {
	return (volatile.LoadUint8(&o.ENDPT6.Reg) & 0x2) >> 1
}
func (o *USB0_Type) SetENDPT6_EPTXEN(value uint8) {
	volatile.StoreUint8(&o.ENDPT6.Reg, volatile.LoadUint8(&o.ENDPT6.Reg)&^(0x4)|value<<2)
}
func (o *USB0_Type) GetENDPT6_EPTXEN() uint8 {
	return (volatile.LoadUint8(&o.ENDPT6.Reg) & 0x4) >> 2
}
func (o *USB0_Type) SetENDPT6_EPRXEN(value uint8) {
	volatile.StoreUint8(&o.ENDPT6.Reg, volatile.LoadUint8(&o.ENDPT6.Reg)&^(0x8)|value<<3)
}
func (o *USB0_Type) GetENDPT6_EPRXEN() uint8 {
	return (volatile.LoadUint8(&o.ENDPT6.Reg) & 0x8) >> 3
}
func (o *USB0_Type) SetENDPT6_EPCTLDIS(value uint8) {
	volatile.StoreUint8(&o.ENDPT6.Reg, volatile.LoadUint8(&o.ENDPT6.Reg)&^(0x10)|value<<4)
}
func (o *USB0_Type) GetENDPT6_EPCTLDIS() uint8 {
	return (volatile.LoadUint8(&o.ENDPT6.Reg) & 0x10) >> 4
}
func (o *USB0_Type) SetENDPT6_RETRYDIS(value uint8) {
	volatile.StoreUint8(&o.ENDPT6.Reg, volatile.LoadUint8(&o.ENDPT6.Reg)&^(0x40)|value<<6)
}
func (o *USB0_Type) GetENDPT6_RETRYDIS() uint8 {
	return (volatile.LoadUint8(&o.ENDPT6.Reg) & 0x40) >> 6
}
func (o *USB0_Type) SetENDPT6_HOSTWOHUB(value uint8) {
	volatile.StoreUint8(&o.ENDPT6.Reg, volatile.LoadUint8(&o.ENDPT6.Reg)&^(0x80)|value<<7)
}
func (o *USB0_Type) GetENDPT6_HOSTWOHUB() uint8 {
	return (volatile.LoadUint8(&o.ENDPT6.Reg) & 0x80) >> 7
}

// USB0.ENDPT7: Endpoint Control register
func (o *USB0_Type) SetENDPT7_EPHSHK(value uint8) {
	volatile.StoreUint8(&o.ENDPT7.Reg, volatile.LoadUint8(&o.ENDPT7.Reg)&^(0x1)|value)
}
func (o *USB0_Type) GetENDPT7_EPHSHK() uint8 {
	return volatile.LoadUint8(&o.ENDPT7.Reg) & 0x1
}
func (o *USB0_Type) SetENDPT7_EPSTALL(value uint8) {
	volatile.StoreUint8(&o.ENDPT7.Reg, volatile.LoadUint8(&o.ENDPT7.Reg)&^(0x2)|value<<1)
}
func (o *USB0_Type) GetENDPT7_EPSTALL() uint8 {
	return (volatile.LoadUint8(&o.ENDPT7.Reg) & 0x2) >> 1
}
func (o *USB0_Type) SetENDPT7_EPTXEN(value uint8) {
	volatile.StoreUint8(&o.ENDPT7.Reg, volatile.LoadUint8(&o.ENDPT7.Reg)&^(0x4)|value<<2)
}
func (o *USB0_Type) GetENDPT7_EPTXEN() uint8 {
	return (volatile.LoadUint8(&o.ENDPT7.Reg) & 0x4) >> 2
}
func (o *USB0_Type) SetENDPT7_EPRXEN(value uint8) {
	volatile.StoreUint8(&o.ENDPT7.Reg, volatile.LoadUint8(&o.ENDPT7.Reg)&^(0x8)|value<<3)
}
func (o *USB0_Type) GetENDPT7_EPRXEN() uint8 {
	return (volatile.LoadUint8(&o.ENDPT7.Reg) & 0x8) >> 3
}
func (o *USB0_Type) SetENDPT7_EPCTLDIS(value uint8) {
	volatile.StoreUint8(&o.ENDPT7.Reg, volatile.LoadUint8(&o.ENDPT7.Reg)&^(0x10)|value<<4)
}
func (o *USB0_Type) GetENDPT7_EPCTLDIS() uint8 {
	return (volatile.LoadUint8(&o.ENDPT7.Reg) & 0x10) >> 4
}
func (o *USB0_Type) SetENDPT7_RETRYDIS(value uint8) {
	volatile.StoreUint8(&o.ENDPT7.Reg, volatile.LoadUint8(&o.ENDPT7.Reg)&^(0x40)|value<<6)
}
func (o *USB0_Type) GetENDPT7_RETRYDIS() uint8 {
	return (volatile.LoadUint8(&o.ENDPT7.Reg) & 0x40) >> 6
}
func (o *USB0_Type) SetENDPT7_HOSTWOHUB(value uint8) {
	volatile.StoreUint8(&o.ENDPT7.Reg, volatile.LoadUint8(&o.ENDPT7.Reg)&^(0x80)|value<<7)
}
func (o *USB0_Type) GetENDPT7_HOSTWOHUB() uint8 {
	return (volatile.LoadUint8(&o.ENDPT7.Reg) & 0x80) >> 7
}

// USB0.ENDPT8: Endpoint Control register
func (o *USB0_Type) SetENDPT8_EPHSHK(value uint8) {
	volatile.StoreUint8(&o.ENDPT8.Reg, volatile.LoadUint8(&o.ENDPT8.Reg)&^(0x1)|value)
}
func (o *USB0_Type) GetENDPT8_EPHSHK() uint8 {
	return volatile.LoadUint8(&o.ENDPT8.Reg) & 0x1
}
func (o *USB0_Type) SetENDPT8_EPSTALL(value uint8) {
	volatile.StoreUint8(&o.ENDPT8.Reg, volatile.LoadUint8(&o.ENDPT8.Reg)&^(0x2)|value<<1)
}
func (o *USB0_Type) GetENDPT8_EPSTALL() uint8 {
	return (volatile.LoadUint8(&o.ENDPT8.Reg) & 0x2) >> 1
}
func (o *USB0_Type) SetENDPT8_EPTXEN(value uint8) {
	volatile.StoreUint8(&o.ENDPT8.Reg, volatile.LoadUint8(&o.ENDPT8.Reg)&^(0x4)|value<<2)
}
func (o *USB0_Type) GetENDPT8_EPTXEN() uint8 {
	return (volatile.LoadUint8(&o.ENDPT8.Reg) & 0x4) >> 2
}
func (o *USB0_Type) SetENDPT8_EPRXEN(value uint8) {
	volatile.StoreUint8(&o.ENDPT8.Reg, volatile.LoadUint8(&o.ENDPT8.Reg)&^(0x8)|value<<3)
}
func (o *USB0_Type) GetENDPT8_EPRXEN() uint8 {
	return (volatile.LoadUint8(&o.ENDPT8.Reg) & 0x8) >> 3
}
func (o *USB0_Type) SetENDPT8_EPCTLDIS(value uint8) {
	volatile.StoreUint8(&o.ENDPT8.Reg, volatile.LoadUint8(&o.ENDPT8.Reg)&^(0x10)|value<<4)
}
func (o *USB0_Type) GetENDPT8_EPCTLDIS() uint8 {
	return (volatile.LoadUint8(&o.ENDPT8.Reg) & 0x10) >> 4
}
func (o *USB0_Type) SetENDPT8_RETRYDIS(value uint8) {
	volatile.StoreUint8(&o.ENDPT8.Reg, volatile.LoadUint8(&o.ENDPT8.Reg)&^(0x40)|value<<6)
}
func (o *USB0_Type) GetENDPT8_RETRYDIS() uint8 {
	return (volatile.LoadUint8(&o.ENDPT8.Reg) & 0x40) >> 6
}
func (o *USB0_Type) SetENDPT8_HOSTWOHUB(value uint8) {
	volatile.StoreUint8(&o.ENDPT8.Reg, volatile.LoadUint8(&o.ENDPT8.Reg)&^(0x80)|value<<7)
}
func (o *USB0_Type) GetENDPT8_HOSTWOHUB() uint8 {
	return (volatile.LoadUint8(&o.ENDPT8.Reg) & 0x80) >> 7
}

// USB0.ENDPT9: Endpoint Control register
func (o *USB0_Type) SetENDPT9_EPHSHK(value uint8) {
	volatile.StoreUint8(&o.ENDPT9.Reg, volatile.LoadUint8(&o.ENDPT9.Reg)&^(0x1)|value)
}
func (o *USB0_Type) GetENDPT9_EPHSHK() uint8 {
	return volatile.LoadUint8(&o.ENDPT9.Reg) & 0x1
}
func (o *USB0_Type) SetENDPT9_EPSTALL(value uint8) {
	volatile.StoreUint8(&o.ENDPT9.Reg, volatile.LoadUint8(&o.ENDPT9.Reg)&^(0x2)|value<<1)
}
func (o *USB0_Type) GetENDPT9_EPSTALL() uint8 {
	return (volatile.LoadUint8(&o.ENDPT9.Reg) & 0x2) >> 1
}
func (o *USB0_Type) SetENDPT9_EPTXEN(value uint8) {
	volatile.StoreUint8(&o.ENDPT9.Reg, volatile.LoadUint8(&o.ENDPT9.Reg)&^(0x4)|value<<2)
}
func (o *USB0_Type) GetENDPT9_EPTXEN() uint8 {
	return (volatile.LoadUint8(&o.ENDPT9.Reg) & 0x4) >> 2
}
func (o *USB0_Type) SetENDPT9_EPRXEN(value uint8) {
	volatile.StoreUint8(&o.ENDPT9.Reg, volatile.LoadUint8(&o.ENDPT9.Reg)&^(0x8)|value<<3)
}
func (o *USB0_Type) GetENDPT9_EPRXEN() uint8 {
	return (volatile.LoadUint8(&o.ENDPT9.Reg) & 0x8) >> 3
}
func (o *USB0_Type) SetENDPT9_EPCTLDIS(value uint8) {
	volatile.StoreUint8(&o.ENDPT9.Reg, volatile.LoadUint8(&o.ENDPT9.Reg)&^(0x10)|value<<4)
}
func (o *USB0_Type) GetENDPT9_EPCTLDIS() uint8 {
	return (volatile.LoadUint8(&o.ENDPT9.Reg) & 0x10) >> 4
}
func (o *USB0_Type) SetENDPT9_RETRYDIS(value uint8) {
	volatile.StoreUint8(&o.ENDPT9.Reg, volatile.LoadUint8(&o.ENDPT9.Reg)&^(0x40)|value<<6)
}
func (o *USB0_Type) GetENDPT9_RETRYDIS() uint8 {
	return (volatile.LoadUint8(&o.ENDPT9.Reg) & 0x40) >> 6
}
func (o *USB0_Type) SetENDPT9_HOSTWOHUB(value uint8) {
	volatile.StoreUint8(&o.ENDPT9.Reg, volatile.LoadUint8(&o.ENDPT9.Reg)&^(0x80)|value<<7)
}
func (o *USB0_Type) GetENDPT9_HOSTWOHUB() uint8 {
	return (volatile.LoadUint8(&o.ENDPT9.Reg) & 0x80) >> 7
}

// USB0.ENDPT10: Endpoint Control register
func (o *USB0_Type) SetENDPT10_EPHSHK(value uint8) {
	volatile.StoreUint8(&o.ENDPT10.Reg, volatile.LoadUint8(&o.ENDPT10.Reg)&^(0x1)|value)
}
func (o *USB0_Type) GetENDPT10_EPHSHK() uint8 {
	return volatile.LoadUint8(&o.ENDPT10.Reg) & 0x1
}
func (o *USB0_Type) SetENDPT10_EPSTALL(value uint8) {
	volatile.StoreUint8(&o.ENDPT10.Reg, volatile.LoadUint8(&o.ENDPT10.Reg)&^(0x2)|value<<1)
}
func (o *USB0_Type) GetENDPT10_EPSTALL() uint8 {
	return (volatile.LoadUint8(&o.ENDPT10.Reg) & 0x2) >> 1
}
func (o *USB0_Type) SetENDPT10_EPTXEN(value uint8) {
	volatile.StoreUint8(&o.ENDPT10.Reg, volatile.LoadUint8(&o.ENDPT10.Reg)&^(0x4)|value<<2)
}
func (o *USB0_Type) GetENDPT10_EPTXEN() uint8 {
	return (volatile.LoadUint8(&o.ENDPT10.Reg) & 0x4) >> 2
}
func (o *USB0_Type) SetENDPT10_EPRXEN(value uint8) {
	volatile.StoreUint8(&o.ENDPT10.Reg, volatile.LoadUint8(&o.ENDPT10.Reg)&^(0x8)|value<<3)
}
func (o *USB0_Type) GetENDPT10_EPRXEN() uint8 {
	return (volatile.LoadUint8(&o.ENDPT10.Reg) & 0x8) >> 3
}
func (o *USB0_Type) SetENDPT10_EPCTLDIS(value uint8) {
	volatile.StoreUint8(&o.ENDPT10.Reg, volatile.LoadUint8(&o.ENDPT10.Reg)&^(0x10)|value<<4)
}
func (o *USB0_Type) GetENDPT10_EPCTLDIS() uint8 {
	return (volatile.LoadUint8(&o.ENDPT10.Reg) & 0x10) >> 4
}
func (o *USB0_Type) SetENDPT10_RETRYDIS(value uint8) {
	volatile.StoreUint8(&o.ENDPT10.Reg, volatile.LoadUint8(&o.ENDPT10.Reg)&^(0x40)|value<<6)
}
func (o *USB0_Type) GetENDPT10_RETRYDIS() uint8 {
	return (volatile.LoadUint8(&o.ENDPT10.Reg) & 0x40) >> 6
}
func (o *USB0_Type) SetENDPT10_HOSTWOHUB(value uint8) {
	volatile.StoreUint8(&o.ENDPT10.Reg, volatile.LoadUint8(&o.ENDPT10.Reg)&^(0x80)|value<<7)
}
func (o *USB0_Type) GetENDPT10_HOSTWOHUB() uint8 {
	return (volatile.LoadUint8(&o.ENDPT10.Reg) & 0x80) >> 7
}

// USB0.ENDPT11: Endpoint Control register
func (o *USB0_Type) SetENDPT11_EPHSHK(value uint8) {
	volatile.StoreUint8(&o.ENDPT11.Reg, volatile.LoadUint8(&o.ENDPT11.Reg)&^(0x1)|value)
}
func (o *USB0_Type) GetENDPT11_EPHSHK() uint8 {
	return volatile.LoadUint8(&o.ENDPT11.Reg) & 0x1
}
func (o *USB0_Type) SetENDPT11_EPSTALL(value uint8) {
	volatile.StoreUint8(&o.ENDPT11.Reg, volatile.LoadUint8(&o.ENDPT11.Reg)&^(0x2)|value<<1)
}
func (o *USB0_Type) GetENDPT11_EPSTALL() uint8 {
	return (volatile.LoadUint8(&o.ENDPT11.Reg) & 0x2) >> 1
}
func (o *USB0_Type) SetENDPT11_EPTXEN(value uint8) {
	volatile.StoreUint8(&o.ENDPT11.Reg, volatile.LoadUint8(&o.ENDPT11.Reg)&^(0x4)|value<<2)
}
func (o *USB0_Type) GetENDPT11_EPTXEN() uint8 {
	return (volatile.LoadUint8(&o.ENDPT11.Reg) & 0x4) >> 2
}
func (o *USB0_Type) SetENDPT11_EPRXEN(value uint8) {
	volatile.StoreUint8(&o.ENDPT11.Reg, volatile.LoadUint8(&o.ENDPT11.Reg)&^(0x8)|value<<3)
}
func (o *USB0_Type) GetENDPT11_EPRXEN() uint8 {
	return (volatile.LoadUint8(&o.ENDPT11.Reg) & 0x8) >> 3
}
func (o *USB0_Type) SetENDPT11_EPCTLDIS(value uint8) {
	volatile.StoreUint8(&o.ENDPT11.Reg, volatile.LoadUint8(&o.ENDPT11.Reg)&^(0x10)|value<<4)
}
func (o *USB0_Type) GetENDPT11_EPCTLDIS() uint8 {
	return (volatile.LoadUint8(&o.ENDPT11.Reg) & 0x10) >> 4
}
func (o *USB0_Type) SetENDPT11_RETRYDIS(value uint8) {
	volatile.StoreUint8(&o.ENDPT11.Reg, volatile.LoadUint8(&o.ENDPT11.Reg)&^(0x40)|value<<6)
}
func (o *USB0_Type) GetENDPT11_RETRYDIS() uint8 {
	return (volatile.LoadUint8(&o.ENDPT11.Reg) & 0x40) >> 6
}
func (o *USB0_Type) SetENDPT11_HOSTWOHUB(value uint8) {
	volatile.StoreUint8(&o.ENDPT11.Reg, volatile.LoadUint8(&o.ENDPT11.Reg)&^(0x80)|value<<7)
}
func (o *USB0_Type) GetENDPT11_HOSTWOHUB() uint8 {
	return (volatile.LoadUint8(&o.ENDPT11.Reg) & 0x80) >> 7
}

// USB0.ENDPT12: Endpoint Control register
func (o *USB0_Type) SetENDPT12_EPHSHK(value uint8) {
	volatile.StoreUint8(&o.ENDPT12.Reg, volatile.LoadUint8(&o.ENDPT12.Reg)&^(0x1)|value)
}
func (o *USB0_Type) GetENDPT12_EPHSHK() uint8 {
	return volatile.LoadUint8(&o.ENDPT12.Reg) & 0x1
}
func (o *USB0_Type) SetENDPT12_EPSTALL(value uint8) {
	volatile.StoreUint8(&o.ENDPT12.Reg, volatile.LoadUint8(&o.ENDPT12.Reg)&^(0x2)|value<<1)
}
func (o *USB0_Type) GetENDPT12_EPSTALL() uint8 {
	return (volatile.LoadUint8(&o.ENDPT12.Reg) & 0x2) >> 1
}
func (o *USB0_Type) SetENDPT12_EPTXEN(value uint8) {
	volatile.StoreUint8(&o.ENDPT12.Reg, volatile.LoadUint8(&o.ENDPT12.Reg)&^(0x4)|value<<2)
}
func (o *USB0_Type) GetENDPT12_EPTXEN() uint8 {
	return (volatile.LoadUint8(&o.ENDPT12.Reg) & 0x4) >> 2
}
func (o *USB0_Type) SetENDPT12_EPRXEN(value uint8) {
	volatile.StoreUint8(&o.ENDPT12.Reg, volatile.LoadUint8(&o.ENDPT12.Reg)&^(0x8)|value<<3)
}
func (o *USB0_Type) GetENDPT12_EPRXEN() uint8 {
	return (volatile.LoadUint8(&o.ENDPT12.Reg) & 0x8) >> 3
}
func (o *USB0_Type) SetENDPT12_EPCTLDIS(value uint8) {
	volatile.StoreUint8(&o.ENDPT12.Reg, volatile.LoadUint8(&o.ENDPT12.Reg)&^(0x10)|value<<4)
}
func (o *USB0_Type) GetENDPT12_EPCTLDIS() uint8 {
	return (volatile.LoadUint8(&o.ENDPT12.Reg) & 0x10) >> 4
}
func (o *USB0_Type) SetENDPT12_RETRYDIS(value uint8) {
	volatile.StoreUint8(&o.ENDPT12.Reg, volatile.LoadUint8(&o.ENDPT12.Reg)&^(0x40)|value<<6)
}
func (o *USB0_Type) GetENDPT12_RETRYDIS() uint8 {
	return (volatile.LoadUint8(&o.ENDPT12.Reg) & 0x40) >> 6
}
func (o *USB0_Type) SetENDPT12_HOSTWOHUB(value uint8) {
	volatile.StoreUint8(&o.ENDPT12.Reg, volatile.LoadUint8(&o.ENDPT12.Reg)&^(0x80)|value<<7)
}
func (o *USB0_Type) GetENDPT12_HOSTWOHUB() uint8 {
	return (volatile.LoadUint8(&o.ENDPT12.Reg) & 0x80) >> 7
}

// USB0.ENDPT13: Endpoint Control register
func (o *USB0_Type) SetENDPT13_EPHSHK(value uint8) {
	volatile.StoreUint8(&o.ENDPT13.Reg, volatile.LoadUint8(&o.ENDPT13.Reg)&^(0x1)|value)
}
func (o *USB0_Type) GetENDPT13_EPHSHK() uint8 {
	return volatile.LoadUint8(&o.ENDPT13.Reg) & 0x1
}
func (o *USB0_Type) SetENDPT13_EPSTALL(value uint8) {
	volatile.StoreUint8(&o.ENDPT13.Reg, volatile.LoadUint8(&o.ENDPT13.Reg)&^(0x2)|value<<1)
}
func (o *USB0_Type) GetENDPT13_EPSTALL() uint8 {
	return (volatile.LoadUint8(&o.ENDPT13.Reg) & 0x2) >> 1
}
func (o *USB0_Type) SetENDPT13_EPTXEN(value uint8) {
	volatile.StoreUint8(&o.ENDPT13.Reg, volatile.LoadUint8(&o.ENDPT13.Reg)&^(0x4)|value<<2)
}
func (o *USB0_Type) GetENDPT13_EPTXEN() uint8 {
	return (volatile.LoadUint8(&o.ENDPT13.Reg) & 0x4) >> 2
}
func (o *USB0_Type) SetENDPT13_EPRXEN(value uint8) {
	volatile.StoreUint8(&o.ENDPT13.Reg, volatile.LoadUint8(&o.ENDPT13.Reg)&^(0x8)|value<<3)
}
func (o *USB0_Type) GetENDPT13_EPRXEN() uint8 {
	return (volatile.LoadUint8(&o.ENDPT13.Reg) & 0x8) >> 3
}
func (o *USB0_Type) SetENDPT13_EPCTLDIS(value uint8) {
	volatile.StoreUint8(&o.ENDPT13.Reg, volatile.LoadUint8(&o.ENDPT13.Reg)&^(0x10)|value<<4)
}
func (o *USB0_Type) GetENDPT13_EPCTLDIS() uint8 {
	return (volatile.LoadUint8(&o.ENDPT13.Reg) & 0x10) >> 4
}
func (o *USB0_Type) SetENDPT13_RETRYDIS(value uint8) {
	volatile.StoreUint8(&o.ENDPT13.Reg, volatile.LoadUint8(&o.ENDPT13.Reg)&^(0x40)|value<<6)
}
func (o *USB0_Type) GetENDPT13_RETRYDIS() uint8 {
	return (volatile.LoadUint8(&o.ENDPT13.Reg) & 0x40) >> 6
}
func (o *USB0_Type) SetENDPT13_HOSTWOHUB(value uint8) {
	volatile.StoreUint8(&o.ENDPT13.Reg, volatile.LoadUint8(&o.ENDPT13.Reg)&^(0x80)|value<<7)
}
func (o *USB0_Type) GetENDPT13_HOSTWOHUB() uint8 {
	return (volatile.LoadUint8(&o.ENDPT13.Reg) & 0x80) >> 7
}

// USB0.ENDPT14: Endpoint Control register
func (o *USB0_Type) SetENDPT14_EPHSHK(value uint8) {
	volatile.StoreUint8(&o.ENDPT14.Reg, volatile.LoadUint8(&o.ENDPT14.Reg)&^(0x1)|value)
}
func (o *USB0_Type) GetENDPT14_EPHSHK() uint8 {
	return volatile.LoadUint8(&o.ENDPT14.Reg) & 0x1
}
func (o *USB0_Type) SetENDPT14_EPSTALL(value uint8) {
	volatile.StoreUint8(&o.ENDPT14.Reg, volatile.LoadUint8(&o.ENDPT14.Reg)&^(0x2)|value<<1)
}
func (o *USB0_Type) GetENDPT14_EPSTALL() uint8 {
	return (volatile.LoadUint8(&o.ENDPT14.Reg) & 0x2) >> 1
}
func (o *USB0_Type) SetENDPT14_EPTXEN(value uint8) {
	volatile.StoreUint8(&o.ENDPT14.Reg, volatile.LoadUint8(&o.ENDPT14.Reg)&^(0x4)|value<<2)
}
func (o *USB0_Type) GetENDPT14_EPTXEN() uint8 {
	return (volatile.LoadUint8(&o.ENDPT14.Reg) & 0x4) >> 2
}
func (o *USB0_Type) SetENDPT14_EPRXEN(value uint8) {
	volatile.StoreUint8(&o.ENDPT14.Reg, volatile.LoadUint8(&o.ENDPT14.Reg)&^(0x8)|value<<3)
}
func (o *USB0_Type) GetENDPT14_EPRXEN() uint8 {
	return (volatile.LoadUint8(&o.ENDPT14.Reg) & 0x8) >> 3
}
func (o *USB0_Type) SetENDPT14_EPCTLDIS(value uint8) {
	volatile.StoreUint8(&o.ENDPT14.Reg, volatile.LoadUint8(&o.ENDPT14.Reg)&^(0x10)|value<<4)
}
func (o *USB0_Type) GetENDPT14_EPCTLDIS() uint8 {
	return (volatile.LoadUint8(&o.ENDPT14.Reg) & 0x10) >> 4
}
func (o *USB0_Type) SetENDPT14_RETRYDIS(value uint8) {
	volatile.StoreUint8(&o.ENDPT14.Reg, volatile.LoadUint8(&o.ENDPT14.Reg)&^(0x40)|value<<6)
}
func (o *USB0_Type) GetENDPT14_RETRYDIS() uint8 {
	return (volatile.LoadUint8(&o.ENDPT14.Reg) & 0x40) >> 6
}
func (o *USB0_Type) SetENDPT14_HOSTWOHUB(value uint8) {
	volatile.StoreUint8(&o.ENDPT14.Reg, volatile.LoadUint8(&o.ENDPT14.Reg)&^(0x80)|value<<7)
}
func (o *USB0_Type) GetENDPT14_HOSTWOHUB() uint8 {
	return (volatile.LoadUint8(&o.ENDPT14.Reg) & 0x80) >> 7
}

// USB0.ENDPT15: Endpoint Control register
func (o *USB0_Type) SetENDPT15_EPHSHK(value uint8) {
	volatile.StoreUint8(&o.ENDPT15.Reg, volatile.LoadUint8(&o.ENDPT15.Reg)&^(0x1)|value)
}
func (o *USB0_Type) GetENDPT15_EPHSHK() uint8 {
	return volatile.LoadUint8(&o.ENDPT15.Reg) & 0x1
}
func (o *USB0_Type) SetENDPT15_EPSTALL(value uint8) {
	volatile.StoreUint8(&o.ENDPT15.Reg, volatile.LoadUint8(&o.ENDPT15.Reg)&^(0x2)|value<<1)
}
func (o *USB0_Type) GetENDPT15_EPSTALL() uint8 {
	return (volatile.LoadUint8(&o.ENDPT15.Reg) & 0x2) >> 1
}
func (o *USB0_Type) SetENDPT15_EPTXEN(value uint8) {
	volatile.StoreUint8(&o.ENDPT15.Reg, volatile.LoadUint8(&o.ENDPT15.Reg)&^(0x4)|value<<2)
}
func (o *USB0_Type) GetENDPT15_EPTXEN() uint8 {
	return (volatile.LoadUint8(&o.ENDPT15.Reg) & 0x4) >> 2
}
func (o *USB0_Type) SetENDPT15_EPRXEN(value uint8) {
	volatile.StoreUint8(&o.ENDPT15.Reg, volatile.LoadUint8(&o.ENDPT15.Reg)&^(0x8)|value<<3)
}
func (o *USB0_Type) GetENDPT15_EPRXEN() uint8 {
	return (volatile.LoadUint8(&o.ENDPT15.Reg) & 0x8) >> 3
}
func (o *USB0_Type) SetENDPT15_EPCTLDIS(value uint8) {
	volatile.StoreUint8(&o.ENDPT15.Reg, volatile.LoadUint8(&o.ENDPT15.Reg)&^(0x10)|value<<4)
}
func (o *USB0_Type) GetENDPT15_EPCTLDIS() uint8 {
	return (volatile.LoadUint8(&o.ENDPT15.Reg) & 0x10) >> 4
}
func (o *USB0_Type) SetENDPT15_RETRYDIS(value uint8) {
	volatile.StoreUint8(&o.ENDPT15.Reg, volatile.LoadUint8(&o.ENDPT15.Reg)&^(0x40)|value<<6)
}
func (o *USB0_Type) GetENDPT15_RETRYDIS() uint8 {
	return (volatile.LoadUint8(&o.ENDPT15.Reg) & 0x40) >> 6
}
func (o *USB0_Type) SetENDPT15_HOSTWOHUB(value uint8) {
	volatile.StoreUint8(&o.ENDPT15.Reg, volatile.LoadUint8(&o.ENDPT15.Reg)&^(0x80)|value<<7)
}
func (o *USB0_Type) GetENDPT15_HOSTWOHUB() uint8 {
	return (volatile.LoadUint8(&o.ENDPT15.Reg) & 0x80) >> 7
}

// USB0.USBCTRL: USB Control register
func (o *USB0_Type) SetUSBCTRL_PDE(value uint8) {
	volatile.StoreUint8(&o.USBCTRL.Reg, volatile.LoadUint8(&o.USBCTRL.Reg)&^(0x40)|value<<6)
}
func (o *USB0_Type) GetUSBCTRL_PDE() uint8 {
	return (volatile.LoadUint8(&o.USBCTRL.Reg) & 0x40) >> 6
}
func (o *USB0_Type) SetUSBCTRL_SUSP(value uint8) {
	volatile.StoreUint8(&o.USBCTRL.Reg, volatile.LoadUint8(&o.USBCTRL.Reg)&^(0x80)|value<<7)
}
func (o *USB0_Type) GetUSBCTRL_SUSP() uint8 {
	return (volatile.LoadUint8(&o.USBCTRL.Reg) & 0x80) >> 7
}

// USB0.OBSERVE: USB OTG Observe register
func (o *USB0_Type) SetOBSERVE_DMPD(value uint8) {
	volatile.StoreUint8(&o.OBSERVE.Reg, volatile.LoadUint8(&o.OBSERVE.Reg)&^(0x10)|value<<4)
}
func (o *USB0_Type) GetOBSERVE_DMPD() uint8 {
	return (volatile.LoadUint8(&o.OBSERVE.Reg) & 0x10) >> 4
}
func (o *USB0_Type) SetOBSERVE_DPPD(value uint8) {
	volatile.StoreUint8(&o.OBSERVE.Reg, volatile.LoadUint8(&o.OBSERVE.Reg)&^(0x40)|value<<6)
}
func (o *USB0_Type) GetOBSERVE_DPPD() uint8 {
	return (volatile.LoadUint8(&o.OBSERVE.Reg) & 0x40) >> 6
}
func (o *USB0_Type) SetOBSERVE_DPPU(value uint8) {
	volatile.StoreUint8(&o.OBSERVE.Reg, volatile.LoadUint8(&o.OBSERVE.Reg)&^(0x80)|value<<7)
}
func (o *USB0_Type) GetOBSERVE_DPPU() uint8 {
	return (volatile.LoadUint8(&o.OBSERVE.Reg) & 0x80) >> 7
}

// USB0.CONTROL: USB OTG Control register
func (o *USB0_Type) SetCONTROL_DPPULLUPNONOTG(value uint8) {
	volatile.StoreUint8(&o.CONTROL.Reg, volatile.LoadUint8(&o.CONTROL.Reg)&^(0x10)|value<<4)
}
func (o *USB0_Type) GetCONTROL_DPPULLUPNONOTG() uint8 {
	return (volatile.LoadUint8(&o.CONTROL.Reg) & 0x10) >> 4
}

// USB0.USBTRC0: USB Transceiver Control register 0
func (o *USB0_Type) SetUSBTRC0_USB_RESUME_INT(value uint8) {
	volatile.StoreUint8(&o.USBTRC0.Reg, volatile.LoadUint8(&o.USBTRC0.Reg)&^(0x1)|value)
}
func (o *USB0_Type) GetUSBTRC0_USB_RESUME_INT() uint8 {
	return volatile.LoadUint8(&o.USBTRC0.Reg) & 0x1
}
func (o *USB0_Type) SetUSBTRC0_SYNC_DET(value uint8) {
	volatile.StoreUint8(&o.USBTRC0.Reg, volatile.LoadUint8(&o.USBTRC0.Reg)&^(0x2)|value<<1)
}
func (o *USB0_Type) GetUSBTRC0_SYNC_DET() uint8 {
	return (volatile.LoadUint8(&o.USBTRC0.Reg) & 0x2) >> 1
}
func (o *USB0_Type) SetUSBTRC0_USB_CLK_RECOVERY_INT(value uint8) {
	volatile.StoreUint8(&o.USBTRC0.Reg, volatile.LoadUint8(&o.USBTRC0.Reg)&^(0x4)|value<<2)
}
func (o *USB0_Type) GetUSBTRC0_USB_CLK_RECOVERY_INT() uint8 {
	return (volatile.LoadUint8(&o.USBTRC0.Reg) & 0x4) >> 2
}
func (o *USB0_Type) SetUSBTRC0_USBRESMEN(value uint8) {
	volatile.StoreUint8(&o.USBTRC0.Reg, volatile.LoadUint8(&o.USBTRC0.Reg)&^(0x20)|value<<5)
}
func (o *USB0_Type) GetUSBTRC0_USBRESMEN() uint8 {
	return (volatile.LoadUint8(&o.USBTRC0.Reg) & 0x20) >> 5
}
func (o *USB0_Type) SetUSBTRC0_USBRESET(value uint8) {
	volatile.StoreUint8(&o.USBTRC0.Reg, volatile.LoadUint8(&o.USBTRC0.Reg)&^(0x80)|value<<7)
}
func (o *USB0_Type) GetUSBTRC0_USBRESET() uint8 {
	return (volatile.LoadUint8(&o.USBTRC0.Reg) & 0x80) >> 7
}

// USB0.USBFRMADJUST: Frame Adjust Register
func (o *USB0_Type) SetUSBFRMADJUST(value uint8) {
	volatile.StoreUint8(&o.USBFRMADJUST.Reg, value)
}
func (o *USB0_Type) GetUSBFRMADJUST() uint8 {
	return volatile.LoadUint8(&o.USBFRMADJUST.Reg)
}

// USB0.CLK_RECOVER_CTRL: USB Clock recovery control
func (o *USB0_Type) SetCLK_RECOVER_CTRL_RESTART_IFRTRIM_EN(value uint8) {
	volatile.StoreUint8(&o.CLK_RECOVER_CTRL.Reg, volatile.LoadUint8(&o.CLK_RECOVER_CTRL.Reg)&^(0x20)|value<<5)
}
func (o *USB0_Type) GetCLK_RECOVER_CTRL_RESTART_IFRTRIM_EN() uint8 {
	return (volatile.LoadUint8(&o.CLK_RECOVER_CTRL.Reg) & 0x20) >> 5
}
func (o *USB0_Type) SetCLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN(value uint8) {
	volatile.StoreUint8(&o.CLK_RECOVER_CTRL.Reg, volatile.LoadUint8(&o.CLK_RECOVER_CTRL.Reg)&^(0x40)|value<<6)
}
func (o *USB0_Type) GetCLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN() uint8 {
	return (volatile.LoadUint8(&o.CLK_RECOVER_CTRL.Reg) & 0x40) >> 6
}
func (o *USB0_Type) SetCLK_RECOVER_CTRL_CLOCK_RECOVER_EN(value uint8) {
	volatile.StoreUint8(&o.CLK_RECOVER_CTRL.Reg, volatile.LoadUint8(&o.CLK_RECOVER_CTRL.Reg)&^(0x80)|value<<7)
}
func (o *USB0_Type) GetCLK_RECOVER_CTRL_CLOCK_RECOVER_EN() uint8 {
	return (volatile.LoadUint8(&o.CLK_RECOVER_CTRL.Reg) & 0x80) >> 7
}

// USB0.CLK_RECOVER_IRC_EN: IRC48M oscillator enable register
func (o *USB0_Type) SetCLK_RECOVER_IRC_EN_REG_EN(value uint8) {
	volatile.StoreUint8(&o.CLK_RECOVER_IRC_EN.Reg, volatile.LoadUint8(&o.CLK_RECOVER_IRC_EN.Reg)&^(0x1)|value)
}
func (o *USB0_Type) GetCLK_RECOVER_IRC_EN_REG_EN() uint8 {
	return volatile.LoadUint8(&o.CLK_RECOVER_IRC_EN.Reg) & 0x1
}
func (o *USB0_Type) SetCLK_RECOVER_IRC_EN_IRC_EN(value uint8) {
	volatile.StoreUint8(&o.CLK_RECOVER_IRC_EN.Reg, volatile.LoadUint8(&o.CLK_RECOVER_IRC_EN.Reg)&^(0x2)|value<<1)
}
func (o *USB0_Type) GetCLK_RECOVER_IRC_EN_IRC_EN() uint8 {
	return (volatile.LoadUint8(&o.CLK_RECOVER_IRC_EN.Reg) & 0x2) >> 1
}

// USB0.CLK_RECOVER_INT_STATUS: Clock recovery separated interrupt status
func (o *USB0_Type) SetCLK_RECOVER_INT_STATUS_OVF_ERROR(value uint8) {
	volatile.StoreUint8(&o.CLK_RECOVER_INT_STATUS.Reg, volatile.LoadUint8(&o.CLK_RECOVER_INT_STATUS.Reg)&^(0x10)|value<<4)
}
func (o *USB0_Type) GetCLK_RECOVER_INT_STATUS_OVF_ERROR() uint8 {
	return (volatile.LoadUint8(&o.CLK_RECOVER_INT_STATUS.Reg) & 0x10) >> 4
}

// High-Speed Comparator (CMP), Voltage Reference (VREF) Digital-to-Analog Converter (DAC), and Analog Mux (ANMUX)
type CMP_Type struct {
	CR0   volatile.Register8 // 0x0
	CR1   volatile.Register8 // 0x1
	FPR   volatile.Register8 // 0x2
	SCR   volatile.Register8 // 0x3
	DACCR volatile.Register8 // 0x4
	MUXCR volatile.Register8 // 0x5
}

// CMP.CR0: CMP Control Register 0
func (o *CMP_Type) SetCR0_HYSTCTR(value uint8) {
	volatile.StoreUint8(&o.CR0.Reg, volatile.LoadUint8(&o.CR0.Reg)&^(0x3)|value)
}
func (o *CMP_Type) GetCR0_HYSTCTR() uint8 {
	return volatile.LoadUint8(&o.CR0.Reg) & 0x3
}
func (o *CMP_Type) SetCR0_FILTER_CNT(value uint8) {
	volatile.StoreUint8(&o.CR0.Reg, volatile.LoadUint8(&o.CR0.Reg)&^(0x70)|value<<4)
}
func (o *CMP_Type) GetCR0_FILTER_CNT() uint8 {
	return (volatile.LoadUint8(&o.CR0.Reg) & 0x70) >> 4
}

// CMP.CR1: CMP Control Register 1
func (o *CMP_Type) SetCR1_EN(value uint8) {
	volatile.StoreUint8(&o.CR1.Reg, volatile.LoadUint8(&o.CR1.Reg)&^(0x1)|value)
}
func (o *CMP_Type) GetCR1_EN() uint8 {
	return volatile.LoadUint8(&o.CR1.Reg) & 0x1
}
func (o *CMP_Type) SetCR1_OPE(value uint8) {
	volatile.StoreUint8(&o.CR1.Reg, volatile.LoadUint8(&o.CR1.Reg)&^(0x2)|value<<1)
}
func (o *CMP_Type) GetCR1_OPE() uint8 {
	return (volatile.LoadUint8(&o.CR1.Reg) & 0x2) >> 1
}
func (o *CMP_Type) SetCR1_COS(value uint8) {
	volatile.StoreUint8(&o.CR1.Reg, volatile.LoadUint8(&o.CR1.Reg)&^(0x4)|value<<2)
}
func (o *CMP_Type) GetCR1_COS() uint8 {
	return (volatile.LoadUint8(&o.CR1.Reg) & 0x4) >> 2
}
func (o *CMP_Type) SetCR1_INV(value uint8) {
	volatile.StoreUint8(&o.CR1.Reg, volatile.LoadUint8(&o.CR1.Reg)&^(0x8)|value<<3)
}
func (o *CMP_Type) GetCR1_INV() uint8 {
	return (volatile.LoadUint8(&o.CR1.Reg) & 0x8) >> 3
}
func (o *CMP_Type) SetCR1_PMODE(value uint8) {
	volatile.StoreUint8(&o.CR1.Reg, volatile.LoadUint8(&o.CR1.Reg)&^(0x10)|value<<4)
}
func (o *CMP_Type) GetCR1_PMODE() uint8 {
	return (volatile.LoadUint8(&o.CR1.Reg) & 0x10) >> 4
}
func (o *CMP_Type) SetCR1_WE(value uint8) {
	volatile.StoreUint8(&o.CR1.Reg, volatile.LoadUint8(&o.CR1.Reg)&^(0x40)|value<<6)
}
func (o *CMP_Type) GetCR1_WE() uint8 {
	return (volatile.LoadUint8(&o.CR1.Reg) & 0x40) >> 6
}
func (o *CMP_Type) SetCR1_SE(value uint8) {
	volatile.StoreUint8(&o.CR1.Reg, volatile.LoadUint8(&o.CR1.Reg)&^(0x80)|value<<7)
}
func (o *CMP_Type) GetCR1_SE() uint8 {
	return (volatile.LoadUint8(&o.CR1.Reg) & 0x80) >> 7
}

// CMP.FPR: CMP Filter Period Register
func (o *CMP_Type) SetFPR(value uint8) {
	volatile.StoreUint8(&o.FPR.Reg, value)
}
func (o *CMP_Type) GetFPR() uint8 {
	return volatile.LoadUint8(&o.FPR.Reg)
}

// CMP.SCR: CMP Status and Control Register
func (o *CMP_Type) SetSCR_COUT(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x1)|value)
}
func (o *CMP_Type) GetSCR_COUT() uint8 {
	return volatile.LoadUint8(&o.SCR.Reg) & 0x1
}
func (o *CMP_Type) SetSCR_CFF(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x2)|value<<1)
}
func (o *CMP_Type) GetSCR_CFF() uint8 {
	return (volatile.LoadUint8(&o.SCR.Reg) & 0x2) >> 1
}
func (o *CMP_Type) SetSCR_CFR(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x4)|value<<2)
}
func (o *CMP_Type) GetSCR_CFR() uint8 {
	return (volatile.LoadUint8(&o.SCR.Reg) & 0x4) >> 2
}
func (o *CMP_Type) SetSCR_IEF(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x8)|value<<3)
}
func (o *CMP_Type) GetSCR_IEF() uint8 {
	return (volatile.LoadUint8(&o.SCR.Reg) & 0x8) >> 3
}
func (o *CMP_Type) SetSCR_IER(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x10)|value<<4)
}
func (o *CMP_Type) GetSCR_IER() uint8 {
	return (volatile.LoadUint8(&o.SCR.Reg) & 0x10) >> 4
}
func (o *CMP_Type) SetSCR_DMAEN(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x40)|value<<6)
}
func (o *CMP_Type) GetSCR_DMAEN() uint8 {
	return (volatile.LoadUint8(&o.SCR.Reg) & 0x40) >> 6
}

// CMP.DACCR: DAC Control Register
func (o *CMP_Type) SetDACCR_VOSEL(value uint8) {
	volatile.StoreUint8(&o.DACCR.Reg, volatile.LoadUint8(&o.DACCR.Reg)&^(0x3f)|value)
}
func (o *CMP_Type) GetDACCR_VOSEL() uint8 {
	return volatile.LoadUint8(&o.DACCR.Reg) & 0x3f
}
func (o *CMP_Type) SetDACCR_VRSEL(value uint8) {
	volatile.StoreUint8(&o.DACCR.Reg, volatile.LoadUint8(&o.DACCR.Reg)&^(0x40)|value<<6)
}
func (o *CMP_Type) GetDACCR_VRSEL() uint8 {
	return (volatile.LoadUint8(&o.DACCR.Reg) & 0x40) >> 6
}
func (o *CMP_Type) SetDACCR_DACEN(value uint8) {
	volatile.StoreUint8(&o.DACCR.Reg, volatile.LoadUint8(&o.DACCR.Reg)&^(0x80)|value<<7)
}
func (o *CMP_Type) GetDACCR_DACEN() uint8 {
	return (volatile.LoadUint8(&o.DACCR.Reg) & 0x80) >> 7
}

// CMP.MUXCR: MUX Control Register
func (o *CMP_Type) SetMUXCR_MSEL(value uint8) {
	volatile.StoreUint8(&o.MUXCR.Reg, volatile.LoadUint8(&o.MUXCR.Reg)&^(0x7)|value)
}
func (o *CMP_Type) GetMUXCR_MSEL() uint8 {
	return volatile.LoadUint8(&o.MUXCR.Reg) & 0x7
}
func (o *CMP_Type) SetMUXCR_PSEL(value uint8) {
	volatile.StoreUint8(&o.MUXCR.Reg, volatile.LoadUint8(&o.MUXCR.Reg)&^(0x38)|value<<3)
}
func (o *CMP_Type) GetMUXCR_PSEL() uint8 {
	return (volatile.LoadUint8(&o.MUXCR.Reg) & 0x38) >> 3
}
func (o *CMP_Type) SetMUXCR_PSTM(value uint8) {
	volatile.StoreUint8(&o.MUXCR.Reg, volatile.LoadUint8(&o.MUXCR.Reg)&^(0x80)|value<<7)
}
func (o *CMP_Type) GetMUXCR_PSTM() uint8 {
	return (volatile.LoadUint8(&o.MUXCR.Reg) & 0x80) >> 7
}

// Voltage Reference
type VREF_Type struct {
	TRM volatile.Register8 // 0x0
	SC  volatile.Register8 // 0x1
}

// VREF.TRM: VREF Trim Register
func (o *VREF_Type) SetTRM_TRIM(value uint8) {
	volatile.StoreUint8(&o.TRM.Reg, volatile.LoadUint8(&o.TRM.Reg)&^(0x3f)|value)
}
func (o *VREF_Type) GetTRM_TRIM() uint8 {
	return volatile.LoadUint8(&o.TRM.Reg) & 0x3f
}
func (o *VREF_Type) SetTRM_CHOPEN(value uint8) {
	volatile.StoreUint8(&o.TRM.Reg, volatile.LoadUint8(&o.TRM.Reg)&^(0x40)|value<<6)
}
func (o *VREF_Type) GetTRM_CHOPEN() uint8 {
	return (volatile.LoadUint8(&o.TRM.Reg) & 0x40) >> 6
}

// VREF.SC: VREF Status and Control Register
func (o *VREF_Type) SetSC_MODE_LV(value uint8) {
	volatile.StoreUint8(&o.SC.Reg, volatile.LoadUint8(&o.SC.Reg)&^(0x3)|value)
}
func (o *VREF_Type) GetSC_MODE_LV() uint8 {
	return volatile.LoadUint8(&o.SC.Reg) & 0x3
}
func (o *VREF_Type) SetSC_VREFST(value uint8) {
	volatile.StoreUint8(&o.SC.Reg, volatile.LoadUint8(&o.SC.Reg)&^(0x4)|value<<2)
}
func (o *VREF_Type) GetSC_VREFST() uint8 {
	return (volatile.LoadUint8(&o.SC.Reg) & 0x4) >> 2
}
func (o *VREF_Type) SetSC_ICOMPEN(value uint8) {
	volatile.StoreUint8(&o.SC.Reg, volatile.LoadUint8(&o.SC.Reg)&^(0x20)|value<<5)
}
func (o *VREF_Type) GetSC_ICOMPEN() uint8 {
	return (volatile.LoadUint8(&o.SC.Reg) & 0x20) >> 5
}
func (o *VREF_Type) SetSC_REGEN(value uint8) {
	volatile.StoreUint8(&o.SC.Reg, volatile.LoadUint8(&o.SC.Reg)&^(0x40)|value<<6)
}
func (o *VREF_Type) GetSC_REGEN() uint8 {
	return (volatile.LoadUint8(&o.SC.Reg) & 0x40) >> 6
}
func (o *VREF_Type) SetSC_VREFEN(value uint8) {
	volatile.StoreUint8(&o.SC.Reg, volatile.LoadUint8(&o.SC.Reg)&^(0x80)|value<<7)
}
func (o *VREF_Type) GetSC_VREFEN() uint8 {
	return (volatile.LoadUint8(&o.SC.Reg) & 0x80) >> 7
}

// Low leakage wakeup unit
type LLWU_Type struct {
	PE1   volatile.Register8 // 0x0
	PE2   volatile.Register8 // 0x1
	PE3   volatile.Register8 // 0x2
	PE4   volatile.Register8 // 0x3
	ME    volatile.Register8 // 0x4
	F1    volatile.Register8 // 0x5
	F2    volatile.Register8 // 0x6
	F3    volatile.Register8 // 0x7
	FILT1 volatile.Register8 // 0x8
	FILT2 volatile.Register8 // 0x9
	RST   volatile.Register8 // 0xA
}

// LLWU.PE1: LLWU Pin Enable 1 register
func (o *LLWU_Type) SetPE1_WUPE0(value uint8) {
	volatile.StoreUint8(&o.PE1.Reg, volatile.LoadUint8(&o.PE1.Reg)&^(0x3)|value)
}
func (o *LLWU_Type) GetPE1_WUPE0() uint8 {
	return volatile.LoadUint8(&o.PE1.Reg) & 0x3
}
func (o *LLWU_Type) SetPE1_WUPE1(value uint8) {
	volatile.StoreUint8(&o.PE1.Reg, volatile.LoadUint8(&o.PE1.Reg)&^(0xc)|value<<2)
}
func (o *LLWU_Type) GetPE1_WUPE1() uint8 {
	return (volatile.LoadUint8(&o.PE1.Reg) & 0xc) >> 2
}
func (o *LLWU_Type) SetPE1_WUPE2(value uint8) {
	volatile.StoreUint8(&o.PE1.Reg, volatile.LoadUint8(&o.PE1.Reg)&^(0x30)|value<<4)
}
func (o *LLWU_Type) GetPE1_WUPE2() uint8 {
	return (volatile.LoadUint8(&o.PE1.Reg) & 0x30) >> 4
}
func (o *LLWU_Type) SetPE1_WUPE3(value uint8) {
	volatile.StoreUint8(&o.PE1.Reg, volatile.LoadUint8(&o.PE1.Reg)&^(0xc0)|value<<6)
}
func (o *LLWU_Type) GetPE1_WUPE3() uint8 {
	return (volatile.LoadUint8(&o.PE1.Reg) & 0xc0) >> 6
}

// LLWU.PE2: LLWU Pin Enable 2 register
func (o *LLWU_Type) SetPE2_WUPE4(value uint8) {
	volatile.StoreUint8(&o.PE2.Reg, volatile.LoadUint8(&o.PE2.Reg)&^(0x3)|value)
}
func (o *LLWU_Type) GetPE2_WUPE4() uint8 {
	return volatile.LoadUint8(&o.PE2.Reg) & 0x3
}
func (o *LLWU_Type) SetPE2_WUPE5(value uint8) {
	volatile.StoreUint8(&o.PE2.Reg, volatile.LoadUint8(&o.PE2.Reg)&^(0xc)|value<<2)
}
func (o *LLWU_Type) GetPE2_WUPE5() uint8 {
	return (volatile.LoadUint8(&o.PE2.Reg) & 0xc) >> 2
}
func (o *LLWU_Type) SetPE2_WUPE6(value uint8) {
	volatile.StoreUint8(&o.PE2.Reg, volatile.LoadUint8(&o.PE2.Reg)&^(0x30)|value<<4)
}
func (o *LLWU_Type) GetPE2_WUPE6() uint8 {
	return (volatile.LoadUint8(&o.PE2.Reg) & 0x30) >> 4
}
func (o *LLWU_Type) SetPE2_WUPE7(value uint8) {
	volatile.StoreUint8(&o.PE2.Reg, volatile.LoadUint8(&o.PE2.Reg)&^(0xc0)|value<<6)
}
func (o *LLWU_Type) GetPE2_WUPE7() uint8 {
	return (volatile.LoadUint8(&o.PE2.Reg) & 0xc0) >> 6
}

// LLWU.PE3: LLWU Pin Enable 3 register
func (o *LLWU_Type) SetPE3_WUPE8(value uint8) {
	volatile.StoreUint8(&o.PE3.Reg, volatile.LoadUint8(&o.PE3.Reg)&^(0x3)|value)
}
func (o *LLWU_Type) GetPE3_WUPE8() uint8 {
	return volatile.LoadUint8(&o.PE3.Reg) & 0x3
}
func (o *LLWU_Type) SetPE3_WUPE9(value uint8) {
	volatile.StoreUint8(&o.PE3.Reg, volatile.LoadUint8(&o.PE3.Reg)&^(0xc)|value<<2)
}
func (o *LLWU_Type) GetPE3_WUPE9() uint8 {
	return (volatile.LoadUint8(&o.PE3.Reg) & 0xc) >> 2
}
func (o *LLWU_Type) SetPE3_WUPE10(value uint8) {
	volatile.StoreUint8(&o.PE3.Reg, volatile.LoadUint8(&o.PE3.Reg)&^(0x30)|value<<4)
}
func (o *LLWU_Type) GetPE3_WUPE10() uint8 {
	return (volatile.LoadUint8(&o.PE3.Reg) & 0x30) >> 4
}
func (o *LLWU_Type) SetPE3_WUPE11(value uint8) {
	volatile.StoreUint8(&o.PE3.Reg, volatile.LoadUint8(&o.PE3.Reg)&^(0xc0)|value<<6)
}
func (o *LLWU_Type) GetPE3_WUPE11() uint8 {
	return (volatile.LoadUint8(&o.PE3.Reg) & 0xc0) >> 6
}

// LLWU.PE4: LLWU Pin Enable 4 register
func (o *LLWU_Type) SetPE4_WUPE12(value uint8) {
	volatile.StoreUint8(&o.PE4.Reg, volatile.LoadUint8(&o.PE4.Reg)&^(0x3)|value)
}
func (o *LLWU_Type) GetPE4_WUPE12() uint8 {
	return volatile.LoadUint8(&o.PE4.Reg) & 0x3
}
func (o *LLWU_Type) SetPE4_WUPE13(value uint8) {
	volatile.StoreUint8(&o.PE4.Reg, volatile.LoadUint8(&o.PE4.Reg)&^(0xc)|value<<2)
}
func (o *LLWU_Type) GetPE4_WUPE13() uint8 {
	return (volatile.LoadUint8(&o.PE4.Reg) & 0xc) >> 2
}
func (o *LLWU_Type) SetPE4_WUPE14(value uint8) {
	volatile.StoreUint8(&o.PE4.Reg, volatile.LoadUint8(&o.PE4.Reg)&^(0x30)|value<<4)
}
func (o *LLWU_Type) GetPE4_WUPE14() uint8 {
	return (volatile.LoadUint8(&o.PE4.Reg) & 0x30) >> 4
}
func (o *LLWU_Type) SetPE4_WUPE15(value uint8) {
	volatile.StoreUint8(&o.PE4.Reg, volatile.LoadUint8(&o.PE4.Reg)&^(0xc0)|value<<6)
}
func (o *LLWU_Type) GetPE4_WUPE15() uint8 {
	return (volatile.LoadUint8(&o.PE4.Reg) & 0xc0) >> 6
}

// LLWU.ME: LLWU Module Enable register
func (o *LLWU_Type) SetME_WUME0(value uint8) {
	volatile.StoreUint8(&o.ME.Reg, volatile.LoadUint8(&o.ME.Reg)&^(0x1)|value)
}
func (o *LLWU_Type) GetME_WUME0() uint8 {
	return volatile.LoadUint8(&o.ME.Reg) & 0x1
}
func (o *LLWU_Type) SetME_WUME1(value uint8) {
	volatile.StoreUint8(&o.ME.Reg, volatile.LoadUint8(&o.ME.Reg)&^(0x2)|value<<1)
}
func (o *LLWU_Type) GetME_WUME1() uint8 {
	return (volatile.LoadUint8(&o.ME.Reg) & 0x2) >> 1
}
func (o *LLWU_Type) SetME_WUME2(value uint8) {
	volatile.StoreUint8(&o.ME.Reg, volatile.LoadUint8(&o.ME.Reg)&^(0x4)|value<<2)
}
func (o *LLWU_Type) GetME_WUME2() uint8 {
	return (volatile.LoadUint8(&o.ME.Reg) & 0x4) >> 2
}
func (o *LLWU_Type) SetME_WUME3(value uint8) {
	volatile.StoreUint8(&o.ME.Reg, volatile.LoadUint8(&o.ME.Reg)&^(0x8)|value<<3)
}
func (o *LLWU_Type) GetME_WUME3() uint8 {
	return (volatile.LoadUint8(&o.ME.Reg) & 0x8) >> 3
}
func (o *LLWU_Type) SetME_WUME4(value uint8) {
	volatile.StoreUint8(&o.ME.Reg, volatile.LoadUint8(&o.ME.Reg)&^(0x10)|value<<4)
}
func (o *LLWU_Type) GetME_WUME4() uint8 {
	return (volatile.LoadUint8(&o.ME.Reg) & 0x10) >> 4
}
func (o *LLWU_Type) SetME_WUME5(value uint8) {
	volatile.StoreUint8(&o.ME.Reg, volatile.LoadUint8(&o.ME.Reg)&^(0x20)|value<<5)
}
func (o *LLWU_Type) GetME_WUME5() uint8 {
	return (volatile.LoadUint8(&o.ME.Reg) & 0x20) >> 5
}
func (o *LLWU_Type) SetME_WUME6(value uint8) {
	volatile.StoreUint8(&o.ME.Reg, volatile.LoadUint8(&o.ME.Reg)&^(0x40)|value<<6)
}
func (o *LLWU_Type) GetME_WUME6() uint8 {
	return (volatile.LoadUint8(&o.ME.Reg) & 0x40) >> 6
}
func (o *LLWU_Type) SetME_WUME7(value uint8) {
	volatile.StoreUint8(&o.ME.Reg, volatile.LoadUint8(&o.ME.Reg)&^(0x80)|value<<7)
}
func (o *LLWU_Type) GetME_WUME7() uint8 {
	return (volatile.LoadUint8(&o.ME.Reg) & 0x80) >> 7
}

// LLWU.F1: LLWU Flag 1 register
func (o *LLWU_Type) SetF1_WUF0(value uint8) {
	volatile.StoreUint8(&o.F1.Reg, volatile.LoadUint8(&o.F1.Reg)&^(0x1)|value)
}
func (o *LLWU_Type) GetF1_WUF0() uint8 {
	return volatile.LoadUint8(&o.F1.Reg) & 0x1
}
func (o *LLWU_Type) SetF1_WUF1(value uint8) {
	volatile.StoreUint8(&o.F1.Reg, volatile.LoadUint8(&o.F1.Reg)&^(0x2)|value<<1)
}
func (o *LLWU_Type) GetF1_WUF1() uint8 {
	return (volatile.LoadUint8(&o.F1.Reg) & 0x2) >> 1
}
func (o *LLWU_Type) SetF1_WUF2(value uint8) {
	volatile.StoreUint8(&o.F1.Reg, volatile.LoadUint8(&o.F1.Reg)&^(0x4)|value<<2)
}
func (o *LLWU_Type) GetF1_WUF2() uint8 {
	return (volatile.LoadUint8(&o.F1.Reg) & 0x4) >> 2
}
func (o *LLWU_Type) SetF1_WUF3(value uint8) {
	volatile.StoreUint8(&o.F1.Reg, volatile.LoadUint8(&o.F1.Reg)&^(0x8)|value<<3)
}
func (o *LLWU_Type) GetF1_WUF3() uint8 {
	return (volatile.LoadUint8(&o.F1.Reg) & 0x8) >> 3
}
func (o *LLWU_Type) SetF1_WUF4(value uint8) {
	volatile.StoreUint8(&o.F1.Reg, volatile.LoadUint8(&o.F1.Reg)&^(0x10)|value<<4)
}
func (o *LLWU_Type) GetF1_WUF4() uint8 {
	return (volatile.LoadUint8(&o.F1.Reg) & 0x10) >> 4
}
func (o *LLWU_Type) SetF1_WUF5(value uint8) {
	volatile.StoreUint8(&o.F1.Reg, volatile.LoadUint8(&o.F1.Reg)&^(0x20)|value<<5)
}
func (o *LLWU_Type) GetF1_WUF5() uint8 {
	return (volatile.LoadUint8(&o.F1.Reg) & 0x20) >> 5
}
func (o *LLWU_Type) SetF1_WUF6(value uint8) {
	volatile.StoreUint8(&o.F1.Reg, volatile.LoadUint8(&o.F1.Reg)&^(0x40)|value<<6)
}
func (o *LLWU_Type) GetF1_WUF6() uint8 {
	return (volatile.LoadUint8(&o.F1.Reg) & 0x40) >> 6
}
func (o *LLWU_Type) SetF1_WUF7(value uint8) {
	volatile.StoreUint8(&o.F1.Reg, volatile.LoadUint8(&o.F1.Reg)&^(0x80)|value<<7)
}
func (o *LLWU_Type) GetF1_WUF7() uint8 {
	return (volatile.LoadUint8(&o.F1.Reg) & 0x80) >> 7
}

// LLWU.F2: LLWU Flag 2 register
func (o *LLWU_Type) SetF2_WUF8(value uint8) {
	volatile.StoreUint8(&o.F2.Reg, volatile.LoadUint8(&o.F2.Reg)&^(0x1)|value)
}
func (o *LLWU_Type) GetF2_WUF8() uint8 {
	return volatile.LoadUint8(&o.F2.Reg) & 0x1
}
func (o *LLWU_Type) SetF2_WUF9(value uint8) {
	volatile.StoreUint8(&o.F2.Reg, volatile.LoadUint8(&o.F2.Reg)&^(0x2)|value<<1)
}
func (o *LLWU_Type) GetF2_WUF9() uint8 {
	return (volatile.LoadUint8(&o.F2.Reg) & 0x2) >> 1
}
func (o *LLWU_Type) SetF2_WUF10(value uint8) {
	volatile.StoreUint8(&o.F2.Reg, volatile.LoadUint8(&o.F2.Reg)&^(0x4)|value<<2)
}
func (o *LLWU_Type) GetF2_WUF10() uint8 {
	return (volatile.LoadUint8(&o.F2.Reg) & 0x4) >> 2
}
func (o *LLWU_Type) SetF2_WUF11(value uint8) {
	volatile.StoreUint8(&o.F2.Reg, volatile.LoadUint8(&o.F2.Reg)&^(0x8)|value<<3)
}
func (o *LLWU_Type) GetF2_WUF11() uint8 {
	return (volatile.LoadUint8(&o.F2.Reg) & 0x8) >> 3
}
func (o *LLWU_Type) SetF2_WUF12(value uint8) {
	volatile.StoreUint8(&o.F2.Reg, volatile.LoadUint8(&o.F2.Reg)&^(0x10)|value<<4)
}
func (o *LLWU_Type) GetF2_WUF12() uint8 {
	return (volatile.LoadUint8(&o.F2.Reg) & 0x10) >> 4
}
func (o *LLWU_Type) SetF2_WUF13(value uint8) {
	volatile.StoreUint8(&o.F2.Reg, volatile.LoadUint8(&o.F2.Reg)&^(0x20)|value<<5)
}
func (o *LLWU_Type) GetF2_WUF13() uint8 {
	return (volatile.LoadUint8(&o.F2.Reg) & 0x20) >> 5
}
func (o *LLWU_Type) SetF2_WUF14(value uint8) {
	volatile.StoreUint8(&o.F2.Reg, volatile.LoadUint8(&o.F2.Reg)&^(0x40)|value<<6)
}
func (o *LLWU_Type) GetF2_WUF14() uint8 {
	return (volatile.LoadUint8(&o.F2.Reg) & 0x40) >> 6
}
func (o *LLWU_Type) SetF2_WUF15(value uint8) {
	volatile.StoreUint8(&o.F2.Reg, volatile.LoadUint8(&o.F2.Reg)&^(0x80)|value<<7)
}
func (o *LLWU_Type) GetF2_WUF15() uint8 {
	return (volatile.LoadUint8(&o.F2.Reg) & 0x80) >> 7
}

// LLWU.F3: LLWU Flag 3 register
func (o *LLWU_Type) SetF3_MWUF0(value uint8) {
	volatile.StoreUint8(&o.F3.Reg, volatile.LoadUint8(&o.F3.Reg)&^(0x1)|value)
}
func (o *LLWU_Type) GetF3_MWUF0() uint8 {
	return volatile.LoadUint8(&o.F3.Reg) & 0x1
}
func (o *LLWU_Type) SetF3_MWUF1(value uint8) {
	volatile.StoreUint8(&o.F3.Reg, volatile.LoadUint8(&o.F3.Reg)&^(0x2)|value<<1)
}
func (o *LLWU_Type) GetF3_MWUF1() uint8 {
	return (volatile.LoadUint8(&o.F3.Reg) & 0x2) >> 1
}
func (o *LLWU_Type) SetF3_MWUF2(value uint8) {
	volatile.StoreUint8(&o.F3.Reg, volatile.LoadUint8(&o.F3.Reg)&^(0x4)|value<<2)
}
func (o *LLWU_Type) GetF3_MWUF2() uint8 {
	return (volatile.LoadUint8(&o.F3.Reg) & 0x4) >> 2
}
func (o *LLWU_Type) SetF3_MWUF3(value uint8) {
	volatile.StoreUint8(&o.F3.Reg, volatile.LoadUint8(&o.F3.Reg)&^(0x8)|value<<3)
}
func (o *LLWU_Type) GetF3_MWUF3() uint8 {
	return (volatile.LoadUint8(&o.F3.Reg) & 0x8) >> 3
}
func (o *LLWU_Type) SetF3_MWUF4(value uint8) {
	volatile.StoreUint8(&o.F3.Reg, volatile.LoadUint8(&o.F3.Reg)&^(0x10)|value<<4)
}
func (o *LLWU_Type) GetF3_MWUF4() uint8 {
	return (volatile.LoadUint8(&o.F3.Reg) & 0x10) >> 4
}
func (o *LLWU_Type) SetF3_MWUF5(value uint8) {
	volatile.StoreUint8(&o.F3.Reg, volatile.LoadUint8(&o.F3.Reg)&^(0x20)|value<<5)
}
func (o *LLWU_Type) GetF3_MWUF5() uint8 {
	return (volatile.LoadUint8(&o.F3.Reg) & 0x20) >> 5
}
func (o *LLWU_Type) SetF3_MWUF6(value uint8) {
	volatile.StoreUint8(&o.F3.Reg, volatile.LoadUint8(&o.F3.Reg)&^(0x40)|value<<6)
}
func (o *LLWU_Type) GetF3_MWUF6() uint8 {
	return (volatile.LoadUint8(&o.F3.Reg) & 0x40) >> 6
}
func (o *LLWU_Type) SetF3_MWUF7(value uint8) {
	volatile.StoreUint8(&o.F3.Reg, volatile.LoadUint8(&o.F3.Reg)&^(0x80)|value<<7)
}
func (o *LLWU_Type) GetF3_MWUF7() uint8 {
	return (volatile.LoadUint8(&o.F3.Reg) & 0x80) >> 7
}

// LLWU.FILT1: LLWU Pin Filter 1 register
func (o *LLWU_Type) SetFILT1_FILTSEL(value uint8) {
	volatile.StoreUint8(&o.FILT1.Reg, volatile.LoadUint8(&o.FILT1.Reg)&^(0xf)|value)
}
func (o *LLWU_Type) GetFILT1_FILTSEL() uint8 {
	return volatile.LoadUint8(&o.FILT1.Reg) & 0xf
}
func (o *LLWU_Type) SetFILT1_FILTE(value uint8) {
	volatile.StoreUint8(&o.FILT1.Reg, volatile.LoadUint8(&o.FILT1.Reg)&^(0x60)|value<<5)
}
func (o *LLWU_Type) GetFILT1_FILTE() uint8 {
	return (volatile.LoadUint8(&o.FILT1.Reg) & 0x60) >> 5
}
func (o *LLWU_Type) SetFILT1_FILTF(value uint8) {
	volatile.StoreUint8(&o.FILT1.Reg, volatile.LoadUint8(&o.FILT1.Reg)&^(0x80)|value<<7)
}
func (o *LLWU_Type) GetFILT1_FILTF() uint8 {
	return (volatile.LoadUint8(&o.FILT1.Reg) & 0x80) >> 7
}

// LLWU.FILT2: LLWU Pin Filter 2 register
func (o *LLWU_Type) SetFILT2_FILTSEL(value uint8) {
	volatile.StoreUint8(&o.FILT2.Reg, volatile.LoadUint8(&o.FILT2.Reg)&^(0xf)|value)
}
func (o *LLWU_Type) GetFILT2_FILTSEL() uint8 {
	return volatile.LoadUint8(&o.FILT2.Reg) & 0xf
}
func (o *LLWU_Type) SetFILT2_FILTE(value uint8) {
	volatile.StoreUint8(&o.FILT2.Reg, volatile.LoadUint8(&o.FILT2.Reg)&^(0x60)|value<<5)
}
func (o *LLWU_Type) GetFILT2_FILTE() uint8 {
	return (volatile.LoadUint8(&o.FILT2.Reg) & 0x60) >> 5
}
func (o *LLWU_Type) SetFILT2_FILTF(value uint8) {
	volatile.StoreUint8(&o.FILT2.Reg, volatile.LoadUint8(&o.FILT2.Reg)&^(0x80)|value<<7)
}
func (o *LLWU_Type) GetFILT2_FILTF() uint8 {
	return (volatile.LoadUint8(&o.FILT2.Reg) & 0x80) >> 7
}

// LLWU.RST: LLWU Reset Enable register
func (o *LLWU_Type) SetRST_RSTFILT(value uint8) {
	volatile.StoreUint8(&o.RST.Reg, volatile.LoadUint8(&o.RST.Reg)&^(0x1)|value)
}
func (o *LLWU_Type) GetRST_RSTFILT() uint8 {
	return volatile.LoadUint8(&o.RST.Reg) & 0x1
}
func (o *LLWU_Type) SetRST_LLRSTE(value uint8) {
	volatile.StoreUint8(&o.RST.Reg, volatile.LoadUint8(&o.RST.Reg)&^(0x2)|value<<1)
}
func (o *LLWU_Type) GetRST_LLRSTE() uint8 {
	return (volatile.LoadUint8(&o.RST.Reg) & 0x2) >> 1
}

// Power Management Controller
type PMC_Type struct {
	LVDSC1 volatile.Register8 // 0x0
	LVDSC2 volatile.Register8 // 0x1
	REGSC  volatile.Register8 // 0x2
}

// PMC.LVDSC1: Low Voltage Detect Status And Control 1 register
func (o *PMC_Type) SetLVDSC1_LVDV(value uint8) {
	volatile.StoreUint8(&o.LVDSC1.Reg, volatile.LoadUint8(&o.LVDSC1.Reg)&^(0x3)|value)
}
func (o *PMC_Type) GetLVDSC1_LVDV() uint8 {
	return volatile.LoadUint8(&o.LVDSC1.Reg) & 0x3
}
func (o *PMC_Type) SetLVDSC1_LVDRE(value uint8) {
	volatile.StoreUint8(&o.LVDSC1.Reg, volatile.LoadUint8(&o.LVDSC1.Reg)&^(0x10)|value<<4)
}
func (o *PMC_Type) GetLVDSC1_LVDRE() uint8 {
	return (volatile.LoadUint8(&o.LVDSC1.Reg) & 0x10) >> 4
}
func (o *PMC_Type) SetLVDSC1_LVDIE(value uint8) {
	volatile.StoreUint8(&o.LVDSC1.Reg, volatile.LoadUint8(&o.LVDSC1.Reg)&^(0x20)|value<<5)
}
func (o *PMC_Type) GetLVDSC1_LVDIE() uint8 {
	return (volatile.LoadUint8(&o.LVDSC1.Reg) & 0x20) >> 5
}
func (o *PMC_Type) SetLVDSC1_LVDACK(value uint8) {
	volatile.StoreUint8(&o.LVDSC1.Reg, volatile.LoadUint8(&o.LVDSC1.Reg)&^(0x40)|value<<6)
}
func (o *PMC_Type) GetLVDSC1_LVDACK() uint8 {
	return (volatile.LoadUint8(&o.LVDSC1.Reg) & 0x40) >> 6
}
func (o *PMC_Type) SetLVDSC1_LVDF(value uint8) {
	volatile.StoreUint8(&o.LVDSC1.Reg, volatile.LoadUint8(&o.LVDSC1.Reg)&^(0x80)|value<<7)
}
func (o *PMC_Type) GetLVDSC1_LVDF() uint8 {
	return (volatile.LoadUint8(&o.LVDSC1.Reg) & 0x80) >> 7
}

// PMC.LVDSC2: Low Voltage Detect Status And Control 2 register
func (o *PMC_Type) SetLVDSC2_LVWV(value uint8) {
	volatile.StoreUint8(&o.LVDSC2.Reg, volatile.LoadUint8(&o.LVDSC2.Reg)&^(0x3)|value)
}
func (o *PMC_Type) GetLVDSC2_LVWV() uint8 {
	return volatile.LoadUint8(&o.LVDSC2.Reg) & 0x3
}
func (o *PMC_Type) SetLVDSC2_LVWIE(value uint8) {
	volatile.StoreUint8(&o.LVDSC2.Reg, volatile.LoadUint8(&o.LVDSC2.Reg)&^(0x20)|value<<5)
}
func (o *PMC_Type) GetLVDSC2_LVWIE() uint8 {
	return (volatile.LoadUint8(&o.LVDSC2.Reg) & 0x20) >> 5
}
func (o *PMC_Type) SetLVDSC2_LVWACK(value uint8) {
	volatile.StoreUint8(&o.LVDSC2.Reg, volatile.LoadUint8(&o.LVDSC2.Reg)&^(0x40)|value<<6)
}
func (o *PMC_Type) GetLVDSC2_LVWACK() uint8 {
	return (volatile.LoadUint8(&o.LVDSC2.Reg) & 0x40) >> 6
}
func (o *PMC_Type) SetLVDSC2_LVWF(value uint8) {
	volatile.StoreUint8(&o.LVDSC2.Reg, volatile.LoadUint8(&o.LVDSC2.Reg)&^(0x80)|value<<7)
}
func (o *PMC_Type) GetLVDSC2_LVWF() uint8 {
	return (volatile.LoadUint8(&o.LVDSC2.Reg) & 0x80) >> 7
}

// PMC.REGSC: Regulator Status And Control register
func (o *PMC_Type) SetREGSC_BGBE(value uint8) {
	volatile.StoreUint8(&o.REGSC.Reg, volatile.LoadUint8(&o.REGSC.Reg)&^(0x1)|value)
}
func (o *PMC_Type) GetREGSC_BGBE() uint8 {
	return volatile.LoadUint8(&o.REGSC.Reg) & 0x1
}
func (o *PMC_Type) SetREGSC_REGONS(value uint8) {
	volatile.StoreUint8(&o.REGSC.Reg, volatile.LoadUint8(&o.REGSC.Reg)&^(0x4)|value<<2)
}
func (o *PMC_Type) GetREGSC_REGONS() uint8 {
	return (volatile.LoadUint8(&o.REGSC.Reg) & 0x4) >> 2
}
func (o *PMC_Type) SetREGSC_ACKISO(value uint8) {
	volatile.StoreUint8(&o.REGSC.Reg, volatile.LoadUint8(&o.REGSC.Reg)&^(0x8)|value<<3)
}
func (o *PMC_Type) GetREGSC_ACKISO() uint8 {
	return (volatile.LoadUint8(&o.REGSC.Reg) & 0x8) >> 3
}
func (o *PMC_Type) SetREGSC_BGEN(value uint8) {
	volatile.StoreUint8(&o.REGSC.Reg, volatile.LoadUint8(&o.REGSC.Reg)&^(0x10)|value<<4)
}
func (o *PMC_Type) GetREGSC_BGEN() uint8 {
	return (volatile.LoadUint8(&o.REGSC.Reg) & 0x10) >> 4
}

// System Mode Controller
type SMC_Type struct {
	PMPROT   volatile.Register8 // 0x0
	PMCTRL   volatile.Register8 // 0x1
	VLLSCTRL volatile.Register8 // 0x2
	PMSTAT   volatile.Register8 // 0x3
}

// SMC.PMPROT: Power Mode Protection register
func (o *SMC_Type) SetPMPROT_AVLLS(value uint8) {
	volatile.StoreUint8(&o.PMPROT.Reg, volatile.LoadUint8(&o.PMPROT.Reg)&^(0x2)|value<<1)
}
func (o *SMC_Type) GetPMPROT_AVLLS() uint8 {
	return (volatile.LoadUint8(&o.PMPROT.Reg) & 0x2) >> 1
}
func (o *SMC_Type) SetPMPROT_ALLS(value uint8) {
	volatile.StoreUint8(&o.PMPROT.Reg, volatile.LoadUint8(&o.PMPROT.Reg)&^(0x8)|value<<3)
}
func (o *SMC_Type) GetPMPROT_ALLS() uint8 {
	return (volatile.LoadUint8(&o.PMPROT.Reg) & 0x8) >> 3
}
func (o *SMC_Type) SetPMPROT_AVLP(value uint8) {
	volatile.StoreUint8(&o.PMPROT.Reg, volatile.LoadUint8(&o.PMPROT.Reg)&^(0x20)|value<<5)
}
func (o *SMC_Type) GetPMPROT_AVLP() uint8 {
	return (volatile.LoadUint8(&o.PMPROT.Reg) & 0x20) >> 5
}

// SMC.PMCTRL: Power Mode Control register
func (o *SMC_Type) SetPMCTRL_STOPM(value uint8) {
	volatile.StoreUint8(&o.PMCTRL.Reg, volatile.LoadUint8(&o.PMCTRL.Reg)&^(0x7)|value)
}
func (o *SMC_Type) GetPMCTRL_STOPM() uint8 {
	return volatile.LoadUint8(&o.PMCTRL.Reg) & 0x7
}
func (o *SMC_Type) SetPMCTRL_STOPA(value uint8) {
	volatile.StoreUint8(&o.PMCTRL.Reg, volatile.LoadUint8(&o.PMCTRL.Reg)&^(0x8)|value<<3)
}
func (o *SMC_Type) GetPMCTRL_STOPA() uint8 {
	return (volatile.LoadUint8(&o.PMCTRL.Reg) & 0x8) >> 3
}
func (o *SMC_Type) SetPMCTRL_RUNM(value uint8) {
	volatile.StoreUint8(&o.PMCTRL.Reg, volatile.LoadUint8(&o.PMCTRL.Reg)&^(0x60)|value<<5)
}
func (o *SMC_Type) GetPMCTRL_RUNM() uint8 {
	return (volatile.LoadUint8(&o.PMCTRL.Reg) & 0x60) >> 5
}
func (o *SMC_Type) SetPMCTRL_LPWUI(value uint8) {
	volatile.StoreUint8(&o.PMCTRL.Reg, volatile.LoadUint8(&o.PMCTRL.Reg)&^(0x80)|value<<7)
}
func (o *SMC_Type) GetPMCTRL_LPWUI() uint8 {
	return (volatile.LoadUint8(&o.PMCTRL.Reg) & 0x80) >> 7
}

// SMC.VLLSCTRL: VLLS Control register
func (o *SMC_Type) SetVLLSCTRL_VLLSM(value uint8) {
	volatile.StoreUint8(&o.VLLSCTRL.Reg, volatile.LoadUint8(&o.VLLSCTRL.Reg)&^(0x7)|value)
}
func (o *SMC_Type) GetVLLSCTRL_VLLSM() uint8 {
	return volatile.LoadUint8(&o.VLLSCTRL.Reg) & 0x7
}
func (o *SMC_Type) SetVLLSCTRL_PORPO(value uint8) {
	volatile.StoreUint8(&o.VLLSCTRL.Reg, volatile.LoadUint8(&o.VLLSCTRL.Reg)&^(0x20)|value<<5)
}
func (o *SMC_Type) GetVLLSCTRL_PORPO() uint8 {
	return (volatile.LoadUint8(&o.VLLSCTRL.Reg) & 0x20) >> 5
}

// SMC.PMSTAT: Power Mode Status register
func (o *SMC_Type) SetPMSTAT(value uint8) {
	volatile.StoreUint8(&o.PMSTAT.Reg, volatile.LoadUint8(&o.PMSTAT.Reg)&^(0x7f)|value)
}
func (o *SMC_Type) GetPMSTAT() uint8 {
	return volatile.LoadUint8(&o.PMSTAT.Reg) & 0x7f
}

// Reset Control Module
type RCM_Type struct {
	SRS0 volatile.Register8 // 0x0
	SRS1 volatile.Register8 // 0x1
	_    [2]byte
	RPFC volatile.Register8 // 0x4
	RPFW volatile.Register8 // 0x5
	_    byte
	MR   volatile.Register8 // 0x7
}

// RCM.SRS0: System Reset Status Register 0
func (o *RCM_Type) SetSRS0_WAKEUP(value uint8) {
	volatile.StoreUint8(&o.SRS0.Reg, volatile.LoadUint8(&o.SRS0.Reg)&^(0x1)|value)
}
func (o *RCM_Type) GetSRS0_WAKEUP() uint8 {
	return volatile.LoadUint8(&o.SRS0.Reg) & 0x1
}
func (o *RCM_Type) SetSRS0_LVD(value uint8) {
	volatile.StoreUint8(&o.SRS0.Reg, volatile.LoadUint8(&o.SRS0.Reg)&^(0x2)|value<<1)
}
func (o *RCM_Type) GetSRS0_LVD() uint8 {
	return (volatile.LoadUint8(&o.SRS0.Reg) & 0x2) >> 1
}
func (o *RCM_Type) SetSRS0_LOC(value uint8) {
	volatile.StoreUint8(&o.SRS0.Reg, volatile.LoadUint8(&o.SRS0.Reg)&^(0x4)|value<<2)
}
func (o *RCM_Type) GetSRS0_LOC() uint8 {
	return (volatile.LoadUint8(&o.SRS0.Reg) & 0x4) >> 2
}
func (o *RCM_Type) SetSRS0_LOL(value uint8) {
	volatile.StoreUint8(&o.SRS0.Reg, volatile.LoadUint8(&o.SRS0.Reg)&^(0x8)|value<<3)
}
func (o *RCM_Type) GetSRS0_LOL() uint8 {
	return (volatile.LoadUint8(&o.SRS0.Reg) & 0x8) >> 3
}
func (o *RCM_Type) SetSRS0_WDOG(value uint8) {
	volatile.StoreUint8(&o.SRS0.Reg, volatile.LoadUint8(&o.SRS0.Reg)&^(0x20)|value<<5)
}
func (o *RCM_Type) GetSRS0_WDOG() uint8 {
	return (volatile.LoadUint8(&o.SRS0.Reg) & 0x20) >> 5
}
func (o *RCM_Type) SetSRS0_PIN(value uint8) {
	volatile.StoreUint8(&o.SRS0.Reg, volatile.LoadUint8(&o.SRS0.Reg)&^(0x40)|value<<6)
}
func (o *RCM_Type) GetSRS0_PIN() uint8 {
	return (volatile.LoadUint8(&o.SRS0.Reg) & 0x40) >> 6
}
func (o *RCM_Type) SetSRS0_POR(value uint8) {
	volatile.StoreUint8(&o.SRS0.Reg, volatile.LoadUint8(&o.SRS0.Reg)&^(0x80)|value<<7)
}
func (o *RCM_Type) GetSRS0_POR() uint8 {
	return (volatile.LoadUint8(&o.SRS0.Reg) & 0x80) >> 7
}

// RCM.SRS1: System Reset Status Register 1
func (o *RCM_Type) SetSRS1_JTAG(value uint8) {
	volatile.StoreUint8(&o.SRS1.Reg, volatile.LoadUint8(&o.SRS1.Reg)&^(0x1)|value)
}
func (o *RCM_Type) GetSRS1_JTAG() uint8 {
	return volatile.LoadUint8(&o.SRS1.Reg) & 0x1
}
func (o *RCM_Type) SetSRS1_LOCKUP(value uint8) {
	volatile.StoreUint8(&o.SRS1.Reg, volatile.LoadUint8(&o.SRS1.Reg)&^(0x2)|value<<1)
}
func (o *RCM_Type) GetSRS1_LOCKUP() uint8 {
	return (volatile.LoadUint8(&o.SRS1.Reg) & 0x2) >> 1
}
func (o *RCM_Type) SetSRS1_SW(value uint8) {
	volatile.StoreUint8(&o.SRS1.Reg, volatile.LoadUint8(&o.SRS1.Reg)&^(0x4)|value<<2)
}
func (o *RCM_Type) GetSRS1_SW() uint8 {
	return (volatile.LoadUint8(&o.SRS1.Reg) & 0x4) >> 2
}
func (o *RCM_Type) SetSRS1_MDM_AP(value uint8) {
	volatile.StoreUint8(&o.SRS1.Reg, volatile.LoadUint8(&o.SRS1.Reg)&^(0x8)|value<<3)
}
func (o *RCM_Type) GetSRS1_MDM_AP() uint8 {
	return (volatile.LoadUint8(&o.SRS1.Reg) & 0x8) >> 3
}
func (o *RCM_Type) SetSRS1_EZPT(value uint8) {
	volatile.StoreUint8(&o.SRS1.Reg, volatile.LoadUint8(&o.SRS1.Reg)&^(0x10)|value<<4)
}
func (o *RCM_Type) GetSRS1_EZPT() uint8 {
	return (volatile.LoadUint8(&o.SRS1.Reg) & 0x10) >> 4
}
func (o *RCM_Type) SetSRS1_SACKERR(value uint8) {
	volatile.StoreUint8(&o.SRS1.Reg, volatile.LoadUint8(&o.SRS1.Reg)&^(0x20)|value<<5)
}
func (o *RCM_Type) GetSRS1_SACKERR() uint8 {
	return (volatile.LoadUint8(&o.SRS1.Reg) & 0x20) >> 5
}

// RCM.RPFC: Reset Pin Filter Control register
func (o *RCM_Type) SetRPFC_RSTFLTSRW(value uint8) {
	volatile.StoreUint8(&o.RPFC.Reg, volatile.LoadUint8(&o.RPFC.Reg)&^(0x3)|value)
}
func (o *RCM_Type) GetRPFC_RSTFLTSRW() uint8 {
	return volatile.LoadUint8(&o.RPFC.Reg) & 0x3
}
func (o *RCM_Type) SetRPFC_RSTFLTSS(value uint8) {
	volatile.StoreUint8(&o.RPFC.Reg, volatile.LoadUint8(&o.RPFC.Reg)&^(0x4)|value<<2)
}
func (o *RCM_Type) GetRPFC_RSTFLTSS() uint8 {
	return (volatile.LoadUint8(&o.RPFC.Reg) & 0x4) >> 2
}

// RCM.RPFW: Reset Pin Filter Width register
func (o *RCM_Type) SetRPFW_RSTFLTSEL(value uint8) {
	volatile.StoreUint8(&o.RPFW.Reg, volatile.LoadUint8(&o.RPFW.Reg)&^(0x1f)|value)
}
func (o *RCM_Type) GetRPFW_RSTFLTSEL() uint8 {
	return volatile.LoadUint8(&o.RPFW.Reg) & 0x1f
}

// RCM.MR: Mode Register
func (o *RCM_Type) SetMR_EZP_MS(value uint8) {
	volatile.StoreUint8(&o.MR.Reg, volatile.LoadUint8(&o.MR.Reg)&^(0x2)|value<<1)
}
func (o *RCM_Type) GetMR_EZP_MS() uint8 {
	return (volatile.LoadUint8(&o.MR.Reg) & 0x2) >> 1
}

// Secured Digital Host Controller
type SDHC_Type struct {
	DSADDR    volatile.Register32 // 0x0
	BLKATTR   volatile.Register32 // 0x4
	CMDARG    volatile.Register32 // 0x8
	XFERTYP   volatile.Register32 // 0xC
	CMDRSP0   volatile.Register32 // 0x10
	CMDRSP1   volatile.Register32 // 0x14
	CMDRSP2   volatile.Register32 // 0x18
	CMDRSP3   volatile.Register32 // 0x1C
	DATPORT   volatile.Register32 // 0x20
	PRSSTAT   volatile.Register32 // 0x24
	PROCTL    volatile.Register32 // 0x28
	SYSCTL    volatile.Register32 // 0x2C
	IRQSTAT   volatile.Register32 // 0x30
	IRQSTATEN volatile.Register32 // 0x34
	IRQSIGEN  volatile.Register32 // 0x38
	AC12ERR   volatile.Register32 // 0x3C
	HTCAPBLT  volatile.Register32 // 0x40
	WML       volatile.Register32 // 0x44
	_         [8]byte
	FEVT      volatile.Register32 // 0x50
	ADMAES    volatile.Register32 // 0x54
	ADSADDR   volatile.Register32 // 0x58
	_         [100]byte
	VENDOR    volatile.Register32 // 0xC0
	MMCBOOT   volatile.Register32 // 0xC4
	_         [52]byte
	HOSTVER   volatile.Register32 // 0xFC
}

// SDHC.DSADDR: DMA System Address register
func (o *SDHC_Type) SetDSADDR(value uint32) {
	volatile.StoreUint32(&o.DSADDR.Reg, volatile.LoadUint32(&o.DSADDR.Reg)&^(0xfffffffc)|value<<2)
}
func (o *SDHC_Type) GetDSADDR() uint32 {
	return (volatile.LoadUint32(&o.DSADDR.Reg) & 0xfffffffc) >> 2
}

// SDHC.BLKATTR: Block Attributes register
func (o *SDHC_Type) SetBLKATTR_BLKSIZE(value uint32) {
	volatile.StoreUint32(&o.BLKATTR.Reg, volatile.LoadUint32(&o.BLKATTR.Reg)&^(0x1fff)|value)
}
func (o *SDHC_Type) GetBLKATTR_BLKSIZE() uint32 {
	return volatile.LoadUint32(&o.BLKATTR.Reg) & 0x1fff
}
func (o *SDHC_Type) SetBLKATTR_BLKCNT(value uint32) {
	volatile.StoreUint32(&o.BLKATTR.Reg, volatile.LoadUint32(&o.BLKATTR.Reg)&^(0xffff0000)|value<<16)
}
func (o *SDHC_Type) GetBLKATTR_BLKCNT() uint32 {
	return (volatile.LoadUint32(&o.BLKATTR.Reg) & 0xffff0000) >> 16
}

// SDHC.CMDARG: Command Argument register
func (o *SDHC_Type) SetCMDARG(value uint32) {
	volatile.StoreUint32(&o.CMDARG.Reg, value)
}
func (o *SDHC_Type) GetCMDARG() uint32 {
	return volatile.LoadUint32(&o.CMDARG.Reg)
}

// SDHC.XFERTYP: Transfer Type register
func (o *SDHC_Type) SetXFERTYP_DMAEN(value uint32) {
	volatile.StoreUint32(&o.XFERTYP.Reg, volatile.LoadUint32(&o.XFERTYP.Reg)&^(0x1)|value)
}
func (o *SDHC_Type) GetXFERTYP_DMAEN() uint32 {
	return volatile.LoadUint32(&o.XFERTYP.Reg) & 0x1
}
func (o *SDHC_Type) SetXFERTYP_BCEN(value uint32) {
	volatile.StoreUint32(&o.XFERTYP.Reg, volatile.LoadUint32(&o.XFERTYP.Reg)&^(0x2)|value<<1)
}
func (o *SDHC_Type) GetXFERTYP_BCEN() uint32 {
	return (volatile.LoadUint32(&o.XFERTYP.Reg) & 0x2) >> 1
}
func (o *SDHC_Type) SetXFERTYP_AC12EN(value uint32) {
	volatile.StoreUint32(&o.XFERTYP.Reg, volatile.LoadUint32(&o.XFERTYP.Reg)&^(0x4)|value<<2)
}
func (o *SDHC_Type) GetXFERTYP_AC12EN() uint32 {
	return (volatile.LoadUint32(&o.XFERTYP.Reg) & 0x4) >> 2
}
func (o *SDHC_Type) SetXFERTYP_DTDSEL(value uint32) {
	volatile.StoreUint32(&o.XFERTYP.Reg, volatile.LoadUint32(&o.XFERTYP.Reg)&^(0x10)|value<<4)
}
func (o *SDHC_Type) GetXFERTYP_DTDSEL() uint32 {
	return (volatile.LoadUint32(&o.XFERTYP.Reg) & 0x10) >> 4
}
func (o *SDHC_Type) SetXFERTYP_MSBSEL(value uint32) {
	volatile.StoreUint32(&o.XFERTYP.Reg, volatile.LoadUint32(&o.XFERTYP.Reg)&^(0x20)|value<<5)
}
func (o *SDHC_Type) GetXFERTYP_MSBSEL() uint32 {
	return (volatile.LoadUint32(&o.XFERTYP.Reg) & 0x20) >> 5
}
func (o *SDHC_Type) SetXFERTYP_RSPTYP(value uint32) {
	volatile.StoreUint32(&o.XFERTYP.Reg, volatile.LoadUint32(&o.XFERTYP.Reg)&^(0x30000)|value<<16)
}
func (o *SDHC_Type) GetXFERTYP_RSPTYP() uint32 {
	return (volatile.LoadUint32(&o.XFERTYP.Reg) & 0x30000) >> 16
}
func (o *SDHC_Type) SetXFERTYP_CCCEN(value uint32) {
	volatile.StoreUint32(&o.XFERTYP.Reg, volatile.LoadUint32(&o.XFERTYP.Reg)&^(0x80000)|value<<19)
}
func (o *SDHC_Type) GetXFERTYP_CCCEN() uint32 {
	return (volatile.LoadUint32(&o.XFERTYP.Reg) & 0x80000) >> 19
}
func (o *SDHC_Type) SetXFERTYP_CICEN(value uint32) {
	volatile.StoreUint32(&o.XFERTYP.Reg, volatile.LoadUint32(&o.XFERTYP.Reg)&^(0x100000)|value<<20)
}
func (o *SDHC_Type) GetXFERTYP_CICEN() uint32 {
	return (volatile.LoadUint32(&o.XFERTYP.Reg) & 0x100000) >> 20
}
func (o *SDHC_Type) SetXFERTYP_DPSEL(value uint32) {
	volatile.StoreUint32(&o.XFERTYP.Reg, volatile.LoadUint32(&o.XFERTYP.Reg)&^(0x200000)|value<<21)
}
func (o *SDHC_Type) GetXFERTYP_DPSEL() uint32 {
	return (volatile.LoadUint32(&o.XFERTYP.Reg) & 0x200000) >> 21
}
func (o *SDHC_Type) SetXFERTYP_CMDTYP(value uint32) {
	volatile.StoreUint32(&o.XFERTYP.Reg, volatile.LoadUint32(&o.XFERTYP.Reg)&^(0xc00000)|value<<22)
}
func (o *SDHC_Type) GetXFERTYP_CMDTYP() uint32 {
	return (volatile.LoadUint32(&o.XFERTYP.Reg) & 0xc00000) >> 22
}
func (o *SDHC_Type) SetXFERTYP_CMDINX(value uint32) {
	volatile.StoreUint32(&o.XFERTYP.Reg, volatile.LoadUint32(&o.XFERTYP.Reg)&^(0x3f000000)|value<<24)
}
func (o *SDHC_Type) GetXFERTYP_CMDINX() uint32 {
	return (volatile.LoadUint32(&o.XFERTYP.Reg) & 0x3f000000) >> 24
}

// SDHC.CMDRSP0: Command Response 0
func (o *SDHC_Type) SetCMDRSP0(value uint32) {
	volatile.StoreUint32(&o.CMDRSP0.Reg, value)
}
func (o *SDHC_Type) GetCMDRSP0() uint32 {
	return volatile.LoadUint32(&o.CMDRSP0.Reg)
}

// SDHC.CMDRSP1: Command Response 1
func (o *SDHC_Type) SetCMDRSP1(value uint32) {
	volatile.StoreUint32(&o.CMDRSP1.Reg, value)
}
func (o *SDHC_Type) GetCMDRSP1() uint32 {
	return volatile.LoadUint32(&o.CMDRSP1.Reg)
}

// SDHC.CMDRSP2: Command Response 2
func (o *SDHC_Type) SetCMDRSP2(value uint32) {
	volatile.StoreUint32(&o.CMDRSP2.Reg, value)
}
func (o *SDHC_Type) GetCMDRSP2() uint32 {
	return volatile.LoadUint32(&o.CMDRSP2.Reg)
}

// SDHC.CMDRSP3: Command Response 3
func (o *SDHC_Type) SetCMDRSP3(value uint32) {
	volatile.StoreUint32(&o.CMDRSP3.Reg, value)
}
func (o *SDHC_Type) GetCMDRSP3() uint32 {
	return volatile.LoadUint32(&o.CMDRSP3.Reg)
}

// SDHC.DATPORT: Buffer Data Port register
func (o *SDHC_Type) SetDATPORT(value uint32) {
	volatile.StoreUint32(&o.DATPORT.Reg, value)
}
func (o *SDHC_Type) GetDATPORT() uint32 {
	return volatile.LoadUint32(&o.DATPORT.Reg)
}

// SDHC.PRSSTAT: Present State register
func (o *SDHC_Type) SetPRSSTAT_CIHB(value uint32) {
	volatile.StoreUint32(&o.PRSSTAT.Reg, volatile.LoadUint32(&o.PRSSTAT.Reg)&^(0x1)|value)
}
func (o *SDHC_Type) GetPRSSTAT_CIHB() uint32 {
	return volatile.LoadUint32(&o.PRSSTAT.Reg) & 0x1
}
func (o *SDHC_Type) SetPRSSTAT_CDIHB(value uint32) {
	volatile.StoreUint32(&o.PRSSTAT.Reg, volatile.LoadUint32(&o.PRSSTAT.Reg)&^(0x2)|value<<1)
}
func (o *SDHC_Type) GetPRSSTAT_CDIHB() uint32 {
	return (volatile.LoadUint32(&o.PRSSTAT.Reg) & 0x2) >> 1
}
func (o *SDHC_Type) SetPRSSTAT_DLA(value uint32) {
	volatile.StoreUint32(&o.PRSSTAT.Reg, volatile.LoadUint32(&o.PRSSTAT.Reg)&^(0x4)|value<<2)
}
func (o *SDHC_Type) GetPRSSTAT_DLA() uint32 {
	return (volatile.LoadUint32(&o.PRSSTAT.Reg) & 0x4) >> 2
}
func (o *SDHC_Type) SetPRSSTAT_SDSTB(value uint32) {
	volatile.StoreUint32(&o.PRSSTAT.Reg, volatile.LoadUint32(&o.PRSSTAT.Reg)&^(0x8)|value<<3)
}
func (o *SDHC_Type) GetPRSSTAT_SDSTB() uint32 {
	return (volatile.LoadUint32(&o.PRSSTAT.Reg) & 0x8) >> 3
}
func (o *SDHC_Type) SetPRSSTAT_IPGOFF(value uint32) {
	volatile.StoreUint32(&o.PRSSTAT.Reg, volatile.LoadUint32(&o.PRSSTAT.Reg)&^(0x10)|value<<4)
}
func (o *SDHC_Type) GetPRSSTAT_IPGOFF() uint32 {
	return (volatile.LoadUint32(&o.PRSSTAT.Reg) & 0x10) >> 4
}
func (o *SDHC_Type) SetPRSSTAT_HCKOFF(value uint32) {
	volatile.StoreUint32(&o.PRSSTAT.Reg, volatile.LoadUint32(&o.PRSSTAT.Reg)&^(0x20)|value<<5)
}
func (o *SDHC_Type) GetPRSSTAT_HCKOFF() uint32 {
	return (volatile.LoadUint32(&o.PRSSTAT.Reg) & 0x20) >> 5
}
func (o *SDHC_Type) SetPRSSTAT_PEROFF(value uint32) {
	volatile.StoreUint32(&o.PRSSTAT.Reg, volatile.LoadUint32(&o.PRSSTAT.Reg)&^(0x40)|value<<6)
}
func (o *SDHC_Type) GetPRSSTAT_PEROFF() uint32 {
	return (volatile.LoadUint32(&o.PRSSTAT.Reg) & 0x40) >> 6
}
func (o *SDHC_Type) SetPRSSTAT_SDOFF(value uint32) {
	volatile.StoreUint32(&o.PRSSTAT.Reg, volatile.LoadUint32(&o.PRSSTAT.Reg)&^(0x80)|value<<7)
}
func (o *SDHC_Type) GetPRSSTAT_SDOFF() uint32 {
	return (volatile.LoadUint32(&o.PRSSTAT.Reg) & 0x80) >> 7
}
func (o *SDHC_Type) SetPRSSTAT_WTA(value uint32) {
	volatile.StoreUint32(&o.PRSSTAT.Reg, volatile.LoadUint32(&o.PRSSTAT.Reg)&^(0x100)|value<<8)
}
func (o *SDHC_Type) GetPRSSTAT_WTA() uint32 {
	return (volatile.LoadUint32(&o.PRSSTAT.Reg) & 0x100) >> 8
}
func (o *SDHC_Type) SetPRSSTAT_RTA(value uint32) {
	volatile.StoreUint32(&o.PRSSTAT.Reg, volatile.LoadUint32(&o.PRSSTAT.Reg)&^(0x200)|value<<9)
}
func (o *SDHC_Type) GetPRSSTAT_RTA() uint32 {
	return (volatile.LoadUint32(&o.PRSSTAT.Reg) & 0x200) >> 9
}
func (o *SDHC_Type) SetPRSSTAT_BWEN(value uint32) {
	volatile.StoreUint32(&o.PRSSTAT.Reg, volatile.LoadUint32(&o.PRSSTAT.Reg)&^(0x400)|value<<10)
}
func (o *SDHC_Type) GetPRSSTAT_BWEN() uint32 {
	return (volatile.LoadUint32(&o.PRSSTAT.Reg) & 0x400) >> 10
}
func (o *SDHC_Type) SetPRSSTAT_BREN(value uint32) {
	volatile.StoreUint32(&o.PRSSTAT.Reg, volatile.LoadUint32(&o.PRSSTAT.Reg)&^(0x800)|value<<11)
}
func (o *SDHC_Type) GetPRSSTAT_BREN() uint32 {
	return (volatile.LoadUint32(&o.PRSSTAT.Reg) & 0x800) >> 11
}
func (o *SDHC_Type) SetPRSSTAT_CINS(value uint32) {
	volatile.StoreUint32(&o.PRSSTAT.Reg, volatile.LoadUint32(&o.PRSSTAT.Reg)&^(0x10000)|value<<16)
}
func (o *SDHC_Type) GetPRSSTAT_CINS() uint32 {
	return (volatile.LoadUint32(&o.PRSSTAT.Reg) & 0x10000) >> 16
}
func (o *SDHC_Type) SetPRSSTAT_CLSL(value uint32) {
	volatile.StoreUint32(&o.PRSSTAT.Reg, volatile.LoadUint32(&o.PRSSTAT.Reg)&^(0x800000)|value<<23)
}
func (o *SDHC_Type) GetPRSSTAT_CLSL() uint32 {
	return (volatile.LoadUint32(&o.PRSSTAT.Reg) & 0x800000) >> 23
}
func (o *SDHC_Type) SetPRSSTAT_DLSL(value uint32) {
	volatile.StoreUint32(&o.PRSSTAT.Reg, volatile.LoadUint32(&o.PRSSTAT.Reg)&^(0xff000000)|value<<24)
}
func (o *SDHC_Type) GetPRSSTAT_DLSL() uint32 {
	return (volatile.LoadUint32(&o.PRSSTAT.Reg) & 0xff000000) >> 24
}

// SDHC.PROCTL: Protocol Control register
func (o *SDHC_Type) SetPROCTL_LCTL(value uint32) {
	volatile.StoreUint32(&o.PROCTL.Reg, volatile.LoadUint32(&o.PROCTL.Reg)&^(0x1)|value)
}
func (o *SDHC_Type) GetPROCTL_LCTL() uint32 {
	return volatile.LoadUint32(&o.PROCTL.Reg) & 0x1
}
func (o *SDHC_Type) SetPROCTL_DTW(value uint32) {
	volatile.StoreUint32(&o.PROCTL.Reg, volatile.LoadUint32(&o.PROCTL.Reg)&^(0x6)|value<<1)
}
func (o *SDHC_Type) GetPROCTL_DTW() uint32 {
	return (volatile.LoadUint32(&o.PROCTL.Reg) & 0x6) >> 1
}
func (o *SDHC_Type) SetPROCTL_D3CD(value uint32) {
	volatile.StoreUint32(&o.PROCTL.Reg, volatile.LoadUint32(&o.PROCTL.Reg)&^(0x8)|value<<3)
}
func (o *SDHC_Type) GetPROCTL_D3CD() uint32 {
	return (volatile.LoadUint32(&o.PROCTL.Reg) & 0x8) >> 3
}
func (o *SDHC_Type) SetPROCTL_EMODE(value uint32) {
	volatile.StoreUint32(&o.PROCTL.Reg, volatile.LoadUint32(&o.PROCTL.Reg)&^(0x30)|value<<4)
}
func (o *SDHC_Type) GetPROCTL_EMODE() uint32 {
	return (volatile.LoadUint32(&o.PROCTL.Reg) & 0x30) >> 4
}
func (o *SDHC_Type) SetPROCTL_CDTL(value uint32) {
	volatile.StoreUint32(&o.PROCTL.Reg, volatile.LoadUint32(&o.PROCTL.Reg)&^(0x40)|value<<6)
}
func (o *SDHC_Type) GetPROCTL_CDTL() uint32 {
	return (volatile.LoadUint32(&o.PROCTL.Reg) & 0x40) >> 6
}
func (o *SDHC_Type) SetPROCTL_CDSS(value uint32) {
	volatile.StoreUint32(&o.PROCTL.Reg, volatile.LoadUint32(&o.PROCTL.Reg)&^(0x80)|value<<7)
}
func (o *SDHC_Type) GetPROCTL_CDSS() uint32 {
	return (volatile.LoadUint32(&o.PROCTL.Reg) & 0x80) >> 7
}
func (o *SDHC_Type) SetPROCTL_DMAS(value uint32) {
	volatile.StoreUint32(&o.PROCTL.Reg, volatile.LoadUint32(&o.PROCTL.Reg)&^(0x300)|value<<8)
}
func (o *SDHC_Type) GetPROCTL_DMAS() uint32 {
	return (volatile.LoadUint32(&o.PROCTL.Reg) & 0x300) >> 8
}
func (o *SDHC_Type) SetPROCTL_SABGREQ(value uint32) {
	volatile.StoreUint32(&o.PROCTL.Reg, volatile.LoadUint32(&o.PROCTL.Reg)&^(0x10000)|value<<16)
}
func (o *SDHC_Type) GetPROCTL_SABGREQ() uint32 {
	return (volatile.LoadUint32(&o.PROCTL.Reg) & 0x10000) >> 16
}
func (o *SDHC_Type) SetPROCTL_CREQ(value uint32) {
	volatile.StoreUint32(&o.PROCTL.Reg, volatile.LoadUint32(&o.PROCTL.Reg)&^(0x20000)|value<<17)
}
func (o *SDHC_Type) GetPROCTL_CREQ() uint32 {
	return (volatile.LoadUint32(&o.PROCTL.Reg) & 0x20000) >> 17
}
func (o *SDHC_Type) SetPROCTL_RWCTL(value uint32) {
	volatile.StoreUint32(&o.PROCTL.Reg, volatile.LoadUint32(&o.PROCTL.Reg)&^(0x40000)|value<<18)
}
func (o *SDHC_Type) GetPROCTL_RWCTL() uint32 {
	return (volatile.LoadUint32(&o.PROCTL.Reg) & 0x40000) >> 18
}
func (o *SDHC_Type) SetPROCTL_IABG(value uint32) {
	volatile.StoreUint32(&o.PROCTL.Reg, volatile.LoadUint32(&o.PROCTL.Reg)&^(0x80000)|value<<19)
}
func (o *SDHC_Type) GetPROCTL_IABG() uint32 {
	return (volatile.LoadUint32(&o.PROCTL.Reg) & 0x80000) >> 19
}
func (o *SDHC_Type) SetPROCTL_WECINT(value uint32) {
	volatile.StoreUint32(&o.PROCTL.Reg, volatile.LoadUint32(&o.PROCTL.Reg)&^(0x1000000)|value<<24)
}
func (o *SDHC_Type) GetPROCTL_WECINT() uint32 {
	return (volatile.LoadUint32(&o.PROCTL.Reg) & 0x1000000) >> 24
}
func (o *SDHC_Type) SetPROCTL_WECINS(value uint32) {
	volatile.StoreUint32(&o.PROCTL.Reg, volatile.LoadUint32(&o.PROCTL.Reg)&^(0x2000000)|value<<25)
}
func (o *SDHC_Type) GetPROCTL_WECINS() uint32 {
	return (volatile.LoadUint32(&o.PROCTL.Reg) & 0x2000000) >> 25
}
func (o *SDHC_Type) SetPROCTL_WECRM(value uint32) {
	volatile.StoreUint32(&o.PROCTL.Reg, volatile.LoadUint32(&o.PROCTL.Reg)&^(0x4000000)|value<<26)
}
func (o *SDHC_Type) GetPROCTL_WECRM() uint32 {
	return (volatile.LoadUint32(&o.PROCTL.Reg) & 0x4000000) >> 26
}

// SDHC.SYSCTL: System Control register
func (o *SDHC_Type) SetSYSCTL_IPGEN(value uint32) {
	volatile.StoreUint32(&o.SYSCTL.Reg, volatile.LoadUint32(&o.SYSCTL.Reg)&^(0x1)|value)
}
func (o *SDHC_Type) GetSYSCTL_IPGEN() uint32 {
	return volatile.LoadUint32(&o.SYSCTL.Reg) & 0x1
}
func (o *SDHC_Type) SetSYSCTL_HCKEN(value uint32) {
	volatile.StoreUint32(&o.SYSCTL.Reg, volatile.LoadUint32(&o.SYSCTL.Reg)&^(0x2)|value<<1)
}
func (o *SDHC_Type) GetSYSCTL_HCKEN() uint32 {
	return (volatile.LoadUint32(&o.SYSCTL.Reg) & 0x2) >> 1
}
func (o *SDHC_Type) SetSYSCTL_PEREN(value uint32) {
	volatile.StoreUint32(&o.SYSCTL.Reg, volatile.LoadUint32(&o.SYSCTL.Reg)&^(0x4)|value<<2)
}
func (o *SDHC_Type) GetSYSCTL_PEREN() uint32 {
	return (volatile.LoadUint32(&o.SYSCTL.Reg) & 0x4) >> 2
}
func (o *SDHC_Type) SetSYSCTL_SDCLKEN(value uint32) {
	volatile.StoreUint32(&o.SYSCTL.Reg, volatile.LoadUint32(&o.SYSCTL.Reg)&^(0x8)|value<<3)
}
func (o *SDHC_Type) GetSYSCTL_SDCLKEN() uint32 {
	return (volatile.LoadUint32(&o.SYSCTL.Reg) & 0x8) >> 3
}
func (o *SDHC_Type) SetSYSCTL_DVS(value uint32) {
	volatile.StoreUint32(&o.SYSCTL.Reg, volatile.LoadUint32(&o.SYSCTL.Reg)&^(0xf0)|value<<4)
}
func (o *SDHC_Type) GetSYSCTL_DVS() uint32 {
	return (volatile.LoadUint32(&o.SYSCTL.Reg) & 0xf0) >> 4
}
func (o *SDHC_Type) SetSYSCTL_SDCLKFS(value uint32) {
	volatile.StoreUint32(&o.SYSCTL.Reg, volatile.LoadUint32(&o.SYSCTL.Reg)&^(0xff00)|value<<8)
}
func (o *SDHC_Type) GetSYSCTL_SDCLKFS() uint32 {
	return (volatile.LoadUint32(&o.SYSCTL.Reg) & 0xff00) >> 8
}
func (o *SDHC_Type) SetSYSCTL_DTOCV(value uint32) {
	volatile.StoreUint32(&o.SYSCTL.Reg, volatile.LoadUint32(&o.SYSCTL.Reg)&^(0xf0000)|value<<16)
}
func (o *SDHC_Type) GetSYSCTL_DTOCV() uint32 {
	return (volatile.LoadUint32(&o.SYSCTL.Reg) & 0xf0000) >> 16
}
func (o *SDHC_Type) SetSYSCTL_RSTA(value uint32) {
	volatile.StoreUint32(&o.SYSCTL.Reg, volatile.LoadUint32(&o.SYSCTL.Reg)&^(0x1000000)|value<<24)
}
func (o *SDHC_Type) GetSYSCTL_RSTA() uint32 {
	return (volatile.LoadUint32(&o.SYSCTL.Reg) & 0x1000000) >> 24
}
func (o *SDHC_Type) SetSYSCTL_RSTC(value uint32) {
	volatile.StoreUint32(&o.SYSCTL.Reg, volatile.LoadUint32(&o.SYSCTL.Reg)&^(0x2000000)|value<<25)
}
func (o *SDHC_Type) GetSYSCTL_RSTC() uint32 {
	return (volatile.LoadUint32(&o.SYSCTL.Reg) & 0x2000000) >> 25
}
func (o *SDHC_Type) SetSYSCTL_RSTD(value uint32) {
	volatile.StoreUint32(&o.SYSCTL.Reg, volatile.LoadUint32(&o.SYSCTL.Reg)&^(0x4000000)|value<<26)
}
func (o *SDHC_Type) GetSYSCTL_RSTD() uint32 {
	return (volatile.LoadUint32(&o.SYSCTL.Reg) & 0x4000000) >> 26
}
func (o *SDHC_Type) SetSYSCTL_INITA(value uint32) {
	volatile.StoreUint32(&o.SYSCTL.Reg, volatile.LoadUint32(&o.SYSCTL.Reg)&^(0x8000000)|value<<27)
}
func (o *SDHC_Type) GetSYSCTL_INITA() uint32 {
	return (volatile.LoadUint32(&o.SYSCTL.Reg) & 0x8000000) >> 27
}

// SDHC.IRQSTAT: Interrupt Status register
func (o *SDHC_Type) SetIRQSTAT_CC(value uint32) {
	volatile.StoreUint32(&o.IRQSTAT.Reg, volatile.LoadUint32(&o.IRQSTAT.Reg)&^(0x1)|value)
}
func (o *SDHC_Type) GetIRQSTAT_CC() uint32 {
	return volatile.LoadUint32(&o.IRQSTAT.Reg) & 0x1
}
func (o *SDHC_Type) SetIRQSTAT_TC(value uint32) {
	volatile.StoreUint32(&o.IRQSTAT.Reg, volatile.LoadUint32(&o.IRQSTAT.Reg)&^(0x2)|value<<1)
}
func (o *SDHC_Type) GetIRQSTAT_TC() uint32 {
	return (volatile.LoadUint32(&o.IRQSTAT.Reg) & 0x2) >> 1
}
func (o *SDHC_Type) SetIRQSTAT_BGE(value uint32) {
	volatile.StoreUint32(&o.IRQSTAT.Reg, volatile.LoadUint32(&o.IRQSTAT.Reg)&^(0x4)|value<<2)
}
func (o *SDHC_Type) GetIRQSTAT_BGE() uint32 {
	return (volatile.LoadUint32(&o.IRQSTAT.Reg) & 0x4) >> 2
}
func (o *SDHC_Type) SetIRQSTAT_DINT(value uint32) {
	volatile.StoreUint32(&o.IRQSTAT.Reg, volatile.LoadUint32(&o.IRQSTAT.Reg)&^(0x8)|value<<3)
}
func (o *SDHC_Type) GetIRQSTAT_DINT() uint32 {
	return (volatile.LoadUint32(&o.IRQSTAT.Reg) & 0x8) >> 3
}
func (o *SDHC_Type) SetIRQSTAT_BWR(value uint32) {
	volatile.StoreUint32(&o.IRQSTAT.Reg, volatile.LoadUint32(&o.IRQSTAT.Reg)&^(0x10)|value<<4)
}
func (o *SDHC_Type) GetIRQSTAT_BWR() uint32 {
	return (volatile.LoadUint32(&o.IRQSTAT.Reg) & 0x10) >> 4
}
func (o *SDHC_Type) SetIRQSTAT_BRR(value uint32) {
	volatile.StoreUint32(&o.IRQSTAT.Reg, volatile.LoadUint32(&o.IRQSTAT.Reg)&^(0x20)|value<<5)
}
func (o *SDHC_Type) GetIRQSTAT_BRR() uint32 {
	return (volatile.LoadUint32(&o.IRQSTAT.Reg) & 0x20) >> 5
}
func (o *SDHC_Type) SetIRQSTAT_CINS(value uint32) {
	volatile.StoreUint32(&o.IRQSTAT.Reg, volatile.LoadUint32(&o.IRQSTAT.Reg)&^(0x40)|value<<6)
}
func (o *SDHC_Type) GetIRQSTAT_CINS() uint32 {
	return (volatile.LoadUint32(&o.IRQSTAT.Reg) & 0x40) >> 6
}
func (o *SDHC_Type) SetIRQSTAT_CRM(value uint32) {
	volatile.StoreUint32(&o.IRQSTAT.Reg, volatile.LoadUint32(&o.IRQSTAT.Reg)&^(0x80)|value<<7)
}
func (o *SDHC_Type) GetIRQSTAT_CRM() uint32 {
	return (volatile.LoadUint32(&o.IRQSTAT.Reg) & 0x80) >> 7
}
func (o *SDHC_Type) SetIRQSTAT_CINT(value uint32) {
	volatile.StoreUint32(&o.IRQSTAT.Reg, volatile.LoadUint32(&o.IRQSTAT.Reg)&^(0x100)|value<<8)
}
func (o *SDHC_Type) GetIRQSTAT_CINT() uint32 {
	return (volatile.LoadUint32(&o.IRQSTAT.Reg) & 0x100) >> 8
}
func (o *SDHC_Type) SetIRQSTAT_CTOE(value uint32) {
	volatile.StoreUint32(&o.IRQSTAT.Reg, volatile.LoadUint32(&o.IRQSTAT.Reg)&^(0x10000)|value<<16)
}
func (o *SDHC_Type) GetIRQSTAT_CTOE() uint32 {
	return (volatile.LoadUint32(&o.IRQSTAT.Reg) & 0x10000) >> 16
}
func (o *SDHC_Type) SetIRQSTAT_CCE(value uint32) {
	volatile.StoreUint32(&o.IRQSTAT.Reg, volatile.LoadUint32(&o.IRQSTAT.Reg)&^(0x20000)|value<<17)
}
func (o *SDHC_Type) GetIRQSTAT_CCE() uint32 {
	return (volatile.LoadUint32(&o.IRQSTAT.Reg) & 0x20000) >> 17
}
func (o *SDHC_Type) SetIRQSTAT_CEBE(value uint32) {
	volatile.StoreUint32(&o.IRQSTAT.Reg, volatile.LoadUint32(&o.IRQSTAT.Reg)&^(0x40000)|value<<18)
}
func (o *SDHC_Type) GetIRQSTAT_CEBE() uint32 {
	return (volatile.LoadUint32(&o.IRQSTAT.Reg) & 0x40000) >> 18
}
func (o *SDHC_Type) SetIRQSTAT_CIE(value uint32) {
	volatile.StoreUint32(&o.IRQSTAT.Reg, volatile.LoadUint32(&o.IRQSTAT.Reg)&^(0x80000)|value<<19)
}
func (o *SDHC_Type) GetIRQSTAT_CIE() uint32 {
	return (volatile.LoadUint32(&o.IRQSTAT.Reg) & 0x80000) >> 19
}
func (o *SDHC_Type) SetIRQSTAT_DTOE(value uint32) {
	volatile.StoreUint32(&o.IRQSTAT.Reg, volatile.LoadUint32(&o.IRQSTAT.Reg)&^(0x100000)|value<<20)
}
func (o *SDHC_Type) GetIRQSTAT_DTOE() uint32 {
	return (volatile.LoadUint32(&o.IRQSTAT.Reg) & 0x100000) >> 20
}
func (o *SDHC_Type) SetIRQSTAT_DCE(value uint32) {
	volatile.StoreUint32(&o.IRQSTAT.Reg, volatile.LoadUint32(&o.IRQSTAT.Reg)&^(0x200000)|value<<21)
}
func (o *SDHC_Type) GetIRQSTAT_DCE() uint32 {
	return (volatile.LoadUint32(&o.IRQSTAT.Reg) & 0x200000) >> 21
}
func (o *SDHC_Type) SetIRQSTAT_DEBE(value uint32) {
	volatile.StoreUint32(&o.IRQSTAT.Reg, volatile.LoadUint32(&o.IRQSTAT.Reg)&^(0x400000)|value<<22)
}
func (o *SDHC_Type) GetIRQSTAT_DEBE() uint32 {
	return (volatile.LoadUint32(&o.IRQSTAT.Reg) & 0x400000) >> 22
}
func (o *SDHC_Type) SetIRQSTAT_AC12E(value uint32) {
	volatile.StoreUint32(&o.IRQSTAT.Reg, volatile.LoadUint32(&o.IRQSTAT.Reg)&^(0x1000000)|value<<24)
}
func (o *SDHC_Type) GetIRQSTAT_AC12E() uint32 {
	return (volatile.LoadUint32(&o.IRQSTAT.Reg) & 0x1000000) >> 24
}
func (o *SDHC_Type) SetIRQSTAT_DMAE(value uint32) {
	volatile.StoreUint32(&o.IRQSTAT.Reg, volatile.LoadUint32(&o.IRQSTAT.Reg)&^(0x10000000)|value<<28)
}
func (o *SDHC_Type) GetIRQSTAT_DMAE() uint32 {
	return (volatile.LoadUint32(&o.IRQSTAT.Reg) & 0x10000000) >> 28
}

// SDHC.IRQSTATEN: Interrupt Status Enable register
func (o *SDHC_Type) SetIRQSTATEN_CCSEN(value uint32) {
	volatile.StoreUint32(&o.IRQSTATEN.Reg, volatile.LoadUint32(&o.IRQSTATEN.Reg)&^(0x1)|value)
}
func (o *SDHC_Type) GetIRQSTATEN_CCSEN() uint32 {
	return volatile.LoadUint32(&o.IRQSTATEN.Reg) & 0x1
}
func (o *SDHC_Type) SetIRQSTATEN_TCSEN(value uint32) {
	volatile.StoreUint32(&o.IRQSTATEN.Reg, volatile.LoadUint32(&o.IRQSTATEN.Reg)&^(0x2)|value<<1)
}
func (o *SDHC_Type) GetIRQSTATEN_TCSEN() uint32 {
	return (volatile.LoadUint32(&o.IRQSTATEN.Reg) & 0x2) >> 1
}
func (o *SDHC_Type) SetIRQSTATEN_BGESEN(value uint32) {
	volatile.StoreUint32(&o.IRQSTATEN.Reg, volatile.LoadUint32(&o.IRQSTATEN.Reg)&^(0x4)|value<<2)
}
func (o *SDHC_Type) GetIRQSTATEN_BGESEN() uint32 {
	return (volatile.LoadUint32(&o.IRQSTATEN.Reg) & 0x4) >> 2
}
func (o *SDHC_Type) SetIRQSTATEN_DINTSEN(value uint32) {
	volatile.StoreUint32(&o.IRQSTATEN.Reg, volatile.LoadUint32(&o.IRQSTATEN.Reg)&^(0x8)|value<<3)
}
func (o *SDHC_Type) GetIRQSTATEN_DINTSEN() uint32 {
	return (volatile.LoadUint32(&o.IRQSTATEN.Reg) & 0x8) >> 3
}
func (o *SDHC_Type) SetIRQSTATEN_BWRSEN(value uint32) {
	volatile.StoreUint32(&o.IRQSTATEN.Reg, volatile.LoadUint32(&o.IRQSTATEN.Reg)&^(0x10)|value<<4)
}
func (o *SDHC_Type) GetIRQSTATEN_BWRSEN() uint32 {
	return (volatile.LoadUint32(&o.IRQSTATEN.Reg) & 0x10) >> 4
}
func (o *SDHC_Type) SetIRQSTATEN_BRRSEN(value uint32) {
	volatile.StoreUint32(&o.IRQSTATEN.Reg, volatile.LoadUint32(&o.IRQSTATEN.Reg)&^(0x20)|value<<5)
}
func (o *SDHC_Type) GetIRQSTATEN_BRRSEN() uint32 {
	return (volatile.LoadUint32(&o.IRQSTATEN.Reg) & 0x20) >> 5
}
func (o *SDHC_Type) SetIRQSTATEN_CINSEN(value uint32) {
	volatile.StoreUint32(&o.IRQSTATEN.Reg, volatile.LoadUint32(&o.IRQSTATEN.Reg)&^(0x40)|value<<6)
}
func (o *SDHC_Type) GetIRQSTATEN_CINSEN() uint32 {
	return (volatile.LoadUint32(&o.IRQSTATEN.Reg) & 0x40) >> 6
}
func (o *SDHC_Type) SetIRQSTATEN_CRMSEN(value uint32) {
	volatile.StoreUint32(&o.IRQSTATEN.Reg, volatile.LoadUint32(&o.IRQSTATEN.Reg)&^(0x80)|value<<7)
}
func (o *SDHC_Type) GetIRQSTATEN_CRMSEN() uint32 {
	return (volatile.LoadUint32(&o.IRQSTATEN.Reg) & 0x80) >> 7
}
func (o *SDHC_Type) SetIRQSTATEN_CINTSEN(value uint32) {
	volatile.StoreUint32(&o.IRQSTATEN.Reg, volatile.LoadUint32(&o.IRQSTATEN.Reg)&^(0x100)|value<<8)
}
func (o *SDHC_Type) GetIRQSTATEN_CINTSEN() uint32 {
	return (volatile.LoadUint32(&o.IRQSTATEN.Reg) & 0x100) >> 8
}
func (o *SDHC_Type) SetIRQSTATEN_CTOESEN(value uint32) {
	volatile.StoreUint32(&o.IRQSTATEN.Reg, volatile.LoadUint32(&o.IRQSTATEN.Reg)&^(0x10000)|value<<16)
}
func (o *SDHC_Type) GetIRQSTATEN_CTOESEN() uint32 {
	return (volatile.LoadUint32(&o.IRQSTATEN.Reg) & 0x10000) >> 16
}
func (o *SDHC_Type) SetIRQSTATEN_CCESEN(value uint32) {
	volatile.StoreUint32(&o.IRQSTATEN.Reg, volatile.LoadUint32(&o.IRQSTATEN.Reg)&^(0x20000)|value<<17)
}
func (o *SDHC_Type) GetIRQSTATEN_CCESEN() uint32 {
	return (volatile.LoadUint32(&o.IRQSTATEN.Reg) & 0x20000) >> 17
}
func (o *SDHC_Type) SetIRQSTATEN_CEBESEN(value uint32) {
	volatile.StoreUint32(&o.IRQSTATEN.Reg, volatile.LoadUint32(&o.IRQSTATEN.Reg)&^(0x40000)|value<<18)
}
func (o *SDHC_Type) GetIRQSTATEN_CEBESEN() uint32 {
	return (volatile.LoadUint32(&o.IRQSTATEN.Reg) & 0x40000) >> 18
}
func (o *SDHC_Type) SetIRQSTATEN_CIESEN(value uint32) {
	volatile.StoreUint32(&o.IRQSTATEN.Reg, volatile.LoadUint32(&o.IRQSTATEN.Reg)&^(0x80000)|value<<19)
}
func (o *SDHC_Type) GetIRQSTATEN_CIESEN() uint32 {
	return (volatile.LoadUint32(&o.IRQSTATEN.Reg) & 0x80000) >> 19
}
func (o *SDHC_Type) SetIRQSTATEN_DTOESEN(value uint32) {
	volatile.StoreUint32(&o.IRQSTATEN.Reg, volatile.LoadUint32(&o.IRQSTATEN.Reg)&^(0x100000)|value<<20)
}
func (o *SDHC_Type) GetIRQSTATEN_DTOESEN() uint32 {
	return (volatile.LoadUint32(&o.IRQSTATEN.Reg) & 0x100000) >> 20
}
func (o *SDHC_Type) SetIRQSTATEN_DCESEN(value uint32) {
	volatile.StoreUint32(&o.IRQSTATEN.Reg, volatile.LoadUint32(&o.IRQSTATEN.Reg)&^(0x200000)|value<<21)
}
func (o *SDHC_Type) GetIRQSTATEN_DCESEN() uint32 {
	return (volatile.LoadUint32(&o.IRQSTATEN.Reg) & 0x200000) >> 21
}
func (o *SDHC_Type) SetIRQSTATEN_DEBESEN(value uint32) {
	volatile.StoreUint32(&o.IRQSTATEN.Reg, volatile.LoadUint32(&o.IRQSTATEN.Reg)&^(0x400000)|value<<22)
}
func (o *SDHC_Type) GetIRQSTATEN_DEBESEN() uint32 {
	return (volatile.LoadUint32(&o.IRQSTATEN.Reg) & 0x400000) >> 22
}
func (o *SDHC_Type) SetIRQSTATEN_AC12ESEN(value uint32) {
	volatile.StoreUint32(&o.IRQSTATEN.Reg, volatile.LoadUint32(&o.IRQSTATEN.Reg)&^(0x1000000)|value<<24)
}
func (o *SDHC_Type) GetIRQSTATEN_AC12ESEN() uint32 {
	return (volatile.LoadUint32(&o.IRQSTATEN.Reg) & 0x1000000) >> 24
}
func (o *SDHC_Type) SetIRQSTATEN_DMAESEN(value uint32) {
	volatile.StoreUint32(&o.IRQSTATEN.Reg, volatile.LoadUint32(&o.IRQSTATEN.Reg)&^(0x10000000)|value<<28)
}
func (o *SDHC_Type) GetIRQSTATEN_DMAESEN() uint32 {
	return (volatile.LoadUint32(&o.IRQSTATEN.Reg) & 0x10000000) >> 28
}

// SDHC.IRQSIGEN: Interrupt Signal Enable register
func (o *SDHC_Type) SetIRQSIGEN_CCIEN(value uint32) {
	volatile.StoreUint32(&o.IRQSIGEN.Reg, volatile.LoadUint32(&o.IRQSIGEN.Reg)&^(0x1)|value)
}
func (o *SDHC_Type) GetIRQSIGEN_CCIEN() uint32 {
	return volatile.LoadUint32(&o.IRQSIGEN.Reg) & 0x1
}
func (o *SDHC_Type) SetIRQSIGEN_TCIEN(value uint32) {
	volatile.StoreUint32(&o.IRQSIGEN.Reg, volatile.LoadUint32(&o.IRQSIGEN.Reg)&^(0x2)|value<<1)
}
func (o *SDHC_Type) GetIRQSIGEN_TCIEN() uint32 {
	return (volatile.LoadUint32(&o.IRQSIGEN.Reg) & 0x2) >> 1
}
func (o *SDHC_Type) SetIRQSIGEN_BGEIEN(value uint32) {
	volatile.StoreUint32(&o.IRQSIGEN.Reg, volatile.LoadUint32(&o.IRQSIGEN.Reg)&^(0x4)|value<<2)
}
func (o *SDHC_Type) GetIRQSIGEN_BGEIEN() uint32 {
	return (volatile.LoadUint32(&o.IRQSIGEN.Reg) & 0x4) >> 2
}
func (o *SDHC_Type) SetIRQSIGEN_DINTIEN(value uint32) {
	volatile.StoreUint32(&o.IRQSIGEN.Reg, volatile.LoadUint32(&o.IRQSIGEN.Reg)&^(0x8)|value<<3)
}
func (o *SDHC_Type) GetIRQSIGEN_DINTIEN() uint32 {
	return (volatile.LoadUint32(&o.IRQSIGEN.Reg) & 0x8) >> 3
}
func (o *SDHC_Type) SetIRQSIGEN_BWRIEN(value uint32) {
	volatile.StoreUint32(&o.IRQSIGEN.Reg, volatile.LoadUint32(&o.IRQSIGEN.Reg)&^(0x10)|value<<4)
}
func (o *SDHC_Type) GetIRQSIGEN_BWRIEN() uint32 {
	return (volatile.LoadUint32(&o.IRQSIGEN.Reg) & 0x10) >> 4
}
func (o *SDHC_Type) SetIRQSIGEN_BRRIEN(value uint32) {
	volatile.StoreUint32(&o.IRQSIGEN.Reg, volatile.LoadUint32(&o.IRQSIGEN.Reg)&^(0x20)|value<<5)
}
func (o *SDHC_Type) GetIRQSIGEN_BRRIEN() uint32 {
	return (volatile.LoadUint32(&o.IRQSIGEN.Reg) & 0x20) >> 5
}
func (o *SDHC_Type) SetIRQSIGEN_CINSIEN(value uint32) {
	volatile.StoreUint32(&o.IRQSIGEN.Reg, volatile.LoadUint32(&o.IRQSIGEN.Reg)&^(0x40)|value<<6)
}
func (o *SDHC_Type) GetIRQSIGEN_CINSIEN() uint32 {
	return (volatile.LoadUint32(&o.IRQSIGEN.Reg) & 0x40) >> 6
}
func (o *SDHC_Type) SetIRQSIGEN_CRMIEN(value uint32) {
	volatile.StoreUint32(&o.IRQSIGEN.Reg, volatile.LoadUint32(&o.IRQSIGEN.Reg)&^(0x80)|value<<7)
}
func (o *SDHC_Type) GetIRQSIGEN_CRMIEN() uint32 {
	return (volatile.LoadUint32(&o.IRQSIGEN.Reg) & 0x80) >> 7
}
func (o *SDHC_Type) SetIRQSIGEN_CINTIEN(value uint32) {
	volatile.StoreUint32(&o.IRQSIGEN.Reg, volatile.LoadUint32(&o.IRQSIGEN.Reg)&^(0x100)|value<<8)
}
func (o *SDHC_Type) GetIRQSIGEN_CINTIEN() uint32 {
	return (volatile.LoadUint32(&o.IRQSIGEN.Reg) & 0x100) >> 8
}
func (o *SDHC_Type) SetIRQSIGEN_CTOEIEN(value uint32) {
	volatile.StoreUint32(&o.IRQSIGEN.Reg, volatile.LoadUint32(&o.IRQSIGEN.Reg)&^(0x10000)|value<<16)
}
func (o *SDHC_Type) GetIRQSIGEN_CTOEIEN() uint32 {
	return (volatile.LoadUint32(&o.IRQSIGEN.Reg) & 0x10000) >> 16
}
func (o *SDHC_Type) SetIRQSIGEN_CCEIEN(value uint32) {
	volatile.StoreUint32(&o.IRQSIGEN.Reg, volatile.LoadUint32(&o.IRQSIGEN.Reg)&^(0x20000)|value<<17)
}
func (o *SDHC_Type) GetIRQSIGEN_CCEIEN() uint32 {
	return (volatile.LoadUint32(&o.IRQSIGEN.Reg) & 0x20000) >> 17
}
func (o *SDHC_Type) SetIRQSIGEN_CEBEIEN(value uint32) {
	volatile.StoreUint32(&o.IRQSIGEN.Reg, volatile.LoadUint32(&o.IRQSIGEN.Reg)&^(0x40000)|value<<18)
}
func (o *SDHC_Type) GetIRQSIGEN_CEBEIEN() uint32 {
	return (volatile.LoadUint32(&o.IRQSIGEN.Reg) & 0x40000) >> 18
}
func (o *SDHC_Type) SetIRQSIGEN_CIEIEN(value uint32) {
	volatile.StoreUint32(&o.IRQSIGEN.Reg, volatile.LoadUint32(&o.IRQSIGEN.Reg)&^(0x80000)|value<<19)
}
func (o *SDHC_Type) GetIRQSIGEN_CIEIEN() uint32 {
	return (volatile.LoadUint32(&o.IRQSIGEN.Reg) & 0x80000) >> 19
}
func (o *SDHC_Type) SetIRQSIGEN_DTOEIEN(value uint32) {
	volatile.StoreUint32(&o.IRQSIGEN.Reg, volatile.LoadUint32(&o.IRQSIGEN.Reg)&^(0x100000)|value<<20)
}
func (o *SDHC_Type) GetIRQSIGEN_DTOEIEN() uint32 {
	return (volatile.LoadUint32(&o.IRQSIGEN.Reg) & 0x100000) >> 20
}
func (o *SDHC_Type) SetIRQSIGEN_DCEIEN(value uint32) {
	volatile.StoreUint32(&o.IRQSIGEN.Reg, volatile.LoadUint32(&o.IRQSIGEN.Reg)&^(0x200000)|value<<21)
}
func (o *SDHC_Type) GetIRQSIGEN_DCEIEN() uint32 {
	return (volatile.LoadUint32(&o.IRQSIGEN.Reg) & 0x200000) >> 21
}
func (o *SDHC_Type) SetIRQSIGEN_DEBEIEN(value uint32) {
	volatile.StoreUint32(&o.IRQSIGEN.Reg, volatile.LoadUint32(&o.IRQSIGEN.Reg)&^(0x400000)|value<<22)
}
func (o *SDHC_Type) GetIRQSIGEN_DEBEIEN() uint32 {
	return (volatile.LoadUint32(&o.IRQSIGEN.Reg) & 0x400000) >> 22
}
func (o *SDHC_Type) SetIRQSIGEN_AC12EIEN(value uint32) {
	volatile.StoreUint32(&o.IRQSIGEN.Reg, volatile.LoadUint32(&o.IRQSIGEN.Reg)&^(0x1000000)|value<<24)
}
func (o *SDHC_Type) GetIRQSIGEN_AC12EIEN() uint32 {
	return (volatile.LoadUint32(&o.IRQSIGEN.Reg) & 0x1000000) >> 24
}
func (o *SDHC_Type) SetIRQSIGEN_DMAEIEN(value uint32) {
	volatile.StoreUint32(&o.IRQSIGEN.Reg, volatile.LoadUint32(&o.IRQSIGEN.Reg)&^(0x10000000)|value<<28)
}
func (o *SDHC_Type) GetIRQSIGEN_DMAEIEN() uint32 {
	return (volatile.LoadUint32(&o.IRQSIGEN.Reg) & 0x10000000) >> 28
}

// SDHC.AC12ERR: Auto CMD12 Error Status Register
func (o *SDHC_Type) SetAC12ERR_AC12NE(value uint32) {
	volatile.StoreUint32(&o.AC12ERR.Reg, volatile.LoadUint32(&o.AC12ERR.Reg)&^(0x1)|value)
}
func (o *SDHC_Type) GetAC12ERR_AC12NE() uint32 {
	return volatile.LoadUint32(&o.AC12ERR.Reg) & 0x1
}
func (o *SDHC_Type) SetAC12ERR_AC12TOE(value uint32) {
	volatile.StoreUint32(&o.AC12ERR.Reg, volatile.LoadUint32(&o.AC12ERR.Reg)&^(0x2)|value<<1)
}
func (o *SDHC_Type) GetAC12ERR_AC12TOE() uint32 {
	return (volatile.LoadUint32(&o.AC12ERR.Reg) & 0x2) >> 1
}
func (o *SDHC_Type) SetAC12ERR_AC12EBE(value uint32) {
	volatile.StoreUint32(&o.AC12ERR.Reg, volatile.LoadUint32(&o.AC12ERR.Reg)&^(0x4)|value<<2)
}
func (o *SDHC_Type) GetAC12ERR_AC12EBE() uint32 {
	return (volatile.LoadUint32(&o.AC12ERR.Reg) & 0x4) >> 2
}
func (o *SDHC_Type) SetAC12ERR_AC12CE(value uint32) {
	volatile.StoreUint32(&o.AC12ERR.Reg, volatile.LoadUint32(&o.AC12ERR.Reg)&^(0x8)|value<<3)
}
func (o *SDHC_Type) GetAC12ERR_AC12CE() uint32 {
	return (volatile.LoadUint32(&o.AC12ERR.Reg) & 0x8) >> 3
}
func (o *SDHC_Type) SetAC12ERR_AC12IE(value uint32) {
	volatile.StoreUint32(&o.AC12ERR.Reg, volatile.LoadUint32(&o.AC12ERR.Reg)&^(0x10)|value<<4)
}
func (o *SDHC_Type) GetAC12ERR_AC12IE() uint32 {
	return (volatile.LoadUint32(&o.AC12ERR.Reg) & 0x10) >> 4
}
func (o *SDHC_Type) SetAC12ERR_CNIBAC12E(value uint32) {
	volatile.StoreUint32(&o.AC12ERR.Reg, volatile.LoadUint32(&o.AC12ERR.Reg)&^(0x80)|value<<7)
}
func (o *SDHC_Type) GetAC12ERR_CNIBAC12E() uint32 {
	return (volatile.LoadUint32(&o.AC12ERR.Reg) & 0x80) >> 7
}

// SDHC.HTCAPBLT: Host Controller Capabilities
func (o *SDHC_Type) SetHTCAPBLT_MBL(value uint32) {
	volatile.StoreUint32(&o.HTCAPBLT.Reg, volatile.LoadUint32(&o.HTCAPBLT.Reg)&^(0x70000)|value<<16)
}
func (o *SDHC_Type) GetHTCAPBLT_MBL() uint32 {
	return (volatile.LoadUint32(&o.HTCAPBLT.Reg) & 0x70000) >> 16
}
func (o *SDHC_Type) SetHTCAPBLT_ADMAS(value uint32) {
	volatile.StoreUint32(&o.HTCAPBLT.Reg, volatile.LoadUint32(&o.HTCAPBLT.Reg)&^(0x100000)|value<<20)
}
func (o *SDHC_Type) GetHTCAPBLT_ADMAS() uint32 {
	return (volatile.LoadUint32(&o.HTCAPBLT.Reg) & 0x100000) >> 20
}
func (o *SDHC_Type) SetHTCAPBLT_HSS(value uint32) {
	volatile.StoreUint32(&o.HTCAPBLT.Reg, volatile.LoadUint32(&o.HTCAPBLT.Reg)&^(0x200000)|value<<21)
}
func (o *SDHC_Type) GetHTCAPBLT_HSS() uint32 {
	return (volatile.LoadUint32(&o.HTCAPBLT.Reg) & 0x200000) >> 21
}
func (o *SDHC_Type) SetHTCAPBLT_DMAS(value uint32) {
	volatile.StoreUint32(&o.HTCAPBLT.Reg, volatile.LoadUint32(&o.HTCAPBLT.Reg)&^(0x400000)|value<<22)
}
func (o *SDHC_Type) GetHTCAPBLT_DMAS() uint32 {
	return (volatile.LoadUint32(&o.HTCAPBLT.Reg) & 0x400000) >> 22
}
func (o *SDHC_Type) SetHTCAPBLT_SRS(value uint32) {
	volatile.StoreUint32(&o.HTCAPBLT.Reg, volatile.LoadUint32(&o.HTCAPBLT.Reg)&^(0x800000)|value<<23)
}
func (o *SDHC_Type) GetHTCAPBLT_SRS() uint32 {
	return (volatile.LoadUint32(&o.HTCAPBLT.Reg) & 0x800000) >> 23
}
func (o *SDHC_Type) SetHTCAPBLT_VS33(value uint32) {
	volatile.StoreUint32(&o.HTCAPBLT.Reg, volatile.LoadUint32(&o.HTCAPBLT.Reg)&^(0x1000000)|value<<24)
}
func (o *SDHC_Type) GetHTCAPBLT_VS33() uint32 {
	return (volatile.LoadUint32(&o.HTCAPBLT.Reg) & 0x1000000) >> 24
}

// SDHC.WML: Watermark Level Register
func (o *SDHC_Type) SetWML_RDWML(value uint32) {
	volatile.StoreUint32(&o.WML.Reg, volatile.LoadUint32(&o.WML.Reg)&^(0xff)|value)
}
func (o *SDHC_Type) GetWML_RDWML() uint32 {
	return volatile.LoadUint32(&o.WML.Reg) & 0xff
}
func (o *SDHC_Type) SetWML_WRWML(value uint32) {
	volatile.StoreUint32(&o.WML.Reg, volatile.LoadUint32(&o.WML.Reg)&^(0xff0000)|value<<16)
}
func (o *SDHC_Type) GetWML_WRWML() uint32 {
	return (volatile.LoadUint32(&o.WML.Reg) & 0xff0000) >> 16
}

// SDHC.FEVT: Force Event register
func (o *SDHC_Type) SetFEVT_AC12NE(value uint32) {
	volatile.StoreUint32(&o.FEVT.Reg, volatile.LoadUint32(&o.FEVT.Reg)&^(0x1)|value)
}
func (o *SDHC_Type) GetFEVT_AC12NE() uint32 {
	return volatile.LoadUint32(&o.FEVT.Reg) & 0x1
}
func (o *SDHC_Type) SetFEVT_AC12TOE(value uint32) {
	volatile.StoreUint32(&o.FEVT.Reg, volatile.LoadUint32(&o.FEVT.Reg)&^(0x2)|value<<1)
}
func (o *SDHC_Type) GetFEVT_AC12TOE() uint32 {
	return (volatile.LoadUint32(&o.FEVT.Reg) & 0x2) >> 1
}
func (o *SDHC_Type) SetFEVT_AC12CE(value uint32) {
	volatile.StoreUint32(&o.FEVT.Reg, volatile.LoadUint32(&o.FEVT.Reg)&^(0x4)|value<<2)
}
func (o *SDHC_Type) GetFEVT_AC12CE() uint32 {
	return (volatile.LoadUint32(&o.FEVT.Reg) & 0x4) >> 2
}
func (o *SDHC_Type) SetFEVT_AC12EBE(value uint32) {
	volatile.StoreUint32(&o.FEVT.Reg, volatile.LoadUint32(&o.FEVT.Reg)&^(0x8)|value<<3)
}
func (o *SDHC_Type) GetFEVT_AC12EBE() uint32 {
	return (volatile.LoadUint32(&o.FEVT.Reg) & 0x8) >> 3
}
func (o *SDHC_Type) SetFEVT_AC12IE(value uint32) {
	volatile.StoreUint32(&o.FEVT.Reg, volatile.LoadUint32(&o.FEVT.Reg)&^(0x10)|value<<4)
}
func (o *SDHC_Type) GetFEVT_AC12IE() uint32 {
	return (volatile.LoadUint32(&o.FEVT.Reg) & 0x10) >> 4
}
func (o *SDHC_Type) SetFEVT_CNIBAC12E(value uint32) {
	volatile.StoreUint32(&o.FEVT.Reg, volatile.LoadUint32(&o.FEVT.Reg)&^(0x80)|value<<7)
}
func (o *SDHC_Type) GetFEVT_CNIBAC12E() uint32 {
	return (volatile.LoadUint32(&o.FEVT.Reg) & 0x80) >> 7
}
func (o *SDHC_Type) SetFEVT_CTOE(value uint32) {
	volatile.StoreUint32(&o.FEVT.Reg, volatile.LoadUint32(&o.FEVT.Reg)&^(0x10000)|value<<16)
}
func (o *SDHC_Type) GetFEVT_CTOE() uint32 {
	return (volatile.LoadUint32(&o.FEVT.Reg) & 0x10000) >> 16
}
func (o *SDHC_Type) SetFEVT_CCE(value uint32) {
	volatile.StoreUint32(&o.FEVT.Reg, volatile.LoadUint32(&o.FEVT.Reg)&^(0x20000)|value<<17)
}
func (o *SDHC_Type) GetFEVT_CCE() uint32 {
	return (volatile.LoadUint32(&o.FEVT.Reg) & 0x20000) >> 17
}
func (o *SDHC_Type) SetFEVT_CEBE(value uint32) {
	volatile.StoreUint32(&o.FEVT.Reg, volatile.LoadUint32(&o.FEVT.Reg)&^(0x40000)|value<<18)
}
func (o *SDHC_Type) GetFEVT_CEBE() uint32 {
	return (volatile.LoadUint32(&o.FEVT.Reg) & 0x40000) >> 18
}
func (o *SDHC_Type) SetFEVT_CIE(value uint32) {
	volatile.StoreUint32(&o.FEVT.Reg, volatile.LoadUint32(&o.FEVT.Reg)&^(0x80000)|value<<19)
}
func (o *SDHC_Type) GetFEVT_CIE() uint32 {
	return (volatile.LoadUint32(&o.FEVT.Reg) & 0x80000) >> 19
}
func (o *SDHC_Type) SetFEVT_DTOE(value uint32) {
	volatile.StoreUint32(&o.FEVT.Reg, volatile.LoadUint32(&o.FEVT.Reg)&^(0x100000)|value<<20)
}
func (o *SDHC_Type) GetFEVT_DTOE() uint32 {
	return (volatile.LoadUint32(&o.FEVT.Reg) & 0x100000) >> 20
}
func (o *SDHC_Type) SetFEVT_DCE(value uint32) {
	volatile.StoreUint32(&o.FEVT.Reg, volatile.LoadUint32(&o.FEVT.Reg)&^(0x200000)|value<<21)
}
func (o *SDHC_Type) GetFEVT_DCE() uint32 {
	return (volatile.LoadUint32(&o.FEVT.Reg) & 0x200000) >> 21
}
func (o *SDHC_Type) SetFEVT_DEBE(value uint32) {
	volatile.StoreUint32(&o.FEVT.Reg, volatile.LoadUint32(&o.FEVT.Reg)&^(0x400000)|value<<22)
}
func (o *SDHC_Type) GetFEVT_DEBE() uint32 {
	return (volatile.LoadUint32(&o.FEVT.Reg) & 0x400000) >> 22
}
func (o *SDHC_Type) SetFEVT_AC12E(value uint32) {
	volatile.StoreUint32(&o.FEVT.Reg, volatile.LoadUint32(&o.FEVT.Reg)&^(0x1000000)|value<<24)
}
func (o *SDHC_Type) GetFEVT_AC12E() uint32 {
	return (volatile.LoadUint32(&o.FEVT.Reg) & 0x1000000) >> 24
}
func (o *SDHC_Type) SetFEVT_DMAE(value uint32) {
	volatile.StoreUint32(&o.FEVT.Reg, volatile.LoadUint32(&o.FEVT.Reg)&^(0x10000000)|value<<28)
}
func (o *SDHC_Type) GetFEVT_DMAE() uint32 {
	return (volatile.LoadUint32(&o.FEVT.Reg) & 0x10000000) >> 28
}
func (o *SDHC_Type) SetFEVT_CINT(value uint32) {
	volatile.StoreUint32(&o.FEVT.Reg, volatile.LoadUint32(&o.FEVT.Reg)&^(0x80000000)|value<<31)
}
func (o *SDHC_Type) GetFEVT_CINT() uint32 {
	return (volatile.LoadUint32(&o.FEVT.Reg) & 0x80000000) >> 31
}

// SDHC.ADMAES: ADMA Error Status register
func (o *SDHC_Type) SetADMAES(value uint32) {
	volatile.StoreUint32(&o.ADMAES.Reg, volatile.LoadUint32(&o.ADMAES.Reg)&^(0x3)|value)
}
func (o *SDHC_Type) GetADMAES() uint32 {
	return volatile.LoadUint32(&o.ADMAES.Reg) & 0x3
}
func (o *SDHC_Type) SetADMAES_ADMALME(value uint32) {
	volatile.StoreUint32(&o.ADMAES.Reg, volatile.LoadUint32(&o.ADMAES.Reg)&^(0x4)|value<<2)
}
func (o *SDHC_Type) GetADMAES_ADMALME() uint32 {
	return (volatile.LoadUint32(&o.ADMAES.Reg) & 0x4) >> 2
}
func (o *SDHC_Type) SetADMAES_ADMADCE(value uint32) {
	volatile.StoreUint32(&o.ADMAES.Reg, volatile.LoadUint32(&o.ADMAES.Reg)&^(0x8)|value<<3)
}
func (o *SDHC_Type) GetADMAES_ADMADCE() uint32 {
	return (volatile.LoadUint32(&o.ADMAES.Reg) & 0x8) >> 3
}

// SDHC.ADSADDR: ADMA System Addressregister
func (o *SDHC_Type) SetADSADDR(value uint32) {
	volatile.StoreUint32(&o.ADSADDR.Reg, volatile.LoadUint32(&o.ADSADDR.Reg)&^(0xfffffffc)|value<<2)
}
func (o *SDHC_Type) GetADSADDR() uint32 {
	return (volatile.LoadUint32(&o.ADSADDR.Reg) & 0xfffffffc) >> 2
}

// SDHC.VENDOR: Vendor Specific register
func (o *SDHC_Type) SetVENDOR_EXTDMAEN(value uint32) {
	volatile.StoreUint32(&o.VENDOR.Reg, volatile.LoadUint32(&o.VENDOR.Reg)&^(0x1)|value)
}
func (o *SDHC_Type) GetVENDOR_EXTDMAEN() uint32 {
	return volatile.LoadUint32(&o.VENDOR.Reg) & 0x1
}
func (o *SDHC_Type) SetVENDOR_EXBLKNU(value uint32) {
	volatile.StoreUint32(&o.VENDOR.Reg, volatile.LoadUint32(&o.VENDOR.Reg)&^(0x2)|value<<1)
}
func (o *SDHC_Type) GetVENDOR_EXBLKNU() uint32 {
	return (volatile.LoadUint32(&o.VENDOR.Reg) & 0x2) >> 1
}
func (o *SDHC_Type) SetVENDOR_INTSTVAL(value uint32) {
	volatile.StoreUint32(&o.VENDOR.Reg, volatile.LoadUint32(&o.VENDOR.Reg)&^(0xff0000)|value<<16)
}
func (o *SDHC_Type) GetVENDOR_INTSTVAL() uint32 {
	return (volatile.LoadUint32(&o.VENDOR.Reg) & 0xff0000) >> 16
}

// SDHC.MMCBOOT: MMC Boot register
func (o *SDHC_Type) SetMMCBOOT_DTOCVACK(value uint32) {
	volatile.StoreUint32(&o.MMCBOOT.Reg, volatile.LoadUint32(&o.MMCBOOT.Reg)&^(0xf)|value)
}
func (o *SDHC_Type) GetMMCBOOT_DTOCVACK() uint32 {
	return volatile.LoadUint32(&o.MMCBOOT.Reg) & 0xf
}
func (o *SDHC_Type) SetMMCBOOT_BOOTACK(value uint32) {
	volatile.StoreUint32(&o.MMCBOOT.Reg, volatile.LoadUint32(&o.MMCBOOT.Reg)&^(0x10)|value<<4)
}
func (o *SDHC_Type) GetMMCBOOT_BOOTACK() uint32 {
	return (volatile.LoadUint32(&o.MMCBOOT.Reg) & 0x10) >> 4
}
func (o *SDHC_Type) SetMMCBOOT_BOOTMODE(value uint32) {
	volatile.StoreUint32(&o.MMCBOOT.Reg, volatile.LoadUint32(&o.MMCBOOT.Reg)&^(0x20)|value<<5)
}
func (o *SDHC_Type) GetMMCBOOT_BOOTMODE() uint32 {
	return (volatile.LoadUint32(&o.MMCBOOT.Reg) & 0x20) >> 5
}
func (o *SDHC_Type) SetMMCBOOT_BOOTEN(value uint32) {
	volatile.StoreUint32(&o.MMCBOOT.Reg, volatile.LoadUint32(&o.MMCBOOT.Reg)&^(0x40)|value<<6)
}
func (o *SDHC_Type) GetMMCBOOT_BOOTEN() uint32 {
	return (volatile.LoadUint32(&o.MMCBOOT.Reg) & 0x40) >> 6
}
func (o *SDHC_Type) SetMMCBOOT_AUTOSABGEN(value uint32) {
	volatile.StoreUint32(&o.MMCBOOT.Reg, volatile.LoadUint32(&o.MMCBOOT.Reg)&^(0x80)|value<<7)
}
func (o *SDHC_Type) GetMMCBOOT_AUTOSABGEN() uint32 {
	return (volatile.LoadUint32(&o.MMCBOOT.Reg) & 0x80) >> 7
}
func (o *SDHC_Type) SetMMCBOOT_BOOTBLKCNT(value uint32) {
	volatile.StoreUint32(&o.MMCBOOT.Reg, volatile.LoadUint32(&o.MMCBOOT.Reg)&^(0xffff0000)|value<<16)
}
func (o *SDHC_Type) GetMMCBOOT_BOOTBLKCNT() uint32 {
	return (volatile.LoadUint32(&o.MMCBOOT.Reg) & 0xffff0000) >> 16
}

// SDHC.HOSTVER: Host Controller Version
func (o *SDHC_Type) SetHOSTVER_SVN(value uint32) {
	volatile.StoreUint32(&o.HOSTVER.Reg, volatile.LoadUint32(&o.HOSTVER.Reg)&^(0xff)|value)
}
func (o *SDHC_Type) GetHOSTVER_SVN() uint32 {
	return volatile.LoadUint32(&o.HOSTVER.Reg) & 0xff
}
func (o *SDHC_Type) SetHOSTVER_VVN(value uint32) {
	volatile.StoreUint32(&o.HOSTVER.Reg, volatile.LoadUint32(&o.HOSTVER.Reg)&^(0xff00)|value<<8)
}
func (o *SDHC_Type) GetHOSTVER_VVN() uint32 {
	return (volatile.LoadUint32(&o.HOSTVER.Reg) & 0xff00) >> 8
}

// Ethernet MAC-NET Core
type ENET_Type struct {
	_                  [4]byte
	EIR                volatile.Register32 // 0x4
	EIMR               volatile.Register32 // 0x8
	_                  [4]byte
	RDAR               volatile.Register32 // 0x10
	TDAR               volatile.Register32 // 0x14
	_                  [12]byte
	ECR                volatile.Register32 // 0x24
	_                  [24]byte
	MMFR               volatile.Register32 // 0x40
	MSCR               volatile.Register32 // 0x44
	_                  [28]byte
	MIBC               volatile.Register32 // 0x64
	_                  [28]byte
	RCR                volatile.Register32 // 0x84
	_                  [60]byte
	TCR                volatile.Register32 // 0xC4
	_                  [28]byte
	PALR               volatile.Register32 // 0xE4
	PAUR               volatile.Register32 // 0xE8
	OPD                volatile.Register32 // 0xEC
	_                  [40]byte
	IAUR               volatile.Register32 // 0x118
	IALR               volatile.Register32 // 0x11C
	GAUR               volatile.Register32 // 0x120
	GALR               volatile.Register32 // 0x124
	_                  [28]byte
	TFWR               volatile.Register32 // 0x144
	_                  [56]byte
	RDSR               volatile.Register32 // 0x180
	TDSR               volatile.Register32 // 0x184
	MRBR               volatile.Register32 // 0x188
	_                  [4]byte
	RSFL               volatile.Register32 // 0x190
	RSEM               volatile.Register32 // 0x194
	RAEM               volatile.Register32 // 0x198
	RAFL               volatile.Register32 // 0x19C
	TSEM               volatile.Register32 // 0x1A0
	TAEM               volatile.Register32 // 0x1A4
	TAFL               volatile.Register32 // 0x1A8
	TIPG               volatile.Register32 // 0x1AC
	FTRL               volatile.Register32 // 0x1B0
	_                  [12]byte
	TACC               volatile.Register32 // 0x1C0
	RACC               volatile.Register32 // 0x1C4
	_                  [60]byte
	RMON_T_PACKETS     volatile.Register32 // 0x204
	RMON_T_BC_PKT      volatile.Register32 // 0x208
	RMON_T_MC_PKT      volatile.Register32 // 0x20C
	RMON_T_CRC_ALIGN   volatile.Register32 // 0x210
	RMON_T_UNDERSIZE   volatile.Register32 // 0x214
	RMON_T_OVERSIZE    volatile.Register32 // 0x218
	RMON_T_FRAG        volatile.Register32 // 0x21C
	RMON_T_JAB         volatile.Register32 // 0x220
	RMON_T_COL         volatile.Register32 // 0x224
	RMON_T_P64         volatile.Register32 // 0x228
	RMON_T_P65TO127    volatile.Register32 // 0x22C
	RMON_T_P128TO255   volatile.Register32 // 0x230
	RMON_T_P256TO511   volatile.Register32 // 0x234
	RMON_T_P512TO1023  volatile.Register32 // 0x238
	RMON_T_P1024TO2047 volatile.Register32 // 0x23C
	RMON_T_P_GTE2048   volatile.Register32 // 0x240
	RMON_T_OCTETS      volatile.Register32 // 0x244
	_                  [4]byte
	IEEE_T_FRAME_OK    volatile.Register32 // 0x24C
	IEEE_T_1COL        volatile.Register32 // 0x250
	IEEE_T_MCOL        volatile.Register32 // 0x254
	IEEE_T_DEF         volatile.Register32 // 0x258
	IEEE_T_LCOL        volatile.Register32 // 0x25C
	IEEE_T_EXCOL       volatile.Register32 // 0x260
	IEEE_T_MACERR      volatile.Register32 // 0x264
	IEEE_T_CSERR       volatile.Register32 // 0x268
	_                  [4]byte
	IEEE_T_FDXFC       volatile.Register32 // 0x270
	IEEE_T_OCTETS_OK   volatile.Register32 // 0x274
	_                  [12]byte
	RMON_R_PACKETS     volatile.Register32 // 0x284
	RMON_R_BC_PKT      volatile.Register32 // 0x288
	RMON_R_MC_PKT      volatile.Register32 // 0x28C
	RMON_R_CRC_ALIGN   volatile.Register32 // 0x290
	RMON_R_UNDERSIZE   volatile.Register32 // 0x294
	RMON_R_OVERSIZE    volatile.Register32 // 0x298
	RMON_R_FRAG        volatile.Register32 // 0x29C
	RMON_R_JAB         volatile.Register32 // 0x2A0
	_                  [4]byte
	RMON_R_P64         volatile.Register32 // 0x2A8
	RMON_R_P65TO127    volatile.Register32 // 0x2AC
	RMON_R_P128TO255   volatile.Register32 // 0x2B0
	RMON_R_P256TO511   volatile.Register32 // 0x2B4
	RMON_R_P512TO1023  volatile.Register32 // 0x2B8
	RMON_R_P1024TO2047 volatile.Register32 // 0x2BC
	RMON_R_P_GTE2048   volatile.Register32 // 0x2C0
	RMON_R_OCTETS      volatile.Register32 // 0x2C4
	IEEE_R_DROP        volatile.Register32 // 0x2C8
	IEEE_R_FRAME_OK    volatile.Register32 // 0x2CC
	IEEE_R_CRC         volatile.Register32 // 0x2D0
	IEEE_R_ALIGN       volatile.Register32 // 0x2D4
	IEEE_R_MACERR      volatile.Register32 // 0x2D8
	IEEE_R_FDXFC       volatile.Register32 // 0x2DC
	IEEE_R_OCTETS_OK   volatile.Register32 // 0x2E0
	_                  [284]byte
	ATCR               volatile.Register32 // 0x400
	ATVR               volatile.Register32 // 0x404
	ATOFF              volatile.Register32 // 0x408
	ATPER              volatile.Register32 // 0x40C
	ATCOR              volatile.Register32 // 0x410
	ATINC              volatile.Register32 // 0x414
	ATSTMP             volatile.Register32 // 0x418
	_                  [488]byte
	TGSR               volatile.Register32 // 0x604
	TCSR0              volatile.Register32 // 0x608
	TCCR0              volatile.Register32 // 0x60C
	TCSR1              volatile.Register32 // 0x610
	TCCR1              volatile.Register32 // 0x614
	TCSR2              volatile.Register32 // 0x618
	TCCR2              volatile.Register32 // 0x61C
	TCSR3              volatile.Register32 // 0x620
	TCCR3              volatile.Register32 // 0x624
}

// ENET.EIR: Interrupt Event Register
func (o *ENET_Type) SetEIR_TS_TIMER(value uint32) {
	volatile.StoreUint32(&o.EIR.Reg, volatile.LoadUint32(&o.EIR.Reg)&^(0x8000)|value<<15)
}
func (o *ENET_Type) GetEIR_TS_TIMER() uint32 {
	return (volatile.LoadUint32(&o.EIR.Reg) & 0x8000) >> 15
}
func (o *ENET_Type) SetEIR_TS_AVAIL(value uint32) {
	volatile.StoreUint32(&o.EIR.Reg, volatile.LoadUint32(&o.EIR.Reg)&^(0x10000)|value<<16)
}
func (o *ENET_Type) GetEIR_TS_AVAIL() uint32 {
	return (volatile.LoadUint32(&o.EIR.Reg) & 0x10000) >> 16
}
func (o *ENET_Type) SetEIR_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.EIR.Reg, volatile.LoadUint32(&o.EIR.Reg)&^(0x20000)|value<<17)
}
func (o *ENET_Type) GetEIR_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.EIR.Reg) & 0x20000) >> 17
}
func (o *ENET_Type) SetEIR_PLR(value uint32) {
	volatile.StoreUint32(&o.EIR.Reg, volatile.LoadUint32(&o.EIR.Reg)&^(0x40000)|value<<18)
}
func (o *ENET_Type) GetEIR_PLR() uint32 {
	return (volatile.LoadUint32(&o.EIR.Reg) & 0x40000) >> 18
}
func (o *ENET_Type) SetEIR_UN(value uint32) {
	volatile.StoreUint32(&o.EIR.Reg, volatile.LoadUint32(&o.EIR.Reg)&^(0x80000)|value<<19)
}
func (o *ENET_Type) GetEIR_UN() uint32 {
	return (volatile.LoadUint32(&o.EIR.Reg) & 0x80000) >> 19
}
func (o *ENET_Type) SetEIR_RL(value uint32) {
	volatile.StoreUint32(&o.EIR.Reg, volatile.LoadUint32(&o.EIR.Reg)&^(0x100000)|value<<20)
}
func (o *ENET_Type) GetEIR_RL() uint32 {
	return (volatile.LoadUint32(&o.EIR.Reg) & 0x100000) >> 20
}
func (o *ENET_Type) SetEIR_LC(value uint32) {
	volatile.StoreUint32(&o.EIR.Reg, volatile.LoadUint32(&o.EIR.Reg)&^(0x200000)|value<<21)
}
func (o *ENET_Type) GetEIR_LC() uint32 {
	return (volatile.LoadUint32(&o.EIR.Reg) & 0x200000) >> 21
}
func (o *ENET_Type) SetEIR_EBERR(value uint32) {
	volatile.StoreUint32(&o.EIR.Reg, volatile.LoadUint32(&o.EIR.Reg)&^(0x400000)|value<<22)
}
func (o *ENET_Type) GetEIR_EBERR() uint32 {
	return (volatile.LoadUint32(&o.EIR.Reg) & 0x400000) >> 22
}
func (o *ENET_Type) SetEIR_MII(value uint32) {
	volatile.StoreUint32(&o.EIR.Reg, volatile.LoadUint32(&o.EIR.Reg)&^(0x800000)|value<<23)
}
func (o *ENET_Type) GetEIR_MII() uint32 {
	return (volatile.LoadUint32(&o.EIR.Reg) & 0x800000) >> 23
}
func (o *ENET_Type) SetEIR_RXB(value uint32) {
	volatile.StoreUint32(&o.EIR.Reg, volatile.LoadUint32(&o.EIR.Reg)&^(0x1000000)|value<<24)
}
func (o *ENET_Type) GetEIR_RXB() uint32 {
	return (volatile.LoadUint32(&o.EIR.Reg) & 0x1000000) >> 24
}
func (o *ENET_Type) SetEIR_RXF(value uint32) {
	volatile.StoreUint32(&o.EIR.Reg, volatile.LoadUint32(&o.EIR.Reg)&^(0x2000000)|value<<25)
}
func (o *ENET_Type) GetEIR_RXF() uint32 {
	return (volatile.LoadUint32(&o.EIR.Reg) & 0x2000000) >> 25
}
func (o *ENET_Type) SetEIR_TXB(value uint32) {
	volatile.StoreUint32(&o.EIR.Reg, volatile.LoadUint32(&o.EIR.Reg)&^(0x4000000)|value<<26)
}
func (o *ENET_Type) GetEIR_TXB() uint32 {
	return (volatile.LoadUint32(&o.EIR.Reg) & 0x4000000) >> 26
}
func (o *ENET_Type) SetEIR_TXF(value uint32) {
	volatile.StoreUint32(&o.EIR.Reg, volatile.LoadUint32(&o.EIR.Reg)&^(0x8000000)|value<<27)
}
func (o *ENET_Type) GetEIR_TXF() uint32 {
	return (volatile.LoadUint32(&o.EIR.Reg) & 0x8000000) >> 27
}
func (o *ENET_Type) SetEIR_GRA(value uint32) {
	volatile.StoreUint32(&o.EIR.Reg, volatile.LoadUint32(&o.EIR.Reg)&^(0x10000000)|value<<28)
}
func (o *ENET_Type) GetEIR_GRA() uint32 {
	return (volatile.LoadUint32(&o.EIR.Reg) & 0x10000000) >> 28
}
func (o *ENET_Type) SetEIR_BABT(value uint32) {
	volatile.StoreUint32(&o.EIR.Reg, volatile.LoadUint32(&o.EIR.Reg)&^(0x20000000)|value<<29)
}
func (o *ENET_Type) GetEIR_BABT() uint32 {
	return (volatile.LoadUint32(&o.EIR.Reg) & 0x20000000) >> 29
}
func (o *ENET_Type) SetEIR_BABR(value uint32) {
	volatile.StoreUint32(&o.EIR.Reg, volatile.LoadUint32(&o.EIR.Reg)&^(0x40000000)|value<<30)
}
func (o *ENET_Type) GetEIR_BABR() uint32 {
	return (volatile.LoadUint32(&o.EIR.Reg) & 0x40000000) >> 30
}

// ENET.EIMR: Interrupt Mask Register
func (o *ENET_Type) SetEIMR_TS_TIMER(value uint32) {
	volatile.StoreUint32(&o.EIMR.Reg, volatile.LoadUint32(&o.EIMR.Reg)&^(0x8000)|value<<15)
}
func (o *ENET_Type) GetEIMR_TS_TIMER() uint32 {
	return (volatile.LoadUint32(&o.EIMR.Reg) & 0x8000) >> 15
}
func (o *ENET_Type) SetEIMR_TS_AVAIL(value uint32) {
	volatile.StoreUint32(&o.EIMR.Reg, volatile.LoadUint32(&o.EIMR.Reg)&^(0x10000)|value<<16)
}
func (o *ENET_Type) GetEIMR_TS_AVAIL() uint32 {
	return (volatile.LoadUint32(&o.EIMR.Reg) & 0x10000) >> 16
}
func (o *ENET_Type) SetEIMR_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.EIMR.Reg, volatile.LoadUint32(&o.EIMR.Reg)&^(0x20000)|value<<17)
}
func (o *ENET_Type) GetEIMR_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.EIMR.Reg) & 0x20000) >> 17
}
func (o *ENET_Type) SetEIMR_PLR(value uint32) {
	volatile.StoreUint32(&o.EIMR.Reg, volatile.LoadUint32(&o.EIMR.Reg)&^(0x40000)|value<<18)
}
func (o *ENET_Type) GetEIMR_PLR() uint32 {
	return (volatile.LoadUint32(&o.EIMR.Reg) & 0x40000) >> 18
}
func (o *ENET_Type) SetEIMR_UN(value uint32) {
	volatile.StoreUint32(&o.EIMR.Reg, volatile.LoadUint32(&o.EIMR.Reg)&^(0x80000)|value<<19)
}
func (o *ENET_Type) GetEIMR_UN() uint32 {
	return (volatile.LoadUint32(&o.EIMR.Reg) & 0x80000) >> 19
}
func (o *ENET_Type) SetEIMR_RL(value uint32) {
	volatile.StoreUint32(&o.EIMR.Reg, volatile.LoadUint32(&o.EIMR.Reg)&^(0x100000)|value<<20)
}
func (o *ENET_Type) GetEIMR_RL() uint32 {
	return (volatile.LoadUint32(&o.EIMR.Reg) & 0x100000) >> 20
}
func (o *ENET_Type) SetEIMR_LC(value uint32) {
	volatile.StoreUint32(&o.EIMR.Reg, volatile.LoadUint32(&o.EIMR.Reg)&^(0x200000)|value<<21)
}
func (o *ENET_Type) GetEIMR_LC() uint32 {
	return (volatile.LoadUint32(&o.EIMR.Reg) & 0x200000) >> 21
}
func (o *ENET_Type) SetEIMR_EBERR(value uint32) {
	volatile.StoreUint32(&o.EIMR.Reg, volatile.LoadUint32(&o.EIMR.Reg)&^(0x400000)|value<<22)
}
func (o *ENET_Type) GetEIMR_EBERR() uint32 {
	return (volatile.LoadUint32(&o.EIMR.Reg) & 0x400000) >> 22
}
func (o *ENET_Type) SetEIMR_MII(value uint32) {
	volatile.StoreUint32(&o.EIMR.Reg, volatile.LoadUint32(&o.EIMR.Reg)&^(0x800000)|value<<23)
}
func (o *ENET_Type) GetEIMR_MII() uint32 {
	return (volatile.LoadUint32(&o.EIMR.Reg) & 0x800000) >> 23
}
func (o *ENET_Type) SetEIMR_RXB(value uint32) {
	volatile.StoreUint32(&o.EIMR.Reg, volatile.LoadUint32(&o.EIMR.Reg)&^(0x1000000)|value<<24)
}
func (o *ENET_Type) GetEIMR_RXB() uint32 {
	return (volatile.LoadUint32(&o.EIMR.Reg) & 0x1000000) >> 24
}
func (o *ENET_Type) SetEIMR_RXF(value uint32) {
	volatile.StoreUint32(&o.EIMR.Reg, volatile.LoadUint32(&o.EIMR.Reg)&^(0x2000000)|value<<25)
}
func (o *ENET_Type) GetEIMR_RXF() uint32 {
	return (volatile.LoadUint32(&o.EIMR.Reg) & 0x2000000) >> 25
}
func (o *ENET_Type) SetEIMR_TXB(value uint32) {
	volatile.StoreUint32(&o.EIMR.Reg, volatile.LoadUint32(&o.EIMR.Reg)&^(0x4000000)|value<<26)
}
func (o *ENET_Type) GetEIMR_TXB() uint32 {
	return (volatile.LoadUint32(&o.EIMR.Reg) & 0x4000000) >> 26
}
func (o *ENET_Type) SetEIMR_TXF(value uint32) {
	volatile.StoreUint32(&o.EIMR.Reg, volatile.LoadUint32(&o.EIMR.Reg)&^(0x8000000)|value<<27)
}
func (o *ENET_Type) GetEIMR_TXF() uint32 {
	return (volatile.LoadUint32(&o.EIMR.Reg) & 0x8000000) >> 27
}
func (o *ENET_Type) SetEIMR_GRA(value uint32) {
	volatile.StoreUint32(&o.EIMR.Reg, volatile.LoadUint32(&o.EIMR.Reg)&^(0x10000000)|value<<28)
}
func (o *ENET_Type) GetEIMR_GRA() uint32 {
	return (volatile.LoadUint32(&o.EIMR.Reg) & 0x10000000) >> 28
}
func (o *ENET_Type) SetEIMR_BABT(value uint32) {
	volatile.StoreUint32(&o.EIMR.Reg, volatile.LoadUint32(&o.EIMR.Reg)&^(0x20000000)|value<<29)
}
func (o *ENET_Type) GetEIMR_BABT() uint32 {
	return (volatile.LoadUint32(&o.EIMR.Reg) & 0x20000000) >> 29
}
func (o *ENET_Type) SetEIMR_BABR(value uint32) {
	volatile.StoreUint32(&o.EIMR.Reg, volatile.LoadUint32(&o.EIMR.Reg)&^(0x40000000)|value<<30)
}
func (o *ENET_Type) GetEIMR_BABR() uint32 {
	return (volatile.LoadUint32(&o.EIMR.Reg) & 0x40000000) >> 30
}

// ENET.RDAR: Receive Descriptor Active Register
func (o *ENET_Type) SetRDAR(value uint32) {
	volatile.StoreUint32(&o.RDAR.Reg, volatile.LoadUint32(&o.RDAR.Reg)&^(0x1000000)|value<<24)
}
func (o *ENET_Type) GetRDAR() uint32 {
	return (volatile.LoadUint32(&o.RDAR.Reg) & 0x1000000) >> 24
}

// ENET.TDAR: Transmit Descriptor Active Register
func (o *ENET_Type) SetTDAR(value uint32) {
	volatile.StoreUint32(&o.TDAR.Reg, volatile.LoadUint32(&o.TDAR.Reg)&^(0x1000000)|value<<24)
}
func (o *ENET_Type) GetTDAR() uint32 {
	return (volatile.LoadUint32(&o.TDAR.Reg) & 0x1000000) >> 24
}

// ENET.ECR: Ethernet Control Register
func (o *ENET_Type) SetECR_RESET(value uint32) {
	volatile.StoreUint32(&o.ECR.Reg, volatile.LoadUint32(&o.ECR.Reg)&^(0x1)|value)
}
func (o *ENET_Type) GetECR_RESET() uint32 {
	return volatile.LoadUint32(&o.ECR.Reg) & 0x1
}
func (o *ENET_Type) SetECR_ETHEREN(value uint32) {
	volatile.StoreUint32(&o.ECR.Reg, volatile.LoadUint32(&o.ECR.Reg)&^(0x2)|value<<1)
}
func (o *ENET_Type) GetECR_ETHEREN() uint32 {
	return (volatile.LoadUint32(&o.ECR.Reg) & 0x2) >> 1
}
func (o *ENET_Type) SetECR_MAGICEN(value uint32) {
	volatile.StoreUint32(&o.ECR.Reg, volatile.LoadUint32(&o.ECR.Reg)&^(0x4)|value<<2)
}
func (o *ENET_Type) GetECR_MAGICEN() uint32 {
	return (volatile.LoadUint32(&o.ECR.Reg) & 0x4) >> 2
}
func (o *ENET_Type) SetECR_SLEEP(value uint32) {
	volatile.StoreUint32(&o.ECR.Reg, volatile.LoadUint32(&o.ECR.Reg)&^(0x8)|value<<3)
}
func (o *ENET_Type) GetECR_SLEEP() uint32 {
	return (volatile.LoadUint32(&o.ECR.Reg) & 0x8) >> 3
}
func (o *ENET_Type) SetECR_EN1588(value uint32) {
	volatile.StoreUint32(&o.ECR.Reg, volatile.LoadUint32(&o.ECR.Reg)&^(0x10)|value<<4)
}
func (o *ENET_Type) GetECR_EN1588() uint32 {
	return (volatile.LoadUint32(&o.ECR.Reg) & 0x10) >> 4
}
func (o *ENET_Type) SetECR_DBGEN(value uint32) {
	volatile.StoreUint32(&o.ECR.Reg, volatile.LoadUint32(&o.ECR.Reg)&^(0x40)|value<<6)
}
func (o *ENET_Type) GetECR_DBGEN() uint32 {
	return (volatile.LoadUint32(&o.ECR.Reg) & 0x40) >> 6
}
func (o *ENET_Type) SetECR_STOPEN(value uint32) {
	volatile.StoreUint32(&o.ECR.Reg, volatile.LoadUint32(&o.ECR.Reg)&^(0x80)|value<<7)
}
func (o *ENET_Type) GetECR_STOPEN() uint32 {
	return (volatile.LoadUint32(&o.ECR.Reg) & 0x80) >> 7
}
func (o *ENET_Type) SetECR_DBSWP(value uint32) {
	volatile.StoreUint32(&o.ECR.Reg, volatile.LoadUint32(&o.ECR.Reg)&^(0x100)|value<<8)
}
func (o *ENET_Type) GetECR_DBSWP() uint32 {
	return (volatile.LoadUint32(&o.ECR.Reg) & 0x100) >> 8
}

// ENET.MMFR: MII Management Frame Register
func (o *ENET_Type) SetMMFR_DATA(value uint32) {
	volatile.StoreUint32(&o.MMFR.Reg, volatile.LoadUint32(&o.MMFR.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetMMFR_DATA() uint32 {
	return volatile.LoadUint32(&o.MMFR.Reg) & 0xffff
}
func (o *ENET_Type) SetMMFR_TA(value uint32) {
	volatile.StoreUint32(&o.MMFR.Reg, volatile.LoadUint32(&o.MMFR.Reg)&^(0x30000)|value<<16)
}
func (o *ENET_Type) GetMMFR_TA() uint32 {
	return (volatile.LoadUint32(&o.MMFR.Reg) & 0x30000) >> 16
}
func (o *ENET_Type) SetMMFR_RA(value uint32) {
	volatile.StoreUint32(&o.MMFR.Reg, volatile.LoadUint32(&o.MMFR.Reg)&^(0x7c0000)|value<<18)
}
func (o *ENET_Type) GetMMFR_RA() uint32 {
	return (volatile.LoadUint32(&o.MMFR.Reg) & 0x7c0000) >> 18
}
func (o *ENET_Type) SetMMFR_PA(value uint32) {
	volatile.StoreUint32(&o.MMFR.Reg, volatile.LoadUint32(&o.MMFR.Reg)&^(0xf800000)|value<<23)
}
func (o *ENET_Type) GetMMFR_PA() uint32 {
	return (volatile.LoadUint32(&o.MMFR.Reg) & 0xf800000) >> 23
}
func (o *ENET_Type) SetMMFR_OP(value uint32) {
	volatile.StoreUint32(&o.MMFR.Reg, volatile.LoadUint32(&o.MMFR.Reg)&^(0x30000000)|value<<28)
}
func (o *ENET_Type) GetMMFR_OP() uint32 {
	return (volatile.LoadUint32(&o.MMFR.Reg) & 0x30000000) >> 28
}
func (o *ENET_Type) SetMMFR_ST(value uint32) {
	volatile.StoreUint32(&o.MMFR.Reg, volatile.LoadUint32(&o.MMFR.Reg)&^(0xc0000000)|value<<30)
}
func (o *ENET_Type) GetMMFR_ST() uint32 {
	return (volatile.LoadUint32(&o.MMFR.Reg) & 0xc0000000) >> 30
}

// ENET.MSCR: MII Speed Control Register
func (o *ENET_Type) SetMSCR_MII_SPEED(value uint32) {
	volatile.StoreUint32(&o.MSCR.Reg, volatile.LoadUint32(&o.MSCR.Reg)&^(0x7e)|value<<1)
}
func (o *ENET_Type) GetMSCR_MII_SPEED() uint32 {
	return (volatile.LoadUint32(&o.MSCR.Reg) & 0x7e) >> 1
}
func (o *ENET_Type) SetMSCR_DIS_PRE(value uint32) {
	volatile.StoreUint32(&o.MSCR.Reg, volatile.LoadUint32(&o.MSCR.Reg)&^(0x80)|value<<7)
}
func (o *ENET_Type) GetMSCR_DIS_PRE() uint32 {
	return (volatile.LoadUint32(&o.MSCR.Reg) & 0x80) >> 7
}
func (o *ENET_Type) SetMSCR_HOLDTIME(value uint32) {
	volatile.StoreUint32(&o.MSCR.Reg, volatile.LoadUint32(&o.MSCR.Reg)&^(0x700)|value<<8)
}
func (o *ENET_Type) GetMSCR_HOLDTIME() uint32 {
	return (volatile.LoadUint32(&o.MSCR.Reg) & 0x700) >> 8
}

// ENET.MIBC: MIB Control Register
func (o *ENET_Type) SetMIBC_MIB_CLEAR(value uint32) {
	volatile.StoreUint32(&o.MIBC.Reg, volatile.LoadUint32(&o.MIBC.Reg)&^(0x20000000)|value<<29)
}
func (o *ENET_Type) GetMIBC_MIB_CLEAR() uint32 {
	return (volatile.LoadUint32(&o.MIBC.Reg) & 0x20000000) >> 29
}
func (o *ENET_Type) SetMIBC_MIB_IDLE(value uint32) {
	volatile.StoreUint32(&o.MIBC.Reg, volatile.LoadUint32(&o.MIBC.Reg)&^(0x40000000)|value<<30)
}
func (o *ENET_Type) GetMIBC_MIB_IDLE() uint32 {
	return (volatile.LoadUint32(&o.MIBC.Reg) & 0x40000000) >> 30
}
func (o *ENET_Type) SetMIBC_MIB_DIS(value uint32) {
	volatile.StoreUint32(&o.MIBC.Reg, volatile.LoadUint32(&o.MIBC.Reg)&^(0x80000000)|value<<31)
}
func (o *ENET_Type) GetMIBC_MIB_DIS() uint32 {
	return (volatile.LoadUint32(&o.MIBC.Reg) & 0x80000000) >> 31
}

// ENET.RCR: Receive Control Register
func (o *ENET_Type) SetRCR_LOOP(value uint32) {
	volatile.StoreUint32(&o.RCR.Reg, volatile.LoadUint32(&o.RCR.Reg)&^(0x1)|value)
}
func (o *ENET_Type) GetRCR_LOOP() uint32 {
	return volatile.LoadUint32(&o.RCR.Reg) & 0x1
}
func (o *ENET_Type) SetRCR_DRT(value uint32) {
	volatile.StoreUint32(&o.RCR.Reg, volatile.LoadUint32(&o.RCR.Reg)&^(0x2)|value<<1)
}
func (o *ENET_Type) GetRCR_DRT() uint32 {
	return (volatile.LoadUint32(&o.RCR.Reg) & 0x2) >> 1
}
func (o *ENET_Type) SetRCR_MII_MODE(value uint32) {
	volatile.StoreUint32(&o.RCR.Reg, volatile.LoadUint32(&o.RCR.Reg)&^(0x4)|value<<2)
}
func (o *ENET_Type) GetRCR_MII_MODE() uint32 {
	return (volatile.LoadUint32(&o.RCR.Reg) & 0x4) >> 2
}
func (o *ENET_Type) SetRCR_PROM(value uint32) {
	volatile.StoreUint32(&o.RCR.Reg, volatile.LoadUint32(&o.RCR.Reg)&^(0x8)|value<<3)
}
func (o *ENET_Type) GetRCR_PROM() uint32 {
	return (volatile.LoadUint32(&o.RCR.Reg) & 0x8) >> 3
}
func (o *ENET_Type) SetRCR_BC_REJ(value uint32) {
	volatile.StoreUint32(&o.RCR.Reg, volatile.LoadUint32(&o.RCR.Reg)&^(0x10)|value<<4)
}
func (o *ENET_Type) GetRCR_BC_REJ() uint32 {
	return (volatile.LoadUint32(&o.RCR.Reg) & 0x10) >> 4
}
func (o *ENET_Type) SetRCR_FCE(value uint32) {
	volatile.StoreUint32(&o.RCR.Reg, volatile.LoadUint32(&o.RCR.Reg)&^(0x20)|value<<5)
}
func (o *ENET_Type) GetRCR_FCE() uint32 {
	return (volatile.LoadUint32(&o.RCR.Reg) & 0x20) >> 5
}
func (o *ENET_Type) SetRCR_RMII_MODE(value uint32) {
	volatile.StoreUint32(&o.RCR.Reg, volatile.LoadUint32(&o.RCR.Reg)&^(0x100)|value<<8)
}
func (o *ENET_Type) GetRCR_RMII_MODE() uint32 {
	return (volatile.LoadUint32(&o.RCR.Reg) & 0x100) >> 8
}
func (o *ENET_Type) SetRCR_RMII_10T(value uint32) {
	volatile.StoreUint32(&o.RCR.Reg, volatile.LoadUint32(&o.RCR.Reg)&^(0x200)|value<<9)
}
func (o *ENET_Type) GetRCR_RMII_10T() uint32 {
	return (volatile.LoadUint32(&o.RCR.Reg) & 0x200) >> 9
}
func (o *ENET_Type) SetRCR_PADEN(value uint32) {
	volatile.StoreUint32(&o.RCR.Reg, volatile.LoadUint32(&o.RCR.Reg)&^(0x1000)|value<<12)
}
func (o *ENET_Type) GetRCR_PADEN() uint32 {
	return (volatile.LoadUint32(&o.RCR.Reg) & 0x1000) >> 12
}
func (o *ENET_Type) SetRCR_PAUFWD(value uint32) {
	volatile.StoreUint32(&o.RCR.Reg, volatile.LoadUint32(&o.RCR.Reg)&^(0x2000)|value<<13)
}
func (o *ENET_Type) GetRCR_PAUFWD() uint32 {
	return (volatile.LoadUint32(&o.RCR.Reg) & 0x2000) >> 13
}
func (o *ENET_Type) SetRCR_CRCFWD(value uint32) {
	volatile.StoreUint32(&o.RCR.Reg, volatile.LoadUint32(&o.RCR.Reg)&^(0x4000)|value<<14)
}
func (o *ENET_Type) GetRCR_CRCFWD() uint32 {
	return (volatile.LoadUint32(&o.RCR.Reg) & 0x4000) >> 14
}
func (o *ENET_Type) SetRCR_CFEN(value uint32) {
	volatile.StoreUint32(&o.RCR.Reg, volatile.LoadUint32(&o.RCR.Reg)&^(0x8000)|value<<15)
}
func (o *ENET_Type) GetRCR_CFEN() uint32 {
	return (volatile.LoadUint32(&o.RCR.Reg) & 0x8000) >> 15
}
func (o *ENET_Type) SetRCR_MAX_FL(value uint32) {
	volatile.StoreUint32(&o.RCR.Reg, volatile.LoadUint32(&o.RCR.Reg)&^(0x3fff0000)|value<<16)
}
func (o *ENET_Type) GetRCR_MAX_FL() uint32 {
	return (volatile.LoadUint32(&o.RCR.Reg) & 0x3fff0000) >> 16
}
func (o *ENET_Type) SetRCR_NLC(value uint32) {
	volatile.StoreUint32(&o.RCR.Reg, volatile.LoadUint32(&o.RCR.Reg)&^(0x40000000)|value<<30)
}
func (o *ENET_Type) GetRCR_NLC() uint32 {
	return (volatile.LoadUint32(&o.RCR.Reg) & 0x40000000) >> 30
}
func (o *ENET_Type) SetRCR_GRS(value uint32) {
	volatile.StoreUint32(&o.RCR.Reg, volatile.LoadUint32(&o.RCR.Reg)&^(0x80000000)|value<<31)
}
func (o *ENET_Type) GetRCR_GRS() uint32 {
	return (volatile.LoadUint32(&o.RCR.Reg) & 0x80000000) >> 31
}

// ENET.TCR: Transmit Control Register
func (o *ENET_Type) SetTCR_GTS(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0x1)|value)
}
func (o *ENET_Type) GetTCR_GTS() uint32 {
	return volatile.LoadUint32(&o.TCR.Reg) & 0x1
}
func (o *ENET_Type) SetTCR_FDEN(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0x4)|value<<2)
}
func (o *ENET_Type) GetTCR_FDEN() uint32 {
	return (volatile.LoadUint32(&o.TCR.Reg) & 0x4) >> 2
}
func (o *ENET_Type) SetTCR_TFC_PAUSE(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0x8)|value<<3)
}
func (o *ENET_Type) GetTCR_TFC_PAUSE() uint32 {
	return (volatile.LoadUint32(&o.TCR.Reg) & 0x8) >> 3
}
func (o *ENET_Type) SetTCR_RFC_PAUSE(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0x10)|value<<4)
}
func (o *ENET_Type) GetTCR_RFC_PAUSE() uint32 {
	return (volatile.LoadUint32(&o.TCR.Reg) & 0x10) >> 4
}
func (o *ENET_Type) SetTCR_ADDSEL(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0xe0)|value<<5)
}
func (o *ENET_Type) GetTCR_ADDSEL() uint32 {
	return (volatile.LoadUint32(&o.TCR.Reg) & 0xe0) >> 5
}
func (o *ENET_Type) SetTCR_ADDINS(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0x100)|value<<8)
}
func (o *ENET_Type) GetTCR_ADDINS() uint32 {
	return (volatile.LoadUint32(&o.TCR.Reg) & 0x100) >> 8
}
func (o *ENET_Type) SetTCR_CRCFWD(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0x200)|value<<9)
}
func (o *ENET_Type) GetTCR_CRCFWD() uint32 {
	return (volatile.LoadUint32(&o.TCR.Reg) & 0x200) >> 9
}

// ENET.PALR: Physical Address Lower Register
func (o *ENET_Type) SetPALR(value uint32) {
	volatile.StoreUint32(&o.PALR.Reg, value)
}
func (o *ENET_Type) GetPALR() uint32 {
	return volatile.LoadUint32(&o.PALR.Reg)
}

// ENET.PAUR: Physical Address Upper Register
func (o *ENET_Type) SetPAUR_TYPE(value uint32) {
	volatile.StoreUint32(&o.PAUR.Reg, volatile.LoadUint32(&o.PAUR.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetPAUR_TYPE() uint32 {
	return volatile.LoadUint32(&o.PAUR.Reg) & 0xffff
}
func (o *ENET_Type) SetPAUR_PADDR2(value uint32) {
	volatile.StoreUint32(&o.PAUR.Reg, volatile.LoadUint32(&o.PAUR.Reg)&^(0xffff0000)|value<<16)
}
func (o *ENET_Type) GetPAUR_PADDR2() uint32 {
	return (volatile.LoadUint32(&o.PAUR.Reg) & 0xffff0000) >> 16
}

// ENET.OPD: Opcode/Pause Duration Register
func (o *ENET_Type) SetOPD_PAUSE_DUR(value uint32) {
	volatile.StoreUint32(&o.OPD.Reg, volatile.LoadUint32(&o.OPD.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetOPD_PAUSE_DUR() uint32 {
	return volatile.LoadUint32(&o.OPD.Reg) & 0xffff
}
func (o *ENET_Type) SetOPD_OPCODE(value uint32) {
	volatile.StoreUint32(&o.OPD.Reg, volatile.LoadUint32(&o.OPD.Reg)&^(0xffff0000)|value<<16)
}
func (o *ENET_Type) GetOPD_OPCODE() uint32 {
	return (volatile.LoadUint32(&o.OPD.Reg) & 0xffff0000) >> 16
}

// ENET.IAUR: Descriptor Individual Upper Address Register
func (o *ENET_Type) SetIAUR(value uint32) {
	volatile.StoreUint32(&o.IAUR.Reg, value)
}
func (o *ENET_Type) GetIAUR() uint32 {
	return volatile.LoadUint32(&o.IAUR.Reg)
}

// ENET.IALR: Descriptor Individual Lower Address Register
func (o *ENET_Type) SetIALR(value uint32) {
	volatile.StoreUint32(&o.IALR.Reg, value)
}
func (o *ENET_Type) GetIALR() uint32 {
	return volatile.LoadUint32(&o.IALR.Reg)
}

// ENET.GAUR: Descriptor Group Upper Address Register
func (o *ENET_Type) SetGAUR(value uint32) {
	volatile.StoreUint32(&o.GAUR.Reg, value)
}
func (o *ENET_Type) GetGAUR() uint32 {
	return volatile.LoadUint32(&o.GAUR.Reg)
}

// ENET.GALR: Descriptor Group Lower Address Register
func (o *ENET_Type) SetGALR(value uint32) {
	volatile.StoreUint32(&o.GALR.Reg, value)
}
func (o *ENET_Type) GetGALR() uint32 {
	return volatile.LoadUint32(&o.GALR.Reg)
}

// ENET.TFWR: Transmit FIFO Watermark Register
func (o *ENET_Type) SetTFWR(value uint32) {
	volatile.StoreUint32(&o.TFWR.Reg, volatile.LoadUint32(&o.TFWR.Reg)&^(0x3f)|value)
}
func (o *ENET_Type) GetTFWR() uint32 {
	return volatile.LoadUint32(&o.TFWR.Reg) & 0x3f
}
func (o *ENET_Type) SetTFWR_STRFWD(value uint32) {
	volatile.StoreUint32(&o.TFWR.Reg, volatile.LoadUint32(&o.TFWR.Reg)&^(0x100)|value<<8)
}
func (o *ENET_Type) GetTFWR_STRFWD() uint32 {
	return (volatile.LoadUint32(&o.TFWR.Reg) & 0x100) >> 8
}

// ENET.RDSR: Receive Descriptor Ring Start Register
func (o *ENET_Type) SetRDSR_R_DES_START(value uint32) {
	volatile.StoreUint32(&o.RDSR.Reg, volatile.LoadUint32(&o.RDSR.Reg)&^(0xfffffff8)|value<<3)
}
func (o *ENET_Type) GetRDSR_R_DES_START() uint32 {
	return (volatile.LoadUint32(&o.RDSR.Reg) & 0xfffffff8) >> 3
}

// ENET.TDSR: Transmit Buffer Descriptor Ring Start Register
func (o *ENET_Type) SetTDSR_X_DES_START(value uint32) {
	volatile.StoreUint32(&o.TDSR.Reg, volatile.LoadUint32(&o.TDSR.Reg)&^(0xfffffff8)|value<<3)
}
func (o *ENET_Type) GetTDSR_X_DES_START() uint32 {
	return (volatile.LoadUint32(&o.TDSR.Reg) & 0xfffffff8) >> 3
}

// ENET.MRBR: Maximum Receive Buffer Size Register
func (o *ENET_Type) SetMRBR_R_BUF_SIZE(value uint32) {
	volatile.StoreUint32(&o.MRBR.Reg, volatile.LoadUint32(&o.MRBR.Reg)&^(0x3ff0)|value<<4)
}
func (o *ENET_Type) GetMRBR_R_BUF_SIZE() uint32 {
	return (volatile.LoadUint32(&o.MRBR.Reg) & 0x3ff0) >> 4
}

// ENET.RSFL: Receive FIFO Section Full Threshold
func (o *ENET_Type) SetRSFL_RX_SECTION_FULL(value uint32) {
	volatile.StoreUint32(&o.RSFL.Reg, volatile.LoadUint32(&o.RSFL.Reg)&^(0xff)|value)
}
func (o *ENET_Type) GetRSFL_RX_SECTION_FULL() uint32 {
	return volatile.LoadUint32(&o.RSFL.Reg) & 0xff
}

// ENET.RSEM: Receive FIFO Section Empty Threshold
func (o *ENET_Type) SetRSEM_RX_SECTION_EMPTY(value uint32) {
	volatile.StoreUint32(&o.RSEM.Reg, volatile.LoadUint32(&o.RSEM.Reg)&^(0xff)|value)
}
func (o *ENET_Type) GetRSEM_RX_SECTION_EMPTY() uint32 {
	return volatile.LoadUint32(&o.RSEM.Reg) & 0xff
}
func (o *ENET_Type) SetRSEM_STAT_SECTION_EMPTY(value uint32) {
	volatile.StoreUint32(&o.RSEM.Reg, volatile.LoadUint32(&o.RSEM.Reg)&^(0x1f0000)|value<<16)
}
func (o *ENET_Type) GetRSEM_STAT_SECTION_EMPTY() uint32 {
	return (volatile.LoadUint32(&o.RSEM.Reg) & 0x1f0000) >> 16
}

// ENET.RAEM: Receive FIFO Almost Empty Threshold
func (o *ENET_Type) SetRAEM_RX_ALMOST_EMPTY(value uint32) {
	volatile.StoreUint32(&o.RAEM.Reg, volatile.LoadUint32(&o.RAEM.Reg)&^(0xff)|value)
}
func (o *ENET_Type) GetRAEM_RX_ALMOST_EMPTY() uint32 {
	return volatile.LoadUint32(&o.RAEM.Reg) & 0xff
}

// ENET.RAFL: Receive FIFO Almost Full Threshold
func (o *ENET_Type) SetRAFL_RX_ALMOST_FULL(value uint32) {
	volatile.StoreUint32(&o.RAFL.Reg, volatile.LoadUint32(&o.RAFL.Reg)&^(0xff)|value)
}
func (o *ENET_Type) GetRAFL_RX_ALMOST_FULL() uint32 {
	return volatile.LoadUint32(&o.RAFL.Reg) & 0xff
}

// ENET.TSEM: Transmit FIFO Section Empty Threshold
func (o *ENET_Type) SetTSEM_TX_SECTION_EMPTY(value uint32) {
	volatile.StoreUint32(&o.TSEM.Reg, volatile.LoadUint32(&o.TSEM.Reg)&^(0xff)|value)
}
func (o *ENET_Type) GetTSEM_TX_SECTION_EMPTY() uint32 {
	return volatile.LoadUint32(&o.TSEM.Reg) & 0xff
}

// ENET.TAEM: Transmit FIFO Almost Empty Threshold
func (o *ENET_Type) SetTAEM_TX_ALMOST_EMPTY(value uint32) {
	volatile.StoreUint32(&o.TAEM.Reg, volatile.LoadUint32(&o.TAEM.Reg)&^(0xff)|value)
}
func (o *ENET_Type) GetTAEM_TX_ALMOST_EMPTY() uint32 {
	return volatile.LoadUint32(&o.TAEM.Reg) & 0xff
}

// ENET.TAFL: Transmit FIFO Almost Full Threshold
func (o *ENET_Type) SetTAFL_TX_ALMOST_FULL(value uint32) {
	volatile.StoreUint32(&o.TAFL.Reg, volatile.LoadUint32(&o.TAFL.Reg)&^(0xff)|value)
}
func (o *ENET_Type) GetTAFL_TX_ALMOST_FULL() uint32 {
	return volatile.LoadUint32(&o.TAFL.Reg) & 0xff
}

// ENET.TIPG: Transmit Inter-Packet Gap
func (o *ENET_Type) SetTIPG_IPG(value uint32) {
	volatile.StoreUint32(&o.TIPG.Reg, volatile.LoadUint32(&o.TIPG.Reg)&^(0x1f)|value)
}
func (o *ENET_Type) GetTIPG_IPG() uint32 {
	return volatile.LoadUint32(&o.TIPG.Reg) & 0x1f
}

// ENET.FTRL: Frame Truncation Length
func (o *ENET_Type) SetFTRL_TRUNC_FL(value uint32) {
	volatile.StoreUint32(&o.FTRL.Reg, volatile.LoadUint32(&o.FTRL.Reg)&^(0x3fff)|value)
}
func (o *ENET_Type) GetFTRL_TRUNC_FL() uint32 {
	return volatile.LoadUint32(&o.FTRL.Reg) & 0x3fff
}

// ENET.TACC: Transmit Accelerator Function Configuration
func (o *ENET_Type) SetTACC_SHIFT16(value uint32) {
	volatile.StoreUint32(&o.TACC.Reg, volatile.LoadUint32(&o.TACC.Reg)&^(0x1)|value)
}
func (o *ENET_Type) GetTACC_SHIFT16() uint32 {
	return volatile.LoadUint32(&o.TACC.Reg) & 0x1
}
func (o *ENET_Type) SetTACC_IPCHK(value uint32) {
	volatile.StoreUint32(&o.TACC.Reg, volatile.LoadUint32(&o.TACC.Reg)&^(0x8)|value<<3)
}
func (o *ENET_Type) GetTACC_IPCHK() uint32 {
	return (volatile.LoadUint32(&o.TACC.Reg) & 0x8) >> 3
}
func (o *ENET_Type) SetTACC_PROCHK(value uint32) {
	volatile.StoreUint32(&o.TACC.Reg, volatile.LoadUint32(&o.TACC.Reg)&^(0x10)|value<<4)
}
func (o *ENET_Type) GetTACC_PROCHK() uint32 {
	return (volatile.LoadUint32(&o.TACC.Reg) & 0x10) >> 4
}

// ENET.RACC: Receive Accelerator Function Configuration
func (o *ENET_Type) SetRACC_PADREM(value uint32) {
	volatile.StoreUint32(&o.RACC.Reg, volatile.LoadUint32(&o.RACC.Reg)&^(0x1)|value)
}
func (o *ENET_Type) GetRACC_PADREM() uint32 {
	return volatile.LoadUint32(&o.RACC.Reg) & 0x1
}
func (o *ENET_Type) SetRACC_IPDIS(value uint32) {
	volatile.StoreUint32(&o.RACC.Reg, volatile.LoadUint32(&o.RACC.Reg)&^(0x2)|value<<1)
}
func (o *ENET_Type) GetRACC_IPDIS() uint32 {
	return (volatile.LoadUint32(&o.RACC.Reg) & 0x2) >> 1
}
func (o *ENET_Type) SetRACC_PRODIS(value uint32) {
	volatile.StoreUint32(&o.RACC.Reg, volatile.LoadUint32(&o.RACC.Reg)&^(0x4)|value<<2)
}
func (o *ENET_Type) GetRACC_PRODIS() uint32 {
	return (volatile.LoadUint32(&o.RACC.Reg) & 0x4) >> 2
}
func (o *ENET_Type) SetRACC_LINEDIS(value uint32) {
	volatile.StoreUint32(&o.RACC.Reg, volatile.LoadUint32(&o.RACC.Reg)&^(0x40)|value<<6)
}
func (o *ENET_Type) GetRACC_LINEDIS() uint32 {
	return (volatile.LoadUint32(&o.RACC.Reg) & 0x40) >> 6
}
func (o *ENET_Type) SetRACC_SHIFT16(value uint32) {
	volatile.StoreUint32(&o.RACC.Reg, volatile.LoadUint32(&o.RACC.Reg)&^(0x80)|value<<7)
}
func (o *ENET_Type) GetRACC_SHIFT16() uint32 {
	return (volatile.LoadUint32(&o.RACC.Reg) & 0x80) >> 7
}

// ENET.RMON_T_PACKETS: Tx Packet Count Statistic Register
func (o *ENET_Type) SetRMON_T_PACKETS_TXPKTS(value uint32) {
	volatile.StoreUint32(&o.RMON_T_PACKETS.Reg, volatile.LoadUint32(&o.RMON_T_PACKETS.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetRMON_T_PACKETS_TXPKTS() uint32 {
	return volatile.LoadUint32(&o.RMON_T_PACKETS.Reg) & 0xffff
}

// ENET.RMON_T_BC_PKT: Tx Broadcast Packets Statistic Register
func (o *ENET_Type) SetRMON_T_BC_PKT_TXPKTS(value uint32) {
	volatile.StoreUint32(&o.RMON_T_BC_PKT.Reg, volatile.LoadUint32(&o.RMON_T_BC_PKT.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetRMON_T_BC_PKT_TXPKTS() uint32 {
	return volatile.LoadUint32(&o.RMON_T_BC_PKT.Reg) & 0xffff
}

// ENET.RMON_T_MC_PKT: Tx Multicast Packets Statistic Register
func (o *ENET_Type) SetRMON_T_MC_PKT_TXPKTS(value uint32) {
	volatile.StoreUint32(&o.RMON_T_MC_PKT.Reg, volatile.LoadUint32(&o.RMON_T_MC_PKT.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetRMON_T_MC_PKT_TXPKTS() uint32 {
	return volatile.LoadUint32(&o.RMON_T_MC_PKT.Reg) & 0xffff
}

// ENET.RMON_T_CRC_ALIGN: Tx Packets with CRC/Align Error Statistic Register
func (o *ENET_Type) SetRMON_T_CRC_ALIGN_TXPKTS(value uint32) {
	volatile.StoreUint32(&o.RMON_T_CRC_ALIGN.Reg, volatile.LoadUint32(&o.RMON_T_CRC_ALIGN.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetRMON_T_CRC_ALIGN_TXPKTS() uint32 {
	return volatile.LoadUint32(&o.RMON_T_CRC_ALIGN.Reg) & 0xffff
}

// ENET.RMON_T_UNDERSIZE: Tx Packets Less Than Bytes and Good CRC Statistic Register
func (o *ENET_Type) SetRMON_T_UNDERSIZE_TXPKTS(value uint32) {
	volatile.StoreUint32(&o.RMON_T_UNDERSIZE.Reg, volatile.LoadUint32(&o.RMON_T_UNDERSIZE.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetRMON_T_UNDERSIZE_TXPKTS() uint32 {
	return volatile.LoadUint32(&o.RMON_T_UNDERSIZE.Reg) & 0xffff
}

// ENET.RMON_T_OVERSIZE: Tx Packets GT MAX_FL bytes and Good CRC Statistic Register
func (o *ENET_Type) SetRMON_T_OVERSIZE_TXPKTS(value uint32) {
	volatile.StoreUint32(&o.RMON_T_OVERSIZE.Reg, volatile.LoadUint32(&o.RMON_T_OVERSIZE.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetRMON_T_OVERSIZE_TXPKTS() uint32 {
	return volatile.LoadUint32(&o.RMON_T_OVERSIZE.Reg) & 0xffff
}

// ENET.RMON_T_FRAG: Tx Packets Less Than 64 Bytes and Bad CRC Statistic Register
func (o *ENET_Type) SetRMON_T_FRAG_TXPKTS(value uint32) {
	volatile.StoreUint32(&o.RMON_T_FRAG.Reg, volatile.LoadUint32(&o.RMON_T_FRAG.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetRMON_T_FRAG_TXPKTS() uint32 {
	return volatile.LoadUint32(&o.RMON_T_FRAG.Reg) & 0xffff
}

// ENET.RMON_T_JAB: Tx Packets Greater Than MAX_FL bytes and Bad CRC Statistic Register
func (o *ENET_Type) SetRMON_T_JAB_TXPKTS(value uint32) {
	volatile.StoreUint32(&o.RMON_T_JAB.Reg, volatile.LoadUint32(&o.RMON_T_JAB.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetRMON_T_JAB_TXPKTS() uint32 {
	return volatile.LoadUint32(&o.RMON_T_JAB.Reg) & 0xffff
}

// ENET.RMON_T_COL: Tx Collision Count Statistic Register
func (o *ENET_Type) SetRMON_T_COL_TXPKTS(value uint32) {
	volatile.StoreUint32(&o.RMON_T_COL.Reg, volatile.LoadUint32(&o.RMON_T_COL.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetRMON_T_COL_TXPKTS() uint32 {
	return volatile.LoadUint32(&o.RMON_T_COL.Reg) & 0xffff
}

// ENET.RMON_T_P64: Tx 64-Byte Packets Statistic Register
func (o *ENET_Type) SetRMON_T_P64_TXPKTS(value uint32) {
	volatile.StoreUint32(&o.RMON_T_P64.Reg, volatile.LoadUint32(&o.RMON_T_P64.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetRMON_T_P64_TXPKTS() uint32 {
	return volatile.LoadUint32(&o.RMON_T_P64.Reg) & 0xffff
}

// ENET.RMON_T_P65TO127: Tx 65- to 127-byte Packets Statistic Register
func (o *ENET_Type) SetRMON_T_P65TO127_TXPKTS(value uint32) {
	volatile.StoreUint32(&o.RMON_T_P65TO127.Reg, volatile.LoadUint32(&o.RMON_T_P65TO127.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetRMON_T_P65TO127_TXPKTS() uint32 {
	return volatile.LoadUint32(&o.RMON_T_P65TO127.Reg) & 0xffff
}

// ENET.RMON_T_P128TO255: Tx 128- to 255-byte Packets Statistic Register
func (o *ENET_Type) SetRMON_T_P128TO255_TXPKTS(value uint32) {
	volatile.StoreUint32(&o.RMON_T_P128TO255.Reg, volatile.LoadUint32(&o.RMON_T_P128TO255.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetRMON_T_P128TO255_TXPKTS() uint32 {
	return volatile.LoadUint32(&o.RMON_T_P128TO255.Reg) & 0xffff
}

// ENET.RMON_T_P256TO511: Tx 256- to 511-byte Packets Statistic Register
func (o *ENET_Type) SetRMON_T_P256TO511_TXPKTS(value uint32) {
	volatile.StoreUint32(&o.RMON_T_P256TO511.Reg, volatile.LoadUint32(&o.RMON_T_P256TO511.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetRMON_T_P256TO511_TXPKTS() uint32 {
	return volatile.LoadUint32(&o.RMON_T_P256TO511.Reg) & 0xffff
}

// ENET.RMON_T_P512TO1023: Tx 512- to 1023-byte Packets Statistic Register
func (o *ENET_Type) SetRMON_T_P512TO1023_TXPKTS(value uint32) {
	volatile.StoreUint32(&o.RMON_T_P512TO1023.Reg, volatile.LoadUint32(&o.RMON_T_P512TO1023.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetRMON_T_P512TO1023_TXPKTS() uint32 {
	return volatile.LoadUint32(&o.RMON_T_P512TO1023.Reg) & 0xffff
}

// ENET.RMON_T_P1024TO2047: Tx 1024- to 2047-byte Packets Statistic Register
func (o *ENET_Type) SetRMON_T_P1024TO2047_TXPKTS(value uint32) {
	volatile.StoreUint32(&o.RMON_T_P1024TO2047.Reg, volatile.LoadUint32(&o.RMON_T_P1024TO2047.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetRMON_T_P1024TO2047_TXPKTS() uint32 {
	return volatile.LoadUint32(&o.RMON_T_P1024TO2047.Reg) & 0xffff
}

// ENET.RMON_T_P_GTE2048: Tx Packets Greater Than 2048 Bytes Statistic Register
func (o *ENET_Type) SetRMON_T_P_GTE2048_TXPKTS(value uint32) {
	volatile.StoreUint32(&o.RMON_T_P_GTE2048.Reg, volatile.LoadUint32(&o.RMON_T_P_GTE2048.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetRMON_T_P_GTE2048_TXPKTS() uint32 {
	return volatile.LoadUint32(&o.RMON_T_P_GTE2048.Reg) & 0xffff
}

// ENET.RMON_T_OCTETS: Tx Octets Statistic Register
func (o *ENET_Type) SetRMON_T_OCTETS(value uint32) {
	volatile.StoreUint32(&o.RMON_T_OCTETS.Reg, value)
}
func (o *ENET_Type) GetRMON_T_OCTETS() uint32 {
	return volatile.LoadUint32(&o.RMON_T_OCTETS.Reg)
}

// ENET.IEEE_T_FRAME_OK: Frames Transmitted OK Statistic Register
func (o *ENET_Type) SetIEEE_T_FRAME_OK_COUNT(value uint32) {
	volatile.StoreUint32(&o.IEEE_T_FRAME_OK.Reg, volatile.LoadUint32(&o.IEEE_T_FRAME_OK.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetIEEE_T_FRAME_OK_COUNT() uint32 {
	return volatile.LoadUint32(&o.IEEE_T_FRAME_OK.Reg) & 0xffff
}

// ENET.IEEE_T_1COL: Frames Transmitted with Single Collision Statistic Register
func (o *ENET_Type) SetIEEE_T_1COL_COUNT(value uint32) {
	volatile.StoreUint32(&o.IEEE_T_1COL.Reg, volatile.LoadUint32(&o.IEEE_T_1COL.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetIEEE_T_1COL_COUNT() uint32 {
	return volatile.LoadUint32(&o.IEEE_T_1COL.Reg) & 0xffff
}

// ENET.IEEE_T_MCOL: Frames Transmitted with Multiple Collisions Statistic Register
func (o *ENET_Type) SetIEEE_T_MCOL_COUNT(value uint32) {
	volatile.StoreUint32(&o.IEEE_T_MCOL.Reg, volatile.LoadUint32(&o.IEEE_T_MCOL.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetIEEE_T_MCOL_COUNT() uint32 {
	return volatile.LoadUint32(&o.IEEE_T_MCOL.Reg) & 0xffff
}

// ENET.IEEE_T_DEF: Frames Transmitted after Deferral Delay Statistic Register
func (o *ENET_Type) SetIEEE_T_DEF_COUNT(value uint32) {
	volatile.StoreUint32(&o.IEEE_T_DEF.Reg, volatile.LoadUint32(&o.IEEE_T_DEF.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetIEEE_T_DEF_COUNT() uint32 {
	return volatile.LoadUint32(&o.IEEE_T_DEF.Reg) & 0xffff
}

// ENET.IEEE_T_LCOL: Frames Transmitted with Late Collision Statistic Register
func (o *ENET_Type) SetIEEE_T_LCOL_COUNT(value uint32) {
	volatile.StoreUint32(&o.IEEE_T_LCOL.Reg, volatile.LoadUint32(&o.IEEE_T_LCOL.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetIEEE_T_LCOL_COUNT() uint32 {
	return volatile.LoadUint32(&o.IEEE_T_LCOL.Reg) & 0xffff
}

// ENET.IEEE_T_EXCOL: Frames Transmitted with Excessive Collisions Statistic Register
func (o *ENET_Type) SetIEEE_T_EXCOL_COUNT(value uint32) {
	volatile.StoreUint32(&o.IEEE_T_EXCOL.Reg, volatile.LoadUint32(&o.IEEE_T_EXCOL.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetIEEE_T_EXCOL_COUNT() uint32 {
	return volatile.LoadUint32(&o.IEEE_T_EXCOL.Reg) & 0xffff
}

// ENET.IEEE_T_MACERR: Frames Transmitted with Tx FIFO Underrun Statistic Register
func (o *ENET_Type) SetIEEE_T_MACERR_COUNT(value uint32) {
	volatile.StoreUint32(&o.IEEE_T_MACERR.Reg, volatile.LoadUint32(&o.IEEE_T_MACERR.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetIEEE_T_MACERR_COUNT() uint32 {
	return volatile.LoadUint32(&o.IEEE_T_MACERR.Reg) & 0xffff
}

// ENET.IEEE_T_CSERR: Frames Transmitted with Carrier Sense Error Statistic Register
func (o *ENET_Type) SetIEEE_T_CSERR_COUNT(value uint32) {
	volatile.StoreUint32(&o.IEEE_T_CSERR.Reg, volatile.LoadUint32(&o.IEEE_T_CSERR.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetIEEE_T_CSERR_COUNT() uint32 {
	return volatile.LoadUint32(&o.IEEE_T_CSERR.Reg) & 0xffff
}

// ENET.IEEE_T_FDXFC: Flow Control Pause Frames Transmitted Statistic Register
func (o *ENET_Type) SetIEEE_T_FDXFC_COUNT(value uint32) {
	volatile.StoreUint32(&o.IEEE_T_FDXFC.Reg, volatile.LoadUint32(&o.IEEE_T_FDXFC.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetIEEE_T_FDXFC_COUNT() uint32 {
	return volatile.LoadUint32(&o.IEEE_T_FDXFC.Reg) & 0xffff
}

// ENET.IEEE_T_OCTETS_OK: Octet Count for Frames Transmitted w/o Error Statistic Register
func (o *ENET_Type) SetIEEE_T_OCTETS_OK(value uint32) {
	volatile.StoreUint32(&o.IEEE_T_OCTETS_OK.Reg, value)
}
func (o *ENET_Type) GetIEEE_T_OCTETS_OK() uint32 {
	return volatile.LoadUint32(&o.IEEE_T_OCTETS_OK.Reg)
}

// ENET.RMON_R_PACKETS: Rx Packet Count Statistic Register
func (o *ENET_Type) SetRMON_R_PACKETS_COUNT(value uint32) {
	volatile.StoreUint32(&o.RMON_R_PACKETS.Reg, volatile.LoadUint32(&o.RMON_R_PACKETS.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetRMON_R_PACKETS_COUNT() uint32 {
	return volatile.LoadUint32(&o.RMON_R_PACKETS.Reg) & 0xffff
}

// ENET.RMON_R_BC_PKT: Rx Broadcast Packets Statistic Register
func (o *ENET_Type) SetRMON_R_BC_PKT_COUNT(value uint32) {
	volatile.StoreUint32(&o.RMON_R_BC_PKT.Reg, volatile.LoadUint32(&o.RMON_R_BC_PKT.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetRMON_R_BC_PKT_COUNT() uint32 {
	return volatile.LoadUint32(&o.RMON_R_BC_PKT.Reg) & 0xffff
}

// ENET.RMON_R_MC_PKT: Rx Multicast Packets Statistic Register
func (o *ENET_Type) SetRMON_R_MC_PKT_COUNT(value uint32) {
	volatile.StoreUint32(&o.RMON_R_MC_PKT.Reg, volatile.LoadUint32(&o.RMON_R_MC_PKT.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetRMON_R_MC_PKT_COUNT() uint32 {
	return volatile.LoadUint32(&o.RMON_R_MC_PKT.Reg) & 0xffff
}

// ENET.RMON_R_CRC_ALIGN: Rx Packets with CRC/Align Error Statistic Register
func (o *ENET_Type) SetRMON_R_CRC_ALIGN_COUNT(value uint32) {
	volatile.StoreUint32(&o.RMON_R_CRC_ALIGN.Reg, volatile.LoadUint32(&o.RMON_R_CRC_ALIGN.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetRMON_R_CRC_ALIGN_COUNT() uint32 {
	return volatile.LoadUint32(&o.RMON_R_CRC_ALIGN.Reg) & 0xffff
}

// ENET.RMON_R_UNDERSIZE: Rx Packets with Less Than 64 Bytes and Good CRC Statistic Register
func (o *ENET_Type) SetRMON_R_UNDERSIZE_COUNT(value uint32) {
	volatile.StoreUint32(&o.RMON_R_UNDERSIZE.Reg, volatile.LoadUint32(&o.RMON_R_UNDERSIZE.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetRMON_R_UNDERSIZE_COUNT() uint32 {
	return volatile.LoadUint32(&o.RMON_R_UNDERSIZE.Reg) & 0xffff
}

// ENET.RMON_R_OVERSIZE: Rx Packets Greater Than MAX_FL and Good CRC Statistic Register
func (o *ENET_Type) SetRMON_R_OVERSIZE_COUNT(value uint32) {
	volatile.StoreUint32(&o.RMON_R_OVERSIZE.Reg, volatile.LoadUint32(&o.RMON_R_OVERSIZE.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetRMON_R_OVERSIZE_COUNT() uint32 {
	return volatile.LoadUint32(&o.RMON_R_OVERSIZE.Reg) & 0xffff
}

// ENET.RMON_R_FRAG: Rx Packets Less Than 64 Bytes and Bad CRC Statistic Register
func (o *ENET_Type) SetRMON_R_FRAG_COUNT(value uint32) {
	volatile.StoreUint32(&o.RMON_R_FRAG.Reg, volatile.LoadUint32(&o.RMON_R_FRAG.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetRMON_R_FRAG_COUNT() uint32 {
	return volatile.LoadUint32(&o.RMON_R_FRAG.Reg) & 0xffff
}

// ENET.RMON_R_JAB: Rx Packets Greater Than MAX_FL Bytes and Bad CRC Statistic Register
func (o *ENET_Type) SetRMON_R_JAB_COUNT(value uint32) {
	volatile.StoreUint32(&o.RMON_R_JAB.Reg, volatile.LoadUint32(&o.RMON_R_JAB.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetRMON_R_JAB_COUNT() uint32 {
	return volatile.LoadUint32(&o.RMON_R_JAB.Reg) & 0xffff
}

// ENET.RMON_R_P64: Rx 64-Byte Packets Statistic Register
func (o *ENET_Type) SetRMON_R_P64_COUNT(value uint32) {
	volatile.StoreUint32(&o.RMON_R_P64.Reg, volatile.LoadUint32(&o.RMON_R_P64.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetRMON_R_P64_COUNT() uint32 {
	return volatile.LoadUint32(&o.RMON_R_P64.Reg) & 0xffff
}

// ENET.RMON_R_P65TO127: Rx 65- to 127-Byte Packets Statistic Register
func (o *ENET_Type) SetRMON_R_P65TO127_COUNT(value uint32) {
	volatile.StoreUint32(&o.RMON_R_P65TO127.Reg, volatile.LoadUint32(&o.RMON_R_P65TO127.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetRMON_R_P65TO127_COUNT() uint32 {
	return volatile.LoadUint32(&o.RMON_R_P65TO127.Reg) & 0xffff
}

// ENET.RMON_R_P128TO255: Rx 128- to 255-Byte Packets Statistic Register
func (o *ENET_Type) SetRMON_R_P128TO255_COUNT(value uint32) {
	volatile.StoreUint32(&o.RMON_R_P128TO255.Reg, volatile.LoadUint32(&o.RMON_R_P128TO255.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetRMON_R_P128TO255_COUNT() uint32 {
	return volatile.LoadUint32(&o.RMON_R_P128TO255.Reg) & 0xffff
}

// ENET.RMON_R_P256TO511: Rx 256- to 511-Byte Packets Statistic Register
func (o *ENET_Type) SetRMON_R_P256TO511_COUNT(value uint32) {
	volatile.StoreUint32(&o.RMON_R_P256TO511.Reg, volatile.LoadUint32(&o.RMON_R_P256TO511.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetRMON_R_P256TO511_COUNT() uint32 {
	return volatile.LoadUint32(&o.RMON_R_P256TO511.Reg) & 0xffff
}

// ENET.RMON_R_P512TO1023: Rx 512- to 1023-Byte Packets Statistic Register
func (o *ENET_Type) SetRMON_R_P512TO1023_COUNT(value uint32) {
	volatile.StoreUint32(&o.RMON_R_P512TO1023.Reg, volatile.LoadUint32(&o.RMON_R_P512TO1023.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetRMON_R_P512TO1023_COUNT() uint32 {
	return volatile.LoadUint32(&o.RMON_R_P512TO1023.Reg) & 0xffff
}

// ENET.RMON_R_P1024TO2047: Rx 1024- to 2047-Byte Packets Statistic Register
func (o *ENET_Type) SetRMON_R_P1024TO2047_COUNT(value uint32) {
	volatile.StoreUint32(&o.RMON_R_P1024TO2047.Reg, volatile.LoadUint32(&o.RMON_R_P1024TO2047.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetRMON_R_P1024TO2047_COUNT() uint32 {
	return volatile.LoadUint32(&o.RMON_R_P1024TO2047.Reg) & 0xffff
}

// ENET.RMON_R_P_GTE2048: Rx Packets Greater than 2048 Bytes Statistic Register
func (o *ENET_Type) SetRMON_R_P_GTE2048_COUNT(value uint32) {
	volatile.StoreUint32(&o.RMON_R_P_GTE2048.Reg, volatile.LoadUint32(&o.RMON_R_P_GTE2048.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetRMON_R_P_GTE2048_COUNT() uint32 {
	return volatile.LoadUint32(&o.RMON_R_P_GTE2048.Reg) & 0xffff
}

// ENET.RMON_R_OCTETS: Rx Octets Statistic Register
func (o *ENET_Type) SetRMON_R_OCTETS(value uint32) {
	volatile.StoreUint32(&o.RMON_R_OCTETS.Reg, value)
}
func (o *ENET_Type) GetRMON_R_OCTETS() uint32 {
	return volatile.LoadUint32(&o.RMON_R_OCTETS.Reg)
}

// ENET.IEEE_R_DROP: Frames not Counted Correctly Statistic Register
func (o *ENET_Type) SetIEEE_R_DROP_COUNT(value uint32) {
	volatile.StoreUint32(&o.IEEE_R_DROP.Reg, volatile.LoadUint32(&o.IEEE_R_DROP.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetIEEE_R_DROP_COUNT() uint32 {
	return volatile.LoadUint32(&o.IEEE_R_DROP.Reg) & 0xffff
}

// ENET.IEEE_R_FRAME_OK: Frames Received OK Statistic Register
func (o *ENET_Type) SetIEEE_R_FRAME_OK_COUNT(value uint32) {
	volatile.StoreUint32(&o.IEEE_R_FRAME_OK.Reg, volatile.LoadUint32(&o.IEEE_R_FRAME_OK.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetIEEE_R_FRAME_OK_COUNT() uint32 {
	return volatile.LoadUint32(&o.IEEE_R_FRAME_OK.Reg) & 0xffff
}

// ENET.IEEE_R_CRC: Frames Received with CRC Error Statistic Register
func (o *ENET_Type) SetIEEE_R_CRC_COUNT(value uint32) {
	volatile.StoreUint32(&o.IEEE_R_CRC.Reg, volatile.LoadUint32(&o.IEEE_R_CRC.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetIEEE_R_CRC_COUNT() uint32 {
	return volatile.LoadUint32(&o.IEEE_R_CRC.Reg) & 0xffff
}

// ENET.IEEE_R_ALIGN: Frames Received with Alignment Error Statistic Register
func (o *ENET_Type) SetIEEE_R_ALIGN_COUNT(value uint32) {
	volatile.StoreUint32(&o.IEEE_R_ALIGN.Reg, volatile.LoadUint32(&o.IEEE_R_ALIGN.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetIEEE_R_ALIGN_COUNT() uint32 {
	return volatile.LoadUint32(&o.IEEE_R_ALIGN.Reg) & 0xffff
}

// ENET.IEEE_R_MACERR: Receive FIFO Overflow Count Statistic Register
func (o *ENET_Type) SetIEEE_R_MACERR_COUNT(value uint32) {
	volatile.StoreUint32(&o.IEEE_R_MACERR.Reg, volatile.LoadUint32(&o.IEEE_R_MACERR.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetIEEE_R_MACERR_COUNT() uint32 {
	return volatile.LoadUint32(&o.IEEE_R_MACERR.Reg) & 0xffff
}

// ENET.IEEE_R_FDXFC: Flow Control Pause Frames Received Statistic Register
func (o *ENET_Type) SetIEEE_R_FDXFC_COUNT(value uint32) {
	volatile.StoreUint32(&o.IEEE_R_FDXFC.Reg, volatile.LoadUint32(&o.IEEE_R_FDXFC.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetIEEE_R_FDXFC_COUNT() uint32 {
	return volatile.LoadUint32(&o.IEEE_R_FDXFC.Reg) & 0xffff
}

// ENET.IEEE_R_OCTETS_OK: Octet Count for Frames Received without Error Statistic Register
func (o *ENET_Type) SetIEEE_R_OCTETS_OK(value uint32) {
	volatile.StoreUint32(&o.IEEE_R_OCTETS_OK.Reg, value)
}
func (o *ENET_Type) GetIEEE_R_OCTETS_OK() uint32 {
	return volatile.LoadUint32(&o.IEEE_R_OCTETS_OK.Reg)
}

// ENET.ATCR: Adjustable Timer Control Register
func (o *ENET_Type) SetATCR_EN(value uint32) {
	volatile.StoreUint32(&o.ATCR.Reg, volatile.LoadUint32(&o.ATCR.Reg)&^(0x1)|value)
}
func (o *ENET_Type) GetATCR_EN() uint32 {
	return volatile.LoadUint32(&o.ATCR.Reg) & 0x1
}
func (o *ENET_Type) SetATCR_OFFEN(value uint32) {
	volatile.StoreUint32(&o.ATCR.Reg, volatile.LoadUint32(&o.ATCR.Reg)&^(0x4)|value<<2)
}
func (o *ENET_Type) GetATCR_OFFEN() uint32 {
	return (volatile.LoadUint32(&o.ATCR.Reg) & 0x4) >> 2
}
func (o *ENET_Type) SetATCR_OFFRST(value uint32) {
	volatile.StoreUint32(&o.ATCR.Reg, volatile.LoadUint32(&o.ATCR.Reg)&^(0x8)|value<<3)
}
func (o *ENET_Type) GetATCR_OFFRST() uint32 {
	return (volatile.LoadUint32(&o.ATCR.Reg) & 0x8) >> 3
}
func (o *ENET_Type) SetATCR_PEREN(value uint32) {
	volatile.StoreUint32(&o.ATCR.Reg, volatile.LoadUint32(&o.ATCR.Reg)&^(0x10)|value<<4)
}
func (o *ENET_Type) GetATCR_PEREN() uint32 {
	return (volatile.LoadUint32(&o.ATCR.Reg) & 0x10) >> 4
}
func (o *ENET_Type) SetATCR_PINPER(value uint32) {
	volatile.StoreUint32(&o.ATCR.Reg, volatile.LoadUint32(&o.ATCR.Reg)&^(0x80)|value<<7)
}
func (o *ENET_Type) GetATCR_PINPER() uint32 {
	return (volatile.LoadUint32(&o.ATCR.Reg) & 0x80) >> 7
}
func (o *ENET_Type) SetATCR_RESTART(value uint32) {
	volatile.StoreUint32(&o.ATCR.Reg, volatile.LoadUint32(&o.ATCR.Reg)&^(0x200)|value<<9)
}
func (o *ENET_Type) GetATCR_RESTART() uint32 {
	return (volatile.LoadUint32(&o.ATCR.Reg) & 0x200) >> 9
}
func (o *ENET_Type) SetATCR_CAPTURE(value uint32) {
	volatile.StoreUint32(&o.ATCR.Reg, volatile.LoadUint32(&o.ATCR.Reg)&^(0x800)|value<<11)
}
func (o *ENET_Type) GetATCR_CAPTURE() uint32 {
	return (volatile.LoadUint32(&o.ATCR.Reg) & 0x800) >> 11
}
func (o *ENET_Type) SetATCR_SLAVE(value uint32) {
	volatile.StoreUint32(&o.ATCR.Reg, volatile.LoadUint32(&o.ATCR.Reg)&^(0x2000)|value<<13)
}
func (o *ENET_Type) GetATCR_SLAVE() uint32 {
	return (volatile.LoadUint32(&o.ATCR.Reg) & 0x2000) >> 13
}

// ENET.ATVR: Timer Value Register
func (o *ENET_Type) SetATVR(value uint32) {
	volatile.StoreUint32(&o.ATVR.Reg, value)
}
func (o *ENET_Type) GetATVR() uint32 {
	return volatile.LoadUint32(&o.ATVR.Reg)
}

// ENET.ATOFF: Timer Offset Register
func (o *ENET_Type) SetATOFF(value uint32) {
	volatile.StoreUint32(&o.ATOFF.Reg, value)
}
func (o *ENET_Type) GetATOFF() uint32 {
	return volatile.LoadUint32(&o.ATOFF.Reg)
}

// ENET.ATPER: Timer Period Register
func (o *ENET_Type) SetATPER(value uint32) {
	volatile.StoreUint32(&o.ATPER.Reg, value)
}
func (o *ENET_Type) GetATPER() uint32 {
	return volatile.LoadUint32(&o.ATPER.Reg)
}

// ENET.ATCOR: Timer Correction Register
func (o *ENET_Type) SetATCOR_COR(value uint32) {
	volatile.StoreUint32(&o.ATCOR.Reg, volatile.LoadUint32(&o.ATCOR.Reg)&^(0x7fffffff)|value)
}
func (o *ENET_Type) GetATCOR_COR() uint32 {
	return volatile.LoadUint32(&o.ATCOR.Reg) & 0x7fffffff
}

// ENET.ATINC: Time-Stamping Clock Period Register
func (o *ENET_Type) SetATINC_INC(value uint32) {
	volatile.StoreUint32(&o.ATINC.Reg, volatile.LoadUint32(&o.ATINC.Reg)&^(0x7f)|value)
}
func (o *ENET_Type) GetATINC_INC() uint32 {
	return volatile.LoadUint32(&o.ATINC.Reg) & 0x7f
}
func (o *ENET_Type) SetATINC_INC_CORR(value uint32) {
	volatile.StoreUint32(&o.ATINC.Reg, volatile.LoadUint32(&o.ATINC.Reg)&^(0x7f00)|value<<8)
}
func (o *ENET_Type) GetATINC_INC_CORR() uint32 {
	return (volatile.LoadUint32(&o.ATINC.Reg) & 0x7f00) >> 8
}

// ENET.ATSTMP: Timestamp of Last Transmitted Frame
func (o *ENET_Type) SetATSTMP(value uint32) {
	volatile.StoreUint32(&o.ATSTMP.Reg, value)
}
func (o *ENET_Type) GetATSTMP() uint32 {
	return volatile.LoadUint32(&o.ATSTMP.Reg)
}

// ENET.TGSR: Timer Global Status Register
func (o *ENET_Type) SetTGSR_TF0(value uint32) {
	volatile.StoreUint32(&o.TGSR.Reg, volatile.LoadUint32(&o.TGSR.Reg)&^(0x1)|value)
}
func (o *ENET_Type) GetTGSR_TF0() uint32 {
	return volatile.LoadUint32(&o.TGSR.Reg) & 0x1
}
func (o *ENET_Type) SetTGSR_TF1(value uint32) {
	volatile.StoreUint32(&o.TGSR.Reg, volatile.LoadUint32(&o.TGSR.Reg)&^(0x2)|value<<1)
}
func (o *ENET_Type) GetTGSR_TF1() uint32 {
	return (volatile.LoadUint32(&o.TGSR.Reg) & 0x2) >> 1
}
func (o *ENET_Type) SetTGSR_TF2(value uint32) {
	volatile.StoreUint32(&o.TGSR.Reg, volatile.LoadUint32(&o.TGSR.Reg)&^(0x4)|value<<2)
}
func (o *ENET_Type) GetTGSR_TF2() uint32 {
	return (volatile.LoadUint32(&o.TGSR.Reg) & 0x4) >> 2
}
func (o *ENET_Type) SetTGSR_TF3(value uint32) {
	volatile.StoreUint32(&o.TGSR.Reg, volatile.LoadUint32(&o.TGSR.Reg)&^(0x8)|value<<3)
}
func (o *ENET_Type) GetTGSR_TF3() uint32 {
	return (volatile.LoadUint32(&o.TGSR.Reg) & 0x8) >> 3
}

// ENET.TCSR0: Timer Control Status Register
func (o *ENET_Type) SetTCSR0_TDRE(value uint32) {
	volatile.StoreUint32(&o.TCSR0.Reg, volatile.LoadUint32(&o.TCSR0.Reg)&^(0x1)|value)
}
func (o *ENET_Type) GetTCSR0_TDRE() uint32 {
	return volatile.LoadUint32(&o.TCSR0.Reg) & 0x1
}
func (o *ENET_Type) SetTCSR0_TMODE(value uint32) {
	volatile.StoreUint32(&o.TCSR0.Reg, volatile.LoadUint32(&o.TCSR0.Reg)&^(0x3c)|value<<2)
}
func (o *ENET_Type) GetTCSR0_TMODE() uint32 {
	return (volatile.LoadUint32(&o.TCSR0.Reg) & 0x3c) >> 2
}
func (o *ENET_Type) SetTCSR0_TIE(value uint32) {
	volatile.StoreUint32(&o.TCSR0.Reg, volatile.LoadUint32(&o.TCSR0.Reg)&^(0x40)|value<<6)
}
func (o *ENET_Type) GetTCSR0_TIE() uint32 {
	return (volatile.LoadUint32(&o.TCSR0.Reg) & 0x40) >> 6
}
func (o *ENET_Type) SetTCSR0_TF(value uint32) {
	volatile.StoreUint32(&o.TCSR0.Reg, volatile.LoadUint32(&o.TCSR0.Reg)&^(0x80)|value<<7)
}
func (o *ENET_Type) GetTCSR0_TF() uint32 {
	return (volatile.LoadUint32(&o.TCSR0.Reg) & 0x80) >> 7
}

// ENET.TCCR0: Timer Compare Capture Register
func (o *ENET_Type) SetTCCR0(value uint32) {
	volatile.StoreUint32(&o.TCCR0.Reg, value)
}
func (o *ENET_Type) GetTCCR0() uint32 {
	return volatile.LoadUint32(&o.TCCR0.Reg)
}

// ENET.TCSR1: Timer Control Status Register
func (o *ENET_Type) SetTCSR1_TDRE(value uint32) {
	volatile.StoreUint32(&o.TCSR1.Reg, volatile.LoadUint32(&o.TCSR1.Reg)&^(0x1)|value)
}
func (o *ENET_Type) GetTCSR1_TDRE() uint32 {
	return volatile.LoadUint32(&o.TCSR1.Reg) & 0x1
}
func (o *ENET_Type) SetTCSR1_TMODE(value uint32) {
	volatile.StoreUint32(&o.TCSR1.Reg, volatile.LoadUint32(&o.TCSR1.Reg)&^(0x3c)|value<<2)
}
func (o *ENET_Type) GetTCSR1_TMODE() uint32 {
	return (volatile.LoadUint32(&o.TCSR1.Reg) & 0x3c) >> 2
}
func (o *ENET_Type) SetTCSR1_TIE(value uint32) {
	volatile.StoreUint32(&o.TCSR1.Reg, volatile.LoadUint32(&o.TCSR1.Reg)&^(0x40)|value<<6)
}
func (o *ENET_Type) GetTCSR1_TIE() uint32 {
	return (volatile.LoadUint32(&o.TCSR1.Reg) & 0x40) >> 6
}
func (o *ENET_Type) SetTCSR1_TF(value uint32) {
	volatile.StoreUint32(&o.TCSR1.Reg, volatile.LoadUint32(&o.TCSR1.Reg)&^(0x80)|value<<7)
}
func (o *ENET_Type) GetTCSR1_TF() uint32 {
	return (volatile.LoadUint32(&o.TCSR1.Reg) & 0x80) >> 7
}

// ENET.TCCR1: Timer Compare Capture Register
func (o *ENET_Type) SetTCCR1(value uint32) {
	volatile.StoreUint32(&o.TCCR1.Reg, value)
}
func (o *ENET_Type) GetTCCR1() uint32 {
	return volatile.LoadUint32(&o.TCCR1.Reg)
}

// ENET.TCSR2: Timer Control Status Register
func (o *ENET_Type) SetTCSR2_TDRE(value uint32) {
	volatile.StoreUint32(&o.TCSR2.Reg, volatile.LoadUint32(&o.TCSR2.Reg)&^(0x1)|value)
}
func (o *ENET_Type) GetTCSR2_TDRE() uint32 {
	return volatile.LoadUint32(&o.TCSR2.Reg) & 0x1
}
func (o *ENET_Type) SetTCSR2_TMODE(value uint32) {
	volatile.StoreUint32(&o.TCSR2.Reg, volatile.LoadUint32(&o.TCSR2.Reg)&^(0x3c)|value<<2)
}
func (o *ENET_Type) GetTCSR2_TMODE() uint32 {
	return (volatile.LoadUint32(&o.TCSR2.Reg) & 0x3c) >> 2
}
func (o *ENET_Type) SetTCSR2_TIE(value uint32) {
	volatile.StoreUint32(&o.TCSR2.Reg, volatile.LoadUint32(&o.TCSR2.Reg)&^(0x40)|value<<6)
}
func (o *ENET_Type) GetTCSR2_TIE() uint32 {
	return (volatile.LoadUint32(&o.TCSR2.Reg) & 0x40) >> 6
}
func (o *ENET_Type) SetTCSR2_TF(value uint32) {
	volatile.StoreUint32(&o.TCSR2.Reg, volatile.LoadUint32(&o.TCSR2.Reg)&^(0x80)|value<<7)
}
func (o *ENET_Type) GetTCSR2_TF() uint32 {
	return (volatile.LoadUint32(&o.TCSR2.Reg) & 0x80) >> 7
}

// ENET.TCCR2: Timer Compare Capture Register
func (o *ENET_Type) SetTCCR2(value uint32) {
	volatile.StoreUint32(&o.TCCR2.Reg, value)
}
func (o *ENET_Type) GetTCCR2() uint32 {
	return volatile.LoadUint32(&o.TCCR2.Reg)
}

// ENET.TCSR3: Timer Control Status Register
func (o *ENET_Type) SetTCSR3_TDRE(value uint32) {
	volatile.StoreUint32(&o.TCSR3.Reg, volatile.LoadUint32(&o.TCSR3.Reg)&^(0x1)|value)
}
func (o *ENET_Type) GetTCSR3_TDRE() uint32 {
	return volatile.LoadUint32(&o.TCSR3.Reg) & 0x1
}
func (o *ENET_Type) SetTCSR3_TMODE(value uint32) {
	volatile.StoreUint32(&o.TCSR3.Reg, volatile.LoadUint32(&o.TCSR3.Reg)&^(0x3c)|value<<2)
}
func (o *ENET_Type) GetTCSR3_TMODE() uint32 {
	return (volatile.LoadUint32(&o.TCSR3.Reg) & 0x3c) >> 2
}
func (o *ENET_Type) SetTCSR3_TIE(value uint32) {
	volatile.StoreUint32(&o.TCSR3.Reg, volatile.LoadUint32(&o.TCSR3.Reg)&^(0x40)|value<<6)
}
func (o *ENET_Type) GetTCSR3_TIE() uint32 {
	return (volatile.LoadUint32(&o.TCSR3.Reg) & 0x40) >> 6
}
func (o *ENET_Type) SetTCSR3_TF(value uint32) {
	volatile.StoreUint32(&o.TCSR3.Reg, volatile.LoadUint32(&o.TCSR3.Reg)&^(0x80)|value<<7)
}
func (o *ENET_Type) GetTCSR3_TF() uint32 {
	return (volatile.LoadUint32(&o.TCSR3.Reg) & 0x80) >> 7
}

// ENET.TCCR3: Timer Compare Capture Register
func (o *ENET_Type) SetTCCR3(value uint32) {
	volatile.StoreUint32(&o.TCCR3.Reg, value)
}
func (o *ENET_Type) GetTCCR3() uint32 {
	return volatile.LoadUint32(&o.TCCR3.Reg)
}

// 12-Bit Digital-to-Analog Converter
type DAC_Type struct {
	DAT0L  volatile.Register8 // 0x0
	DAT0H  volatile.Register8 // 0x1
	DAT1L  volatile.Register8 // 0x2
	DAT1H  volatile.Register8 // 0x3
	DAT2L  volatile.Register8 // 0x4
	DAT2H  volatile.Register8 // 0x5
	DAT3L  volatile.Register8 // 0x6
	DAT3H  volatile.Register8 // 0x7
	DAT4L  volatile.Register8 // 0x8
	DAT4H  volatile.Register8 // 0x9
	DAT5L  volatile.Register8 // 0xA
	DAT5H  volatile.Register8 // 0xB
	DAT6L  volatile.Register8 // 0xC
	DAT6H  volatile.Register8 // 0xD
	DAT7L  volatile.Register8 // 0xE
	DAT7H  volatile.Register8 // 0xF
	DAT8L  volatile.Register8 // 0x10
	DAT8H  volatile.Register8 // 0x11
	DAT9L  volatile.Register8 // 0x12
	DAT9H  volatile.Register8 // 0x13
	DAT10L volatile.Register8 // 0x14
	DAT10H volatile.Register8 // 0x15
	DAT11L volatile.Register8 // 0x16
	DAT11H volatile.Register8 // 0x17
	DAT12L volatile.Register8 // 0x18
	DAT12H volatile.Register8 // 0x19
	DAT13L volatile.Register8 // 0x1A
	DAT13H volatile.Register8 // 0x1B
	DAT14L volatile.Register8 // 0x1C
	DAT14H volatile.Register8 // 0x1D
	DAT15L volatile.Register8 // 0x1E
	DAT15H volatile.Register8 // 0x1F
	SR     volatile.Register8 // 0x20
	C0     volatile.Register8 // 0x21
	C1     volatile.Register8 // 0x22
	C2     volatile.Register8 // 0x23
}

// DAC.DAT0L: DAC Data Low Register
func (o *DAC_Type) SetDAT0L(value uint8) {
	volatile.StoreUint8(&o.DAT0L.Reg, value)
}
func (o *DAC_Type) GetDAT0L() uint8 {
	return volatile.LoadUint8(&o.DAT0L.Reg)
}

// DAC.DAT0H: DAC Data High Register
func (o *DAC_Type) SetDAT0H_DATA1(value uint8) {
	volatile.StoreUint8(&o.DAT0H.Reg, volatile.LoadUint8(&o.DAT0H.Reg)&^(0xf)|value)
}
func (o *DAC_Type) GetDAT0H_DATA1() uint8 {
	return volatile.LoadUint8(&o.DAT0H.Reg) & 0xf
}

// DAC.DAT1L: DAC Data Low Register
func (o *DAC_Type) SetDAT1L(value uint8) {
	volatile.StoreUint8(&o.DAT1L.Reg, value)
}
func (o *DAC_Type) GetDAT1L() uint8 {
	return volatile.LoadUint8(&o.DAT1L.Reg)
}

// DAC.DAT1H: DAC Data High Register
func (o *DAC_Type) SetDAT1H_DATA1(value uint8) {
	volatile.StoreUint8(&o.DAT1H.Reg, volatile.LoadUint8(&o.DAT1H.Reg)&^(0xf)|value)
}
func (o *DAC_Type) GetDAT1H_DATA1() uint8 {
	return volatile.LoadUint8(&o.DAT1H.Reg) & 0xf
}

// DAC.DAT2L: DAC Data Low Register
func (o *DAC_Type) SetDAT2L(value uint8) {
	volatile.StoreUint8(&o.DAT2L.Reg, value)
}
func (o *DAC_Type) GetDAT2L() uint8 {
	return volatile.LoadUint8(&o.DAT2L.Reg)
}

// DAC.DAT2H: DAC Data High Register
func (o *DAC_Type) SetDAT2H_DATA1(value uint8) {
	volatile.StoreUint8(&o.DAT2H.Reg, volatile.LoadUint8(&o.DAT2H.Reg)&^(0xf)|value)
}
func (o *DAC_Type) GetDAT2H_DATA1() uint8 {
	return volatile.LoadUint8(&o.DAT2H.Reg) & 0xf
}

// DAC.DAT3L: DAC Data Low Register
func (o *DAC_Type) SetDAT3L(value uint8) {
	volatile.StoreUint8(&o.DAT3L.Reg, value)
}
func (o *DAC_Type) GetDAT3L() uint8 {
	return volatile.LoadUint8(&o.DAT3L.Reg)
}

// DAC.DAT3H: DAC Data High Register
func (o *DAC_Type) SetDAT3H_DATA1(value uint8) {
	volatile.StoreUint8(&o.DAT3H.Reg, volatile.LoadUint8(&o.DAT3H.Reg)&^(0xf)|value)
}
func (o *DAC_Type) GetDAT3H_DATA1() uint8 {
	return volatile.LoadUint8(&o.DAT3H.Reg) & 0xf
}

// DAC.DAT4L: DAC Data Low Register
func (o *DAC_Type) SetDAT4L(value uint8) {
	volatile.StoreUint8(&o.DAT4L.Reg, value)
}
func (o *DAC_Type) GetDAT4L() uint8 {
	return volatile.LoadUint8(&o.DAT4L.Reg)
}

// DAC.DAT4H: DAC Data High Register
func (o *DAC_Type) SetDAT4H_DATA1(value uint8) {
	volatile.StoreUint8(&o.DAT4H.Reg, volatile.LoadUint8(&o.DAT4H.Reg)&^(0xf)|value)
}
func (o *DAC_Type) GetDAT4H_DATA1() uint8 {
	return volatile.LoadUint8(&o.DAT4H.Reg) & 0xf
}

// DAC.DAT5L: DAC Data Low Register
func (o *DAC_Type) SetDAT5L(value uint8) {
	volatile.StoreUint8(&o.DAT5L.Reg, value)
}
func (o *DAC_Type) GetDAT5L() uint8 {
	return volatile.LoadUint8(&o.DAT5L.Reg)
}

// DAC.DAT5H: DAC Data High Register
func (o *DAC_Type) SetDAT5H_DATA1(value uint8) {
	volatile.StoreUint8(&o.DAT5H.Reg, volatile.LoadUint8(&o.DAT5H.Reg)&^(0xf)|value)
}
func (o *DAC_Type) GetDAT5H_DATA1() uint8 {
	return volatile.LoadUint8(&o.DAT5H.Reg) & 0xf
}

// DAC.DAT6L: DAC Data Low Register
func (o *DAC_Type) SetDAT6L(value uint8) {
	volatile.StoreUint8(&o.DAT6L.Reg, value)
}
func (o *DAC_Type) GetDAT6L() uint8 {
	return volatile.LoadUint8(&o.DAT6L.Reg)
}

// DAC.DAT6H: DAC Data High Register
func (o *DAC_Type) SetDAT6H_DATA1(value uint8) {
	volatile.StoreUint8(&o.DAT6H.Reg, volatile.LoadUint8(&o.DAT6H.Reg)&^(0xf)|value)
}
func (o *DAC_Type) GetDAT6H_DATA1() uint8 {
	return volatile.LoadUint8(&o.DAT6H.Reg) & 0xf
}

// DAC.DAT7L: DAC Data Low Register
func (o *DAC_Type) SetDAT7L(value uint8) {
	volatile.StoreUint8(&o.DAT7L.Reg, value)
}
func (o *DAC_Type) GetDAT7L() uint8 {
	return volatile.LoadUint8(&o.DAT7L.Reg)
}

// DAC.DAT7H: DAC Data High Register
func (o *DAC_Type) SetDAT7H_DATA1(value uint8) {
	volatile.StoreUint8(&o.DAT7H.Reg, volatile.LoadUint8(&o.DAT7H.Reg)&^(0xf)|value)
}
func (o *DAC_Type) GetDAT7H_DATA1() uint8 {
	return volatile.LoadUint8(&o.DAT7H.Reg) & 0xf
}

// DAC.DAT8L: DAC Data Low Register
func (o *DAC_Type) SetDAT8L(value uint8) {
	volatile.StoreUint8(&o.DAT8L.Reg, value)
}
func (o *DAC_Type) GetDAT8L() uint8 {
	return volatile.LoadUint8(&o.DAT8L.Reg)
}

// DAC.DAT8H: DAC Data High Register
func (o *DAC_Type) SetDAT8H_DATA1(value uint8) {
	volatile.StoreUint8(&o.DAT8H.Reg, volatile.LoadUint8(&o.DAT8H.Reg)&^(0xf)|value)
}
func (o *DAC_Type) GetDAT8H_DATA1() uint8 {
	return volatile.LoadUint8(&o.DAT8H.Reg) & 0xf
}

// DAC.DAT9L: DAC Data Low Register
func (o *DAC_Type) SetDAT9L(value uint8) {
	volatile.StoreUint8(&o.DAT9L.Reg, value)
}
func (o *DAC_Type) GetDAT9L() uint8 {
	return volatile.LoadUint8(&o.DAT9L.Reg)
}

// DAC.DAT9H: DAC Data High Register
func (o *DAC_Type) SetDAT9H_DATA1(value uint8) {
	volatile.StoreUint8(&o.DAT9H.Reg, volatile.LoadUint8(&o.DAT9H.Reg)&^(0xf)|value)
}
func (o *DAC_Type) GetDAT9H_DATA1() uint8 {
	return volatile.LoadUint8(&o.DAT9H.Reg) & 0xf
}

// DAC.DAT10L: DAC Data Low Register
func (o *DAC_Type) SetDAT10L(value uint8) {
	volatile.StoreUint8(&o.DAT10L.Reg, value)
}
func (o *DAC_Type) GetDAT10L() uint8 {
	return volatile.LoadUint8(&o.DAT10L.Reg)
}

// DAC.DAT10H: DAC Data High Register
func (o *DAC_Type) SetDAT10H_DATA1(value uint8) {
	volatile.StoreUint8(&o.DAT10H.Reg, volatile.LoadUint8(&o.DAT10H.Reg)&^(0xf)|value)
}
func (o *DAC_Type) GetDAT10H_DATA1() uint8 {
	return volatile.LoadUint8(&o.DAT10H.Reg) & 0xf
}

// DAC.DAT11L: DAC Data Low Register
func (o *DAC_Type) SetDAT11L(value uint8) {
	volatile.StoreUint8(&o.DAT11L.Reg, value)
}
func (o *DAC_Type) GetDAT11L() uint8 {
	return volatile.LoadUint8(&o.DAT11L.Reg)
}

// DAC.DAT11H: DAC Data High Register
func (o *DAC_Type) SetDAT11H_DATA1(value uint8) {
	volatile.StoreUint8(&o.DAT11H.Reg, volatile.LoadUint8(&o.DAT11H.Reg)&^(0xf)|value)
}
func (o *DAC_Type) GetDAT11H_DATA1() uint8 {
	return volatile.LoadUint8(&o.DAT11H.Reg) & 0xf
}

// DAC.DAT12L: DAC Data Low Register
func (o *DAC_Type) SetDAT12L(value uint8) {
	volatile.StoreUint8(&o.DAT12L.Reg, value)
}
func (o *DAC_Type) GetDAT12L() uint8 {
	return volatile.LoadUint8(&o.DAT12L.Reg)
}

// DAC.DAT12H: DAC Data High Register
func (o *DAC_Type) SetDAT12H_DATA1(value uint8) {
	volatile.StoreUint8(&o.DAT12H.Reg, volatile.LoadUint8(&o.DAT12H.Reg)&^(0xf)|value)
}
func (o *DAC_Type) GetDAT12H_DATA1() uint8 {
	return volatile.LoadUint8(&o.DAT12H.Reg) & 0xf
}

// DAC.DAT13L: DAC Data Low Register
func (o *DAC_Type) SetDAT13L(value uint8) {
	volatile.StoreUint8(&o.DAT13L.Reg, value)
}
func (o *DAC_Type) GetDAT13L() uint8 {
	return volatile.LoadUint8(&o.DAT13L.Reg)
}

// DAC.DAT13H: DAC Data High Register
func (o *DAC_Type) SetDAT13H_DATA1(value uint8) {
	volatile.StoreUint8(&o.DAT13H.Reg, volatile.LoadUint8(&o.DAT13H.Reg)&^(0xf)|value)
}
func (o *DAC_Type) GetDAT13H_DATA1() uint8 {
	return volatile.LoadUint8(&o.DAT13H.Reg) & 0xf
}

// DAC.DAT14L: DAC Data Low Register
func (o *DAC_Type) SetDAT14L(value uint8) {
	volatile.StoreUint8(&o.DAT14L.Reg, value)
}
func (o *DAC_Type) GetDAT14L() uint8 {
	return volatile.LoadUint8(&o.DAT14L.Reg)
}

// DAC.DAT14H: DAC Data High Register
func (o *DAC_Type) SetDAT14H_DATA1(value uint8) {
	volatile.StoreUint8(&o.DAT14H.Reg, volatile.LoadUint8(&o.DAT14H.Reg)&^(0xf)|value)
}
func (o *DAC_Type) GetDAT14H_DATA1() uint8 {
	return volatile.LoadUint8(&o.DAT14H.Reg) & 0xf
}

// DAC.DAT15L: DAC Data Low Register
func (o *DAC_Type) SetDAT15L(value uint8) {
	volatile.StoreUint8(&o.DAT15L.Reg, value)
}
func (o *DAC_Type) GetDAT15L() uint8 {
	return volatile.LoadUint8(&o.DAT15L.Reg)
}

// DAC.DAT15H: DAC Data High Register
func (o *DAC_Type) SetDAT15H_DATA1(value uint8) {
	volatile.StoreUint8(&o.DAT15H.Reg, volatile.LoadUint8(&o.DAT15H.Reg)&^(0xf)|value)
}
func (o *DAC_Type) GetDAT15H_DATA1() uint8 {
	return volatile.LoadUint8(&o.DAT15H.Reg) & 0xf
}

// DAC.SR: DAC Status Register
func (o *DAC_Type) SetSR_DACBFRPBF(value uint8) {
	volatile.StoreUint8(&o.SR.Reg, volatile.LoadUint8(&o.SR.Reg)&^(0x1)|value)
}
func (o *DAC_Type) GetSR_DACBFRPBF() uint8 {
	return volatile.LoadUint8(&o.SR.Reg) & 0x1
}
func (o *DAC_Type) SetSR_DACBFRPTF(value uint8) {
	volatile.StoreUint8(&o.SR.Reg, volatile.LoadUint8(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *DAC_Type) GetSR_DACBFRPTF() uint8 {
	return (volatile.LoadUint8(&o.SR.Reg) & 0x2) >> 1
}
func (o *DAC_Type) SetSR_DACBFWMF(value uint8) {
	volatile.StoreUint8(&o.SR.Reg, volatile.LoadUint8(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *DAC_Type) GetSR_DACBFWMF() uint8 {
	return (volatile.LoadUint8(&o.SR.Reg) & 0x4) >> 2
}

// DAC.C0: DAC Control Register
func (o *DAC_Type) SetC0_DACBBIEN(value uint8) {
	volatile.StoreUint8(&o.C0.Reg, volatile.LoadUint8(&o.C0.Reg)&^(0x1)|value)
}
func (o *DAC_Type) GetC0_DACBBIEN() uint8 {
	return volatile.LoadUint8(&o.C0.Reg) & 0x1
}
func (o *DAC_Type) SetC0_DACBTIEN(value uint8) {
	volatile.StoreUint8(&o.C0.Reg, volatile.LoadUint8(&o.C0.Reg)&^(0x2)|value<<1)
}
func (o *DAC_Type) GetC0_DACBTIEN() uint8 {
	return (volatile.LoadUint8(&o.C0.Reg) & 0x2) >> 1
}
func (o *DAC_Type) SetC0_DACBWIEN(value uint8) {
	volatile.StoreUint8(&o.C0.Reg, volatile.LoadUint8(&o.C0.Reg)&^(0x4)|value<<2)
}
func (o *DAC_Type) GetC0_DACBWIEN() uint8 {
	return (volatile.LoadUint8(&o.C0.Reg) & 0x4) >> 2
}
func (o *DAC_Type) SetC0_LPEN(value uint8) {
	volatile.StoreUint8(&o.C0.Reg, volatile.LoadUint8(&o.C0.Reg)&^(0x8)|value<<3)
}
func (o *DAC_Type) GetC0_LPEN() uint8 {
	return (volatile.LoadUint8(&o.C0.Reg) & 0x8) >> 3
}
func (o *DAC_Type) SetC0_DACSWTRG(value uint8) {
	volatile.StoreUint8(&o.C0.Reg, volatile.LoadUint8(&o.C0.Reg)&^(0x10)|value<<4)
}
func (o *DAC_Type) GetC0_DACSWTRG() uint8 {
	return (volatile.LoadUint8(&o.C0.Reg) & 0x10) >> 4
}
func (o *DAC_Type) SetC0_DACTRGSEL(value uint8) {
	volatile.StoreUint8(&o.C0.Reg, volatile.LoadUint8(&o.C0.Reg)&^(0x20)|value<<5)
}
func (o *DAC_Type) GetC0_DACTRGSEL() uint8 {
	return (volatile.LoadUint8(&o.C0.Reg) & 0x20) >> 5
}
func (o *DAC_Type) SetC0_DACRFS(value uint8) {
	volatile.StoreUint8(&o.C0.Reg, volatile.LoadUint8(&o.C0.Reg)&^(0x40)|value<<6)
}
func (o *DAC_Type) GetC0_DACRFS() uint8 {
	return (volatile.LoadUint8(&o.C0.Reg) & 0x40) >> 6
}
func (o *DAC_Type) SetC0_DACEN(value uint8) {
	volatile.StoreUint8(&o.C0.Reg, volatile.LoadUint8(&o.C0.Reg)&^(0x80)|value<<7)
}
func (o *DAC_Type) GetC0_DACEN() uint8 {
	return (volatile.LoadUint8(&o.C0.Reg) & 0x80) >> 7
}

// DAC.C1: DAC Control Register 1
func (o *DAC_Type) SetC1_DACBFEN(value uint8) {
	volatile.StoreUint8(&o.C1.Reg, volatile.LoadUint8(&o.C1.Reg)&^(0x1)|value)
}
func (o *DAC_Type) GetC1_DACBFEN() uint8 {
	return volatile.LoadUint8(&o.C1.Reg) & 0x1
}
func (o *DAC_Type) SetC1_DACBFMD(value uint8) {
	volatile.StoreUint8(&o.C1.Reg, volatile.LoadUint8(&o.C1.Reg)&^(0x6)|value<<1)
}
func (o *DAC_Type) GetC1_DACBFMD() uint8 {
	return (volatile.LoadUint8(&o.C1.Reg) & 0x6) >> 1
}
func (o *DAC_Type) SetC1_DACBFWM(value uint8) {
	volatile.StoreUint8(&o.C1.Reg, volatile.LoadUint8(&o.C1.Reg)&^(0x18)|value<<3)
}
func (o *DAC_Type) GetC1_DACBFWM() uint8 {
	return (volatile.LoadUint8(&o.C1.Reg) & 0x18) >> 3
}
func (o *DAC_Type) SetC1_DMAEN(value uint8) {
	volatile.StoreUint8(&o.C1.Reg, volatile.LoadUint8(&o.C1.Reg)&^(0x80)|value<<7)
}
func (o *DAC_Type) GetC1_DMAEN() uint8 {
	return (volatile.LoadUint8(&o.C1.Reg) & 0x80) >> 7
}

// DAC.C2: DAC Control Register 2
func (o *DAC_Type) SetC2_DACBFUP(value uint8) {
	volatile.StoreUint8(&o.C2.Reg, volatile.LoadUint8(&o.C2.Reg)&^(0xf)|value)
}
func (o *DAC_Type) GetC2_DACBFUP() uint8 {
	return volatile.LoadUint8(&o.C2.Reg) & 0xf
}
func (o *DAC_Type) SetC2_DACBFRP(value uint8) {
	volatile.StoreUint8(&o.C2.Reg, volatile.LoadUint8(&o.C2.Reg)&^(0xf0)|value<<4)
}
func (o *DAC_Type) GetC2_DACBFRP() uint8 {
	return (volatile.LoadUint8(&o.C2.Reg) & 0xf0) >> 4
}

// General Purpose Input/Output
type GPIO_Type struct {
	PDOR volatile.Register32 // 0x0
	PSOR volatile.Register32 // 0x4
	PCOR volatile.Register32 // 0x8
	PTOR volatile.Register32 // 0xC
	PDIR volatile.Register32 // 0x10
	PDDR volatile.Register32 // 0x14
}

// GPIO.PDOR: Port Data Output Register
func (o *GPIO_Type) SetPDOR_PDO0(value uint32) {
	volatile.StoreUint32(&o.PDOR.Reg, volatile.LoadUint32(&o.PDOR.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetPDOR_PDO0() uint32 {
	return volatile.LoadUint32(&o.PDOR.Reg) & 0x1
}
func (o *GPIO_Type) SetPDOR_PDO1(value uint32) {
	volatile.StoreUint32(&o.PDOR.Reg, volatile.LoadUint32(&o.PDOR.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetPDOR_PDO1() uint32 {
	return (volatile.LoadUint32(&o.PDOR.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetPDOR_PDO2(value uint32) {
	volatile.StoreUint32(&o.PDOR.Reg, volatile.LoadUint32(&o.PDOR.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPDOR_PDO2() uint32 {
	return (volatile.LoadUint32(&o.PDOR.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPDOR_PDO3(value uint32) {
	volatile.StoreUint32(&o.PDOR.Reg, volatile.LoadUint32(&o.PDOR.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetPDOR_PDO3() uint32 {
	return (volatile.LoadUint32(&o.PDOR.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetPDOR_PDO4(value uint32) {
	volatile.StoreUint32(&o.PDOR.Reg, volatile.LoadUint32(&o.PDOR.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetPDOR_PDO4() uint32 {
	return (volatile.LoadUint32(&o.PDOR.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetPDOR_PDO5(value uint32) {
	volatile.StoreUint32(&o.PDOR.Reg, volatile.LoadUint32(&o.PDOR.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetPDOR_PDO5() uint32 {
	return (volatile.LoadUint32(&o.PDOR.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetPDOR_PDO6(value uint32) {
	volatile.StoreUint32(&o.PDOR.Reg, volatile.LoadUint32(&o.PDOR.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetPDOR_PDO6() uint32 {
	return (volatile.LoadUint32(&o.PDOR.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetPDOR_PDO7(value uint32) {
	volatile.StoreUint32(&o.PDOR.Reg, volatile.LoadUint32(&o.PDOR.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetPDOR_PDO7() uint32 {
	return (volatile.LoadUint32(&o.PDOR.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetPDOR_PDO8(value uint32) {
	volatile.StoreUint32(&o.PDOR.Reg, volatile.LoadUint32(&o.PDOR.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetPDOR_PDO8() uint32 {
	return (volatile.LoadUint32(&o.PDOR.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetPDOR_PDO9(value uint32) {
	volatile.StoreUint32(&o.PDOR.Reg, volatile.LoadUint32(&o.PDOR.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetPDOR_PDO9() uint32 {
	return (volatile.LoadUint32(&o.PDOR.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetPDOR_PDO10(value uint32) {
	volatile.StoreUint32(&o.PDOR.Reg, volatile.LoadUint32(&o.PDOR.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPDOR_PDO10() uint32 {
	return (volatile.LoadUint32(&o.PDOR.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPDOR_PDO11(value uint32) {
	volatile.StoreUint32(&o.PDOR.Reg, volatile.LoadUint32(&o.PDOR.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetPDOR_PDO11() uint32 {
	return (volatile.LoadUint32(&o.PDOR.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetPDOR_PDO12(value uint32) {
	volatile.StoreUint32(&o.PDOR.Reg, volatile.LoadUint32(&o.PDOR.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetPDOR_PDO12() uint32 {
	return (volatile.LoadUint32(&o.PDOR.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetPDOR_PDO13(value uint32) {
	volatile.StoreUint32(&o.PDOR.Reg, volatile.LoadUint32(&o.PDOR.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetPDOR_PDO13() uint32 {
	return (volatile.LoadUint32(&o.PDOR.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetPDOR_PDO14(value uint32) {
	volatile.StoreUint32(&o.PDOR.Reg, volatile.LoadUint32(&o.PDOR.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetPDOR_PDO14() uint32 {
	return (volatile.LoadUint32(&o.PDOR.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetPDOR_PDO15(value uint32) {
	volatile.StoreUint32(&o.PDOR.Reg, volatile.LoadUint32(&o.PDOR.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetPDOR_PDO15() uint32 {
	return (volatile.LoadUint32(&o.PDOR.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetPDOR_PDO16(value uint32) {
	volatile.StoreUint32(&o.PDOR.Reg, volatile.LoadUint32(&o.PDOR.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_Type) GetPDOR_PDO16() uint32 {
	return (volatile.LoadUint32(&o.PDOR.Reg) & 0x10000) >> 16
}
func (o *GPIO_Type) SetPDOR_PDO17(value uint32) {
	volatile.StoreUint32(&o.PDOR.Reg, volatile.LoadUint32(&o.PDOR.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_Type) GetPDOR_PDO17() uint32 {
	return (volatile.LoadUint32(&o.PDOR.Reg) & 0x20000) >> 17
}
func (o *GPIO_Type) SetPDOR_PDO18(value uint32) {
	volatile.StoreUint32(&o.PDOR.Reg, volatile.LoadUint32(&o.PDOR.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_Type) GetPDOR_PDO18() uint32 {
	return (volatile.LoadUint32(&o.PDOR.Reg) & 0x40000) >> 18
}
func (o *GPIO_Type) SetPDOR_PDO19(value uint32) {
	volatile.StoreUint32(&o.PDOR.Reg, volatile.LoadUint32(&o.PDOR.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_Type) GetPDOR_PDO19() uint32 {
	return (volatile.LoadUint32(&o.PDOR.Reg) & 0x80000) >> 19
}
func (o *GPIO_Type) SetPDOR_PDO20(value uint32) {
	volatile.StoreUint32(&o.PDOR.Reg, volatile.LoadUint32(&o.PDOR.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_Type) GetPDOR_PDO20() uint32 {
	return (volatile.LoadUint32(&o.PDOR.Reg) & 0x100000) >> 20
}
func (o *GPIO_Type) SetPDOR_PDO21(value uint32) {
	volatile.StoreUint32(&o.PDOR.Reg, volatile.LoadUint32(&o.PDOR.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_Type) GetPDOR_PDO21() uint32 {
	return (volatile.LoadUint32(&o.PDOR.Reg) & 0x200000) >> 21
}
func (o *GPIO_Type) SetPDOR_PDO22(value uint32) {
	volatile.StoreUint32(&o.PDOR.Reg, volatile.LoadUint32(&o.PDOR.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_Type) GetPDOR_PDO22() uint32 {
	return (volatile.LoadUint32(&o.PDOR.Reg) & 0x400000) >> 22
}
func (o *GPIO_Type) SetPDOR_PDO23(value uint32) {
	volatile.StoreUint32(&o.PDOR.Reg, volatile.LoadUint32(&o.PDOR.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_Type) GetPDOR_PDO23() uint32 {
	return (volatile.LoadUint32(&o.PDOR.Reg) & 0x800000) >> 23
}
func (o *GPIO_Type) SetPDOR_PDO24(value uint32) {
	volatile.StoreUint32(&o.PDOR.Reg, volatile.LoadUint32(&o.PDOR.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_Type) GetPDOR_PDO24() uint32 {
	return (volatile.LoadUint32(&o.PDOR.Reg) & 0x1000000) >> 24
}
func (o *GPIO_Type) SetPDOR_PDO25(value uint32) {
	volatile.StoreUint32(&o.PDOR.Reg, volatile.LoadUint32(&o.PDOR.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_Type) GetPDOR_PDO25() uint32 {
	return (volatile.LoadUint32(&o.PDOR.Reg) & 0x2000000) >> 25
}
func (o *GPIO_Type) SetPDOR_PDO26(value uint32) {
	volatile.StoreUint32(&o.PDOR.Reg, volatile.LoadUint32(&o.PDOR.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_Type) GetPDOR_PDO26() uint32 {
	return (volatile.LoadUint32(&o.PDOR.Reg) & 0x4000000) >> 26
}
func (o *GPIO_Type) SetPDOR_PDO27(value uint32) {
	volatile.StoreUint32(&o.PDOR.Reg, volatile.LoadUint32(&o.PDOR.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_Type) GetPDOR_PDO27() uint32 {
	return (volatile.LoadUint32(&o.PDOR.Reg) & 0x8000000) >> 27
}
func (o *GPIO_Type) SetPDOR_PDO28(value uint32) {
	volatile.StoreUint32(&o.PDOR.Reg, volatile.LoadUint32(&o.PDOR.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_Type) GetPDOR_PDO28() uint32 {
	return (volatile.LoadUint32(&o.PDOR.Reg) & 0x10000000) >> 28
}
func (o *GPIO_Type) SetPDOR_PDO29(value uint32) {
	volatile.StoreUint32(&o.PDOR.Reg, volatile.LoadUint32(&o.PDOR.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_Type) GetPDOR_PDO29() uint32 {
	return (volatile.LoadUint32(&o.PDOR.Reg) & 0x20000000) >> 29
}
func (o *GPIO_Type) SetPDOR_PDO30(value uint32) {
	volatile.StoreUint32(&o.PDOR.Reg, volatile.LoadUint32(&o.PDOR.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_Type) GetPDOR_PDO30() uint32 {
	return (volatile.LoadUint32(&o.PDOR.Reg) & 0x40000000) >> 30
}
func (o *GPIO_Type) SetPDOR_PDO31(value uint32) {
	volatile.StoreUint32(&o.PDOR.Reg, volatile.LoadUint32(&o.PDOR.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_Type) GetPDOR_PDO31() uint32 {
	return (volatile.LoadUint32(&o.PDOR.Reg) & 0x80000000) >> 31
}

// GPIO.PSOR: Port Set Output Register
func (o *GPIO_Type) SetPSOR_PTSO0(value uint32) {
	volatile.StoreUint32(&o.PSOR.Reg, volatile.LoadUint32(&o.PSOR.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetPSOR_PTSO0() uint32 {
	return volatile.LoadUint32(&o.PSOR.Reg) & 0x1
}
func (o *GPIO_Type) SetPSOR_PTSO1(value uint32) {
	volatile.StoreUint32(&o.PSOR.Reg, volatile.LoadUint32(&o.PSOR.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetPSOR_PTSO1() uint32 {
	return (volatile.LoadUint32(&o.PSOR.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetPSOR_PTSO2(value uint32) {
	volatile.StoreUint32(&o.PSOR.Reg, volatile.LoadUint32(&o.PSOR.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPSOR_PTSO2() uint32 {
	return (volatile.LoadUint32(&o.PSOR.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPSOR_PTSO3(value uint32) {
	volatile.StoreUint32(&o.PSOR.Reg, volatile.LoadUint32(&o.PSOR.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetPSOR_PTSO3() uint32 {
	return (volatile.LoadUint32(&o.PSOR.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetPSOR_PTSO4(value uint32) {
	volatile.StoreUint32(&o.PSOR.Reg, volatile.LoadUint32(&o.PSOR.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetPSOR_PTSO4() uint32 {
	return (volatile.LoadUint32(&o.PSOR.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetPSOR_PTSO5(value uint32) {
	volatile.StoreUint32(&o.PSOR.Reg, volatile.LoadUint32(&o.PSOR.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetPSOR_PTSO5() uint32 {
	return (volatile.LoadUint32(&o.PSOR.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetPSOR_PTSO6(value uint32) {
	volatile.StoreUint32(&o.PSOR.Reg, volatile.LoadUint32(&o.PSOR.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetPSOR_PTSO6() uint32 {
	return (volatile.LoadUint32(&o.PSOR.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetPSOR_PTSO7(value uint32) {
	volatile.StoreUint32(&o.PSOR.Reg, volatile.LoadUint32(&o.PSOR.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetPSOR_PTSO7() uint32 {
	return (volatile.LoadUint32(&o.PSOR.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetPSOR_PTSO8(value uint32) {
	volatile.StoreUint32(&o.PSOR.Reg, volatile.LoadUint32(&o.PSOR.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetPSOR_PTSO8() uint32 {
	return (volatile.LoadUint32(&o.PSOR.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetPSOR_PTSO9(value uint32) {
	volatile.StoreUint32(&o.PSOR.Reg, volatile.LoadUint32(&o.PSOR.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetPSOR_PTSO9() uint32 {
	return (volatile.LoadUint32(&o.PSOR.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetPSOR_PTSO10(value uint32) {
	volatile.StoreUint32(&o.PSOR.Reg, volatile.LoadUint32(&o.PSOR.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPSOR_PTSO10() uint32 {
	return (volatile.LoadUint32(&o.PSOR.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPSOR_PTSO11(value uint32) {
	volatile.StoreUint32(&o.PSOR.Reg, volatile.LoadUint32(&o.PSOR.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetPSOR_PTSO11() uint32 {
	return (volatile.LoadUint32(&o.PSOR.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetPSOR_PTSO12(value uint32) {
	volatile.StoreUint32(&o.PSOR.Reg, volatile.LoadUint32(&o.PSOR.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetPSOR_PTSO12() uint32 {
	return (volatile.LoadUint32(&o.PSOR.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetPSOR_PTSO13(value uint32) {
	volatile.StoreUint32(&o.PSOR.Reg, volatile.LoadUint32(&o.PSOR.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetPSOR_PTSO13() uint32 {
	return (volatile.LoadUint32(&o.PSOR.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetPSOR_PTSO14(value uint32) {
	volatile.StoreUint32(&o.PSOR.Reg, volatile.LoadUint32(&o.PSOR.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetPSOR_PTSO14() uint32 {
	return (volatile.LoadUint32(&o.PSOR.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetPSOR_PTSO15(value uint32) {
	volatile.StoreUint32(&o.PSOR.Reg, volatile.LoadUint32(&o.PSOR.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetPSOR_PTSO15() uint32 {
	return (volatile.LoadUint32(&o.PSOR.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetPSOR_PTSO16(value uint32) {
	volatile.StoreUint32(&o.PSOR.Reg, volatile.LoadUint32(&o.PSOR.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_Type) GetPSOR_PTSO16() uint32 {
	return (volatile.LoadUint32(&o.PSOR.Reg) & 0x10000) >> 16
}
func (o *GPIO_Type) SetPSOR_PTSO17(value uint32) {
	volatile.StoreUint32(&o.PSOR.Reg, volatile.LoadUint32(&o.PSOR.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_Type) GetPSOR_PTSO17() uint32 {
	return (volatile.LoadUint32(&o.PSOR.Reg) & 0x20000) >> 17
}
func (o *GPIO_Type) SetPSOR_PTSO18(value uint32) {
	volatile.StoreUint32(&o.PSOR.Reg, volatile.LoadUint32(&o.PSOR.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_Type) GetPSOR_PTSO18() uint32 {
	return (volatile.LoadUint32(&o.PSOR.Reg) & 0x40000) >> 18
}
func (o *GPIO_Type) SetPSOR_PTSO19(value uint32) {
	volatile.StoreUint32(&o.PSOR.Reg, volatile.LoadUint32(&o.PSOR.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_Type) GetPSOR_PTSO19() uint32 {
	return (volatile.LoadUint32(&o.PSOR.Reg) & 0x80000) >> 19
}
func (o *GPIO_Type) SetPSOR_PTSO20(value uint32) {
	volatile.StoreUint32(&o.PSOR.Reg, volatile.LoadUint32(&o.PSOR.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_Type) GetPSOR_PTSO20() uint32 {
	return (volatile.LoadUint32(&o.PSOR.Reg) & 0x100000) >> 20
}
func (o *GPIO_Type) SetPSOR_PTSO21(value uint32) {
	volatile.StoreUint32(&o.PSOR.Reg, volatile.LoadUint32(&o.PSOR.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_Type) GetPSOR_PTSO21() uint32 {
	return (volatile.LoadUint32(&o.PSOR.Reg) & 0x200000) >> 21
}
func (o *GPIO_Type) SetPSOR_PTSO22(value uint32) {
	volatile.StoreUint32(&o.PSOR.Reg, volatile.LoadUint32(&o.PSOR.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_Type) GetPSOR_PTSO22() uint32 {
	return (volatile.LoadUint32(&o.PSOR.Reg) & 0x400000) >> 22
}
func (o *GPIO_Type) SetPSOR_PTSO23(value uint32) {
	volatile.StoreUint32(&o.PSOR.Reg, volatile.LoadUint32(&o.PSOR.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_Type) GetPSOR_PTSO23() uint32 {
	return (volatile.LoadUint32(&o.PSOR.Reg) & 0x800000) >> 23
}
func (o *GPIO_Type) SetPSOR_PTSO24(value uint32) {
	volatile.StoreUint32(&o.PSOR.Reg, volatile.LoadUint32(&o.PSOR.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_Type) GetPSOR_PTSO24() uint32 {
	return (volatile.LoadUint32(&o.PSOR.Reg) & 0x1000000) >> 24
}
func (o *GPIO_Type) SetPSOR_PTSO25(value uint32) {
	volatile.StoreUint32(&o.PSOR.Reg, volatile.LoadUint32(&o.PSOR.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_Type) GetPSOR_PTSO25() uint32 {
	return (volatile.LoadUint32(&o.PSOR.Reg) & 0x2000000) >> 25
}
func (o *GPIO_Type) SetPSOR_PTSO26(value uint32) {
	volatile.StoreUint32(&o.PSOR.Reg, volatile.LoadUint32(&o.PSOR.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_Type) GetPSOR_PTSO26() uint32 {
	return (volatile.LoadUint32(&o.PSOR.Reg) & 0x4000000) >> 26
}
func (o *GPIO_Type) SetPSOR_PTSO27(value uint32) {
	volatile.StoreUint32(&o.PSOR.Reg, volatile.LoadUint32(&o.PSOR.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_Type) GetPSOR_PTSO27() uint32 {
	return (volatile.LoadUint32(&o.PSOR.Reg) & 0x8000000) >> 27
}
func (o *GPIO_Type) SetPSOR_PTSO28(value uint32) {
	volatile.StoreUint32(&o.PSOR.Reg, volatile.LoadUint32(&o.PSOR.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_Type) GetPSOR_PTSO28() uint32 {
	return (volatile.LoadUint32(&o.PSOR.Reg) & 0x10000000) >> 28
}
func (o *GPIO_Type) SetPSOR_PTSO29(value uint32) {
	volatile.StoreUint32(&o.PSOR.Reg, volatile.LoadUint32(&o.PSOR.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_Type) GetPSOR_PTSO29() uint32 {
	return (volatile.LoadUint32(&o.PSOR.Reg) & 0x20000000) >> 29
}
func (o *GPIO_Type) SetPSOR_PTSO30(value uint32) {
	volatile.StoreUint32(&o.PSOR.Reg, volatile.LoadUint32(&o.PSOR.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_Type) GetPSOR_PTSO30() uint32 {
	return (volatile.LoadUint32(&o.PSOR.Reg) & 0x40000000) >> 30
}
func (o *GPIO_Type) SetPSOR_PTSO31(value uint32) {
	volatile.StoreUint32(&o.PSOR.Reg, volatile.LoadUint32(&o.PSOR.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_Type) GetPSOR_PTSO31() uint32 {
	return (volatile.LoadUint32(&o.PSOR.Reg) & 0x80000000) >> 31
}

// GPIO.PCOR: Port Clear Output Register
func (o *GPIO_Type) SetPCOR_PTCO0(value uint32) {
	volatile.StoreUint32(&o.PCOR.Reg, volatile.LoadUint32(&o.PCOR.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetPCOR_PTCO0() uint32 {
	return volatile.LoadUint32(&o.PCOR.Reg) & 0x1
}
func (o *GPIO_Type) SetPCOR_PTCO1(value uint32) {
	volatile.StoreUint32(&o.PCOR.Reg, volatile.LoadUint32(&o.PCOR.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetPCOR_PTCO1() uint32 {
	return (volatile.LoadUint32(&o.PCOR.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetPCOR_PTCO2(value uint32) {
	volatile.StoreUint32(&o.PCOR.Reg, volatile.LoadUint32(&o.PCOR.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPCOR_PTCO2() uint32 {
	return (volatile.LoadUint32(&o.PCOR.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPCOR_PTCO3(value uint32) {
	volatile.StoreUint32(&o.PCOR.Reg, volatile.LoadUint32(&o.PCOR.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetPCOR_PTCO3() uint32 {
	return (volatile.LoadUint32(&o.PCOR.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetPCOR_PTCO4(value uint32) {
	volatile.StoreUint32(&o.PCOR.Reg, volatile.LoadUint32(&o.PCOR.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetPCOR_PTCO4() uint32 {
	return (volatile.LoadUint32(&o.PCOR.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetPCOR_PTCO5(value uint32) {
	volatile.StoreUint32(&o.PCOR.Reg, volatile.LoadUint32(&o.PCOR.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetPCOR_PTCO5() uint32 {
	return (volatile.LoadUint32(&o.PCOR.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetPCOR_PTCO6(value uint32) {
	volatile.StoreUint32(&o.PCOR.Reg, volatile.LoadUint32(&o.PCOR.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetPCOR_PTCO6() uint32 {
	return (volatile.LoadUint32(&o.PCOR.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetPCOR_PTCO7(value uint32) {
	volatile.StoreUint32(&o.PCOR.Reg, volatile.LoadUint32(&o.PCOR.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetPCOR_PTCO7() uint32 {
	return (volatile.LoadUint32(&o.PCOR.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetPCOR_PTCO8(value uint32) {
	volatile.StoreUint32(&o.PCOR.Reg, volatile.LoadUint32(&o.PCOR.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetPCOR_PTCO8() uint32 {
	return (volatile.LoadUint32(&o.PCOR.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetPCOR_PTCO9(value uint32) {
	volatile.StoreUint32(&o.PCOR.Reg, volatile.LoadUint32(&o.PCOR.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetPCOR_PTCO9() uint32 {
	return (volatile.LoadUint32(&o.PCOR.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetPCOR_PTCO10(value uint32) {
	volatile.StoreUint32(&o.PCOR.Reg, volatile.LoadUint32(&o.PCOR.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPCOR_PTCO10() uint32 {
	return (volatile.LoadUint32(&o.PCOR.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPCOR_PTCO11(value uint32) {
	volatile.StoreUint32(&o.PCOR.Reg, volatile.LoadUint32(&o.PCOR.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetPCOR_PTCO11() uint32 {
	return (volatile.LoadUint32(&o.PCOR.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetPCOR_PTCO12(value uint32) {
	volatile.StoreUint32(&o.PCOR.Reg, volatile.LoadUint32(&o.PCOR.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetPCOR_PTCO12() uint32 {
	return (volatile.LoadUint32(&o.PCOR.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetPCOR_PTCO13(value uint32) {
	volatile.StoreUint32(&o.PCOR.Reg, volatile.LoadUint32(&o.PCOR.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetPCOR_PTCO13() uint32 {
	return (volatile.LoadUint32(&o.PCOR.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetPCOR_PTCO14(value uint32) {
	volatile.StoreUint32(&o.PCOR.Reg, volatile.LoadUint32(&o.PCOR.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetPCOR_PTCO14() uint32 {
	return (volatile.LoadUint32(&o.PCOR.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetPCOR_PTCO15(value uint32) {
	volatile.StoreUint32(&o.PCOR.Reg, volatile.LoadUint32(&o.PCOR.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetPCOR_PTCO15() uint32 {
	return (volatile.LoadUint32(&o.PCOR.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetPCOR_PTCO16(value uint32) {
	volatile.StoreUint32(&o.PCOR.Reg, volatile.LoadUint32(&o.PCOR.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_Type) GetPCOR_PTCO16() uint32 {
	return (volatile.LoadUint32(&o.PCOR.Reg) & 0x10000) >> 16
}
func (o *GPIO_Type) SetPCOR_PTCO17(value uint32) {
	volatile.StoreUint32(&o.PCOR.Reg, volatile.LoadUint32(&o.PCOR.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_Type) GetPCOR_PTCO17() uint32 {
	return (volatile.LoadUint32(&o.PCOR.Reg) & 0x20000) >> 17
}
func (o *GPIO_Type) SetPCOR_PTCO18(value uint32) {
	volatile.StoreUint32(&o.PCOR.Reg, volatile.LoadUint32(&o.PCOR.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_Type) GetPCOR_PTCO18() uint32 {
	return (volatile.LoadUint32(&o.PCOR.Reg) & 0x40000) >> 18
}
func (o *GPIO_Type) SetPCOR_PTCO19(value uint32) {
	volatile.StoreUint32(&o.PCOR.Reg, volatile.LoadUint32(&o.PCOR.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_Type) GetPCOR_PTCO19() uint32 {
	return (volatile.LoadUint32(&o.PCOR.Reg) & 0x80000) >> 19
}
func (o *GPIO_Type) SetPCOR_PTCO20(value uint32) {
	volatile.StoreUint32(&o.PCOR.Reg, volatile.LoadUint32(&o.PCOR.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_Type) GetPCOR_PTCO20() uint32 {
	return (volatile.LoadUint32(&o.PCOR.Reg) & 0x100000) >> 20
}
func (o *GPIO_Type) SetPCOR_PTCO21(value uint32) {
	volatile.StoreUint32(&o.PCOR.Reg, volatile.LoadUint32(&o.PCOR.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_Type) GetPCOR_PTCO21() uint32 {
	return (volatile.LoadUint32(&o.PCOR.Reg) & 0x200000) >> 21
}
func (o *GPIO_Type) SetPCOR_PTCO22(value uint32) {
	volatile.StoreUint32(&o.PCOR.Reg, volatile.LoadUint32(&o.PCOR.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_Type) GetPCOR_PTCO22() uint32 {
	return (volatile.LoadUint32(&o.PCOR.Reg) & 0x400000) >> 22
}
func (o *GPIO_Type) SetPCOR_PTCO23(value uint32) {
	volatile.StoreUint32(&o.PCOR.Reg, volatile.LoadUint32(&o.PCOR.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_Type) GetPCOR_PTCO23() uint32 {
	return (volatile.LoadUint32(&o.PCOR.Reg) & 0x800000) >> 23
}
func (o *GPIO_Type) SetPCOR_PTCO24(value uint32) {
	volatile.StoreUint32(&o.PCOR.Reg, volatile.LoadUint32(&o.PCOR.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_Type) GetPCOR_PTCO24() uint32 {
	return (volatile.LoadUint32(&o.PCOR.Reg) & 0x1000000) >> 24
}
func (o *GPIO_Type) SetPCOR_PTCO25(value uint32) {
	volatile.StoreUint32(&o.PCOR.Reg, volatile.LoadUint32(&o.PCOR.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_Type) GetPCOR_PTCO25() uint32 {
	return (volatile.LoadUint32(&o.PCOR.Reg) & 0x2000000) >> 25
}
func (o *GPIO_Type) SetPCOR_PTCO26(value uint32) {
	volatile.StoreUint32(&o.PCOR.Reg, volatile.LoadUint32(&o.PCOR.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_Type) GetPCOR_PTCO26() uint32 {
	return (volatile.LoadUint32(&o.PCOR.Reg) & 0x4000000) >> 26
}
func (o *GPIO_Type) SetPCOR_PTCO27(value uint32) {
	volatile.StoreUint32(&o.PCOR.Reg, volatile.LoadUint32(&o.PCOR.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_Type) GetPCOR_PTCO27() uint32 {
	return (volatile.LoadUint32(&o.PCOR.Reg) & 0x8000000) >> 27
}
func (o *GPIO_Type) SetPCOR_PTCO28(value uint32) {
	volatile.StoreUint32(&o.PCOR.Reg, volatile.LoadUint32(&o.PCOR.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_Type) GetPCOR_PTCO28() uint32 {
	return (volatile.LoadUint32(&o.PCOR.Reg) & 0x10000000) >> 28
}
func (o *GPIO_Type) SetPCOR_PTCO29(value uint32) {
	volatile.StoreUint32(&o.PCOR.Reg, volatile.LoadUint32(&o.PCOR.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_Type) GetPCOR_PTCO29() uint32 {
	return (volatile.LoadUint32(&o.PCOR.Reg) & 0x20000000) >> 29
}
func (o *GPIO_Type) SetPCOR_PTCO30(value uint32) {
	volatile.StoreUint32(&o.PCOR.Reg, volatile.LoadUint32(&o.PCOR.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_Type) GetPCOR_PTCO30() uint32 {
	return (volatile.LoadUint32(&o.PCOR.Reg) & 0x40000000) >> 30
}
func (o *GPIO_Type) SetPCOR_PTCO31(value uint32) {
	volatile.StoreUint32(&o.PCOR.Reg, volatile.LoadUint32(&o.PCOR.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_Type) GetPCOR_PTCO31() uint32 {
	return (volatile.LoadUint32(&o.PCOR.Reg) & 0x80000000) >> 31
}

// GPIO.PTOR: Port Toggle Output Register
func (o *GPIO_Type) SetPTOR_PTTO0(value uint32) {
	volatile.StoreUint32(&o.PTOR.Reg, volatile.LoadUint32(&o.PTOR.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetPTOR_PTTO0() uint32 {
	return volatile.LoadUint32(&o.PTOR.Reg) & 0x1
}
func (o *GPIO_Type) SetPTOR_PTTO1(value uint32) {
	volatile.StoreUint32(&o.PTOR.Reg, volatile.LoadUint32(&o.PTOR.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetPTOR_PTTO1() uint32 {
	return (volatile.LoadUint32(&o.PTOR.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetPTOR_PTTO2(value uint32) {
	volatile.StoreUint32(&o.PTOR.Reg, volatile.LoadUint32(&o.PTOR.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPTOR_PTTO2() uint32 {
	return (volatile.LoadUint32(&o.PTOR.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPTOR_PTTO3(value uint32) {
	volatile.StoreUint32(&o.PTOR.Reg, volatile.LoadUint32(&o.PTOR.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetPTOR_PTTO3() uint32 {
	return (volatile.LoadUint32(&o.PTOR.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetPTOR_PTTO4(value uint32) {
	volatile.StoreUint32(&o.PTOR.Reg, volatile.LoadUint32(&o.PTOR.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetPTOR_PTTO4() uint32 {
	return (volatile.LoadUint32(&o.PTOR.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetPTOR_PTTO5(value uint32) {
	volatile.StoreUint32(&o.PTOR.Reg, volatile.LoadUint32(&o.PTOR.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetPTOR_PTTO5() uint32 {
	return (volatile.LoadUint32(&o.PTOR.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetPTOR_PTTO6(value uint32) {
	volatile.StoreUint32(&o.PTOR.Reg, volatile.LoadUint32(&o.PTOR.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetPTOR_PTTO6() uint32 {
	return (volatile.LoadUint32(&o.PTOR.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetPTOR_PTTO7(value uint32) {
	volatile.StoreUint32(&o.PTOR.Reg, volatile.LoadUint32(&o.PTOR.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetPTOR_PTTO7() uint32 {
	return (volatile.LoadUint32(&o.PTOR.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetPTOR_PTTO8(value uint32) {
	volatile.StoreUint32(&o.PTOR.Reg, volatile.LoadUint32(&o.PTOR.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetPTOR_PTTO8() uint32 {
	return (volatile.LoadUint32(&o.PTOR.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetPTOR_PTTO9(value uint32) {
	volatile.StoreUint32(&o.PTOR.Reg, volatile.LoadUint32(&o.PTOR.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetPTOR_PTTO9() uint32 {
	return (volatile.LoadUint32(&o.PTOR.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetPTOR_PTTO10(value uint32) {
	volatile.StoreUint32(&o.PTOR.Reg, volatile.LoadUint32(&o.PTOR.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPTOR_PTTO10() uint32 {
	return (volatile.LoadUint32(&o.PTOR.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPTOR_PTTO11(value uint32) {
	volatile.StoreUint32(&o.PTOR.Reg, volatile.LoadUint32(&o.PTOR.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetPTOR_PTTO11() uint32 {
	return (volatile.LoadUint32(&o.PTOR.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetPTOR_PTTO12(value uint32) {
	volatile.StoreUint32(&o.PTOR.Reg, volatile.LoadUint32(&o.PTOR.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetPTOR_PTTO12() uint32 {
	return (volatile.LoadUint32(&o.PTOR.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetPTOR_PTTO13(value uint32) {
	volatile.StoreUint32(&o.PTOR.Reg, volatile.LoadUint32(&o.PTOR.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetPTOR_PTTO13() uint32 {
	return (volatile.LoadUint32(&o.PTOR.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetPTOR_PTTO14(value uint32) {
	volatile.StoreUint32(&o.PTOR.Reg, volatile.LoadUint32(&o.PTOR.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetPTOR_PTTO14() uint32 {
	return (volatile.LoadUint32(&o.PTOR.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetPTOR_PTTO15(value uint32) {
	volatile.StoreUint32(&o.PTOR.Reg, volatile.LoadUint32(&o.PTOR.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetPTOR_PTTO15() uint32 {
	return (volatile.LoadUint32(&o.PTOR.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetPTOR_PTTO16(value uint32) {
	volatile.StoreUint32(&o.PTOR.Reg, volatile.LoadUint32(&o.PTOR.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_Type) GetPTOR_PTTO16() uint32 {
	return (volatile.LoadUint32(&o.PTOR.Reg) & 0x10000) >> 16
}
func (o *GPIO_Type) SetPTOR_PTTO17(value uint32) {
	volatile.StoreUint32(&o.PTOR.Reg, volatile.LoadUint32(&o.PTOR.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_Type) GetPTOR_PTTO17() uint32 {
	return (volatile.LoadUint32(&o.PTOR.Reg) & 0x20000) >> 17
}
func (o *GPIO_Type) SetPTOR_PTTO18(value uint32) {
	volatile.StoreUint32(&o.PTOR.Reg, volatile.LoadUint32(&o.PTOR.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_Type) GetPTOR_PTTO18() uint32 {
	return (volatile.LoadUint32(&o.PTOR.Reg) & 0x40000) >> 18
}
func (o *GPIO_Type) SetPTOR_PTTO19(value uint32) {
	volatile.StoreUint32(&o.PTOR.Reg, volatile.LoadUint32(&o.PTOR.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_Type) GetPTOR_PTTO19() uint32 {
	return (volatile.LoadUint32(&o.PTOR.Reg) & 0x80000) >> 19
}
func (o *GPIO_Type) SetPTOR_PTTO20(value uint32) {
	volatile.StoreUint32(&o.PTOR.Reg, volatile.LoadUint32(&o.PTOR.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_Type) GetPTOR_PTTO20() uint32 {
	return (volatile.LoadUint32(&o.PTOR.Reg) & 0x100000) >> 20
}
func (o *GPIO_Type) SetPTOR_PTTO21(value uint32) {
	volatile.StoreUint32(&o.PTOR.Reg, volatile.LoadUint32(&o.PTOR.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_Type) GetPTOR_PTTO21() uint32 {
	return (volatile.LoadUint32(&o.PTOR.Reg) & 0x200000) >> 21
}
func (o *GPIO_Type) SetPTOR_PTTO22(value uint32) {
	volatile.StoreUint32(&o.PTOR.Reg, volatile.LoadUint32(&o.PTOR.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_Type) GetPTOR_PTTO22() uint32 {
	return (volatile.LoadUint32(&o.PTOR.Reg) & 0x400000) >> 22
}
func (o *GPIO_Type) SetPTOR_PTTO23(value uint32) {
	volatile.StoreUint32(&o.PTOR.Reg, volatile.LoadUint32(&o.PTOR.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_Type) GetPTOR_PTTO23() uint32 {
	return (volatile.LoadUint32(&o.PTOR.Reg) & 0x800000) >> 23
}
func (o *GPIO_Type) SetPTOR_PTTO24(value uint32) {
	volatile.StoreUint32(&o.PTOR.Reg, volatile.LoadUint32(&o.PTOR.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_Type) GetPTOR_PTTO24() uint32 {
	return (volatile.LoadUint32(&o.PTOR.Reg) & 0x1000000) >> 24
}
func (o *GPIO_Type) SetPTOR_PTTO25(value uint32) {
	volatile.StoreUint32(&o.PTOR.Reg, volatile.LoadUint32(&o.PTOR.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_Type) GetPTOR_PTTO25() uint32 {
	return (volatile.LoadUint32(&o.PTOR.Reg) & 0x2000000) >> 25
}
func (o *GPIO_Type) SetPTOR_PTTO26(value uint32) {
	volatile.StoreUint32(&o.PTOR.Reg, volatile.LoadUint32(&o.PTOR.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_Type) GetPTOR_PTTO26() uint32 {
	return (volatile.LoadUint32(&o.PTOR.Reg) & 0x4000000) >> 26
}
func (o *GPIO_Type) SetPTOR_PTTO27(value uint32) {
	volatile.StoreUint32(&o.PTOR.Reg, volatile.LoadUint32(&o.PTOR.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_Type) GetPTOR_PTTO27() uint32 {
	return (volatile.LoadUint32(&o.PTOR.Reg) & 0x8000000) >> 27
}
func (o *GPIO_Type) SetPTOR_PTTO28(value uint32) {
	volatile.StoreUint32(&o.PTOR.Reg, volatile.LoadUint32(&o.PTOR.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_Type) GetPTOR_PTTO28() uint32 {
	return (volatile.LoadUint32(&o.PTOR.Reg) & 0x10000000) >> 28
}
func (o *GPIO_Type) SetPTOR_PTTO29(value uint32) {
	volatile.StoreUint32(&o.PTOR.Reg, volatile.LoadUint32(&o.PTOR.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_Type) GetPTOR_PTTO29() uint32 {
	return (volatile.LoadUint32(&o.PTOR.Reg) & 0x20000000) >> 29
}
func (o *GPIO_Type) SetPTOR_PTTO30(value uint32) {
	volatile.StoreUint32(&o.PTOR.Reg, volatile.LoadUint32(&o.PTOR.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_Type) GetPTOR_PTTO30() uint32 {
	return (volatile.LoadUint32(&o.PTOR.Reg) & 0x40000000) >> 30
}
func (o *GPIO_Type) SetPTOR_PTTO31(value uint32) {
	volatile.StoreUint32(&o.PTOR.Reg, volatile.LoadUint32(&o.PTOR.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_Type) GetPTOR_PTTO31() uint32 {
	return (volatile.LoadUint32(&o.PTOR.Reg) & 0x80000000) >> 31
}

// GPIO.PDIR: Port Data Input Register
func (o *GPIO_Type) SetPDIR_PDI0(value uint32) {
	volatile.StoreUint32(&o.PDIR.Reg, volatile.LoadUint32(&o.PDIR.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetPDIR_PDI0() uint32 {
	return volatile.LoadUint32(&o.PDIR.Reg) & 0x1
}
func (o *GPIO_Type) SetPDIR_PDI1(value uint32) {
	volatile.StoreUint32(&o.PDIR.Reg, volatile.LoadUint32(&o.PDIR.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetPDIR_PDI1() uint32 {
	return (volatile.LoadUint32(&o.PDIR.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetPDIR_PDI2(value uint32) {
	volatile.StoreUint32(&o.PDIR.Reg, volatile.LoadUint32(&o.PDIR.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPDIR_PDI2() uint32 {
	return (volatile.LoadUint32(&o.PDIR.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPDIR_PDI3(value uint32) {
	volatile.StoreUint32(&o.PDIR.Reg, volatile.LoadUint32(&o.PDIR.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetPDIR_PDI3() uint32 {
	return (volatile.LoadUint32(&o.PDIR.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetPDIR_PDI4(value uint32) {
	volatile.StoreUint32(&o.PDIR.Reg, volatile.LoadUint32(&o.PDIR.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetPDIR_PDI4() uint32 {
	return (volatile.LoadUint32(&o.PDIR.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetPDIR_PDI5(value uint32) {
	volatile.StoreUint32(&o.PDIR.Reg, volatile.LoadUint32(&o.PDIR.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetPDIR_PDI5() uint32 {
	return (volatile.LoadUint32(&o.PDIR.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetPDIR_PDI6(value uint32) {
	volatile.StoreUint32(&o.PDIR.Reg, volatile.LoadUint32(&o.PDIR.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetPDIR_PDI6() uint32 {
	return (volatile.LoadUint32(&o.PDIR.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetPDIR_PDI7(value uint32) {
	volatile.StoreUint32(&o.PDIR.Reg, volatile.LoadUint32(&o.PDIR.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetPDIR_PDI7() uint32 {
	return (volatile.LoadUint32(&o.PDIR.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetPDIR_PDI8(value uint32) {
	volatile.StoreUint32(&o.PDIR.Reg, volatile.LoadUint32(&o.PDIR.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetPDIR_PDI8() uint32 {
	return (volatile.LoadUint32(&o.PDIR.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetPDIR_PDI9(value uint32) {
	volatile.StoreUint32(&o.PDIR.Reg, volatile.LoadUint32(&o.PDIR.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetPDIR_PDI9() uint32 {
	return (volatile.LoadUint32(&o.PDIR.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetPDIR_PDI10(value uint32) {
	volatile.StoreUint32(&o.PDIR.Reg, volatile.LoadUint32(&o.PDIR.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPDIR_PDI10() uint32 {
	return (volatile.LoadUint32(&o.PDIR.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPDIR_PDI11(value uint32) {
	volatile.StoreUint32(&o.PDIR.Reg, volatile.LoadUint32(&o.PDIR.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetPDIR_PDI11() uint32 {
	return (volatile.LoadUint32(&o.PDIR.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetPDIR_PDI12(value uint32) {
	volatile.StoreUint32(&o.PDIR.Reg, volatile.LoadUint32(&o.PDIR.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetPDIR_PDI12() uint32 {
	return (volatile.LoadUint32(&o.PDIR.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetPDIR_PDI13(value uint32) {
	volatile.StoreUint32(&o.PDIR.Reg, volatile.LoadUint32(&o.PDIR.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetPDIR_PDI13() uint32 {
	return (volatile.LoadUint32(&o.PDIR.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetPDIR_PDI14(value uint32) {
	volatile.StoreUint32(&o.PDIR.Reg, volatile.LoadUint32(&o.PDIR.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetPDIR_PDI14() uint32 {
	return (volatile.LoadUint32(&o.PDIR.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetPDIR_PDI15(value uint32) {
	volatile.StoreUint32(&o.PDIR.Reg, volatile.LoadUint32(&o.PDIR.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetPDIR_PDI15() uint32 {
	return (volatile.LoadUint32(&o.PDIR.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetPDIR_PDI16(value uint32) {
	volatile.StoreUint32(&o.PDIR.Reg, volatile.LoadUint32(&o.PDIR.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_Type) GetPDIR_PDI16() uint32 {
	return (volatile.LoadUint32(&o.PDIR.Reg) & 0x10000) >> 16
}
func (o *GPIO_Type) SetPDIR_PDI17(value uint32) {
	volatile.StoreUint32(&o.PDIR.Reg, volatile.LoadUint32(&o.PDIR.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_Type) GetPDIR_PDI17() uint32 {
	return (volatile.LoadUint32(&o.PDIR.Reg) & 0x20000) >> 17
}
func (o *GPIO_Type) SetPDIR_PDI18(value uint32) {
	volatile.StoreUint32(&o.PDIR.Reg, volatile.LoadUint32(&o.PDIR.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_Type) GetPDIR_PDI18() uint32 {
	return (volatile.LoadUint32(&o.PDIR.Reg) & 0x40000) >> 18
}
func (o *GPIO_Type) SetPDIR_PDI19(value uint32) {
	volatile.StoreUint32(&o.PDIR.Reg, volatile.LoadUint32(&o.PDIR.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_Type) GetPDIR_PDI19() uint32 {
	return (volatile.LoadUint32(&o.PDIR.Reg) & 0x80000) >> 19
}
func (o *GPIO_Type) SetPDIR_PDI20(value uint32) {
	volatile.StoreUint32(&o.PDIR.Reg, volatile.LoadUint32(&o.PDIR.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_Type) GetPDIR_PDI20() uint32 {
	return (volatile.LoadUint32(&o.PDIR.Reg) & 0x100000) >> 20
}
func (o *GPIO_Type) SetPDIR_PDI21(value uint32) {
	volatile.StoreUint32(&o.PDIR.Reg, volatile.LoadUint32(&o.PDIR.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_Type) GetPDIR_PDI21() uint32 {
	return (volatile.LoadUint32(&o.PDIR.Reg) & 0x200000) >> 21
}
func (o *GPIO_Type) SetPDIR_PDI22(value uint32) {
	volatile.StoreUint32(&o.PDIR.Reg, volatile.LoadUint32(&o.PDIR.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_Type) GetPDIR_PDI22() uint32 {
	return (volatile.LoadUint32(&o.PDIR.Reg) & 0x400000) >> 22
}
func (o *GPIO_Type) SetPDIR_PDI23(value uint32) {
	volatile.StoreUint32(&o.PDIR.Reg, volatile.LoadUint32(&o.PDIR.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_Type) GetPDIR_PDI23() uint32 {
	return (volatile.LoadUint32(&o.PDIR.Reg) & 0x800000) >> 23
}
func (o *GPIO_Type) SetPDIR_PDI24(value uint32) {
	volatile.StoreUint32(&o.PDIR.Reg, volatile.LoadUint32(&o.PDIR.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_Type) GetPDIR_PDI24() uint32 {
	return (volatile.LoadUint32(&o.PDIR.Reg) & 0x1000000) >> 24
}
func (o *GPIO_Type) SetPDIR_PDI25(value uint32) {
	volatile.StoreUint32(&o.PDIR.Reg, volatile.LoadUint32(&o.PDIR.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_Type) GetPDIR_PDI25() uint32 {
	return (volatile.LoadUint32(&o.PDIR.Reg) & 0x2000000) >> 25
}
func (o *GPIO_Type) SetPDIR_PDI26(value uint32) {
	volatile.StoreUint32(&o.PDIR.Reg, volatile.LoadUint32(&o.PDIR.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_Type) GetPDIR_PDI26() uint32 {
	return (volatile.LoadUint32(&o.PDIR.Reg) & 0x4000000) >> 26
}
func (o *GPIO_Type) SetPDIR_PDI27(value uint32) {
	volatile.StoreUint32(&o.PDIR.Reg, volatile.LoadUint32(&o.PDIR.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_Type) GetPDIR_PDI27() uint32 {
	return (volatile.LoadUint32(&o.PDIR.Reg) & 0x8000000) >> 27
}
func (o *GPIO_Type) SetPDIR_PDI28(value uint32) {
	volatile.StoreUint32(&o.PDIR.Reg, volatile.LoadUint32(&o.PDIR.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_Type) GetPDIR_PDI28() uint32 {
	return (volatile.LoadUint32(&o.PDIR.Reg) & 0x10000000) >> 28
}
func (o *GPIO_Type) SetPDIR_PDI29(value uint32) {
	volatile.StoreUint32(&o.PDIR.Reg, volatile.LoadUint32(&o.PDIR.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_Type) GetPDIR_PDI29() uint32 {
	return (volatile.LoadUint32(&o.PDIR.Reg) & 0x20000000) >> 29
}
func (o *GPIO_Type) SetPDIR_PDI30(value uint32) {
	volatile.StoreUint32(&o.PDIR.Reg, volatile.LoadUint32(&o.PDIR.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_Type) GetPDIR_PDI30() uint32 {
	return (volatile.LoadUint32(&o.PDIR.Reg) & 0x40000000) >> 30
}
func (o *GPIO_Type) SetPDIR_PDI31(value uint32) {
	volatile.StoreUint32(&o.PDIR.Reg, volatile.LoadUint32(&o.PDIR.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_Type) GetPDIR_PDI31() uint32 {
	return (volatile.LoadUint32(&o.PDIR.Reg) & 0x80000000) >> 31
}

// GPIO.PDDR: Port Data Direction Register
func (o *GPIO_Type) SetPDDR_PDD0(value uint32) {
	volatile.StoreUint32(&o.PDDR.Reg, volatile.LoadUint32(&o.PDDR.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetPDDR_PDD0() uint32 {
	return volatile.LoadUint32(&o.PDDR.Reg) & 0x1
}
func (o *GPIO_Type) SetPDDR_PDD1(value uint32) {
	volatile.StoreUint32(&o.PDDR.Reg, volatile.LoadUint32(&o.PDDR.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetPDDR_PDD1() uint32 {
	return (volatile.LoadUint32(&o.PDDR.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetPDDR_PDD2(value uint32) {
	volatile.StoreUint32(&o.PDDR.Reg, volatile.LoadUint32(&o.PDDR.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPDDR_PDD2() uint32 {
	return (volatile.LoadUint32(&o.PDDR.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPDDR_PDD3(value uint32) {
	volatile.StoreUint32(&o.PDDR.Reg, volatile.LoadUint32(&o.PDDR.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetPDDR_PDD3() uint32 {
	return (volatile.LoadUint32(&o.PDDR.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetPDDR_PDD4(value uint32) {
	volatile.StoreUint32(&o.PDDR.Reg, volatile.LoadUint32(&o.PDDR.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetPDDR_PDD4() uint32 {
	return (volatile.LoadUint32(&o.PDDR.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetPDDR_PDD5(value uint32) {
	volatile.StoreUint32(&o.PDDR.Reg, volatile.LoadUint32(&o.PDDR.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetPDDR_PDD5() uint32 {
	return (volatile.LoadUint32(&o.PDDR.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetPDDR_PDD6(value uint32) {
	volatile.StoreUint32(&o.PDDR.Reg, volatile.LoadUint32(&o.PDDR.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetPDDR_PDD6() uint32 {
	return (volatile.LoadUint32(&o.PDDR.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetPDDR_PDD7(value uint32) {
	volatile.StoreUint32(&o.PDDR.Reg, volatile.LoadUint32(&o.PDDR.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetPDDR_PDD7() uint32 {
	return (volatile.LoadUint32(&o.PDDR.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetPDDR_PDD8(value uint32) {
	volatile.StoreUint32(&o.PDDR.Reg, volatile.LoadUint32(&o.PDDR.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetPDDR_PDD8() uint32 {
	return (volatile.LoadUint32(&o.PDDR.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetPDDR_PDD9(value uint32) {
	volatile.StoreUint32(&o.PDDR.Reg, volatile.LoadUint32(&o.PDDR.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetPDDR_PDD9() uint32 {
	return (volatile.LoadUint32(&o.PDDR.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetPDDR_PDD10(value uint32) {
	volatile.StoreUint32(&o.PDDR.Reg, volatile.LoadUint32(&o.PDDR.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPDDR_PDD10() uint32 {
	return (volatile.LoadUint32(&o.PDDR.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPDDR_PDD11(value uint32) {
	volatile.StoreUint32(&o.PDDR.Reg, volatile.LoadUint32(&o.PDDR.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetPDDR_PDD11() uint32 {
	return (volatile.LoadUint32(&o.PDDR.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetPDDR_PDD12(value uint32) {
	volatile.StoreUint32(&o.PDDR.Reg, volatile.LoadUint32(&o.PDDR.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetPDDR_PDD12() uint32 {
	return (volatile.LoadUint32(&o.PDDR.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetPDDR_PDD13(value uint32) {
	volatile.StoreUint32(&o.PDDR.Reg, volatile.LoadUint32(&o.PDDR.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetPDDR_PDD13() uint32 {
	return (volatile.LoadUint32(&o.PDDR.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetPDDR_PDD14(value uint32) {
	volatile.StoreUint32(&o.PDDR.Reg, volatile.LoadUint32(&o.PDDR.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetPDDR_PDD14() uint32 {
	return (volatile.LoadUint32(&o.PDDR.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetPDDR_PDD15(value uint32) {
	volatile.StoreUint32(&o.PDDR.Reg, volatile.LoadUint32(&o.PDDR.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetPDDR_PDD15() uint32 {
	return (volatile.LoadUint32(&o.PDDR.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetPDDR_PDD16(value uint32) {
	volatile.StoreUint32(&o.PDDR.Reg, volatile.LoadUint32(&o.PDDR.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_Type) GetPDDR_PDD16() uint32 {
	return (volatile.LoadUint32(&o.PDDR.Reg) & 0x10000) >> 16
}
func (o *GPIO_Type) SetPDDR_PDD17(value uint32) {
	volatile.StoreUint32(&o.PDDR.Reg, volatile.LoadUint32(&o.PDDR.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_Type) GetPDDR_PDD17() uint32 {
	return (volatile.LoadUint32(&o.PDDR.Reg) & 0x20000) >> 17
}
func (o *GPIO_Type) SetPDDR_PDD18(value uint32) {
	volatile.StoreUint32(&o.PDDR.Reg, volatile.LoadUint32(&o.PDDR.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_Type) GetPDDR_PDD18() uint32 {
	return (volatile.LoadUint32(&o.PDDR.Reg) & 0x40000) >> 18
}
func (o *GPIO_Type) SetPDDR_PDD19(value uint32) {
	volatile.StoreUint32(&o.PDDR.Reg, volatile.LoadUint32(&o.PDDR.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_Type) GetPDDR_PDD19() uint32 {
	return (volatile.LoadUint32(&o.PDDR.Reg) & 0x80000) >> 19
}
func (o *GPIO_Type) SetPDDR_PDD20(value uint32) {
	volatile.StoreUint32(&o.PDDR.Reg, volatile.LoadUint32(&o.PDDR.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_Type) GetPDDR_PDD20() uint32 {
	return (volatile.LoadUint32(&o.PDDR.Reg) & 0x100000) >> 20
}
func (o *GPIO_Type) SetPDDR_PDD21(value uint32) {
	volatile.StoreUint32(&o.PDDR.Reg, volatile.LoadUint32(&o.PDDR.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_Type) GetPDDR_PDD21() uint32 {
	return (volatile.LoadUint32(&o.PDDR.Reg) & 0x200000) >> 21
}
func (o *GPIO_Type) SetPDDR_PDD22(value uint32) {
	volatile.StoreUint32(&o.PDDR.Reg, volatile.LoadUint32(&o.PDDR.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_Type) GetPDDR_PDD22() uint32 {
	return (volatile.LoadUint32(&o.PDDR.Reg) & 0x400000) >> 22
}
func (o *GPIO_Type) SetPDDR_PDD23(value uint32) {
	volatile.StoreUint32(&o.PDDR.Reg, volatile.LoadUint32(&o.PDDR.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_Type) GetPDDR_PDD23() uint32 {
	return (volatile.LoadUint32(&o.PDDR.Reg) & 0x800000) >> 23
}
func (o *GPIO_Type) SetPDDR_PDD24(value uint32) {
	volatile.StoreUint32(&o.PDDR.Reg, volatile.LoadUint32(&o.PDDR.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_Type) GetPDDR_PDD24() uint32 {
	return (volatile.LoadUint32(&o.PDDR.Reg) & 0x1000000) >> 24
}
func (o *GPIO_Type) SetPDDR_PDD25(value uint32) {
	volatile.StoreUint32(&o.PDDR.Reg, volatile.LoadUint32(&o.PDDR.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_Type) GetPDDR_PDD25() uint32 {
	return (volatile.LoadUint32(&o.PDDR.Reg) & 0x2000000) >> 25
}
func (o *GPIO_Type) SetPDDR_PDD26(value uint32) {
	volatile.StoreUint32(&o.PDDR.Reg, volatile.LoadUint32(&o.PDDR.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_Type) GetPDDR_PDD26() uint32 {
	return (volatile.LoadUint32(&o.PDDR.Reg) & 0x4000000) >> 26
}
func (o *GPIO_Type) SetPDDR_PDD27(value uint32) {
	volatile.StoreUint32(&o.PDDR.Reg, volatile.LoadUint32(&o.PDDR.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_Type) GetPDDR_PDD27() uint32 {
	return (volatile.LoadUint32(&o.PDDR.Reg) & 0x8000000) >> 27
}
func (o *GPIO_Type) SetPDDR_PDD28(value uint32) {
	volatile.StoreUint32(&o.PDDR.Reg, volatile.LoadUint32(&o.PDDR.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_Type) GetPDDR_PDD28() uint32 {
	return (volatile.LoadUint32(&o.PDDR.Reg) & 0x10000000) >> 28
}
func (o *GPIO_Type) SetPDDR_PDD29(value uint32) {
	volatile.StoreUint32(&o.PDDR.Reg, volatile.LoadUint32(&o.PDDR.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_Type) GetPDDR_PDD29() uint32 {
	return (volatile.LoadUint32(&o.PDDR.Reg) & 0x20000000) >> 29
}
func (o *GPIO_Type) SetPDDR_PDD30(value uint32) {
	volatile.StoreUint32(&o.PDDR.Reg, volatile.LoadUint32(&o.PDDR.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_Type) GetPDDR_PDD30() uint32 {
	return (volatile.LoadUint32(&o.PDDR.Reg) & 0x40000000) >> 30
}
func (o *GPIO_Type) SetPDDR_PDD31(value uint32) {
	volatile.StoreUint32(&o.PDDR.Reg, volatile.LoadUint32(&o.PDDR.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_Type) GetPDDR_PDD31() uint32 {
	return (volatile.LoadUint32(&o.PDDR.Reg) & 0x80000000) >> 31
}

// System Control Block
type SystemControl_Type struct {
	_      [8]byte
	ACTLR  volatile.Register32 // 0x8
	_      [3316]byte
	CPUID  volatile.Register32 // 0xD00
	ICSR   volatile.Register32 // 0xD04
	VTOR   volatile.Register32 // 0xD08
	AIRCR  volatile.Register32 // 0xD0C
	SCR    volatile.Register32 // 0xD10
	CCR    volatile.Register32 // 0xD14
	SHPR1  volatile.Register32 // 0xD18
	SHPR2  volatile.Register32 // 0xD1C
	SHPR3  volatile.Register32 // 0xD20
	SHCSR  volatile.Register32 // 0xD24
	CFSR   volatile.Register32 // 0xD28
	HFSR   volatile.Register32 // 0xD2C
	DFSR   volatile.Register32 // 0xD30
	MMFAR  volatile.Register32 // 0xD34
	BFAR   volatile.Register32 // 0xD38
	AFSR   volatile.Register32 // 0xD3C
	_      [72]byte
	CPACR  volatile.Register32 // 0xD88
	_      [424]byte
	FPCCR  volatile.Register32 // 0xF34
	FPCAR  volatile.Register32 // 0xF38
	FPDSCR volatile.Register32 // 0xF3C
}

// SystemControl.ACTLR: Auxiliary Control Register,
func (o *SystemControl_Type) SetACTLR_DISMCYCINT(value uint32) {
	volatile.StoreUint32(&o.ACTLR.Reg, volatile.LoadUint32(&o.ACTLR.Reg)&^(0x1)|value)
}
func (o *SystemControl_Type) GetACTLR_DISMCYCINT() uint32 {
	return volatile.LoadUint32(&o.ACTLR.Reg) & 0x1
}
func (o *SystemControl_Type) SetACTLR_DISDEFWBUF(value uint32) {
	volatile.StoreUint32(&o.ACTLR.Reg, volatile.LoadUint32(&o.ACTLR.Reg)&^(0x2)|value<<1)
}
func (o *SystemControl_Type) GetACTLR_DISDEFWBUF() uint32 {
	return (volatile.LoadUint32(&o.ACTLR.Reg) & 0x2) >> 1
}
func (o *SystemControl_Type) SetACTLR_DISFOLD(value uint32) {
	volatile.StoreUint32(&o.ACTLR.Reg, volatile.LoadUint32(&o.ACTLR.Reg)&^(0x4)|value<<2)
}
func (o *SystemControl_Type) GetACTLR_DISFOLD() uint32 {
	return (volatile.LoadUint32(&o.ACTLR.Reg) & 0x4) >> 2
}

// SystemControl.CPUID: CPUID Base Register
func (o *SystemControl_Type) SetCPUID_REVISION(value uint32) {
	volatile.StoreUint32(&o.CPUID.Reg, volatile.LoadUint32(&o.CPUID.Reg)&^(0xf)|value)
}
func (o *SystemControl_Type) GetCPUID_REVISION() uint32 {
	return volatile.LoadUint32(&o.CPUID.Reg) & 0xf
}
func (o *SystemControl_Type) SetCPUID_PARTNO(value uint32) {
	volatile.StoreUint32(&o.CPUID.Reg, volatile.LoadUint32(&o.CPUID.Reg)&^(0xfff0)|value<<4)
}
func (o *SystemControl_Type) GetCPUID_PARTNO() uint32 {
	return (volatile.LoadUint32(&o.CPUID.Reg) & 0xfff0) >> 4
}
func (o *SystemControl_Type) SetCPUID_VARIANT(value uint32) {
	volatile.StoreUint32(&o.CPUID.Reg, volatile.LoadUint32(&o.CPUID.Reg)&^(0xf00000)|value<<20)
}
func (o *SystemControl_Type) GetCPUID_VARIANT() uint32 {
	return (volatile.LoadUint32(&o.CPUID.Reg) & 0xf00000) >> 20
}
func (o *SystemControl_Type) SetCPUID_IMPLEMENTER(value uint32) {
	volatile.StoreUint32(&o.CPUID.Reg, volatile.LoadUint32(&o.CPUID.Reg)&^(0xff000000)|value<<24)
}
func (o *SystemControl_Type) GetCPUID_IMPLEMENTER() uint32 {
	return (volatile.LoadUint32(&o.CPUID.Reg) & 0xff000000) >> 24
}

// SystemControl.ICSR: Interrupt Control and State Register
func (o *SystemControl_Type) SetICSR_VECTACTIVE(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x1ff)|value)
}
func (o *SystemControl_Type) GetICSR_VECTACTIVE() uint32 {
	return volatile.LoadUint32(&o.ICSR.Reg) & 0x1ff
}
func (o *SystemControl_Type) SetICSR_RETTOBASE(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x800)|value<<11)
}
func (o *SystemControl_Type) GetICSR_RETTOBASE() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x800) >> 11
}
func (o *SystemControl_Type) SetICSR_VECTPENDING(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x3f000)|value<<12)
}
func (o *SystemControl_Type) GetICSR_VECTPENDING() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x3f000) >> 12
}
func (o *SystemControl_Type) SetICSR_ISRPENDING(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x400000)|value<<22)
}
func (o *SystemControl_Type) GetICSR_ISRPENDING() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x400000) >> 22
}
func (o *SystemControl_Type) SetICSR_ISRPREEMPT(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x800000)|value<<23)
}
func (o *SystemControl_Type) GetICSR_ISRPREEMPT() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x800000) >> 23
}
func (o *SystemControl_Type) SetICSR_PENDSTCLR(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x2000000)|value<<25)
}
func (o *SystemControl_Type) GetICSR_PENDSTCLR() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x2000000) >> 25
}
func (o *SystemControl_Type) SetICSR_PENDSTSET(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x4000000)|value<<26)
}
func (o *SystemControl_Type) GetICSR_PENDSTSET() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x4000000) >> 26
}
func (o *SystemControl_Type) SetICSR_PENDSVCLR(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x8000000)|value<<27)
}
func (o *SystemControl_Type) GetICSR_PENDSVCLR() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x8000000) >> 27
}
func (o *SystemControl_Type) SetICSR_PENDSVSET(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x10000000)|value<<28)
}
func (o *SystemControl_Type) GetICSR_PENDSVSET() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x10000000) >> 28
}
func (o *SystemControl_Type) SetICSR_NMIPENDSET(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x80000000)|value<<31)
}
func (o *SystemControl_Type) GetICSR_NMIPENDSET() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x80000000) >> 31
}

// SystemControl.VTOR: Vector Table Offset Register
func (o *SystemControl_Type) SetVTOR_TBLOFF(value uint32) {
	volatile.StoreUint32(&o.VTOR.Reg, volatile.LoadUint32(&o.VTOR.Reg)&^(0xffffff80)|value<<7)
}
func (o *SystemControl_Type) GetVTOR_TBLOFF() uint32 {
	return (volatile.LoadUint32(&o.VTOR.Reg) & 0xffffff80) >> 7
}

// SystemControl.AIRCR: Application Interrupt and Reset Control Register
func (o *SystemControl_Type) SetAIRCR_VECTRESET(value uint32) {
	volatile.StoreUint32(&o.AIRCR.Reg, volatile.LoadUint32(&o.AIRCR.Reg)&^(0x1)|value)
}
func (o *SystemControl_Type) GetAIRCR_VECTRESET() uint32 {
	return volatile.LoadUint32(&o.AIRCR.Reg) & 0x1
}
func (o *SystemControl_Type) SetAIRCR_VECTCLRACTIVE(value uint32) {
	volatile.StoreUint32(&o.AIRCR.Reg, volatile.LoadUint32(&o.AIRCR.Reg)&^(0x2)|value<<1)
}
func (o *SystemControl_Type) GetAIRCR_VECTCLRACTIVE() uint32 {
	return (volatile.LoadUint32(&o.AIRCR.Reg) & 0x2) >> 1
}
func (o *SystemControl_Type) SetAIRCR_SYSRESETREQ(value uint32) {
	volatile.StoreUint32(&o.AIRCR.Reg, volatile.LoadUint32(&o.AIRCR.Reg)&^(0x4)|value<<2)
}
func (o *SystemControl_Type) GetAIRCR_SYSRESETREQ() uint32 {
	return (volatile.LoadUint32(&o.AIRCR.Reg) & 0x4) >> 2
}
func (o *SystemControl_Type) SetAIRCR_PRIGROUP(value uint32) {
	volatile.StoreUint32(&o.AIRCR.Reg, volatile.LoadUint32(&o.AIRCR.Reg)&^(0x700)|value<<8)
}
func (o *SystemControl_Type) GetAIRCR_PRIGROUP() uint32 {
	return (volatile.LoadUint32(&o.AIRCR.Reg) & 0x700) >> 8
}
func (o *SystemControl_Type) SetAIRCR_ENDIANNESS(value uint32) {
	volatile.StoreUint32(&o.AIRCR.Reg, volatile.LoadUint32(&o.AIRCR.Reg)&^(0x8000)|value<<15)
}
func (o *SystemControl_Type) GetAIRCR_ENDIANNESS() uint32 {
	return (volatile.LoadUint32(&o.AIRCR.Reg) & 0x8000) >> 15
}
func (o *SystemControl_Type) SetAIRCR_VECTKEY(value uint32) {
	volatile.StoreUint32(&o.AIRCR.Reg, volatile.LoadUint32(&o.AIRCR.Reg)&^(0xffff0000)|value<<16)
}
func (o *SystemControl_Type) GetAIRCR_VECTKEY() uint32 {
	return (volatile.LoadUint32(&o.AIRCR.Reg) & 0xffff0000) >> 16
}

// SystemControl.SCR: System Control Register
func (o *SystemControl_Type) SetSCR_SLEEPONEXIT(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x2)|value<<1)
}
func (o *SystemControl_Type) GetSCR_SLEEPONEXIT() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x2) >> 1
}
func (o *SystemControl_Type) SetSCR_SLEEPDEEP(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x4)|value<<2)
}
func (o *SystemControl_Type) GetSCR_SLEEPDEEP() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x4) >> 2
}
func (o *SystemControl_Type) SetSCR_SEVONPEND(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x10)|value<<4)
}
func (o *SystemControl_Type) GetSCR_SEVONPEND() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x10) >> 4
}

// SystemControl.CCR: Configuration and Control Register
func (o *SystemControl_Type) SetCCR_NONBASETHRDENA(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x1)|value)
}
func (o *SystemControl_Type) GetCCR_NONBASETHRDENA() uint32 {
	return volatile.LoadUint32(&o.CCR.Reg) & 0x1
}
func (o *SystemControl_Type) SetCCR_USERSETMPEND(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x2)|value<<1)
}
func (o *SystemControl_Type) GetCCR_USERSETMPEND() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x2) >> 1
}
func (o *SystemControl_Type) SetCCR_UNALIGN_TRP(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x8)|value<<3)
}
func (o *SystemControl_Type) GetCCR_UNALIGN_TRP() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x8) >> 3
}
func (o *SystemControl_Type) SetCCR_DIV_0_TRP(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x10)|value<<4)
}
func (o *SystemControl_Type) GetCCR_DIV_0_TRP() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x10) >> 4
}
func (o *SystemControl_Type) SetCCR_BFHFNMIGN(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x100)|value<<8)
}
func (o *SystemControl_Type) GetCCR_BFHFNMIGN() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x100) >> 8
}
func (o *SystemControl_Type) SetCCR_STKALIGN(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x200)|value<<9)
}
func (o *SystemControl_Type) GetCCR_STKALIGN() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x200) >> 9
}

// SystemControl.SHPR1: System Handler Priority Register 1
func (o *SystemControl_Type) SetSHPR1_PRI_4(value uint32) {
	volatile.StoreUint32(&o.SHPR1.Reg, volatile.LoadUint32(&o.SHPR1.Reg)&^(0xff)|value)
}
func (o *SystemControl_Type) GetSHPR1_PRI_4() uint32 {
	return volatile.LoadUint32(&o.SHPR1.Reg) & 0xff
}
func (o *SystemControl_Type) SetSHPR1_PRI_5(value uint32) {
	volatile.StoreUint32(&o.SHPR1.Reg, volatile.LoadUint32(&o.SHPR1.Reg)&^(0xff00)|value<<8)
}
func (o *SystemControl_Type) GetSHPR1_PRI_5() uint32 {
	return (volatile.LoadUint32(&o.SHPR1.Reg) & 0xff00) >> 8
}
func (o *SystemControl_Type) SetSHPR1_PRI_6(value uint32) {
	volatile.StoreUint32(&o.SHPR1.Reg, volatile.LoadUint32(&o.SHPR1.Reg)&^(0xff0000)|value<<16)
}
func (o *SystemControl_Type) GetSHPR1_PRI_6() uint32 {
	return (volatile.LoadUint32(&o.SHPR1.Reg) & 0xff0000) >> 16
}

// SystemControl.SHPR2: System Handler Priority Register 2
func (o *SystemControl_Type) SetSHPR2_PRI_11(value uint32) {
	volatile.StoreUint32(&o.SHPR2.Reg, volatile.LoadUint32(&o.SHPR2.Reg)&^(0xff000000)|value<<24)
}
func (o *SystemControl_Type) GetSHPR2_PRI_11() uint32 {
	return (volatile.LoadUint32(&o.SHPR2.Reg) & 0xff000000) >> 24
}

// SystemControl.SHPR3: System Handler Priority Register 3
func (o *SystemControl_Type) SetSHPR3_PRI_14(value uint32) {
	volatile.StoreUint32(&o.SHPR3.Reg, volatile.LoadUint32(&o.SHPR3.Reg)&^(0xff0000)|value<<16)
}
func (o *SystemControl_Type) GetSHPR3_PRI_14() uint32 {
	return (volatile.LoadUint32(&o.SHPR3.Reg) & 0xff0000) >> 16
}
func (o *SystemControl_Type) SetSHPR3_PRI_15(value uint32) {
	volatile.StoreUint32(&o.SHPR3.Reg, volatile.LoadUint32(&o.SHPR3.Reg)&^(0xff000000)|value<<24)
}
func (o *SystemControl_Type) GetSHPR3_PRI_15() uint32 {
	return (volatile.LoadUint32(&o.SHPR3.Reg) & 0xff000000) >> 24
}

// SystemControl.SHCSR: System Handler Control and State Register
func (o *SystemControl_Type) SetSHCSR_MEMFAULTACT(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x1)|value)
}
func (o *SystemControl_Type) GetSHCSR_MEMFAULTACT() uint32 {
	return volatile.LoadUint32(&o.SHCSR.Reg) & 0x1
}
func (o *SystemControl_Type) SetSHCSR_BUSFAULTACT(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x2)|value<<1)
}
func (o *SystemControl_Type) GetSHCSR_BUSFAULTACT() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x2) >> 1
}
func (o *SystemControl_Type) SetSHCSR_USGFAULTACT(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x8)|value<<3)
}
func (o *SystemControl_Type) GetSHCSR_USGFAULTACT() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x8) >> 3
}
func (o *SystemControl_Type) SetSHCSR_SVCALLACT(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x80)|value<<7)
}
func (o *SystemControl_Type) GetSHCSR_SVCALLACT() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x80) >> 7
}
func (o *SystemControl_Type) SetSHCSR_MONITORACT(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x100)|value<<8)
}
func (o *SystemControl_Type) GetSHCSR_MONITORACT() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x100) >> 8
}
func (o *SystemControl_Type) SetSHCSR_PENDSVACT(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x400)|value<<10)
}
func (o *SystemControl_Type) GetSHCSR_PENDSVACT() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x400) >> 10
}
func (o *SystemControl_Type) SetSHCSR_SYSTICKACT(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x800)|value<<11)
}
func (o *SystemControl_Type) GetSHCSR_SYSTICKACT() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x800) >> 11
}
func (o *SystemControl_Type) SetSHCSR_USGFAULTPENDED(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x1000)|value<<12)
}
func (o *SystemControl_Type) GetSHCSR_USGFAULTPENDED() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x1000) >> 12
}
func (o *SystemControl_Type) SetSHCSR_MEMFAULTPENDED(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x2000)|value<<13)
}
func (o *SystemControl_Type) GetSHCSR_MEMFAULTPENDED() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x2000) >> 13
}
func (o *SystemControl_Type) SetSHCSR_BUSFAULTPENDED(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x4000)|value<<14)
}
func (o *SystemControl_Type) GetSHCSR_BUSFAULTPENDED() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x4000) >> 14
}
func (o *SystemControl_Type) SetSHCSR_SVCALLPENDED(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x8000)|value<<15)
}
func (o *SystemControl_Type) GetSHCSR_SVCALLPENDED() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x8000) >> 15
}
func (o *SystemControl_Type) SetSHCSR_MEMFAULTENA(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x10000)|value<<16)
}
func (o *SystemControl_Type) GetSHCSR_MEMFAULTENA() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x10000) >> 16
}
func (o *SystemControl_Type) SetSHCSR_BUSFAULTENA(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x20000)|value<<17)
}
func (o *SystemControl_Type) GetSHCSR_BUSFAULTENA() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x20000) >> 17
}
func (o *SystemControl_Type) SetSHCSR_USGFAULTENA(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x40000)|value<<18)
}
func (o *SystemControl_Type) GetSHCSR_USGFAULTENA() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x40000) >> 18
}

// SystemControl.CFSR: Configurable Fault Status Registers
func (o *SystemControl_Type) SetCFSR_IACCVIOL(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x1)|value)
}
func (o *SystemControl_Type) GetCFSR_IACCVIOL() uint32 {
	return volatile.LoadUint32(&o.CFSR.Reg) & 0x1
}
func (o *SystemControl_Type) SetCFSR_DACCVIOL(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x2)|value<<1)
}
func (o *SystemControl_Type) GetCFSR_DACCVIOL() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x2) >> 1
}
func (o *SystemControl_Type) SetCFSR_MUNSTKERR(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x8)|value<<3)
}
func (o *SystemControl_Type) GetCFSR_MUNSTKERR() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x8) >> 3
}
func (o *SystemControl_Type) SetCFSR_MSTKERR(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x10)|value<<4)
}
func (o *SystemControl_Type) GetCFSR_MSTKERR() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x10) >> 4
}
func (o *SystemControl_Type) SetCFSR_MLSPERR(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x20)|value<<5)
}
func (o *SystemControl_Type) GetCFSR_MLSPERR() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x20) >> 5
}
func (o *SystemControl_Type) SetCFSR_MMARVALID(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x80)|value<<7)
}
func (o *SystemControl_Type) GetCFSR_MMARVALID() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x80) >> 7
}
func (o *SystemControl_Type) SetCFSR_IBUSERR(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x100)|value<<8)
}
func (o *SystemControl_Type) GetCFSR_IBUSERR() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x100) >> 8
}
func (o *SystemControl_Type) SetCFSR_PRECISERR(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x200)|value<<9)
}
func (o *SystemControl_Type) GetCFSR_PRECISERR() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x200) >> 9
}
func (o *SystemControl_Type) SetCFSR_IMPRECISERR(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x400)|value<<10)
}
func (o *SystemControl_Type) GetCFSR_IMPRECISERR() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x400) >> 10
}
func (o *SystemControl_Type) SetCFSR_UNSTKERR(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x800)|value<<11)
}
func (o *SystemControl_Type) GetCFSR_UNSTKERR() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x800) >> 11
}
func (o *SystemControl_Type) SetCFSR_STKERR(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x1000)|value<<12)
}
func (o *SystemControl_Type) GetCFSR_STKERR() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x1000) >> 12
}
func (o *SystemControl_Type) SetCFSR_LSPERR(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x2000)|value<<13)
}
func (o *SystemControl_Type) GetCFSR_LSPERR() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x2000) >> 13
}
func (o *SystemControl_Type) SetCFSR_BFARVALID(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x8000)|value<<15)
}
func (o *SystemControl_Type) GetCFSR_BFARVALID() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x8000) >> 15
}
func (o *SystemControl_Type) SetCFSR_UNDEFINSTR(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x10000)|value<<16)
}
func (o *SystemControl_Type) GetCFSR_UNDEFINSTR() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x10000) >> 16
}
func (o *SystemControl_Type) SetCFSR_INVSTATE(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x20000)|value<<17)
}
func (o *SystemControl_Type) GetCFSR_INVSTATE() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x20000) >> 17
}
func (o *SystemControl_Type) SetCFSR_INVPC(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x40000)|value<<18)
}
func (o *SystemControl_Type) GetCFSR_INVPC() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x40000) >> 18
}
func (o *SystemControl_Type) SetCFSR_NOCP(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x80000)|value<<19)
}
func (o *SystemControl_Type) GetCFSR_NOCP() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x80000) >> 19
}
func (o *SystemControl_Type) SetCFSR_UNALIGNED(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x1000000)|value<<24)
}
func (o *SystemControl_Type) GetCFSR_UNALIGNED() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x1000000) >> 24
}
func (o *SystemControl_Type) SetCFSR_DIVBYZERO(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x2000000)|value<<25)
}
func (o *SystemControl_Type) GetCFSR_DIVBYZERO() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x2000000) >> 25
}

// SystemControl.HFSR: HardFault Status register
func (o *SystemControl_Type) SetHFSR_VECTTBL(value uint32) {
	volatile.StoreUint32(&o.HFSR.Reg, volatile.LoadUint32(&o.HFSR.Reg)&^(0x2)|value<<1)
}
func (o *SystemControl_Type) GetHFSR_VECTTBL() uint32 {
	return (volatile.LoadUint32(&o.HFSR.Reg) & 0x2) >> 1
}
func (o *SystemControl_Type) SetHFSR_FORCED(value uint32) {
	volatile.StoreUint32(&o.HFSR.Reg, volatile.LoadUint32(&o.HFSR.Reg)&^(0x40000000)|value<<30)
}
func (o *SystemControl_Type) GetHFSR_FORCED() uint32 {
	return (volatile.LoadUint32(&o.HFSR.Reg) & 0x40000000) >> 30
}
func (o *SystemControl_Type) SetHFSR_DEBUGEVT(value uint32) {
	volatile.StoreUint32(&o.HFSR.Reg, volatile.LoadUint32(&o.HFSR.Reg)&^(0x80000000)|value<<31)
}
func (o *SystemControl_Type) GetHFSR_DEBUGEVT() uint32 {
	return (volatile.LoadUint32(&o.HFSR.Reg) & 0x80000000) >> 31
}

// SystemControl.DFSR: Debug Fault Status Register
func (o *SystemControl_Type) SetDFSR_HALTED(value uint32) {
	volatile.StoreUint32(&o.DFSR.Reg, volatile.LoadUint32(&o.DFSR.Reg)&^(0x1)|value)
}
func (o *SystemControl_Type) GetDFSR_HALTED() uint32 {
	return volatile.LoadUint32(&o.DFSR.Reg) & 0x1
}
func (o *SystemControl_Type) SetDFSR_BKPT(value uint32) {
	volatile.StoreUint32(&o.DFSR.Reg, volatile.LoadUint32(&o.DFSR.Reg)&^(0x2)|value<<1)
}
func (o *SystemControl_Type) GetDFSR_BKPT() uint32 {
	return (volatile.LoadUint32(&o.DFSR.Reg) & 0x2) >> 1
}
func (o *SystemControl_Type) SetDFSR_DWTTRAP(value uint32) {
	volatile.StoreUint32(&o.DFSR.Reg, volatile.LoadUint32(&o.DFSR.Reg)&^(0x4)|value<<2)
}
func (o *SystemControl_Type) GetDFSR_DWTTRAP() uint32 {
	return (volatile.LoadUint32(&o.DFSR.Reg) & 0x4) >> 2
}
func (o *SystemControl_Type) SetDFSR_VCATCH(value uint32) {
	volatile.StoreUint32(&o.DFSR.Reg, volatile.LoadUint32(&o.DFSR.Reg)&^(0x8)|value<<3)
}
func (o *SystemControl_Type) GetDFSR_VCATCH() uint32 {
	return (volatile.LoadUint32(&o.DFSR.Reg) & 0x8) >> 3
}
func (o *SystemControl_Type) SetDFSR_EXTERNAL(value uint32) {
	volatile.StoreUint32(&o.DFSR.Reg, volatile.LoadUint32(&o.DFSR.Reg)&^(0x10)|value<<4)
}
func (o *SystemControl_Type) GetDFSR_EXTERNAL() uint32 {
	return (volatile.LoadUint32(&o.DFSR.Reg) & 0x10) >> 4
}

// SystemControl.MMFAR: MemManage Address Register
func (o *SystemControl_Type) SetMMFAR(value uint32) {
	volatile.StoreUint32(&o.MMFAR.Reg, value)
}
func (o *SystemControl_Type) GetMMFAR() uint32 {
	return volatile.LoadUint32(&o.MMFAR.Reg)
}

// SystemControl.BFAR: BusFault Address Register
func (o *SystemControl_Type) SetBFAR(value uint32) {
	volatile.StoreUint32(&o.BFAR.Reg, value)
}
func (o *SystemControl_Type) GetBFAR() uint32 {
	return volatile.LoadUint32(&o.BFAR.Reg)
}

// SystemControl.AFSR: Auxiliary Fault Status Register
func (o *SystemControl_Type) SetAFSR(value uint32) {
	volatile.StoreUint32(&o.AFSR.Reg, value)
}
func (o *SystemControl_Type) GetAFSR() uint32 {
	return volatile.LoadUint32(&o.AFSR.Reg)
}

// SystemControl.CPACR: Coprocessor Access Control Register
func (o *SystemControl_Type) SetCPACR_CP10(value uint32) {
	volatile.StoreUint32(&o.CPACR.Reg, volatile.LoadUint32(&o.CPACR.Reg)&^(0x300000)|value<<20)
}
func (o *SystemControl_Type) GetCPACR_CP10() uint32 {
	return (volatile.LoadUint32(&o.CPACR.Reg) & 0x300000) >> 20
}
func (o *SystemControl_Type) SetCPACR_CP11(value uint32) {
	volatile.StoreUint32(&o.CPACR.Reg, volatile.LoadUint32(&o.CPACR.Reg)&^(0xc00000)|value<<22)
}
func (o *SystemControl_Type) GetCPACR_CP11() uint32 {
	return (volatile.LoadUint32(&o.CPACR.Reg) & 0xc00000) >> 22
}

// SystemControl.FPCCR: Floating-point Context Control Register
func (o *SystemControl_Type) SetFPCCR_LSPACT(value uint32) {
	volatile.StoreUint32(&o.FPCCR.Reg, volatile.LoadUint32(&o.FPCCR.Reg)&^(0x1)|value)
}
func (o *SystemControl_Type) GetFPCCR_LSPACT() uint32 {
	return volatile.LoadUint32(&o.FPCCR.Reg) & 0x1
}
func (o *SystemControl_Type) SetFPCCR_USER(value uint32) {
	volatile.StoreUint32(&o.FPCCR.Reg, volatile.LoadUint32(&o.FPCCR.Reg)&^(0x2)|value<<1)
}
func (o *SystemControl_Type) GetFPCCR_USER() uint32 {
	return (volatile.LoadUint32(&o.FPCCR.Reg) & 0x2) >> 1
}
func (o *SystemControl_Type) SetFPCCR_THREAD(value uint32) {
	volatile.StoreUint32(&o.FPCCR.Reg, volatile.LoadUint32(&o.FPCCR.Reg)&^(0x8)|value<<3)
}
func (o *SystemControl_Type) GetFPCCR_THREAD() uint32 {
	return (volatile.LoadUint32(&o.FPCCR.Reg) & 0x8) >> 3
}
func (o *SystemControl_Type) SetFPCCR_HFRDY(value uint32) {
	volatile.StoreUint32(&o.FPCCR.Reg, volatile.LoadUint32(&o.FPCCR.Reg)&^(0x10)|value<<4)
}
func (o *SystemControl_Type) GetFPCCR_HFRDY() uint32 {
	return (volatile.LoadUint32(&o.FPCCR.Reg) & 0x10) >> 4
}
func (o *SystemControl_Type) SetFPCCR_MMRDY(value uint32) {
	volatile.StoreUint32(&o.FPCCR.Reg, volatile.LoadUint32(&o.FPCCR.Reg)&^(0x20)|value<<5)
}
func (o *SystemControl_Type) GetFPCCR_MMRDY() uint32 {
	return (volatile.LoadUint32(&o.FPCCR.Reg) & 0x20) >> 5
}
func (o *SystemControl_Type) SetFPCCR_BFRDY(value uint32) {
	volatile.StoreUint32(&o.FPCCR.Reg, volatile.LoadUint32(&o.FPCCR.Reg)&^(0x40)|value<<6)
}
func (o *SystemControl_Type) GetFPCCR_BFRDY() uint32 {
	return (volatile.LoadUint32(&o.FPCCR.Reg) & 0x40) >> 6
}
func (o *SystemControl_Type) SetFPCCR_MONRDY(value uint32) {
	volatile.StoreUint32(&o.FPCCR.Reg, volatile.LoadUint32(&o.FPCCR.Reg)&^(0x100)|value<<8)
}
func (o *SystemControl_Type) GetFPCCR_MONRDY() uint32 {
	return (volatile.LoadUint32(&o.FPCCR.Reg) & 0x100) >> 8
}
func (o *SystemControl_Type) SetFPCCR_LSPEN(value uint32) {
	volatile.StoreUint32(&o.FPCCR.Reg, volatile.LoadUint32(&o.FPCCR.Reg)&^(0x40000000)|value<<30)
}
func (o *SystemControl_Type) GetFPCCR_LSPEN() uint32 {
	return (volatile.LoadUint32(&o.FPCCR.Reg) & 0x40000000) >> 30
}
func (o *SystemControl_Type) SetFPCCR_ASPEN(value uint32) {
	volatile.StoreUint32(&o.FPCCR.Reg, volatile.LoadUint32(&o.FPCCR.Reg)&^(0x80000000)|value<<31)
}
func (o *SystemControl_Type) GetFPCCR_ASPEN() uint32 {
	return (volatile.LoadUint32(&o.FPCCR.Reg) & 0x80000000) >> 31
}

// SystemControl.FPCAR: Floating-point Context Address Register
func (o *SystemControl_Type) SetFPCAR_ADDRESS(value uint32) {
	volatile.StoreUint32(&o.FPCAR.Reg, volatile.LoadUint32(&o.FPCAR.Reg)&^(0xfffffff8)|value<<3)
}
func (o *SystemControl_Type) GetFPCAR_ADDRESS() uint32 {
	return (volatile.LoadUint32(&o.FPCAR.Reg) & 0xfffffff8) >> 3
}

// SystemControl.FPDSCR: Floating-point Default Status Control Register
func (o *SystemControl_Type) SetFPDSCR_RMode(value uint32) {
	volatile.StoreUint32(&o.FPDSCR.Reg, volatile.LoadUint32(&o.FPDSCR.Reg)&^(0xc00000)|value<<22)
}
func (o *SystemControl_Type) GetFPDSCR_RMode() uint32 {
	return (volatile.LoadUint32(&o.FPDSCR.Reg) & 0xc00000) >> 22
}
func (o *SystemControl_Type) SetFPDSCR_FZ(value uint32) {
	volatile.StoreUint32(&o.FPDSCR.Reg, volatile.LoadUint32(&o.FPDSCR.Reg)&^(0x1000000)|value<<24)
}
func (o *SystemControl_Type) GetFPDSCR_FZ() uint32 {
	return (volatile.LoadUint32(&o.FPDSCR.Reg) & 0x1000000) >> 24
}
func (o *SystemControl_Type) SetFPDSCR_DN(value uint32) {
	volatile.StoreUint32(&o.FPDSCR.Reg, volatile.LoadUint32(&o.FPDSCR.Reg)&^(0x2000000)|value<<25)
}
func (o *SystemControl_Type) GetFPDSCR_DN() uint32 {
	return (volatile.LoadUint32(&o.FPDSCR.Reg) & 0x2000000) >> 25
}
func (o *SystemControl_Type) SetFPDSCR_AHP(value uint32) {
	volatile.StoreUint32(&o.FPDSCR.Reg, volatile.LoadUint32(&o.FPDSCR.Reg)&^(0x4000000)|value<<26)
}
func (o *SystemControl_Type) GetFPDSCR_AHP() uint32 {
	return (volatile.LoadUint32(&o.FPDSCR.Reg) & 0x4000000) >> 26
}

// System timer
type SysTick_Type struct {
	CSR   volatile.Register32 // 0x0
	RVR   volatile.Register32 // 0x4
	CVR   volatile.Register32 // 0x8
	CALIB volatile.Register32 // 0xC
}

// SysTick.CSR: SysTick Control and Status Register
func (o *SysTick_Type) SetCSR_ENABLE(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x1)|value)
}
func (o *SysTick_Type) GetCSR_ENABLE() uint32 {
	return volatile.LoadUint32(&o.CSR.Reg) & 0x1
}
func (o *SysTick_Type) SetCSR_TICKINT(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x2)|value<<1)
}
func (o *SysTick_Type) GetCSR_TICKINT() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x2) >> 1
}
func (o *SysTick_Type) SetCSR_CLKSOURCE(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x4)|value<<2)
}
func (o *SysTick_Type) GetCSR_CLKSOURCE() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x4) >> 2
}
func (o *SysTick_Type) SetCSR_COUNTFLAG(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x10000)|value<<16)
}
func (o *SysTick_Type) GetCSR_COUNTFLAG() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x10000) >> 16
}

// SysTick.RVR: SysTick Reload Value Register
func (o *SysTick_Type) SetRVR_RELOAD(value uint32) {
	volatile.StoreUint32(&o.RVR.Reg, volatile.LoadUint32(&o.RVR.Reg)&^(0xffffff)|value)
}
func (o *SysTick_Type) GetRVR_RELOAD() uint32 {
	return volatile.LoadUint32(&o.RVR.Reg) & 0xffffff
}

// SysTick.CVR: SysTick Current Value Register
func (o *SysTick_Type) SetCVR_CURRENT(value uint32) {
	volatile.StoreUint32(&o.CVR.Reg, volatile.LoadUint32(&o.CVR.Reg)&^(0xffffff)|value)
}
func (o *SysTick_Type) GetCVR_CURRENT() uint32 {
	return volatile.LoadUint32(&o.CVR.Reg) & 0xffffff
}

// SysTick.CALIB: SysTick Calibration Value Register
func (o *SysTick_Type) SetCALIB_TENMS(value uint32) {
	volatile.StoreUint32(&o.CALIB.Reg, volatile.LoadUint32(&o.CALIB.Reg)&^(0xffffff)|value)
}
func (o *SysTick_Type) GetCALIB_TENMS() uint32 {
	return volatile.LoadUint32(&o.CALIB.Reg) & 0xffffff
}
func (o *SysTick_Type) SetCALIB_SKEW(value uint32) {
	volatile.StoreUint32(&o.CALIB.Reg, volatile.LoadUint32(&o.CALIB.Reg)&^(0x40000000)|value<<30)
}
func (o *SysTick_Type) GetCALIB_SKEW() uint32 {
	return (volatile.LoadUint32(&o.CALIB.Reg) & 0x40000000) >> 30
}
func (o *SysTick_Type) SetCALIB_NOREF(value uint32) {
	volatile.StoreUint32(&o.CALIB.Reg, volatile.LoadUint32(&o.CALIB.Reg)&^(0x80000000)|value<<31)
}
func (o *SysTick_Type) GetCALIB_NOREF() uint32 {
	return (volatile.LoadUint32(&o.CALIB.Reg) & 0x80000000) >> 31
}

// Nested Vectored Interrupt Controller
type NVIC_Type struct {
	NVICISER0 volatile.Register32 // 0x0
	NVICISER1 volatile.Register32 // 0x4
	NVICISER2 volatile.Register32 // 0x8
	NVICISER3 volatile.Register32 // 0xC
	_         [112]byte
	NVICICER0 volatile.Register32 // 0x80
	NVICICER1 volatile.Register32 // 0x84
	NVICICER2 volatile.Register32 // 0x88
	NVICICER3 volatile.Register32 // 0x8C
	_         [112]byte
	NVICISPR0 volatile.Register32 // 0x100
	NVICISPR1 volatile.Register32 // 0x104
	NVICISPR2 volatile.Register32 // 0x108
	NVICISPR3 volatile.Register32 // 0x10C
	_         [112]byte
	NVICICPR0 volatile.Register32 // 0x180
	NVICICPR1 volatile.Register32 // 0x184
	NVICICPR2 volatile.Register32 // 0x188
	NVICICPR3 volatile.Register32 // 0x18C
	_         [112]byte
	NVICIABR0 volatile.Register32 // 0x200
	NVICIABR1 volatile.Register32 // 0x204
	NVICIABR2 volatile.Register32 // 0x208
	NVICIABR3 volatile.Register32 // 0x20C
	_         [240]byte
	NVICIP0   volatile.Register8 // 0x300
	NVICIP1   volatile.Register8 // 0x301
	NVICIP2   volatile.Register8 // 0x302
	NVICIP3   volatile.Register8 // 0x303
	NVICIP4   volatile.Register8 // 0x304
	NVICIP5   volatile.Register8 // 0x305
	NVICIP6   volatile.Register8 // 0x306
	NVICIP7   volatile.Register8 // 0x307
	NVICIP8   volatile.Register8 // 0x308
	NVICIP9   volatile.Register8 // 0x309
	NVICIP10  volatile.Register8 // 0x30A
	NVICIP11  volatile.Register8 // 0x30B
	NVICIP12  volatile.Register8 // 0x30C
	NVICIP13  volatile.Register8 // 0x30D
	NVICIP14  volatile.Register8 // 0x30E
	NVICIP15  volatile.Register8 // 0x30F
	NVICIP16  volatile.Register8 // 0x310
	NVICIP17  volatile.Register8 // 0x311
	NVICIP18  volatile.Register8 // 0x312
	NVICIP19  volatile.Register8 // 0x313
	NVICIP20  volatile.Register8 // 0x314
	NVICIP21  volatile.Register8 // 0x315
	NVICIP22  volatile.Register8 // 0x316
	NVICIP23  volatile.Register8 // 0x317
	NVICIP24  volatile.Register8 // 0x318
	NVICIP25  volatile.Register8 // 0x319
	NVICIP26  volatile.Register8 // 0x31A
	NVICIP27  volatile.Register8 // 0x31B
	NVICIP28  volatile.Register8 // 0x31C
	NVICIP29  volatile.Register8 // 0x31D
	NVICIP30  volatile.Register8 // 0x31E
	NVICIP31  volatile.Register8 // 0x31F
	NVICIP32  volatile.Register8 // 0x320
	NVICIP33  volatile.Register8 // 0x321
	NVICIP34  volatile.Register8 // 0x322
	NVICIP35  volatile.Register8 // 0x323
	NVICIP36  volatile.Register8 // 0x324
	NVICIP37  volatile.Register8 // 0x325
	NVICIP38  volatile.Register8 // 0x326
	NVICIP39  volatile.Register8 // 0x327
	NVICIP40  volatile.Register8 // 0x328
	NVICIP41  volatile.Register8 // 0x329
	NVICIP42  volatile.Register8 // 0x32A
	NVICIP43  volatile.Register8 // 0x32B
	NVICIP44  volatile.Register8 // 0x32C
	NVICIP45  volatile.Register8 // 0x32D
	NVICIP46  volatile.Register8 // 0x32E
	NVICIP47  volatile.Register8 // 0x32F
	NVICIP48  volatile.Register8 // 0x330
	NVICIP49  volatile.Register8 // 0x331
	NVICIP50  volatile.Register8 // 0x332
	NVICIP51  volatile.Register8 // 0x333
	NVICIP52  volatile.Register8 // 0x334
	NVICIP53  volatile.Register8 // 0x335
	NVICIP54  volatile.Register8 // 0x336
	NVICIP55  volatile.Register8 // 0x337
	NVICIP56  volatile.Register8 // 0x338
	NVICIP57  volatile.Register8 // 0x339
	NVICIP58  volatile.Register8 // 0x33A
	NVICIP59  volatile.Register8 // 0x33B
	NVICIP60  volatile.Register8 // 0x33C
	NVICIP61  volatile.Register8 // 0x33D
	NVICIP62  volatile.Register8 // 0x33E
	NVICIP63  volatile.Register8 // 0x33F
	NVICIP64  volatile.Register8 // 0x340
	NVICIP65  volatile.Register8 // 0x341
	NVICIP66  volatile.Register8 // 0x342
	NVICIP67  volatile.Register8 // 0x343
	NVICIP68  volatile.Register8 // 0x344
	NVICIP69  volatile.Register8 // 0x345
	NVICIP70  volatile.Register8 // 0x346
	NVICIP71  volatile.Register8 // 0x347
	NVICIP72  volatile.Register8 // 0x348
	NVICIP73  volatile.Register8 // 0x349
	NVICIP74  volatile.Register8 // 0x34A
	NVICIP75  volatile.Register8 // 0x34B
	NVICIP76  volatile.Register8 // 0x34C
	NVICIP77  volatile.Register8 // 0x34D
	NVICIP78  volatile.Register8 // 0x34E
	NVICIP79  volatile.Register8 // 0x34F
	NVICIP80  volatile.Register8 // 0x350
	NVICIP81  volatile.Register8 // 0x351
	NVICIP82  volatile.Register8 // 0x352
	NVICIP83  volatile.Register8 // 0x353
	NVICIP84  volatile.Register8 // 0x354
	NVICIP85  volatile.Register8 // 0x355
	NVICIP86  volatile.Register8 // 0x356
	NVICIP87  volatile.Register8 // 0x357
	NVICIP88  volatile.Register8 // 0x358
	NVICIP89  volatile.Register8 // 0x359
	NVICIP90  volatile.Register8 // 0x35A
	NVICIP91  volatile.Register8 // 0x35B
	NVICIP92  volatile.Register8 // 0x35C
	NVICIP93  volatile.Register8 // 0x35D
	NVICIP94  volatile.Register8 // 0x35E
	NVICIP95  volatile.Register8 // 0x35F
	NVICIP96  volatile.Register8 // 0x360
	NVICIP97  volatile.Register8 // 0x361
	NVICIP98  volatile.Register8 // 0x362
	NVICIP99  volatile.Register8 // 0x363
	NVICIP100 volatile.Register8 // 0x364
	NVICIP101 volatile.Register8 // 0x365
	NVICIP102 volatile.Register8 // 0x366
	NVICIP103 volatile.Register8 // 0x367
	NVICIP104 volatile.Register8 // 0x368
	NVICIP105 volatile.Register8 // 0x369
	_         [2710]byte
	NVICSTIR  volatile.Register32 // 0xE00
}

// NVIC.NVICISER0: Interrupt Set Enable Register n
func (o *NVIC_Type) SetNVICISER0(value uint32) {
	volatile.StoreUint32(&o.NVICISER0.Reg, value)
}
func (o *NVIC_Type) GetNVICISER0() uint32 {
	return volatile.LoadUint32(&o.NVICISER0.Reg)
}

// NVIC.NVICISER1: Interrupt Set Enable Register n
func (o *NVIC_Type) SetNVICISER1(value uint32) {
	volatile.StoreUint32(&o.NVICISER1.Reg, value)
}
func (o *NVIC_Type) GetNVICISER1() uint32 {
	return volatile.LoadUint32(&o.NVICISER1.Reg)
}

// NVIC.NVICISER2: Interrupt Set Enable Register n
func (o *NVIC_Type) SetNVICISER2(value uint32) {
	volatile.StoreUint32(&o.NVICISER2.Reg, value)
}
func (o *NVIC_Type) GetNVICISER2() uint32 {
	return volatile.LoadUint32(&o.NVICISER2.Reg)
}

// NVIC.NVICISER3: Interrupt Set Enable Register n
func (o *NVIC_Type) SetNVICISER3(value uint32) {
	volatile.StoreUint32(&o.NVICISER3.Reg, value)
}
func (o *NVIC_Type) GetNVICISER3() uint32 {
	return volatile.LoadUint32(&o.NVICISER3.Reg)
}

// NVIC.NVICICER0: Interrupt Clear Enable Register n
func (o *NVIC_Type) SetNVICICER0(value uint32) {
	volatile.StoreUint32(&o.NVICICER0.Reg, value)
}
func (o *NVIC_Type) GetNVICICER0() uint32 {
	return volatile.LoadUint32(&o.NVICICER0.Reg)
}

// NVIC.NVICICER1: Interrupt Clear Enable Register n
func (o *NVIC_Type) SetNVICICER1(value uint32) {
	volatile.StoreUint32(&o.NVICICER1.Reg, value)
}
func (o *NVIC_Type) GetNVICICER1() uint32 {
	return volatile.LoadUint32(&o.NVICICER1.Reg)
}

// NVIC.NVICICER2: Interrupt Clear Enable Register n
func (o *NVIC_Type) SetNVICICER2(value uint32) {
	volatile.StoreUint32(&o.NVICICER2.Reg, value)
}
func (o *NVIC_Type) GetNVICICER2() uint32 {
	return volatile.LoadUint32(&o.NVICICER2.Reg)
}

// NVIC.NVICICER3: Interrupt Clear Enable Register n
func (o *NVIC_Type) SetNVICICER3(value uint32) {
	volatile.StoreUint32(&o.NVICICER3.Reg, value)
}
func (o *NVIC_Type) GetNVICICER3() uint32 {
	return volatile.LoadUint32(&o.NVICICER3.Reg)
}

// NVIC.NVICISPR0: Interrupt Set Pending Register n
func (o *NVIC_Type) SetNVICISPR0(value uint32) {
	volatile.StoreUint32(&o.NVICISPR0.Reg, value)
}
func (o *NVIC_Type) GetNVICISPR0() uint32 {
	return volatile.LoadUint32(&o.NVICISPR0.Reg)
}

// NVIC.NVICISPR1: Interrupt Set Pending Register n
func (o *NVIC_Type) SetNVICISPR1(value uint32) {
	volatile.StoreUint32(&o.NVICISPR1.Reg, value)
}
func (o *NVIC_Type) GetNVICISPR1() uint32 {
	return volatile.LoadUint32(&o.NVICISPR1.Reg)
}

// NVIC.NVICISPR2: Interrupt Set Pending Register n
func (o *NVIC_Type) SetNVICISPR2(value uint32) {
	volatile.StoreUint32(&o.NVICISPR2.Reg, value)
}
func (o *NVIC_Type) GetNVICISPR2() uint32 {
	return volatile.LoadUint32(&o.NVICISPR2.Reg)
}

// NVIC.NVICISPR3: Interrupt Set Pending Register n
func (o *NVIC_Type) SetNVICISPR3(value uint32) {
	volatile.StoreUint32(&o.NVICISPR3.Reg, value)
}
func (o *NVIC_Type) GetNVICISPR3() uint32 {
	return volatile.LoadUint32(&o.NVICISPR3.Reg)
}

// NVIC.NVICICPR0: Interrupt Clear Pending Register n
func (o *NVIC_Type) SetNVICICPR0(value uint32) {
	volatile.StoreUint32(&o.NVICICPR0.Reg, value)
}
func (o *NVIC_Type) GetNVICICPR0() uint32 {
	return volatile.LoadUint32(&o.NVICICPR0.Reg)
}

// NVIC.NVICICPR1: Interrupt Clear Pending Register n
func (o *NVIC_Type) SetNVICICPR1(value uint32) {
	volatile.StoreUint32(&o.NVICICPR1.Reg, value)
}
func (o *NVIC_Type) GetNVICICPR1() uint32 {
	return volatile.LoadUint32(&o.NVICICPR1.Reg)
}

// NVIC.NVICICPR2: Interrupt Clear Pending Register n
func (o *NVIC_Type) SetNVICICPR2(value uint32) {
	volatile.StoreUint32(&o.NVICICPR2.Reg, value)
}
func (o *NVIC_Type) GetNVICICPR2() uint32 {
	return volatile.LoadUint32(&o.NVICICPR2.Reg)
}

// NVIC.NVICICPR3: Interrupt Clear Pending Register n
func (o *NVIC_Type) SetNVICICPR3(value uint32) {
	volatile.StoreUint32(&o.NVICICPR3.Reg, value)
}
func (o *NVIC_Type) GetNVICICPR3() uint32 {
	return volatile.LoadUint32(&o.NVICICPR3.Reg)
}

// NVIC.NVICIABR0: Interrupt Active bit Register n
func (o *NVIC_Type) SetNVICIABR0(value uint32) {
	volatile.StoreUint32(&o.NVICIABR0.Reg, value)
}
func (o *NVIC_Type) GetNVICIABR0() uint32 {
	return volatile.LoadUint32(&o.NVICIABR0.Reg)
}

// NVIC.NVICIABR1: Interrupt Active bit Register n
func (o *NVIC_Type) SetNVICIABR1(value uint32) {
	volatile.StoreUint32(&o.NVICIABR1.Reg, value)
}
func (o *NVIC_Type) GetNVICIABR1() uint32 {
	return volatile.LoadUint32(&o.NVICIABR1.Reg)
}

// NVIC.NVICIABR2: Interrupt Active bit Register n
func (o *NVIC_Type) SetNVICIABR2(value uint32) {
	volatile.StoreUint32(&o.NVICIABR2.Reg, value)
}
func (o *NVIC_Type) GetNVICIABR2() uint32 {
	return volatile.LoadUint32(&o.NVICIABR2.Reg)
}

// NVIC.NVICIABR3: Interrupt Active bit Register n
func (o *NVIC_Type) SetNVICIABR3(value uint32) {
	volatile.StoreUint32(&o.NVICIABR3.Reg, value)
}
func (o *NVIC_Type) GetNVICIABR3() uint32 {
	return volatile.LoadUint32(&o.NVICIABR3.Reg)
}

// NVIC.NVICIP0: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP0(value uint8) {
	volatile.StoreUint8(&o.NVICIP0.Reg, value)
}
func (o *NVIC_Type) GetNVICIP0() uint8 {
	return volatile.LoadUint8(&o.NVICIP0.Reg)
}

// NVIC.NVICIP1: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP1(value uint8) {
	volatile.StoreUint8(&o.NVICIP1.Reg, value)
}
func (o *NVIC_Type) GetNVICIP1() uint8 {
	return volatile.LoadUint8(&o.NVICIP1.Reg)
}

// NVIC.NVICIP2: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP2(value uint8) {
	volatile.StoreUint8(&o.NVICIP2.Reg, value)
}
func (o *NVIC_Type) GetNVICIP2() uint8 {
	return volatile.LoadUint8(&o.NVICIP2.Reg)
}

// NVIC.NVICIP3: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP3(value uint8) {
	volatile.StoreUint8(&o.NVICIP3.Reg, value)
}
func (o *NVIC_Type) GetNVICIP3() uint8 {
	return volatile.LoadUint8(&o.NVICIP3.Reg)
}

// NVIC.NVICIP4: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP4(value uint8) {
	volatile.StoreUint8(&o.NVICIP4.Reg, value)
}
func (o *NVIC_Type) GetNVICIP4() uint8 {
	return volatile.LoadUint8(&o.NVICIP4.Reg)
}

// NVIC.NVICIP5: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP5(value uint8) {
	volatile.StoreUint8(&o.NVICIP5.Reg, value)
}
func (o *NVIC_Type) GetNVICIP5() uint8 {
	return volatile.LoadUint8(&o.NVICIP5.Reg)
}

// NVIC.NVICIP6: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP6(value uint8) {
	volatile.StoreUint8(&o.NVICIP6.Reg, value)
}
func (o *NVIC_Type) GetNVICIP6() uint8 {
	return volatile.LoadUint8(&o.NVICIP6.Reg)
}

// NVIC.NVICIP7: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP7(value uint8) {
	volatile.StoreUint8(&o.NVICIP7.Reg, value)
}
func (o *NVIC_Type) GetNVICIP7() uint8 {
	return volatile.LoadUint8(&o.NVICIP7.Reg)
}

// NVIC.NVICIP8: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP8(value uint8) {
	volatile.StoreUint8(&o.NVICIP8.Reg, value)
}
func (o *NVIC_Type) GetNVICIP8() uint8 {
	return volatile.LoadUint8(&o.NVICIP8.Reg)
}

// NVIC.NVICIP9: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP9(value uint8) {
	volatile.StoreUint8(&o.NVICIP9.Reg, value)
}
func (o *NVIC_Type) GetNVICIP9() uint8 {
	return volatile.LoadUint8(&o.NVICIP9.Reg)
}

// NVIC.NVICIP10: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP10(value uint8) {
	volatile.StoreUint8(&o.NVICIP10.Reg, value)
}
func (o *NVIC_Type) GetNVICIP10() uint8 {
	return volatile.LoadUint8(&o.NVICIP10.Reg)
}

// NVIC.NVICIP11: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP11(value uint8) {
	volatile.StoreUint8(&o.NVICIP11.Reg, value)
}
func (o *NVIC_Type) GetNVICIP11() uint8 {
	return volatile.LoadUint8(&o.NVICIP11.Reg)
}

// NVIC.NVICIP12: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP12(value uint8) {
	volatile.StoreUint8(&o.NVICIP12.Reg, value)
}
func (o *NVIC_Type) GetNVICIP12() uint8 {
	return volatile.LoadUint8(&o.NVICIP12.Reg)
}

// NVIC.NVICIP13: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP13(value uint8) {
	volatile.StoreUint8(&o.NVICIP13.Reg, value)
}
func (o *NVIC_Type) GetNVICIP13() uint8 {
	return volatile.LoadUint8(&o.NVICIP13.Reg)
}

// NVIC.NVICIP14: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP14(value uint8) {
	volatile.StoreUint8(&o.NVICIP14.Reg, value)
}
func (o *NVIC_Type) GetNVICIP14() uint8 {
	return volatile.LoadUint8(&o.NVICIP14.Reg)
}

// NVIC.NVICIP15: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP15(value uint8) {
	volatile.StoreUint8(&o.NVICIP15.Reg, value)
}
func (o *NVIC_Type) GetNVICIP15() uint8 {
	return volatile.LoadUint8(&o.NVICIP15.Reg)
}

// NVIC.NVICIP16: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP16(value uint8) {
	volatile.StoreUint8(&o.NVICIP16.Reg, value)
}
func (o *NVIC_Type) GetNVICIP16() uint8 {
	return volatile.LoadUint8(&o.NVICIP16.Reg)
}

// NVIC.NVICIP17: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP17(value uint8) {
	volatile.StoreUint8(&o.NVICIP17.Reg, value)
}
func (o *NVIC_Type) GetNVICIP17() uint8 {
	return volatile.LoadUint8(&o.NVICIP17.Reg)
}

// NVIC.NVICIP18: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP18(value uint8) {
	volatile.StoreUint8(&o.NVICIP18.Reg, value)
}
func (o *NVIC_Type) GetNVICIP18() uint8 {
	return volatile.LoadUint8(&o.NVICIP18.Reg)
}

// NVIC.NVICIP19: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP19(value uint8) {
	volatile.StoreUint8(&o.NVICIP19.Reg, value)
}
func (o *NVIC_Type) GetNVICIP19() uint8 {
	return volatile.LoadUint8(&o.NVICIP19.Reg)
}

// NVIC.NVICIP20: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP20(value uint8) {
	volatile.StoreUint8(&o.NVICIP20.Reg, value)
}
func (o *NVIC_Type) GetNVICIP20() uint8 {
	return volatile.LoadUint8(&o.NVICIP20.Reg)
}

// NVIC.NVICIP21: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP21(value uint8) {
	volatile.StoreUint8(&o.NVICIP21.Reg, value)
}
func (o *NVIC_Type) GetNVICIP21() uint8 {
	return volatile.LoadUint8(&o.NVICIP21.Reg)
}

// NVIC.NVICIP22: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP22(value uint8) {
	volatile.StoreUint8(&o.NVICIP22.Reg, value)
}
func (o *NVIC_Type) GetNVICIP22() uint8 {
	return volatile.LoadUint8(&o.NVICIP22.Reg)
}

// NVIC.NVICIP23: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP23(value uint8) {
	volatile.StoreUint8(&o.NVICIP23.Reg, value)
}
func (o *NVIC_Type) GetNVICIP23() uint8 {
	return volatile.LoadUint8(&o.NVICIP23.Reg)
}

// NVIC.NVICIP24: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP24(value uint8) {
	volatile.StoreUint8(&o.NVICIP24.Reg, value)
}
func (o *NVIC_Type) GetNVICIP24() uint8 {
	return volatile.LoadUint8(&o.NVICIP24.Reg)
}

// NVIC.NVICIP25: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP25(value uint8) {
	volatile.StoreUint8(&o.NVICIP25.Reg, value)
}
func (o *NVIC_Type) GetNVICIP25() uint8 {
	return volatile.LoadUint8(&o.NVICIP25.Reg)
}

// NVIC.NVICIP26: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP26(value uint8) {
	volatile.StoreUint8(&o.NVICIP26.Reg, value)
}
func (o *NVIC_Type) GetNVICIP26() uint8 {
	return volatile.LoadUint8(&o.NVICIP26.Reg)
}

// NVIC.NVICIP27: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP27(value uint8) {
	volatile.StoreUint8(&o.NVICIP27.Reg, value)
}
func (o *NVIC_Type) GetNVICIP27() uint8 {
	return volatile.LoadUint8(&o.NVICIP27.Reg)
}

// NVIC.NVICIP28: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP28(value uint8) {
	volatile.StoreUint8(&o.NVICIP28.Reg, value)
}
func (o *NVIC_Type) GetNVICIP28() uint8 {
	return volatile.LoadUint8(&o.NVICIP28.Reg)
}

// NVIC.NVICIP29: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP29(value uint8) {
	volatile.StoreUint8(&o.NVICIP29.Reg, value)
}
func (o *NVIC_Type) GetNVICIP29() uint8 {
	return volatile.LoadUint8(&o.NVICIP29.Reg)
}

// NVIC.NVICIP30: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP30(value uint8) {
	volatile.StoreUint8(&o.NVICIP30.Reg, value)
}
func (o *NVIC_Type) GetNVICIP30() uint8 {
	return volatile.LoadUint8(&o.NVICIP30.Reg)
}

// NVIC.NVICIP31: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP31(value uint8) {
	volatile.StoreUint8(&o.NVICIP31.Reg, value)
}
func (o *NVIC_Type) GetNVICIP31() uint8 {
	return volatile.LoadUint8(&o.NVICIP31.Reg)
}

// NVIC.NVICIP32: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP32(value uint8) {
	volatile.StoreUint8(&o.NVICIP32.Reg, value)
}
func (o *NVIC_Type) GetNVICIP32() uint8 {
	return volatile.LoadUint8(&o.NVICIP32.Reg)
}

// NVIC.NVICIP33: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP33(value uint8) {
	volatile.StoreUint8(&o.NVICIP33.Reg, value)
}
func (o *NVIC_Type) GetNVICIP33() uint8 {
	return volatile.LoadUint8(&o.NVICIP33.Reg)
}

// NVIC.NVICIP34: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP34(value uint8) {
	volatile.StoreUint8(&o.NVICIP34.Reg, value)
}
func (o *NVIC_Type) GetNVICIP34() uint8 {
	return volatile.LoadUint8(&o.NVICIP34.Reg)
}

// NVIC.NVICIP35: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP35(value uint8) {
	volatile.StoreUint8(&o.NVICIP35.Reg, value)
}
func (o *NVIC_Type) GetNVICIP35() uint8 {
	return volatile.LoadUint8(&o.NVICIP35.Reg)
}

// NVIC.NVICIP36: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP36(value uint8) {
	volatile.StoreUint8(&o.NVICIP36.Reg, value)
}
func (o *NVIC_Type) GetNVICIP36() uint8 {
	return volatile.LoadUint8(&o.NVICIP36.Reg)
}

// NVIC.NVICIP37: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP37(value uint8) {
	volatile.StoreUint8(&o.NVICIP37.Reg, value)
}
func (o *NVIC_Type) GetNVICIP37() uint8 {
	return volatile.LoadUint8(&o.NVICIP37.Reg)
}

// NVIC.NVICIP38: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP38(value uint8) {
	volatile.StoreUint8(&o.NVICIP38.Reg, value)
}
func (o *NVIC_Type) GetNVICIP38() uint8 {
	return volatile.LoadUint8(&o.NVICIP38.Reg)
}

// NVIC.NVICIP39: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP39(value uint8) {
	volatile.StoreUint8(&o.NVICIP39.Reg, value)
}
func (o *NVIC_Type) GetNVICIP39() uint8 {
	return volatile.LoadUint8(&o.NVICIP39.Reg)
}

// NVIC.NVICIP40: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP40(value uint8) {
	volatile.StoreUint8(&o.NVICIP40.Reg, value)
}
func (o *NVIC_Type) GetNVICIP40() uint8 {
	return volatile.LoadUint8(&o.NVICIP40.Reg)
}

// NVIC.NVICIP41: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP41(value uint8) {
	volatile.StoreUint8(&o.NVICIP41.Reg, value)
}
func (o *NVIC_Type) GetNVICIP41() uint8 {
	return volatile.LoadUint8(&o.NVICIP41.Reg)
}

// NVIC.NVICIP42: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP42(value uint8) {
	volatile.StoreUint8(&o.NVICIP42.Reg, value)
}
func (o *NVIC_Type) GetNVICIP42() uint8 {
	return volatile.LoadUint8(&o.NVICIP42.Reg)
}

// NVIC.NVICIP43: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP43(value uint8) {
	volatile.StoreUint8(&o.NVICIP43.Reg, value)
}
func (o *NVIC_Type) GetNVICIP43() uint8 {
	return volatile.LoadUint8(&o.NVICIP43.Reg)
}

// NVIC.NVICIP44: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP44(value uint8) {
	volatile.StoreUint8(&o.NVICIP44.Reg, value)
}
func (o *NVIC_Type) GetNVICIP44() uint8 {
	return volatile.LoadUint8(&o.NVICIP44.Reg)
}

// NVIC.NVICIP45: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP45(value uint8) {
	volatile.StoreUint8(&o.NVICIP45.Reg, value)
}
func (o *NVIC_Type) GetNVICIP45() uint8 {
	return volatile.LoadUint8(&o.NVICIP45.Reg)
}

// NVIC.NVICIP46: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP46(value uint8) {
	volatile.StoreUint8(&o.NVICIP46.Reg, value)
}
func (o *NVIC_Type) GetNVICIP46() uint8 {
	return volatile.LoadUint8(&o.NVICIP46.Reg)
}

// NVIC.NVICIP47: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP47(value uint8) {
	volatile.StoreUint8(&o.NVICIP47.Reg, value)
}
func (o *NVIC_Type) GetNVICIP47() uint8 {
	return volatile.LoadUint8(&o.NVICIP47.Reg)
}

// NVIC.NVICIP48: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP48(value uint8) {
	volatile.StoreUint8(&o.NVICIP48.Reg, value)
}
func (o *NVIC_Type) GetNVICIP48() uint8 {
	return volatile.LoadUint8(&o.NVICIP48.Reg)
}

// NVIC.NVICIP49: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP49(value uint8) {
	volatile.StoreUint8(&o.NVICIP49.Reg, value)
}
func (o *NVIC_Type) GetNVICIP49() uint8 {
	return volatile.LoadUint8(&o.NVICIP49.Reg)
}

// NVIC.NVICIP50: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP50(value uint8) {
	volatile.StoreUint8(&o.NVICIP50.Reg, value)
}
func (o *NVIC_Type) GetNVICIP50() uint8 {
	return volatile.LoadUint8(&o.NVICIP50.Reg)
}

// NVIC.NVICIP51: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP51(value uint8) {
	volatile.StoreUint8(&o.NVICIP51.Reg, value)
}
func (o *NVIC_Type) GetNVICIP51() uint8 {
	return volatile.LoadUint8(&o.NVICIP51.Reg)
}

// NVIC.NVICIP52: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP52(value uint8) {
	volatile.StoreUint8(&o.NVICIP52.Reg, value)
}
func (o *NVIC_Type) GetNVICIP52() uint8 {
	return volatile.LoadUint8(&o.NVICIP52.Reg)
}

// NVIC.NVICIP53: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP53(value uint8) {
	volatile.StoreUint8(&o.NVICIP53.Reg, value)
}
func (o *NVIC_Type) GetNVICIP53() uint8 {
	return volatile.LoadUint8(&o.NVICIP53.Reg)
}

// NVIC.NVICIP54: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP54(value uint8) {
	volatile.StoreUint8(&o.NVICIP54.Reg, value)
}
func (o *NVIC_Type) GetNVICIP54() uint8 {
	return volatile.LoadUint8(&o.NVICIP54.Reg)
}

// NVIC.NVICIP55: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP55(value uint8) {
	volatile.StoreUint8(&o.NVICIP55.Reg, value)
}
func (o *NVIC_Type) GetNVICIP55() uint8 {
	return volatile.LoadUint8(&o.NVICIP55.Reg)
}

// NVIC.NVICIP56: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP56(value uint8) {
	volatile.StoreUint8(&o.NVICIP56.Reg, value)
}
func (o *NVIC_Type) GetNVICIP56() uint8 {
	return volatile.LoadUint8(&o.NVICIP56.Reg)
}

// NVIC.NVICIP57: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP57(value uint8) {
	volatile.StoreUint8(&o.NVICIP57.Reg, value)
}
func (o *NVIC_Type) GetNVICIP57() uint8 {
	return volatile.LoadUint8(&o.NVICIP57.Reg)
}

// NVIC.NVICIP58: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP58(value uint8) {
	volatile.StoreUint8(&o.NVICIP58.Reg, value)
}
func (o *NVIC_Type) GetNVICIP58() uint8 {
	return volatile.LoadUint8(&o.NVICIP58.Reg)
}

// NVIC.NVICIP59: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP59(value uint8) {
	volatile.StoreUint8(&o.NVICIP59.Reg, value)
}
func (o *NVIC_Type) GetNVICIP59() uint8 {
	return volatile.LoadUint8(&o.NVICIP59.Reg)
}

// NVIC.NVICIP60: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP60(value uint8) {
	volatile.StoreUint8(&o.NVICIP60.Reg, value)
}
func (o *NVIC_Type) GetNVICIP60() uint8 {
	return volatile.LoadUint8(&o.NVICIP60.Reg)
}

// NVIC.NVICIP61: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP61(value uint8) {
	volatile.StoreUint8(&o.NVICIP61.Reg, value)
}
func (o *NVIC_Type) GetNVICIP61() uint8 {
	return volatile.LoadUint8(&o.NVICIP61.Reg)
}

// NVIC.NVICIP62: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP62(value uint8) {
	volatile.StoreUint8(&o.NVICIP62.Reg, value)
}
func (o *NVIC_Type) GetNVICIP62() uint8 {
	return volatile.LoadUint8(&o.NVICIP62.Reg)
}

// NVIC.NVICIP63: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP63(value uint8) {
	volatile.StoreUint8(&o.NVICIP63.Reg, value)
}
func (o *NVIC_Type) GetNVICIP63() uint8 {
	return volatile.LoadUint8(&o.NVICIP63.Reg)
}

// NVIC.NVICIP64: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP64(value uint8) {
	volatile.StoreUint8(&o.NVICIP64.Reg, value)
}
func (o *NVIC_Type) GetNVICIP64() uint8 {
	return volatile.LoadUint8(&o.NVICIP64.Reg)
}

// NVIC.NVICIP65: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP65(value uint8) {
	volatile.StoreUint8(&o.NVICIP65.Reg, value)
}
func (o *NVIC_Type) GetNVICIP65() uint8 {
	return volatile.LoadUint8(&o.NVICIP65.Reg)
}

// NVIC.NVICIP66: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP66(value uint8) {
	volatile.StoreUint8(&o.NVICIP66.Reg, value)
}
func (o *NVIC_Type) GetNVICIP66() uint8 {
	return volatile.LoadUint8(&o.NVICIP66.Reg)
}

// NVIC.NVICIP67: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP67(value uint8) {
	volatile.StoreUint8(&o.NVICIP67.Reg, value)
}
func (o *NVIC_Type) GetNVICIP67() uint8 {
	return volatile.LoadUint8(&o.NVICIP67.Reg)
}

// NVIC.NVICIP68: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP68(value uint8) {
	volatile.StoreUint8(&o.NVICIP68.Reg, value)
}
func (o *NVIC_Type) GetNVICIP68() uint8 {
	return volatile.LoadUint8(&o.NVICIP68.Reg)
}

// NVIC.NVICIP69: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP69(value uint8) {
	volatile.StoreUint8(&o.NVICIP69.Reg, value)
}
func (o *NVIC_Type) GetNVICIP69() uint8 {
	return volatile.LoadUint8(&o.NVICIP69.Reg)
}

// NVIC.NVICIP70: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP70(value uint8) {
	volatile.StoreUint8(&o.NVICIP70.Reg, value)
}
func (o *NVIC_Type) GetNVICIP70() uint8 {
	return volatile.LoadUint8(&o.NVICIP70.Reg)
}

// NVIC.NVICIP71: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP71(value uint8) {
	volatile.StoreUint8(&o.NVICIP71.Reg, value)
}
func (o *NVIC_Type) GetNVICIP71() uint8 {
	return volatile.LoadUint8(&o.NVICIP71.Reg)
}

// NVIC.NVICIP72: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP72(value uint8) {
	volatile.StoreUint8(&o.NVICIP72.Reg, value)
}
func (o *NVIC_Type) GetNVICIP72() uint8 {
	return volatile.LoadUint8(&o.NVICIP72.Reg)
}

// NVIC.NVICIP73: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP73(value uint8) {
	volatile.StoreUint8(&o.NVICIP73.Reg, value)
}
func (o *NVIC_Type) GetNVICIP73() uint8 {
	return volatile.LoadUint8(&o.NVICIP73.Reg)
}

// NVIC.NVICIP74: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP74(value uint8) {
	volatile.StoreUint8(&o.NVICIP74.Reg, value)
}
func (o *NVIC_Type) GetNVICIP74() uint8 {
	return volatile.LoadUint8(&o.NVICIP74.Reg)
}

// NVIC.NVICIP75: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP75(value uint8) {
	volatile.StoreUint8(&o.NVICIP75.Reg, value)
}
func (o *NVIC_Type) GetNVICIP75() uint8 {
	return volatile.LoadUint8(&o.NVICIP75.Reg)
}

// NVIC.NVICIP76: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP76(value uint8) {
	volatile.StoreUint8(&o.NVICIP76.Reg, value)
}
func (o *NVIC_Type) GetNVICIP76() uint8 {
	return volatile.LoadUint8(&o.NVICIP76.Reg)
}

// NVIC.NVICIP77: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP77(value uint8) {
	volatile.StoreUint8(&o.NVICIP77.Reg, value)
}
func (o *NVIC_Type) GetNVICIP77() uint8 {
	return volatile.LoadUint8(&o.NVICIP77.Reg)
}

// NVIC.NVICIP78: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP78(value uint8) {
	volatile.StoreUint8(&o.NVICIP78.Reg, value)
}
func (o *NVIC_Type) GetNVICIP78() uint8 {
	return volatile.LoadUint8(&o.NVICIP78.Reg)
}

// NVIC.NVICIP79: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP79(value uint8) {
	volatile.StoreUint8(&o.NVICIP79.Reg, value)
}
func (o *NVIC_Type) GetNVICIP79() uint8 {
	return volatile.LoadUint8(&o.NVICIP79.Reg)
}

// NVIC.NVICIP80: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP80(value uint8) {
	volatile.StoreUint8(&o.NVICIP80.Reg, value)
}
func (o *NVIC_Type) GetNVICIP80() uint8 {
	return volatile.LoadUint8(&o.NVICIP80.Reg)
}

// NVIC.NVICIP81: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP81(value uint8) {
	volatile.StoreUint8(&o.NVICIP81.Reg, value)
}
func (o *NVIC_Type) GetNVICIP81() uint8 {
	return volatile.LoadUint8(&o.NVICIP81.Reg)
}

// NVIC.NVICIP82: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP82(value uint8) {
	volatile.StoreUint8(&o.NVICIP82.Reg, value)
}
func (o *NVIC_Type) GetNVICIP82() uint8 {
	return volatile.LoadUint8(&o.NVICIP82.Reg)
}

// NVIC.NVICIP83: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP83(value uint8) {
	volatile.StoreUint8(&o.NVICIP83.Reg, value)
}
func (o *NVIC_Type) GetNVICIP83() uint8 {
	return volatile.LoadUint8(&o.NVICIP83.Reg)
}

// NVIC.NVICIP84: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP84(value uint8) {
	volatile.StoreUint8(&o.NVICIP84.Reg, value)
}
func (o *NVIC_Type) GetNVICIP84() uint8 {
	return volatile.LoadUint8(&o.NVICIP84.Reg)
}

// NVIC.NVICIP85: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP85(value uint8) {
	volatile.StoreUint8(&o.NVICIP85.Reg, value)
}
func (o *NVIC_Type) GetNVICIP85() uint8 {
	return volatile.LoadUint8(&o.NVICIP85.Reg)
}

// NVIC.NVICIP86: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP86(value uint8) {
	volatile.StoreUint8(&o.NVICIP86.Reg, value)
}
func (o *NVIC_Type) GetNVICIP86() uint8 {
	return volatile.LoadUint8(&o.NVICIP86.Reg)
}

// NVIC.NVICIP87: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP87(value uint8) {
	volatile.StoreUint8(&o.NVICIP87.Reg, value)
}
func (o *NVIC_Type) GetNVICIP87() uint8 {
	return volatile.LoadUint8(&o.NVICIP87.Reg)
}

// NVIC.NVICIP88: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP88(value uint8) {
	volatile.StoreUint8(&o.NVICIP88.Reg, value)
}
func (o *NVIC_Type) GetNVICIP88() uint8 {
	return volatile.LoadUint8(&o.NVICIP88.Reg)
}

// NVIC.NVICIP89: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP89(value uint8) {
	volatile.StoreUint8(&o.NVICIP89.Reg, value)
}
func (o *NVIC_Type) GetNVICIP89() uint8 {
	return volatile.LoadUint8(&o.NVICIP89.Reg)
}

// NVIC.NVICIP90: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP90(value uint8) {
	volatile.StoreUint8(&o.NVICIP90.Reg, value)
}
func (o *NVIC_Type) GetNVICIP90() uint8 {
	return volatile.LoadUint8(&o.NVICIP90.Reg)
}

// NVIC.NVICIP91: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP91(value uint8) {
	volatile.StoreUint8(&o.NVICIP91.Reg, value)
}
func (o *NVIC_Type) GetNVICIP91() uint8 {
	return volatile.LoadUint8(&o.NVICIP91.Reg)
}

// NVIC.NVICIP92: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP92(value uint8) {
	volatile.StoreUint8(&o.NVICIP92.Reg, value)
}
func (o *NVIC_Type) GetNVICIP92() uint8 {
	return volatile.LoadUint8(&o.NVICIP92.Reg)
}

// NVIC.NVICIP93: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP93(value uint8) {
	volatile.StoreUint8(&o.NVICIP93.Reg, value)
}
func (o *NVIC_Type) GetNVICIP93() uint8 {
	return volatile.LoadUint8(&o.NVICIP93.Reg)
}

// NVIC.NVICIP94: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP94(value uint8) {
	volatile.StoreUint8(&o.NVICIP94.Reg, value)
}
func (o *NVIC_Type) GetNVICIP94() uint8 {
	return volatile.LoadUint8(&o.NVICIP94.Reg)
}

// NVIC.NVICIP95: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP95(value uint8) {
	volatile.StoreUint8(&o.NVICIP95.Reg, value)
}
func (o *NVIC_Type) GetNVICIP95() uint8 {
	return volatile.LoadUint8(&o.NVICIP95.Reg)
}

// NVIC.NVICIP96: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP96(value uint8) {
	volatile.StoreUint8(&o.NVICIP96.Reg, value)
}
func (o *NVIC_Type) GetNVICIP96() uint8 {
	return volatile.LoadUint8(&o.NVICIP96.Reg)
}

// NVIC.NVICIP97: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP97(value uint8) {
	volatile.StoreUint8(&o.NVICIP97.Reg, value)
}
func (o *NVIC_Type) GetNVICIP97() uint8 {
	return volatile.LoadUint8(&o.NVICIP97.Reg)
}

// NVIC.NVICIP98: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP98(value uint8) {
	volatile.StoreUint8(&o.NVICIP98.Reg, value)
}
func (o *NVIC_Type) GetNVICIP98() uint8 {
	return volatile.LoadUint8(&o.NVICIP98.Reg)
}

// NVIC.NVICIP99: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP99(value uint8) {
	volatile.StoreUint8(&o.NVICIP99.Reg, value)
}
func (o *NVIC_Type) GetNVICIP99() uint8 {
	return volatile.LoadUint8(&o.NVICIP99.Reg)
}

// NVIC.NVICIP100: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP100(value uint8) {
	volatile.StoreUint8(&o.NVICIP100.Reg, value)
}
func (o *NVIC_Type) GetNVICIP100() uint8 {
	return volatile.LoadUint8(&o.NVICIP100.Reg)
}

// NVIC.NVICIP101: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP101(value uint8) {
	volatile.StoreUint8(&o.NVICIP101.Reg, value)
}
func (o *NVIC_Type) GetNVICIP101() uint8 {
	return volatile.LoadUint8(&o.NVICIP101.Reg)
}

// NVIC.NVICIP102: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP102(value uint8) {
	volatile.StoreUint8(&o.NVICIP102.Reg, value)
}
func (o *NVIC_Type) GetNVICIP102() uint8 {
	return volatile.LoadUint8(&o.NVICIP102.Reg)
}

// NVIC.NVICIP103: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP103(value uint8) {
	volatile.StoreUint8(&o.NVICIP103.Reg, value)
}
func (o *NVIC_Type) GetNVICIP103() uint8 {
	return volatile.LoadUint8(&o.NVICIP103.Reg)
}

// NVIC.NVICIP104: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP104(value uint8) {
	volatile.StoreUint8(&o.NVICIP104.Reg, value)
}
func (o *NVIC_Type) GetNVICIP104() uint8 {
	return volatile.LoadUint8(&o.NVICIP104.Reg)
}

// NVIC.NVICIP105: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP105(value uint8) {
	volatile.StoreUint8(&o.NVICIP105.Reg, value)
}
func (o *NVIC_Type) GetNVICIP105() uint8 {
	return volatile.LoadUint8(&o.NVICIP105.Reg)
}

// NVIC.NVICSTIR: Software Trigger Interrupt Register
func (o *NVIC_Type) SetNVICSTIR_INTID(value uint32) {
	volatile.StoreUint32(&o.NVICSTIR.Reg, volatile.LoadUint32(&o.NVICSTIR.Reg)&^(0x1ff)|value)
}
func (o *NVIC_Type) GetNVICSTIR_INTID() uint32 {
	return volatile.LoadUint32(&o.NVICSTIR.Reg) & 0x1ff
}

// Core Platform Miscellaneous Control Module
type MCM_Type struct {
	_      [8]byte
	PLASC  volatile.Register16 // 0x8
	PLAMC  volatile.Register16 // 0xA
	CR     volatile.Register32 // 0xC
	ISCR   volatile.Register32 // 0x10
	ETBCC  volatile.Register32 // 0x14
	ETBRL  volatile.Register32 // 0x18
	ETBCNT volatile.Register32 // 0x1C
	_      [16]byte
	PID    volatile.Register32 // 0x30
}

// MCM.PLASC: Crossbar Switch (AXBS) Slave Configuration
func (o *MCM_Type) SetPLASC_ASC(value uint16) {
	volatile.StoreUint16(&o.PLASC.Reg, volatile.LoadUint16(&o.PLASC.Reg)&^(0xff)|value)
}
func (o *MCM_Type) GetPLASC_ASC() uint16 {
	return volatile.LoadUint16(&o.PLASC.Reg) & 0xff
}

// MCM.PLAMC: Crossbar Switch (AXBS) Master Configuration
func (o *MCM_Type) SetPLAMC_AMC(value uint16) {
	volatile.StoreUint16(&o.PLAMC.Reg, volatile.LoadUint16(&o.PLAMC.Reg)&^(0xff)|value)
}
func (o *MCM_Type) GetPLAMC_AMC() uint16 {
	return volatile.LoadUint16(&o.PLAMC.Reg) & 0xff
}

// MCM.CR: Control Register
func (o *MCM_Type) SetCR_SRAMUAP(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x3000000)|value<<24)
}
func (o *MCM_Type) GetCR_SRAMUAP() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x3000000) >> 24
}
func (o *MCM_Type) SetCR_SRAMUWP(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4000000)|value<<26)
}
func (o *MCM_Type) GetCR_SRAMUWP() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4000000) >> 26
}
func (o *MCM_Type) SetCR_SRAMLAP(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x30000000)|value<<28)
}
func (o *MCM_Type) GetCR_SRAMLAP() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x30000000) >> 28
}
func (o *MCM_Type) SetCR_SRAMLWP(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40000000)|value<<30)
}
func (o *MCM_Type) GetCR_SRAMLWP() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40000000) >> 30
}

// MCM.ISCR: Interrupt Status Register
func (o *MCM_Type) SetISCR_IRQ(value uint32) {
	volatile.StoreUint32(&o.ISCR.Reg, volatile.LoadUint32(&o.ISCR.Reg)&^(0x2)|value<<1)
}
func (o *MCM_Type) GetISCR_IRQ() uint32 {
	return (volatile.LoadUint32(&o.ISCR.Reg) & 0x2) >> 1
}
func (o *MCM_Type) SetISCR_NMI(value uint32) {
	volatile.StoreUint32(&o.ISCR.Reg, volatile.LoadUint32(&o.ISCR.Reg)&^(0x4)|value<<2)
}
func (o *MCM_Type) GetISCR_NMI() uint32 {
	return (volatile.LoadUint32(&o.ISCR.Reg) & 0x4) >> 2
}
func (o *MCM_Type) SetISCR_DHREQ(value uint32) {
	volatile.StoreUint32(&o.ISCR.Reg, volatile.LoadUint32(&o.ISCR.Reg)&^(0x8)|value<<3)
}
func (o *MCM_Type) GetISCR_DHREQ() uint32 {
	return (volatile.LoadUint32(&o.ISCR.Reg) & 0x8) >> 3
}
func (o *MCM_Type) SetISCR_FIOC(value uint32) {
	volatile.StoreUint32(&o.ISCR.Reg, volatile.LoadUint32(&o.ISCR.Reg)&^(0x100)|value<<8)
}
func (o *MCM_Type) GetISCR_FIOC() uint32 {
	return (volatile.LoadUint32(&o.ISCR.Reg) & 0x100) >> 8
}
func (o *MCM_Type) SetISCR_FDZC(value uint32) {
	volatile.StoreUint32(&o.ISCR.Reg, volatile.LoadUint32(&o.ISCR.Reg)&^(0x200)|value<<9)
}
func (o *MCM_Type) GetISCR_FDZC() uint32 {
	return (volatile.LoadUint32(&o.ISCR.Reg) & 0x200) >> 9
}
func (o *MCM_Type) SetISCR_FOFC(value uint32) {
	volatile.StoreUint32(&o.ISCR.Reg, volatile.LoadUint32(&o.ISCR.Reg)&^(0x400)|value<<10)
}
func (o *MCM_Type) GetISCR_FOFC() uint32 {
	return (volatile.LoadUint32(&o.ISCR.Reg) & 0x400) >> 10
}
func (o *MCM_Type) SetISCR_FUFC(value uint32) {
	volatile.StoreUint32(&o.ISCR.Reg, volatile.LoadUint32(&o.ISCR.Reg)&^(0x800)|value<<11)
}
func (o *MCM_Type) GetISCR_FUFC() uint32 {
	return (volatile.LoadUint32(&o.ISCR.Reg) & 0x800) >> 11
}
func (o *MCM_Type) SetISCR_FIXC(value uint32) {
	volatile.StoreUint32(&o.ISCR.Reg, volatile.LoadUint32(&o.ISCR.Reg)&^(0x1000)|value<<12)
}
func (o *MCM_Type) GetISCR_FIXC() uint32 {
	return (volatile.LoadUint32(&o.ISCR.Reg) & 0x1000) >> 12
}
func (o *MCM_Type) SetISCR_FIDC(value uint32) {
	volatile.StoreUint32(&o.ISCR.Reg, volatile.LoadUint32(&o.ISCR.Reg)&^(0x8000)|value<<15)
}
func (o *MCM_Type) GetISCR_FIDC() uint32 {
	return (volatile.LoadUint32(&o.ISCR.Reg) & 0x8000) >> 15
}
func (o *MCM_Type) SetISCR_FIOCE(value uint32) {
	volatile.StoreUint32(&o.ISCR.Reg, volatile.LoadUint32(&o.ISCR.Reg)&^(0x1000000)|value<<24)
}
func (o *MCM_Type) GetISCR_FIOCE() uint32 {
	return (volatile.LoadUint32(&o.ISCR.Reg) & 0x1000000) >> 24
}
func (o *MCM_Type) SetISCR_FDZCE(value uint32) {
	volatile.StoreUint32(&o.ISCR.Reg, volatile.LoadUint32(&o.ISCR.Reg)&^(0x2000000)|value<<25)
}
func (o *MCM_Type) GetISCR_FDZCE() uint32 {
	return (volatile.LoadUint32(&o.ISCR.Reg) & 0x2000000) >> 25
}
func (o *MCM_Type) SetISCR_FOFCE(value uint32) {
	volatile.StoreUint32(&o.ISCR.Reg, volatile.LoadUint32(&o.ISCR.Reg)&^(0x4000000)|value<<26)
}
func (o *MCM_Type) GetISCR_FOFCE() uint32 {
	return (volatile.LoadUint32(&o.ISCR.Reg) & 0x4000000) >> 26
}
func (o *MCM_Type) SetISCR_FUFCE(value uint32) {
	volatile.StoreUint32(&o.ISCR.Reg, volatile.LoadUint32(&o.ISCR.Reg)&^(0x8000000)|value<<27)
}
func (o *MCM_Type) GetISCR_FUFCE() uint32 {
	return (volatile.LoadUint32(&o.ISCR.Reg) & 0x8000000) >> 27
}
func (o *MCM_Type) SetISCR_FIXCE(value uint32) {
	volatile.StoreUint32(&o.ISCR.Reg, volatile.LoadUint32(&o.ISCR.Reg)&^(0x10000000)|value<<28)
}
func (o *MCM_Type) GetISCR_FIXCE() uint32 {
	return (volatile.LoadUint32(&o.ISCR.Reg) & 0x10000000) >> 28
}
func (o *MCM_Type) SetISCR_FIDCE(value uint32) {
	volatile.StoreUint32(&o.ISCR.Reg, volatile.LoadUint32(&o.ISCR.Reg)&^(0x80000000)|value<<31)
}
func (o *MCM_Type) GetISCR_FIDCE() uint32 {
	return (volatile.LoadUint32(&o.ISCR.Reg) & 0x80000000) >> 31
}

// MCM.ETBCC: ETB Counter Control register
func (o *MCM_Type) SetETBCC_CNTEN(value uint32) {
	volatile.StoreUint32(&o.ETBCC.Reg, volatile.LoadUint32(&o.ETBCC.Reg)&^(0x1)|value)
}
func (o *MCM_Type) GetETBCC_CNTEN() uint32 {
	return volatile.LoadUint32(&o.ETBCC.Reg) & 0x1
}
func (o *MCM_Type) SetETBCC_RSPT(value uint32) {
	volatile.StoreUint32(&o.ETBCC.Reg, volatile.LoadUint32(&o.ETBCC.Reg)&^(0x6)|value<<1)
}
func (o *MCM_Type) GetETBCC_RSPT() uint32 {
	return (volatile.LoadUint32(&o.ETBCC.Reg) & 0x6) >> 1
}
func (o *MCM_Type) SetETBCC_RLRQ(value uint32) {
	volatile.StoreUint32(&o.ETBCC.Reg, volatile.LoadUint32(&o.ETBCC.Reg)&^(0x8)|value<<3)
}
func (o *MCM_Type) GetETBCC_RLRQ() uint32 {
	return (volatile.LoadUint32(&o.ETBCC.Reg) & 0x8) >> 3
}
func (o *MCM_Type) SetETBCC_ETDIS(value uint32) {
	volatile.StoreUint32(&o.ETBCC.Reg, volatile.LoadUint32(&o.ETBCC.Reg)&^(0x10)|value<<4)
}
func (o *MCM_Type) GetETBCC_ETDIS() uint32 {
	return (volatile.LoadUint32(&o.ETBCC.Reg) & 0x10) >> 4
}
func (o *MCM_Type) SetETBCC_ITDIS(value uint32) {
	volatile.StoreUint32(&o.ETBCC.Reg, volatile.LoadUint32(&o.ETBCC.Reg)&^(0x20)|value<<5)
}
func (o *MCM_Type) GetETBCC_ITDIS() uint32 {
	return (volatile.LoadUint32(&o.ETBCC.Reg) & 0x20) >> 5
}

// MCM.ETBRL: ETB Reload register
func (o *MCM_Type) SetETBRL_RELOAD(value uint32) {
	volatile.StoreUint32(&o.ETBRL.Reg, volatile.LoadUint32(&o.ETBRL.Reg)&^(0x7ff)|value)
}
func (o *MCM_Type) GetETBRL_RELOAD() uint32 {
	return volatile.LoadUint32(&o.ETBRL.Reg) & 0x7ff
}

// MCM.ETBCNT: ETB Counter Value register
func (o *MCM_Type) SetETBCNT_COUNTER(value uint32) {
	volatile.StoreUint32(&o.ETBCNT.Reg, volatile.LoadUint32(&o.ETBCNT.Reg)&^(0x7ff)|value)
}
func (o *MCM_Type) GetETBCNT_COUNTER() uint32 {
	return volatile.LoadUint32(&o.ETBCNT.Reg) & 0x7ff
}

// MCM.PID: Process ID register
func (o *MCM_Type) SetPID(value uint32) {
	volatile.StoreUint32(&o.PID.Reg, volatile.LoadUint32(&o.PID.Reg)&^(0xff)|value)
}
func (o *MCM_Type) GetPID() uint32 {
	return volatile.LoadUint32(&o.PID.Reg) & 0xff
}

// Memory Mapped Cryptographic Acceleration Unit (MMCAU)
type CAU_Type struct {
	CAU_DIRECT0    volatile.Register32 // 0x0
	CAU_DIRECT1    volatile.Register32 // 0x4
	CAU_DIRECT2    volatile.Register32 // 0x8
	CAU_DIRECT3    volatile.Register32 // 0xC
	CAU_DIRECT4    volatile.Register32 // 0x10
	CAU_DIRECT5    volatile.Register32 // 0x14
	CAU_DIRECT6    volatile.Register32 // 0x18
	CAU_DIRECT7    volatile.Register32 // 0x1C
	CAU_DIRECT8    volatile.Register32 // 0x20
	CAU_DIRECT9    volatile.Register32 // 0x24
	CAU_DIRECT10   volatile.Register32 // 0x28
	CAU_DIRECT11   volatile.Register32 // 0x2C
	CAU_DIRECT12   volatile.Register32 // 0x30
	CAU_DIRECT13   volatile.Register32 // 0x34
	CAU_DIRECT14   volatile.Register32 // 0x38
	CAU_DIRECT15   volatile.Register32 // 0x3C
	_              [2048]byte
	CAU_LDR_CASR   volatile.Register32 // 0x840
	CAU_LDR_CAA    volatile.Register32 // 0x844
	CAU_LDR_CA0    volatile.Register32 // 0x848
	CAU_LDR_CA1    volatile.Register32 // 0x84C
	CAU_LDR_CA2    volatile.Register32 // 0x850
	CAU_LDR_CA3    volatile.Register32 // 0x854
	CAU_LDR_CA4    volatile.Register32 // 0x858
	CAU_LDR_CA5    volatile.Register32 // 0x85C
	CAU_LDR_CA6    volatile.Register32 // 0x860
	CAU_LDR_CA7    volatile.Register32 // 0x864
	CAU_LDR_CA8    volatile.Register32 // 0x868
	_              [20]byte
	CAU_STR_CASR   volatile.Register32 // 0x880
	CAU_STR_CAA    volatile.Register32 // 0x884
	CAU_STR_CA0    volatile.Register32 // 0x888
	CAU_STR_CA1    volatile.Register32 // 0x88C
	CAU_STR_CA2    volatile.Register32 // 0x890
	CAU_STR_CA3    volatile.Register32 // 0x894
	CAU_STR_CA4    volatile.Register32 // 0x898
	CAU_STR_CA5    volatile.Register32 // 0x89C
	CAU_STR_CA6    volatile.Register32 // 0x8A0
	CAU_STR_CA7    volatile.Register32 // 0x8A4
	CAU_STR_CA8    volatile.Register32 // 0x8A8
	_              [20]byte
	CAU_ADR_CASR   volatile.Register32 // 0x8C0
	CAU_ADR_CAA    volatile.Register32 // 0x8C4
	CAU_ADR_CA0    volatile.Register32 // 0x8C8
	CAU_ADR_CA1    volatile.Register32 // 0x8CC
	CAU_ADR_CA2    volatile.Register32 // 0x8D0
	CAU_ADR_CA3    volatile.Register32 // 0x8D4
	CAU_ADR_CA4    volatile.Register32 // 0x8D8
	CAU_ADR_CA5    volatile.Register32 // 0x8DC
	CAU_ADR_CA6    volatile.Register32 // 0x8E0
	CAU_ADR_CA7    volatile.Register32 // 0x8E4
	CAU_ADR_CA8    volatile.Register32 // 0x8E8
	_              [20]byte
	CAU_RADR_CASR  volatile.Register32 // 0x900
	CAU_RADR_CAA   volatile.Register32 // 0x904
	CAU_RADR_CA0   volatile.Register32 // 0x908
	CAU_RADR_CA1   volatile.Register32 // 0x90C
	CAU_RADR_CA2   volatile.Register32 // 0x910
	CAU_RADR_CA3   volatile.Register32 // 0x914
	CAU_RADR_CA4   volatile.Register32 // 0x918
	CAU_RADR_CA5   volatile.Register32 // 0x91C
	CAU_RADR_CA6   volatile.Register32 // 0x920
	CAU_RADR_CA7   volatile.Register32 // 0x924
	CAU_RADR_CA8   volatile.Register32 // 0x928
	_              [84]byte
	CAU_XOR_CASR   volatile.Register32 // 0x980
	CAU_XOR_CAA    volatile.Register32 // 0x984
	CAU_XOR_CA0    volatile.Register32 // 0x988
	CAU_XOR_CA1    volatile.Register32 // 0x98C
	CAU_XOR_CA2    volatile.Register32 // 0x990
	CAU_XOR_CA3    volatile.Register32 // 0x994
	CAU_XOR_CA4    volatile.Register32 // 0x998
	CAU_XOR_CA5    volatile.Register32 // 0x99C
	CAU_XOR_CA6    volatile.Register32 // 0x9A0
	CAU_XOR_CA7    volatile.Register32 // 0x9A4
	CAU_XOR_CA8    volatile.Register32 // 0x9A8
	_              [20]byte
	CAU_ROTL_CASR  volatile.Register32 // 0x9C0
	CAU_ROTL_CAA   volatile.Register32 // 0x9C4
	CAU_ROTL_CA0   volatile.Register32 // 0x9C8
	CAU_ROTL_CA1   volatile.Register32 // 0x9CC
	CAU_ROTL_CA2   volatile.Register32 // 0x9D0
	CAU_ROTL_CA3   volatile.Register32 // 0x9D4
	CAU_ROTL_CA4   volatile.Register32 // 0x9D8
	CAU_ROTL_CA5   volatile.Register32 // 0x9DC
	CAU_ROTL_CA6   volatile.Register32 // 0x9E0
	CAU_ROTL_CA7   volatile.Register32 // 0x9E4
	CAU_ROTL_CA8   volatile.Register32 // 0x9E8
	_              [276]byte
	CAU_AESC_CASR  volatile.Register32 // 0xB00
	CAU_AESC_CAA   volatile.Register32 // 0xB04
	CAU_AESC_CA0   volatile.Register32 // 0xB08
	CAU_AESC_CA1   volatile.Register32 // 0xB0C
	CAU_AESC_CA2   volatile.Register32 // 0xB10
	CAU_AESC_CA3   volatile.Register32 // 0xB14
	CAU_AESC_CA4   volatile.Register32 // 0xB18
	CAU_AESC_CA5   volatile.Register32 // 0xB1C
	CAU_AESC_CA6   volatile.Register32 // 0xB20
	CAU_AESC_CA7   volatile.Register32 // 0xB24
	CAU_AESC_CA8   volatile.Register32 // 0xB28
	_              [20]byte
	CAU_AESIC_CASR volatile.Register32 // 0xB40
	CAU_AESIC_CAA  volatile.Register32 // 0xB44
	CAU_AESIC_CA0  volatile.Register32 // 0xB48
	CAU_AESIC_CA1  volatile.Register32 // 0xB4C
	CAU_AESIC_CA2  volatile.Register32 // 0xB50
	CAU_AESIC_CA3  volatile.Register32 // 0xB54
	CAU_AESIC_CA4  volatile.Register32 // 0xB58
	CAU_AESIC_CA5  volatile.Register32 // 0xB5C
	CAU_AESIC_CA6  volatile.Register32 // 0xB60
	CAU_AESIC_CA7  volatile.Register32 // 0xB64
	CAU_AESIC_CA8  volatile.Register32 // 0xB68
}

// CAU.CAU_DIRECT0: Direct access register 0
func (o *CAU_Type) SetCAU_DIRECT0(value uint32) {
	volatile.StoreUint32(&o.CAU_DIRECT0.Reg, value)
}
func (o *CAU_Type) GetCAU_DIRECT0() uint32 {
	return volatile.LoadUint32(&o.CAU_DIRECT0.Reg)
}

// CAU.CAU_DIRECT1: Direct access register 1
func (o *CAU_Type) SetCAU_DIRECT1(value uint32) {
	volatile.StoreUint32(&o.CAU_DIRECT1.Reg, value)
}
func (o *CAU_Type) GetCAU_DIRECT1() uint32 {
	return volatile.LoadUint32(&o.CAU_DIRECT1.Reg)
}

// CAU.CAU_DIRECT2: Direct access register 2
func (o *CAU_Type) SetCAU_DIRECT2(value uint32) {
	volatile.StoreUint32(&o.CAU_DIRECT2.Reg, value)
}
func (o *CAU_Type) GetCAU_DIRECT2() uint32 {
	return volatile.LoadUint32(&o.CAU_DIRECT2.Reg)
}

// CAU.CAU_DIRECT3: Direct access register 3
func (o *CAU_Type) SetCAU_DIRECT3(value uint32) {
	volatile.StoreUint32(&o.CAU_DIRECT3.Reg, value)
}
func (o *CAU_Type) GetCAU_DIRECT3() uint32 {
	return volatile.LoadUint32(&o.CAU_DIRECT3.Reg)
}

// CAU.CAU_DIRECT4: Direct access register 4
func (o *CAU_Type) SetCAU_DIRECT4(value uint32) {
	volatile.StoreUint32(&o.CAU_DIRECT4.Reg, value)
}
func (o *CAU_Type) GetCAU_DIRECT4() uint32 {
	return volatile.LoadUint32(&o.CAU_DIRECT4.Reg)
}

// CAU.CAU_DIRECT5: Direct access register 5
func (o *CAU_Type) SetCAU_DIRECT5(value uint32) {
	volatile.StoreUint32(&o.CAU_DIRECT5.Reg, value)
}
func (o *CAU_Type) GetCAU_DIRECT5() uint32 {
	return volatile.LoadUint32(&o.CAU_DIRECT5.Reg)
}

// CAU.CAU_DIRECT6: Direct access register 6
func (o *CAU_Type) SetCAU_DIRECT6(value uint32) {
	volatile.StoreUint32(&o.CAU_DIRECT6.Reg, value)
}
func (o *CAU_Type) GetCAU_DIRECT6() uint32 {
	return volatile.LoadUint32(&o.CAU_DIRECT6.Reg)
}

// CAU.CAU_DIRECT7: Direct access register 7
func (o *CAU_Type) SetCAU_DIRECT7(value uint32) {
	volatile.StoreUint32(&o.CAU_DIRECT7.Reg, value)
}
func (o *CAU_Type) GetCAU_DIRECT7() uint32 {
	return volatile.LoadUint32(&o.CAU_DIRECT7.Reg)
}

// CAU.CAU_DIRECT8: Direct access register 8
func (o *CAU_Type) SetCAU_DIRECT8(value uint32) {
	volatile.StoreUint32(&o.CAU_DIRECT8.Reg, value)
}
func (o *CAU_Type) GetCAU_DIRECT8() uint32 {
	return volatile.LoadUint32(&o.CAU_DIRECT8.Reg)
}

// CAU.CAU_DIRECT9: Direct access register 9
func (o *CAU_Type) SetCAU_DIRECT9(value uint32) {
	volatile.StoreUint32(&o.CAU_DIRECT9.Reg, value)
}
func (o *CAU_Type) GetCAU_DIRECT9() uint32 {
	return volatile.LoadUint32(&o.CAU_DIRECT9.Reg)
}

// CAU.CAU_DIRECT10: Direct access register 10
func (o *CAU_Type) SetCAU_DIRECT10(value uint32) {
	volatile.StoreUint32(&o.CAU_DIRECT10.Reg, value)
}
func (o *CAU_Type) GetCAU_DIRECT10() uint32 {
	return volatile.LoadUint32(&o.CAU_DIRECT10.Reg)
}

// CAU.CAU_DIRECT11: Direct access register 11
func (o *CAU_Type) SetCAU_DIRECT11(value uint32) {
	volatile.StoreUint32(&o.CAU_DIRECT11.Reg, value)
}
func (o *CAU_Type) GetCAU_DIRECT11() uint32 {
	return volatile.LoadUint32(&o.CAU_DIRECT11.Reg)
}

// CAU.CAU_DIRECT12: Direct access register 12
func (o *CAU_Type) SetCAU_DIRECT12(value uint32) {
	volatile.StoreUint32(&o.CAU_DIRECT12.Reg, value)
}
func (o *CAU_Type) GetCAU_DIRECT12() uint32 {
	return volatile.LoadUint32(&o.CAU_DIRECT12.Reg)
}

// CAU.CAU_DIRECT13: Direct access register 13
func (o *CAU_Type) SetCAU_DIRECT13(value uint32) {
	volatile.StoreUint32(&o.CAU_DIRECT13.Reg, value)
}
func (o *CAU_Type) GetCAU_DIRECT13() uint32 {
	return volatile.LoadUint32(&o.CAU_DIRECT13.Reg)
}

// CAU.CAU_DIRECT14: Direct access register 14
func (o *CAU_Type) SetCAU_DIRECT14(value uint32) {
	volatile.StoreUint32(&o.CAU_DIRECT14.Reg, value)
}
func (o *CAU_Type) GetCAU_DIRECT14() uint32 {
	return volatile.LoadUint32(&o.CAU_DIRECT14.Reg)
}

// CAU.CAU_DIRECT15: Direct access register 15
func (o *CAU_Type) SetCAU_DIRECT15(value uint32) {
	volatile.StoreUint32(&o.CAU_DIRECT15.Reg, value)
}
func (o *CAU_Type) GetCAU_DIRECT15() uint32 {
	return volatile.LoadUint32(&o.CAU_DIRECT15.Reg)
}

// CAU.CAU_LDR_CASR: Status register - Load Register command
func (o *CAU_Type) SetCAU_LDR_CASR_IC(value uint32) {
	volatile.StoreUint32(&o.CAU_LDR_CASR.Reg, volatile.LoadUint32(&o.CAU_LDR_CASR.Reg)&^(0x1)|value)
}
func (o *CAU_Type) GetCAU_LDR_CASR_IC() uint32 {
	return volatile.LoadUint32(&o.CAU_LDR_CASR.Reg) & 0x1
}
func (o *CAU_Type) SetCAU_LDR_CASR_DPE(value uint32) {
	volatile.StoreUint32(&o.CAU_LDR_CASR.Reg, volatile.LoadUint32(&o.CAU_LDR_CASR.Reg)&^(0x2)|value<<1)
}
func (o *CAU_Type) GetCAU_LDR_CASR_DPE() uint32 {
	return (volatile.LoadUint32(&o.CAU_LDR_CASR.Reg) & 0x2) >> 1
}
func (o *CAU_Type) SetCAU_LDR_CASR_VER(value uint32) {
	volatile.StoreUint32(&o.CAU_LDR_CASR.Reg, volatile.LoadUint32(&o.CAU_LDR_CASR.Reg)&^(0xf0000000)|value<<28)
}
func (o *CAU_Type) GetCAU_LDR_CASR_VER() uint32 {
	return (volatile.LoadUint32(&o.CAU_LDR_CASR.Reg) & 0xf0000000) >> 28
}

// CAU.CAU_LDR_CAA: Accumulator register - Load Register command
func (o *CAU_Type) SetCAU_LDR_CAA(value uint32) {
	volatile.StoreUint32(&o.CAU_LDR_CAA.Reg, value)
}
func (o *CAU_Type) GetCAU_LDR_CAA() uint32 {
	return volatile.LoadUint32(&o.CAU_LDR_CAA.Reg)
}

// CAU.CAU_LDR_CA0: General Purpose Register 0 - Load Register command
func (o *CAU_Type) SetCAU_LDR_CA0(value uint32) {
	volatile.StoreUint32(&o.CAU_LDR_CA0.Reg, value)
}
func (o *CAU_Type) GetCAU_LDR_CA0() uint32 {
	return volatile.LoadUint32(&o.CAU_LDR_CA0.Reg)
}

// CAU.CAU_LDR_CA1: General Purpose Register 1 - Load Register command
func (o *CAU_Type) SetCAU_LDR_CA1(value uint32) {
	volatile.StoreUint32(&o.CAU_LDR_CA1.Reg, value)
}
func (o *CAU_Type) GetCAU_LDR_CA1() uint32 {
	return volatile.LoadUint32(&o.CAU_LDR_CA1.Reg)
}

// CAU.CAU_LDR_CA2: General Purpose Register 2 - Load Register command
func (o *CAU_Type) SetCAU_LDR_CA2(value uint32) {
	volatile.StoreUint32(&o.CAU_LDR_CA2.Reg, value)
}
func (o *CAU_Type) GetCAU_LDR_CA2() uint32 {
	return volatile.LoadUint32(&o.CAU_LDR_CA2.Reg)
}

// CAU.CAU_LDR_CA3: General Purpose Register 3 - Load Register command
func (o *CAU_Type) SetCAU_LDR_CA3(value uint32) {
	volatile.StoreUint32(&o.CAU_LDR_CA3.Reg, value)
}
func (o *CAU_Type) GetCAU_LDR_CA3() uint32 {
	return volatile.LoadUint32(&o.CAU_LDR_CA3.Reg)
}

// CAU.CAU_LDR_CA4: General Purpose Register 4 - Load Register command
func (o *CAU_Type) SetCAU_LDR_CA4(value uint32) {
	volatile.StoreUint32(&o.CAU_LDR_CA4.Reg, value)
}
func (o *CAU_Type) GetCAU_LDR_CA4() uint32 {
	return volatile.LoadUint32(&o.CAU_LDR_CA4.Reg)
}

// CAU.CAU_LDR_CA5: General Purpose Register 5 - Load Register command
func (o *CAU_Type) SetCAU_LDR_CA5(value uint32) {
	volatile.StoreUint32(&o.CAU_LDR_CA5.Reg, value)
}
func (o *CAU_Type) GetCAU_LDR_CA5() uint32 {
	return volatile.LoadUint32(&o.CAU_LDR_CA5.Reg)
}

// CAU.CAU_LDR_CA6: General Purpose Register 6 - Load Register command
func (o *CAU_Type) SetCAU_LDR_CA6(value uint32) {
	volatile.StoreUint32(&o.CAU_LDR_CA6.Reg, value)
}
func (o *CAU_Type) GetCAU_LDR_CA6() uint32 {
	return volatile.LoadUint32(&o.CAU_LDR_CA6.Reg)
}

// CAU.CAU_LDR_CA7: General Purpose Register 7 - Load Register command
func (o *CAU_Type) SetCAU_LDR_CA7(value uint32) {
	volatile.StoreUint32(&o.CAU_LDR_CA7.Reg, value)
}
func (o *CAU_Type) GetCAU_LDR_CA7() uint32 {
	return volatile.LoadUint32(&o.CAU_LDR_CA7.Reg)
}

// CAU.CAU_LDR_CA8: General Purpose Register 8 - Load Register command
func (o *CAU_Type) SetCAU_LDR_CA8(value uint32) {
	volatile.StoreUint32(&o.CAU_LDR_CA8.Reg, value)
}
func (o *CAU_Type) GetCAU_LDR_CA8() uint32 {
	return volatile.LoadUint32(&o.CAU_LDR_CA8.Reg)
}

// CAU.CAU_STR_CASR: Status register - Store Register command
func (o *CAU_Type) SetCAU_STR_CASR_IC(value uint32) {
	volatile.StoreUint32(&o.CAU_STR_CASR.Reg, volatile.LoadUint32(&o.CAU_STR_CASR.Reg)&^(0x1)|value)
}
func (o *CAU_Type) GetCAU_STR_CASR_IC() uint32 {
	return volatile.LoadUint32(&o.CAU_STR_CASR.Reg) & 0x1
}
func (o *CAU_Type) SetCAU_STR_CASR_DPE(value uint32) {
	volatile.StoreUint32(&o.CAU_STR_CASR.Reg, volatile.LoadUint32(&o.CAU_STR_CASR.Reg)&^(0x2)|value<<1)
}
func (o *CAU_Type) GetCAU_STR_CASR_DPE() uint32 {
	return (volatile.LoadUint32(&o.CAU_STR_CASR.Reg) & 0x2) >> 1
}
func (o *CAU_Type) SetCAU_STR_CASR_VER(value uint32) {
	volatile.StoreUint32(&o.CAU_STR_CASR.Reg, volatile.LoadUint32(&o.CAU_STR_CASR.Reg)&^(0xf0000000)|value<<28)
}
func (o *CAU_Type) GetCAU_STR_CASR_VER() uint32 {
	return (volatile.LoadUint32(&o.CAU_STR_CASR.Reg) & 0xf0000000) >> 28
}

// CAU.CAU_STR_CAA: Accumulator register - Store Register command
func (o *CAU_Type) SetCAU_STR_CAA(value uint32) {
	volatile.StoreUint32(&o.CAU_STR_CAA.Reg, value)
}
func (o *CAU_Type) GetCAU_STR_CAA() uint32 {
	return volatile.LoadUint32(&o.CAU_STR_CAA.Reg)
}

// CAU.CAU_STR_CA0: General Purpose Register 0 - Store Register command
func (o *CAU_Type) SetCAU_STR_CA0(value uint32) {
	volatile.StoreUint32(&o.CAU_STR_CA0.Reg, value)
}
func (o *CAU_Type) GetCAU_STR_CA0() uint32 {
	return volatile.LoadUint32(&o.CAU_STR_CA0.Reg)
}

// CAU.CAU_STR_CA1: General Purpose Register 1 - Store Register command
func (o *CAU_Type) SetCAU_STR_CA1(value uint32) {
	volatile.StoreUint32(&o.CAU_STR_CA1.Reg, value)
}
func (o *CAU_Type) GetCAU_STR_CA1() uint32 {
	return volatile.LoadUint32(&o.CAU_STR_CA1.Reg)
}

// CAU.CAU_STR_CA2: General Purpose Register 2 - Store Register command
func (o *CAU_Type) SetCAU_STR_CA2(value uint32) {
	volatile.StoreUint32(&o.CAU_STR_CA2.Reg, value)
}
func (o *CAU_Type) GetCAU_STR_CA2() uint32 {
	return volatile.LoadUint32(&o.CAU_STR_CA2.Reg)
}

// CAU.CAU_STR_CA3: General Purpose Register 3 - Store Register command
func (o *CAU_Type) SetCAU_STR_CA3(value uint32) {
	volatile.StoreUint32(&o.CAU_STR_CA3.Reg, value)
}
func (o *CAU_Type) GetCAU_STR_CA3() uint32 {
	return volatile.LoadUint32(&o.CAU_STR_CA3.Reg)
}

// CAU.CAU_STR_CA4: General Purpose Register 4 - Store Register command
func (o *CAU_Type) SetCAU_STR_CA4(value uint32) {
	volatile.StoreUint32(&o.CAU_STR_CA4.Reg, value)
}
func (o *CAU_Type) GetCAU_STR_CA4() uint32 {
	return volatile.LoadUint32(&o.CAU_STR_CA4.Reg)
}

// CAU.CAU_STR_CA5: General Purpose Register 5 - Store Register command
func (o *CAU_Type) SetCAU_STR_CA5(value uint32) {
	volatile.StoreUint32(&o.CAU_STR_CA5.Reg, value)
}
func (o *CAU_Type) GetCAU_STR_CA5() uint32 {
	return volatile.LoadUint32(&o.CAU_STR_CA5.Reg)
}

// CAU.CAU_STR_CA6: General Purpose Register 6 - Store Register command
func (o *CAU_Type) SetCAU_STR_CA6(value uint32) {
	volatile.StoreUint32(&o.CAU_STR_CA6.Reg, value)
}
func (o *CAU_Type) GetCAU_STR_CA6() uint32 {
	return volatile.LoadUint32(&o.CAU_STR_CA6.Reg)
}

// CAU.CAU_STR_CA7: General Purpose Register 7 - Store Register command
func (o *CAU_Type) SetCAU_STR_CA7(value uint32) {
	volatile.StoreUint32(&o.CAU_STR_CA7.Reg, value)
}
func (o *CAU_Type) GetCAU_STR_CA7() uint32 {
	return volatile.LoadUint32(&o.CAU_STR_CA7.Reg)
}

// CAU.CAU_STR_CA8: General Purpose Register 8 - Store Register command
func (o *CAU_Type) SetCAU_STR_CA8(value uint32) {
	volatile.StoreUint32(&o.CAU_STR_CA8.Reg, value)
}
func (o *CAU_Type) GetCAU_STR_CA8() uint32 {
	return volatile.LoadUint32(&o.CAU_STR_CA8.Reg)
}

// CAU.CAU_ADR_CASR: Status register - Add Register command
func (o *CAU_Type) SetCAU_ADR_CASR_IC(value uint32) {
	volatile.StoreUint32(&o.CAU_ADR_CASR.Reg, volatile.LoadUint32(&o.CAU_ADR_CASR.Reg)&^(0x1)|value)
}
func (o *CAU_Type) GetCAU_ADR_CASR_IC() uint32 {
	return volatile.LoadUint32(&o.CAU_ADR_CASR.Reg) & 0x1
}
func (o *CAU_Type) SetCAU_ADR_CASR_DPE(value uint32) {
	volatile.StoreUint32(&o.CAU_ADR_CASR.Reg, volatile.LoadUint32(&o.CAU_ADR_CASR.Reg)&^(0x2)|value<<1)
}
func (o *CAU_Type) GetCAU_ADR_CASR_DPE() uint32 {
	return (volatile.LoadUint32(&o.CAU_ADR_CASR.Reg) & 0x2) >> 1
}
func (o *CAU_Type) SetCAU_ADR_CASR_VER(value uint32) {
	volatile.StoreUint32(&o.CAU_ADR_CASR.Reg, volatile.LoadUint32(&o.CAU_ADR_CASR.Reg)&^(0xf0000000)|value<<28)
}
func (o *CAU_Type) GetCAU_ADR_CASR_VER() uint32 {
	return (volatile.LoadUint32(&o.CAU_ADR_CASR.Reg) & 0xf0000000) >> 28
}

// CAU.CAU_ADR_CAA: Accumulator register - Add to register command
func (o *CAU_Type) SetCAU_ADR_CAA(value uint32) {
	volatile.StoreUint32(&o.CAU_ADR_CAA.Reg, value)
}
func (o *CAU_Type) GetCAU_ADR_CAA() uint32 {
	return volatile.LoadUint32(&o.CAU_ADR_CAA.Reg)
}

// CAU.CAU_ADR_CA0: General Purpose Register 0 - Add to register command
func (o *CAU_Type) SetCAU_ADR_CA0(value uint32) {
	volatile.StoreUint32(&o.CAU_ADR_CA0.Reg, value)
}
func (o *CAU_Type) GetCAU_ADR_CA0() uint32 {
	return volatile.LoadUint32(&o.CAU_ADR_CA0.Reg)
}

// CAU.CAU_ADR_CA1: General Purpose Register 1 - Add to register command
func (o *CAU_Type) SetCAU_ADR_CA1(value uint32) {
	volatile.StoreUint32(&o.CAU_ADR_CA1.Reg, value)
}
func (o *CAU_Type) GetCAU_ADR_CA1() uint32 {
	return volatile.LoadUint32(&o.CAU_ADR_CA1.Reg)
}

// CAU.CAU_ADR_CA2: General Purpose Register 2 - Add to register command
func (o *CAU_Type) SetCAU_ADR_CA2(value uint32) {
	volatile.StoreUint32(&o.CAU_ADR_CA2.Reg, value)
}
func (o *CAU_Type) GetCAU_ADR_CA2() uint32 {
	return volatile.LoadUint32(&o.CAU_ADR_CA2.Reg)
}

// CAU.CAU_ADR_CA3: General Purpose Register 3 - Add to register command
func (o *CAU_Type) SetCAU_ADR_CA3(value uint32) {
	volatile.StoreUint32(&o.CAU_ADR_CA3.Reg, value)
}
func (o *CAU_Type) GetCAU_ADR_CA3() uint32 {
	return volatile.LoadUint32(&o.CAU_ADR_CA3.Reg)
}

// CAU.CAU_ADR_CA4: General Purpose Register 4 - Add to register command
func (o *CAU_Type) SetCAU_ADR_CA4(value uint32) {
	volatile.StoreUint32(&o.CAU_ADR_CA4.Reg, value)
}
func (o *CAU_Type) GetCAU_ADR_CA4() uint32 {
	return volatile.LoadUint32(&o.CAU_ADR_CA4.Reg)
}

// CAU.CAU_ADR_CA5: General Purpose Register 5 - Add to register command
func (o *CAU_Type) SetCAU_ADR_CA5(value uint32) {
	volatile.StoreUint32(&o.CAU_ADR_CA5.Reg, value)
}
func (o *CAU_Type) GetCAU_ADR_CA5() uint32 {
	return volatile.LoadUint32(&o.CAU_ADR_CA5.Reg)
}

// CAU.CAU_ADR_CA6: General Purpose Register 6 - Add to register command
func (o *CAU_Type) SetCAU_ADR_CA6(value uint32) {
	volatile.StoreUint32(&o.CAU_ADR_CA6.Reg, value)
}
func (o *CAU_Type) GetCAU_ADR_CA6() uint32 {
	return volatile.LoadUint32(&o.CAU_ADR_CA6.Reg)
}

// CAU.CAU_ADR_CA7: General Purpose Register 7 - Add to register command
func (o *CAU_Type) SetCAU_ADR_CA7(value uint32) {
	volatile.StoreUint32(&o.CAU_ADR_CA7.Reg, value)
}
func (o *CAU_Type) GetCAU_ADR_CA7() uint32 {
	return volatile.LoadUint32(&o.CAU_ADR_CA7.Reg)
}

// CAU.CAU_ADR_CA8: General Purpose Register 8 - Add to register command
func (o *CAU_Type) SetCAU_ADR_CA8(value uint32) {
	volatile.StoreUint32(&o.CAU_ADR_CA8.Reg, value)
}
func (o *CAU_Type) GetCAU_ADR_CA8() uint32 {
	return volatile.LoadUint32(&o.CAU_ADR_CA8.Reg)
}

// CAU.CAU_RADR_CASR: Status register - Reverse and Add to Register command
func (o *CAU_Type) SetCAU_RADR_CASR_IC(value uint32) {
	volatile.StoreUint32(&o.CAU_RADR_CASR.Reg, volatile.LoadUint32(&o.CAU_RADR_CASR.Reg)&^(0x1)|value)
}
func (o *CAU_Type) GetCAU_RADR_CASR_IC() uint32 {
	return volatile.LoadUint32(&o.CAU_RADR_CASR.Reg) & 0x1
}
func (o *CAU_Type) SetCAU_RADR_CASR_DPE(value uint32) {
	volatile.StoreUint32(&o.CAU_RADR_CASR.Reg, volatile.LoadUint32(&o.CAU_RADR_CASR.Reg)&^(0x2)|value<<1)
}
func (o *CAU_Type) GetCAU_RADR_CASR_DPE() uint32 {
	return (volatile.LoadUint32(&o.CAU_RADR_CASR.Reg) & 0x2) >> 1
}
func (o *CAU_Type) SetCAU_RADR_CASR_VER(value uint32) {
	volatile.StoreUint32(&o.CAU_RADR_CASR.Reg, volatile.LoadUint32(&o.CAU_RADR_CASR.Reg)&^(0xf0000000)|value<<28)
}
func (o *CAU_Type) GetCAU_RADR_CASR_VER() uint32 {
	return (volatile.LoadUint32(&o.CAU_RADR_CASR.Reg) & 0xf0000000) >> 28
}

// CAU.CAU_RADR_CAA: Accumulator register - Reverse and Add to Register command
func (o *CAU_Type) SetCAU_RADR_CAA(value uint32) {
	volatile.StoreUint32(&o.CAU_RADR_CAA.Reg, value)
}
func (o *CAU_Type) GetCAU_RADR_CAA() uint32 {
	return volatile.LoadUint32(&o.CAU_RADR_CAA.Reg)
}

// CAU.CAU_RADR_CA0: General Purpose Register 0 - Reverse and Add to Register command
func (o *CAU_Type) SetCAU_RADR_CA0(value uint32) {
	volatile.StoreUint32(&o.CAU_RADR_CA0.Reg, value)
}
func (o *CAU_Type) GetCAU_RADR_CA0() uint32 {
	return volatile.LoadUint32(&o.CAU_RADR_CA0.Reg)
}

// CAU.CAU_RADR_CA1: General Purpose Register 1 - Reverse and Add to Register command
func (o *CAU_Type) SetCAU_RADR_CA1(value uint32) {
	volatile.StoreUint32(&o.CAU_RADR_CA1.Reg, value)
}
func (o *CAU_Type) GetCAU_RADR_CA1() uint32 {
	return volatile.LoadUint32(&o.CAU_RADR_CA1.Reg)
}

// CAU.CAU_RADR_CA2: General Purpose Register 2 - Reverse and Add to Register command
func (o *CAU_Type) SetCAU_RADR_CA2(value uint32) {
	volatile.StoreUint32(&o.CAU_RADR_CA2.Reg, value)
}
func (o *CAU_Type) GetCAU_RADR_CA2() uint32 {
	return volatile.LoadUint32(&o.CAU_RADR_CA2.Reg)
}

// CAU.CAU_RADR_CA3: General Purpose Register 3 - Reverse and Add to Register command
func (o *CAU_Type) SetCAU_RADR_CA3(value uint32) {
	volatile.StoreUint32(&o.CAU_RADR_CA3.Reg, value)
}
func (o *CAU_Type) GetCAU_RADR_CA3() uint32 {
	return volatile.LoadUint32(&o.CAU_RADR_CA3.Reg)
}

// CAU.CAU_RADR_CA4: General Purpose Register 4 - Reverse and Add to Register command
func (o *CAU_Type) SetCAU_RADR_CA4(value uint32) {
	volatile.StoreUint32(&o.CAU_RADR_CA4.Reg, value)
}
func (o *CAU_Type) GetCAU_RADR_CA4() uint32 {
	return volatile.LoadUint32(&o.CAU_RADR_CA4.Reg)
}

// CAU.CAU_RADR_CA5: General Purpose Register 5 - Reverse and Add to Register command
func (o *CAU_Type) SetCAU_RADR_CA5(value uint32) {
	volatile.StoreUint32(&o.CAU_RADR_CA5.Reg, value)
}
func (o *CAU_Type) GetCAU_RADR_CA5() uint32 {
	return volatile.LoadUint32(&o.CAU_RADR_CA5.Reg)
}

// CAU.CAU_RADR_CA6: General Purpose Register 6 - Reverse and Add to Register command
func (o *CAU_Type) SetCAU_RADR_CA6(value uint32) {
	volatile.StoreUint32(&o.CAU_RADR_CA6.Reg, value)
}
func (o *CAU_Type) GetCAU_RADR_CA6() uint32 {
	return volatile.LoadUint32(&o.CAU_RADR_CA6.Reg)
}

// CAU.CAU_RADR_CA7: General Purpose Register 7 - Reverse and Add to Register command
func (o *CAU_Type) SetCAU_RADR_CA7(value uint32) {
	volatile.StoreUint32(&o.CAU_RADR_CA7.Reg, value)
}
func (o *CAU_Type) GetCAU_RADR_CA7() uint32 {
	return volatile.LoadUint32(&o.CAU_RADR_CA7.Reg)
}

// CAU.CAU_RADR_CA8: General Purpose Register 8 - Reverse and Add to Register command
func (o *CAU_Type) SetCAU_RADR_CA8(value uint32) {
	volatile.StoreUint32(&o.CAU_RADR_CA8.Reg, value)
}
func (o *CAU_Type) GetCAU_RADR_CA8() uint32 {
	return volatile.LoadUint32(&o.CAU_RADR_CA8.Reg)
}

// CAU.CAU_XOR_CASR: Status register - Exclusive Or command
func (o *CAU_Type) SetCAU_XOR_CASR_IC(value uint32) {
	volatile.StoreUint32(&o.CAU_XOR_CASR.Reg, volatile.LoadUint32(&o.CAU_XOR_CASR.Reg)&^(0x1)|value)
}
func (o *CAU_Type) GetCAU_XOR_CASR_IC() uint32 {
	return volatile.LoadUint32(&o.CAU_XOR_CASR.Reg) & 0x1
}
func (o *CAU_Type) SetCAU_XOR_CASR_DPE(value uint32) {
	volatile.StoreUint32(&o.CAU_XOR_CASR.Reg, volatile.LoadUint32(&o.CAU_XOR_CASR.Reg)&^(0x2)|value<<1)
}
func (o *CAU_Type) GetCAU_XOR_CASR_DPE() uint32 {
	return (volatile.LoadUint32(&o.CAU_XOR_CASR.Reg) & 0x2) >> 1
}
func (o *CAU_Type) SetCAU_XOR_CASR_VER(value uint32) {
	volatile.StoreUint32(&o.CAU_XOR_CASR.Reg, volatile.LoadUint32(&o.CAU_XOR_CASR.Reg)&^(0xf0000000)|value<<28)
}
func (o *CAU_Type) GetCAU_XOR_CASR_VER() uint32 {
	return (volatile.LoadUint32(&o.CAU_XOR_CASR.Reg) & 0xf0000000) >> 28
}

// CAU.CAU_XOR_CAA: Accumulator register - Exclusive Or command
func (o *CAU_Type) SetCAU_XOR_CAA(value uint32) {
	volatile.StoreUint32(&o.CAU_XOR_CAA.Reg, value)
}
func (o *CAU_Type) GetCAU_XOR_CAA() uint32 {
	return volatile.LoadUint32(&o.CAU_XOR_CAA.Reg)
}

// CAU.CAU_XOR_CA0: General Purpose Register 0 - Exclusive Or command
func (o *CAU_Type) SetCAU_XOR_CA0(value uint32) {
	volatile.StoreUint32(&o.CAU_XOR_CA0.Reg, value)
}
func (o *CAU_Type) GetCAU_XOR_CA0() uint32 {
	return volatile.LoadUint32(&o.CAU_XOR_CA0.Reg)
}

// CAU.CAU_XOR_CA1: General Purpose Register 1 - Exclusive Or command
func (o *CAU_Type) SetCAU_XOR_CA1(value uint32) {
	volatile.StoreUint32(&o.CAU_XOR_CA1.Reg, value)
}
func (o *CAU_Type) GetCAU_XOR_CA1() uint32 {
	return volatile.LoadUint32(&o.CAU_XOR_CA1.Reg)
}

// CAU.CAU_XOR_CA2: General Purpose Register 2 - Exclusive Or command
func (o *CAU_Type) SetCAU_XOR_CA2(value uint32) {
	volatile.StoreUint32(&o.CAU_XOR_CA2.Reg, value)
}
func (o *CAU_Type) GetCAU_XOR_CA2() uint32 {
	return volatile.LoadUint32(&o.CAU_XOR_CA2.Reg)
}

// CAU.CAU_XOR_CA3: General Purpose Register 3 - Exclusive Or command
func (o *CAU_Type) SetCAU_XOR_CA3(value uint32) {
	volatile.StoreUint32(&o.CAU_XOR_CA3.Reg, value)
}
func (o *CAU_Type) GetCAU_XOR_CA3() uint32 {
	return volatile.LoadUint32(&o.CAU_XOR_CA3.Reg)
}

// CAU.CAU_XOR_CA4: General Purpose Register 4 - Exclusive Or command
func (o *CAU_Type) SetCAU_XOR_CA4(value uint32) {
	volatile.StoreUint32(&o.CAU_XOR_CA4.Reg, value)
}
func (o *CAU_Type) GetCAU_XOR_CA4() uint32 {
	return volatile.LoadUint32(&o.CAU_XOR_CA4.Reg)
}

// CAU.CAU_XOR_CA5: General Purpose Register 5 - Exclusive Or command
func (o *CAU_Type) SetCAU_XOR_CA5(value uint32) {
	volatile.StoreUint32(&o.CAU_XOR_CA5.Reg, value)
}
func (o *CAU_Type) GetCAU_XOR_CA5() uint32 {
	return volatile.LoadUint32(&o.CAU_XOR_CA5.Reg)
}

// CAU.CAU_XOR_CA6: General Purpose Register 6 - Exclusive Or command
func (o *CAU_Type) SetCAU_XOR_CA6(value uint32) {
	volatile.StoreUint32(&o.CAU_XOR_CA6.Reg, value)
}
func (o *CAU_Type) GetCAU_XOR_CA6() uint32 {
	return volatile.LoadUint32(&o.CAU_XOR_CA6.Reg)
}

// CAU.CAU_XOR_CA7: General Purpose Register 7 - Exclusive Or command
func (o *CAU_Type) SetCAU_XOR_CA7(value uint32) {
	volatile.StoreUint32(&o.CAU_XOR_CA7.Reg, value)
}
func (o *CAU_Type) GetCAU_XOR_CA7() uint32 {
	return volatile.LoadUint32(&o.CAU_XOR_CA7.Reg)
}

// CAU.CAU_XOR_CA8: General Purpose Register 8 - Exclusive Or command
func (o *CAU_Type) SetCAU_XOR_CA8(value uint32) {
	volatile.StoreUint32(&o.CAU_XOR_CA8.Reg, value)
}
func (o *CAU_Type) GetCAU_XOR_CA8() uint32 {
	return volatile.LoadUint32(&o.CAU_XOR_CA8.Reg)
}

// CAU.CAU_ROTL_CASR: Status register - Rotate Left command
func (o *CAU_Type) SetCAU_ROTL_CASR_IC(value uint32) {
	volatile.StoreUint32(&o.CAU_ROTL_CASR.Reg, volatile.LoadUint32(&o.CAU_ROTL_CASR.Reg)&^(0x1)|value)
}
func (o *CAU_Type) GetCAU_ROTL_CASR_IC() uint32 {
	return volatile.LoadUint32(&o.CAU_ROTL_CASR.Reg) & 0x1
}
func (o *CAU_Type) SetCAU_ROTL_CASR_DPE(value uint32) {
	volatile.StoreUint32(&o.CAU_ROTL_CASR.Reg, volatile.LoadUint32(&o.CAU_ROTL_CASR.Reg)&^(0x2)|value<<1)
}
func (o *CAU_Type) GetCAU_ROTL_CASR_DPE() uint32 {
	return (volatile.LoadUint32(&o.CAU_ROTL_CASR.Reg) & 0x2) >> 1
}
func (o *CAU_Type) SetCAU_ROTL_CASR_VER(value uint32) {
	volatile.StoreUint32(&o.CAU_ROTL_CASR.Reg, volatile.LoadUint32(&o.CAU_ROTL_CASR.Reg)&^(0xf0000000)|value<<28)
}
func (o *CAU_Type) GetCAU_ROTL_CASR_VER() uint32 {
	return (volatile.LoadUint32(&o.CAU_ROTL_CASR.Reg) & 0xf0000000) >> 28
}

// CAU.CAU_ROTL_CAA: Accumulator register - Rotate Left command
func (o *CAU_Type) SetCAU_ROTL_CAA(value uint32) {
	volatile.StoreUint32(&o.CAU_ROTL_CAA.Reg, value)
}
func (o *CAU_Type) GetCAU_ROTL_CAA() uint32 {
	return volatile.LoadUint32(&o.CAU_ROTL_CAA.Reg)
}

// CAU.CAU_ROTL_CA0: General Purpose Register 0 - Rotate Left command
func (o *CAU_Type) SetCAU_ROTL_CA0(value uint32) {
	volatile.StoreUint32(&o.CAU_ROTL_CA0.Reg, value)
}
func (o *CAU_Type) GetCAU_ROTL_CA0() uint32 {
	return volatile.LoadUint32(&o.CAU_ROTL_CA0.Reg)
}

// CAU.CAU_ROTL_CA1: General Purpose Register 1 - Rotate Left command
func (o *CAU_Type) SetCAU_ROTL_CA1(value uint32) {
	volatile.StoreUint32(&o.CAU_ROTL_CA1.Reg, value)
}
func (o *CAU_Type) GetCAU_ROTL_CA1() uint32 {
	return volatile.LoadUint32(&o.CAU_ROTL_CA1.Reg)
}

// CAU.CAU_ROTL_CA2: General Purpose Register 2 - Rotate Left command
func (o *CAU_Type) SetCAU_ROTL_CA2(value uint32) {
	volatile.StoreUint32(&o.CAU_ROTL_CA2.Reg, value)
}
func (o *CAU_Type) GetCAU_ROTL_CA2() uint32 {
	return volatile.LoadUint32(&o.CAU_ROTL_CA2.Reg)
}

// CAU.CAU_ROTL_CA3: General Purpose Register 3 - Rotate Left command
func (o *CAU_Type) SetCAU_ROTL_CA3(value uint32) {
	volatile.StoreUint32(&o.CAU_ROTL_CA3.Reg, value)
}
func (o *CAU_Type) GetCAU_ROTL_CA3() uint32 {
	return volatile.LoadUint32(&o.CAU_ROTL_CA3.Reg)
}

// CAU.CAU_ROTL_CA4: General Purpose Register 4 - Rotate Left command
func (o *CAU_Type) SetCAU_ROTL_CA4(value uint32) {
	volatile.StoreUint32(&o.CAU_ROTL_CA4.Reg, value)
}
func (o *CAU_Type) GetCAU_ROTL_CA4() uint32 {
	return volatile.LoadUint32(&o.CAU_ROTL_CA4.Reg)
}

// CAU.CAU_ROTL_CA5: General Purpose Register 5 - Rotate Left command
func (o *CAU_Type) SetCAU_ROTL_CA5(value uint32) {
	volatile.StoreUint32(&o.CAU_ROTL_CA5.Reg, value)
}
func (o *CAU_Type) GetCAU_ROTL_CA5() uint32 {
	return volatile.LoadUint32(&o.CAU_ROTL_CA5.Reg)
}

// CAU.CAU_ROTL_CA6: General Purpose Register 6 - Rotate Left command
func (o *CAU_Type) SetCAU_ROTL_CA6(value uint32) {
	volatile.StoreUint32(&o.CAU_ROTL_CA6.Reg, value)
}
func (o *CAU_Type) GetCAU_ROTL_CA6() uint32 {
	return volatile.LoadUint32(&o.CAU_ROTL_CA6.Reg)
}

// CAU.CAU_ROTL_CA7: General Purpose Register 7 - Rotate Left command
func (o *CAU_Type) SetCAU_ROTL_CA7(value uint32) {
	volatile.StoreUint32(&o.CAU_ROTL_CA7.Reg, value)
}
func (o *CAU_Type) GetCAU_ROTL_CA7() uint32 {
	return volatile.LoadUint32(&o.CAU_ROTL_CA7.Reg)
}

// CAU.CAU_ROTL_CA8: General Purpose Register 8 - Rotate Left command
func (o *CAU_Type) SetCAU_ROTL_CA8(value uint32) {
	volatile.StoreUint32(&o.CAU_ROTL_CA8.Reg, value)
}
func (o *CAU_Type) GetCAU_ROTL_CA8() uint32 {
	return volatile.LoadUint32(&o.CAU_ROTL_CA8.Reg)
}

// CAU.CAU_AESC_CASR: Status register - AES Column Operation command
func (o *CAU_Type) SetCAU_AESC_CASR_IC(value uint32) {
	volatile.StoreUint32(&o.CAU_AESC_CASR.Reg, volatile.LoadUint32(&o.CAU_AESC_CASR.Reg)&^(0x1)|value)
}
func (o *CAU_Type) GetCAU_AESC_CASR_IC() uint32 {
	return volatile.LoadUint32(&o.CAU_AESC_CASR.Reg) & 0x1
}
func (o *CAU_Type) SetCAU_AESC_CASR_DPE(value uint32) {
	volatile.StoreUint32(&o.CAU_AESC_CASR.Reg, volatile.LoadUint32(&o.CAU_AESC_CASR.Reg)&^(0x2)|value<<1)
}
func (o *CAU_Type) GetCAU_AESC_CASR_DPE() uint32 {
	return (volatile.LoadUint32(&o.CAU_AESC_CASR.Reg) & 0x2) >> 1
}
func (o *CAU_Type) SetCAU_AESC_CASR_VER(value uint32) {
	volatile.StoreUint32(&o.CAU_AESC_CASR.Reg, volatile.LoadUint32(&o.CAU_AESC_CASR.Reg)&^(0xf0000000)|value<<28)
}
func (o *CAU_Type) GetCAU_AESC_CASR_VER() uint32 {
	return (volatile.LoadUint32(&o.CAU_AESC_CASR.Reg) & 0xf0000000) >> 28
}

// CAU.CAU_AESC_CAA: Accumulator register - AES Column Operation command
func (o *CAU_Type) SetCAU_AESC_CAA(value uint32) {
	volatile.StoreUint32(&o.CAU_AESC_CAA.Reg, value)
}
func (o *CAU_Type) GetCAU_AESC_CAA() uint32 {
	return volatile.LoadUint32(&o.CAU_AESC_CAA.Reg)
}

// CAU.CAU_AESC_CA0: General Purpose Register 0 - AES Column Operation command
func (o *CAU_Type) SetCAU_AESC_CA0(value uint32) {
	volatile.StoreUint32(&o.CAU_AESC_CA0.Reg, value)
}
func (o *CAU_Type) GetCAU_AESC_CA0() uint32 {
	return volatile.LoadUint32(&o.CAU_AESC_CA0.Reg)
}

// CAU.CAU_AESC_CA1: General Purpose Register 1 - AES Column Operation command
func (o *CAU_Type) SetCAU_AESC_CA1(value uint32) {
	volatile.StoreUint32(&o.CAU_AESC_CA1.Reg, value)
}
func (o *CAU_Type) GetCAU_AESC_CA1() uint32 {
	return volatile.LoadUint32(&o.CAU_AESC_CA1.Reg)
}

// CAU.CAU_AESC_CA2: General Purpose Register 2 - AES Column Operation command
func (o *CAU_Type) SetCAU_AESC_CA2(value uint32) {
	volatile.StoreUint32(&o.CAU_AESC_CA2.Reg, value)
}
func (o *CAU_Type) GetCAU_AESC_CA2() uint32 {
	return volatile.LoadUint32(&o.CAU_AESC_CA2.Reg)
}

// CAU.CAU_AESC_CA3: General Purpose Register 3 - AES Column Operation command
func (o *CAU_Type) SetCAU_AESC_CA3(value uint32) {
	volatile.StoreUint32(&o.CAU_AESC_CA3.Reg, value)
}
func (o *CAU_Type) GetCAU_AESC_CA3() uint32 {
	return volatile.LoadUint32(&o.CAU_AESC_CA3.Reg)
}

// CAU.CAU_AESC_CA4: General Purpose Register 4 - AES Column Operation command
func (o *CAU_Type) SetCAU_AESC_CA4(value uint32) {
	volatile.StoreUint32(&o.CAU_AESC_CA4.Reg, value)
}
func (o *CAU_Type) GetCAU_AESC_CA4() uint32 {
	return volatile.LoadUint32(&o.CAU_AESC_CA4.Reg)
}

// CAU.CAU_AESC_CA5: General Purpose Register 5 - AES Column Operation command
func (o *CAU_Type) SetCAU_AESC_CA5(value uint32) {
	volatile.StoreUint32(&o.CAU_AESC_CA5.Reg, value)
}
func (o *CAU_Type) GetCAU_AESC_CA5() uint32 {
	return volatile.LoadUint32(&o.CAU_AESC_CA5.Reg)
}

// CAU.CAU_AESC_CA6: General Purpose Register 6 - AES Column Operation command
func (o *CAU_Type) SetCAU_AESC_CA6(value uint32) {
	volatile.StoreUint32(&o.CAU_AESC_CA6.Reg, value)
}
func (o *CAU_Type) GetCAU_AESC_CA6() uint32 {
	return volatile.LoadUint32(&o.CAU_AESC_CA6.Reg)
}

// CAU.CAU_AESC_CA7: General Purpose Register 7 - AES Column Operation command
func (o *CAU_Type) SetCAU_AESC_CA7(value uint32) {
	volatile.StoreUint32(&o.CAU_AESC_CA7.Reg, value)
}
func (o *CAU_Type) GetCAU_AESC_CA7() uint32 {
	return volatile.LoadUint32(&o.CAU_AESC_CA7.Reg)
}

// CAU.CAU_AESC_CA8: General Purpose Register 8 - AES Column Operation command
func (o *CAU_Type) SetCAU_AESC_CA8(value uint32) {
	volatile.StoreUint32(&o.CAU_AESC_CA8.Reg, value)
}
func (o *CAU_Type) GetCAU_AESC_CA8() uint32 {
	return volatile.LoadUint32(&o.CAU_AESC_CA8.Reg)
}

// CAU.CAU_AESIC_CASR: Status register - AES Inverse Column Operation command
func (o *CAU_Type) SetCAU_AESIC_CASR_IC(value uint32) {
	volatile.StoreUint32(&o.CAU_AESIC_CASR.Reg, volatile.LoadUint32(&o.CAU_AESIC_CASR.Reg)&^(0x1)|value)
}
func (o *CAU_Type) GetCAU_AESIC_CASR_IC() uint32 {
	return volatile.LoadUint32(&o.CAU_AESIC_CASR.Reg) & 0x1
}
func (o *CAU_Type) SetCAU_AESIC_CASR_DPE(value uint32) {
	volatile.StoreUint32(&o.CAU_AESIC_CASR.Reg, volatile.LoadUint32(&o.CAU_AESIC_CASR.Reg)&^(0x2)|value<<1)
}
func (o *CAU_Type) GetCAU_AESIC_CASR_DPE() uint32 {
	return (volatile.LoadUint32(&o.CAU_AESIC_CASR.Reg) & 0x2) >> 1
}
func (o *CAU_Type) SetCAU_AESIC_CASR_VER(value uint32) {
	volatile.StoreUint32(&o.CAU_AESIC_CASR.Reg, volatile.LoadUint32(&o.CAU_AESIC_CASR.Reg)&^(0xf0000000)|value<<28)
}
func (o *CAU_Type) GetCAU_AESIC_CASR_VER() uint32 {
	return (volatile.LoadUint32(&o.CAU_AESIC_CASR.Reg) & 0xf0000000) >> 28
}

// CAU.CAU_AESIC_CAA: Accumulator register - AES Inverse Column Operation command
func (o *CAU_Type) SetCAU_AESIC_CAA(value uint32) {
	volatile.StoreUint32(&o.CAU_AESIC_CAA.Reg, value)
}
func (o *CAU_Type) GetCAU_AESIC_CAA() uint32 {
	return volatile.LoadUint32(&o.CAU_AESIC_CAA.Reg)
}

// CAU.CAU_AESIC_CA0: General Purpose Register 0 - AES Inverse Column Operation command
func (o *CAU_Type) SetCAU_AESIC_CA0(value uint32) {
	volatile.StoreUint32(&o.CAU_AESIC_CA0.Reg, value)
}
func (o *CAU_Type) GetCAU_AESIC_CA0() uint32 {
	return volatile.LoadUint32(&o.CAU_AESIC_CA0.Reg)
}

// CAU.CAU_AESIC_CA1: General Purpose Register 1 - AES Inverse Column Operation command
func (o *CAU_Type) SetCAU_AESIC_CA1(value uint32) {
	volatile.StoreUint32(&o.CAU_AESIC_CA1.Reg, value)
}
func (o *CAU_Type) GetCAU_AESIC_CA1() uint32 {
	return volatile.LoadUint32(&o.CAU_AESIC_CA1.Reg)
}

// CAU.CAU_AESIC_CA2: General Purpose Register 2 - AES Inverse Column Operation command
func (o *CAU_Type) SetCAU_AESIC_CA2(value uint32) {
	volatile.StoreUint32(&o.CAU_AESIC_CA2.Reg, value)
}
func (o *CAU_Type) GetCAU_AESIC_CA2() uint32 {
	return volatile.LoadUint32(&o.CAU_AESIC_CA2.Reg)
}

// CAU.CAU_AESIC_CA3: General Purpose Register 3 - AES Inverse Column Operation command
func (o *CAU_Type) SetCAU_AESIC_CA3(value uint32) {
	volatile.StoreUint32(&o.CAU_AESIC_CA3.Reg, value)
}
func (o *CAU_Type) GetCAU_AESIC_CA3() uint32 {
	return volatile.LoadUint32(&o.CAU_AESIC_CA3.Reg)
}

// CAU.CAU_AESIC_CA4: General Purpose Register 4 - AES Inverse Column Operation command
func (o *CAU_Type) SetCAU_AESIC_CA4(value uint32) {
	volatile.StoreUint32(&o.CAU_AESIC_CA4.Reg, value)
}
func (o *CAU_Type) GetCAU_AESIC_CA4() uint32 {
	return volatile.LoadUint32(&o.CAU_AESIC_CA4.Reg)
}

// CAU.CAU_AESIC_CA5: General Purpose Register 5 - AES Inverse Column Operation command
func (o *CAU_Type) SetCAU_AESIC_CA5(value uint32) {
	volatile.StoreUint32(&o.CAU_AESIC_CA5.Reg, value)
}
func (o *CAU_Type) GetCAU_AESIC_CA5() uint32 {
	return volatile.LoadUint32(&o.CAU_AESIC_CA5.Reg)
}

// CAU.CAU_AESIC_CA6: General Purpose Register 6 - AES Inverse Column Operation command
func (o *CAU_Type) SetCAU_AESIC_CA6(value uint32) {
	volatile.StoreUint32(&o.CAU_AESIC_CA6.Reg, value)
}
func (o *CAU_Type) GetCAU_AESIC_CA6() uint32 {
	return volatile.LoadUint32(&o.CAU_AESIC_CA6.Reg)
}

// CAU.CAU_AESIC_CA7: General Purpose Register 7 - AES Inverse Column Operation command
func (o *CAU_Type) SetCAU_AESIC_CA7(value uint32) {
	volatile.StoreUint32(&o.CAU_AESIC_CA7.Reg, value)
}
func (o *CAU_Type) GetCAU_AESIC_CA7() uint32 {
	return volatile.LoadUint32(&o.CAU_AESIC_CA7.Reg)
}

// CAU.CAU_AESIC_CA8: General Purpose Register 8 - AES Inverse Column Operation command
func (o *CAU_Type) SetCAU_AESIC_CA8(value uint32) {
	volatile.StoreUint32(&o.CAU_AESIC_CA8.Reg, value)
}
func (o *CAU_Type) GetCAU_AESIC_CA8() uint32 {
	return volatile.LoadUint32(&o.CAU_AESIC_CA8.Reg)
}

// Constants for FTFE_FlashConfig: Flash configuration field
const (
	// BACKKEY3: Backdoor Comparison Key 3.
	// Position of KEY field.
	FTFE_FlashConfig_BACKKEY3_KEY_Pos = 0x0
	// Bit mask of KEY field.
	FTFE_FlashConfig_BACKKEY3_KEY_Msk = 0xff

	// BACKKEY2: Backdoor Comparison Key 2.
	// Position of KEY field.
	FTFE_FlashConfig_BACKKEY2_KEY_Pos = 0x0
	// Bit mask of KEY field.
	FTFE_FlashConfig_BACKKEY2_KEY_Msk = 0xff

	// BACKKEY1: Backdoor Comparison Key 1.
	// Position of KEY field.
	FTFE_FlashConfig_BACKKEY1_KEY_Pos = 0x0
	// Bit mask of KEY field.
	FTFE_FlashConfig_BACKKEY1_KEY_Msk = 0xff

	// BACKKEY0: Backdoor Comparison Key 0.
	// Position of KEY field.
	FTFE_FlashConfig_BACKKEY0_KEY_Pos = 0x0
	// Bit mask of KEY field.
	FTFE_FlashConfig_BACKKEY0_KEY_Msk = 0xff

	// BACKKEY7: Backdoor Comparison Key 7.
	// Position of KEY field.
	FTFE_FlashConfig_BACKKEY7_KEY_Pos = 0x0
	// Bit mask of KEY field.
	FTFE_FlashConfig_BACKKEY7_KEY_Msk = 0xff

	// BACKKEY6: Backdoor Comparison Key 6.
	// Position of KEY field.
	FTFE_FlashConfig_BACKKEY6_KEY_Pos = 0x0
	// Bit mask of KEY field.
	FTFE_FlashConfig_BACKKEY6_KEY_Msk = 0xff

	// BACKKEY5: Backdoor Comparison Key 5.
	// Position of KEY field.
	FTFE_FlashConfig_BACKKEY5_KEY_Pos = 0x0
	// Bit mask of KEY field.
	FTFE_FlashConfig_BACKKEY5_KEY_Msk = 0xff

	// BACKKEY4: Backdoor Comparison Key 4.
	// Position of KEY field.
	FTFE_FlashConfig_BACKKEY4_KEY_Pos = 0x0
	// Bit mask of KEY field.
	FTFE_FlashConfig_BACKKEY4_KEY_Msk = 0xff

	// FPROT3: Non-volatile P-Flash Protection 1 - Low Register
	// Position of PROT field.
	FTFE_FlashConfig_FPROT3_PROT_Pos = 0x0
	// Bit mask of PROT field.
	FTFE_FlashConfig_FPROT3_PROT_Msk = 0xff

	// FPROT2: Non-volatile P-Flash Protection 1 - High Register
	// Position of PROT field.
	FTFE_FlashConfig_FPROT2_PROT_Pos = 0x0
	// Bit mask of PROT field.
	FTFE_FlashConfig_FPROT2_PROT_Msk = 0xff

	// FPROT1: Non-volatile P-Flash Protection 0 - Low Register
	// Position of PROT field.
	FTFE_FlashConfig_FPROT1_PROT_Pos = 0x0
	// Bit mask of PROT field.
	FTFE_FlashConfig_FPROT1_PROT_Msk = 0xff

	// FPROT0: Non-volatile P-Flash Protection 0 - High Register
	// Position of PROT field.
	FTFE_FlashConfig_FPROT0_PROT_Pos = 0x0
	// Bit mask of PROT field.
	FTFE_FlashConfig_FPROT0_PROT_Msk = 0xff

	// FSEC: Non-volatile Flash Security Register
	// Position of SEC field.
	FTFE_FlashConfig_FSEC_SEC_Pos = 0x0
	// Bit mask of SEC field.
	FTFE_FlashConfig_FSEC_SEC_Msk = 0x3
	// MCU security status is unsecure
	FTFE_FlashConfig_FSEC_SEC_10 = 0x2
	// MCU security status is secure
	FTFE_FlashConfig_FSEC_SEC_11 = 0x3
	// Position of FSLACC field.
	FTFE_FlashConfig_FSEC_FSLACC_Pos = 0x2
	// Bit mask of FSLACC field.
	FTFE_FlashConfig_FSEC_FSLACC_Msk = 0xc
	// Freescale factory access denied
	FTFE_FlashConfig_FSEC_FSLACC_10 = 0x2
	// Freescale factory access granted
	FTFE_FlashConfig_FSEC_FSLACC_11 = 0x3
	// Position of MEEN field.
	FTFE_FlashConfig_FSEC_MEEN_Pos = 0x4
	// Bit mask of MEEN field.
	FTFE_FlashConfig_FSEC_MEEN_Msk = 0x30
	// Mass erase is disabled
	FTFE_FlashConfig_FSEC_MEEN_10 = 0x2
	// Mass erase is enabled
	FTFE_FlashConfig_FSEC_MEEN_11 = 0x3
	// Position of KEYEN field.
	FTFE_FlashConfig_FSEC_KEYEN_Pos = 0x6
	// Bit mask of KEYEN field.
	FTFE_FlashConfig_FSEC_KEYEN_Msk = 0xc0
	// Backdoor key access enabled
	FTFE_FlashConfig_FSEC_KEYEN_10 = 0x2
	// Backdoor key access disabled
	FTFE_FlashConfig_FSEC_KEYEN_11 = 0x3

	// FOPT: Non-volatile Flash Option Register
	// Position of LPBOOT field.
	FTFE_FlashConfig_FOPT_LPBOOT_Pos = 0x0
	// Bit mask of LPBOOT field.
	FTFE_FlashConfig_FOPT_LPBOOT_Msk = 0x1
	// Bit LPBOOT.
	FTFE_FlashConfig_FOPT_LPBOOT = 0x1
	// Low-power boot
	FTFE_FlashConfig_FOPT_LPBOOT_00 = 0x0
	// Normal boot
	FTFE_FlashConfig_FOPT_LPBOOT_01 = 0x1
	// Position of EZPORT_DIS field.
	FTFE_FlashConfig_FOPT_EZPORT_DIS_Pos = 0x1
	// Bit mask of EZPORT_DIS field.
	FTFE_FlashConfig_FOPT_EZPORT_DIS_Msk = 0x2
	// Bit EZPORT_DIS.
	FTFE_FlashConfig_FOPT_EZPORT_DIS = 0x2
	// EzPort operation is disabled
	FTFE_FlashConfig_FOPT_EZPORT_DIS_00 = 0x0
	// EzPort operation is enabled
	FTFE_FlashConfig_FOPT_EZPORT_DIS_01 = 0x1

	// FEPROT: Non-volatile EERAM Protection Register
	// Position of EPROT field.
	FTFE_FlashConfig_FEPROT_EPROT_Pos = 0x0
	// Bit mask of EPROT field.
	FTFE_FlashConfig_FEPROT_EPROT_Msk = 0xff

	// FDPROT: Non-volatile D-Flash Protection Register
	// Position of DPROT field.
	FTFE_FlashConfig_FDPROT_DPROT_Pos = 0x0
	// Bit mask of DPROT field.
	FTFE_FlashConfig_FDPROT_DPROT_Msk = 0xff
)

// Constants for AIPS0: AIPS-Lite Bridge
const (
	// MPRA: Master Privilege Register A
	// Position of MPL5 field.
	AIPS_MPRA_MPL5_Pos = 0x8
	// Bit mask of MPL5 field.
	AIPS_MPRA_MPL5_Msk = 0x100
	// Bit MPL5.
	AIPS_MPRA_MPL5 = 0x100
	// Accesses from this master are forced to user-mode.
	AIPS_MPRA_MPL5_0 = 0x0
	// Accesses from this master are not forced to user-mode.
	AIPS_MPRA_MPL5_1 = 0x1
	// Position of MTW5 field.
	AIPS_MPRA_MTW5_Pos = 0x9
	// Bit mask of MTW5 field.
	AIPS_MPRA_MTW5_Msk = 0x200
	// Bit MTW5.
	AIPS_MPRA_MTW5 = 0x200
	// This master is not trusted for write accesses.
	AIPS_MPRA_MTW5_0 = 0x0
	// This master is trusted for write accesses.
	AIPS_MPRA_MTW5_1 = 0x1
	// Position of MTR5 field.
	AIPS_MPRA_MTR5_Pos = 0xa
	// Bit mask of MTR5 field.
	AIPS_MPRA_MTR5_Msk = 0x400
	// Bit MTR5.
	AIPS_MPRA_MTR5 = 0x400
	// This master is not trusted for read accesses.
	AIPS_MPRA_MTR5_0 = 0x0
	// This master is trusted for read accesses.
	AIPS_MPRA_MTR5_1 = 0x1
	// Position of MPL4 field.
	AIPS_MPRA_MPL4_Pos = 0xc
	// Bit mask of MPL4 field.
	AIPS_MPRA_MPL4_Msk = 0x1000
	// Bit MPL4.
	AIPS_MPRA_MPL4 = 0x1000
	// Accesses from this master are forced to user-mode.
	AIPS_MPRA_MPL4_0 = 0x0
	// Accesses from this master are not forced to user-mode.
	AIPS_MPRA_MPL4_1 = 0x1
	// Position of MTW4 field.
	AIPS_MPRA_MTW4_Pos = 0xd
	// Bit mask of MTW4 field.
	AIPS_MPRA_MTW4_Msk = 0x2000
	// Bit MTW4.
	AIPS_MPRA_MTW4 = 0x2000
	// This master is not trusted for write accesses.
	AIPS_MPRA_MTW4_0 = 0x0
	// This master is trusted for write accesses.
	AIPS_MPRA_MTW4_1 = 0x1
	// Position of MTR4 field.
	AIPS_MPRA_MTR4_Pos = 0xe
	// Bit mask of MTR4 field.
	AIPS_MPRA_MTR4_Msk = 0x4000
	// Bit MTR4.
	AIPS_MPRA_MTR4 = 0x4000
	// This master is not trusted for read accesses.
	AIPS_MPRA_MTR4_0 = 0x0
	// This master is trusted for read accesses.
	AIPS_MPRA_MTR4_1 = 0x1
	// Position of MPL3 field.
	AIPS_MPRA_MPL3_Pos = 0x10
	// Bit mask of MPL3 field.
	AIPS_MPRA_MPL3_Msk = 0x10000
	// Bit MPL3.
	AIPS_MPRA_MPL3 = 0x10000
	// Accesses from this master are forced to user-mode.
	AIPS_MPRA_MPL3_0 = 0x0
	// Accesses from this master are not forced to user-mode.
	AIPS_MPRA_MPL3_1 = 0x1
	// Position of MTW3 field.
	AIPS_MPRA_MTW3_Pos = 0x11
	// Bit mask of MTW3 field.
	AIPS_MPRA_MTW3_Msk = 0x20000
	// Bit MTW3.
	AIPS_MPRA_MTW3 = 0x20000
	// This master is not trusted for write accesses.
	AIPS_MPRA_MTW3_0 = 0x0
	// This master is trusted for write accesses.
	AIPS_MPRA_MTW3_1 = 0x1
	// Position of MTR3 field.
	AIPS_MPRA_MTR3_Pos = 0x12
	// Bit mask of MTR3 field.
	AIPS_MPRA_MTR3_Msk = 0x40000
	// Bit MTR3.
	AIPS_MPRA_MTR3 = 0x40000
	// This master is not trusted for read accesses.
	AIPS_MPRA_MTR3_0 = 0x0
	// This master is trusted for read accesses.
	AIPS_MPRA_MTR3_1 = 0x1
	// Position of MPL2 field.
	AIPS_MPRA_MPL2_Pos = 0x14
	// Bit mask of MPL2 field.
	AIPS_MPRA_MPL2_Msk = 0x100000
	// Bit MPL2.
	AIPS_MPRA_MPL2 = 0x100000
	// Accesses from this master are forced to user-mode.
	AIPS_MPRA_MPL2_0 = 0x0
	// Accesses from this master are not forced to user-mode.
	AIPS_MPRA_MPL2_1 = 0x1
	// Position of MTW2 field.
	AIPS_MPRA_MTW2_Pos = 0x15
	// Bit mask of MTW2 field.
	AIPS_MPRA_MTW2_Msk = 0x200000
	// Bit MTW2.
	AIPS_MPRA_MTW2 = 0x200000
	// This master is not trusted for write accesses.
	AIPS_MPRA_MTW2_0 = 0x0
	// This master is trusted for write accesses.
	AIPS_MPRA_MTW2_1 = 0x1
	// Position of MTR2 field.
	AIPS_MPRA_MTR2_Pos = 0x16
	// Bit mask of MTR2 field.
	AIPS_MPRA_MTR2_Msk = 0x400000
	// Bit MTR2.
	AIPS_MPRA_MTR2 = 0x400000
	// This master is not trusted for read accesses.
	AIPS_MPRA_MTR2_0 = 0x0
	// This master is trusted for read accesses.
	AIPS_MPRA_MTR2_1 = 0x1
	// Position of MPL1 field.
	AIPS_MPRA_MPL1_Pos = 0x18
	// Bit mask of MPL1 field.
	AIPS_MPRA_MPL1_Msk = 0x1000000
	// Bit MPL1.
	AIPS_MPRA_MPL1 = 0x1000000
	// Accesses from this master are forced to user-mode.
	AIPS_MPRA_MPL1_0 = 0x0
	// Accesses from this master are not forced to user-mode.
	AIPS_MPRA_MPL1_1 = 0x1
	// Position of MTW1 field.
	AIPS_MPRA_MTW1_Pos = 0x19
	// Bit mask of MTW1 field.
	AIPS_MPRA_MTW1_Msk = 0x2000000
	// Bit MTW1.
	AIPS_MPRA_MTW1 = 0x2000000
	// This master is not trusted for write accesses.
	AIPS_MPRA_MTW1_0 = 0x0
	// This master is trusted for write accesses.
	AIPS_MPRA_MTW1_1 = 0x1
	// Position of MTR1 field.
	AIPS_MPRA_MTR1_Pos = 0x1a
	// Bit mask of MTR1 field.
	AIPS_MPRA_MTR1_Msk = 0x4000000
	// Bit MTR1.
	AIPS_MPRA_MTR1 = 0x4000000
	// This master is not trusted for read accesses.
	AIPS_MPRA_MTR1_0 = 0x0
	// This master is trusted for read accesses.
	AIPS_MPRA_MTR1_1 = 0x1
	// Position of MPL0 field.
	AIPS_MPRA_MPL0_Pos = 0x1c
	// Bit mask of MPL0 field.
	AIPS_MPRA_MPL0_Msk = 0x10000000
	// Bit MPL0.
	AIPS_MPRA_MPL0 = 0x10000000
	// Accesses from this master are forced to user-mode.
	AIPS_MPRA_MPL0_0 = 0x0
	// Accesses from this master are not forced to user-mode.
	AIPS_MPRA_MPL0_1 = 0x1
	// Position of MTW0 field.
	AIPS_MPRA_MTW0_Pos = 0x1d
	// Bit mask of MTW0 field.
	AIPS_MPRA_MTW0_Msk = 0x20000000
	// Bit MTW0.
	AIPS_MPRA_MTW0 = 0x20000000
	// This master is not trusted for write accesses.
	AIPS_MPRA_MTW0_0 = 0x0
	// This master is trusted for write accesses.
	AIPS_MPRA_MTW0_1 = 0x1
	// Position of MTR0 field.
	AIPS_MPRA_MTR0_Pos = 0x1e
	// Bit mask of MTR0 field.
	AIPS_MPRA_MTR0_Msk = 0x40000000
	// Bit MTR0.
	AIPS_MPRA_MTR0 = 0x40000000
	// This master is not trusted for read accesses.
	AIPS_MPRA_MTR0_0 = 0x0
	// This master is trusted for read accesses.
	AIPS_MPRA_MTR0_1 = 0x1

	// PACRA: Peripheral Access Control Register
	// Position of TP7 field.
	AIPS_PACRA_TP7_Pos = 0x0
	// Bit mask of TP7 field.
	AIPS_PACRA_TP7_Msk = 0x1
	// Bit TP7.
	AIPS_PACRA_TP7 = 0x1
	// Accesses from an untrusted master are allowed.
	AIPS_PACRA_TP7_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRA_TP7_1 = 0x1
	// Position of WP7 field.
	AIPS_PACRA_WP7_Pos = 0x1
	// Bit mask of WP7 field.
	AIPS_PACRA_WP7_Msk = 0x2
	// Bit WP7.
	AIPS_PACRA_WP7 = 0x2
	// This peripheral allows write accesses.
	AIPS_PACRA_WP7_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRA_WP7_1 = 0x1
	// Position of SP7 field.
	AIPS_PACRA_SP7_Pos = 0x2
	// Bit mask of SP7 field.
	AIPS_PACRA_SP7_Msk = 0x4
	// Bit SP7.
	AIPS_PACRA_SP7 = 0x4
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRA_SP7_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRA_SP7_1 = 0x1
	// Position of TP6 field.
	AIPS_PACRA_TP6_Pos = 0x4
	// Bit mask of TP6 field.
	AIPS_PACRA_TP6_Msk = 0x10
	// Bit TP6.
	AIPS_PACRA_TP6 = 0x10
	// Accesses from an untrusted master are allowed.
	AIPS_PACRA_TP6_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRA_TP6_1 = 0x1
	// Position of WP6 field.
	AIPS_PACRA_WP6_Pos = 0x5
	// Bit mask of WP6 field.
	AIPS_PACRA_WP6_Msk = 0x20
	// Bit WP6.
	AIPS_PACRA_WP6 = 0x20
	// This peripheral allows write accesses.
	AIPS_PACRA_WP6_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRA_WP6_1 = 0x1
	// Position of SP6 field.
	AIPS_PACRA_SP6_Pos = 0x6
	// Bit mask of SP6 field.
	AIPS_PACRA_SP6_Msk = 0x40
	// Bit SP6.
	AIPS_PACRA_SP6 = 0x40
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRA_SP6_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRA_SP6_1 = 0x1
	// Position of TP5 field.
	AIPS_PACRA_TP5_Pos = 0x8
	// Bit mask of TP5 field.
	AIPS_PACRA_TP5_Msk = 0x100
	// Bit TP5.
	AIPS_PACRA_TP5 = 0x100
	// Accesses from an untrusted master are allowed.
	AIPS_PACRA_TP5_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRA_TP5_1 = 0x1
	// Position of WP5 field.
	AIPS_PACRA_WP5_Pos = 0x9
	// Bit mask of WP5 field.
	AIPS_PACRA_WP5_Msk = 0x200
	// Bit WP5.
	AIPS_PACRA_WP5 = 0x200
	// This peripheral allows write accesses.
	AIPS_PACRA_WP5_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRA_WP5_1 = 0x1
	// Position of SP5 field.
	AIPS_PACRA_SP5_Pos = 0xa
	// Bit mask of SP5 field.
	AIPS_PACRA_SP5_Msk = 0x400
	// Bit SP5.
	AIPS_PACRA_SP5 = 0x400
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRA_SP5_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRA_SP5_1 = 0x1
	// Position of TP4 field.
	AIPS_PACRA_TP4_Pos = 0xc
	// Bit mask of TP4 field.
	AIPS_PACRA_TP4_Msk = 0x1000
	// Bit TP4.
	AIPS_PACRA_TP4 = 0x1000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRA_TP4_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRA_TP4_1 = 0x1
	// Position of WP4 field.
	AIPS_PACRA_WP4_Pos = 0xd
	// Bit mask of WP4 field.
	AIPS_PACRA_WP4_Msk = 0x2000
	// Bit WP4.
	AIPS_PACRA_WP4 = 0x2000
	// This peripheral allows write accesses.
	AIPS_PACRA_WP4_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRA_WP4_1 = 0x1
	// Position of SP4 field.
	AIPS_PACRA_SP4_Pos = 0xe
	// Bit mask of SP4 field.
	AIPS_PACRA_SP4_Msk = 0x4000
	// Bit SP4.
	AIPS_PACRA_SP4 = 0x4000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRA_SP4_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRA_SP4_1 = 0x1
	// Position of TP3 field.
	AIPS_PACRA_TP3_Pos = 0x10
	// Bit mask of TP3 field.
	AIPS_PACRA_TP3_Msk = 0x10000
	// Bit TP3.
	AIPS_PACRA_TP3 = 0x10000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRA_TP3_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRA_TP3_1 = 0x1
	// Position of WP3 field.
	AIPS_PACRA_WP3_Pos = 0x11
	// Bit mask of WP3 field.
	AIPS_PACRA_WP3_Msk = 0x20000
	// Bit WP3.
	AIPS_PACRA_WP3 = 0x20000
	// This peripheral allows write accesses.
	AIPS_PACRA_WP3_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRA_WP3_1 = 0x1
	// Position of SP3 field.
	AIPS_PACRA_SP3_Pos = 0x12
	// Bit mask of SP3 field.
	AIPS_PACRA_SP3_Msk = 0x40000
	// Bit SP3.
	AIPS_PACRA_SP3 = 0x40000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRA_SP3_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRA_SP3_1 = 0x1
	// Position of TP2 field.
	AIPS_PACRA_TP2_Pos = 0x14
	// Bit mask of TP2 field.
	AIPS_PACRA_TP2_Msk = 0x100000
	// Bit TP2.
	AIPS_PACRA_TP2 = 0x100000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRA_TP2_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRA_TP2_1 = 0x1
	// Position of WP2 field.
	AIPS_PACRA_WP2_Pos = 0x15
	// Bit mask of WP2 field.
	AIPS_PACRA_WP2_Msk = 0x200000
	// Bit WP2.
	AIPS_PACRA_WP2 = 0x200000
	// This peripheral allows write accesses.
	AIPS_PACRA_WP2_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRA_WP2_1 = 0x1
	// Position of SP2 field.
	AIPS_PACRA_SP2_Pos = 0x16
	// Bit mask of SP2 field.
	AIPS_PACRA_SP2_Msk = 0x400000
	// Bit SP2.
	AIPS_PACRA_SP2 = 0x400000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRA_SP2_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRA_SP2_1 = 0x1
	// Position of TP1 field.
	AIPS_PACRA_TP1_Pos = 0x18
	// Bit mask of TP1 field.
	AIPS_PACRA_TP1_Msk = 0x1000000
	// Bit TP1.
	AIPS_PACRA_TP1 = 0x1000000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRA_TP1_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRA_TP1_1 = 0x1
	// Position of WP1 field.
	AIPS_PACRA_WP1_Pos = 0x19
	// Bit mask of WP1 field.
	AIPS_PACRA_WP1_Msk = 0x2000000
	// Bit WP1.
	AIPS_PACRA_WP1 = 0x2000000
	// This peripheral allows write accesses.
	AIPS_PACRA_WP1_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRA_WP1_1 = 0x1
	// Position of SP1 field.
	AIPS_PACRA_SP1_Pos = 0x1a
	// Bit mask of SP1 field.
	AIPS_PACRA_SP1_Msk = 0x4000000
	// Bit SP1.
	AIPS_PACRA_SP1 = 0x4000000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRA_SP1_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRA_SP1_1 = 0x1
	// Position of TP0 field.
	AIPS_PACRA_TP0_Pos = 0x1c
	// Bit mask of TP0 field.
	AIPS_PACRA_TP0_Msk = 0x10000000
	// Bit TP0.
	AIPS_PACRA_TP0 = 0x10000000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRA_TP0_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRA_TP0_1 = 0x1
	// Position of WP0 field.
	AIPS_PACRA_WP0_Pos = 0x1d
	// Bit mask of WP0 field.
	AIPS_PACRA_WP0_Msk = 0x20000000
	// Bit WP0.
	AIPS_PACRA_WP0 = 0x20000000
	// This peripheral allows write accesses.
	AIPS_PACRA_WP0_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRA_WP0_1 = 0x1
	// Position of SP0 field.
	AIPS_PACRA_SP0_Pos = 0x1e
	// Bit mask of SP0 field.
	AIPS_PACRA_SP0_Msk = 0x40000000
	// Bit SP0.
	AIPS_PACRA_SP0 = 0x40000000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRA_SP0_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRA_SP0_1 = 0x1

	// PACRB: Peripheral Access Control Register
	// Position of TP7 field.
	AIPS_PACRB_TP7_Pos = 0x0
	// Bit mask of TP7 field.
	AIPS_PACRB_TP7_Msk = 0x1
	// Bit TP7.
	AIPS_PACRB_TP7 = 0x1
	// Accesses from an untrusted master are allowed.
	AIPS_PACRB_TP7_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRB_TP7_1 = 0x1
	// Position of WP7 field.
	AIPS_PACRB_WP7_Pos = 0x1
	// Bit mask of WP7 field.
	AIPS_PACRB_WP7_Msk = 0x2
	// Bit WP7.
	AIPS_PACRB_WP7 = 0x2
	// This peripheral allows write accesses.
	AIPS_PACRB_WP7_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRB_WP7_1 = 0x1
	// Position of SP7 field.
	AIPS_PACRB_SP7_Pos = 0x2
	// Bit mask of SP7 field.
	AIPS_PACRB_SP7_Msk = 0x4
	// Bit SP7.
	AIPS_PACRB_SP7 = 0x4
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRB_SP7_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRB_SP7_1 = 0x1
	// Position of TP6 field.
	AIPS_PACRB_TP6_Pos = 0x4
	// Bit mask of TP6 field.
	AIPS_PACRB_TP6_Msk = 0x10
	// Bit TP6.
	AIPS_PACRB_TP6 = 0x10
	// Accesses from an untrusted master are allowed.
	AIPS_PACRB_TP6_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRB_TP6_1 = 0x1
	// Position of WP6 field.
	AIPS_PACRB_WP6_Pos = 0x5
	// Bit mask of WP6 field.
	AIPS_PACRB_WP6_Msk = 0x20
	// Bit WP6.
	AIPS_PACRB_WP6 = 0x20
	// This peripheral allows write accesses.
	AIPS_PACRB_WP6_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRB_WP6_1 = 0x1
	// Position of SP6 field.
	AIPS_PACRB_SP6_Pos = 0x6
	// Bit mask of SP6 field.
	AIPS_PACRB_SP6_Msk = 0x40
	// Bit SP6.
	AIPS_PACRB_SP6 = 0x40
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRB_SP6_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRB_SP6_1 = 0x1
	// Position of TP5 field.
	AIPS_PACRB_TP5_Pos = 0x8
	// Bit mask of TP5 field.
	AIPS_PACRB_TP5_Msk = 0x100
	// Bit TP5.
	AIPS_PACRB_TP5 = 0x100
	// Accesses from an untrusted master are allowed.
	AIPS_PACRB_TP5_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRB_TP5_1 = 0x1
	// Position of WP5 field.
	AIPS_PACRB_WP5_Pos = 0x9
	// Bit mask of WP5 field.
	AIPS_PACRB_WP5_Msk = 0x200
	// Bit WP5.
	AIPS_PACRB_WP5 = 0x200
	// This peripheral allows write accesses.
	AIPS_PACRB_WP5_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRB_WP5_1 = 0x1
	// Position of SP5 field.
	AIPS_PACRB_SP5_Pos = 0xa
	// Bit mask of SP5 field.
	AIPS_PACRB_SP5_Msk = 0x400
	// Bit SP5.
	AIPS_PACRB_SP5 = 0x400
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRB_SP5_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRB_SP5_1 = 0x1
	// Position of TP4 field.
	AIPS_PACRB_TP4_Pos = 0xc
	// Bit mask of TP4 field.
	AIPS_PACRB_TP4_Msk = 0x1000
	// Bit TP4.
	AIPS_PACRB_TP4 = 0x1000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRB_TP4_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRB_TP4_1 = 0x1
	// Position of WP4 field.
	AIPS_PACRB_WP4_Pos = 0xd
	// Bit mask of WP4 field.
	AIPS_PACRB_WP4_Msk = 0x2000
	// Bit WP4.
	AIPS_PACRB_WP4 = 0x2000
	// This peripheral allows write accesses.
	AIPS_PACRB_WP4_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRB_WP4_1 = 0x1
	// Position of SP4 field.
	AIPS_PACRB_SP4_Pos = 0xe
	// Bit mask of SP4 field.
	AIPS_PACRB_SP4_Msk = 0x4000
	// Bit SP4.
	AIPS_PACRB_SP4 = 0x4000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRB_SP4_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRB_SP4_1 = 0x1
	// Position of TP3 field.
	AIPS_PACRB_TP3_Pos = 0x10
	// Bit mask of TP3 field.
	AIPS_PACRB_TP3_Msk = 0x10000
	// Bit TP3.
	AIPS_PACRB_TP3 = 0x10000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRB_TP3_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRB_TP3_1 = 0x1
	// Position of WP3 field.
	AIPS_PACRB_WP3_Pos = 0x11
	// Bit mask of WP3 field.
	AIPS_PACRB_WP3_Msk = 0x20000
	// Bit WP3.
	AIPS_PACRB_WP3 = 0x20000
	// This peripheral allows write accesses.
	AIPS_PACRB_WP3_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRB_WP3_1 = 0x1
	// Position of SP3 field.
	AIPS_PACRB_SP3_Pos = 0x12
	// Bit mask of SP3 field.
	AIPS_PACRB_SP3_Msk = 0x40000
	// Bit SP3.
	AIPS_PACRB_SP3 = 0x40000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRB_SP3_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRB_SP3_1 = 0x1
	// Position of TP2 field.
	AIPS_PACRB_TP2_Pos = 0x14
	// Bit mask of TP2 field.
	AIPS_PACRB_TP2_Msk = 0x100000
	// Bit TP2.
	AIPS_PACRB_TP2 = 0x100000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRB_TP2_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRB_TP2_1 = 0x1
	// Position of WP2 field.
	AIPS_PACRB_WP2_Pos = 0x15
	// Bit mask of WP2 field.
	AIPS_PACRB_WP2_Msk = 0x200000
	// Bit WP2.
	AIPS_PACRB_WP2 = 0x200000
	// This peripheral allows write accesses.
	AIPS_PACRB_WP2_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRB_WP2_1 = 0x1
	// Position of SP2 field.
	AIPS_PACRB_SP2_Pos = 0x16
	// Bit mask of SP2 field.
	AIPS_PACRB_SP2_Msk = 0x400000
	// Bit SP2.
	AIPS_PACRB_SP2 = 0x400000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRB_SP2_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRB_SP2_1 = 0x1
	// Position of TP1 field.
	AIPS_PACRB_TP1_Pos = 0x18
	// Bit mask of TP1 field.
	AIPS_PACRB_TP1_Msk = 0x1000000
	// Bit TP1.
	AIPS_PACRB_TP1 = 0x1000000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRB_TP1_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRB_TP1_1 = 0x1
	// Position of WP1 field.
	AIPS_PACRB_WP1_Pos = 0x19
	// Bit mask of WP1 field.
	AIPS_PACRB_WP1_Msk = 0x2000000
	// Bit WP1.
	AIPS_PACRB_WP1 = 0x2000000
	// This peripheral allows write accesses.
	AIPS_PACRB_WP1_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRB_WP1_1 = 0x1
	// Position of SP1 field.
	AIPS_PACRB_SP1_Pos = 0x1a
	// Bit mask of SP1 field.
	AIPS_PACRB_SP1_Msk = 0x4000000
	// Bit SP1.
	AIPS_PACRB_SP1 = 0x4000000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRB_SP1_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRB_SP1_1 = 0x1
	// Position of TP0 field.
	AIPS_PACRB_TP0_Pos = 0x1c
	// Bit mask of TP0 field.
	AIPS_PACRB_TP0_Msk = 0x10000000
	// Bit TP0.
	AIPS_PACRB_TP0 = 0x10000000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRB_TP0_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRB_TP0_1 = 0x1
	// Position of WP0 field.
	AIPS_PACRB_WP0_Pos = 0x1d
	// Bit mask of WP0 field.
	AIPS_PACRB_WP0_Msk = 0x20000000
	// Bit WP0.
	AIPS_PACRB_WP0 = 0x20000000
	// This peripheral allows write accesses.
	AIPS_PACRB_WP0_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRB_WP0_1 = 0x1
	// Position of SP0 field.
	AIPS_PACRB_SP0_Pos = 0x1e
	// Bit mask of SP0 field.
	AIPS_PACRB_SP0_Msk = 0x40000000
	// Bit SP0.
	AIPS_PACRB_SP0 = 0x40000000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRB_SP0_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRB_SP0_1 = 0x1

	// PACRC: Peripheral Access Control Register
	// Position of TP7 field.
	AIPS_PACRC_TP7_Pos = 0x0
	// Bit mask of TP7 field.
	AIPS_PACRC_TP7_Msk = 0x1
	// Bit TP7.
	AIPS_PACRC_TP7 = 0x1
	// Accesses from an untrusted master are allowed.
	AIPS_PACRC_TP7_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRC_TP7_1 = 0x1
	// Position of WP7 field.
	AIPS_PACRC_WP7_Pos = 0x1
	// Bit mask of WP7 field.
	AIPS_PACRC_WP7_Msk = 0x2
	// Bit WP7.
	AIPS_PACRC_WP7 = 0x2
	// This peripheral allows write accesses.
	AIPS_PACRC_WP7_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRC_WP7_1 = 0x1
	// Position of SP7 field.
	AIPS_PACRC_SP7_Pos = 0x2
	// Bit mask of SP7 field.
	AIPS_PACRC_SP7_Msk = 0x4
	// Bit SP7.
	AIPS_PACRC_SP7 = 0x4
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRC_SP7_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRC_SP7_1 = 0x1
	// Position of TP6 field.
	AIPS_PACRC_TP6_Pos = 0x4
	// Bit mask of TP6 field.
	AIPS_PACRC_TP6_Msk = 0x10
	// Bit TP6.
	AIPS_PACRC_TP6 = 0x10
	// Accesses from an untrusted master are allowed.
	AIPS_PACRC_TP6_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRC_TP6_1 = 0x1
	// Position of WP6 field.
	AIPS_PACRC_WP6_Pos = 0x5
	// Bit mask of WP6 field.
	AIPS_PACRC_WP6_Msk = 0x20
	// Bit WP6.
	AIPS_PACRC_WP6 = 0x20
	// This peripheral allows write accesses.
	AIPS_PACRC_WP6_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRC_WP6_1 = 0x1
	// Position of SP6 field.
	AIPS_PACRC_SP6_Pos = 0x6
	// Bit mask of SP6 field.
	AIPS_PACRC_SP6_Msk = 0x40
	// Bit SP6.
	AIPS_PACRC_SP6 = 0x40
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRC_SP6_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRC_SP6_1 = 0x1
	// Position of TP5 field.
	AIPS_PACRC_TP5_Pos = 0x8
	// Bit mask of TP5 field.
	AIPS_PACRC_TP5_Msk = 0x100
	// Bit TP5.
	AIPS_PACRC_TP5 = 0x100
	// Accesses from an untrusted master are allowed.
	AIPS_PACRC_TP5_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRC_TP5_1 = 0x1
	// Position of WP5 field.
	AIPS_PACRC_WP5_Pos = 0x9
	// Bit mask of WP5 field.
	AIPS_PACRC_WP5_Msk = 0x200
	// Bit WP5.
	AIPS_PACRC_WP5 = 0x200
	// This peripheral allows write accesses.
	AIPS_PACRC_WP5_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRC_WP5_1 = 0x1
	// Position of SP5 field.
	AIPS_PACRC_SP5_Pos = 0xa
	// Bit mask of SP5 field.
	AIPS_PACRC_SP5_Msk = 0x400
	// Bit SP5.
	AIPS_PACRC_SP5 = 0x400
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRC_SP5_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRC_SP5_1 = 0x1
	// Position of TP4 field.
	AIPS_PACRC_TP4_Pos = 0xc
	// Bit mask of TP4 field.
	AIPS_PACRC_TP4_Msk = 0x1000
	// Bit TP4.
	AIPS_PACRC_TP4 = 0x1000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRC_TP4_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRC_TP4_1 = 0x1
	// Position of WP4 field.
	AIPS_PACRC_WP4_Pos = 0xd
	// Bit mask of WP4 field.
	AIPS_PACRC_WP4_Msk = 0x2000
	// Bit WP4.
	AIPS_PACRC_WP4 = 0x2000
	// This peripheral allows write accesses.
	AIPS_PACRC_WP4_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRC_WP4_1 = 0x1
	// Position of SP4 field.
	AIPS_PACRC_SP4_Pos = 0xe
	// Bit mask of SP4 field.
	AIPS_PACRC_SP4_Msk = 0x4000
	// Bit SP4.
	AIPS_PACRC_SP4 = 0x4000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRC_SP4_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRC_SP4_1 = 0x1
	// Position of TP3 field.
	AIPS_PACRC_TP3_Pos = 0x10
	// Bit mask of TP3 field.
	AIPS_PACRC_TP3_Msk = 0x10000
	// Bit TP3.
	AIPS_PACRC_TP3 = 0x10000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRC_TP3_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRC_TP3_1 = 0x1
	// Position of WP3 field.
	AIPS_PACRC_WP3_Pos = 0x11
	// Bit mask of WP3 field.
	AIPS_PACRC_WP3_Msk = 0x20000
	// Bit WP3.
	AIPS_PACRC_WP3 = 0x20000
	// This peripheral allows write accesses.
	AIPS_PACRC_WP3_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRC_WP3_1 = 0x1
	// Position of SP3 field.
	AIPS_PACRC_SP3_Pos = 0x12
	// Bit mask of SP3 field.
	AIPS_PACRC_SP3_Msk = 0x40000
	// Bit SP3.
	AIPS_PACRC_SP3 = 0x40000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRC_SP3_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRC_SP3_1 = 0x1
	// Position of TP2 field.
	AIPS_PACRC_TP2_Pos = 0x14
	// Bit mask of TP2 field.
	AIPS_PACRC_TP2_Msk = 0x100000
	// Bit TP2.
	AIPS_PACRC_TP2 = 0x100000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRC_TP2_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRC_TP2_1 = 0x1
	// Position of WP2 field.
	AIPS_PACRC_WP2_Pos = 0x15
	// Bit mask of WP2 field.
	AIPS_PACRC_WP2_Msk = 0x200000
	// Bit WP2.
	AIPS_PACRC_WP2 = 0x200000
	// This peripheral allows write accesses.
	AIPS_PACRC_WP2_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRC_WP2_1 = 0x1
	// Position of SP2 field.
	AIPS_PACRC_SP2_Pos = 0x16
	// Bit mask of SP2 field.
	AIPS_PACRC_SP2_Msk = 0x400000
	// Bit SP2.
	AIPS_PACRC_SP2 = 0x400000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRC_SP2_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRC_SP2_1 = 0x1
	// Position of TP1 field.
	AIPS_PACRC_TP1_Pos = 0x18
	// Bit mask of TP1 field.
	AIPS_PACRC_TP1_Msk = 0x1000000
	// Bit TP1.
	AIPS_PACRC_TP1 = 0x1000000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRC_TP1_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRC_TP1_1 = 0x1
	// Position of WP1 field.
	AIPS_PACRC_WP1_Pos = 0x19
	// Bit mask of WP1 field.
	AIPS_PACRC_WP1_Msk = 0x2000000
	// Bit WP1.
	AIPS_PACRC_WP1 = 0x2000000
	// This peripheral allows write accesses.
	AIPS_PACRC_WP1_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRC_WP1_1 = 0x1
	// Position of SP1 field.
	AIPS_PACRC_SP1_Pos = 0x1a
	// Bit mask of SP1 field.
	AIPS_PACRC_SP1_Msk = 0x4000000
	// Bit SP1.
	AIPS_PACRC_SP1 = 0x4000000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRC_SP1_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRC_SP1_1 = 0x1
	// Position of TP0 field.
	AIPS_PACRC_TP0_Pos = 0x1c
	// Bit mask of TP0 field.
	AIPS_PACRC_TP0_Msk = 0x10000000
	// Bit TP0.
	AIPS_PACRC_TP0 = 0x10000000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRC_TP0_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRC_TP0_1 = 0x1
	// Position of WP0 field.
	AIPS_PACRC_WP0_Pos = 0x1d
	// Bit mask of WP0 field.
	AIPS_PACRC_WP0_Msk = 0x20000000
	// Bit WP0.
	AIPS_PACRC_WP0 = 0x20000000
	// This peripheral allows write accesses.
	AIPS_PACRC_WP0_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRC_WP0_1 = 0x1
	// Position of SP0 field.
	AIPS_PACRC_SP0_Pos = 0x1e
	// Bit mask of SP0 field.
	AIPS_PACRC_SP0_Msk = 0x40000000
	// Bit SP0.
	AIPS_PACRC_SP0 = 0x40000000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRC_SP0_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRC_SP0_1 = 0x1

	// PACRD: Peripheral Access Control Register
	// Position of TP7 field.
	AIPS_PACRD_TP7_Pos = 0x0
	// Bit mask of TP7 field.
	AIPS_PACRD_TP7_Msk = 0x1
	// Bit TP7.
	AIPS_PACRD_TP7 = 0x1
	// Accesses from an untrusted master are allowed.
	AIPS_PACRD_TP7_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRD_TP7_1 = 0x1
	// Position of WP7 field.
	AIPS_PACRD_WP7_Pos = 0x1
	// Bit mask of WP7 field.
	AIPS_PACRD_WP7_Msk = 0x2
	// Bit WP7.
	AIPS_PACRD_WP7 = 0x2
	// This peripheral allows write accesses.
	AIPS_PACRD_WP7_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRD_WP7_1 = 0x1
	// Position of SP7 field.
	AIPS_PACRD_SP7_Pos = 0x2
	// Bit mask of SP7 field.
	AIPS_PACRD_SP7_Msk = 0x4
	// Bit SP7.
	AIPS_PACRD_SP7 = 0x4
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRD_SP7_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRD_SP7_1 = 0x1
	// Position of TP6 field.
	AIPS_PACRD_TP6_Pos = 0x4
	// Bit mask of TP6 field.
	AIPS_PACRD_TP6_Msk = 0x10
	// Bit TP6.
	AIPS_PACRD_TP6 = 0x10
	// Accesses from an untrusted master are allowed.
	AIPS_PACRD_TP6_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRD_TP6_1 = 0x1
	// Position of WP6 field.
	AIPS_PACRD_WP6_Pos = 0x5
	// Bit mask of WP6 field.
	AIPS_PACRD_WP6_Msk = 0x20
	// Bit WP6.
	AIPS_PACRD_WP6 = 0x20
	// This peripheral allows write accesses.
	AIPS_PACRD_WP6_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRD_WP6_1 = 0x1
	// Position of SP6 field.
	AIPS_PACRD_SP6_Pos = 0x6
	// Bit mask of SP6 field.
	AIPS_PACRD_SP6_Msk = 0x40
	// Bit SP6.
	AIPS_PACRD_SP6 = 0x40
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRD_SP6_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRD_SP6_1 = 0x1
	// Position of TP5 field.
	AIPS_PACRD_TP5_Pos = 0x8
	// Bit mask of TP5 field.
	AIPS_PACRD_TP5_Msk = 0x100
	// Bit TP5.
	AIPS_PACRD_TP5 = 0x100
	// Accesses from an untrusted master are allowed.
	AIPS_PACRD_TP5_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRD_TP5_1 = 0x1
	// Position of WP5 field.
	AIPS_PACRD_WP5_Pos = 0x9
	// Bit mask of WP5 field.
	AIPS_PACRD_WP5_Msk = 0x200
	// Bit WP5.
	AIPS_PACRD_WP5 = 0x200
	// This peripheral allows write accesses.
	AIPS_PACRD_WP5_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRD_WP5_1 = 0x1
	// Position of SP5 field.
	AIPS_PACRD_SP5_Pos = 0xa
	// Bit mask of SP5 field.
	AIPS_PACRD_SP5_Msk = 0x400
	// Bit SP5.
	AIPS_PACRD_SP5 = 0x400
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRD_SP5_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRD_SP5_1 = 0x1
	// Position of TP4 field.
	AIPS_PACRD_TP4_Pos = 0xc
	// Bit mask of TP4 field.
	AIPS_PACRD_TP4_Msk = 0x1000
	// Bit TP4.
	AIPS_PACRD_TP4 = 0x1000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRD_TP4_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRD_TP4_1 = 0x1
	// Position of WP4 field.
	AIPS_PACRD_WP4_Pos = 0xd
	// Bit mask of WP4 field.
	AIPS_PACRD_WP4_Msk = 0x2000
	// Bit WP4.
	AIPS_PACRD_WP4 = 0x2000
	// This peripheral allows write accesses.
	AIPS_PACRD_WP4_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRD_WP4_1 = 0x1
	// Position of SP4 field.
	AIPS_PACRD_SP4_Pos = 0xe
	// Bit mask of SP4 field.
	AIPS_PACRD_SP4_Msk = 0x4000
	// Bit SP4.
	AIPS_PACRD_SP4 = 0x4000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRD_SP4_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRD_SP4_1 = 0x1
	// Position of TP3 field.
	AIPS_PACRD_TP3_Pos = 0x10
	// Bit mask of TP3 field.
	AIPS_PACRD_TP3_Msk = 0x10000
	// Bit TP3.
	AIPS_PACRD_TP3 = 0x10000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRD_TP3_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRD_TP3_1 = 0x1
	// Position of WP3 field.
	AIPS_PACRD_WP3_Pos = 0x11
	// Bit mask of WP3 field.
	AIPS_PACRD_WP3_Msk = 0x20000
	// Bit WP3.
	AIPS_PACRD_WP3 = 0x20000
	// This peripheral allows write accesses.
	AIPS_PACRD_WP3_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRD_WP3_1 = 0x1
	// Position of SP3 field.
	AIPS_PACRD_SP3_Pos = 0x12
	// Bit mask of SP3 field.
	AIPS_PACRD_SP3_Msk = 0x40000
	// Bit SP3.
	AIPS_PACRD_SP3 = 0x40000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRD_SP3_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRD_SP3_1 = 0x1
	// Position of TP2 field.
	AIPS_PACRD_TP2_Pos = 0x14
	// Bit mask of TP2 field.
	AIPS_PACRD_TP2_Msk = 0x100000
	// Bit TP2.
	AIPS_PACRD_TP2 = 0x100000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRD_TP2_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRD_TP2_1 = 0x1
	// Position of WP2 field.
	AIPS_PACRD_WP2_Pos = 0x15
	// Bit mask of WP2 field.
	AIPS_PACRD_WP2_Msk = 0x200000
	// Bit WP2.
	AIPS_PACRD_WP2 = 0x200000
	// This peripheral allows write accesses.
	AIPS_PACRD_WP2_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRD_WP2_1 = 0x1
	// Position of SP2 field.
	AIPS_PACRD_SP2_Pos = 0x16
	// Bit mask of SP2 field.
	AIPS_PACRD_SP2_Msk = 0x400000
	// Bit SP2.
	AIPS_PACRD_SP2 = 0x400000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRD_SP2_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRD_SP2_1 = 0x1
	// Position of TP1 field.
	AIPS_PACRD_TP1_Pos = 0x18
	// Bit mask of TP1 field.
	AIPS_PACRD_TP1_Msk = 0x1000000
	// Bit TP1.
	AIPS_PACRD_TP1 = 0x1000000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRD_TP1_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRD_TP1_1 = 0x1
	// Position of WP1 field.
	AIPS_PACRD_WP1_Pos = 0x19
	// Bit mask of WP1 field.
	AIPS_PACRD_WP1_Msk = 0x2000000
	// Bit WP1.
	AIPS_PACRD_WP1 = 0x2000000
	// This peripheral allows write accesses.
	AIPS_PACRD_WP1_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRD_WP1_1 = 0x1
	// Position of SP1 field.
	AIPS_PACRD_SP1_Pos = 0x1a
	// Bit mask of SP1 field.
	AIPS_PACRD_SP1_Msk = 0x4000000
	// Bit SP1.
	AIPS_PACRD_SP1 = 0x4000000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRD_SP1_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRD_SP1_1 = 0x1
	// Position of TP0 field.
	AIPS_PACRD_TP0_Pos = 0x1c
	// Bit mask of TP0 field.
	AIPS_PACRD_TP0_Msk = 0x10000000
	// Bit TP0.
	AIPS_PACRD_TP0 = 0x10000000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRD_TP0_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRD_TP0_1 = 0x1
	// Position of WP0 field.
	AIPS_PACRD_WP0_Pos = 0x1d
	// Bit mask of WP0 field.
	AIPS_PACRD_WP0_Msk = 0x20000000
	// Bit WP0.
	AIPS_PACRD_WP0 = 0x20000000
	// This peripheral allows write accesses.
	AIPS_PACRD_WP0_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRD_WP0_1 = 0x1
	// Position of SP0 field.
	AIPS_PACRD_SP0_Pos = 0x1e
	// Bit mask of SP0 field.
	AIPS_PACRD_SP0_Msk = 0x40000000
	// Bit SP0.
	AIPS_PACRD_SP0 = 0x40000000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRD_SP0_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRD_SP0_1 = 0x1

	// PACRE: Peripheral Access Control Register
	// Position of TP7 field.
	AIPS_PACRE_TP7_Pos = 0x0
	// Bit mask of TP7 field.
	AIPS_PACRE_TP7_Msk = 0x1
	// Bit TP7.
	AIPS_PACRE_TP7 = 0x1
	// Accesses from an untrusted master are allowed.
	AIPS_PACRE_TP7_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRE_TP7_1 = 0x1
	// Position of WP7 field.
	AIPS_PACRE_WP7_Pos = 0x1
	// Bit mask of WP7 field.
	AIPS_PACRE_WP7_Msk = 0x2
	// Bit WP7.
	AIPS_PACRE_WP7 = 0x2
	// This peripheral allows write accesses.
	AIPS_PACRE_WP7_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRE_WP7_1 = 0x1
	// Position of SP7 field.
	AIPS_PACRE_SP7_Pos = 0x2
	// Bit mask of SP7 field.
	AIPS_PACRE_SP7_Msk = 0x4
	// Bit SP7.
	AIPS_PACRE_SP7 = 0x4
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRE_SP7_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRE_SP7_1 = 0x1
	// Position of TP6 field.
	AIPS_PACRE_TP6_Pos = 0x4
	// Bit mask of TP6 field.
	AIPS_PACRE_TP6_Msk = 0x10
	// Bit TP6.
	AIPS_PACRE_TP6 = 0x10
	// Accesses from an untrusted master are allowed.
	AIPS_PACRE_TP6_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRE_TP6_1 = 0x1
	// Position of WP6 field.
	AIPS_PACRE_WP6_Pos = 0x5
	// Bit mask of WP6 field.
	AIPS_PACRE_WP6_Msk = 0x20
	// Bit WP6.
	AIPS_PACRE_WP6 = 0x20
	// This peripheral allows write accesses.
	AIPS_PACRE_WP6_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRE_WP6_1 = 0x1
	// Position of SP6 field.
	AIPS_PACRE_SP6_Pos = 0x6
	// Bit mask of SP6 field.
	AIPS_PACRE_SP6_Msk = 0x40
	// Bit SP6.
	AIPS_PACRE_SP6 = 0x40
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRE_SP6_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRE_SP6_1 = 0x1
	// Position of TP5 field.
	AIPS_PACRE_TP5_Pos = 0x8
	// Bit mask of TP5 field.
	AIPS_PACRE_TP5_Msk = 0x100
	// Bit TP5.
	AIPS_PACRE_TP5 = 0x100
	// Accesses from an untrusted master are allowed.
	AIPS_PACRE_TP5_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRE_TP5_1 = 0x1
	// Position of WP5 field.
	AIPS_PACRE_WP5_Pos = 0x9
	// Bit mask of WP5 field.
	AIPS_PACRE_WP5_Msk = 0x200
	// Bit WP5.
	AIPS_PACRE_WP5 = 0x200
	// This peripheral allows write accesses.
	AIPS_PACRE_WP5_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRE_WP5_1 = 0x1
	// Position of SP5 field.
	AIPS_PACRE_SP5_Pos = 0xa
	// Bit mask of SP5 field.
	AIPS_PACRE_SP5_Msk = 0x400
	// Bit SP5.
	AIPS_PACRE_SP5 = 0x400
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRE_SP5_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRE_SP5_1 = 0x1
	// Position of TP4 field.
	AIPS_PACRE_TP4_Pos = 0xc
	// Bit mask of TP4 field.
	AIPS_PACRE_TP4_Msk = 0x1000
	// Bit TP4.
	AIPS_PACRE_TP4 = 0x1000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRE_TP4_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRE_TP4_1 = 0x1
	// Position of WP4 field.
	AIPS_PACRE_WP4_Pos = 0xd
	// Bit mask of WP4 field.
	AIPS_PACRE_WP4_Msk = 0x2000
	// Bit WP4.
	AIPS_PACRE_WP4 = 0x2000
	// This peripheral allows write accesses.
	AIPS_PACRE_WP4_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRE_WP4_1 = 0x1
	// Position of SP4 field.
	AIPS_PACRE_SP4_Pos = 0xe
	// Bit mask of SP4 field.
	AIPS_PACRE_SP4_Msk = 0x4000
	// Bit SP4.
	AIPS_PACRE_SP4 = 0x4000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRE_SP4_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRE_SP4_1 = 0x1
	// Position of TP3 field.
	AIPS_PACRE_TP3_Pos = 0x10
	// Bit mask of TP3 field.
	AIPS_PACRE_TP3_Msk = 0x10000
	// Bit TP3.
	AIPS_PACRE_TP3 = 0x10000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRE_TP3_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRE_TP3_1 = 0x1
	// Position of WP3 field.
	AIPS_PACRE_WP3_Pos = 0x11
	// Bit mask of WP3 field.
	AIPS_PACRE_WP3_Msk = 0x20000
	// Bit WP3.
	AIPS_PACRE_WP3 = 0x20000
	// This peripheral allows write accesses.
	AIPS_PACRE_WP3_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRE_WP3_1 = 0x1
	// Position of SP3 field.
	AIPS_PACRE_SP3_Pos = 0x12
	// Bit mask of SP3 field.
	AIPS_PACRE_SP3_Msk = 0x40000
	// Bit SP3.
	AIPS_PACRE_SP3 = 0x40000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRE_SP3_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRE_SP3_1 = 0x1
	// Position of TP2 field.
	AIPS_PACRE_TP2_Pos = 0x14
	// Bit mask of TP2 field.
	AIPS_PACRE_TP2_Msk = 0x100000
	// Bit TP2.
	AIPS_PACRE_TP2 = 0x100000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRE_TP2_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRE_TP2_1 = 0x1
	// Position of WP2 field.
	AIPS_PACRE_WP2_Pos = 0x15
	// Bit mask of WP2 field.
	AIPS_PACRE_WP2_Msk = 0x200000
	// Bit WP2.
	AIPS_PACRE_WP2 = 0x200000
	// This peripheral allows write accesses.
	AIPS_PACRE_WP2_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRE_WP2_1 = 0x1
	// Position of SP2 field.
	AIPS_PACRE_SP2_Pos = 0x16
	// Bit mask of SP2 field.
	AIPS_PACRE_SP2_Msk = 0x400000
	// Bit SP2.
	AIPS_PACRE_SP2 = 0x400000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRE_SP2_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRE_SP2_1 = 0x1
	// Position of TP1 field.
	AIPS_PACRE_TP1_Pos = 0x18
	// Bit mask of TP1 field.
	AIPS_PACRE_TP1_Msk = 0x1000000
	// Bit TP1.
	AIPS_PACRE_TP1 = 0x1000000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRE_TP1_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRE_TP1_1 = 0x1
	// Position of WP1 field.
	AIPS_PACRE_WP1_Pos = 0x19
	// Bit mask of WP1 field.
	AIPS_PACRE_WP1_Msk = 0x2000000
	// Bit WP1.
	AIPS_PACRE_WP1 = 0x2000000
	// This peripheral allows write accesses.
	AIPS_PACRE_WP1_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRE_WP1_1 = 0x1
	// Position of SP1 field.
	AIPS_PACRE_SP1_Pos = 0x1a
	// Bit mask of SP1 field.
	AIPS_PACRE_SP1_Msk = 0x4000000
	// Bit SP1.
	AIPS_PACRE_SP1 = 0x4000000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRE_SP1_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRE_SP1_1 = 0x1
	// Position of TP0 field.
	AIPS_PACRE_TP0_Pos = 0x1c
	// Bit mask of TP0 field.
	AIPS_PACRE_TP0_Msk = 0x10000000
	// Bit TP0.
	AIPS_PACRE_TP0 = 0x10000000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRE_TP0_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRE_TP0_1 = 0x1
	// Position of WP0 field.
	AIPS_PACRE_WP0_Pos = 0x1d
	// Bit mask of WP0 field.
	AIPS_PACRE_WP0_Msk = 0x20000000
	// Bit WP0.
	AIPS_PACRE_WP0 = 0x20000000
	// This peripheral allows write accesses.
	AIPS_PACRE_WP0_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRE_WP0_1 = 0x1
	// Position of SP0 field.
	AIPS_PACRE_SP0_Pos = 0x1e
	// Bit mask of SP0 field.
	AIPS_PACRE_SP0_Msk = 0x40000000
	// Bit SP0.
	AIPS_PACRE_SP0 = 0x40000000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRE_SP0_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRE_SP0_1 = 0x1

	// PACRF: Peripheral Access Control Register
	// Position of TP7 field.
	AIPS_PACRF_TP7_Pos = 0x0
	// Bit mask of TP7 field.
	AIPS_PACRF_TP7_Msk = 0x1
	// Bit TP7.
	AIPS_PACRF_TP7 = 0x1
	// Accesses from an untrusted master are allowed.
	AIPS_PACRF_TP7_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRF_TP7_1 = 0x1
	// Position of WP7 field.
	AIPS_PACRF_WP7_Pos = 0x1
	// Bit mask of WP7 field.
	AIPS_PACRF_WP7_Msk = 0x2
	// Bit WP7.
	AIPS_PACRF_WP7 = 0x2
	// This peripheral allows write accesses.
	AIPS_PACRF_WP7_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRF_WP7_1 = 0x1
	// Position of SP7 field.
	AIPS_PACRF_SP7_Pos = 0x2
	// Bit mask of SP7 field.
	AIPS_PACRF_SP7_Msk = 0x4
	// Bit SP7.
	AIPS_PACRF_SP7 = 0x4
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRF_SP7_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRF_SP7_1 = 0x1
	// Position of TP6 field.
	AIPS_PACRF_TP6_Pos = 0x4
	// Bit mask of TP6 field.
	AIPS_PACRF_TP6_Msk = 0x10
	// Bit TP6.
	AIPS_PACRF_TP6 = 0x10
	// Accesses from an untrusted master are allowed.
	AIPS_PACRF_TP6_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRF_TP6_1 = 0x1
	// Position of WP6 field.
	AIPS_PACRF_WP6_Pos = 0x5
	// Bit mask of WP6 field.
	AIPS_PACRF_WP6_Msk = 0x20
	// Bit WP6.
	AIPS_PACRF_WP6 = 0x20
	// This peripheral allows write accesses.
	AIPS_PACRF_WP6_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRF_WP6_1 = 0x1
	// Position of SP6 field.
	AIPS_PACRF_SP6_Pos = 0x6
	// Bit mask of SP6 field.
	AIPS_PACRF_SP6_Msk = 0x40
	// Bit SP6.
	AIPS_PACRF_SP6 = 0x40
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRF_SP6_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRF_SP6_1 = 0x1
	// Position of TP5 field.
	AIPS_PACRF_TP5_Pos = 0x8
	// Bit mask of TP5 field.
	AIPS_PACRF_TP5_Msk = 0x100
	// Bit TP5.
	AIPS_PACRF_TP5 = 0x100
	// Accesses from an untrusted master are allowed.
	AIPS_PACRF_TP5_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRF_TP5_1 = 0x1
	// Position of WP5 field.
	AIPS_PACRF_WP5_Pos = 0x9
	// Bit mask of WP5 field.
	AIPS_PACRF_WP5_Msk = 0x200
	// Bit WP5.
	AIPS_PACRF_WP5 = 0x200
	// This peripheral allows write accesses.
	AIPS_PACRF_WP5_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRF_WP5_1 = 0x1
	// Position of SP5 field.
	AIPS_PACRF_SP5_Pos = 0xa
	// Bit mask of SP5 field.
	AIPS_PACRF_SP5_Msk = 0x400
	// Bit SP5.
	AIPS_PACRF_SP5 = 0x400
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRF_SP5_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRF_SP5_1 = 0x1
	// Position of TP4 field.
	AIPS_PACRF_TP4_Pos = 0xc
	// Bit mask of TP4 field.
	AIPS_PACRF_TP4_Msk = 0x1000
	// Bit TP4.
	AIPS_PACRF_TP4 = 0x1000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRF_TP4_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRF_TP4_1 = 0x1
	// Position of WP4 field.
	AIPS_PACRF_WP4_Pos = 0xd
	// Bit mask of WP4 field.
	AIPS_PACRF_WP4_Msk = 0x2000
	// Bit WP4.
	AIPS_PACRF_WP4 = 0x2000
	// This peripheral allows write accesses.
	AIPS_PACRF_WP4_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRF_WP4_1 = 0x1
	// Position of SP4 field.
	AIPS_PACRF_SP4_Pos = 0xe
	// Bit mask of SP4 field.
	AIPS_PACRF_SP4_Msk = 0x4000
	// Bit SP4.
	AIPS_PACRF_SP4 = 0x4000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRF_SP4_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRF_SP4_1 = 0x1
	// Position of TP3 field.
	AIPS_PACRF_TP3_Pos = 0x10
	// Bit mask of TP3 field.
	AIPS_PACRF_TP3_Msk = 0x10000
	// Bit TP3.
	AIPS_PACRF_TP3 = 0x10000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRF_TP3_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRF_TP3_1 = 0x1
	// Position of WP3 field.
	AIPS_PACRF_WP3_Pos = 0x11
	// Bit mask of WP3 field.
	AIPS_PACRF_WP3_Msk = 0x20000
	// Bit WP3.
	AIPS_PACRF_WP3 = 0x20000
	// This peripheral allows write accesses.
	AIPS_PACRF_WP3_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRF_WP3_1 = 0x1
	// Position of SP3 field.
	AIPS_PACRF_SP3_Pos = 0x12
	// Bit mask of SP3 field.
	AIPS_PACRF_SP3_Msk = 0x40000
	// Bit SP3.
	AIPS_PACRF_SP3 = 0x40000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRF_SP3_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRF_SP3_1 = 0x1
	// Position of TP2 field.
	AIPS_PACRF_TP2_Pos = 0x14
	// Bit mask of TP2 field.
	AIPS_PACRF_TP2_Msk = 0x100000
	// Bit TP2.
	AIPS_PACRF_TP2 = 0x100000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRF_TP2_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRF_TP2_1 = 0x1
	// Position of WP2 field.
	AIPS_PACRF_WP2_Pos = 0x15
	// Bit mask of WP2 field.
	AIPS_PACRF_WP2_Msk = 0x200000
	// Bit WP2.
	AIPS_PACRF_WP2 = 0x200000
	// This peripheral allows write accesses.
	AIPS_PACRF_WP2_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRF_WP2_1 = 0x1
	// Position of SP2 field.
	AIPS_PACRF_SP2_Pos = 0x16
	// Bit mask of SP2 field.
	AIPS_PACRF_SP2_Msk = 0x400000
	// Bit SP2.
	AIPS_PACRF_SP2 = 0x400000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRF_SP2_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRF_SP2_1 = 0x1
	// Position of TP1 field.
	AIPS_PACRF_TP1_Pos = 0x18
	// Bit mask of TP1 field.
	AIPS_PACRF_TP1_Msk = 0x1000000
	// Bit TP1.
	AIPS_PACRF_TP1 = 0x1000000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRF_TP1_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRF_TP1_1 = 0x1
	// Position of WP1 field.
	AIPS_PACRF_WP1_Pos = 0x19
	// Bit mask of WP1 field.
	AIPS_PACRF_WP1_Msk = 0x2000000
	// Bit WP1.
	AIPS_PACRF_WP1 = 0x2000000
	// This peripheral allows write accesses.
	AIPS_PACRF_WP1_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRF_WP1_1 = 0x1
	// Position of SP1 field.
	AIPS_PACRF_SP1_Pos = 0x1a
	// Bit mask of SP1 field.
	AIPS_PACRF_SP1_Msk = 0x4000000
	// Bit SP1.
	AIPS_PACRF_SP1 = 0x4000000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRF_SP1_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRF_SP1_1 = 0x1
	// Position of TP0 field.
	AIPS_PACRF_TP0_Pos = 0x1c
	// Bit mask of TP0 field.
	AIPS_PACRF_TP0_Msk = 0x10000000
	// Bit TP0.
	AIPS_PACRF_TP0 = 0x10000000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRF_TP0_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRF_TP0_1 = 0x1
	// Position of WP0 field.
	AIPS_PACRF_WP0_Pos = 0x1d
	// Bit mask of WP0 field.
	AIPS_PACRF_WP0_Msk = 0x20000000
	// Bit WP0.
	AIPS_PACRF_WP0 = 0x20000000
	// This peripheral allows write accesses.
	AIPS_PACRF_WP0_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRF_WP0_1 = 0x1
	// Position of SP0 field.
	AIPS_PACRF_SP0_Pos = 0x1e
	// Bit mask of SP0 field.
	AIPS_PACRF_SP0_Msk = 0x40000000
	// Bit SP0.
	AIPS_PACRF_SP0 = 0x40000000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRF_SP0_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRF_SP0_1 = 0x1

	// PACRG: Peripheral Access Control Register
	// Position of TP7 field.
	AIPS_PACRG_TP7_Pos = 0x0
	// Bit mask of TP7 field.
	AIPS_PACRG_TP7_Msk = 0x1
	// Bit TP7.
	AIPS_PACRG_TP7 = 0x1
	// Accesses from an untrusted master are allowed.
	AIPS_PACRG_TP7_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRG_TP7_1 = 0x1
	// Position of WP7 field.
	AIPS_PACRG_WP7_Pos = 0x1
	// Bit mask of WP7 field.
	AIPS_PACRG_WP7_Msk = 0x2
	// Bit WP7.
	AIPS_PACRG_WP7 = 0x2
	// This peripheral allows write accesses.
	AIPS_PACRG_WP7_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRG_WP7_1 = 0x1
	// Position of SP7 field.
	AIPS_PACRG_SP7_Pos = 0x2
	// Bit mask of SP7 field.
	AIPS_PACRG_SP7_Msk = 0x4
	// Bit SP7.
	AIPS_PACRG_SP7 = 0x4
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRG_SP7_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRG_SP7_1 = 0x1
	// Position of TP6 field.
	AIPS_PACRG_TP6_Pos = 0x4
	// Bit mask of TP6 field.
	AIPS_PACRG_TP6_Msk = 0x10
	// Bit TP6.
	AIPS_PACRG_TP6 = 0x10
	// Accesses from an untrusted master are allowed.
	AIPS_PACRG_TP6_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRG_TP6_1 = 0x1
	// Position of WP6 field.
	AIPS_PACRG_WP6_Pos = 0x5
	// Bit mask of WP6 field.
	AIPS_PACRG_WP6_Msk = 0x20
	// Bit WP6.
	AIPS_PACRG_WP6 = 0x20
	// This peripheral allows write accesses.
	AIPS_PACRG_WP6_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRG_WP6_1 = 0x1
	// Position of SP6 field.
	AIPS_PACRG_SP6_Pos = 0x6
	// Bit mask of SP6 field.
	AIPS_PACRG_SP6_Msk = 0x40
	// Bit SP6.
	AIPS_PACRG_SP6 = 0x40
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRG_SP6_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRG_SP6_1 = 0x1
	// Position of TP5 field.
	AIPS_PACRG_TP5_Pos = 0x8
	// Bit mask of TP5 field.
	AIPS_PACRG_TP5_Msk = 0x100
	// Bit TP5.
	AIPS_PACRG_TP5 = 0x100
	// Accesses from an untrusted master are allowed.
	AIPS_PACRG_TP5_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRG_TP5_1 = 0x1
	// Position of WP5 field.
	AIPS_PACRG_WP5_Pos = 0x9
	// Bit mask of WP5 field.
	AIPS_PACRG_WP5_Msk = 0x200
	// Bit WP5.
	AIPS_PACRG_WP5 = 0x200
	// This peripheral allows write accesses.
	AIPS_PACRG_WP5_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRG_WP5_1 = 0x1
	// Position of SP5 field.
	AIPS_PACRG_SP5_Pos = 0xa
	// Bit mask of SP5 field.
	AIPS_PACRG_SP5_Msk = 0x400
	// Bit SP5.
	AIPS_PACRG_SP5 = 0x400
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRG_SP5_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRG_SP5_1 = 0x1
	// Position of TP4 field.
	AIPS_PACRG_TP4_Pos = 0xc
	// Bit mask of TP4 field.
	AIPS_PACRG_TP4_Msk = 0x1000
	// Bit TP4.
	AIPS_PACRG_TP4 = 0x1000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRG_TP4_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRG_TP4_1 = 0x1
	// Position of WP4 field.
	AIPS_PACRG_WP4_Pos = 0xd
	// Bit mask of WP4 field.
	AIPS_PACRG_WP4_Msk = 0x2000
	// Bit WP4.
	AIPS_PACRG_WP4 = 0x2000
	// This peripheral allows write accesses.
	AIPS_PACRG_WP4_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRG_WP4_1 = 0x1
	// Position of SP4 field.
	AIPS_PACRG_SP4_Pos = 0xe
	// Bit mask of SP4 field.
	AIPS_PACRG_SP4_Msk = 0x4000
	// Bit SP4.
	AIPS_PACRG_SP4 = 0x4000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRG_SP4_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRG_SP4_1 = 0x1
	// Position of TP3 field.
	AIPS_PACRG_TP3_Pos = 0x10
	// Bit mask of TP3 field.
	AIPS_PACRG_TP3_Msk = 0x10000
	// Bit TP3.
	AIPS_PACRG_TP3 = 0x10000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRG_TP3_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRG_TP3_1 = 0x1
	// Position of WP3 field.
	AIPS_PACRG_WP3_Pos = 0x11
	// Bit mask of WP3 field.
	AIPS_PACRG_WP3_Msk = 0x20000
	// Bit WP3.
	AIPS_PACRG_WP3 = 0x20000
	// This peripheral allows write accesses.
	AIPS_PACRG_WP3_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRG_WP3_1 = 0x1
	// Position of SP3 field.
	AIPS_PACRG_SP3_Pos = 0x12
	// Bit mask of SP3 field.
	AIPS_PACRG_SP3_Msk = 0x40000
	// Bit SP3.
	AIPS_PACRG_SP3 = 0x40000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRG_SP3_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRG_SP3_1 = 0x1
	// Position of TP2 field.
	AIPS_PACRG_TP2_Pos = 0x14
	// Bit mask of TP2 field.
	AIPS_PACRG_TP2_Msk = 0x100000
	// Bit TP2.
	AIPS_PACRG_TP2 = 0x100000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRG_TP2_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRG_TP2_1 = 0x1
	// Position of WP2 field.
	AIPS_PACRG_WP2_Pos = 0x15
	// Bit mask of WP2 field.
	AIPS_PACRG_WP2_Msk = 0x200000
	// Bit WP2.
	AIPS_PACRG_WP2 = 0x200000
	// This peripheral allows write accesses.
	AIPS_PACRG_WP2_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRG_WP2_1 = 0x1
	// Position of SP2 field.
	AIPS_PACRG_SP2_Pos = 0x16
	// Bit mask of SP2 field.
	AIPS_PACRG_SP2_Msk = 0x400000
	// Bit SP2.
	AIPS_PACRG_SP2 = 0x400000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRG_SP2_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRG_SP2_1 = 0x1
	// Position of TP1 field.
	AIPS_PACRG_TP1_Pos = 0x18
	// Bit mask of TP1 field.
	AIPS_PACRG_TP1_Msk = 0x1000000
	// Bit TP1.
	AIPS_PACRG_TP1 = 0x1000000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRG_TP1_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRG_TP1_1 = 0x1
	// Position of WP1 field.
	AIPS_PACRG_WP1_Pos = 0x19
	// Bit mask of WP1 field.
	AIPS_PACRG_WP1_Msk = 0x2000000
	// Bit WP1.
	AIPS_PACRG_WP1 = 0x2000000
	// This peripheral allows write accesses.
	AIPS_PACRG_WP1_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRG_WP1_1 = 0x1
	// Position of SP1 field.
	AIPS_PACRG_SP1_Pos = 0x1a
	// Bit mask of SP1 field.
	AIPS_PACRG_SP1_Msk = 0x4000000
	// Bit SP1.
	AIPS_PACRG_SP1 = 0x4000000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRG_SP1_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRG_SP1_1 = 0x1
	// Position of TP0 field.
	AIPS_PACRG_TP0_Pos = 0x1c
	// Bit mask of TP0 field.
	AIPS_PACRG_TP0_Msk = 0x10000000
	// Bit TP0.
	AIPS_PACRG_TP0 = 0x10000000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRG_TP0_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRG_TP0_1 = 0x1
	// Position of WP0 field.
	AIPS_PACRG_WP0_Pos = 0x1d
	// Bit mask of WP0 field.
	AIPS_PACRG_WP0_Msk = 0x20000000
	// Bit WP0.
	AIPS_PACRG_WP0 = 0x20000000
	// This peripheral allows write accesses.
	AIPS_PACRG_WP0_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRG_WP0_1 = 0x1
	// Position of SP0 field.
	AIPS_PACRG_SP0_Pos = 0x1e
	// Bit mask of SP0 field.
	AIPS_PACRG_SP0_Msk = 0x40000000
	// Bit SP0.
	AIPS_PACRG_SP0 = 0x40000000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRG_SP0_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRG_SP0_1 = 0x1

	// PACRH: Peripheral Access Control Register
	// Position of TP7 field.
	AIPS_PACRH_TP7_Pos = 0x0
	// Bit mask of TP7 field.
	AIPS_PACRH_TP7_Msk = 0x1
	// Bit TP7.
	AIPS_PACRH_TP7 = 0x1
	// Accesses from an untrusted master are allowed.
	AIPS_PACRH_TP7_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRH_TP7_1 = 0x1
	// Position of WP7 field.
	AIPS_PACRH_WP7_Pos = 0x1
	// Bit mask of WP7 field.
	AIPS_PACRH_WP7_Msk = 0x2
	// Bit WP7.
	AIPS_PACRH_WP7 = 0x2
	// This peripheral allows write accesses.
	AIPS_PACRH_WP7_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRH_WP7_1 = 0x1
	// Position of SP7 field.
	AIPS_PACRH_SP7_Pos = 0x2
	// Bit mask of SP7 field.
	AIPS_PACRH_SP7_Msk = 0x4
	// Bit SP7.
	AIPS_PACRH_SP7 = 0x4
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRH_SP7_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRH_SP7_1 = 0x1
	// Position of TP6 field.
	AIPS_PACRH_TP6_Pos = 0x4
	// Bit mask of TP6 field.
	AIPS_PACRH_TP6_Msk = 0x10
	// Bit TP6.
	AIPS_PACRH_TP6 = 0x10
	// Accesses from an untrusted master are allowed.
	AIPS_PACRH_TP6_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRH_TP6_1 = 0x1
	// Position of WP6 field.
	AIPS_PACRH_WP6_Pos = 0x5
	// Bit mask of WP6 field.
	AIPS_PACRH_WP6_Msk = 0x20
	// Bit WP6.
	AIPS_PACRH_WP6 = 0x20
	// This peripheral allows write accesses.
	AIPS_PACRH_WP6_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRH_WP6_1 = 0x1
	// Position of SP6 field.
	AIPS_PACRH_SP6_Pos = 0x6
	// Bit mask of SP6 field.
	AIPS_PACRH_SP6_Msk = 0x40
	// Bit SP6.
	AIPS_PACRH_SP6 = 0x40
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRH_SP6_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRH_SP6_1 = 0x1
	// Position of TP5 field.
	AIPS_PACRH_TP5_Pos = 0x8
	// Bit mask of TP5 field.
	AIPS_PACRH_TP5_Msk = 0x100
	// Bit TP5.
	AIPS_PACRH_TP5 = 0x100
	// Accesses from an untrusted master are allowed.
	AIPS_PACRH_TP5_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRH_TP5_1 = 0x1
	// Position of WP5 field.
	AIPS_PACRH_WP5_Pos = 0x9
	// Bit mask of WP5 field.
	AIPS_PACRH_WP5_Msk = 0x200
	// Bit WP5.
	AIPS_PACRH_WP5 = 0x200
	// This peripheral allows write accesses.
	AIPS_PACRH_WP5_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRH_WP5_1 = 0x1
	// Position of SP5 field.
	AIPS_PACRH_SP5_Pos = 0xa
	// Bit mask of SP5 field.
	AIPS_PACRH_SP5_Msk = 0x400
	// Bit SP5.
	AIPS_PACRH_SP5 = 0x400
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRH_SP5_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRH_SP5_1 = 0x1
	// Position of TP4 field.
	AIPS_PACRH_TP4_Pos = 0xc
	// Bit mask of TP4 field.
	AIPS_PACRH_TP4_Msk = 0x1000
	// Bit TP4.
	AIPS_PACRH_TP4 = 0x1000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRH_TP4_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRH_TP4_1 = 0x1
	// Position of WP4 field.
	AIPS_PACRH_WP4_Pos = 0xd
	// Bit mask of WP4 field.
	AIPS_PACRH_WP4_Msk = 0x2000
	// Bit WP4.
	AIPS_PACRH_WP4 = 0x2000
	// This peripheral allows write accesses.
	AIPS_PACRH_WP4_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRH_WP4_1 = 0x1
	// Position of SP4 field.
	AIPS_PACRH_SP4_Pos = 0xe
	// Bit mask of SP4 field.
	AIPS_PACRH_SP4_Msk = 0x4000
	// Bit SP4.
	AIPS_PACRH_SP4 = 0x4000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRH_SP4_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRH_SP4_1 = 0x1
	// Position of TP3 field.
	AIPS_PACRH_TP3_Pos = 0x10
	// Bit mask of TP3 field.
	AIPS_PACRH_TP3_Msk = 0x10000
	// Bit TP3.
	AIPS_PACRH_TP3 = 0x10000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRH_TP3_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRH_TP3_1 = 0x1
	// Position of WP3 field.
	AIPS_PACRH_WP3_Pos = 0x11
	// Bit mask of WP3 field.
	AIPS_PACRH_WP3_Msk = 0x20000
	// Bit WP3.
	AIPS_PACRH_WP3 = 0x20000
	// This peripheral allows write accesses.
	AIPS_PACRH_WP3_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRH_WP3_1 = 0x1
	// Position of SP3 field.
	AIPS_PACRH_SP3_Pos = 0x12
	// Bit mask of SP3 field.
	AIPS_PACRH_SP3_Msk = 0x40000
	// Bit SP3.
	AIPS_PACRH_SP3 = 0x40000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRH_SP3_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRH_SP3_1 = 0x1
	// Position of TP2 field.
	AIPS_PACRH_TP2_Pos = 0x14
	// Bit mask of TP2 field.
	AIPS_PACRH_TP2_Msk = 0x100000
	// Bit TP2.
	AIPS_PACRH_TP2 = 0x100000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRH_TP2_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRH_TP2_1 = 0x1
	// Position of WP2 field.
	AIPS_PACRH_WP2_Pos = 0x15
	// Bit mask of WP2 field.
	AIPS_PACRH_WP2_Msk = 0x200000
	// Bit WP2.
	AIPS_PACRH_WP2 = 0x200000
	// This peripheral allows write accesses.
	AIPS_PACRH_WP2_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRH_WP2_1 = 0x1
	// Position of SP2 field.
	AIPS_PACRH_SP2_Pos = 0x16
	// Bit mask of SP2 field.
	AIPS_PACRH_SP2_Msk = 0x400000
	// Bit SP2.
	AIPS_PACRH_SP2 = 0x400000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRH_SP2_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRH_SP2_1 = 0x1
	// Position of TP1 field.
	AIPS_PACRH_TP1_Pos = 0x18
	// Bit mask of TP1 field.
	AIPS_PACRH_TP1_Msk = 0x1000000
	// Bit TP1.
	AIPS_PACRH_TP1 = 0x1000000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRH_TP1_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRH_TP1_1 = 0x1
	// Position of WP1 field.
	AIPS_PACRH_WP1_Pos = 0x19
	// Bit mask of WP1 field.
	AIPS_PACRH_WP1_Msk = 0x2000000
	// Bit WP1.
	AIPS_PACRH_WP1 = 0x2000000
	// This peripheral allows write accesses.
	AIPS_PACRH_WP1_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRH_WP1_1 = 0x1
	// Position of SP1 field.
	AIPS_PACRH_SP1_Pos = 0x1a
	// Bit mask of SP1 field.
	AIPS_PACRH_SP1_Msk = 0x4000000
	// Bit SP1.
	AIPS_PACRH_SP1 = 0x4000000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRH_SP1_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRH_SP1_1 = 0x1
	// Position of TP0 field.
	AIPS_PACRH_TP0_Pos = 0x1c
	// Bit mask of TP0 field.
	AIPS_PACRH_TP0_Msk = 0x10000000
	// Bit TP0.
	AIPS_PACRH_TP0 = 0x10000000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRH_TP0_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRH_TP0_1 = 0x1
	// Position of WP0 field.
	AIPS_PACRH_WP0_Pos = 0x1d
	// Bit mask of WP0 field.
	AIPS_PACRH_WP0_Msk = 0x20000000
	// Bit WP0.
	AIPS_PACRH_WP0 = 0x20000000
	// This peripheral allows write accesses.
	AIPS_PACRH_WP0_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRH_WP0_1 = 0x1
	// Position of SP0 field.
	AIPS_PACRH_SP0_Pos = 0x1e
	// Bit mask of SP0 field.
	AIPS_PACRH_SP0_Msk = 0x40000000
	// Bit SP0.
	AIPS_PACRH_SP0 = 0x40000000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRH_SP0_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRH_SP0_1 = 0x1

	// PACRI: Peripheral Access Control Register
	// Position of TP7 field.
	AIPS_PACRI_TP7_Pos = 0x0
	// Bit mask of TP7 field.
	AIPS_PACRI_TP7_Msk = 0x1
	// Bit TP7.
	AIPS_PACRI_TP7 = 0x1
	// Accesses from an untrusted master are allowed.
	AIPS_PACRI_TP7_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRI_TP7_1 = 0x1
	// Position of WP7 field.
	AIPS_PACRI_WP7_Pos = 0x1
	// Bit mask of WP7 field.
	AIPS_PACRI_WP7_Msk = 0x2
	// Bit WP7.
	AIPS_PACRI_WP7 = 0x2
	// This peripheral allows write accesses.
	AIPS_PACRI_WP7_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRI_WP7_1 = 0x1
	// Position of SP7 field.
	AIPS_PACRI_SP7_Pos = 0x2
	// Bit mask of SP7 field.
	AIPS_PACRI_SP7_Msk = 0x4
	// Bit SP7.
	AIPS_PACRI_SP7 = 0x4
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRI_SP7_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRI_SP7_1 = 0x1
	// Position of TP6 field.
	AIPS_PACRI_TP6_Pos = 0x4
	// Bit mask of TP6 field.
	AIPS_PACRI_TP6_Msk = 0x10
	// Bit TP6.
	AIPS_PACRI_TP6 = 0x10
	// Accesses from an untrusted master are allowed.
	AIPS_PACRI_TP6_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRI_TP6_1 = 0x1
	// Position of WP6 field.
	AIPS_PACRI_WP6_Pos = 0x5
	// Bit mask of WP6 field.
	AIPS_PACRI_WP6_Msk = 0x20
	// Bit WP6.
	AIPS_PACRI_WP6 = 0x20
	// This peripheral allows write accesses.
	AIPS_PACRI_WP6_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRI_WP6_1 = 0x1
	// Position of SP6 field.
	AIPS_PACRI_SP6_Pos = 0x6
	// Bit mask of SP6 field.
	AIPS_PACRI_SP6_Msk = 0x40
	// Bit SP6.
	AIPS_PACRI_SP6 = 0x40
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRI_SP6_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRI_SP6_1 = 0x1
	// Position of TP5 field.
	AIPS_PACRI_TP5_Pos = 0x8
	// Bit mask of TP5 field.
	AIPS_PACRI_TP5_Msk = 0x100
	// Bit TP5.
	AIPS_PACRI_TP5 = 0x100
	// Accesses from an untrusted master are allowed.
	AIPS_PACRI_TP5_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRI_TP5_1 = 0x1
	// Position of WP5 field.
	AIPS_PACRI_WP5_Pos = 0x9
	// Bit mask of WP5 field.
	AIPS_PACRI_WP5_Msk = 0x200
	// Bit WP5.
	AIPS_PACRI_WP5 = 0x200
	// This peripheral allows write accesses.
	AIPS_PACRI_WP5_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRI_WP5_1 = 0x1
	// Position of SP5 field.
	AIPS_PACRI_SP5_Pos = 0xa
	// Bit mask of SP5 field.
	AIPS_PACRI_SP5_Msk = 0x400
	// Bit SP5.
	AIPS_PACRI_SP5 = 0x400
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRI_SP5_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRI_SP5_1 = 0x1
	// Position of TP4 field.
	AIPS_PACRI_TP4_Pos = 0xc
	// Bit mask of TP4 field.
	AIPS_PACRI_TP4_Msk = 0x1000
	// Bit TP4.
	AIPS_PACRI_TP4 = 0x1000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRI_TP4_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRI_TP4_1 = 0x1
	// Position of WP4 field.
	AIPS_PACRI_WP4_Pos = 0xd
	// Bit mask of WP4 field.
	AIPS_PACRI_WP4_Msk = 0x2000
	// Bit WP4.
	AIPS_PACRI_WP4 = 0x2000
	// This peripheral allows write accesses.
	AIPS_PACRI_WP4_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRI_WP4_1 = 0x1
	// Position of SP4 field.
	AIPS_PACRI_SP4_Pos = 0xe
	// Bit mask of SP4 field.
	AIPS_PACRI_SP4_Msk = 0x4000
	// Bit SP4.
	AIPS_PACRI_SP4 = 0x4000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRI_SP4_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRI_SP4_1 = 0x1
	// Position of TP3 field.
	AIPS_PACRI_TP3_Pos = 0x10
	// Bit mask of TP3 field.
	AIPS_PACRI_TP3_Msk = 0x10000
	// Bit TP3.
	AIPS_PACRI_TP3 = 0x10000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRI_TP3_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRI_TP3_1 = 0x1
	// Position of WP3 field.
	AIPS_PACRI_WP3_Pos = 0x11
	// Bit mask of WP3 field.
	AIPS_PACRI_WP3_Msk = 0x20000
	// Bit WP3.
	AIPS_PACRI_WP3 = 0x20000
	// This peripheral allows write accesses.
	AIPS_PACRI_WP3_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRI_WP3_1 = 0x1
	// Position of SP3 field.
	AIPS_PACRI_SP3_Pos = 0x12
	// Bit mask of SP3 field.
	AIPS_PACRI_SP3_Msk = 0x40000
	// Bit SP3.
	AIPS_PACRI_SP3 = 0x40000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRI_SP3_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRI_SP3_1 = 0x1
	// Position of TP2 field.
	AIPS_PACRI_TP2_Pos = 0x14
	// Bit mask of TP2 field.
	AIPS_PACRI_TP2_Msk = 0x100000
	// Bit TP2.
	AIPS_PACRI_TP2 = 0x100000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRI_TP2_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRI_TP2_1 = 0x1
	// Position of WP2 field.
	AIPS_PACRI_WP2_Pos = 0x15
	// Bit mask of WP2 field.
	AIPS_PACRI_WP2_Msk = 0x200000
	// Bit WP2.
	AIPS_PACRI_WP2 = 0x200000
	// This peripheral allows write accesses.
	AIPS_PACRI_WP2_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRI_WP2_1 = 0x1
	// Position of SP2 field.
	AIPS_PACRI_SP2_Pos = 0x16
	// Bit mask of SP2 field.
	AIPS_PACRI_SP2_Msk = 0x400000
	// Bit SP2.
	AIPS_PACRI_SP2 = 0x400000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRI_SP2_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRI_SP2_1 = 0x1
	// Position of TP1 field.
	AIPS_PACRI_TP1_Pos = 0x18
	// Bit mask of TP1 field.
	AIPS_PACRI_TP1_Msk = 0x1000000
	// Bit TP1.
	AIPS_PACRI_TP1 = 0x1000000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRI_TP1_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRI_TP1_1 = 0x1
	// Position of WP1 field.
	AIPS_PACRI_WP1_Pos = 0x19
	// Bit mask of WP1 field.
	AIPS_PACRI_WP1_Msk = 0x2000000
	// Bit WP1.
	AIPS_PACRI_WP1 = 0x2000000
	// This peripheral allows write accesses.
	AIPS_PACRI_WP1_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRI_WP1_1 = 0x1
	// Position of SP1 field.
	AIPS_PACRI_SP1_Pos = 0x1a
	// Bit mask of SP1 field.
	AIPS_PACRI_SP1_Msk = 0x4000000
	// Bit SP1.
	AIPS_PACRI_SP1 = 0x4000000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRI_SP1_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRI_SP1_1 = 0x1
	// Position of TP0 field.
	AIPS_PACRI_TP0_Pos = 0x1c
	// Bit mask of TP0 field.
	AIPS_PACRI_TP0_Msk = 0x10000000
	// Bit TP0.
	AIPS_PACRI_TP0 = 0x10000000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRI_TP0_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRI_TP0_1 = 0x1
	// Position of WP0 field.
	AIPS_PACRI_WP0_Pos = 0x1d
	// Bit mask of WP0 field.
	AIPS_PACRI_WP0_Msk = 0x20000000
	// Bit WP0.
	AIPS_PACRI_WP0 = 0x20000000
	// This peripheral allows write accesses.
	AIPS_PACRI_WP0_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRI_WP0_1 = 0x1
	// Position of SP0 field.
	AIPS_PACRI_SP0_Pos = 0x1e
	// Bit mask of SP0 field.
	AIPS_PACRI_SP0_Msk = 0x40000000
	// Bit SP0.
	AIPS_PACRI_SP0 = 0x40000000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRI_SP0_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRI_SP0_1 = 0x1

	// PACRJ: Peripheral Access Control Register
	// Position of TP7 field.
	AIPS_PACRJ_TP7_Pos = 0x0
	// Bit mask of TP7 field.
	AIPS_PACRJ_TP7_Msk = 0x1
	// Bit TP7.
	AIPS_PACRJ_TP7 = 0x1
	// Accesses from an untrusted master are allowed.
	AIPS_PACRJ_TP7_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRJ_TP7_1 = 0x1
	// Position of WP7 field.
	AIPS_PACRJ_WP7_Pos = 0x1
	// Bit mask of WP7 field.
	AIPS_PACRJ_WP7_Msk = 0x2
	// Bit WP7.
	AIPS_PACRJ_WP7 = 0x2
	// This peripheral allows write accesses.
	AIPS_PACRJ_WP7_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRJ_WP7_1 = 0x1
	// Position of SP7 field.
	AIPS_PACRJ_SP7_Pos = 0x2
	// Bit mask of SP7 field.
	AIPS_PACRJ_SP7_Msk = 0x4
	// Bit SP7.
	AIPS_PACRJ_SP7 = 0x4
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRJ_SP7_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRJ_SP7_1 = 0x1
	// Position of TP6 field.
	AIPS_PACRJ_TP6_Pos = 0x4
	// Bit mask of TP6 field.
	AIPS_PACRJ_TP6_Msk = 0x10
	// Bit TP6.
	AIPS_PACRJ_TP6 = 0x10
	// Accesses from an untrusted master are allowed.
	AIPS_PACRJ_TP6_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRJ_TP6_1 = 0x1
	// Position of WP6 field.
	AIPS_PACRJ_WP6_Pos = 0x5
	// Bit mask of WP6 field.
	AIPS_PACRJ_WP6_Msk = 0x20
	// Bit WP6.
	AIPS_PACRJ_WP6 = 0x20
	// This peripheral allows write accesses.
	AIPS_PACRJ_WP6_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRJ_WP6_1 = 0x1
	// Position of SP6 field.
	AIPS_PACRJ_SP6_Pos = 0x6
	// Bit mask of SP6 field.
	AIPS_PACRJ_SP6_Msk = 0x40
	// Bit SP6.
	AIPS_PACRJ_SP6 = 0x40
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRJ_SP6_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRJ_SP6_1 = 0x1
	// Position of TP5 field.
	AIPS_PACRJ_TP5_Pos = 0x8
	// Bit mask of TP5 field.
	AIPS_PACRJ_TP5_Msk = 0x100
	// Bit TP5.
	AIPS_PACRJ_TP5 = 0x100
	// Accesses from an untrusted master are allowed.
	AIPS_PACRJ_TP5_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRJ_TP5_1 = 0x1
	// Position of WP5 field.
	AIPS_PACRJ_WP5_Pos = 0x9
	// Bit mask of WP5 field.
	AIPS_PACRJ_WP5_Msk = 0x200
	// Bit WP5.
	AIPS_PACRJ_WP5 = 0x200
	// This peripheral allows write accesses.
	AIPS_PACRJ_WP5_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRJ_WP5_1 = 0x1
	// Position of SP5 field.
	AIPS_PACRJ_SP5_Pos = 0xa
	// Bit mask of SP5 field.
	AIPS_PACRJ_SP5_Msk = 0x400
	// Bit SP5.
	AIPS_PACRJ_SP5 = 0x400
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRJ_SP5_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRJ_SP5_1 = 0x1
	// Position of TP4 field.
	AIPS_PACRJ_TP4_Pos = 0xc
	// Bit mask of TP4 field.
	AIPS_PACRJ_TP4_Msk = 0x1000
	// Bit TP4.
	AIPS_PACRJ_TP4 = 0x1000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRJ_TP4_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRJ_TP4_1 = 0x1
	// Position of WP4 field.
	AIPS_PACRJ_WP4_Pos = 0xd
	// Bit mask of WP4 field.
	AIPS_PACRJ_WP4_Msk = 0x2000
	// Bit WP4.
	AIPS_PACRJ_WP4 = 0x2000
	// This peripheral allows write accesses.
	AIPS_PACRJ_WP4_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRJ_WP4_1 = 0x1
	// Position of SP4 field.
	AIPS_PACRJ_SP4_Pos = 0xe
	// Bit mask of SP4 field.
	AIPS_PACRJ_SP4_Msk = 0x4000
	// Bit SP4.
	AIPS_PACRJ_SP4 = 0x4000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRJ_SP4_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRJ_SP4_1 = 0x1
	// Position of TP3 field.
	AIPS_PACRJ_TP3_Pos = 0x10
	// Bit mask of TP3 field.
	AIPS_PACRJ_TP3_Msk = 0x10000
	// Bit TP3.
	AIPS_PACRJ_TP3 = 0x10000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRJ_TP3_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRJ_TP3_1 = 0x1
	// Position of WP3 field.
	AIPS_PACRJ_WP3_Pos = 0x11
	// Bit mask of WP3 field.
	AIPS_PACRJ_WP3_Msk = 0x20000
	// Bit WP3.
	AIPS_PACRJ_WP3 = 0x20000
	// This peripheral allows write accesses.
	AIPS_PACRJ_WP3_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRJ_WP3_1 = 0x1
	// Position of SP3 field.
	AIPS_PACRJ_SP3_Pos = 0x12
	// Bit mask of SP3 field.
	AIPS_PACRJ_SP3_Msk = 0x40000
	// Bit SP3.
	AIPS_PACRJ_SP3 = 0x40000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRJ_SP3_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRJ_SP3_1 = 0x1
	// Position of TP2 field.
	AIPS_PACRJ_TP2_Pos = 0x14
	// Bit mask of TP2 field.
	AIPS_PACRJ_TP2_Msk = 0x100000
	// Bit TP2.
	AIPS_PACRJ_TP2 = 0x100000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRJ_TP2_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRJ_TP2_1 = 0x1
	// Position of WP2 field.
	AIPS_PACRJ_WP2_Pos = 0x15
	// Bit mask of WP2 field.
	AIPS_PACRJ_WP2_Msk = 0x200000
	// Bit WP2.
	AIPS_PACRJ_WP2 = 0x200000
	// This peripheral allows write accesses.
	AIPS_PACRJ_WP2_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRJ_WP2_1 = 0x1
	// Position of SP2 field.
	AIPS_PACRJ_SP2_Pos = 0x16
	// Bit mask of SP2 field.
	AIPS_PACRJ_SP2_Msk = 0x400000
	// Bit SP2.
	AIPS_PACRJ_SP2 = 0x400000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRJ_SP2_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRJ_SP2_1 = 0x1
	// Position of TP1 field.
	AIPS_PACRJ_TP1_Pos = 0x18
	// Bit mask of TP1 field.
	AIPS_PACRJ_TP1_Msk = 0x1000000
	// Bit TP1.
	AIPS_PACRJ_TP1 = 0x1000000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRJ_TP1_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRJ_TP1_1 = 0x1
	// Position of WP1 field.
	AIPS_PACRJ_WP1_Pos = 0x19
	// Bit mask of WP1 field.
	AIPS_PACRJ_WP1_Msk = 0x2000000
	// Bit WP1.
	AIPS_PACRJ_WP1 = 0x2000000
	// This peripheral allows write accesses.
	AIPS_PACRJ_WP1_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRJ_WP1_1 = 0x1
	// Position of SP1 field.
	AIPS_PACRJ_SP1_Pos = 0x1a
	// Bit mask of SP1 field.
	AIPS_PACRJ_SP1_Msk = 0x4000000
	// Bit SP1.
	AIPS_PACRJ_SP1 = 0x4000000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRJ_SP1_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRJ_SP1_1 = 0x1
	// Position of TP0 field.
	AIPS_PACRJ_TP0_Pos = 0x1c
	// Bit mask of TP0 field.
	AIPS_PACRJ_TP0_Msk = 0x10000000
	// Bit TP0.
	AIPS_PACRJ_TP0 = 0x10000000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRJ_TP0_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRJ_TP0_1 = 0x1
	// Position of WP0 field.
	AIPS_PACRJ_WP0_Pos = 0x1d
	// Bit mask of WP0 field.
	AIPS_PACRJ_WP0_Msk = 0x20000000
	// Bit WP0.
	AIPS_PACRJ_WP0 = 0x20000000
	// This peripheral allows write accesses.
	AIPS_PACRJ_WP0_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRJ_WP0_1 = 0x1
	// Position of SP0 field.
	AIPS_PACRJ_SP0_Pos = 0x1e
	// Bit mask of SP0 field.
	AIPS_PACRJ_SP0_Msk = 0x40000000
	// Bit SP0.
	AIPS_PACRJ_SP0 = 0x40000000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRJ_SP0_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRJ_SP0_1 = 0x1

	// PACRK: Peripheral Access Control Register
	// Position of TP7 field.
	AIPS_PACRK_TP7_Pos = 0x0
	// Bit mask of TP7 field.
	AIPS_PACRK_TP7_Msk = 0x1
	// Bit TP7.
	AIPS_PACRK_TP7 = 0x1
	// Accesses from an untrusted master are allowed.
	AIPS_PACRK_TP7_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRK_TP7_1 = 0x1
	// Position of WP7 field.
	AIPS_PACRK_WP7_Pos = 0x1
	// Bit mask of WP7 field.
	AIPS_PACRK_WP7_Msk = 0x2
	// Bit WP7.
	AIPS_PACRK_WP7 = 0x2
	// This peripheral allows write accesses.
	AIPS_PACRK_WP7_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRK_WP7_1 = 0x1
	// Position of SP7 field.
	AIPS_PACRK_SP7_Pos = 0x2
	// Bit mask of SP7 field.
	AIPS_PACRK_SP7_Msk = 0x4
	// Bit SP7.
	AIPS_PACRK_SP7 = 0x4
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRK_SP7_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRK_SP7_1 = 0x1
	// Position of TP6 field.
	AIPS_PACRK_TP6_Pos = 0x4
	// Bit mask of TP6 field.
	AIPS_PACRK_TP6_Msk = 0x10
	// Bit TP6.
	AIPS_PACRK_TP6 = 0x10
	// Accesses from an untrusted master are allowed.
	AIPS_PACRK_TP6_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRK_TP6_1 = 0x1
	// Position of WP6 field.
	AIPS_PACRK_WP6_Pos = 0x5
	// Bit mask of WP6 field.
	AIPS_PACRK_WP6_Msk = 0x20
	// Bit WP6.
	AIPS_PACRK_WP6 = 0x20
	// This peripheral allows write accesses.
	AIPS_PACRK_WP6_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRK_WP6_1 = 0x1
	// Position of SP6 field.
	AIPS_PACRK_SP6_Pos = 0x6
	// Bit mask of SP6 field.
	AIPS_PACRK_SP6_Msk = 0x40
	// Bit SP6.
	AIPS_PACRK_SP6 = 0x40
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRK_SP6_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRK_SP6_1 = 0x1
	// Position of TP5 field.
	AIPS_PACRK_TP5_Pos = 0x8
	// Bit mask of TP5 field.
	AIPS_PACRK_TP5_Msk = 0x100
	// Bit TP5.
	AIPS_PACRK_TP5 = 0x100
	// Accesses from an untrusted master are allowed.
	AIPS_PACRK_TP5_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRK_TP5_1 = 0x1
	// Position of WP5 field.
	AIPS_PACRK_WP5_Pos = 0x9
	// Bit mask of WP5 field.
	AIPS_PACRK_WP5_Msk = 0x200
	// Bit WP5.
	AIPS_PACRK_WP5 = 0x200
	// This peripheral allows write accesses.
	AIPS_PACRK_WP5_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRK_WP5_1 = 0x1
	// Position of SP5 field.
	AIPS_PACRK_SP5_Pos = 0xa
	// Bit mask of SP5 field.
	AIPS_PACRK_SP5_Msk = 0x400
	// Bit SP5.
	AIPS_PACRK_SP5 = 0x400
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRK_SP5_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRK_SP5_1 = 0x1
	// Position of TP4 field.
	AIPS_PACRK_TP4_Pos = 0xc
	// Bit mask of TP4 field.
	AIPS_PACRK_TP4_Msk = 0x1000
	// Bit TP4.
	AIPS_PACRK_TP4 = 0x1000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRK_TP4_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRK_TP4_1 = 0x1
	// Position of WP4 field.
	AIPS_PACRK_WP4_Pos = 0xd
	// Bit mask of WP4 field.
	AIPS_PACRK_WP4_Msk = 0x2000
	// Bit WP4.
	AIPS_PACRK_WP4 = 0x2000
	// This peripheral allows write accesses.
	AIPS_PACRK_WP4_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRK_WP4_1 = 0x1
	// Position of SP4 field.
	AIPS_PACRK_SP4_Pos = 0xe
	// Bit mask of SP4 field.
	AIPS_PACRK_SP4_Msk = 0x4000
	// Bit SP4.
	AIPS_PACRK_SP4 = 0x4000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRK_SP4_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRK_SP4_1 = 0x1
	// Position of TP3 field.
	AIPS_PACRK_TP3_Pos = 0x10
	// Bit mask of TP3 field.
	AIPS_PACRK_TP3_Msk = 0x10000
	// Bit TP3.
	AIPS_PACRK_TP3 = 0x10000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRK_TP3_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRK_TP3_1 = 0x1
	// Position of WP3 field.
	AIPS_PACRK_WP3_Pos = 0x11
	// Bit mask of WP3 field.
	AIPS_PACRK_WP3_Msk = 0x20000
	// Bit WP3.
	AIPS_PACRK_WP3 = 0x20000
	// This peripheral allows write accesses.
	AIPS_PACRK_WP3_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRK_WP3_1 = 0x1
	// Position of SP3 field.
	AIPS_PACRK_SP3_Pos = 0x12
	// Bit mask of SP3 field.
	AIPS_PACRK_SP3_Msk = 0x40000
	// Bit SP3.
	AIPS_PACRK_SP3 = 0x40000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRK_SP3_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRK_SP3_1 = 0x1
	// Position of TP2 field.
	AIPS_PACRK_TP2_Pos = 0x14
	// Bit mask of TP2 field.
	AIPS_PACRK_TP2_Msk = 0x100000
	// Bit TP2.
	AIPS_PACRK_TP2 = 0x100000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRK_TP2_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRK_TP2_1 = 0x1
	// Position of WP2 field.
	AIPS_PACRK_WP2_Pos = 0x15
	// Bit mask of WP2 field.
	AIPS_PACRK_WP2_Msk = 0x200000
	// Bit WP2.
	AIPS_PACRK_WP2 = 0x200000
	// This peripheral allows write accesses.
	AIPS_PACRK_WP2_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRK_WP2_1 = 0x1
	// Position of SP2 field.
	AIPS_PACRK_SP2_Pos = 0x16
	// Bit mask of SP2 field.
	AIPS_PACRK_SP2_Msk = 0x400000
	// Bit SP2.
	AIPS_PACRK_SP2 = 0x400000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRK_SP2_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRK_SP2_1 = 0x1
	// Position of TP1 field.
	AIPS_PACRK_TP1_Pos = 0x18
	// Bit mask of TP1 field.
	AIPS_PACRK_TP1_Msk = 0x1000000
	// Bit TP1.
	AIPS_PACRK_TP1 = 0x1000000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRK_TP1_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRK_TP1_1 = 0x1
	// Position of WP1 field.
	AIPS_PACRK_WP1_Pos = 0x19
	// Bit mask of WP1 field.
	AIPS_PACRK_WP1_Msk = 0x2000000
	// Bit WP1.
	AIPS_PACRK_WP1 = 0x2000000
	// This peripheral allows write accesses.
	AIPS_PACRK_WP1_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRK_WP1_1 = 0x1
	// Position of SP1 field.
	AIPS_PACRK_SP1_Pos = 0x1a
	// Bit mask of SP1 field.
	AIPS_PACRK_SP1_Msk = 0x4000000
	// Bit SP1.
	AIPS_PACRK_SP1 = 0x4000000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRK_SP1_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRK_SP1_1 = 0x1
	// Position of TP0 field.
	AIPS_PACRK_TP0_Pos = 0x1c
	// Bit mask of TP0 field.
	AIPS_PACRK_TP0_Msk = 0x10000000
	// Bit TP0.
	AIPS_PACRK_TP0 = 0x10000000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRK_TP0_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRK_TP0_1 = 0x1
	// Position of WP0 field.
	AIPS_PACRK_WP0_Pos = 0x1d
	// Bit mask of WP0 field.
	AIPS_PACRK_WP0_Msk = 0x20000000
	// Bit WP0.
	AIPS_PACRK_WP0 = 0x20000000
	// This peripheral allows write accesses.
	AIPS_PACRK_WP0_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRK_WP0_1 = 0x1
	// Position of SP0 field.
	AIPS_PACRK_SP0_Pos = 0x1e
	// Bit mask of SP0 field.
	AIPS_PACRK_SP0_Msk = 0x40000000
	// Bit SP0.
	AIPS_PACRK_SP0 = 0x40000000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRK_SP0_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRK_SP0_1 = 0x1

	// PACRL: Peripheral Access Control Register
	// Position of TP7 field.
	AIPS_PACRL_TP7_Pos = 0x0
	// Bit mask of TP7 field.
	AIPS_PACRL_TP7_Msk = 0x1
	// Bit TP7.
	AIPS_PACRL_TP7 = 0x1
	// Accesses from an untrusted master are allowed.
	AIPS_PACRL_TP7_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRL_TP7_1 = 0x1
	// Position of WP7 field.
	AIPS_PACRL_WP7_Pos = 0x1
	// Bit mask of WP7 field.
	AIPS_PACRL_WP7_Msk = 0x2
	// Bit WP7.
	AIPS_PACRL_WP7 = 0x2
	// This peripheral allows write accesses.
	AIPS_PACRL_WP7_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRL_WP7_1 = 0x1
	// Position of SP7 field.
	AIPS_PACRL_SP7_Pos = 0x2
	// Bit mask of SP7 field.
	AIPS_PACRL_SP7_Msk = 0x4
	// Bit SP7.
	AIPS_PACRL_SP7 = 0x4
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRL_SP7_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRL_SP7_1 = 0x1
	// Position of TP6 field.
	AIPS_PACRL_TP6_Pos = 0x4
	// Bit mask of TP6 field.
	AIPS_PACRL_TP6_Msk = 0x10
	// Bit TP6.
	AIPS_PACRL_TP6 = 0x10
	// Accesses from an untrusted master are allowed.
	AIPS_PACRL_TP6_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRL_TP6_1 = 0x1
	// Position of WP6 field.
	AIPS_PACRL_WP6_Pos = 0x5
	// Bit mask of WP6 field.
	AIPS_PACRL_WP6_Msk = 0x20
	// Bit WP6.
	AIPS_PACRL_WP6 = 0x20
	// This peripheral allows write accesses.
	AIPS_PACRL_WP6_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRL_WP6_1 = 0x1
	// Position of SP6 field.
	AIPS_PACRL_SP6_Pos = 0x6
	// Bit mask of SP6 field.
	AIPS_PACRL_SP6_Msk = 0x40
	// Bit SP6.
	AIPS_PACRL_SP6 = 0x40
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRL_SP6_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRL_SP6_1 = 0x1
	// Position of TP5 field.
	AIPS_PACRL_TP5_Pos = 0x8
	// Bit mask of TP5 field.
	AIPS_PACRL_TP5_Msk = 0x100
	// Bit TP5.
	AIPS_PACRL_TP5 = 0x100
	// Accesses from an untrusted master are allowed.
	AIPS_PACRL_TP5_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRL_TP5_1 = 0x1
	// Position of WP5 field.
	AIPS_PACRL_WP5_Pos = 0x9
	// Bit mask of WP5 field.
	AIPS_PACRL_WP5_Msk = 0x200
	// Bit WP5.
	AIPS_PACRL_WP5 = 0x200
	// This peripheral allows write accesses.
	AIPS_PACRL_WP5_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRL_WP5_1 = 0x1
	// Position of SP5 field.
	AIPS_PACRL_SP5_Pos = 0xa
	// Bit mask of SP5 field.
	AIPS_PACRL_SP5_Msk = 0x400
	// Bit SP5.
	AIPS_PACRL_SP5 = 0x400
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRL_SP5_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRL_SP5_1 = 0x1
	// Position of TP4 field.
	AIPS_PACRL_TP4_Pos = 0xc
	// Bit mask of TP4 field.
	AIPS_PACRL_TP4_Msk = 0x1000
	// Bit TP4.
	AIPS_PACRL_TP4 = 0x1000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRL_TP4_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRL_TP4_1 = 0x1
	// Position of WP4 field.
	AIPS_PACRL_WP4_Pos = 0xd
	// Bit mask of WP4 field.
	AIPS_PACRL_WP4_Msk = 0x2000
	// Bit WP4.
	AIPS_PACRL_WP4 = 0x2000
	// This peripheral allows write accesses.
	AIPS_PACRL_WP4_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRL_WP4_1 = 0x1
	// Position of SP4 field.
	AIPS_PACRL_SP4_Pos = 0xe
	// Bit mask of SP4 field.
	AIPS_PACRL_SP4_Msk = 0x4000
	// Bit SP4.
	AIPS_PACRL_SP4 = 0x4000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRL_SP4_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRL_SP4_1 = 0x1
	// Position of TP3 field.
	AIPS_PACRL_TP3_Pos = 0x10
	// Bit mask of TP3 field.
	AIPS_PACRL_TP3_Msk = 0x10000
	// Bit TP3.
	AIPS_PACRL_TP3 = 0x10000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRL_TP3_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRL_TP3_1 = 0x1
	// Position of WP3 field.
	AIPS_PACRL_WP3_Pos = 0x11
	// Bit mask of WP3 field.
	AIPS_PACRL_WP3_Msk = 0x20000
	// Bit WP3.
	AIPS_PACRL_WP3 = 0x20000
	// This peripheral allows write accesses.
	AIPS_PACRL_WP3_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRL_WP3_1 = 0x1
	// Position of SP3 field.
	AIPS_PACRL_SP3_Pos = 0x12
	// Bit mask of SP3 field.
	AIPS_PACRL_SP3_Msk = 0x40000
	// Bit SP3.
	AIPS_PACRL_SP3 = 0x40000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRL_SP3_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRL_SP3_1 = 0x1
	// Position of TP2 field.
	AIPS_PACRL_TP2_Pos = 0x14
	// Bit mask of TP2 field.
	AIPS_PACRL_TP2_Msk = 0x100000
	// Bit TP2.
	AIPS_PACRL_TP2 = 0x100000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRL_TP2_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRL_TP2_1 = 0x1
	// Position of WP2 field.
	AIPS_PACRL_WP2_Pos = 0x15
	// Bit mask of WP2 field.
	AIPS_PACRL_WP2_Msk = 0x200000
	// Bit WP2.
	AIPS_PACRL_WP2 = 0x200000
	// This peripheral allows write accesses.
	AIPS_PACRL_WP2_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRL_WP2_1 = 0x1
	// Position of SP2 field.
	AIPS_PACRL_SP2_Pos = 0x16
	// Bit mask of SP2 field.
	AIPS_PACRL_SP2_Msk = 0x400000
	// Bit SP2.
	AIPS_PACRL_SP2 = 0x400000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRL_SP2_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRL_SP2_1 = 0x1
	// Position of TP1 field.
	AIPS_PACRL_TP1_Pos = 0x18
	// Bit mask of TP1 field.
	AIPS_PACRL_TP1_Msk = 0x1000000
	// Bit TP1.
	AIPS_PACRL_TP1 = 0x1000000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRL_TP1_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRL_TP1_1 = 0x1
	// Position of WP1 field.
	AIPS_PACRL_WP1_Pos = 0x19
	// Bit mask of WP1 field.
	AIPS_PACRL_WP1_Msk = 0x2000000
	// Bit WP1.
	AIPS_PACRL_WP1 = 0x2000000
	// This peripheral allows write accesses.
	AIPS_PACRL_WP1_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRL_WP1_1 = 0x1
	// Position of SP1 field.
	AIPS_PACRL_SP1_Pos = 0x1a
	// Bit mask of SP1 field.
	AIPS_PACRL_SP1_Msk = 0x4000000
	// Bit SP1.
	AIPS_PACRL_SP1 = 0x4000000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRL_SP1_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRL_SP1_1 = 0x1
	// Position of TP0 field.
	AIPS_PACRL_TP0_Pos = 0x1c
	// Bit mask of TP0 field.
	AIPS_PACRL_TP0_Msk = 0x10000000
	// Bit TP0.
	AIPS_PACRL_TP0 = 0x10000000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRL_TP0_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRL_TP0_1 = 0x1
	// Position of WP0 field.
	AIPS_PACRL_WP0_Pos = 0x1d
	// Bit mask of WP0 field.
	AIPS_PACRL_WP0_Msk = 0x20000000
	// Bit WP0.
	AIPS_PACRL_WP0 = 0x20000000
	// This peripheral allows write accesses.
	AIPS_PACRL_WP0_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRL_WP0_1 = 0x1
	// Position of SP0 field.
	AIPS_PACRL_SP0_Pos = 0x1e
	// Bit mask of SP0 field.
	AIPS_PACRL_SP0_Msk = 0x40000000
	// Bit SP0.
	AIPS_PACRL_SP0 = 0x40000000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRL_SP0_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRL_SP0_1 = 0x1

	// PACRM: Peripheral Access Control Register
	// Position of TP7 field.
	AIPS_PACRM_TP7_Pos = 0x0
	// Bit mask of TP7 field.
	AIPS_PACRM_TP7_Msk = 0x1
	// Bit TP7.
	AIPS_PACRM_TP7 = 0x1
	// Accesses from an untrusted master are allowed.
	AIPS_PACRM_TP7_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRM_TP7_1 = 0x1
	// Position of WP7 field.
	AIPS_PACRM_WP7_Pos = 0x1
	// Bit mask of WP7 field.
	AIPS_PACRM_WP7_Msk = 0x2
	// Bit WP7.
	AIPS_PACRM_WP7 = 0x2
	// This peripheral allows write accesses.
	AIPS_PACRM_WP7_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRM_WP7_1 = 0x1
	// Position of SP7 field.
	AIPS_PACRM_SP7_Pos = 0x2
	// Bit mask of SP7 field.
	AIPS_PACRM_SP7_Msk = 0x4
	// Bit SP7.
	AIPS_PACRM_SP7 = 0x4
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRM_SP7_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRM_SP7_1 = 0x1
	// Position of TP6 field.
	AIPS_PACRM_TP6_Pos = 0x4
	// Bit mask of TP6 field.
	AIPS_PACRM_TP6_Msk = 0x10
	// Bit TP6.
	AIPS_PACRM_TP6 = 0x10
	// Accesses from an untrusted master are allowed.
	AIPS_PACRM_TP6_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRM_TP6_1 = 0x1
	// Position of WP6 field.
	AIPS_PACRM_WP6_Pos = 0x5
	// Bit mask of WP6 field.
	AIPS_PACRM_WP6_Msk = 0x20
	// Bit WP6.
	AIPS_PACRM_WP6 = 0x20
	// This peripheral allows write accesses.
	AIPS_PACRM_WP6_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRM_WP6_1 = 0x1
	// Position of SP6 field.
	AIPS_PACRM_SP6_Pos = 0x6
	// Bit mask of SP6 field.
	AIPS_PACRM_SP6_Msk = 0x40
	// Bit SP6.
	AIPS_PACRM_SP6 = 0x40
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRM_SP6_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRM_SP6_1 = 0x1
	// Position of TP5 field.
	AIPS_PACRM_TP5_Pos = 0x8
	// Bit mask of TP5 field.
	AIPS_PACRM_TP5_Msk = 0x100
	// Bit TP5.
	AIPS_PACRM_TP5 = 0x100
	// Accesses from an untrusted master are allowed.
	AIPS_PACRM_TP5_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRM_TP5_1 = 0x1
	// Position of WP5 field.
	AIPS_PACRM_WP5_Pos = 0x9
	// Bit mask of WP5 field.
	AIPS_PACRM_WP5_Msk = 0x200
	// Bit WP5.
	AIPS_PACRM_WP5 = 0x200
	// This peripheral allows write accesses.
	AIPS_PACRM_WP5_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRM_WP5_1 = 0x1
	// Position of SP5 field.
	AIPS_PACRM_SP5_Pos = 0xa
	// Bit mask of SP5 field.
	AIPS_PACRM_SP5_Msk = 0x400
	// Bit SP5.
	AIPS_PACRM_SP5 = 0x400
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRM_SP5_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRM_SP5_1 = 0x1
	// Position of TP4 field.
	AIPS_PACRM_TP4_Pos = 0xc
	// Bit mask of TP4 field.
	AIPS_PACRM_TP4_Msk = 0x1000
	// Bit TP4.
	AIPS_PACRM_TP4 = 0x1000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRM_TP4_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRM_TP4_1 = 0x1
	// Position of WP4 field.
	AIPS_PACRM_WP4_Pos = 0xd
	// Bit mask of WP4 field.
	AIPS_PACRM_WP4_Msk = 0x2000
	// Bit WP4.
	AIPS_PACRM_WP4 = 0x2000
	// This peripheral allows write accesses.
	AIPS_PACRM_WP4_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRM_WP4_1 = 0x1
	// Position of SP4 field.
	AIPS_PACRM_SP4_Pos = 0xe
	// Bit mask of SP4 field.
	AIPS_PACRM_SP4_Msk = 0x4000
	// Bit SP4.
	AIPS_PACRM_SP4 = 0x4000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRM_SP4_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRM_SP4_1 = 0x1
	// Position of TP3 field.
	AIPS_PACRM_TP3_Pos = 0x10
	// Bit mask of TP3 field.
	AIPS_PACRM_TP3_Msk = 0x10000
	// Bit TP3.
	AIPS_PACRM_TP3 = 0x10000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRM_TP3_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRM_TP3_1 = 0x1
	// Position of WP3 field.
	AIPS_PACRM_WP3_Pos = 0x11
	// Bit mask of WP3 field.
	AIPS_PACRM_WP3_Msk = 0x20000
	// Bit WP3.
	AIPS_PACRM_WP3 = 0x20000
	// This peripheral allows write accesses.
	AIPS_PACRM_WP3_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRM_WP3_1 = 0x1
	// Position of SP3 field.
	AIPS_PACRM_SP3_Pos = 0x12
	// Bit mask of SP3 field.
	AIPS_PACRM_SP3_Msk = 0x40000
	// Bit SP3.
	AIPS_PACRM_SP3 = 0x40000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRM_SP3_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRM_SP3_1 = 0x1
	// Position of TP2 field.
	AIPS_PACRM_TP2_Pos = 0x14
	// Bit mask of TP2 field.
	AIPS_PACRM_TP2_Msk = 0x100000
	// Bit TP2.
	AIPS_PACRM_TP2 = 0x100000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRM_TP2_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRM_TP2_1 = 0x1
	// Position of WP2 field.
	AIPS_PACRM_WP2_Pos = 0x15
	// Bit mask of WP2 field.
	AIPS_PACRM_WP2_Msk = 0x200000
	// Bit WP2.
	AIPS_PACRM_WP2 = 0x200000
	// This peripheral allows write accesses.
	AIPS_PACRM_WP2_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRM_WP2_1 = 0x1
	// Position of SP2 field.
	AIPS_PACRM_SP2_Pos = 0x16
	// Bit mask of SP2 field.
	AIPS_PACRM_SP2_Msk = 0x400000
	// Bit SP2.
	AIPS_PACRM_SP2 = 0x400000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRM_SP2_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRM_SP2_1 = 0x1
	// Position of TP1 field.
	AIPS_PACRM_TP1_Pos = 0x18
	// Bit mask of TP1 field.
	AIPS_PACRM_TP1_Msk = 0x1000000
	// Bit TP1.
	AIPS_PACRM_TP1 = 0x1000000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRM_TP1_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRM_TP1_1 = 0x1
	// Position of WP1 field.
	AIPS_PACRM_WP1_Pos = 0x19
	// Bit mask of WP1 field.
	AIPS_PACRM_WP1_Msk = 0x2000000
	// Bit WP1.
	AIPS_PACRM_WP1 = 0x2000000
	// This peripheral allows write accesses.
	AIPS_PACRM_WP1_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRM_WP1_1 = 0x1
	// Position of SP1 field.
	AIPS_PACRM_SP1_Pos = 0x1a
	// Bit mask of SP1 field.
	AIPS_PACRM_SP1_Msk = 0x4000000
	// Bit SP1.
	AIPS_PACRM_SP1 = 0x4000000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRM_SP1_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRM_SP1_1 = 0x1
	// Position of TP0 field.
	AIPS_PACRM_TP0_Pos = 0x1c
	// Bit mask of TP0 field.
	AIPS_PACRM_TP0_Msk = 0x10000000
	// Bit TP0.
	AIPS_PACRM_TP0 = 0x10000000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRM_TP0_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRM_TP0_1 = 0x1
	// Position of WP0 field.
	AIPS_PACRM_WP0_Pos = 0x1d
	// Bit mask of WP0 field.
	AIPS_PACRM_WP0_Msk = 0x20000000
	// Bit WP0.
	AIPS_PACRM_WP0 = 0x20000000
	// This peripheral allows write accesses.
	AIPS_PACRM_WP0_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRM_WP0_1 = 0x1
	// Position of SP0 field.
	AIPS_PACRM_SP0_Pos = 0x1e
	// Bit mask of SP0 field.
	AIPS_PACRM_SP0_Msk = 0x40000000
	// Bit SP0.
	AIPS_PACRM_SP0 = 0x40000000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRM_SP0_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRM_SP0_1 = 0x1

	// PACRN: Peripheral Access Control Register
	// Position of TP7 field.
	AIPS_PACRN_TP7_Pos = 0x0
	// Bit mask of TP7 field.
	AIPS_PACRN_TP7_Msk = 0x1
	// Bit TP7.
	AIPS_PACRN_TP7 = 0x1
	// Accesses from an untrusted master are allowed.
	AIPS_PACRN_TP7_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRN_TP7_1 = 0x1
	// Position of WP7 field.
	AIPS_PACRN_WP7_Pos = 0x1
	// Bit mask of WP7 field.
	AIPS_PACRN_WP7_Msk = 0x2
	// Bit WP7.
	AIPS_PACRN_WP7 = 0x2
	// This peripheral allows write accesses.
	AIPS_PACRN_WP7_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRN_WP7_1 = 0x1
	// Position of SP7 field.
	AIPS_PACRN_SP7_Pos = 0x2
	// Bit mask of SP7 field.
	AIPS_PACRN_SP7_Msk = 0x4
	// Bit SP7.
	AIPS_PACRN_SP7 = 0x4
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRN_SP7_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRN_SP7_1 = 0x1
	// Position of TP6 field.
	AIPS_PACRN_TP6_Pos = 0x4
	// Bit mask of TP6 field.
	AIPS_PACRN_TP6_Msk = 0x10
	// Bit TP6.
	AIPS_PACRN_TP6 = 0x10
	// Accesses from an untrusted master are allowed.
	AIPS_PACRN_TP6_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRN_TP6_1 = 0x1
	// Position of WP6 field.
	AIPS_PACRN_WP6_Pos = 0x5
	// Bit mask of WP6 field.
	AIPS_PACRN_WP6_Msk = 0x20
	// Bit WP6.
	AIPS_PACRN_WP6 = 0x20
	// This peripheral allows write accesses.
	AIPS_PACRN_WP6_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRN_WP6_1 = 0x1
	// Position of SP6 field.
	AIPS_PACRN_SP6_Pos = 0x6
	// Bit mask of SP6 field.
	AIPS_PACRN_SP6_Msk = 0x40
	// Bit SP6.
	AIPS_PACRN_SP6 = 0x40
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRN_SP6_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRN_SP6_1 = 0x1
	// Position of TP5 field.
	AIPS_PACRN_TP5_Pos = 0x8
	// Bit mask of TP5 field.
	AIPS_PACRN_TP5_Msk = 0x100
	// Bit TP5.
	AIPS_PACRN_TP5 = 0x100
	// Accesses from an untrusted master are allowed.
	AIPS_PACRN_TP5_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRN_TP5_1 = 0x1
	// Position of WP5 field.
	AIPS_PACRN_WP5_Pos = 0x9
	// Bit mask of WP5 field.
	AIPS_PACRN_WP5_Msk = 0x200
	// Bit WP5.
	AIPS_PACRN_WP5 = 0x200
	// This peripheral allows write accesses.
	AIPS_PACRN_WP5_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRN_WP5_1 = 0x1
	// Position of SP5 field.
	AIPS_PACRN_SP5_Pos = 0xa
	// Bit mask of SP5 field.
	AIPS_PACRN_SP5_Msk = 0x400
	// Bit SP5.
	AIPS_PACRN_SP5 = 0x400
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRN_SP5_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRN_SP5_1 = 0x1
	// Position of TP4 field.
	AIPS_PACRN_TP4_Pos = 0xc
	// Bit mask of TP4 field.
	AIPS_PACRN_TP4_Msk = 0x1000
	// Bit TP4.
	AIPS_PACRN_TP4 = 0x1000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRN_TP4_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRN_TP4_1 = 0x1
	// Position of WP4 field.
	AIPS_PACRN_WP4_Pos = 0xd
	// Bit mask of WP4 field.
	AIPS_PACRN_WP4_Msk = 0x2000
	// Bit WP4.
	AIPS_PACRN_WP4 = 0x2000
	// This peripheral allows write accesses.
	AIPS_PACRN_WP4_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRN_WP4_1 = 0x1
	// Position of SP4 field.
	AIPS_PACRN_SP4_Pos = 0xe
	// Bit mask of SP4 field.
	AIPS_PACRN_SP4_Msk = 0x4000
	// Bit SP4.
	AIPS_PACRN_SP4 = 0x4000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRN_SP4_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRN_SP4_1 = 0x1
	// Position of TP3 field.
	AIPS_PACRN_TP3_Pos = 0x10
	// Bit mask of TP3 field.
	AIPS_PACRN_TP3_Msk = 0x10000
	// Bit TP3.
	AIPS_PACRN_TP3 = 0x10000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRN_TP3_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRN_TP3_1 = 0x1
	// Position of WP3 field.
	AIPS_PACRN_WP3_Pos = 0x11
	// Bit mask of WP3 field.
	AIPS_PACRN_WP3_Msk = 0x20000
	// Bit WP3.
	AIPS_PACRN_WP3 = 0x20000
	// This peripheral allows write accesses.
	AIPS_PACRN_WP3_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRN_WP3_1 = 0x1
	// Position of SP3 field.
	AIPS_PACRN_SP3_Pos = 0x12
	// Bit mask of SP3 field.
	AIPS_PACRN_SP3_Msk = 0x40000
	// Bit SP3.
	AIPS_PACRN_SP3 = 0x40000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRN_SP3_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRN_SP3_1 = 0x1
	// Position of TP2 field.
	AIPS_PACRN_TP2_Pos = 0x14
	// Bit mask of TP2 field.
	AIPS_PACRN_TP2_Msk = 0x100000
	// Bit TP2.
	AIPS_PACRN_TP2 = 0x100000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRN_TP2_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRN_TP2_1 = 0x1
	// Position of WP2 field.
	AIPS_PACRN_WP2_Pos = 0x15
	// Bit mask of WP2 field.
	AIPS_PACRN_WP2_Msk = 0x200000
	// Bit WP2.
	AIPS_PACRN_WP2 = 0x200000
	// This peripheral allows write accesses.
	AIPS_PACRN_WP2_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRN_WP2_1 = 0x1
	// Position of SP2 field.
	AIPS_PACRN_SP2_Pos = 0x16
	// Bit mask of SP2 field.
	AIPS_PACRN_SP2_Msk = 0x400000
	// Bit SP2.
	AIPS_PACRN_SP2 = 0x400000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRN_SP2_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRN_SP2_1 = 0x1
	// Position of TP1 field.
	AIPS_PACRN_TP1_Pos = 0x18
	// Bit mask of TP1 field.
	AIPS_PACRN_TP1_Msk = 0x1000000
	// Bit TP1.
	AIPS_PACRN_TP1 = 0x1000000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRN_TP1_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRN_TP1_1 = 0x1
	// Position of WP1 field.
	AIPS_PACRN_WP1_Pos = 0x19
	// Bit mask of WP1 field.
	AIPS_PACRN_WP1_Msk = 0x2000000
	// Bit WP1.
	AIPS_PACRN_WP1 = 0x2000000
	// This peripheral allows write accesses.
	AIPS_PACRN_WP1_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRN_WP1_1 = 0x1
	// Position of SP1 field.
	AIPS_PACRN_SP1_Pos = 0x1a
	// Bit mask of SP1 field.
	AIPS_PACRN_SP1_Msk = 0x4000000
	// Bit SP1.
	AIPS_PACRN_SP1 = 0x4000000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRN_SP1_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRN_SP1_1 = 0x1
	// Position of TP0 field.
	AIPS_PACRN_TP0_Pos = 0x1c
	// Bit mask of TP0 field.
	AIPS_PACRN_TP0_Msk = 0x10000000
	// Bit TP0.
	AIPS_PACRN_TP0 = 0x10000000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRN_TP0_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRN_TP0_1 = 0x1
	// Position of WP0 field.
	AIPS_PACRN_WP0_Pos = 0x1d
	// Bit mask of WP0 field.
	AIPS_PACRN_WP0_Msk = 0x20000000
	// Bit WP0.
	AIPS_PACRN_WP0 = 0x20000000
	// This peripheral allows write accesses.
	AIPS_PACRN_WP0_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRN_WP0_1 = 0x1
	// Position of SP0 field.
	AIPS_PACRN_SP0_Pos = 0x1e
	// Bit mask of SP0 field.
	AIPS_PACRN_SP0_Msk = 0x40000000
	// Bit SP0.
	AIPS_PACRN_SP0 = 0x40000000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRN_SP0_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRN_SP0_1 = 0x1

	// PACRO: Peripheral Access Control Register
	// Position of TP7 field.
	AIPS_PACRO_TP7_Pos = 0x0
	// Bit mask of TP7 field.
	AIPS_PACRO_TP7_Msk = 0x1
	// Bit TP7.
	AIPS_PACRO_TP7 = 0x1
	// Accesses from an untrusted master are allowed.
	AIPS_PACRO_TP7_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRO_TP7_1 = 0x1
	// Position of WP7 field.
	AIPS_PACRO_WP7_Pos = 0x1
	// Bit mask of WP7 field.
	AIPS_PACRO_WP7_Msk = 0x2
	// Bit WP7.
	AIPS_PACRO_WP7 = 0x2
	// This peripheral allows write accesses.
	AIPS_PACRO_WP7_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRO_WP7_1 = 0x1
	// Position of SP7 field.
	AIPS_PACRO_SP7_Pos = 0x2
	// Bit mask of SP7 field.
	AIPS_PACRO_SP7_Msk = 0x4
	// Bit SP7.
	AIPS_PACRO_SP7 = 0x4
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRO_SP7_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRO_SP7_1 = 0x1
	// Position of TP6 field.
	AIPS_PACRO_TP6_Pos = 0x4
	// Bit mask of TP6 field.
	AIPS_PACRO_TP6_Msk = 0x10
	// Bit TP6.
	AIPS_PACRO_TP6 = 0x10
	// Accesses from an untrusted master are allowed.
	AIPS_PACRO_TP6_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRO_TP6_1 = 0x1
	// Position of WP6 field.
	AIPS_PACRO_WP6_Pos = 0x5
	// Bit mask of WP6 field.
	AIPS_PACRO_WP6_Msk = 0x20
	// Bit WP6.
	AIPS_PACRO_WP6 = 0x20
	// This peripheral allows write accesses.
	AIPS_PACRO_WP6_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRO_WP6_1 = 0x1
	// Position of SP6 field.
	AIPS_PACRO_SP6_Pos = 0x6
	// Bit mask of SP6 field.
	AIPS_PACRO_SP6_Msk = 0x40
	// Bit SP6.
	AIPS_PACRO_SP6 = 0x40
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRO_SP6_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRO_SP6_1 = 0x1
	// Position of TP5 field.
	AIPS_PACRO_TP5_Pos = 0x8
	// Bit mask of TP5 field.
	AIPS_PACRO_TP5_Msk = 0x100
	// Bit TP5.
	AIPS_PACRO_TP5 = 0x100
	// Accesses from an untrusted master are allowed.
	AIPS_PACRO_TP5_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRO_TP5_1 = 0x1
	// Position of WP5 field.
	AIPS_PACRO_WP5_Pos = 0x9
	// Bit mask of WP5 field.
	AIPS_PACRO_WP5_Msk = 0x200
	// Bit WP5.
	AIPS_PACRO_WP5 = 0x200
	// This peripheral allows write accesses.
	AIPS_PACRO_WP5_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRO_WP5_1 = 0x1
	// Position of SP5 field.
	AIPS_PACRO_SP5_Pos = 0xa
	// Bit mask of SP5 field.
	AIPS_PACRO_SP5_Msk = 0x400
	// Bit SP5.
	AIPS_PACRO_SP5 = 0x400
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRO_SP5_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRO_SP5_1 = 0x1
	// Position of TP4 field.
	AIPS_PACRO_TP4_Pos = 0xc
	// Bit mask of TP4 field.
	AIPS_PACRO_TP4_Msk = 0x1000
	// Bit TP4.
	AIPS_PACRO_TP4 = 0x1000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRO_TP4_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRO_TP4_1 = 0x1
	// Position of WP4 field.
	AIPS_PACRO_WP4_Pos = 0xd
	// Bit mask of WP4 field.
	AIPS_PACRO_WP4_Msk = 0x2000
	// Bit WP4.
	AIPS_PACRO_WP4 = 0x2000
	// This peripheral allows write accesses.
	AIPS_PACRO_WP4_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRO_WP4_1 = 0x1
	// Position of SP4 field.
	AIPS_PACRO_SP4_Pos = 0xe
	// Bit mask of SP4 field.
	AIPS_PACRO_SP4_Msk = 0x4000
	// Bit SP4.
	AIPS_PACRO_SP4 = 0x4000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRO_SP4_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRO_SP4_1 = 0x1
	// Position of TP3 field.
	AIPS_PACRO_TP3_Pos = 0x10
	// Bit mask of TP3 field.
	AIPS_PACRO_TP3_Msk = 0x10000
	// Bit TP3.
	AIPS_PACRO_TP3 = 0x10000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRO_TP3_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRO_TP3_1 = 0x1
	// Position of WP3 field.
	AIPS_PACRO_WP3_Pos = 0x11
	// Bit mask of WP3 field.
	AIPS_PACRO_WP3_Msk = 0x20000
	// Bit WP3.
	AIPS_PACRO_WP3 = 0x20000
	// This peripheral allows write accesses.
	AIPS_PACRO_WP3_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRO_WP3_1 = 0x1
	// Position of SP3 field.
	AIPS_PACRO_SP3_Pos = 0x12
	// Bit mask of SP3 field.
	AIPS_PACRO_SP3_Msk = 0x40000
	// Bit SP3.
	AIPS_PACRO_SP3 = 0x40000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRO_SP3_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRO_SP3_1 = 0x1
	// Position of TP2 field.
	AIPS_PACRO_TP2_Pos = 0x14
	// Bit mask of TP2 field.
	AIPS_PACRO_TP2_Msk = 0x100000
	// Bit TP2.
	AIPS_PACRO_TP2 = 0x100000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRO_TP2_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRO_TP2_1 = 0x1
	// Position of WP2 field.
	AIPS_PACRO_WP2_Pos = 0x15
	// Bit mask of WP2 field.
	AIPS_PACRO_WP2_Msk = 0x200000
	// Bit WP2.
	AIPS_PACRO_WP2 = 0x200000
	// This peripheral allows write accesses.
	AIPS_PACRO_WP2_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRO_WP2_1 = 0x1
	// Position of SP2 field.
	AIPS_PACRO_SP2_Pos = 0x16
	// Bit mask of SP2 field.
	AIPS_PACRO_SP2_Msk = 0x400000
	// Bit SP2.
	AIPS_PACRO_SP2 = 0x400000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRO_SP2_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRO_SP2_1 = 0x1
	// Position of TP1 field.
	AIPS_PACRO_TP1_Pos = 0x18
	// Bit mask of TP1 field.
	AIPS_PACRO_TP1_Msk = 0x1000000
	// Bit TP1.
	AIPS_PACRO_TP1 = 0x1000000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRO_TP1_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRO_TP1_1 = 0x1
	// Position of WP1 field.
	AIPS_PACRO_WP1_Pos = 0x19
	// Bit mask of WP1 field.
	AIPS_PACRO_WP1_Msk = 0x2000000
	// Bit WP1.
	AIPS_PACRO_WP1 = 0x2000000
	// This peripheral allows write accesses.
	AIPS_PACRO_WP1_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRO_WP1_1 = 0x1
	// Position of SP1 field.
	AIPS_PACRO_SP1_Pos = 0x1a
	// Bit mask of SP1 field.
	AIPS_PACRO_SP1_Msk = 0x4000000
	// Bit SP1.
	AIPS_PACRO_SP1 = 0x4000000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRO_SP1_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRO_SP1_1 = 0x1
	// Position of TP0 field.
	AIPS_PACRO_TP0_Pos = 0x1c
	// Bit mask of TP0 field.
	AIPS_PACRO_TP0_Msk = 0x10000000
	// Bit TP0.
	AIPS_PACRO_TP0 = 0x10000000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRO_TP0_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRO_TP0_1 = 0x1
	// Position of WP0 field.
	AIPS_PACRO_WP0_Pos = 0x1d
	// Bit mask of WP0 field.
	AIPS_PACRO_WP0_Msk = 0x20000000
	// Bit WP0.
	AIPS_PACRO_WP0 = 0x20000000
	// This peripheral allows write accesses.
	AIPS_PACRO_WP0_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRO_WP0_1 = 0x1
	// Position of SP0 field.
	AIPS_PACRO_SP0_Pos = 0x1e
	// Bit mask of SP0 field.
	AIPS_PACRO_SP0_Msk = 0x40000000
	// Bit SP0.
	AIPS_PACRO_SP0 = 0x40000000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRO_SP0_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRO_SP0_1 = 0x1

	// PACRP: Peripheral Access Control Register
	// Position of TP7 field.
	AIPS_PACRP_TP7_Pos = 0x0
	// Bit mask of TP7 field.
	AIPS_PACRP_TP7_Msk = 0x1
	// Bit TP7.
	AIPS_PACRP_TP7 = 0x1
	// Accesses from an untrusted master are allowed.
	AIPS_PACRP_TP7_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRP_TP7_1 = 0x1
	// Position of WP7 field.
	AIPS_PACRP_WP7_Pos = 0x1
	// Bit mask of WP7 field.
	AIPS_PACRP_WP7_Msk = 0x2
	// Bit WP7.
	AIPS_PACRP_WP7 = 0x2
	// This peripheral allows write accesses.
	AIPS_PACRP_WP7_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRP_WP7_1 = 0x1
	// Position of SP7 field.
	AIPS_PACRP_SP7_Pos = 0x2
	// Bit mask of SP7 field.
	AIPS_PACRP_SP7_Msk = 0x4
	// Bit SP7.
	AIPS_PACRP_SP7 = 0x4
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRP_SP7_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRP_SP7_1 = 0x1
	// Position of TP6 field.
	AIPS_PACRP_TP6_Pos = 0x4
	// Bit mask of TP6 field.
	AIPS_PACRP_TP6_Msk = 0x10
	// Bit TP6.
	AIPS_PACRP_TP6 = 0x10
	// Accesses from an untrusted master are allowed.
	AIPS_PACRP_TP6_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRP_TP6_1 = 0x1
	// Position of WP6 field.
	AIPS_PACRP_WP6_Pos = 0x5
	// Bit mask of WP6 field.
	AIPS_PACRP_WP6_Msk = 0x20
	// Bit WP6.
	AIPS_PACRP_WP6 = 0x20
	// This peripheral allows write accesses.
	AIPS_PACRP_WP6_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRP_WP6_1 = 0x1
	// Position of SP6 field.
	AIPS_PACRP_SP6_Pos = 0x6
	// Bit mask of SP6 field.
	AIPS_PACRP_SP6_Msk = 0x40
	// Bit SP6.
	AIPS_PACRP_SP6 = 0x40
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRP_SP6_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRP_SP6_1 = 0x1
	// Position of TP5 field.
	AIPS_PACRP_TP5_Pos = 0x8
	// Bit mask of TP5 field.
	AIPS_PACRP_TP5_Msk = 0x100
	// Bit TP5.
	AIPS_PACRP_TP5 = 0x100
	// Accesses from an untrusted master are allowed.
	AIPS_PACRP_TP5_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRP_TP5_1 = 0x1
	// Position of WP5 field.
	AIPS_PACRP_WP5_Pos = 0x9
	// Bit mask of WP5 field.
	AIPS_PACRP_WP5_Msk = 0x200
	// Bit WP5.
	AIPS_PACRP_WP5 = 0x200
	// This peripheral allows write accesses.
	AIPS_PACRP_WP5_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRP_WP5_1 = 0x1
	// Position of SP5 field.
	AIPS_PACRP_SP5_Pos = 0xa
	// Bit mask of SP5 field.
	AIPS_PACRP_SP5_Msk = 0x400
	// Bit SP5.
	AIPS_PACRP_SP5 = 0x400
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRP_SP5_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRP_SP5_1 = 0x1
	// Position of TP4 field.
	AIPS_PACRP_TP4_Pos = 0xc
	// Bit mask of TP4 field.
	AIPS_PACRP_TP4_Msk = 0x1000
	// Bit TP4.
	AIPS_PACRP_TP4 = 0x1000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRP_TP4_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRP_TP4_1 = 0x1
	// Position of WP4 field.
	AIPS_PACRP_WP4_Pos = 0xd
	// Bit mask of WP4 field.
	AIPS_PACRP_WP4_Msk = 0x2000
	// Bit WP4.
	AIPS_PACRP_WP4 = 0x2000
	// This peripheral allows write accesses.
	AIPS_PACRP_WP4_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRP_WP4_1 = 0x1
	// Position of SP4 field.
	AIPS_PACRP_SP4_Pos = 0xe
	// Bit mask of SP4 field.
	AIPS_PACRP_SP4_Msk = 0x4000
	// Bit SP4.
	AIPS_PACRP_SP4 = 0x4000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRP_SP4_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRP_SP4_1 = 0x1
	// Position of TP3 field.
	AIPS_PACRP_TP3_Pos = 0x10
	// Bit mask of TP3 field.
	AIPS_PACRP_TP3_Msk = 0x10000
	// Bit TP3.
	AIPS_PACRP_TP3 = 0x10000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRP_TP3_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRP_TP3_1 = 0x1
	// Position of WP3 field.
	AIPS_PACRP_WP3_Pos = 0x11
	// Bit mask of WP3 field.
	AIPS_PACRP_WP3_Msk = 0x20000
	// Bit WP3.
	AIPS_PACRP_WP3 = 0x20000
	// This peripheral allows write accesses.
	AIPS_PACRP_WP3_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRP_WP3_1 = 0x1
	// Position of SP3 field.
	AIPS_PACRP_SP3_Pos = 0x12
	// Bit mask of SP3 field.
	AIPS_PACRP_SP3_Msk = 0x40000
	// Bit SP3.
	AIPS_PACRP_SP3 = 0x40000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRP_SP3_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRP_SP3_1 = 0x1
	// Position of TP2 field.
	AIPS_PACRP_TP2_Pos = 0x14
	// Bit mask of TP2 field.
	AIPS_PACRP_TP2_Msk = 0x100000
	// Bit TP2.
	AIPS_PACRP_TP2 = 0x100000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRP_TP2_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRP_TP2_1 = 0x1
	// Position of WP2 field.
	AIPS_PACRP_WP2_Pos = 0x15
	// Bit mask of WP2 field.
	AIPS_PACRP_WP2_Msk = 0x200000
	// Bit WP2.
	AIPS_PACRP_WP2 = 0x200000
	// This peripheral allows write accesses.
	AIPS_PACRP_WP2_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRP_WP2_1 = 0x1
	// Position of SP2 field.
	AIPS_PACRP_SP2_Pos = 0x16
	// Bit mask of SP2 field.
	AIPS_PACRP_SP2_Msk = 0x400000
	// Bit SP2.
	AIPS_PACRP_SP2 = 0x400000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRP_SP2_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRP_SP2_1 = 0x1
	// Position of TP1 field.
	AIPS_PACRP_TP1_Pos = 0x18
	// Bit mask of TP1 field.
	AIPS_PACRP_TP1_Msk = 0x1000000
	// Bit TP1.
	AIPS_PACRP_TP1 = 0x1000000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRP_TP1_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRP_TP1_1 = 0x1
	// Position of WP1 field.
	AIPS_PACRP_WP1_Pos = 0x19
	// Bit mask of WP1 field.
	AIPS_PACRP_WP1_Msk = 0x2000000
	// Bit WP1.
	AIPS_PACRP_WP1 = 0x2000000
	// This peripheral allows write accesses.
	AIPS_PACRP_WP1_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRP_WP1_1 = 0x1
	// Position of SP1 field.
	AIPS_PACRP_SP1_Pos = 0x1a
	// Bit mask of SP1 field.
	AIPS_PACRP_SP1_Msk = 0x4000000
	// Bit SP1.
	AIPS_PACRP_SP1 = 0x4000000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRP_SP1_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRP_SP1_1 = 0x1
	// Position of TP0 field.
	AIPS_PACRP_TP0_Pos = 0x1c
	// Bit mask of TP0 field.
	AIPS_PACRP_TP0_Msk = 0x10000000
	// Bit TP0.
	AIPS_PACRP_TP0 = 0x10000000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRP_TP0_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRP_TP0_1 = 0x1
	// Position of WP0 field.
	AIPS_PACRP_WP0_Pos = 0x1d
	// Bit mask of WP0 field.
	AIPS_PACRP_WP0_Msk = 0x20000000
	// Bit WP0.
	AIPS_PACRP_WP0 = 0x20000000
	// This peripheral allows write accesses.
	AIPS_PACRP_WP0_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRP_WP0_1 = 0x1
	// Position of SP0 field.
	AIPS_PACRP_SP0_Pos = 0x1e
	// Bit mask of SP0 field.
	AIPS_PACRP_SP0_Msk = 0x40000000
	// Bit SP0.
	AIPS_PACRP_SP0 = 0x40000000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRP_SP0_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRP_SP0_1 = 0x1

	// PACRU: Peripheral Access Control Register
	// Position of TP1 field.
	AIPS_PACRU_TP1_Pos = 0x18
	// Bit mask of TP1 field.
	AIPS_PACRU_TP1_Msk = 0x1000000
	// Bit TP1.
	AIPS_PACRU_TP1 = 0x1000000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRU_TP1_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRU_TP1_1 = 0x1
	// Position of WP1 field.
	AIPS_PACRU_WP1_Pos = 0x19
	// Bit mask of WP1 field.
	AIPS_PACRU_WP1_Msk = 0x2000000
	// Bit WP1.
	AIPS_PACRU_WP1 = 0x2000000
	// This peripheral allows write accesses.
	AIPS_PACRU_WP1_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRU_WP1_1 = 0x1
	// Position of SP1 field.
	AIPS_PACRU_SP1_Pos = 0x1a
	// Bit mask of SP1 field.
	AIPS_PACRU_SP1_Msk = 0x4000000
	// Bit SP1.
	AIPS_PACRU_SP1 = 0x4000000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRU_SP1_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRU_SP1_1 = 0x1
	// Position of TP0 field.
	AIPS_PACRU_TP0_Pos = 0x1c
	// Bit mask of TP0 field.
	AIPS_PACRU_TP0_Msk = 0x10000000
	// Bit TP0.
	AIPS_PACRU_TP0 = 0x10000000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRU_TP0_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRU_TP0_1 = 0x1
	// Position of WP0 field.
	AIPS_PACRU_WP0_Pos = 0x1d
	// Bit mask of WP0 field.
	AIPS_PACRU_WP0_Msk = 0x20000000
	// Bit WP0.
	AIPS_PACRU_WP0 = 0x20000000
	// This peripheral allows write accesses.
	AIPS_PACRU_WP0_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRU_WP0_1 = 0x1
	// Position of SP0 field.
	AIPS_PACRU_SP0_Pos = 0x1e
	// Bit mask of SP0 field.
	AIPS_PACRU_SP0_Msk = 0x40000000
	// Bit SP0.
	AIPS_PACRU_SP0 = 0x40000000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRU_SP0_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRU_SP0_1 = 0x1
)

// Constants for AXBS: Crossbar switch
const (
	// PRS0: Priority Registers Slave
	// Position of M0 field.
	AXBS_PRS_M0_Pos = 0x0
	// Bit mask of M0 field.
	AXBS_PRS_M0_Msk = 0x7
	// This master has level 1, or highest, priority when accessing the slave port.
	AXBS_PRS_M0_000 = 0x0
	// This master has level 2 priority when accessing the slave port.
	AXBS_PRS_M0_001 = 0x1
	// This master has level 3 priority when accessing the slave port.
	AXBS_PRS_M0_010 = 0x2
	// This master has level 4 priority when accessing the slave port.
	AXBS_PRS_M0_011 = 0x3
	// This master has level 5 priority when accessing the slave port.
	AXBS_PRS_M0_100 = 0x4
	// This master has level 6 priority when accessing the slave port.
	AXBS_PRS_M0_101 = 0x5
	// This master has level 7 priority when accessing the slave port.
	AXBS_PRS_M0_110 = 0x6
	// This master has level 8, or lowest, priority when accessing the slave port.
	AXBS_PRS_M0_111 = 0x7
	// Position of M1 field.
	AXBS_PRS_M1_Pos = 0x4
	// Bit mask of M1 field.
	AXBS_PRS_M1_Msk = 0x70
	// This master has level 1, or highest, priority when accessing the slave port.
	AXBS_PRS_M1_000 = 0x0
	// This master has level 2 priority when accessing the slave port.
	AXBS_PRS_M1_001 = 0x1
	// This master has level 3 priority when accessing the slave port.
	AXBS_PRS_M1_010 = 0x2
	// This master has level 4 priority when accessing the slave port.
	AXBS_PRS_M1_011 = 0x3
	// This master has level 5 priority when accessing the slave port.
	AXBS_PRS_M1_100 = 0x4
	// This master has level 6 priority when accessing the slave port.
	AXBS_PRS_M1_101 = 0x5
	// This master has level 7 priority when accessing the slave port.
	AXBS_PRS_M1_110 = 0x6
	// This master has level 8, or lowest, priority when accessing the slave port.
	AXBS_PRS_M1_111 = 0x7
	// Position of M2 field.
	AXBS_PRS_M2_Pos = 0x8
	// Bit mask of M2 field.
	AXBS_PRS_M2_Msk = 0x700
	// This master has level 1, or highest, priority when accessing the slave port.
	AXBS_PRS_M2_000 = 0x0
	// This master has level 2 priority when accessing the slave port.
	AXBS_PRS_M2_001 = 0x1
	// This master has level 3 priority when accessing the slave port.
	AXBS_PRS_M2_010 = 0x2
	// This master has level 4 priority when accessing the slave port.
	AXBS_PRS_M2_011 = 0x3
	// This master has level 5 priority when accessing the slave port.
	AXBS_PRS_M2_100 = 0x4
	// This master has level 6 priority when accessing the slave port.
	AXBS_PRS_M2_101 = 0x5
	// This master has level 7 priority when accessing the slave port.
	AXBS_PRS_M2_110 = 0x6
	// This master has level 8, or lowest, priority when accessing the slave port.
	AXBS_PRS_M2_111 = 0x7
	// Position of M3 field.
	AXBS_PRS_M3_Pos = 0xc
	// Bit mask of M3 field.
	AXBS_PRS_M3_Msk = 0x7000
	// This master has level 1, or highest, priority when accessing the slave port.
	AXBS_PRS_M3_000 = 0x0
	// This master has level 2 priority when accessing the slave port.
	AXBS_PRS_M3_001 = 0x1
	// This master has level 3 priority when accessing the slave port.
	AXBS_PRS_M3_010 = 0x2
	// This master has level 4 priority when accessing the slave port.
	AXBS_PRS_M3_011 = 0x3
	// This master has level 5 priority when accessing the slave port.
	AXBS_PRS_M3_100 = 0x4
	// This master has level 6 priority when accessing the slave port.
	AXBS_PRS_M3_101 = 0x5
	// This master has level 7 priority when accessing the slave port.
	AXBS_PRS_M3_110 = 0x6
	// This master has level 8, or lowest, priority when accessing the slave port.
	AXBS_PRS_M3_111 = 0x7
	// Position of M4 field.
	AXBS_PRS_M4_Pos = 0x10
	// Bit mask of M4 field.
	AXBS_PRS_M4_Msk = 0x70000
	// This master has level 1, or highest, priority when accessing the slave port.
	AXBS_PRS_M4_000 = 0x0
	// This master has level 2 priority when accessing the slave port.
	AXBS_PRS_M4_001 = 0x1
	// This master has level 3 priority when accessing the slave port.
	AXBS_PRS_M4_010 = 0x2
	// This master has level 4 priority when accessing the slave port.
	AXBS_PRS_M4_011 = 0x3
	// This master has level 5 priority when accessing the slave port.
	AXBS_PRS_M4_100 = 0x4
	// This master has level 6 priority when accessing the slave port.
	AXBS_PRS_M4_101 = 0x5
	// This master has level 7 priority when accessing the slave port.
	AXBS_PRS_M4_110 = 0x6
	// This master has level 8, or lowest, priority when accessing the slave port.
	AXBS_PRS_M4_111 = 0x7
	// Position of M5 field.
	AXBS_PRS_M5_Pos = 0x14
	// Bit mask of M5 field.
	AXBS_PRS_M5_Msk = 0x700000
	// This master has level 1, or highest, priority when accessing the slave port.
	AXBS_PRS_M5_000 = 0x0
	// This master has level 2 priority when accessing the slave port.
	AXBS_PRS_M5_001 = 0x1
	// This master has level 3 priority when accessing the slave port.
	AXBS_PRS_M5_010 = 0x2
	// This master has level 4 priority when accessing the slave port.
	AXBS_PRS_M5_011 = 0x3
	// This master has level 5 priority when accessing the slave port.
	AXBS_PRS_M5_100 = 0x4
	// This master has level 6 priority when accessing the slave port.
	AXBS_PRS_M5_101 = 0x5
	// This master has level 7 priority when accessing the slave port.
	AXBS_PRS_M5_110 = 0x6
	// This master has level 8, or lowest, priority when accessing the slave port.
	AXBS_PRS_M5_111 = 0x7

	// CRS0: Control Register
	// Position of PARK field.
	AXBS_CRS_PARK_Pos = 0x0
	// Bit mask of PARK field.
	AXBS_CRS_PARK_Msk = 0x7
	// Park on master port M0
	AXBS_CRS_PARK_000 = 0x0
	// Park on master port M1
	AXBS_CRS_PARK_001 = 0x1
	// Park on master port M2
	AXBS_CRS_PARK_010 = 0x2
	// Park on master port M3
	AXBS_CRS_PARK_011 = 0x3
	// Park on master port M4
	AXBS_CRS_PARK_100 = 0x4
	// Park on master port M5
	AXBS_CRS_PARK_101 = 0x5
	// Park on master port M6
	AXBS_CRS_PARK_110 = 0x6
	// Park on master port M7
	AXBS_CRS_PARK_111 = 0x7
	// Position of PCTL field.
	AXBS_CRS_PCTL_Pos = 0x4
	// Bit mask of PCTL field.
	AXBS_CRS_PCTL_Msk = 0x30
	// When no master makes a request, the arbiter parks the slave port on the master port defined by the PARK field
	AXBS_CRS_PCTL_00 = 0x0
	// When no master makes a request, the arbiter parks the slave port on the last master to be in control of the slave port
	AXBS_CRS_PCTL_01 = 0x1
	// When no master makes a request, the slave port is not parked on a master and the arbiter drives all outputs to a constant safe state
	AXBS_CRS_PCTL_10 = 0x2
	// Position of ARB field.
	AXBS_CRS_ARB_Pos = 0x8
	// Bit mask of ARB field.
	AXBS_CRS_ARB_Msk = 0x300
	// Fixed priority
	AXBS_CRS_ARB_00 = 0x0
	// Round-robin, or rotating, priority
	AXBS_CRS_ARB_01 = 0x1
	// Position of HLP field.
	AXBS_CRS_HLP_Pos = 0x1e
	// Bit mask of HLP field.
	AXBS_CRS_HLP_Msk = 0x40000000
	// Bit HLP.
	AXBS_CRS_HLP = 0x40000000
	// The low power mode request has the highest priority for arbitration on this slave port
	AXBS_CRS_HLP_0 = 0x0
	// The low power mode request has the lowest initial priority for arbitration on this slave port
	AXBS_CRS_HLP_1 = 0x1
	// Position of RO field.
	AXBS_CRS_RO_Pos = 0x1f
	// Bit mask of RO field.
	AXBS_CRS_RO_Msk = 0x80000000
	// Bit RO.
	AXBS_CRS_RO = 0x80000000
	// The slave port's registers are writeable
	AXBS_CRS_RO_0 = 0x0
	// The slave port's registers are read-only and cannot be written. Attempted writes have no effect on the registers and result in a bus error response.
	AXBS_CRS_RO_1 = 0x1

	// MGPCR0: Master General Purpose Control Register
	// Position of AULB field.
	AXBS_MGPCR_AULB_Pos = 0x0
	// Bit mask of AULB field.
	AXBS_MGPCR_AULB_Msk = 0x7
	// No arbitration is allowed during an undefined length burst
	AXBS_MGPCR_AULB_000 = 0x0
	// Arbitration is allowed at any time during an undefined length burst
	AXBS_MGPCR_AULB_001 = 0x1
	// Arbitration is allowed after four beats of an undefined length burst
	AXBS_MGPCR_AULB_010 = 0x2
	// Arbitration is allowed after eight beats of an undefined length burst
	AXBS_MGPCR_AULB_011 = 0x3
	// Arbitration is allowed after 16 beats of an undefined length burst
	AXBS_MGPCR_AULB_100 = 0x4
)

// Constants for DMA: Enhanced direct memory access controller
const (
	// CR: Control Register
	// Position of EDBG field.
	DMA_CR_EDBG_Pos = 0x1
	// Bit mask of EDBG field.
	DMA_CR_EDBG_Msk = 0x2
	// Bit EDBG.
	DMA_CR_EDBG = 0x2
	// When in debug mode, the DMA continues to operate.
	DMA_CR_EDBG_0 = 0x0
	// When in debug mode, the DMA stalls the start of a new channel. Executing channels are allowed to complete. Channel execution resumes when the system exits debug mode or the EDBG bit is cleared.
	DMA_CR_EDBG_1 = 0x1
	// Position of ERCA field.
	DMA_CR_ERCA_Pos = 0x2
	// Bit mask of ERCA field.
	DMA_CR_ERCA_Msk = 0x4
	// Bit ERCA.
	DMA_CR_ERCA = 0x4
	// Fixed priority arbitration is used for channel selection .
	DMA_CR_ERCA_0 = 0x0
	// Round robin arbitration is used for channel selection .
	DMA_CR_ERCA_1 = 0x1
	// Position of HOE field.
	DMA_CR_HOE_Pos = 0x4
	// Bit mask of HOE field.
	DMA_CR_HOE_Msk = 0x10
	// Bit HOE.
	DMA_CR_HOE = 0x10
	// Normal operation
	DMA_CR_HOE_0 = 0x0
	// Any error causes the HALT bit to set. Subsequently, all service requests are ignored until the HALT bit is cleared.
	DMA_CR_HOE_1 = 0x1
	// Position of HALT field.
	DMA_CR_HALT_Pos = 0x5
	// Bit mask of HALT field.
	DMA_CR_HALT_Msk = 0x20
	// Bit HALT.
	DMA_CR_HALT = 0x20
	// Normal operation
	DMA_CR_HALT_0 = 0x0
	// Stall the start of any new channels. Executing channels are allowed to complete. Channel execution resumes when this bit is cleared.
	DMA_CR_HALT_1 = 0x1
	// Position of CLM field.
	DMA_CR_CLM_Pos = 0x6
	// Bit mask of CLM field.
	DMA_CR_CLM_Msk = 0x40
	// Bit CLM.
	DMA_CR_CLM = 0x40
	// A minor loop channel link made to itself goes through channel arbitration before being activated again.
	DMA_CR_CLM_0 = 0x0
	// A minor loop channel link made to itself does not go through channel arbitration before being activated again. Upon minor loop completion, the channel activates again if that channel has a minor loop channel link enabled and the link channel is itself. This effectively applies the minor loop offsets and restarts the next minor loop.
	DMA_CR_CLM_1 = 0x1
	// Position of EMLM field.
	DMA_CR_EMLM_Pos = 0x7
	// Bit mask of EMLM field.
	DMA_CR_EMLM_Msk = 0x80
	// Bit EMLM.
	DMA_CR_EMLM = 0x80
	// Disabled. TCDn.word2 is defined as a 32-bit NBYTES field.
	DMA_CR_EMLM_0 = 0x0
	// Enabled. TCDn.word2 is redefined to include individual enable fields, an offset field, and the NBYTES field. The individual enable fields allow the minor loop offset to be applied to the source address, the destination address, or both. The NBYTES field is reduced when either offset is enabled.
	DMA_CR_EMLM_1 = 0x1
	// Position of ECX field.
	DMA_CR_ECX_Pos = 0x10
	// Bit mask of ECX field.
	DMA_CR_ECX_Msk = 0x10000
	// Bit ECX.
	DMA_CR_ECX = 0x10000
	// Normal operation
	DMA_CR_ECX_0 = 0x0
	// Cancel the remaining data transfer in the same fashion as the CX bit. Stop the executing channel and force the minor loop to finish. The cancel takes effect after the last write of the current read/write sequence. The ECX bit clears itself after the cancel is honored. In addition to cancelling the transfer, ECX treats the cancel as an error condition, thus updating the Error Status register (DMAx_ES) and generating an optional error interrupt.
	DMA_CR_ECX_1 = 0x1
	// Position of CX field.
	DMA_CR_CX_Pos = 0x11
	// Bit mask of CX field.
	DMA_CR_CX_Msk = 0x20000
	// Bit CX.
	DMA_CR_CX = 0x20000
	// Normal operation
	DMA_CR_CX_0 = 0x0
	// Cancel the remaining data transfer. Stop the executing channel and force the minor loop to finish. The cancel takes effect after the last write of the current read/write sequence. The CX bit clears itself after the cancel has been honored. This cancel retires the channel normally as if the minor loop was completed.
	DMA_CR_CX_1 = 0x1

	// ES: Error Status Register
	// Position of DBE field.
	DMA_ES_DBE_Pos = 0x0
	// Bit mask of DBE field.
	DMA_ES_DBE_Msk = 0x1
	// Bit DBE.
	DMA_ES_DBE = 0x1
	// No destination bus error
	DMA_ES_DBE_0 = 0x0
	// The last recorded error was a bus error on a destination write
	DMA_ES_DBE_1 = 0x1
	// Position of SBE field.
	DMA_ES_SBE_Pos = 0x1
	// Bit mask of SBE field.
	DMA_ES_SBE_Msk = 0x2
	// Bit SBE.
	DMA_ES_SBE = 0x2
	// No source bus error
	DMA_ES_SBE_0 = 0x0
	// The last recorded error was a bus error on a source read
	DMA_ES_SBE_1 = 0x1
	// Position of SGE field.
	DMA_ES_SGE_Pos = 0x2
	// Bit mask of SGE field.
	DMA_ES_SGE_Msk = 0x4
	// Bit SGE.
	DMA_ES_SGE = 0x4
	// No scatter/gather configuration error
	DMA_ES_SGE_0 = 0x0
	// The last recorded error was a configuration error detected in the TCDn_DLASTSGA field. This field is checked at the beginning of a scatter/gather operation after major loop completion if TCDn_CSR[ESG] is enabled. TCDn_DLASTSGA is not on a 32 byte boundary.
	DMA_ES_SGE_1 = 0x1
	// Position of NCE field.
	DMA_ES_NCE_Pos = 0x3
	// Bit mask of NCE field.
	DMA_ES_NCE_Msk = 0x8
	// Bit NCE.
	DMA_ES_NCE = 0x8
	// No NBYTES/CITER configuration error
	DMA_ES_NCE_0 = 0x0
	// The last recorded error was a configuration error detected in the TCDn_NBYTES or TCDn_CITER fields. TCDn_NBYTES is not a multiple of TCDn_ATTR[SSIZE] and TCDn_ATTR[DSIZE], or TCDn_CITER[CITER] is equal to zero, or TCDn_CITER[ELINK] is not equal to TCDn_BITER[ELINK]
	DMA_ES_NCE_1 = 0x1
	// Position of DOE field.
	DMA_ES_DOE_Pos = 0x4
	// Bit mask of DOE field.
	DMA_ES_DOE_Msk = 0x10
	// Bit DOE.
	DMA_ES_DOE = 0x10
	// No destination offset configuration error
	DMA_ES_DOE_0 = 0x0
	// The last recorded error was a configuration error detected in the TCDn_DOFF field. TCDn_DOFF is inconsistent with TCDn_ATTR[DSIZE].
	DMA_ES_DOE_1 = 0x1
	// Position of DAE field.
	DMA_ES_DAE_Pos = 0x5
	// Bit mask of DAE field.
	DMA_ES_DAE_Msk = 0x20
	// Bit DAE.
	DMA_ES_DAE = 0x20
	// No destination address configuration error
	DMA_ES_DAE_0 = 0x0
	// The last recorded error was a configuration error detected in the TCDn_DADDR field. TCDn_DADDR is inconsistent with TCDn_ATTR[DSIZE].
	DMA_ES_DAE_1 = 0x1
	// Position of SOE field.
	DMA_ES_SOE_Pos = 0x6
	// Bit mask of SOE field.
	DMA_ES_SOE_Msk = 0x40
	// Bit SOE.
	DMA_ES_SOE = 0x40
	// No source offset configuration error
	DMA_ES_SOE_0 = 0x0
	// The last recorded error was a configuration error detected in the TCDn_SOFF field. TCDn_SOFF is inconsistent with TCDn_ATTR[SSIZE].
	DMA_ES_SOE_1 = 0x1
	// Position of SAE field.
	DMA_ES_SAE_Pos = 0x7
	// Bit mask of SAE field.
	DMA_ES_SAE_Msk = 0x80
	// Bit SAE.
	DMA_ES_SAE = 0x80
	// No source address configuration error.
	DMA_ES_SAE_0 = 0x0
	// The last recorded error was a configuration error detected in the TCDn_SADDR field. TCDn_SADDR is inconsistent with TCDn_ATTR[SSIZE].
	DMA_ES_SAE_1 = 0x1
	// Position of ERRCHN field.
	DMA_ES_ERRCHN_Pos = 0x8
	// Bit mask of ERRCHN field.
	DMA_ES_ERRCHN_Msk = 0xf00
	// Position of CPE field.
	DMA_ES_CPE_Pos = 0xe
	// Bit mask of CPE field.
	DMA_ES_CPE_Msk = 0x4000
	// Bit CPE.
	DMA_ES_CPE = 0x4000
	// No channel priority error
	DMA_ES_CPE_0 = 0x0
	// The last recorded error was a configuration error in the channel priorities . Channel priorities are not unique.
	DMA_ES_CPE_1 = 0x1
	// Position of ECX field.
	DMA_ES_ECX_Pos = 0x10
	// Bit mask of ECX field.
	DMA_ES_ECX_Msk = 0x10000
	// Bit ECX.
	DMA_ES_ECX = 0x10000
	// No canceled transfers
	DMA_ES_ECX_0 = 0x0
	// The last recorded entry was a canceled transfer by the error cancel transfer input
	DMA_ES_ECX_1 = 0x1
	// Position of VLD field.
	DMA_ES_VLD_Pos = 0x1f
	// Bit mask of VLD field.
	DMA_ES_VLD_Msk = 0x80000000
	// Bit VLD.
	DMA_ES_VLD = 0x80000000
	// No ERR bits are set
	DMA_ES_VLD_0 = 0x0
	// At least one ERR bit is set indicating a valid error exists that has not been cleared
	DMA_ES_VLD_1 = 0x1

	// ERQ: Enable Request Register
	// Position of ERQ0 field.
	DMA_ERQ_ERQ0_Pos = 0x0
	// Bit mask of ERQ0 field.
	DMA_ERQ_ERQ0_Msk = 0x1
	// Bit ERQ0.
	DMA_ERQ_ERQ0 = 0x1
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ0_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ0_1 = 0x1
	// Position of ERQ1 field.
	DMA_ERQ_ERQ1_Pos = 0x1
	// Bit mask of ERQ1 field.
	DMA_ERQ_ERQ1_Msk = 0x2
	// Bit ERQ1.
	DMA_ERQ_ERQ1 = 0x2
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ1_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ1_1 = 0x1
	// Position of ERQ2 field.
	DMA_ERQ_ERQ2_Pos = 0x2
	// Bit mask of ERQ2 field.
	DMA_ERQ_ERQ2_Msk = 0x4
	// Bit ERQ2.
	DMA_ERQ_ERQ2 = 0x4
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ2_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ2_1 = 0x1
	// Position of ERQ3 field.
	DMA_ERQ_ERQ3_Pos = 0x3
	// Bit mask of ERQ3 field.
	DMA_ERQ_ERQ3_Msk = 0x8
	// Bit ERQ3.
	DMA_ERQ_ERQ3 = 0x8
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ3_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ3_1 = 0x1
	// Position of ERQ4 field.
	DMA_ERQ_ERQ4_Pos = 0x4
	// Bit mask of ERQ4 field.
	DMA_ERQ_ERQ4_Msk = 0x10
	// Bit ERQ4.
	DMA_ERQ_ERQ4 = 0x10
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ4_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ4_1 = 0x1
	// Position of ERQ5 field.
	DMA_ERQ_ERQ5_Pos = 0x5
	// Bit mask of ERQ5 field.
	DMA_ERQ_ERQ5_Msk = 0x20
	// Bit ERQ5.
	DMA_ERQ_ERQ5 = 0x20
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ5_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ5_1 = 0x1
	// Position of ERQ6 field.
	DMA_ERQ_ERQ6_Pos = 0x6
	// Bit mask of ERQ6 field.
	DMA_ERQ_ERQ6_Msk = 0x40
	// Bit ERQ6.
	DMA_ERQ_ERQ6 = 0x40
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ6_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ6_1 = 0x1
	// Position of ERQ7 field.
	DMA_ERQ_ERQ7_Pos = 0x7
	// Bit mask of ERQ7 field.
	DMA_ERQ_ERQ7_Msk = 0x80
	// Bit ERQ7.
	DMA_ERQ_ERQ7 = 0x80
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ7_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ7_1 = 0x1
	// Position of ERQ8 field.
	DMA_ERQ_ERQ8_Pos = 0x8
	// Bit mask of ERQ8 field.
	DMA_ERQ_ERQ8_Msk = 0x100
	// Bit ERQ8.
	DMA_ERQ_ERQ8 = 0x100
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ8_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ8_1 = 0x1
	// Position of ERQ9 field.
	DMA_ERQ_ERQ9_Pos = 0x9
	// Bit mask of ERQ9 field.
	DMA_ERQ_ERQ9_Msk = 0x200
	// Bit ERQ9.
	DMA_ERQ_ERQ9 = 0x200
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ9_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ9_1 = 0x1
	// Position of ERQ10 field.
	DMA_ERQ_ERQ10_Pos = 0xa
	// Bit mask of ERQ10 field.
	DMA_ERQ_ERQ10_Msk = 0x400
	// Bit ERQ10.
	DMA_ERQ_ERQ10 = 0x400
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ10_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ10_1 = 0x1
	// Position of ERQ11 field.
	DMA_ERQ_ERQ11_Pos = 0xb
	// Bit mask of ERQ11 field.
	DMA_ERQ_ERQ11_Msk = 0x800
	// Bit ERQ11.
	DMA_ERQ_ERQ11 = 0x800
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ11_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ11_1 = 0x1
	// Position of ERQ12 field.
	DMA_ERQ_ERQ12_Pos = 0xc
	// Bit mask of ERQ12 field.
	DMA_ERQ_ERQ12_Msk = 0x1000
	// Bit ERQ12.
	DMA_ERQ_ERQ12 = 0x1000
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ12_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ12_1 = 0x1
	// Position of ERQ13 field.
	DMA_ERQ_ERQ13_Pos = 0xd
	// Bit mask of ERQ13 field.
	DMA_ERQ_ERQ13_Msk = 0x2000
	// Bit ERQ13.
	DMA_ERQ_ERQ13 = 0x2000
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ13_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ13_1 = 0x1
	// Position of ERQ14 field.
	DMA_ERQ_ERQ14_Pos = 0xe
	// Bit mask of ERQ14 field.
	DMA_ERQ_ERQ14_Msk = 0x4000
	// Bit ERQ14.
	DMA_ERQ_ERQ14 = 0x4000
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ14_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ14_1 = 0x1
	// Position of ERQ15 field.
	DMA_ERQ_ERQ15_Pos = 0xf
	// Bit mask of ERQ15 field.
	DMA_ERQ_ERQ15_Msk = 0x8000
	// Bit ERQ15.
	DMA_ERQ_ERQ15 = 0x8000
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ15_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ15_1 = 0x1

	// EEI: Enable Error Interrupt Register
	// Position of EEI0 field.
	DMA_EEI_EEI0_Pos = 0x0
	// Bit mask of EEI0 field.
	DMA_EEI_EEI0_Msk = 0x1
	// Bit EEI0.
	DMA_EEI_EEI0 = 0x1
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI0_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI0_1 = 0x1
	// Position of EEI1 field.
	DMA_EEI_EEI1_Pos = 0x1
	// Bit mask of EEI1 field.
	DMA_EEI_EEI1_Msk = 0x2
	// Bit EEI1.
	DMA_EEI_EEI1 = 0x2
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI1_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI1_1 = 0x1
	// Position of EEI2 field.
	DMA_EEI_EEI2_Pos = 0x2
	// Bit mask of EEI2 field.
	DMA_EEI_EEI2_Msk = 0x4
	// Bit EEI2.
	DMA_EEI_EEI2 = 0x4
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI2_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI2_1 = 0x1
	// Position of EEI3 field.
	DMA_EEI_EEI3_Pos = 0x3
	// Bit mask of EEI3 field.
	DMA_EEI_EEI3_Msk = 0x8
	// Bit EEI3.
	DMA_EEI_EEI3 = 0x8
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI3_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI3_1 = 0x1
	// Position of EEI4 field.
	DMA_EEI_EEI4_Pos = 0x4
	// Bit mask of EEI4 field.
	DMA_EEI_EEI4_Msk = 0x10
	// Bit EEI4.
	DMA_EEI_EEI4 = 0x10
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI4_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI4_1 = 0x1
	// Position of EEI5 field.
	DMA_EEI_EEI5_Pos = 0x5
	// Bit mask of EEI5 field.
	DMA_EEI_EEI5_Msk = 0x20
	// Bit EEI5.
	DMA_EEI_EEI5 = 0x20
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI5_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI5_1 = 0x1
	// Position of EEI6 field.
	DMA_EEI_EEI6_Pos = 0x6
	// Bit mask of EEI6 field.
	DMA_EEI_EEI6_Msk = 0x40
	// Bit EEI6.
	DMA_EEI_EEI6 = 0x40
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI6_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI6_1 = 0x1
	// Position of EEI7 field.
	DMA_EEI_EEI7_Pos = 0x7
	// Bit mask of EEI7 field.
	DMA_EEI_EEI7_Msk = 0x80
	// Bit EEI7.
	DMA_EEI_EEI7 = 0x80
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI7_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI7_1 = 0x1
	// Position of EEI8 field.
	DMA_EEI_EEI8_Pos = 0x8
	// Bit mask of EEI8 field.
	DMA_EEI_EEI8_Msk = 0x100
	// Bit EEI8.
	DMA_EEI_EEI8 = 0x100
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI8_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI8_1 = 0x1
	// Position of EEI9 field.
	DMA_EEI_EEI9_Pos = 0x9
	// Bit mask of EEI9 field.
	DMA_EEI_EEI9_Msk = 0x200
	// Bit EEI9.
	DMA_EEI_EEI9 = 0x200
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI9_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI9_1 = 0x1
	// Position of EEI10 field.
	DMA_EEI_EEI10_Pos = 0xa
	// Bit mask of EEI10 field.
	DMA_EEI_EEI10_Msk = 0x400
	// Bit EEI10.
	DMA_EEI_EEI10 = 0x400
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI10_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI10_1 = 0x1
	// Position of EEI11 field.
	DMA_EEI_EEI11_Pos = 0xb
	// Bit mask of EEI11 field.
	DMA_EEI_EEI11_Msk = 0x800
	// Bit EEI11.
	DMA_EEI_EEI11 = 0x800
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI11_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI11_1 = 0x1
	// Position of EEI12 field.
	DMA_EEI_EEI12_Pos = 0xc
	// Bit mask of EEI12 field.
	DMA_EEI_EEI12_Msk = 0x1000
	// Bit EEI12.
	DMA_EEI_EEI12 = 0x1000
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI12_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI12_1 = 0x1
	// Position of EEI13 field.
	DMA_EEI_EEI13_Pos = 0xd
	// Bit mask of EEI13 field.
	DMA_EEI_EEI13_Msk = 0x2000
	// Bit EEI13.
	DMA_EEI_EEI13 = 0x2000
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI13_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI13_1 = 0x1
	// Position of EEI14 field.
	DMA_EEI_EEI14_Pos = 0xe
	// Bit mask of EEI14 field.
	DMA_EEI_EEI14_Msk = 0x4000
	// Bit EEI14.
	DMA_EEI_EEI14 = 0x4000
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI14_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI14_1 = 0x1
	// Position of EEI15 field.
	DMA_EEI_EEI15_Pos = 0xf
	// Bit mask of EEI15 field.
	DMA_EEI_EEI15_Msk = 0x8000
	// Bit EEI15.
	DMA_EEI_EEI15 = 0x8000
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI15_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI15_1 = 0x1

	// CEEI: Clear Enable Error Interrupt Register
	// Position of CEEI field.
	DMA_CEEI_CEEI_Pos = 0x0
	// Bit mask of CEEI field.
	DMA_CEEI_CEEI_Msk = 0xf
	// Position of CAEE field.
	DMA_CEEI_CAEE_Pos = 0x6
	// Bit mask of CAEE field.
	DMA_CEEI_CAEE_Msk = 0x40
	// Bit CAEE.
	DMA_CEEI_CAEE = 0x40
	// Clear only the EEI bit specified in the CEEI field
	DMA_CEEI_CAEE_0 = 0x0
	// Clear all bits in EEI
	DMA_CEEI_CAEE_1 = 0x1
	// Position of NOP field.
	DMA_CEEI_NOP_Pos = 0x7
	// Bit mask of NOP field.
	DMA_CEEI_NOP_Msk = 0x80
	// Bit NOP.
	DMA_CEEI_NOP = 0x80
	// Normal operation
	DMA_CEEI_NOP_0 = 0x0
	// No operation, ignore the other bits in this register
	DMA_CEEI_NOP_1 = 0x1

	// SEEI: Set Enable Error Interrupt Register
	// Position of SEEI field.
	DMA_SEEI_SEEI_Pos = 0x0
	// Bit mask of SEEI field.
	DMA_SEEI_SEEI_Msk = 0xf
	// Position of SAEE field.
	DMA_SEEI_SAEE_Pos = 0x6
	// Bit mask of SAEE field.
	DMA_SEEI_SAEE_Msk = 0x40
	// Bit SAEE.
	DMA_SEEI_SAEE = 0x40
	// Set only the EEI bit specified in the SEEI field.
	DMA_SEEI_SAEE_0 = 0x0
	// Sets all bits in EEI
	DMA_SEEI_SAEE_1 = 0x1
	// Position of NOP field.
	DMA_SEEI_NOP_Pos = 0x7
	// Bit mask of NOP field.
	DMA_SEEI_NOP_Msk = 0x80
	// Bit NOP.
	DMA_SEEI_NOP = 0x80
	// Normal operation
	DMA_SEEI_NOP_0 = 0x0
	// No operation, ignore the other bits in this register
	DMA_SEEI_NOP_1 = 0x1

	// CERQ: Clear Enable Request Register
	// Position of CERQ field.
	DMA_CERQ_CERQ_Pos = 0x0
	// Bit mask of CERQ field.
	DMA_CERQ_CERQ_Msk = 0xf
	// Position of CAER field.
	DMA_CERQ_CAER_Pos = 0x6
	// Bit mask of CAER field.
	DMA_CERQ_CAER_Msk = 0x40
	// Bit CAER.
	DMA_CERQ_CAER = 0x40
	// Clear only the ERQ bit specified in the CERQ field
	DMA_CERQ_CAER_0 = 0x0
	// Clear all bits in ERQ
	DMA_CERQ_CAER_1 = 0x1
	// Position of NOP field.
	DMA_CERQ_NOP_Pos = 0x7
	// Bit mask of NOP field.
	DMA_CERQ_NOP_Msk = 0x80
	// Bit NOP.
	DMA_CERQ_NOP = 0x80
	// Normal operation
	DMA_CERQ_NOP_0 = 0x0
	// No operation, ignore the other bits in this register
	DMA_CERQ_NOP_1 = 0x1

	// SERQ: Set Enable Request Register
	// Position of SERQ field.
	DMA_SERQ_SERQ_Pos = 0x0
	// Bit mask of SERQ field.
	DMA_SERQ_SERQ_Msk = 0xf
	// Position of SAER field.
	DMA_SERQ_SAER_Pos = 0x6
	// Bit mask of SAER field.
	DMA_SERQ_SAER_Msk = 0x40
	// Bit SAER.
	DMA_SERQ_SAER = 0x40
	// Set only the ERQ bit specified in the SERQ field
	DMA_SERQ_SAER_0 = 0x0
	// Set all bits in ERQ
	DMA_SERQ_SAER_1 = 0x1
	// Position of NOP field.
	DMA_SERQ_NOP_Pos = 0x7
	// Bit mask of NOP field.
	DMA_SERQ_NOP_Msk = 0x80
	// Bit NOP.
	DMA_SERQ_NOP = 0x80
	// Normal operation
	DMA_SERQ_NOP_0 = 0x0
	// No operation, ignore the other bits in this register
	DMA_SERQ_NOP_1 = 0x1

	// CDNE: Clear DONE Status Bit Register
	// Position of CDNE field.
	DMA_CDNE_CDNE_Pos = 0x0
	// Bit mask of CDNE field.
	DMA_CDNE_CDNE_Msk = 0xf
	// Position of CADN field.
	DMA_CDNE_CADN_Pos = 0x6
	// Bit mask of CADN field.
	DMA_CDNE_CADN_Msk = 0x40
	// Bit CADN.
	DMA_CDNE_CADN = 0x40
	// Clears only the TCDn_CSR[DONE] bit specified in the CDNE field
	DMA_CDNE_CADN_0 = 0x0
	// Clears all bits in TCDn_CSR[DONE]
	DMA_CDNE_CADN_1 = 0x1
	// Position of NOP field.
	DMA_CDNE_NOP_Pos = 0x7
	// Bit mask of NOP field.
	DMA_CDNE_NOP_Msk = 0x80
	// Bit NOP.
	DMA_CDNE_NOP = 0x80
	// Normal operation
	DMA_CDNE_NOP_0 = 0x0
	// No operation, ignore the other bits in this register
	DMA_CDNE_NOP_1 = 0x1

	// SSRT: Set START Bit Register
	// Position of SSRT field.
	DMA_SSRT_SSRT_Pos = 0x0
	// Bit mask of SSRT field.
	DMA_SSRT_SSRT_Msk = 0xf
	// Position of SAST field.
	DMA_SSRT_SAST_Pos = 0x6
	// Bit mask of SAST field.
	DMA_SSRT_SAST_Msk = 0x40
	// Bit SAST.
	DMA_SSRT_SAST = 0x40
	// Set only the TCDn_CSR[START] bit specified in the SSRT field
	DMA_SSRT_SAST_0 = 0x0
	// Set all bits in TCDn_CSR[START]
	DMA_SSRT_SAST_1 = 0x1
	// Position of NOP field.
	DMA_SSRT_NOP_Pos = 0x7
	// Bit mask of NOP field.
	DMA_SSRT_NOP_Msk = 0x80
	// Bit NOP.
	DMA_SSRT_NOP = 0x80
	// Normal operation
	DMA_SSRT_NOP_0 = 0x0
	// No operation, ignore the other bits in this register
	DMA_SSRT_NOP_1 = 0x1

	// CERR: Clear Error Register
	// Position of CERR field.
	DMA_CERR_CERR_Pos = 0x0
	// Bit mask of CERR field.
	DMA_CERR_CERR_Msk = 0xf
	// Position of CAEI field.
	DMA_CERR_CAEI_Pos = 0x6
	// Bit mask of CAEI field.
	DMA_CERR_CAEI_Msk = 0x40
	// Bit CAEI.
	DMA_CERR_CAEI = 0x40
	// Clear only the ERR bit specified in the CERR field
	DMA_CERR_CAEI_0 = 0x0
	// Clear all bits in ERR
	DMA_CERR_CAEI_1 = 0x1
	// Position of NOP field.
	DMA_CERR_NOP_Pos = 0x7
	// Bit mask of NOP field.
	DMA_CERR_NOP_Msk = 0x80
	// Bit NOP.
	DMA_CERR_NOP = 0x80
	// Normal operation
	DMA_CERR_NOP_0 = 0x0
	// No operation, ignore the other bits in this register
	DMA_CERR_NOP_1 = 0x1

	// CINT: Clear Interrupt Request Register
	// Position of CINT field.
	DMA_CINT_CINT_Pos = 0x0
	// Bit mask of CINT field.
	DMA_CINT_CINT_Msk = 0xf
	// Position of CAIR field.
	DMA_CINT_CAIR_Pos = 0x6
	// Bit mask of CAIR field.
	DMA_CINT_CAIR_Msk = 0x40
	// Bit CAIR.
	DMA_CINT_CAIR = 0x40
	// Clear only the INT bit specified in the CINT field
	DMA_CINT_CAIR_0 = 0x0
	// Clear all bits in INT
	DMA_CINT_CAIR_1 = 0x1
	// Position of NOP field.
	DMA_CINT_NOP_Pos = 0x7
	// Bit mask of NOP field.
	DMA_CINT_NOP_Msk = 0x80
	// Bit NOP.
	DMA_CINT_NOP = 0x80
	// Normal operation
	DMA_CINT_NOP_0 = 0x0
	// No operation, ignore the other bits in this register
	DMA_CINT_NOP_1 = 0x1

	// INT: Interrupt Request Register
	// Position of INT0 field.
	DMA_INT_INT0_Pos = 0x0
	// Bit mask of INT0 field.
	DMA_INT_INT0_Msk = 0x1
	// Bit INT0.
	DMA_INT_INT0 = 0x1
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT0_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT0_1 = 0x1
	// Position of INT1 field.
	DMA_INT_INT1_Pos = 0x1
	// Bit mask of INT1 field.
	DMA_INT_INT1_Msk = 0x2
	// Bit INT1.
	DMA_INT_INT1 = 0x2
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT1_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT1_1 = 0x1
	// Position of INT2 field.
	DMA_INT_INT2_Pos = 0x2
	// Bit mask of INT2 field.
	DMA_INT_INT2_Msk = 0x4
	// Bit INT2.
	DMA_INT_INT2 = 0x4
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT2_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT2_1 = 0x1
	// Position of INT3 field.
	DMA_INT_INT3_Pos = 0x3
	// Bit mask of INT3 field.
	DMA_INT_INT3_Msk = 0x8
	// Bit INT3.
	DMA_INT_INT3 = 0x8
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT3_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT3_1 = 0x1
	// Position of INT4 field.
	DMA_INT_INT4_Pos = 0x4
	// Bit mask of INT4 field.
	DMA_INT_INT4_Msk = 0x10
	// Bit INT4.
	DMA_INT_INT4 = 0x10
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT4_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT4_1 = 0x1
	// Position of INT5 field.
	DMA_INT_INT5_Pos = 0x5
	// Bit mask of INT5 field.
	DMA_INT_INT5_Msk = 0x20
	// Bit INT5.
	DMA_INT_INT5 = 0x20
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT5_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT5_1 = 0x1
	// Position of INT6 field.
	DMA_INT_INT6_Pos = 0x6
	// Bit mask of INT6 field.
	DMA_INT_INT6_Msk = 0x40
	// Bit INT6.
	DMA_INT_INT6 = 0x40
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT6_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT6_1 = 0x1
	// Position of INT7 field.
	DMA_INT_INT7_Pos = 0x7
	// Bit mask of INT7 field.
	DMA_INT_INT7_Msk = 0x80
	// Bit INT7.
	DMA_INT_INT7 = 0x80
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT7_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT7_1 = 0x1
	// Position of INT8 field.
	DMA_INT_INT8_Pos = 0x8
	// Bit mask of INT8 field.
	DMA_INT_INT8_Msk = 0x100
	// Bit INT8.
	DMA_INT_INT8 = 0x100
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT8_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT8_1 = 0x1
	// Position of INT9 field.
	DMA_INT_INT9_Pos = 0x9
	// Bit mask of INT9 field.
	DMA_INT_INT9_Msk = 0x200
	// Bit INT9.
	DMA_INT_INT9 = 0x200
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT9_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT9_1 = 0x1
	// Position of INT10 field.
	DMA_INT_INT10_Pos = 0xa
	// Bit mask of INT10 field.
	DMA_INT_INT10_Msk = 0x400
	// Bit INT10.
	DMA_INT_INT10 = 0x400
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT10_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT10_1 = 0x1
	// Position of INT11 field.
	DMA_INT_INT11_Pos = 0xb
	// Bit mask of INT11 field.
	DMA_INT_INT11_Msk = 0x800
	// Bit INT11.
	DMA_INT_INT11 = 0x800
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT11_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT11_1 = 0x1
	// Position of INT12 field.
	DMA_INT_INT12_Pos = 0xc
	// Bit mask of INT12 field.
	DMA_INT_INT12_Msk = 0x1000
	// Bit INT12.
	DMA_INT_INT12 = 0x1000
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT12_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT12_1 = 0x1
	// Position of INT13 field.
	DMA_INT_INT13_Pos = 0xd
	// Bit mask of INT13 field.
	DMA_INT_INT13_Msk = 0x2000
	// Bit INT13.
	DMA_INT_INT13 = 0x2000
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT13_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT13_1 = 0x1
	// Position of INT14 field.
	DMA_INT_INT14_Pos = 0xe
	// Bit mask of INT14 field.
	DMA_INT_INT14_Msk = 0x4000
	// Bit INT14.
	DMA_INT_INT14 = 0x4000
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT14_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT14_1 = 0x1
	// Position of INT15 field.
	DMA_INT_INT15_Pos = 0xf
	// Bit mask of INT15 field.
	DMA_INT_INT15_Msk = 0x8000
	// Bit INT15.
	DMA_INT_INT15 = 0x8000
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT15_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT15_1 = 0x1

	// ERR: Error Register
	// Position of ERR0 field.
	DMA_ERR_ERR0_Pos = 0x0
	// Bit mask of ERR0 field.
	DMA_ERR_ERR0_Msk = 0x1
	// Bit ERR0.
	DMA_ERR_ERR0 = 0x1
	// An error in the corresponding channel has not occurred
	DMA_ERR_ERR0_0 = 0x0
	// An error in the corresponding channel has occurred
	DMA_ERR_ERR0_1 = 0x1
	// Position of ERR1 field.
	DMA_ERR_ERR1_Pos = 0x1
	// Bit mask of ERR1 field.
	DMA_ERR_ERR1_Msk = 0x2
	// Bit ERR1.
	DMA_ERR_ERR1 = 0x2
	// An error in the corresponding channel has not occurred
	DMA_ERR_ERR1_0 = 0x0
	// An error in the corresponding channel has occurred
	DMA_ERR_ERR1_1 = 0x1
	// Position of ERR2 field.
	DMA_ERR_ERR2_Pos = 0x2
	// Bit mask of ERR2 field.
	DMA_ERR_ERR2_Msk = 0x4
	// Bit ERR2.
	DMA_ERR_ERR2 = 0x4
	// An error in the corresponding channel has not occurred
	DMA_ERR_ERR2_0 = 0x0
	// An error in the corresponding channel has occurred
	DMA_ERR_ERR2_1 = 0x1
	// Position of ERR3 field.
	DMA_ERR_ERR3_Pos = 0x3
	// Bit mask of ERR3 field.
	DMA_ERR_ERR3_Msk = 0x8
	// Bit ERR3.
	DMA_ERR_ERR3 = 0x8
	// An error in the corresponding channel has not occurred
	DMA_ERR_ERR3_0 = 0x0
	// An error in the corresponding channel has occurred
	DMA_ERR_ERR3_1 = 0x1
	// Position of ERR4 field.
	DMA_ERR_ERR4_Pos = 0x4
	// Bit mask of ERR4 field.
	DMA_ERR_ERR4_Msk = 0x10
	// Bit ERR4.
	DMA_ERR_ERR4 = 0x10
	// An error in the corresponding channel has not occurred
	DMA_ERR_ERR4_0 = 0x0
	// An error in the corresponding channel has occurred
	DMA_ERR_ERR4_1 = 0x1
	// Position of ERR5 field.
	DMA_ERR_ERR5_Pos = 0x5
	// Bit mask of ERR5 field.
	DMA_ERR_ERR5_Msk = 0x20
	// Bit ERR5.
	DMA_ERR_ERR5 = 0x20
	// An error in the corresponding channel has not occurred
	DMA_ERR_ERR5_0 = 0x0
	// An error in the corresponding channel has occurred
	DMA_ERR_ERR5_1 = 0x1
	// Position of ERR6 field.
	DMA_ERR_ERR6_Pos = 0x6
	// Bit mask of ERR6 field.
	DMA_ERR_ERR6_Msk = 0x40
	// Bit ERR6.
	DMA_ERR_ERR6 = 0x40
	// An error in the corresponding channel has not occurred
	DMA_ERR_ERR6_0 = 0x0
	// An error in the corresponding channel has occurred
	DMA_ERR_ERR6_1 = 0x1
	// Position of ERR7 field.
	DMA_ERR_ERR7_Pos = 0x7
	// Bit mask of ERR7 field.
	DMA_ERR_ERR7_Msk = 0x80
	// Bit ERR7.
	DMA_ERR_ERR7 = 0x80
	// An error in the corresponding channel has not occurred
	DMA_ERR_ERR7_0 = 0x0
	// An error in the corresponding channel has occurred
	DMA_ERR_ERR7_1 = 0x1
	// Position of ERR8 field.
	DMA_ERR_ERR8_Pos = 0x8
	// Bit mask of ERR8 field.
	DMA_ERR_ERR8_Msk = 0x100
	// Bit ERR8.
	DMA_ERR_ERR8 = 0x100
	// An error in the corresponding channel has not occurred
	DMA_ERR_ERR8_0 = 0x0
	// An error in the corresponding channel has occurred
	DMA_ERR_ERR8_1 = 0x1
	// Position of ERR9 field.
	DMA_ERR_ERR9_Pos = 0x9
	// Bit mask of ERR9 field.
	DMA_ERR_ERR9_Msk = 0x200
	// Bit ERR9.
	DMA_ERR_ERR9 = 0x200
	// An error in the corresponding channel has not occurred
	DMA_ERR_ERR9_0 = 0x0
	// An error in the corresponding channel has occurred
	DMA_ERR_ERR9_1 = 0x1
	// Position of ERR10 field.
	DMA_ERR_ERR10_Pos = 0xa
	// Bit mask of ERR10 field.
	DMA_ERR_ERR10_Msk = 0x400
	// Bit ERR10.
	DMA_ERR_ERR10 = 0x400
	// An error in the corresponding channel has not occurred
	DMA_ERR_ERR10_0 = 0x0
	// An error in the corresponding channel has occurred
	DMA_ERR_ERR10_1 = 0x1
	// Position of ERR11 field.
	DMA_ERR_ERR11_Pos = 0xb
	// Bit mask of ERR11 field.
	DMA_ERR_ERR11_Msk = 0x800
	// Bit ERR11.
	DMA_ERR_ERR11 = 0x800
	// An error in the corresponding channel has not occurred
	DMA_ERR_ERR11_0 = 0x0
	// An error in the corresponding channel has occurred
	DMA_ERR_ERR11_1 = 0x1
	// Position of ERR12 field.
	DMA_ERR_ERR12_Pos = 0xc
	// Bit mask of ERR12 field.
	DMA_ERR_ERR12_Msk = 0x1000
	// Bit ERR12.
	DMA_ERR_ERR12 = 0x1000
	// An error in the corresponding channel has not occurred
	DMA_ERR_ERR12_0 = 0x0
	// An error in the corresponding channel has occurred
	DMA_ERR_ERR12_1 = 0x1
	// Position of ERR13 field.
	DMA_ERR_ERR13_Pos = 0xd
	// Bit mask of ERR13 field.
	DMA_ERR_ERR13_Msk = 0x2000
	// Bit ERR13.
	DMA_ERR_ERR13 = 0x2000
	// An error in the corresponding channel has not occurred
	DMA_ERR_ERR13_0 = 0x0
	// An error in the corresponding channel has occurred
	DMA_ERR_ERR13_1 = 0x1
	// Position of ERR14 field.
	DMA_ERR_ERR14_Pos = 0xe
	// Bit mask of ERR14 field.
	DMA_ERR_ERR14_Msk = 0x4000
	// Bit ERR14.
	DMA_ERR_ERR14 = 0x4000
	// An error in the corresponding channel has not occurred
	DMA_ERR_ERR14_0 = 0x0
	// An error in the corresponding channel has occurred
	DMA_ERR_ERR14_1 = 0x1
	// Position of ERR15 field.
	DMA_ERR_ERR15_Pos = 0xf
	// Bit mask of ERR15 field.
	DMA_ERR_ERR15_Msk = 0x8000
	// Bit ERR15.
	DMA_ERR_ERR15 = 0x8000
	// An error in the corresponding channel has not occurred
	DMA_ERR_ERR15_0 = 0x0
	// An error in the corresponding channel has occurred
	DMA_ERR_ERR15_1 = 0x1

	// HRS: Hardware Request Status Register
	// Position of HRS0 field.
	DMA_HRS_HRS0_Pos = 0x0
	// Bit mask of HRS0 field.
	DMA_HRS_HRS0_Msk = 0x1
	// Bit HRS0.
	DMA_HRS_HRS0 = 0x1
	// A hardware service request for channel 0 is not present
	DMA_HRS_HRS0_0 = 0x0
	// A hardware service request for channel 0 is present
	DMA_HRS_HRS0_1 = 0x1
	// Position of HRS1 field.
	DMA_HRS_HRS1_Pos = 0x1
	// Bit mask of HRS1 field.
	DMA_HRS_HRS1_Msk = 0x2
	// Bit HRS1.
	DMA_HRS_HRS1 = 0x2
	// A hardware service request for channel 1 is not present
	DMA_HRS_HRS1_0 = 0x0
	// A hardware service request for channel 1 is present
	DMA_HRS_HRS1_1 = 0x1
	// Position of HRS2 field.
	DMA_HRS_HRS2_Pos = 0x2
	// Bit mask of HRS2 field.
	DMA_HRS_HRS2_Msk = 0x4
	// Bit HRS2.
	DMA_HRS_HRS2 = 0x4
	// A hardware service request for channel 2 is not present
	DMA_HRS_HRS2_0 = 0x0
	// A hardware service request for channel 2 is present
	DMA_HRS_HRS2_1 = 0x1
	// Position of HRS3 field.
	DMA_HRS_HRS3_Pos = 0x3
	// Bit mask of HRS3 field.
	DMA_HRS_HRS3_Msk = 0x8
	// Bit HRS3.
	DMA_HRS_HRS3 = 0x8
	// A hardware service request for channel 3 is not present
	DMA_HRS_HRS3_0 = 0x0
	// A hardware service request for channel 3 is present
	DMA_HRS_HRS3_1 = 0x1
	// Position of HRS4 field.
	DMA_HRS_HRS4_Pos = 0x4
	// Bit mask of HRS4 field.
	DMA_HRS_HRS4_Msk = 0x10
	// Bit HRS4.
	DMA_HRS_HRS4 = 0x10
	// A hardware service request for channel 4 is not present
	DMA_HRS_HRS4_0 = 0x0
	// A hardware service request for channel 4 is present
	DMA_HRS_HRS4_1 = 0x1
	// Position of HRS5 field.
	DMA_HRS_HRS5_Pos = 0x5
	// Bit mask of HRS5 field.
	DMA_HRS_HRS5_Msk = 0x20
	// Bit HRS5.
	DMA_HRS_HRS5 = 0x20
	// A hardware service request for channel 5 is not present
	DMA_HRS_HRS5_0 = 0x0
	// A hardware service request for channel 5 is present
	DMA_HRS_HRS5_1 = 0x1
	// Position of HRS6 field.
	DMA_HRS_HRS6_Pos = 0x6
	// Bit mask of HRS6 field.
	DMA_HRS_HRS6_Msk = 0x40
	// Bit HRS6.
	DMA_HRS_HRS6 = 0x40
	// A hardware service request for channel 6 is not present
	DMA_HRS_HRS6_0 = 0x0
	// A hardware service request for channel 6 is present
	DMA_HRS_HRS6_1 = 0x1
	// Position of HRS7 field.
	DMA_HRS_HRS7_Pos = 0x7
	// Bit mask of HRS7 field.
	DMA_HRS_HRS7_Msk = 0x80
	// Bit HRS7.
	DMA_HRS_HRS7 = 0x80
	// A hardware service request for channel 7 is not present
	DMA_HRS_HRS7_0 = 0x0
	// A hardware service request for channel 7 is present
	DMA_HRS_HRS7_1 = 0x1
	// Position of HRS8 field.
	DMA_HRS_HRS8_Pos = 0x8
	// Bit mask of HRS8 field.
	DMA_HRS_HRS8_Msk = 0x100
	// Bit HRS8.
	DMA_HRS_HRS8 = 0x100
	// A hardware service request for channel 8 is not present
	DMA_HRS_HRS8_0 = 0x0
	// A hardware service request for channel 8 is present
	DMA_HRS_HRS8_1 = 0x1
	// Position of HRS9 field.
	DMA_HRS_HRS9_Pos = 0x9
	// Bit mask of HRS9 field.
	DMA_HRS_HRS9_Msk = 0x200
	// Bit HRS9.
	DMA_HRS_HRS9 = 0x200
	// A hardware service request for channel 9 is not present
	DMA_HRS_HRS9_0 = 0x0
	// A hardware service request for channel 9 is present
	DMA_HRS_HRS9_1 = 0x1
	// Position of HRS10 field.
	DMA_HRS_HRS10_Pos = 0xa
	// Bit mask of HRS10 field.
	DMA_HRS_HRS10_Msk = 0x400
	// Bit HRS10.
	DMA_HRS_HRS10 = 0x400
	// A hardware service request for channel 10 is not present
	DMA_HRS_HRS10_0 = 0x0
	// A hardware service request for channel 10 is present
	DMA_HRS_HRS10_1 = 0x1
	// Position of HRS11 field.
	DMA_HRS_HRS11_Pos = 0xb
	// Bit mask of HRS11 field.
	DMA_HRS_HRS11_Msk = 0x800
	// Bit HRS11.
	DMA_HRS_HRS11 = 0x800
	// A hardware service request for channel 11 is not present
	DMA_HRS_HRS11_0 = 0x0
	// A hardware service request for channel 11 is present
	DMA_HRS_HRS11_1 = 0x1
	// Position of HRS12 field.
	DMA_HRS_HRS12_Pos = 0xc
	// Bit mask of HRS12 field.
	DMA_HRS_HRS12_Msk = 0x1000
	// Bit HRS12.
	DMA_HRS_HRS12 = 0x1000
	// A hardware service request for channel 12 is not present
	DMA_HRS_HRS12_0 = 0x0
	// A hardware service request for channel 12 is present
	DMA_HRS_HRS12_1 = 0x1
	// Position of HRS13 field.
	DMA_HRS_HRS13_Pos = 0xd
	// Bit mask of HRS13 field.
	DMA_HRS_HRS13_Msk = 0x2000
	// Bit HRS13.
	DMA_HRS_HRS13 = 0x2000
	// A hardware service request for channel 13 is not present
	DMA_HRS_HRS13_0 = 0x0
	// A hardware service request for channel 13 is present
	DMA_HRS_HRS13_1 = 0x1
	// Position of HRS14 field.
	DMA_HRS_HRS14_Pos = 0xe
	// Bit mask of HRS14 field.
	DMA_HRS_HRS14_Msk = 0x4000
	// Bit HRS14.
	DMA_HRS_HRS14 = 0x4000
	// A hardware service request for channel 14 is not present
	DMA_HRS_HRS14_0 = 0x0
	// A hardware service request for channel 14 is present
	DMA_HRS_HRS14_1 = 0x1
	// Position of HRS15 field.
	DMA_HRS_HRS15_Pos = 0xf
	// Bit mask of HRS15 field.
	DMA_HRS_HRS15_Msk = 0x8000
	// Bit HRS15.
	DMA_HRS_HRS15 = 0x8000
	// A hardware service request for channel 15 is not present
	DMA_HRS_HRS15_0 = 0x0
	// A hardware service request for channel 15 is present
	DMA_HRS_HRS15_1 = 0x1

	// DCHPRI3: Channel n Priority Register
	// Position of CHPRI field.
	DMA_DCHPRI_CHPRI_Pos = 0x0
	// Bit mask of CHPRI field.
	DMA_DCHPRI_CHPRI_Msk = 0xf
	// Position of DPA field.
	DMA_DCHPRI_DPA_Pos = 0x6
	// Bit mask of DPA field.
	DMA_DCHPRI_DPA_Msk = 0x40
	// Bit DPA.
	DMA_DCHPRI_DPA = 0x40
	// Channel n can suspend a lower priority channel
	DMA_DCHPRI_DPA_0 = 0x0
	// Channel n cannot suspend any channel, regardless of channel priority
	DMA_DCHPRI_DPA_1 = 0x1
	// Position of ECP field.
	DMA_DCHPRI_ECP_Pos = 0x7
	// Bit mask of ECP field.
	DMA_DCHPRI_ECP_Msk = 0x80
	// Bit ECP.
	DMA_DCHPRI_ECP = 0x80
	// Channel n cannot be suspended by a higher priority channel's service request
	DMA_DCHPRI_ECP_0 = 0x0
	// Channel n can be temporarily suspended by the service request of a higher priority channel
	DMA_DCHPRI_ECP_1 = 0x1

	// TCD0_SADDR: TCD Source Address
	// Position of SADDR field.
	DMA_TCD_SADDR_SADDR_Pos = 0x0
	// Bit mask of SADDR field.
	DMA_TCD_SADDR_SADDR_Msk = 0xffffffff

	// TCD0_SOFF: TCD Signed Source Address Offset
	// Position of SOFF field.
	DMA_TCD_SOFF_SOFF_Pos = 0x0
	// Bit mask of SOFF field.
	DMA_TCD_SOFF_SOFF_Msk = 0xffff

	// TCD0_ATTR: TCD Transfer Attributes
	// Position of DSIZE field.
	DMA_TCD_ATTR_DSIZE_Pos = 0x0
	// Bit mask of DSIZE field.
	DMA_TCD_ATTR_DSIZE_Msk = 0x7
	// Position of DMOD field.
	DMA_TCD_ATTR_DMOD_Pos = 0x3
	// Bit mask of DMOD field.
	DMA_TCD_ATTR_DMOD_Msk = 0xf8
	// Position of SSIZE field.
	DMA_TCD_ATTR_SSIZE_Pos = 0x8
	// Bit mask of SSIZE field.
	DMA_TCD_ATTR_SSIZE_Msk = 0x700
	// 8-bit
	DMA_TCD_ATTR_SSIZE_000 = 0x0
	// 16-bit
	DMA_TCD_ATTR_SSIZE_001 = 0x1
	// 32-bit
	DMA_TCD_ATTR_SSIZE_010 = 0x2
	// 16-byte
	DMA_TCD_ATTR_SSIZE_100 = 0x4
	// 32-byte
	DMA_TCD_ATTR_SSIZE_101 = 0x5
	// Position of SMOD field.
	DMA_TCD_ATTR_SMOD_Pos = 0xb
	// Bit mask of SMOD field.
	DMA_TCD_ATTR_SMOD_Msk = 0xf800
	// Source address modulo feature is disabled
	DMA_TCD_ATTR_SMOD_0 = 0x0

	// TCD0_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Disabled)
	// Position of NBYTES field.
	DMA_TCD_NBYTES_MLNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD_NBYTES_MLNO_NBYTES_Msk = 0xffffffff

	// TCD0_NBYTES_MLOFFNO: TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
	// Position of NBYTES field.
	DMA_TCD_NBYTES_MLOFFNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD_NBYTES_MLOFFNO_NBYTES_Msk = 0x3fffffff
	// Position of DMLOE field.
	DMA_TCD_NBYTES_MLOFFNO_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD_NBYTES_MLOFFNO_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD_NBYTES_MLOFFNO_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD_NBYTES_MLOFFNO_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD_NBYTES_MLOFFNO_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD_NBYTES_MLOFFNO_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD_NBYTES_MLOFFNO_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD_NBYTES_MLOFFNO_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD_NBYTES_MLOFFNO_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD_NBYTES_MLOFFNO_SMLOE_1 = 0x1

	// TCD0_NBYTES_MLOFFYES: TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
	// Position of NBYTES field.
	DMA_TCD_NBYTES_MLOFFYES_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD_NBYTES_MLOFFYES_NBYTES_Msk = 0x3ff
	// Position of MLOFF field.
	DMA_TCD_NBYTES_MLOFFYES_MLOFF_Pos = 0xa
	// Bit mask of MLOFF field.
	DMA_TCD_NBYTES_MLOFFYES_MLOFF_Msk = 0x3ffffc00
	// Position of DMLOE field.
	DMA_TCD_NBYTES_MLOFFYES_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD_NBYTES_MLOFFYES_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD_NBYTES_MLOFFYES_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD_NBYTES_MLOFFYES_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD_NBYTES_MLOFFYES_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD_NBYTES_MLOFFYES_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD_NBYTES_MLOFFYES_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD_NBYTES_MLOFFYES_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD_NBYTES_MLOFFYES_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD_NBYTES_MLOFFYES_SMLOE_1 = 0x1

	// TCD0_SLAST: TCD Last Source Address Adjustment
	// Position of SLAST field.
	DMA_TCD_SLAST_SLAST_Pos = 0x0
	// Bit mask of SLAST field.
	DMA_TCD_SLAST_SLAST_Msk = 0xffffffff

	// TCD0_DADDR: TCD Destination Address
	// Position of DADDR field.
	DMA_TCD_DADDR_DADDR_Pos = 0x0
	// Bit mask of DADDR field.
	DMA_TCD_DADDR_DADDR_Msk = 0xffffffff

	// TCD0_DOFF: TCD Signed Destination Address Offset
	// Position of DOFF field.
	DMA_TCD_DOFF_DOFF_Pos = 0x0
	// Bit mask of DOFF field.
	DMA_TCD_DOFF_DOFF_Msk = 0xffff

	// TCD0_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of CITER field.
	DMA_TCD_CITER_ELINKNO_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD_CITER_ELINKNO_CITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD_CITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD_CITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD_CITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD_CITER_ELINKNO_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD_CITER_ELINKNO_ELINK_1 = 0x1

	// TCD0_CITER_ELINKYES: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of CITER field.
	DMA_TCD_CITER_ELINKYES_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD_CITER_ELINKYES_CITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD_CITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD_CITER_ELINKYES_LINKCH_Msk = 0x1e00
	// Position of ELINK field.
	DMA_TCD_CITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD_CITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD_CITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD_CITER_ELINKYES_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD_CITER_ELINKYES_ELINK_1 = 0x1

	// TCD0_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
	// Position of DLASTSGA field.
	DMA_TCD_DLASTSGA_DLASTSGA_Pos = 0x0
	// Bit mask of DLASTSGA field.
	DMA_TCD_DLASTSGA_DLASTSGA_Msk = 0xffffffff

	// TCD0_CSR: TCD Control and Status
	// Position of START field.
	DMA_TCD_CSR_START_Pos = 0x0
	// Bit mask of START field.
	DMA_TCD_CSR_START_Msk = 0x1
	// Bit START.
	DMA_TCD_CSR_START = 0x1
	// The channel is not explicitly started
	DMA_TCD_CSR_START_0 = 0x0
	// The channel is explicitly started via a software initiated service request
	DMA_TCD_CSR_START_1 = 0x1
	// Position of INTMAJOR field.
	DMA_TCD_CSR_INTMAJOR_Pos = 0x1
	// Bit mask of INTMAJOR field.
	DMA_TCD_CSR_INTMAJOR_Msk = 0x2
	// Bit INTMAJOR.
	DMA_TCD_CSR_INTMAJOR = 0x2
	// The end-of-major loop interrupt is disabled
	DMA_TCD_CSR_INTMAJOR_0 = 0x0
	// The end-of-major loop interrupt is enabled
	DMA_TCD_CSR_INTMAJOR_1 = 0x1
	// Position of INTHALF field.
	DMA_TCD_CSR_INTHALF_Pos = 0x2
	// Bit mask of INTHALF field.
	DMA_TCD_CSR_INTHALF_Msk = 0x4
	// Bit INTHALF.
	DMA_TCD_CSR_INTHALF = 0x4
	// The half-point interrupt is disabled
	DMA_TCD_CSR_INTHALF_0 = 0x0
	// The half-point interrupt is enabled
	DMA_TCD_CSR_INTHALF_1 = 0x1
	// Position of DREQ field.
	DMA_TCD_CSR_DREQ_Pos = 0x3
	// Bit mask of DREQ field.
	DMA_TCD_CSR_DREQ_Msk = 0x8
	// Bit DREQ.
	DMA_TCD_CSR_DREQ = 0x8
	// The channel's ERQ bit is not affected
	DMA_TCD_CSR_DREQ_0 = 0x0
	// The channel's ERQ bit is cleared when the major loop is complete
	DMA_TCD_CSR_DREQ_1 = 0x1
	// Position of ESG field.
	DMA_TCD_CSR_ESG_Pos = 0x4
	// Bit mask of ESG field.
	DMA_TCD_CSR_ESG_Msk = 0x10
	// Bit ESG.
	DMA_TCD_CSR_ESG = 0x10
	// The current channel's TCD is normal format.
	DMA_TCD_CSR_ESG_0 = 0x0
	// The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
	DMA_TCD_CSR_ESG_1 = 0x1
	// Position of MAJORELINK field.
	DMA_TCD_CSR_MAJORELINK_Pos = 0x5
	// Bit mask of MAJORELINK field.
	DMA_TCD_CSR_MAJORELINK_Msk = 0x20
	// Bit MAJORELINK.
	DMA_TCD_CSR_MAJORELINK = 0x20
	// The channel-to-channel linking is disabled
	DMA_TCD_CSR_MAJORELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD_CSR_MAJORELINK_1 = 0x1
	// Position of ACTIVE field.
	DMA_TCD_CSR_ACTIVE_Pos = 0x6
	// Bit mask of ACTIVE field.
	DMA_TCD_CSR_ACTIVE_Msk = 0x40
	// Bit ACTIVE.
	DMA_TCD_CSR_ACTIVE = 0x40
	// Position of DONE field.
	DMA_TCD_CSR_DONE_Pos = 0x7
	// Bit mask of DONE field.
	DMA_TCD_CSR_DONE_Msk = 0x80
	// Bit DONE.
	DMA_TCD_CSR_DONE = 0x80
	// Position of MAJORLINKCH field.
	DMA_TCD_CSR_MAJORLINKCH_Pos = 0x8
	// Bit mask of MAJORLINKCH field.
	DMA_TCD_CSR_MAJORLINKCH_Msk = 0xf00
	// Position of BWC field.
	DMA_TCD_CSR_BWC_Pos = 0xe
	// Bit mask of BWC field.
	DMA_TCD_CSR_BWC_Msk = 0xc000
	// No eDMA engine stalls
	DMA_TCD_CSR_BWC_00 = 0x0
	// eDMA engine stalls for 4 cycles after each r/w
	DMA_TCD_CSR_BWC_10 = 0x2
	// eDMA engine stalls for 8 cycles after each r/w
	DMA_TCD_CSR_BWC_11 = 0x3

	// TCD0_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of BITER field.
	DMA_TCD_BITER_ELINKNO_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD_BITER_ELINKNO_BITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD_BITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD_BITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD_BITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD_BITER_ELINKNO_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD_BITER_ELINKNO_ELINK_1 = 0x1

	// TCD0_BITER_ELINKYES: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of BITER field.
	DMA_TCD_BITER_ELINKYES_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD_BITER_ELINKYES_BITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD_BITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD_BITER_ELINKYES_LINKCH_Msk = 0x1e00
	// Position of ELINK field.
	DMA_TCD_BITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD_BITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD_BITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD_BITER_ELINKYES_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD_BITER_ELINKYES_ELINK_1 = 0x1
)

// Constants for FB: FlexBus external bus interface
const (
	// CSAR0: Chip Select Address Register
	// Position of BA field.
	FB_CSAR_BA_Pos = 0x10
	// Bit mask of BA field.
	FB_CSAR_BA_Msk = 0xffff0000

	// CSMR0: Chip Select Mask Register
	// Position of V field.
	FB_CSMR_V_Pos = 0x0
	// Bit mask of V field.
	FB_CSMR_V_Msk = 0x1
	// Bit V.
	FB_CSMR_V = 0x1
	// Chip-select is invalid.
	FB_CSMR_V_0 = 0x0
	// Chip-select is valid.
	FB_CSMR_V_1 = 0x1
	// Position of WP field.
	FB_CSMR_WP_Pos = 0x8
	// Bit mask of WP field.
	FB_CSMR_WP_Msk = 0x100
	// Bit WP.
	FB_CSMR_WP = 0x100
	// Write accesses are allowed.
	FB_CSMR_WP_0 = 0x0
	// Write accesses are not allowed. Attempting to write to the range of addresses for which the WP bit is set results in a bus error termination of the internal cycle and no external cycle.
	FB_CSMR_WP_1 = 0x1
	// Position of BAM field.
	FB_CSMR_BAM_Pos = 0x10
	// Bit mask of BAM field.
	FB_CSMR_BAM_Msk = 0xffff0000
	// The corresponding address bit in CSAR is used in the chip-select decode.
	FB_CSMR_BAM_0 = 0x0
	// The corresponding address bit in CSAR is a don't care in the chip-select decode.
	FB_CSMR_BAM_1 = 0x1

	// CSCR0: Chip Select Control Register
	// Position of BSTW field.
	FB_CSCR_BSTW_Pos = 0x3
	// Bit mask of BSTW field.
	FB_CSCR_BSTW_Msk = 0x8
	// Bit BSTW.
	FB_CSCR_BSTW = 0x8
	// Disabled. Data exceeding the specified port size is broken into individual, port-sized, non-burst writes. For example, a 32-bit write to an 8-bit port takes four byte writes.
	FB_CSCR_BSTW_0 = 0x0
	// Enabled. Enables burst write of data larger than the specified port size, including 32-bit writes to 8- and 16-bit ports, 16-bit writes to 8-bit ports, and line writes to 8-, 16-, and 32-bit ports.
	FB_CSCR_BSTW_1 = 0x1
	// Position of BSTR field.
	FB_CSCR_BSTR_Pos = 0x4
	// Bit mask of BSTR field.
	FB_CSCR_BSTR_Msk = 0x10
	// Bit BSTR.
	FB_CSCR_BSTR = 0x10
	// Disabled. Data exceeding the specified port size is broken into individual, port-sized, non-burst reads. For example, a 32-bit read from an 8-bit port is broken into four 8-bit reads.
	FB_CSCR_BSTR_0 = 0x0
	// Enabled. Enables data burst reads larger than the specified port size, including 32-bit reads from 8- and 16-bit ports, 16-bit reads from 8-bit ports, and line reads from 8-, 16-, and 32-bit ports.
	FB_CSCR_BSTR_1 = 0x1
	// Position of BEM field.
	FB_CSCR_BEM_Pos = 0x5
	// Bit mask of BEM field.
	FB_CSCR_BEM_Msk = 0x20
	// Bit BEM.
	FB_CSCR_BEM = 0x20
	// FB_BE is asserted for data write only.
	FB_CSCR_BEM_0 = 0x0
	// FB_BE is asserted for data read and write accesses.
	FB_CSCR_BEM_1 = 0x1
	// Position of PS field.
	FB_CSCR_PS_Pos = 0x6
	// Bit mask of PS field.
	FB_CSCR_PS_Msk = 0xc0
	// 32-bit port size. Valid data is sampled and driven on FB_D[31:0].
	FB_CSCR_PS_00 = 0x0
	// 8-bit port size. Valid data is sampled and driven on FB_D[31:24] when BLS is 0b, or FB_D[7:0] when BLS is 1b.
	FB_CSCR_PS_01 = 0x1
	// Position of AA field.
	FB_CSCR_AA_Pos = 0x8
	// Bit mask of AA field.
	FB_CSCR_AA_Msk = 0x100
	// Bit AA.
	FB_CSCR_AA = 0x100
	// Disabled. No internal transfer acknowledge is asserted and the cycle is terminated externally.
	FB_CSCR_AA_0 = 0x0
	// Enabled. Internal transfer acknowledge is asserted as specified by WS.
	FB_CSCR_AA_1 = 0x1
	// Position of BLS field.
	FB_CSCR_BLS_Pos = 0x9
	// Bit mask of BLS field.
	FB_CSCR_BLS_Msk = 0x200
	// Bit BLS.
	FB_CSCR_BLS = 0x200
	// Not shifted. Data is left-aligned on FB_AD.
	FB_CSCR_BLS_0 = 0x0
	// Shifted. Data is right-aligned on FB_AD.
	FB_CSCR_BLS_1 = 0x1
	// Position of WS field.
	FB_CSCR_WS_Pos = 0xa
	// Bit mask of WS field.
	FB_CSCR_WS_Msk = 0xfc00
	// Position of WRAH field.
	FB_CSCR_WRAH_Pos = 0x10
	// Bit mask of WRAH field.
	FB_CSCR_WRAH_Msk = 0x30000
	// 1 cycle (default for all but FB_CS0 )
	FB_CSCR_WRAH_00 = 0x0
	// 2 cycles
	FB_CSCR_WRAH_01 = 0x1
	// 3 cycles
	FB_CSCR_WRAH_10 = 0x2
	// 4 cycles (default for FB_CS0 )
	FB_CSCR_WRAH_11 = 0x3
	// Position of RDAH field.
	FB_CSCR_RDAH_Pos = 0x12
	// Bit mask of RDAH field.
	FB_CSCR_RDAH_Msk = 0xc0000
	// When AA is 0b, 1 cycle. When AA is 1b, 0 cycles.
	FB_CSCR_RDAH_00 = 0x0
	// When AA is 0b, 2 cycles. When AA is 1b, 1 cycle.
	FB_CSCR_RDAH_01 = 0x1
	// When AA is 0b, 3 cycles. When AA is 1b, 2 cycles.
	FB_CSCR_RDAH_10 = 0x2
	// When AA is 0b, 4 cycles. When AA is 1b, 3 cycles.
	FB_CSCR_RDAH_11 = 0x3
	// Position of ASET field.
	FB_CSCR_ASET_Pos = 0x14
	// Bit mask of ASET field.
	FB_CSCR_ASET_Msk = 0x300000
	// Assert FB_CSn on the first rising clock edge after the address is asserted (default for all but FB_CS0 ).
	FB_CSCR_ASET_00 = 0x0
	// Assert FB_CSn on the second rising clock edge after the address is asserted.
	FB_CSCR_ASET_01 = 0x1
	// Assert FB_CSn on the third rising clock edge after the address is asserted.
	FB_CSCR_ASET_10 = 0x2
	// Assert FB_CSn on the fourth rising clock edge after the address is asserted (default for FB_CS0 ).
	FB_CSCR_ASET_11 = 0x3
	// Position of EXTS field.
	FB_CSCR_EXTS_Pos = 0x16
	// Bit mask of EXTS field.
	FB_CSCR_EXTS_Msk = 0x400000
	// Bit EXTS.
	FB_CSCR_EXTS = 0x400000
	// Disabled. FB_TS /FB_ALE asserts for one bus clock cycle.
	FB_CSCR_EXTS_0 = 0x0
	// Enabled. FB_TS /FB_ALE remains asserted until the first positive clock edge after FB_CSn asserts.
	FB_CSCR_EXTS_1 = 0x1
	// Position of SWSEN field.
	FB_CSCR_SWSEN_Pos = 0x17
	// Bit mask of SWSEN field.
	FB_CSCR_SWSEN_Msk = 0x800000
	// Bit SWSEN.
	FB_CSCR_SWSEN = 0x800000
	// Disabled. A number of wait states (specified by WS) are inserted before an internal transfer acknowledge is generated for all transfers.
	FB_CSCR_SWSEN_0 = 0x0
	// Enabled. A number of wait states (specified by SWS) are inserted before an internal transfer acknowledge is generated for burst transfer secondary terminations.
	FB_CSCR_SWSEN_1 = 0x1
	// Position of SWS field.
	FB_CSCR_SWS_Pos = 0x1a
	// Bit mask of SWS field.
	FB_CSCR_SWS_Msk = 0xfc000000

	// CSPMCR: Chip Select port Multiplexing Control Register
	// Position of GROUP5 field.
	FB_CSPMCR_GROUP5_Pos = 0xc
	// Bit mask of GROUP5 field.
	FB_CSPMCR_GROUP5_Msk = 0xf000
	// FB_TA
	FB_CSPMCR_GROUP5_0000 = 0x0
	// FB_CS3 . You must also write 1b to CSCR[AA].
	FB_CSPMCR_GROUP5_0001 = 0x1
	// FB_BE_7_0 . You must also write 1b to CSCR[AA].
	FB_CSPMCR_GROUP5_0010 = 0x2
	// Position of GROUP4 field.
	FB_CSPMCR_GROUP4_Pos = 0x10
	// Bit mask of GROUP4 field.
	FB_CSPMCR_GROUP4_Msk = 0xf0000
	// FB_TBST
	FB_CSPMCR_GROUP4_0000 = 0x0
	// FB_CS2
	FB_CSPMCR_GROUP4_0001 = 0x1
	// FB_BE_15_8
	FB_CSPMCR_GROUP4_0010 = 0x2
	// Position of GROUP3 field.
	FB_CSPMCR_GROUP3_Pos = 0x14
	// Bit mask of GROUP3 field.
	FB_CSPMCR_GROUP3_Msk = 0xf00000
	// FB_CS5
	FB_CSPMCR_GROUP3_0000 = 0x0
	// FB_TSIZ1
	FB_CSPMCR_GROUP3_0001 = 0x1
	// FB_BE_23_16
	FB_CSPMCR_GROUP3_0010 = 0x2
	// Position of GROUP2 field.
	FB_CSPMCR_GROUP2_Pos = 0x18
	// Bit mask of GROUP2 field.
	FB_CSPMCR_GROUP2_Msk = 0xf000000
	// FB_CS4
	FB_CSPMCR_GROUP2_0000 = 0x0
	// FB_TSIZ0
	FB_CSPMCR_GROUP2_0001 = 0x1
	// FB_BE_31_24
	FB_CSPMCR_GROUP2_0010 = 0x2
	// Position of GROUP1 field.
	FB_CSPMCR_GROUP1_Pos = 0x1c
	// Bit mask of GROUP1 field.
	FB_CSPMCR_GROUP1_Msk = 0xf0000000
	// FB_ALE
	FB_CSPMCR_GROUP1_0000 = 0x0
	// FB_CS1
	FB_CSPMCR_GROUP1_0001 = 0x1
	// FB_TS
	FB_CSPMCR_GROUP1_0010 = 0x2
)

// Constants for SYSMPU: Memory protection unit
const (
	// CESR: Control/Error Status Register
	// Position of VLD field.
	SYSMPU_CESR_VLD_Pos = 0x0
	// Bit mask of VLD field.
	SYSMPU_CESR_VLD_Msk = 0x1
	// Bit VLD.
	SYSMPU_CESR_VLD = 0x1
	// MPU is disabled. All accesses from all bus masters are allowed.
	SYSMPU_CESR_VLD_0 = 0x0
	// MPU is enabled
	SYSMPU_CESR_VLD_1 = 0x1
	// Position of NRGD field.
	SYSMPU_CESR_NRGD_Pos = 0x8
	// Bit mask of NRGD field.
	SYSMPU_CESR_NRGD_Msk = 0xf00
	// 8 region descriptors
	SYSMPU_CESR_NRGD_0000 = 0x0
	// 12 region descriptors
	SYSMPU_CESR_NRGD_0001 = 0x1
	// 16 region descriptors
	SYSMPU_CESR_NRGD_0010 = 0x2
	// Position of NSP field.
	SYSMPU_CESR_NSP_Pos = 0xc
	// Bit mask of NSP field.
	SYSMPU_CESR_NSP_Msk = 0xf000
	// Position of HRL field.
	SYSMPU_CESR_HRL_Pos = 0x10
	// Bit mask of HRL field.
	SYSMPU_CESR_HRL_Msk = 0xf0000
	// Position of SPERR field.
	SYSMPU_CESR_SPERR_Pos = 0x1b
	// Bit mask of SPERR field.
	SYSMPU_CESR_SPERR_Msk = 0xf8000000
	// No error has occurred for slave port n.
	SYSMPU_CESR_SPERR_0 = 0x0
	// An error has occurred for slave port n.
	SYSMPU_CESR_SPERR_1 = 0x1

	// EAR0: Error Address Register, slave port n
	// Position of EADDR field.
	SYSMPU_EAR_EADDR_Pos = 0x0
	// Bit mask of EADDR field.
	SYSMPU_EAR_EADDR_Msk = 0xffffffff

	// EDR0: Error Detail Register, slave port n
	// Position of ERW field.
	SYSMPU_EDR_ERW_Pos = 0x0
	// Bit mask of ERW field.
	SYSMPU_EDR_ERW_Msk = 0x1
	// Bit ERW.
	SYSMPU_EDR_ERW = 0x1
	// Read
	SYSMPU_EDR_ERW_0 = 0x0
	// Write
	SYSMPU_EDR_ERW_1 = 0x1
	// Position of EATTR field.
	SYSMPU_EDR_EATTR_Pos = 0x1
	// Bit mask of EATTR field.
	SYSMPU_EDR_EATTR_Msk = 0xe
	// User mode, instruction access
	SYSMPU_EDR_EATTR_000 = 0x0
	// User mode, data access
	SYSMPU_EDR_EATTR_001 = 0x1
	// Supervisor mode, instruction access
	SYSMPU_EDR_EATTR_010 = 0x2
	// Supervisor mode, data access
	SYSMPU_EDR_EATTR_011 = 0x3
	// Position of EMN field.
	SYSMPU_EDR_EMN_Pos = 0x4
	// Bit mask of EMN field.
	SYSMPU_EDR_EMN_Msk = 0xf0
	// Position of EPID field.
	SYSMPU_EDR_EPID_Pos = 0x8
	// Bit mask of EPID field.
	SYSMPU_EDR_EPID_Msk = 0xff00
	// Position of EACD field.
	SYSMPU_EDR_EACD_Pos = 0x10
	// Bit mask of EACD field.
	SYSMPU_EDR_EACD_Msk = 0xffff0000

	// RGD0_WORD0: Region Descriptor n, Word 0
	// Position of SRTADDR field.
	SYSMPU_RGD_WORD0_SRTADDR_Pos = 0x5
	// Bit mask of SRTADDR field.
	SYSMPU_RGD_WORD0_SRTADDR_Msk = 0xffffffe0

	// RGD0_WORD1: Region Descriptor n, Word 1
	// Position of ENDADDR field.
	SYSMPU_RGD_WORD1_ENDADDR_Pos = 0x5
	// Bit mask of ENDADDR field.
	SYSMPU_RGD_WORD1_ENDADDR_Msk = 0xffffffe0

	// RGD0_WORD2: Region Descriptor n, Word 2
	// Position of M0UM field.
	SYSMPU_RGD_WORD2_M0UM_Pos = 0x0
	// Bit mask of M0UM field.
	SYSMPU_RGD_WORD2_M0UM_Msk = 0x7
	// Position of M0SM field.
	SYSMPU_RGD_WORD2_M0SM_Pos = 0x3
	// Bit mask of M0SM field.
	SYSMPU_RGD_WORD2_M0SM_Msk = 0x18
	// Position of M0PE field.
	SYSMPU_RGD_WORD2_M0PE_Pos = 0x5
	// Bit mask of M0PE field.
	SYSMPU_RGD_WORD2_M0PE_Msk = 0x20
	// Bit M0PE.
	SYSMPU_RGD_WORD2_M0PE = 0x20
	// Position of M1UM field.
	SYSMPU_RGD_WORD2_M1UM_Pos = 0x6
	// Bit mask of M1UM field.
	SYSMPU_RGD_WORD2_M1UM_Msk = 0x1c0
	// Position of M1SM field.
	SYSMPU_RGD_WORD2_M1SM_Pos = 0x9
	// Bit mask of M1SM field.
	SYSMPU_RGD_WORD2_M1SM_Msk = 0x600
	// Position of M1PE field.
	SYSMPU_RGD_WORD2_M1PE_Pos = 0xb
	// Bit mask of M1PE field.
	SYSMPU_RGD_WORD2_M1PE_Msk = 0x800
	// Bit M1PE.
	SYSMPU_RGD_WORD2_M1PE = 0x800
	// Position of M2UM field.
	SYSMPU_RGD_WORD2_M2UM_Pos = 0xc
	// Bit mask of M2UM field.
	SYSMPU_RGD_WORD2_M2UM_Msk = 0x7000
	// Position of M2SM field.
	SYSMPU_RGD_WORD2_M2SM_Pos = 0xf
	// Bit mask of M2SM field.
	SYSMPU_RGD_WORD2_M2SM_Msk = 0x18000
	// Position of M2PE field.
	SYSMPU_RGD_WORD2_M2PE_Pos = 0x11
	// Bit mask of M2PE field.
	SYSMPU_RGD_WORD2_M2PE_Msk = 0x20000
	// Bit M2PE.
	SYSMPU_RGD_WORD2_M2PE = 0x20000
	// Position of M3UM field.
	SYSMPU_RGD_WORD2_M3UM_Pos = 0x12
	// Bit mask of M3UM field.
	SYSMPU_RGD_WORD2_M3UM_Msk = 0x1c0000
	// An attempted access of that mode may be terminated with an access error (if not allowed by another descriptor) and the access not performed.
	SYSMPU_RGD_WORD2_M3UM_0 = 0x0
	// Allows the given access type to occur
	SYSMPU_RGD_WORD2_M3UM_1 = 0x1
	// Position of M3SM field.
	SYSMPU_RGD_WORD2_M3SM_Pos = 0x15
	// Bit mask of M3SM field.
	SYSMPU_RGD_WORD2_M3SM_Msk = 0x600000
	// r/w/x; read, write and execute allowed
	SYSMPU_RGD_WORD2_M3SM_00 = 0x0
	// r/x; read and execute allowed, but no write
	SYSMPU_RGD_WORD2_M3SM_01 = 0x1
	// r/w; read and write allowed, but no execute
	SYSMPU_RGD_WORD2_M3SM_10 = 0x2
	// Same as User mode defined in M3UM
	SYSMPU_RGD_WORD2_M3SM_11 = 0x3
	// Position of M3PE field.
	SYSMPU_RGD_WORD2_M3PE_Pos = 0x17
	// Bit mask of M3PE field.
	SYSMPU_RGD_WORD2_M3PE_Msk = 0x800000
	// Bit M3PE.
	SYSMPU_RGD_WORD2_M3PE = 0x800000
	// Do not include the process identifier in the evaluation
	SYSMPU_RGD_WORD2_M3PE_0 = 0x0
	// Include the process identifier and mask (RGDn_WORD3) in the region hit evaluation
	SYSMPU_RGD_WORD2_M3PE_1 = 0x1
	// Position of M4WE field.
	SYSMPU_RGD_WORD2_M4WE_Pos = 0x18
	// Bit mask of M4WE field.
	SYSMPU_RGD_WORD2_M4WE_Msk = 0x1000000
	// Bit M4WE.
	SYSMPU_RGD_WORD2_M4WE = 0x1000000
	// Bus master 4 writes terminate with an access error and the write is not performed
	SYSMPU_RGD_WORD2_M4WE_0 = 0x0
	// Bus master 4 writes allowed
	SYSMPU_RGD_WORD2_M4WE_1 = 0x1
	// Position of M4RE field.
	SYSMPU_RGD_WORD2_M4RE_Pos = 0x19
	// Bit mask of M4RE field.
	SYSMPU_RGD_WORD2_M4RE_Msk = 0x2000000
	// Bit M4RE.
	SYSMPU_RGD_WORD2_M4RE = 0x2000000
	// Bus master 4 reads terminate with an access error and the read is not performed
	SYSMPU_RGD_WORD2_M4RE_0 = 0x0
	// Bus master 4 reads allowed
	SYSMPU_RGD_WORD2_M4RE_1 = 0x1
	// Position of M5WE field.
	SYSMPU_RGD_WORD2_M5WE_Pos = 0x1a
	// Bit mask of M5WE field.
	SYSMPU_RGD_WORD2_M5WE_Msk = 0x4000000
	// Bit M5WE.
	SYSMPU_RGD_WORD2_M5WE = 0x4000000
	// Bus master 5 writes terminate with an access error and the write is not performed
	SYSMPU_RGD_WORD2_M5WE_0 = 0x0
	// Bus master 5 writes allowed
	SYSMPU_RGD_WORD2_M5WE_1 = 0x1
	// Position of M5RE field.
	SYSMPU_RGD_WORD2_M5RE_Pos = 0x1b
	// Bit mask of M5RE field.
	SYSMPU_RGD_WORD2_M5RE_Msk = 0x8000000
	// Bit M5RE.
	SYSMPU_RGD_WORD2_M5RE = 0x8000000
	// Bus master 5 reads terminate with an access error and the read is not performed
	SYSMPU_RGD_WORD2_M5RE_0 = 0x0
	// Bus master 5 reads allowed
	SYSMPU_RGD_WORD2_M5RE_1 = 0x1
	// Position of M6WE field.
	SYSMPU_RGD_WORD2_M6WE_Pos = 0x1c
	// Bit mask of M6WE field.
	SYSMPU_RGD_WORD2_M6WE_Msk = 0x10000000
	// Bit M6WE.
	SYSMPU_RGD_WORD2_M6WE = 0x10000000
	// Bus master 6 writes terminate with an access error and the write is not performed
	SYSMPU_RGD_WORD2_M6WE_0 = 0x0
	// Bus master 6 writes allowed
	SYSMPU_RGD_WORD2_M6WE_1 = 0x1
	// Position of M6RE field.
	SYSMPU_RGD_WORD2_M6RE_Pos = 0x1d
	// Bit mask of M6RE field.
	SYSMPU_RGD_WORD2_M6RE_Msk = 0x20000000
	// Bit M6RE.
	SYSMPU_RGD_WORD2_M6RE = 0x20000000
	// Bus master 6 reads terminate with an access error and the read is not performed
	SYSMPU_RGD_WORD2_M6RE_0 = 0x0
	// Bus master 6 reads allowed
	SYSMPU_RGD_WORD2_M6RE_1 = 0x1
	// Position of M7WE field.
	SYSMPU_RGD_WORD2_M7WE_Pos = 0x1e
	// Bit mask of M7WE field.
	SYSMPU_RGD_WORD2_M7WE_Msk = 0x40000000
	// Bit M7WE.
	SYSMPU_RGD_WORD2_M7WE = 0x40000000
	// Bus master 7 writes terminate with an access error and the write is not performed
	SYSMPU_RGD_WORD2_M7WE_0 = 0x0
	// Bus master 7 writes allowed
	SYSMPU_RGD_WORD2_M7WE_1 = 0x1
	// Position of M7RE field.
	SYSMPU_RGD_WORD2_M7RE_Pos = 0x1f
	// Bit mask of M7RE field.
	SYSMPU_RGD_WORD2_M7RE_Msk = 0x80000000
	// Bit M7RE.
	SYSMPU_RGD_WORD2_M7RE = 0x80000000
	// Bus master 7 reads terminate with an access error and the read is not performed
	SYSMPU_RGD_WORD2_M7RE_0 = 0x0
	// Bus master 7 reads allowed
	SYSMPU_RGD_WORD2_M7RE_1 = 0x1

	// RGD0_WORD3: Region Descriptor n, Word 3
	// Position of VLD field.
	SYSMPU_RGD_WORD3_VLD_Pos = 0x0
	// Bit mask of VLD field.
	SYSMPU_RGD_WORD3_VLD_Msk = 0x1
	// Bit VLD.
	SYSMPU_RGD_WORD3_VLD = 0x1
	// Region descriptor is invalid
	SYSMPU_RGD_WORD3_VLD_0 = 0x0
	// Region descriptor is valid
	SYSMPU_RGD_WORD3_VLD_1 = 0x1
	// Position of PIDMASK field.
	SYSMPU_RGD_WORD3_PIDMASK_Pos = 0x10
	// Bit mask of PIDMASK field.
	SYSMPU_RGD_WORD3_PIDMASK_Msk = 0xff0000
	// Position of PID field.
	SYSMPU_RGD_WORD3_PID_Pos = 0x18
	// Bit mask of PID field.
	SYSMPU_RGD_WORD3_PID_Msk = 0xff000000

	// RGDAAC0: Region Descriptor Alternate Access Control n
	// Position of M0UM field.
	SYSMPU_RGDAAC_M0UM_Pos = 0x0
	// Bit mask of M0UM field.
	SYSMPU_RGDAAC_M0UM_Msk = 0x7
	// Position of M0SM field.
	SYSMPU_RGDAAC_M0SM_Pos = 0x3
	// Bit mask of M0SM field.
	SYSMPU_RGDAAC_M0SM_Msk = 0x18
	// Position of M0PE field.
	SYSMPU_RGDAAC_M0PE_Pos = 0x5
	// Bit mask of M0PE field.
	SYSMPU_RGDAAC_M0PE_Msk = 0x20
	// Bit M0PE.
	SYSMPU_RGDAAC_M0PE = 0x20
	// Position of M1UM field.
	SYSMPU_RGDAAC_M1UM_Pos = 0x6
	// Bit mask of M1UM field.
	SYSMPU_RGDAAC_M1UM_Msk = 0x1c0
	// Position of M1SM field.
	SYSMPU_RGDAAC_M1SM_Pos = 0x9
	// Bit mask of M1SM field.
	SYSMPU_RGDAAC_M1SM_Msk = 0x600
	// Position of M1PE field.
	SYSMPU_RGDAAC_M1PE_Pos = 0xb
	// Bit mask of M1PE field.
	SYSMPU_RGDAAC_M1PE_Msk = 0x800
	// Bit M1PE.
	SYSMPU_RGDAAC_M1PE = 0x800
	// Position of M2UM field.
	SYSMPU_RGDAAC_M2UM_Pos = 0xc
	// Bit mask of M2UM field.
	SYSMPU_RGDAAC_M2UM_Msk = 0x7000
	// Position of M2SM field.
	SYSMPU_RGDAAC_M2SM_Pos = 0xf
	// Bit mask of M2SM field.
	SYSMPU_RGDAAC_M2SM_Msk = 0x18000
	// Position of M2PE field.
	SYSMPU_RGDAAC_M2PE_Pos = 0x11
	// Bit mask of M2PE field.
	SYSMPU_RGDAAC_M2PE_Msk = 0x20000
	// Bit M2PE.
	SYSMPU_RGDAAC_M2PE = 0x20000
	// Position of M3UM field.
	SYSMPU_RGDAAC_M3UM_Pos = 0x12
	// Bit mask of M3UM field.
	SYSMPU_RGDAAC_M3UM_Msk = 0x1c0000
	// An attempted access of that mode may be terminated with an access error (if not allowed by another descriptor) and the access not performed.
	SYSMPU_RGDAAC_M3UM_0 = 0x0
	// Allows the given access type to occur
	SYSMPU_RGDAAC_M3UM_1 = 0x1
	// Position of M3SM field.
	SYSMPU_RGDAAC_M3SM_Pos = 0x15
	// Bit mask of M3SM field.
	SYSMPU_RGDAAC_M3SM_Msk = 0x600000
	// r/w/x; read, write and execute allowed
	SYSMPU_RGDAAC_M3SM_00 = 0x0
	// r/x; read and execute allowed, but no write
	SYSMPU_RGDAAC_M3SM_01 = 0x1
	// r/w; read and write allowed, but no execute
	SYSMPU_RGDAAC_M3SM_10 = 0x2
	// Same as User mode defined in M3UM
	SYSMPU_RGDAAC_M3SM_11 = 0x3
	// Position of M3PE field.
	SYSMPU_RGDAAC_M3PE_Pos = 0x17
	// Bit mask of M3PE field.
	SYSMPU_RGDAAC_M3PE_Msk = 0x800000
	// Bit M3PE.
	SYSMPU_RGDAAC_M3PE = 0x800000
	// Do not include the process identifier in the evaluation
	SYSMPU_RGDAAC_M3PE_0 = 0x0
	// Include the process identifier and mask (RGDn.RGDAAC) in the region hit evaluation
	SYSMPU_RGDAAC_M3PE_1 = 0x1
	// Position of M4WE field.
	SYSMPU_RGDAAC_M4WE_Pos = 0x18
	// Bit mask of M4WE field.
	SYSMPU_RGDAAC_M4WE_Msk = 0x1000000
	// Bit M4WE.
	SYSMPU_RGDAAC_M4WE = 0x1000000
	// Bus master 4 writes terminate with an access error and the write is not performed
	SYSMPU_RGDAAC_M4WE_0 = 0x0
	// Bus master 4 writes allowed
	SYSMPU_RGDAAC_M4WE_1 = 0x1
	// Position of M4RE field.
	SYSMPU_RGDAAC_M4RE_Pos = 0x19
	// Bit mask of M4RE field.
	SYSMPU_RGDAAC_M4RE_Msk = 0x2000000
	// Bit M4RE.
	SYSMPU_RGDAAC_M4RE = 0x2000000
	// Bus master 4 reads terminate with an access error and the read is not performed
	SYSMPU_RGDAAC_M4RE_0 = 0x0
	// Bus master 4 reads allowed
	SYSMPU_RGDAAC_M4RE_1 = 0x1
	// Position of M5WE field.
	SYSMPU_RGDAAC_M5WE_Pos = 0x1a
	// Bit mask of M5WE field.
	SYSMPU_RGDAAC_M5WE_Msk = 0x4000000
	// Bit M5WE.
	SYSMPU_RGDAAC_M5WE = 0x4000000
	// Bus master 5 writes terminate with an access error and the write is not performed
	SYSMPU_RGDAAC_M5WE_0 = 0x0
	// Bus master 5 writes allowed
	SYSMPU_RGDAAC_M5WE_1 = 0x1
	// Position of M5RE field.
	SYSMPU_RGDAAC_M5RE_Pos = 0x1b
	// Bit mask of M5RE field.
	SYSMPU_RGDAAC_M5RE_Msk = 0x8000000
	// Bit M5RE.
	SYSMPU_RGDAAC_M5RE = 0x8000000
	// Bus master 5 reads terminate with an access error and the read is not performed
	SYSMPU_RGDAAC_M5RE_0 = 0x0
	// Bus master 5 reads allowed
	SYSMPU_RGDAAC_M5RE_1 = 0x1
	// Position of M6WE field.
	SYSMPU_RGDAAC_M6WE_Pos = 0x1c
	// Bit mask of M6WE field.
	SYSMPU_RGDAAC_M6WE_Msk = 0x10000000
	// Bit M6WE.
	SYSMPU_RGDAAC_M6WE = 0x10000000
	// Bus master 6 writes terminate with an access error and the write is not performed
	SYSMPU_RGDAAC_M6WE_0 = 0x0
	// Bus master 6 writes allowed
	SYSMPU_RGDAAC_M6WE_1 = 0x1
	// Position of M6RE field.
	SYSMPU_RGDAAC_M6RE_Pos = 0x1d
	// Bit mask of M6RE field.
	SYSMPU_RGDAAC_M6RE_Msk = 0x20000000
	// Bit M6RE.
	SYSMPU_RGDAAC_M6RE = 0x20000000
	// Bus master 6 reads terminate with an access error and the read is not performed
	SYSMPU_RGDAAC_M6RE_0 = 0x0
	// Bus master 6 reads allowed
	SYSMPU_RGDAAC_M6RE_1 = 0x1
	// Position of M7WE field.
	SYSMPU_RGDAAC_M7WE_Pos = 0x1e
	// Bit mask of M7WE field.
	SYSMPU_RGDAAC_M7WE_Msk = 0x40000000
	// Bit M7WE.
	SYSMPU_RGDAAC_M7WE = 0x40000000
	// Bus master 7 writes terminate with an access error and the write is not performed
	SYSMPU_RGDAAC_M7WE_0 = 0x0
	// Bus master 7 writes allowed
	SYSMPU_RGDAAC_M7WE_1 = 0x1
	// Position of M7RE field.
	SYSMPU_RGDAAC_M7RE_Pos = 0x1f
	// Bit mask of M7RE field.
	SYSMPU_RGDAAC_M7RE_Msk = 0x80000000
	// Bit M7RE.
	SYSMPU_RGDAAC_M7RE = 0x80000000
	// Bus master 7 reads terminate with an access error and the read is not performed
	SYSMPU_RGDAAC_M7RE_0 = 0x0
	// Bus master 7 reads allowed
	SYSMPU_RGDAAC_M7RE_1 = 0x1
)

// Constants for FMC: Flash Memory Controller
const (
	// PFAPR: Flash Access Protection Register
	// Position of M0AP field.
	FMC_PFAPR_M0AP_Pos = 0x0
	// Bit mask of M0AP field.
	FMC_PFAPR_M0AP_Msk = 0x3
	// No access may be performed by this master
	FMC_PFAPR_M0AP_00 = 0x0
	// Only read accesses may be performed by this master
	FMC_PFAPR_M0AP_01 = 0x1
	// Only write accesses may be performed by this master
	FMC_PFAPR_M0AP_10 = 0x2
	// Both read and write accesses may be performed by this master
	FMC_PFAPR_M0AP_11 = 0x3
	// Position of M1AP field.
	FMC_PFAPR_M1AP_Pos = 0x2
	// Bit mask of M1AP field.
	FMC_PFAPR_M1AP_Msk = 0xc
	// No access may be performed by this master
	FMC_PFAPR_M1AP_00 = 0x0
	// Only read accesses may be performed by this master
	FMC_PFAPR_M1AP_01 = 0x1
	// Only write accesses may be performed by this master
	FMC_PFAPR_M1AP_10 = 0x2
	// Both read and write accesses may be performed by this master
	FMC_PFAPR_M1AP_11 = 0x3
	// Position of M2AP field.
	FMC_PFAPR_M2AP_Pos = 0x4
	// Bit mask of M2AP field.
	FMC_PFAPR_M2AP_Msk = 0x30
	// No access may be performed by this master
	FMC_PFAPR_M2AP_00 = 0x0
	// Only read accesses may be performed by this master
	FMC_PFAPR_M2AP_01 = 0x1
	// Only write accesses may be performed by this master
	FMC_PFAPR_M2AP_10 = 0x2
	// Both read and write accesses may be performed by this master
	FMC_PFAPR_M2AP_11 = 0x3
	// Position of M3AP field.
	FMC_PFAPR_M3AP_Pos = 0x6
	// Bit mask of M3AP field.
	FMC_PFAPR_M3AP_Msk = 0xc0
	// No access may be performed by this master
	FMC_PFAPR_M3AP_00 = 0x0
	// Only read accesses may be performed by this master
	FMC_PFAPR_M3AP_01 = 0x1
	// Only write accesses may be performed by this master
	FMC_PFAPR_M3AP_10 = 0x2
	// Both read and write accesses may be performed by this master
	FMC_PFAPR_M3AP_11 = 0x3
	// Position of M4AP field.
	FMC_PFAPR_M4AP_Pos = 0x8
	// Bit mask of M4AP field.
	FMC_PFAPR_M4AP_Msk = 0x300
	// No access may be performed by this master
	FMC_PFAPR_M4AP_00 = 0x0
	// Only read accesses may be performed by this master
	FMC_PFAPR_M4AP_01 = 0x1
	// Only write accesses may be performed by this master
	FMC_PFAPR_M4AP_10 = 0x2
	// Both read and write accesses may be performed by this master
	FMC_PFAPR_M4AP_11 = 0x3
	// Position of M5AP field.
	FMC_PFAPR_M5AP_Pos = 0xa
	// Bit mask of M5AP field.
	FMC_PFAPR_M5AP_Msk = 0xc00
	// No access may be performed by this master
	FMC_PFAPR_M5AP_00 = 0x0
	// Only read accesses may be performed by this master
	FMC_PFAPR_M5AP_01 = 0x1
	// Only write accesses may be performed by this master
	FMC_PFAPR_M5AP_10 = 0x2
	// Both read and write accesses may be performed by this master
	FMC_PFAPR_M5AP_11 = 0x3
	// Position of M6AP field.
	FMC_PFAPR_M6AP_Pos = 0xc
	// Bit mask of M6AP field.
	FMC_PFAPR_M6AP_Msk = 0x3000
	// No access may be performed by this master
	FMC_PFAPR_M6AP_00 = 0x0
	// Only read accesses may be performed by this master
	FMC_PFAPR_M6AP_01 = 0x1
	// Only write accesses may be performed by this master
	FMC_PFAPR_M6AP_10 = 0x2
	// Both read and write accesses may be performed by this master
	FMC_PFAPR_M6AP_11 = 0x3
	// Position of M7AP field.
	FMC_PFAPR_M7AP_Pos = 0xe
	// Bit mask of M7AP field.
	FMC_PFAPR_M7AP_Msk = 0xc000
	// No access may be performed by this master.
	FMC_PFAPR_M7AP_00 = 0x0
	// Only read accesses may be performed by this master.
	FMC_PFAPR_M7AP_01 = 0x1
	// Only write accesses may be performed by this master.
	FMC_PFAPR_M7AP_10 = 0x2
	// Both read and write accesses may be performed by this master.
	FMC_PFAPR_M7AP_11 = 0x3
	// Position of M0PFD field.
	FMC_PFAPR_M0PFD_Pos = 0x10
	// Bit mask of M0PFD field.
	FMC_PFAPR_M0PFD_Msk = 0x10000
	// Bit M0PFD.
	FMC_PFAPR_M0PFD = 0x10000
	// Prefetching for this master is enabled.
	FMC_PFAPR_M0PFD_0 = 0x0
	// Prefetching for this master is disabled.
	FMC_PFAPR_M0PFD_1 = 0x1
	// Position of M1PFD field.
	FMC_PFAPR_M1PFD_Pos = 0x11
	// Bit mask of M1PFD field.
	FMC_PFAPR_M1PFD_Msk = 0x20000
	// Bit M1PFD.
	FMC_PFAPR_M1PFD = 0x20000
	// Prefetching for this master is enabled.
	FMC_PFAPR_M1PFD_0 = 0x0
	// Prefetching for this master is disabled.
	FMC_PFAPR_M1PFD_1 = 0x1
	// Position of M2PFD field.
	FMC_PFAPR_M2PFD_Pos = 0x12
	// Bit mask of M2PFD field.
	FMC_PFAPR_M2PFD_Msk = 0x40000
	// Bit M2PFD.
	FMC_PFAPR_M2PFD = 0x40000
	// Prefetching for this master is enabled.
	FMC_PFAPR_M2PFD_0 = 0x0
	// Prefetching for this master is disabled.
	FMC_PFAPR_M2PFD_1 = 0x1
	// Position of M3PFD field.
	FMC_PFAPR_M3PFD_Pos = 0x13
	// Bit mask of M3PFD field.
	FMC_PFAPR_M3PFD_Msk = 0x80000
	// Bit M3PFD.
	FMC_PFAPR_M3PFD = 0x80000
	// Prefetching for this master is enabled.
	FMC_PFAPR_M3PFD_0 = 0x0
	// Prefetching for this master is disabled.
	FMC_PFAPR_M3PFD_1 = 0x1
	// Position of M4PFD field.
	FMC_PFAPR_M4PFD_Pos = 0x14
	// Bit mask of M4PFD field.
	FMC_PFAPR_M4PFD_Msk = 0x100000
	// Bit M4PFD.
	FMC_PFAPR_M4PFD = 0x100000
	// Prefetching for this master is enabled.
	FMC_PFAPR_M4PFD_0 = 0x0
	// Prefetching for this master is disabled.
	FMC_PFAPR_M4PFD_1 = 0x1
	// Position of M5PFD field.
	FMC_PFAPR_M5PFD_Pos = 0x15
	// Bit mask of M5PFD field.
	FMC_PFAPR_M5PFD_Msk = 0x200000
	// Bit M5PFD.
	FMC_PFAPR_M5PFD = 0x200000
	// Prefetching for this master is enabled.
	FMC_PFAPR_M5PFD_0 = 0x0
	// Prefetching for this master is disabled.
	FMC_PFAPR_M5PFD_1 = 0x1
	// Position of M6PFD field.
	FMC_PFAPR_M6PFD_Pos = 0x16
	// Bit mask of M6PFD field.
	FMC_PFAPR_M6PFD_Msk = 0x400000
	// Bit M6PFD.
	FMC_PFAPR_M6PFD = 0x400000
	// Prefetching for this master is enabled.
	FMC_PFAPR_M6PFD_0 = 0x0
	// Prefetching for this master is disabled.
	FMC_PFAPR_M6PFD_1 = 0x1
	// Position of M7PFD field.
	FMC_PFAPR_M7PFD_Pos = 0x17
	// Bit mask of M7PFD field.
	FMC_PFAPR_M7PFD_Msk = 0x800000
	// Bit M7PFD.
	FMC_PFAPR_M7PFD = 0x800000
	// Prefetching for this master is enabled.
	FMC_PFAPR_M7PFD_0 = 0x0
	// Prefetching for this master is disabled.
	FMC_PFAPR_M7PFD_1 = 0x1

	// PFB0CR: Flash Bank 0 Control Register
	// Position of B0SEBE field.
	FMC_PFB0CR_B0SEBE_Pos = 0x0
	// Bit mask of B0SEBE field.
	FMC_PFB0CR_B0SEBE_Msk = 0x1
	// Bit B0SEBE.
	FMC_PFB0CR_B0SEBE = 0x1
	// Single entry buffer is disabled.
	FMC_PFB0CR_B0SEBE_0 = 0x0
	// Single entry buffer is enabled.
	FMC_PFB0CR_B0SEBE_1 = 0x1
	// Position of B0IPE field.
	FMC_PFB0CR_B0IPE_Pos = 0x1
	// Bit mask of B0IPE field.
	FMC_PFB0CR_B0IPE_Msk = 0x2
	// Bit B0IPE.
	FMC_PFB0CR_B0IPE = 0x2
	// Do not prefetch in response to instruction fetches.
	FMC_PFB0CR_B0IPE_0 = 0x0
	// Enable prefetches in response to instruction fetches.
	FMC_PFB0CR_B0IPE_1 = 0x1
	// Position of B0DPE field.
	FMC_PFB0CR_B0DPE_Pos = 0x2
	// Bit mask of B0DPE field.
	FMC_PFB0CR_B0DPE_Msk = 0x4
	// Bit B0DPE.
	FMC_PFB0CR_B0DPE = 0x4
	// Do not prefetch in response to data references.
	FMC_PFB0CR_B0DPE_0 = 0x0
	// Enable prefetches in response to data references.
	FMC_PFB0CR_B0DPE_1 = 0x1
	// Position of B0ICE field.
	FMC_PFB0CR_B0ICE_Pos = 0x3
	// Bit mask of B0ICE field.
	FMC_PFB0CR_B0ICE_Msk = 0x8
	// Bit B0ICE.
	FMC_PFB0CR_B0ICE = 0x8
	// Do not cache instruction fetches.
	FMC_PFB0CR_B0ICE_0 = 0x0
	// Cache instruction fetches.
	FMC_PFB0CR_B0ICE_1 = 0x1
	// Position of B0DCE field.
	FMC_PFB0CR_B0DCE_Pos = 0x4
	// Bit mask of B0DCE field.
	FMC_PFB0CR_B0DCE_Msk = 0x10
	// Bit B0DCE.
	FMC_PFB0CR_B0DCE = 0x10
	// Do not cache data references.
	FMC_PFB0CR_B0DCE_0 = 0x0
	// Cache data references.
	FMC_PFB0CR_B0DCE_1 = 0x1
	// Position of CRC field.
	FMC_PFB0CR_CRC_Pos = 0x5
	// Bit mask of CRC field.
	FMC_PFB0CR_CRC_Msk = 0xe0
	// LRU replacement algorithm per set across all four ways
	FMC_PFB0CR_CRC_000 = 0x0
	// Independent LRU with ways [0-1] for ifetches, [2-3] for data
	FMC_PFB0CR_CRC_010 = 0x2
	// Independent LRU with ways [0-2] for ifetches, [3] for data
	FMC_PFB0CR_CRC_011 = 0x3
	// Position of B0MW field.
	FMC_PFB0CR_B0MW_Pos = 0x11
	// Bit mask of B0MW field.
	FMC_PFB0CR_B0MW_Msk = 0x60000
	// 32 bits
	FMC_PFB0CR_B0MW_00 = 0x0
	// 64 bits
	FMC_PFB0CR_B0MW_01 = 0x1
	// 128 bits
	FMC_PFB0CR_B0MW_10 = 0x2
	// Position of S_B_INV field.
	FMC_PFB0CR_S_B_INV_Pos = 0x13
	// Bit mask of S_B_INV field.
	FMC_PFB0CR_S_B_INV_Msk = 0x80000
	// Bit S_B_INV.
	FMC_PFB0CR_S_B_INV = 0x80000
	// Speculation buffer and single entry buffer are not affected.
	FMC_PFB0CR_S_B_INV_0 = 0x0
	// Invalidate (clear) speculation buffer and single entry buffer.
	FMC_PFB0CR_S_B_INV_1 = 0x1
	// Position of CINV_WAY field.
	FMC_PFB0CR_CINV_WAY_Pos = 0x14
	// Bit mask of CINV_WAY field.
	FMC_PFB0CR_CINV_WAY_Msk = 0xf00000
	// No cache way invalidation for the corresponding cache
	FMC_PFB0CR_CINV_WAY_0 = 0x0
	// Invalidate cache way for the corresponding cache: clear the tag, data, and vld bits of ways selected
	FMC_PFB0CR_CINV_WAY_1 = 0x1
	// Position of CLCK_WAY field.
	FMC_PFB0CR_CLCK_WAY_Pos = 0x18
	// Bit mask of CLCK_WAY field.
	FMC_PFB0CR_CLCK_WAY_Msk = 0xf000000
	// Cache way is unlocked and may be displaced
	FMC_PFB0CR_CLCK_WAY_0 = 0x0
	// Cache way is locked and its contents are not displaced
	FMC_PFB0CR_CLCK_WAY_1 = 0x1
	// Position of B0RWSC field.
	FMC_PFB0CR_B0RWSC_Pos = 0x1c
	// Bit mask of B0RWSC field.
	FMC_PFB0CR_B0RWSC_Msk = 0xf0000000

	// PFB1CR: Flash Bank 1 Control Register
	// Position of B1SEBE field.
	FMC_PFB1CR_B1SEBE_Pos = 0x0
	// Bit mask of B1SEBE field.
	FMC_PFB1CR_B1SEBE_Msk = 0x1
	// Bit B1SEBE.
	FMC_PFB1CR_B1SEBE = 0x1
	// Single entry buffer is disabled.
	FMC_PFB1CR_B1SEBE_0 = 0x0
	// Single entry buffer is enabled.
	FMC_PFB1CR_B1SEBE_1 = 0x1
	// Position of B1IPE field.
	FMC_PFB1CR_B1IPE_Pos = 0x1
	// Bit mask of B1IPE field.
	FMC_PFB1CR_B1IPE_Msk = 0x2
	// Bit B1IPE.
	FMC_PFB1CR_B1IPE = 0x2
	// Do not prefetch in response to instruction fetches.
	FMC_PFB1CR_B1IPE_0 = 0x0
	// Enable prefetches in response to instruction fetches.
	FMC_PFB1CR_B1IPE_1 = 0x1
	// Position of B1DPE field.
	FMC_PFB1CR_B1DPE_Pos = 0x2
	// Bit mask of B1DPE field.
	FMC_PFB1CR_B1DPE_Msk = 0x4
	// Bit B1DPE.
	FMC_PFB1CR_B1DPE = 0x4
	// Do not prefetch in response to data references.
	FMC_PFB1CR_B1DPE_0 = 0x0
	// Enable prefetches in response to data references.
	FMC_PFB1CR_B1DPE_1 = 0x1
	// Position of B1ICE field.
	FMC_PFB1CR_B1ICE_Pos = 0x3
	// Bit mask of B1ICE field.
	FMC_PFB1CR_B1ICE_Msk = 0x8
	// Bit B1ICE.
	FMC_PFB1CR_B1ICE = 0x8
	// Do not cache instruction fetches.
	FMC_PFB1CR_B1ICE_0 = 0x0
	// Cache instruction fetches.
	FMC_PFB1CR_B1ICE_1 = 0x1
	// Position of B1DCE field.
	FMC_PFB1CR_B1DCE_Pos = 0x4
	// Bit mask of B1DCE field.
	FMC_PFB1CR_B1DCE_Msk = 0x10
	// Bit B1DCE.
	FMC_PFB1CR_B1DCE = 0x10
	// Do not cache data references.
	FMC_PFB1CR_B1DCE_0 = 0x0
	// Cache data references.
	FMC_PFB1CR_B1DCE_1 = 0x1
	// Position of B1MW field.
	FMC_PFB1CR_B1MW_Pos = 0x11
	// Bit mask of B1MW field.
	FMC_PFB1CR_B1MW_Msk = 0x60000
	// 32 bits
	FMC_PFB1CR_B1MW_00 = 0x0
	// 64 bits
	FMC_PFB1CR_B1MW_01 = 0x1
	// 128 bits
	FMC_PFB1CR_B1MW_10 = 0x2
	// Position of B1RWSC field.
	FMC_PFB1CR_B1RWSC_Pos = 0x1c
	// Bit mask of B1RWSC field.
	FMC_PFB1CR_B1RWSC_Msk = 0xf0000000

	// TAGVDW0S0: Cache Tag Storage
	// Position of VALID field.
	FMC_TAGVDW0S_VALID_Pos = 0x0
	// Bit mask of VALID field.
	FMC_TAGVDW0S_VALID_Msk = 0x1
	// Bit VALID.
	FMC_TAGVDW0S_VALID = 0x1
	// Position of TAG field.
	FMC_TAGVDW0S_TAG_Pos = 0x5
	// Bit mask of TAG field.
	FMC_TAGVDW0S_TAG_Msk = 0x7ffe0

	// TAGVDW1S0: Cache Tag Storage
	// Position of VALID field.
	FMC_TAGVDW1S_VALID_Pos = 0x0
	// Bit mask of VALID field.
	FMC_TAGVDW1S_VALID_Msk = 0x1
	// Bit VALID.
	FMC_TAGVDW1S_VALID = 0x1
	// Position of TAG field.
	FMC_TAGVDW1S_TAG_Pos = 0x5
	// Bit mask of TAG field.
	FMC_TAGVDW1S_TAG_Msk = 0x7ffe0

	// TAGVDW2S0: Cache Tag Storage
	// Position of VALID field.
	FMC_TAGVDW2S_VALID_Pos = 0x0
	// Bit mask of VALID field.
	FMC_TAGVDW2S_VALID_Msk = 0x1
	// Bit VALID.
	FMC_TAGVDW2S_VALID = 0x1
	// Position of TAG field.
	FMC_TAGVDW2S_TAG_Pos = 0x5
	// Bit mask of TAG field.
	FMC_TAGVDW2S_TAG_Msk = 0x7ffe0

	// TAGVDW3S0: Cache Tag Storage
	// Position of VALID field.
	FMC_TAGVDW3S_VALID_Pos = 0x0
	// Bit mask of VALID field.
	FMC_TAGVDW3S_VALID_Msk = 0x1
	// Bit VALID.
	FMC_TAGVDW3S_VALID = 0x1
	// Position of TAG field.
	FMC_TAGVDW3S_TAG_Pos = 0x5
	// Bit mask of TAG field.
	FMC_TAGVDW3S_TAG_Msk = 0x7ffe0

	// DATAW0S0U: Cache Data Storage (upper word)
	// Position of DATA field.
	FMC_DATAW0SU_DATA_Pos = 0x0
	// Bit mask of DATA field.
	FMC_DATAW0SU_DATA_Msk = 0xffffffff

	// DATAW0S0L: Cache Data Storage (lower word)
	// Position of DATA field.
	FMC_DATAW0SL_DATA_Pos = 0x0
	// Bit mask of DATA field.
	FMC_DATAW0SL_DATA_Msk = 0xffffffff

	// DATAW1S0U: Cache Data Storage (upper word)
	// Position of DATA field.
	FMC_DATAW1SU_DATA_Pos = 0x0
	// Bit mask of DATA field.
	FMC_DATAW1SU_DATA_Msk = 0xffffffff

	// DATAW1S0L: Cache Data Storage (lower word)
	// Position of DATA field.
	FMC_DATAW1SL_DATA_Pos = 0x0
	// Bit mask of DATA field.
	FMC_DATAW1SL_DATA_Msk = 0xffffffff

	// DATAW2S0U: Cache Data Storage (upper word)
	// Position of DATA field.
	FMC_DATAW2SU_DATA_Pos = 0x0
	// Bit mask of DATA field.
	FMC_DATAW2SU_DATA_Msk = 0xffffffff

	// DATAW2S0L: Cache Data Storage (lower word)
	// Position of DATA field.
	FMC_DATAW2SL_DATA_Pos = 0x0
	// Bit mask of DATA field.
	FMC_DATAW2SL_DATA_Msk = 0xffffffff

	// DATAW3S0U: Cache Data Storage (upper word)
	// Position of DATA field.
	FMC_DATAW3SU_DATA_Pos = 0x0
	// Bit mask of DATA field.
	FMC_DATAW3SU_DATA_Msk = 0xffffffff

	// DATAW3S0L: Cache Data Storage (lower word)
	// Position of DATA field.
	FMC_DATAW3SL_DATA_Pos = 0x0
	// Bit mask of DATA field.
	FMC_DATAW3SL_DATA_Msk = 0xffffffff
)

// Constants for FTFE: Flash Memory Interface
const (
	// FSTAT: Flash Status Register
	// Position of MGSTAT0 field.
	FTFE_FSTAT_MGSTAT0_Pos = 0x0
	// Bit mask of MGSTAT0 field.
	FTFE_FSTAT_MGSTAT0_Msk = 0x1
	// Bit MGSTAT0.
	FTFE_FSTAT_MGSTAT0 = 0x1
	// Position of FPVIOL field.
	FTFE_FSTAT_FPVIOL_Pos = 0x4
	// Bit mask of FPVIOL field.
	FTFE_FSTAT_FPVIOL_Msk = 0x10
	// Bit FPVIOL.
	FTFE_FSTAT_FPVIOL = 0x10
	// No protection violation detected
	FTFE_FSTAT_FPVIOL_0 = 0x0
	// Protection violation detected
	FTFE_FSTAT_FPVIOL_1 = 0x1
	// Position of ACCERR field.
	FTFE_FSTAT_ACCERR_Pos = 0x5
	// Bit mask of ACCERR field.
	FTFE_FSTAT_ACCERR_Msk = 0x20
	// Bit ACCERR.
	FTFE_FSTAT_ACCERR = 0x20
	// No access error detected
	FTFE_FSTAT_ACCERR_0 = 0x0
	// Access error detected
	FTFE_FSTAT_ACCERR_1 = 0x1
	// Position of RDCOLERR field.
	FTFE_FSTAT_RDCOLERR_Pos = 0x6
	// Bit mask of RDCOLERR field.
	FTFE_FSTAT_RDCOLERR_Msk = 0x40
	// Bit RDCOLERR.
	FTFE_FSTAT_RDCOLERR = 0x40
	// No collision error detected
	FTFE_FSTAT_RDCOLERR_0 = 0x0
	// Collision error detected
	FTFE_FSTAT_RDCOLERR_1 = 0x1
	// Position of CCIF field.
	FTFE_FSTAT_CCIF_Pos = 0x7
	// Bit mask of CCIF field.
	FTFE_FSTAT_CCIF_Msk = 0x80
	// Bit CCIF.
	FTFE_FSTAT_CCIF = 0x80
	// FTFE command or EEPROM file system operation in progress
	FTFE_FSTAT_CCIF_0 = 0x0
	// FTFE command or EEPROM file system operation has completed
	FTFE_FSTAT_CCIF_1 = 0x1

	// FCNFG: Flash Configuration Register
	// Position of EEERDY field.
	FTFE_FCNFG_EEERDY_Pos = 0x0
	// Bit mask of EEERDY field.
	FTFE_FCNFG_EEERDY_Msk = 0x1
	// Bit EEERDY.
	FTFE_FCNFG_EEERDY = 0x1
	// For devices with FlexNVM: FlexRAM is not available for EEPROM operation.
	FTFE_FCNFG_EEERDY_0 = 0x0
	// For devices with FlexNVM: FlexRAM is available for EEPROM operations where: reads from the FlexRAM return data previously written to the FlexRAM in EEPROM mode and writes launch an EEPROM operation to store the written data in the FlexRAM and EEPROM backup.
	FTFE_FCNFG_EEERDY_1 = 0x1
	// Position of RAMRDY field.
	FTFE_FCNFG_RAMRDY_Pos = 0x1
	// Bit mask of RAMRDY field.
	FTFE_FCNFG_RAMRDY_Msk = 0x2
	// Bit RAMRDY.
	FTFE_FCNFG_RAMRDY = 0x2
	// For devices with FlexNVM: FlexRAM is not available for traditional RAM access. For devices without FlexNVM: Programming acceleration RAM is not available.
	FTFE_FCNFG_RAMRDY_0 = 0x0
	// For devices with FlexNVM: FlexRAM is available as traditional RAM only; writes to the FlexRAM do not trigger EEPROM operations. For devices without FlexNVM: Programming acceleration RAM is available.
	FTFE_FCNFG_RAMRDY_1 = 0x1
	// Position of PFLSH field.
	FTFE_FCNFG_PFLSH_Pos = 0x2
	// Bit mask of PFLSH field.
	FTFE_FCNFG_PFLSH_Msk = 0x4
	// Bit PFLSH.
	FTFE_FCNFG_PFLSH = 0x4
	// For devices with FlexNVM: FTFE configuration supports two program flash blocks and two FlexNVM blocks For devices with program flash only: Reserved
	FTFE_FCNFG_PFLSH_0 = 0x0
	// For devices with FlexNVM: Reserved For devices with program flash only: FTFE configuration supports four program flash blocks
	FTFE_FCNFG_PFLSH_1 = 0x1
	// Position of SWAP field.
	FTFE_FCNFG_SWAP_Pos = 0x3
	// Bit mask of SWAP field.
	FTFE_FCNFG_SWAP_Msk = 0x8
	// Bit SWAP.
	FTFE_FCNFG_SWAP = 0x8
	// For devices with FlexNVM: Program flash 0 block is located at relative address 0x0000 For devices with program flash only: Program flash 0 block is located at relative address 0x0000
	FTFE_FCNFG_SWAP_0 = 0x0
	// For devices with FlexNVM: Reserved For devices with program flash only: Program flash 1 block is located at relative address 0x0000
	FTFE_FCNFG_SWAP_1 = 0x1
	// Position of ERSSUSP field.
	FTFE_FCNFG_ERSSUSP_Pos = 0x4
	// Bit mask of ERSSUSP field.
	FTFE_FCNFG_ERSSUSP_Msk = 0x10
	// Bit ERSSUSP.
	FTFE_FCNFG_ERSSUSP = 0x10
	// No suspend requested
	FTFE_FCNFG_ERSSUSP_0 = 0x0
	// Suspend the current Erase Flash Sector command execution.
	FTFE_FCNFG_ERSSUSP_1 = 0x1
	// Position of ERSAREQ field.
	FTFE_FCNFG_ERSAREQ_Pos = 0x5
	// Bit mask of ERSAREQ field.
	FTFE_FCNFG_ERSAREQ_Msk = 0x20
	// Bit ERSAREQ.
	FTFE_FCNFG_ERSAREQ = 0x20
	// No request or request complete
	FTFE_FCNFG_ERSAREQ_0 = 0x0
	// Request to: run the Erase All Blocks command, verify the erased state, program the security byte in the Flash Configuration Field to the unsecure state, and release MCU security by setting the FSEC[SEC] field to the unsecure state.
	FTFE_FCNFG_ERSAREQ_1 = 0x1
	// Position of RDCOLLIE field.
	FTFE_FCNFG_RDCOLLIE_Pos = 0x6
	// Bit mask of RDCOLLIE field.
	FTFE_FCNFG_RDCOLLIE_Msk = 0x40
	// Bit RDCOLLIE.
	FTFE_FCNFG_RDCOLLIE = 0x40
	// Read collision error interrupt disabled
	FTFE_FCNFG_RDCOLLIE_0 = 0x0
	// Read collision error interrupt enabled. An interrupt request is generated whenever an FTFE read collision error is detected (see the description of FSTAT[RDCOLERR]).
	FTFE_FCNFG_RDCOLLIE_1 = 0x1
	// Position of CCIE field.
	FTFE_FCNFG_CCIE_Pos = 0x7
	// Bit mask of CCIE field.
	FTFE_FCNFG_CCIE_Msk = 0x80
	// Bit CCIE.
	FTFE_FCNFG_CCIE = 0x80
	// Command complete interrupt disabled
	FTFE_FCNFG_CCIE_0 = 0x0
	// Command complete interrupt enabled. An interrupt request is generated whenever the FSTAT[CCIF] flag is set.
	FTFE_FCNFG_CCIE_1 = 0x1

	// FSEC: Flash Security Register
	// Position of SEC field.
	FTFE_FSEC_SEC_Pos = 0x0
	// Bit mask of SEC field.
	FTFE_FSEC_SEC_Msk = 0x3
	// MCU security status is secure
	FTFE_FSEC_SEC_00 = 0x0
	// MCU security status is secure
	FTFE_FSEC_SEC_01 = 0x1
	// MCU security status is unsecure (The standard shipping condition of the FTFE is unsecure.)
	FTFE_FSEC_SEC_10 = 0x2
	// MCU security status is secure
	FTFE_FSEC_SEC_11 = 0x3
	// Position of FSLACC field.
	FTFE_FSEC_FSLACC_Pos = 0x2
	// Bit mask of FSLACC field.
	FTFE_FSEC_FSLACC_Msk = 0xc
	// Freescale factory access granted
	FTFE_FSEC_FSLACC_00 = 0x0
	// Freescale factory access denied
	FTFE_FSEC_FSLACC_01 = 0x1
	// Freescale factory access denied
	FTFE_FSEC_FSLACC_10 = 0x2
	// Freescale factory access granted
	FTFE_FSEC_FSLACC_11 = 0x3
	// Position of MEEN field.
	FTFE_FSEC_MEEN_Pos = 0x4
	// Bit mask of MEEN field.
	FTFE_FSEC_MEEN_Msk = 0x30
	// Mass erase is enabled
	FTFE_FSEC_MEEN_00 = 0x0
	// Mass erase is enabled
	FTFE_FSEC_MEEN_01 = 0x1
	// Mass erase is disabled
	FTFE_FSEC_MEEN_10 = 0x2
	// Mass erase is enabled
	FTFE_FSEC_MEEN_11 = 0x3
	// Position of KEYEN field.
	FTFE_FSEC_KEYEN_Pos = 0x6
	// Bit mask of KEYEN field.
	FTFE_FSEC_KEYEN_Msk = 0xc0
	// Backdoor key access disabled
	FTFE_FSEC_KEYEN_00 = 0x0
	// Backdoor key access disabled (preferred KEYEN state to disable backdoor key access)
	FTFE_FSEC_KEYEN_01 = 0x1
	// Backdoor key access enabled
	FTFE_FSEC_KEYEN_10 = 0x2
	// Backdoor key access disabled
	FTFE_FSEC_KEYEN_11 = 0x3

	// FOPT: Flash Option Register
	// Position of OPT field.
	FTFE_FOPT_OPT_Pos = 0x0
	// Bit mask of OPT field.
	FTFE_FOPT_OPT_Msk = 0xff

	// FCCOB3: Flash Common Command Object Registers
	// Position of CCOBn field.
	FTFE_FCCOB_CCOBn_Pos = 0x0
	// Bit mask of CCOBn field.
	FTFE_FCCOB_CCOBn_Msk = 0xff

	// FPROT3: Program Flash Protection Registers
	// Position of PROT field.
	FTFE_FPROT_PROT_Pos = 0x0
	// Bit mask of PROT field.
	FTFE_FPROT_PROT_Msk = 0xff
	// Program flash region is protected.
	FTFE_FPROT_PROT_0 = 0x0
	// Program flash region is not protected
	FTFE_FPROT_PROT_1 = 0x1

	// FEPROT: EEPROM Protection Register
	// Position of EPROT field.
	FTFE_FEPROT_EPROT_Pos = 0x0
	// Bit mask of EPROT field.
	FTFE_FEPROT_EPROT_Msk = 0xff
	// For devices with program flash only: Reserved For devices with FlexNVM: EEPROM region is protected
	FTFE_FEPROT_EPROT_0 = 0x0
	// For devices with program flash only: Reserved For devices with FlexNVM: EEPROM region is not protected
	FTFE_FEPROT_EPROT_1 = 0x1

	// FDPROT: Data Flash Protection Register
	// Position of DPROT field.
	FTFE_FDPROT_DPROT_Pos = 0x0
	// Bit mask of DPROT field.
	FTFE_FDPROT_DPROT_Msk = 0xff
	// Data Flash region is protected
	FTFE_FDPROT_DPROT_0 = 0x0
	// Data Flash region is not protected
	FTFE_FDPROT_DPROT_1 = 0x1
)

// Constants for DMAMUX: DMA channel multiplexor
const (
	// CHCFG0: Channel Configuration register
	// Position of SOURCE field.
	DMAMUX_CHCFG_SOURCE_Pos = 0x0
	// Bit mask of SOURCE field.
	DMAMUX_CHCFG_SOURCE_Msk = 0x3f
	// Disable_Signal
	DMAMUX_CHCFG_SOURCE_0 = 0x0
	// UART0_Rx_Signal
	DMAMUX_CHCFG_SOURCE_2 = 0x2
	// UART0_Tx_Signal
	DMAMUX_CHCFG_SOURCE_3 = 0x3
	// UART1_Rx_Signal
	DMAMUX_CHCFG_SOURCE_4 = 0x4
	// UART1_Tx_Signal
	DMAMUX_CHCFG_SOURCE_5 = 0x5
	// UART2_Rx_Signal
	DMAMUX_CHCFG_SOURCE_6 = 0x6
	// UART2_Tx_Signal
	DMAMUX_CHCFG_SOURCE_7 = 0x7
	// UART3_Rx_Signal
	DMAMUX_CHCFG_SOURCE_8 = 0x8
	// UART3_Tx_Signal
	DMAMUX_CHCFG_SOURCE_9 = 0x9
	// UART4_Signal
	DMAMUX_CHCFG_SOURCE_10 = 0xa
	// UART5_Signal
	DMAMUX_CHCFG_SOURCE_11 = 0xb
	// I2S0_Rx_Signal
	DMAMUX_CHCFG_SOURCE_12 = 0xc
	// I2S0_Tx_Signal
	DMAMUX_CHCFG_SOURCE_13 = 0xd
	// SPI0_Rx_Signal
	DMAMUX_CHCFG_SOURCE_14 = 0xe
	// SPI0_Tx_Signal
	DMAMUX_CHCFG_SOURCE_15 = 0xf
	// SPI1_Signal
	DMAMUX_CHCFG_SOURCE_16 = 0x10
	// SPI2_Signal
	DMAMUX_CHCFG_SOURCE_17 = 0x11
	// I2C0_Signal
	DMAMUX_CHCFG_SOURCE_18 = 0x12
	// I2C1_I2C2_Signal
	DMAMUX_CHCFG_SOURCE_19 = 0x13
	// FTM0_Channel0_Signal
	DMAMUX_CHCFG_SOURCE_20 = 0x14
	// FTM0_Channel1_Signal
	DMAMUX_CHCFG_SOURCE_21 = 0x15
	// FTM0_Channel2_Signal
	DMAMUX_CHCFG_SOURCE_22 = 0x16
	// FTM0_Channel3_Signal
	DMAMUX_CHCFG_SOURCE_23 = 0x17
	// FTM0_Channel4_Signal
	DMAMUX_CHCFG_SOURCE_24 = 0x18
	// FTM0_Channel5_Signal
	DMAMUX_CHCFG_SOURCE_25 = 0x19
	// FTM0_Channel6_Signal
	DMAMUX_CHCFG_SOURCE_26 = 0x1a
	// FTM0_Channel7_Signal
	DMAMUX_CHCFG_SOURCE_27 = 0x1b
	// FTM1_Channel0_Signal
	DMAMUX_CHCFG_SOURCE_28 = 0x1c
	// FTM1_Channel1_Signal
	DMAMUX_CHCFG_SOURCE_29 = 0x1d
	// FTM2_Channel0_Signal
	DMAMUX_CHCFG_SOURCE_30 = 0x1e
	// FTM2_Channel1_Signal
	DMAMUX_CHCFG_SOURCE_31 = 0x1f
	// FTM3_Channel0_Signal
	DMAMUX_CHCFG_SOURCE_32 = 0x20
	// FTM3_Channel1_Signal
	DMAMUX_CHCFG_SOURCE_33 = 0x21
	// FTM3_Channel2_Signal
	DMAMUX_CHCFG_SOURCE_34 = 0x22
	// FTM3_Channel3_Signal
	DMAMUX_CHCFG_SOURCE_35 = 0x23
	// FTM3_Channel4_Signal
	DMAMUX_CHCFG_SOURCE_36 = 0x24
	// FTM3_Channel5_Signal
	DMAMUX_CHCFG_SOURCE_37 = 0x25
	// FTM3_Channel6_Signal
	DMAMUX_CHCFG_SOURCE_38 = 0x26
	// FTM3_Channel7_Signal
	DMAMUX_CHCFG_SOURCE_39 = 0x27
	// ADC0_Signal
	DMAMUX_CHCFG_SOURCE_40 = 0x28
	// ADC1_Signal
	DMAMUX_CHCFG_SOURCE_41 = 0x29
	// CMP0_Signal
	DMAMUX_CHCFG_SOURCE_42 = 0x2a
	// CMP1_Signal
	DMAMUX_CHCFG_SOURCE_43 = 0x2b
	// CMP2_Signal
	DMAMUX_CHCFG_SOURCE_44 = 0x2c
	// DAC0_Signal
	DMAMUX_CHCFG_SOURCE_45 = 0x2d
	// DAC1_Signal
	DMAMUX_CHCFG_SOURCE_46 = 0x2e
	// CMT_Signal
	DMAMUX_CHCFG_SOURCE_47 = 0x2f
	// PDB_Signal
	DMAMUX_CHCFG_SOURCE_48 = 0x30
	// PortA_Signal
	DMAMUX_CHCFG_SOURCE_49 = 0x31
	// PortB_Signal
	DMAMUX_CHCFG_SOURCE_50 = 0x32
	// PortC_Signal
	DMAMUX_CHCFG_SOURCE_51 = 0x33
	// PortD_Signal
	DMAMUX_CHCFG_SOURCE_52 = 0x34
	// PortE_Signal
	DMAMUX_CHCFG_SOURCE_53 = 0x35
	// IEEE1588Timer0_Signal
	DMAMUX_CHCFG_SOURCE_54 = 0x36
	// IEEE1588Timer1_Signal
	DMAMUX_CHCFG_SOURCE_55 = 0x37
	// IEEE1588Timer2_Signal
	DMAMUX_CHCFG_SOURCE_56 = 0x38
	// IEEE1588Timer3_Signal
	DMAMUX_CHCFG_SOURCE_57 = 0x39
	// AlwaysOn58_Signal
	DMAMUX_CHCFG_SOURCE_58 = 0x3a
	// AlwaysOn59_Signal
	DMAMUX_CHCFG_SOURCE_59 = 0x3b
	// AlwaysOn60_Signal
	DMAMUX_CHCFG_SOURCE_60 = 0x3c
	// AlwaysOn61_Signal
	DMAMUX_CHCFG_SOURCE_61 = 0x3d
	// AlwaysOn62_Signal
	DMAMUX_CHCFG_SOURCE_62 = 0x3e
	// AlwaysOn63_Signal
	DMAMUX_CHCFG_SOURCE_63 = 0x3f
	// Position of TRIG field.
	DMAMUX_CHCFG_TRIG_Pos = 0x6
	// Bit mask of TRIG field.
	DMAMUX_CHCFG_TRIG_Msk = 0x40
	// Bit TRIG.
	DMAMUX_CHCFG_TRIG = 0x40
	// Triggering is disabled. If triggering is disabled and ENBL is set, the DMA Channel will simply route the specified source to the DMA channel. (Normal mode)
	DMAMUX_CHCFG_TRIG_0 = 0x0
	// Triggering is enabled. If triggering is enabled and ENBL is set, the DMAMUX is in Periodic Trigger mode.
	DMAMUX_CHCFG_TRIG_1 = 0x1
	// Position of ENBL field.
	DMAMUX_CHCFG_ENBL_Pos = 0x7
	// Bit mask of ENBL field.
	DMAMUX_CHCFG_ENBL_Msk = 0x80
	// Bit ENBL.
	DMAMUX_CHCFG_ENBL = 0x80
	// DMA channel is disabled. This mode is primarily used during configuration of the DMAMux. The DMA has separate channel enables/disables, which should be used to disable or reconfigure a DMA channel.
	DMAMUX_CHCFG_ENBL_0 = 0x0
	// DMA channel is enabled
	DMAMUX_CHCFG_ENBL_1 = 0x1
)

// Constants for CAN0: Flex Controller Area Network module
const (
	// MCR: Module Configuration Register
	// Position of MAXMB field.
	CAN0_MCR_MAXMB_Pos = 0x0
	// Bit mask of MAXMB field.
	CAN0_MCR_MAXMB_Msk = 0x7f
	// Position of IDAM field.
	CAN0_MCR_IDAM_Pos = 0x8
	// Bit mask of IDAM field.
	CAN0_MCR_IDAM_Msk = 0x300
	// Format A: One full ID (standard and extended) per ID Filter Table element.
	CAN0_MCR_IDAM_00 = 0x0
	// Format B: Two full standard IDs or two partial 14-bit (standard and extended) IDs per ID Filter Table element.
	CAN0_MCR_IDAM_01 = 0x1
	// Format C: Four partial 8-bit Standard IDs per ID Filter Table element.
	CAN0_MCR_IDAM_10 = 0x2
	// Format D: All frames rejected.
	CAN0_MCR_IDAM_11 = 0x3
	// Position of AEN field.
	CAN0_MCR_AEN_Pos = 0xc
	// Bit mask of AEN field.
	CAN0_MCR_AEN_Msk = 0x1000
	// Bit AEN.
	CAN0_MCR_AEN = 0x1000
	// Abort disabled.
	CAN0_MCR_AEN_0 = 0x0
	// Abort enabled.
	CAN0_MCR_AEN_1 = 0x1
	// Position of LPRIOEN field.
	CAN0_MCR_LPRIOEN_Pos = 0xd
	// Bit mask of LPRIOEN field.
	CAN0_MCR_LPRIOEN_Msk = 0x2000
	// Bit LPRIOEN.
	CAN0_MCR_LPRIOEN = 0x2000
	// Local Priority disabled.
	CAN0_MCR_LPRIOEN_0 = 0x0
	// Local Priority enabled.
	CAN0_MCR_LPRIOEN_1 = 0x1
	// Position of IRMQ field.
	CAN0_MCR_IRMQ_Pos = 0x10
	// Bit mask of IRMQ field.
	CAN0_MCR_IRMQ_Msk = 0x10000
	// Bit IRMQ.
	CAN0_MCR_IRMQ = 0x10000
	// Individual Rx masking and queue feature are disabled. For backward compatibility with legacy applications, the reading of C/S word locks the MB even if it is EMPTY.
	CAN0_MCR_IRMQ_0 = 0x0
	// Individual Rx masking and queue feature are enabled.
	CAN0_MCR_IRMQ_1 = 0x1
	// Position of SRXDIS field.
	CAN0_MCR_SRXDIS_Pos = 0x11
	// Bit mask of SRXDIS field.
	CAN0_MCR_SRXDIS_Msk = 0x20000
	// Bit SRXDIS.
	CAN0_MCR_SRXDIS = 0x20000
	// Self reception enabled.
	CAN0_MCR_SRXDIS_0 = 0x0
	// Self reception disabled.
	CAN0_MCR_SRXDIS_1 = 0x1
	// Position of WAKSRC field.
	CAN0_MCR_WAKSRC_Pos = 0x13
	// Bit mask of WAKSRC field.
	CAN0_MCR_WAKSRC_Msk = 0x80000
	// Bit WAKSRC.
	CAN0_MCR_WAKSRC = 0x80000
	// FlexCAN uses the unfiltered Rx input to detect recessive to dominant edges on the CAN bus.
	CAN0_MCR_WAKSRC_0 = 0x0
	// FlexCAN uses the filtered Rx input to detect recessive to dominant edges on the CAN bus.
	CAN0_MCR_WAKSRC_1 = 0x1
	// Position of LPMACK field.
	CAN0_MCR_LPMACK_Pos = 0x14
	// Bit mask of LPMACK field.
	CAN0_MCR_LPMACK_Msk = 0x100000
	// Bit LPMACK.
	CAN0_MCR_LPMACK = 0x100000
	// FlexCAN is not in a low-power mode.
	CAN0_MCR_LPMACK_0 = 0x0
	// FlexCAN is in a low-power mode.
	CAN0_MCR_LPMACK_1 = 0x1
	// Position of WRNEN field.
	CAN0_MCR_WRNEN_Pos = 0x15
	// Bit mask of WRNEN field.
	CAN0_MCR_WRNEN_Msk = 0x200000
	// Bit WRNEN.
	CAN0_MCR_WRNEN = 0x200000
	// TWRNINT and RWRNINT bits are zero, independent of the values in the error counters.
	CAN0_MCR_WRNEN_0 = 0x0
	// TWRNINT and RWRNINT bits are set when the respective error counter transitions from less than 96 to greater than or equal to 96.
	CAN0_MCR_WRNEN_1 = 0x1
	// Position of SLFWAK field.
	CAN0_MCR_SLFWAK_Pos = 0x16
	// Bit mask of SLFWAK field.
	CAN0_MCR_SLFWAK_Msk = 0x400000
	// Bit SLFWAK.
	CAN0_MCR_SLFWAK = 0x400000
	// FlexCAN Self Wake Up feature is disabled.
	CAN0_MCR_SLFWAK_0 = 0x0
	// FlexCAN Self Wake Up feature is enabled.
	CAN0_MCR_SLFWAK_1 = 0x1
	// Position of SUPV field.
	CAN0_MCR_SUPV_Pos = 0x17
	// Bit mask of SUPV field.
	CAN0_MCR_SUPV_Msk = 0x800000
	// Bit SUPV.
	CAN0_MCR_SUPV = 0x800000
	// FlexCAN is in User mode. Affected registers allow both Supervisor and Unrestricted accesses .
	CAN0_MCR_SUPV_0 = 0x0
	// FlexCAN is in Supervisor mode. Affected registers allow only Supervisor access. Unrestricted access behaves as though the access was done to an unimplemented register location .
	CAN0_MCR_SUPV_1 = 0x1
	// Position of FRZACK field.
	CAN0_MCR_FRZACK_Pos = 0x18
	// Bit mask of FRZACK field.
	CAN0_MCR_FRZACK_Msk = 0x1000000
	// Bit FRZACK.
	CAN0_MCR_FRZACK = 0x1000000
	// FlexCAN not in Freeze mode, prescaler running.
	CAN0_MCR_FRZACK_0 = 0x0
	// FlexCAN in Freeze mode, prescaler stopped.
	CAN0_MCR_FRZACK_1 = 0x1
	// Position of SOFTRST field.
	CAN0_MCR_SOFTRST_Pos = 0x19
	// Bit mask of SOFTRST field.
	CAN0_MCR_SOFTRST_Msk = 0x2000000
	// Bit SOFTRST.
	CAN0_MCR_SOFTRST = 0x2000000
	// No reset request.
	CAN0_MCR_SOFTRST_0 = 0x0
	// Resets the registers affected by soft reset.
	CAN0_MCR_SOFTRST_1 = 0x1
	// Position of WAKMSK field.
	CAN0_MCR_WAKMSK_Pos = 0x1a
	// Bit mask of WAKMSK field.
	CAN0_MCR_WAKMSK_Msk = 0x4000000
	// Bit WAKMSK.
	CAN0_MCR_WAKMSK = 0x4000000
	// Wake Up Interrupt is disabled.
	CAN0_MCR_WAKMSK_0 = 0x0
	// Wake Up Interrupt is enabled.
	CAN0_MCR_WAKMSK_1 = 0x1
	// Position of NOTRDY field.
	CAN0_MCR_NOTRDY_Pos = 0x1b
	// Bit mask of NOTRDY field.
	CAN0_MCR_NOTRDY_Msk = 0x8000000
	// Bit NOTRDY.
	CAN0_MCR_NOTRDY = 0x8000000
	// FlexCAN module is either in Normal mode, Listen-Only mode or Loop-Back mode.
	CAN0_MCR_NOTRDY_0 = 0x0
	// FlexCAN module is either in Disable mode , Stop mode or Freeze mode.
	CAN0_MCR_NOTRDY_1 = 0x1
	// Position of HALT field.
	CAN0_MCR_HALT_Pos = 0x1c
	// Bit mask of HALT field.
	CAN0_MCR_HALT_Msk = 0x10000000
	// Bit HALT.
	CAN0_MCR_HALT = 0x10000000
	// No Freeze mode request.
	CAN0_MCR_HALT_0 = 0x0
	// Enters Freeze mode if the FRZ bit is asserted.
	CAN0_MCR_HALT_1 = 0x1
	// Position of RFEN field.
	CAN0_MCR_RFEN_Pos = 0x1d
	// Bit mask of RFEN field.
	CAN0_MCR_RFEN_Msk = 0x20000000
	// Bit RFEN.
	CAN0_MCR_RFEN = 0x20000000
	// Rx FIFO not enabled.
	CAN0_MCR_RFEN_0 = 0x0
	// Rx FIFO enabled.
	CAN0_MCR_RFEN_1 = 0x1
	// Position of FRZ field.
	CAN0_MCR_FRZ_Pos = 0x1e
	// Bit mask of FRZ field.
	CAN0_MCR_FRZ_Msk = 0x40000000
	// Bit FRZ.
	CAN0_MCR_FRZ = 0x40000000
	// Not enabled to enter Freeze mode.
	CAN0_MCR_FRZ_0 = 0x0
	// Enabled to enter Freeze mode.
	CAN0_MCR_FRZ_1 = 0x1
	// Position of MDIS field.
	CAN0_MCR_MDIS_Pos = 0x1f
	// Bit mask of MDIS field.
	CAN0_MCR_MDIS_Msk = 0x80000000
	// Bit MDIS.
	CAN0_MCR_MDIS = 0x80000000
	// Enable the FlexCAN module.
	CAN0_MCR_MDIS_0 = 0x0
	// Disable the FlexCAN module.
	CAN0_MCR_MDIS_1 = 0x1

	// CTRL1: Control 1 register
	// Position of PROPSEG field.
	CAN0_CTRL1_PROPSEG_Pos = 0x0
	// Bit mask of PROPSEG field.
	CAN0_CTRL1_PROPSEG_Msk = 0x7
	// Position of LOM field.
	CAN0_CTRL1_LOM_Pos = 0x3
	// Bit mask of LOM field.
	CAN0_CTRL1_LOM_Msk = 0x8
	// Bit LOM.
	CAN0_CTRL1_LOM = 0x8
	// Listen-Only mode is deactivated.
	CAN0_CTRL1_LOM_0 = 0x0
	// FlexCAN module operates in Listen-Only mode.
	CAN0_CTRL1_LOM_1 = 0x1
	// Position of LBUF field.
	CAN0_CTRL1_LBUF_Pos = 0x4
	// Bit mask of LBUF field.
	CAN0_CTRL1_LBUF_Msk = 0x10
	// Bit LBUF.
	CAN0_CTRL1_LBUF = 0x10
	// Buffer with highest priority is transmitted first.
	CAN0_CTRL1_LBUF_0 = 0x0
	// Lowest number buffer is transmitted first.
	CAN0_CTRL1_LBUF_1 = 0x1
	// Position of TSYN field.
	CAN0_CTRL1_TSYN_Pos = 0x5
	// Bit mask of TSYN field.
	CAN0_CTRL1_TSYN_Msk = 0x20
	// Bit TSYN.
	CAN0_CTRL1_TSYN = 0x20
	// Timer Sync feature disabled
	CAN0_CTRL1_TSYN_0 = 0x0
	// Timer Sync feature enabled
	CAN0_CTRL1_TSYN_1 = 0x1
	// Position of BOFFREC field.
	CAN0_CTRL1_BOFFREC_Pos = 0x6
	// Bit mask of BOFFREC field.
	CAN0_CTRL1_BOFFREC_Msk = 0x40
	// Bit BOFFREC.
	CAN0_CTRL1_BOFFREC = 0x40
	// Automatic recovering from Bus Off state enabled, according to CAN Spec 2.0 part B.
	CAN0_CTRL1_BOFFREC_0 = 0x0
	// Automatic recovering from Bus Off state disabled.
	CAN0_CTRL1_BOFFREC_1 = 0x1
	// Position of SMP field.
	CAN0_CTRL1_SMP_Pos = 0x7
	// Bit mask of SMP field.
	CAN0_CTRL1_SMP_Msk = 0x80
	// Bit SMP.
	CAN0_CTRL1_SMP = 0x80
	// Just one sample is used to determine the bit value.
	CAN0_CTRL1_SMP_0 = 0x0
	// Three samples are used to determine the value of the received bit: the regular one (sample point) and 2 preceding samples; a majority rule is used.
	CAN0_CTRL1_SMP_1 = 0x1
	// Position of RWRNMSK field.
	CAN0_CTRL1_RWRNMSK_Pos = 0xa
	// Bit mask of RWRNMSK field.
	CAN0_CTRL1_RWRNMSK_Msk = 0x400
	// Bit RWRNMSK.
	CAN0_CTRL1_RWRNMSK = 0x400
	// Rx Warning Interrupt disabled.
	CAN0_CTRL1_RWRNMSK_0 = 0x0
	// Rx Warning Interrupt enabled.
	CAN0_CTRL1_RWRNMSK_1 = 0x1
	// Position of TWRNMSK field.
	CAN0_CTRL1_TWRNMSK_Pos = 0xb
	// Bit mask of TWRNMSK field.
	CAN0_CTRL1_TWRNMSK_Msk = 0x800
	// Bit TWRNMSK.
	CAN0_CTRL1_TWRNMSK = 0x800
	// Tx Warning Interrupt disabled.
	CAN0_CTRL1_TWRNMSK_0 = 0x0
	// Tx Warning Interrupt enabled.
	CAN0_CTRL1_TWRNMSK_1 = 0x1
	// Position of LPB field.
	CAN0_CTRL1_LPB_Pos = 0xc
	// Bit mask of LPB field.
	CAN0_CTRL1_LPB_Msk = 0x1000
	// Bit LPB.
	CAN0_CTRL1_LPB = 0x1000
	// Loop Back disabled.
	CAN0_CTRL1_LPB_0 = 0x0
	// Loop Back enabled.
	CAN0_CTRL1_LPB_1 = 0x1
	// Position of CLKSRC field.
	CAN0_CTRL1_CLKSRC_Pos = 0xd
	// Bit mask of CLKSRC field.
	CAN0_CTRL1_CLKSRC_Msk = 0x2000
	// Bit CLKSRC.
	CAN0_CTRL1_CLKSRC = 0x2000
	// The CAN engine clock source is the oscillator clock. Under this condition, the oscillator clock frequency must be lower than the bus clock.
	CAN0_CTRL1_CLKSRC_0 = 0x0
	// The CAN engine clock source is the peripheral clock.
	CAN0_CTRL1_CLKSRC_1 = 0x1
	// Position of ERRMSK field.
	CAN0_CTRL1_ERRMSK_Pos = 0xe
	// Bit mask of ERRMSK field.
	CAN0_CTRL1_ERRMSK_Msk = 0x4000
	// Bit ERRMSK.
	CAN0_CTRL1_ERRMSK = 0x4000
	// Error interrupt disabled.
	CAN0_CTRL1_ERRMSK_0 = 0x0
	// Error interrupt enabled.
	CAN0_CTRL1_ERRMSK_1 = 0x1
	// Position of BOFFMSK field.
	CAN0_CTRL1_BOFFMSK_Pos = 0xf
	// Bit mask of BOFFMSK field.
	CAN0_CTRL1_BOFFMSK_Msk = 0x8000
	// Bit BOFFMSK.
	CAN0_CTRL1_BOFFMSK = 0x8000
	// Bus Off interrupt disabled.
	CAN0_CTRL1_BOFFMSK_0 = 0x0
	// Bus Off interrupt enabled.
	CAN0_CTRL1_BOFFMSK_1 = 0x1
	// Position of PSEG2 field.
	CAN0_CTRL1_PSEG2_Pos = 0x10
	// Bit mask of PSEG2 field.
	CAN0_CTRL1_PSEG2_Msk = 0x70000
	// Position of PSEG1 field.
	CAN0_CTRL1_PSEG1_Pos = 0x13
	// Bit mask of PSEG1 field.
	CAN0_CTRL1_PSEG1_Msk = 0x380000
	// Position of RJW field.
	CAN0_CTRL1_RJW_Pos = 0x16
	// Bit mask of RJW field.
	CAN0_CTRL1_RJW_Msk = 0xc00000
	// Position of PRESDIV field.
	CAN0_CTRL1_PRESDIV_Pos = 0x18
	// Bit mask of PRESDIV field.
	CAN0_CTRL1_PRESDIV_Msk = 0xff000000

	// TIMER: Free Running Timer
	// Position of TIMER field.
	CAN0_TIMER_TIMER_Pos = 0x0
	// Bit mask of TIMER field.
	CAN0_TIMER_TIMER_Msk = 0xffff

	// RXMGMASK: Rx Mailboxes Global Mask Register
	// Position of MG0 field.
	CAN0_RXMGMASK_MG0_Pos = 0x0
	// Bit mask of MG0 field.
	CAN0_RXMGMASK_MG0_Msk = 0x1
	// Bit MG0.
	CAN0_RXMGMASK_MG0 = 0x1
	// The corresponding bit in the filter is "don't care."
	CAN0_RXMGMASK_MG0_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXMGMASK_MG0_1 = 0x1
	// Position of MG1 field.
	CAN0_RXMGMASK_MG1_Pos = 0x1
	// Bit mask of MG1 field.
	CAN0_RXMGMASK_MG1_Msk = 0x2
	// Bit MG1.
	CAN0_RXMGMASK_MG1 = 0x2
	// The corresponding bit in the filter is "don't care."
	CAN0_RXMGMASK_MG1_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXMGMASK_MG1_1 = 0x1
	// Position of MG2 field.
	CAN0_RXMGMASK_MG2_Pos = 0x2
	// Bit mask of MG2 field.
	CAN0_RXMGMASK_MG2_Msk = 0x4
	// Bit MG2.
	CAN0_RXMGMASK_MG2 = 0x4
	// The corresponding bit in the filter is "don't care."
	CAN0_RXMGMASK_MG2_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXMGMASK_MG2_1 = 0x1
	// Position of MG3 field.
	CAN0_RXMGMASK_MG3_Pos = 0x3
	// Bit mask of MG3 field.
	CAN0_RXMGMASK_MG3_Msk = 0x8
	// Bit MG3.
	CAN0_RXMGMASK_MG3 = 0x8
	// The corresponding bit in the filter is "don't care."
	CAN0_RXMGMASK_MG3_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXMGMASK_MG3_1 = 0x1
	// Position of MG4 field.
	CAN0_RXMGMASK_MG4_Pos = 0x4
	// Bit mask of MG4 field.
	CAN0_RXMGMASK_MG4_Msk = 0x10
	// Bit MG4.
	CAN0_RXMGMASK_MG4 = 0x10
	// The corresponding bit in the filter is "don't care."
	CAN0_RXMGMASK_MG4_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXMGMASK_MG4_1 = 0x1
	// Position of MG5 field.
	CAN0_RXMGMASK_MG5_Pos = 0x5
	// Bit mask of MG5 field.
	CAN0_RXMGMASK_MG5_Msk = 0x20
	// Bit MG5.
	CAN0_RXMGMASK_MG5 = 0x20
	// The corresponding bit in the filter is "don't care."
	CAN0_RXMGMASK_MG5_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXMGMASK_MG5_1 = 0x1
	// Position of MG6 field.
	CAN0_RXMGMASK_MG6_Pos = 0x6
	// Bit mask of MG6 field.
	CAN0_RXMGMASK_MG6_Msk = 0x40
	// Bit MG6.
	CAN0_RXMGMASK_MG6 = 0x40
	// The corresponding bit in the filter is "don't care."
	CAN0_RXMGMASK_MG6_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXMGMASK_MG6_1 = 0x1
	// Position of MG7 field.
	CAN0_RXMGMASK_MG7_Pos = 0x7
	// Bit mask of MG7 field.
	CAN0_RXMGMASK_MG7_Msk = 0x80
	// Bit MG7.
	CAN0_RXMGMASK_MG7 = 0x80
	// The corresponding bit in the filter is "don't care."
	CAN0_RXMGMASK_MG7_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXMGMASK_MG7_1 = 0x1
	// Position of MG8 field.
	CAN0_RXMGMASK_MG8_Pos = 0x8
	// Bit mask of MG8 field.
	CAN0_RXMGMASK_MG8_Msk = 0x100
	// Bit MG8.
	CAN0_RXMGMASK_MG8 = 0x100
	// The corresponding bit in the filter is "don't care."
	CAN0_RXMGMASK_MG8_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXMGMASK_MG8_1 = 0x1
	// Position of MG9 field.
	CAN0_RXMGMASK_MG9_Pos = 0x9
	// Bit mask of MG9 field.
	CAN0_RXMGMASK_MG9_Msk = 0x200
	// Bit MG9.
	CAN0_RXMGMASK_MG9 = 0x200
	// The corresponding bit in the filter is "don't care."
	CAN0_RXMGMASK_MG9_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXMGMASK_MG9_1 = 0x1
	// Position of MG10 field.
	CAN0_RXMGMASK_MG10_Pos = 0xa
	// Bit mask of MG10 field.
	CAN0_RXMGMASK_MG10_Msk = 0x400
	// Bit MG10.
	CAN0_RXMGMASK_MG10 = 0x400
	// The corresponding bit in the filter is "don't care."
	CAN0_RXMGMASK_MG10_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXMGMASK_MG10_1 = 0x1
	// Position of MG11 field.
	CAN0_RXMGMASK_MG11_Pos = 0xb
	// Bit mask of MG11 field.
	CAN0_RXMGMASK_MG11_Msk = 0x800
	// Bit MG11.
	CAN0_RXMGMASK_MG11 = 0x800
	// The corresponding bit in the filter is "don't care."
	CAN0_RXMGMASK_MG11_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXMGMASK_MG11_1 = 0x1
	// Position of MG12 field.
	CAN0_RXMGMASK_MG12_Pos = 0xc
	// Bit mask of MG12 field.
	CAN0_RXMGMASK_MG12_Msk = 0x1000
	// Bit MG12.
	CAN0_RXMGMASK_MG12 = 0x1000
	// The corresponding bit in the filter is "don't care."
	CAN0_RXMGMASK_MG12_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXMGMASK_MG12_1 = 0x1
	// Position of MG13 field.
	CAN0_RXMGMASK_MG13_Pos = 0xd
	// Bit mask of MG13 field.
	CAN0_RXMGMASK_MG13_Msk = 0x2000
	// Bit MG13.
	CAN0_RXMGMASK_MG13 = 0x2000
	// The corresponding bit in the filter is "don't care."
	CAN0_RXMGMASK_MG13_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXMGMASK_MG13_1 = 0x1
	// Position of MG14 field.
	CAN0_RXMGMASK_MG14_Pos = 0xe
	// Bit mask of MG14 field.
	CAN0_RXMGMASK_MG14_Msk = 0x4000
	// Bit MG14.
	CAN0_RXMGMASK_MG14 = 0x4000
	// The corresponding bit in the filter is "don't care."
	CAN0_RXMGMASK_MG14_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXMGMASK_MG14_1 = 0x1
	// Position of MG15 field.
	CAN0_RXMGMASK_MG15_Pos = 0xf
	// Bit mask of MG15 field.
	CAN0_RXMGMASK_MG15_Msk = 0x8000
	// Bit MG15.
	CAN0_RXMGMASK_MG15 = 0x8000
	// The corresponding bit in the filter is "don't care."
	CAN0_RXMGMASK_MG15_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXMGMASK_MG15_1 = 0x1
	// Position of MG16 field.
	CAN0_RXMGMASK_MG16_Pos = 0x10
	// Bit mask of MG16 field.
	CAN0_RXMGMASK_MG16_Msk = 0x10000
	// Bit MG16.
	CAN0_RXMGMASK_MG16 = 0x10000
	// The corresponding bit in the filter is "don't care."
	CAN0_RXMGMASK_MG16_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXMGMASK_MG16_1 = 0x1
	// Position of MG17 field.
	CAN0_RXMGMASK_MG17_Pos = 0x11
	// Bit mask of MG17 field.
	CAN0_RXMGMASK_MG17_Msk = 0x20000
	// Bit MG17.
	CAN0_RXMGMASK_MG17 = 0x20000
	// The corresponding bit in the filter is "don't care."
	CAN0_RXMGMASK_MG17_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXMGMASK_MG17_1 = 0x1
	// Position of MG18 field.
	CAN0_RXMGMASK_MG18_Pos = 0x12
	// Bit mask of MG18 field.
	CAN0_RXMGMASK_MG18_Msk = 0x40000
	// Bit MG18.
	CAN0_RXMGMASK_MG18 = 0x40000
	// The corresponding bit in the filter is "don't care."
	CAN0_RXMGMASK_MG18_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXMGMASK_MG18_1 = 0x1
	// Position of MG19 field.
	CAN0_RXMGMASK_MG19_Pos = 0x13
	// Bit mask of MG19 field.
	CAN0_RXMGMASK_MG19_Msk = 0x80000
	// Bit MG19.
	CAN0_RXMGMASK_MG19 = 0x80000
	// The corresponding bit in the filter is "don't care."
	CAN0_RXMGMASK_MG19_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXMGMASK_MG19_1 = 0x1
	// Position of MG20 field.
	CAN0_RXMGMASK_MG20_Pos = 0x14
	// Bit mask of MG20 field.
	CAN0_RXMGMASK_MG20_Msk = 0x100000
	// Bit MG20.
	CAN0_RXMGMASK_MG20 = 0x100000
	// The corresponding bit in the filter is "don't care."
	CAN0_RXMGMASK_MG20_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXMGMASK_MG20_1 = 0x1
	// Position of MG21 field.
	CAN0_RXMGMASK_MG21_Pos = 0x15
	// Bit mask of MG21 field.
	CAN0_RXMGMASK_MG21_Msk = 0x200000
	// Bit MG21.
	CAN0_RXMGMASK_MG21 = 0x200000
	// The corresponding bit in the filter is "don't care."
	CAN0_RXMGMASK_MG21_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXMGMASK_MG21_1 = 0x1
	// Position of MG22 field.
	CAN0_RXMGMASK_MG22_Pos = 0x16
	// Bit mask of MG22 field.
	CAN0_RXMGMASK_MG22_Msk = 0x400000
	// Bit MG22.
	CAN0_RXMGMASK_MG22 = 0x400000
	// The corresponding bit in the filter is "don't care."
	CAN0_RXMGMASK_MG22_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXMGMASK_MG22_1 = 0x1
	// Position of MG23 field.
	CAN0_RXMGMASK_MG23_Pos = 0x17
	// Bit mask of MG23 field.
	CAN0_RXMGMASK_MG23_Msk = 0x800000
	// Bit MG23.
	CAN0_RXMGMASK_MG23 = 0x800000
	// The corresponding bit in the filter is "don't care."
	CAN0_RXMGMASK_MG23_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXMGMASK_MG23_1 = 0x1
	// Position of MG24 field.
	CAN0_RXMGMASK_MG24_Pos = 0x18
	// Bit mask of MG24 field.
	CAN0_RXMGMASK_MG24_Msk = 0x1000000
	// Bit MG24.
	CAN0_RXMGMASK_MG24 = 0x1000000
	// The corresponding bit in the filter is "don't care."
	CAN0_RXMGMASK_MG24_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXMGMASK_MG24_1 = 0x1
	// Position of MG25 field.
	CAN0_RXMGMASK_MG25_Pos = 0x19
	// Bit mask of MG25 field.
	CAN0_RXMGMASK_MG25_Msk = 0x2000000
	// Bit MG25.
	CAN0_RXMGMASK_MG25 = 0x2000000
	// The corresponding bit in the filter is "don't care."
	CAN0_RXMGMASK_MG25_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXMGMASK_MG25_1 = 0x1
	// Position of MG26 field.
	CAN0_RXMGMASK_MG26_Pos = 0x1a
	// Bit mask of MG26 field.
	CAN0_RXMGMASK_MG26_Msk = 0x4000000
	// Bit MG26.
	CAN0_RXMGMASK_MG26 = 0x4000000
	// The corresponding bit in the filter is "don't care."
	CAN0_RXMGMASK_MG26_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXMGMASK_MG26_1 = 0x1
	// Position of MG27 field.
	CAN0_RXMGMASK_MG27_Pos = 0x1b
	// Bit mask of MG27 field.
	CAN0_RXMGMASK_MG27_Msk = 0x8000000
	// Bit MG27.
	CAN0_RXMGMASK_MG27 = 0x8000000
	// The corresponding bit in the filter is "don't care."
	CAN0_RXMGMASK_MG27_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXMGMASK_MG27_1 = 0x1
	// Position of MG28 field.
	CAN0_RXMGMASK_MG28_Pos = 0x1c
	// Bit mask of MG28 field.
	CAN0_RXMGMASK_MG28_Msk = 0x10000000
	// Bit MG28.
	CAN0_RXMGMASK_MG28 = 0x10000000
	// The corresponding bit in the filter is "don't care."
	CAN0_RXMGMASK_MG28_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXMGMASK_MG28_1 = 0x1
	// Position of MG29 field.
	CAN0_RXMGMASK_MG29_Pos = 0x1d
	// Bit mask of MG29 field.
	CAN0_RXMGMASK_MG29_Msk = 0x20000000
	// Bit MG29.
	CAN0_RXMGMASK_MG29 = 0x20000000
	// The corresponding bit in the filter is "don't care."
	CAN0_RXMGMASK_MG29_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXMGMASK_MG29_1 = 0x1
	// Position of MG30 field.
	CAN0_RXMGMASK_MG30_Pos = 0x1e
	// Bit mask of MG30 field.
	CAN0_RXMGMASK_MG30_Msk = 0x40000000
	// Bit MG30.
	CAN0_RXMGMASK_MG30 = 0x40000000
	// The corresponding bit in the filter is "don't care."
	CAN0_RXMGMASK_MG30_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXMGMASK_MG30_1 = 0x1
	// Position of MG31 field.
	CAN0_RXMGMASK_MG31_Pos = 0x1f
	// Bit mask of MG31 field.
	CAN0_RXMGMASK_MG31_Msk = 0x80000000
	// Bit MG31.
	CAN0_RXMGMASK_MG31 = 0x80000000
	// The corresponding bit in the filter is "don't care."
	CAN0_RXMGMASK_MG31_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXMGMASK_MG31_1 = 0x1

	// RX14MASK: Rx 14 Mask register
	// Position of RX14M0 field.
	CAN0_RX14MASK_RX14M0_Pos = 0x0
	// Bit mask of RX14M0 field.
	CAN0_RX14MASK_RX14M0_Msk = 0x1
	// Bit RX14M0.
	CAN0_RX14MASK_RX14M0 = 0x1
	// The corresponding bit in the filter is "don't care."
	CAN0_RX14MASK_RX14M0_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RX14MASK_RX14M0_1 = 0x1
	// Position of RX14M1 field.
	CAN0_RX14MASK_RX14M1_Pos = 0x1
	// Bit mask of RX14M1 field.
	CAN0_RX14MASK_RX14M1_Msk = 0x2
	// Bit RX14M1.
	CAN0_RX14MASK_RX14M1 = 0x2
	// The corresponding bit in the filter is "don't care."
	CAN0_RX14MASK_RX14M1_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RX14MASK_RX14M1_1 = 0x1
	// Position of RX14M2 field.
	CAN0_RX14MASK_RX14M2_Pos = 0x2
	// Bit mask of RX14M2 field.
	CAN0_RX14MASK_RX14M2_Msk = 0x4
	// Bit RX14M2.
	CAN0_RX14MASK_RX14M2 = 0x4
	// The corresponding bit in the filter is "don't care."
	CAN0_RX14MASK_RX14M2_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RX14MASK_RX14M2_1 = 0x1
	// Position of RX14M3 field.
	CAN0_RX14MASK_RX14M3_Pos = 0x3
	// Bit mask of RX14M3 field.
	CAN0_RX14MASK_RX14M3_Msk = 0x8
	// Bit RX14M3.
	CAN0_RX14MASK_RX14M3 = 0x8
	// The corresponding bit in the filter is "don't care."
	CAN0_RX14MASK_RX14M3_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RX14MASK_RX14M3_1 = 0x1
	// Position of RX14M4 field.
	CAN0_RX14MASK_RX14M4_Pos = 0x4
	// Bit mask of RX14M4 field.
	CAN0_RX14MASK_RX14M4_Msk = 0x10
	// Bit RX14M4.
	CAN0_RX14MASK_RX14M4 = 0x10
	// The corresponding bit in the filter is "don't care."
	CAN0_RX14MASK_RX14M4_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RX14MASK_RX14M4_1 = 0x1
	// Position of RX14M5 field.
	CAN0_RX14MASK_RX14M5_Pos = 0x5
	// Bit mask of RX14M5 field.
	CAN0_RX14MASK_RX14M5_Msk = 0x20
	// Bit RX14M5.
	CAN0_RX14MASK_RX14M5 = 0x20
	// The corresponding bit in the filter is "don't care."
	CAN0_RX14MASK_RX14M5_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RX14MASK_RX14M5_1 = 0x1
	// Position of RX14M6 field.
	CAN0_RX14MASK_RX14M6_Pos = 0x6
	// Bit mask of RX14M6 field.
	CAN0_RX14MASK_RX14M6_Msk = 0x40
	// Bit RX14M6.
	CAN0_RX14MASK_RX14M6 = 0x40
	// The corresponding bit in the filter is "don't care."
	CAN0_RX14MASK_RX14M6_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RX14MASK_RX14M6_1 = 0x1
	// Position of RX14M7 field.
	CAN0_RX14MASK_RX14M7_Pos = 0x7
	// Bit mask of RX14M7 field.
	CAN0_RX14MASK_RX14M7_Msk = 0x80
	// Bit RX14M7.
	CAN0_RX14MASK_RX14M7 = 0x80
	// The corresponding bit in the filter is "don't care."
	CAN0_RX14MASK_RX14M7_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RX14MASK_RX14M7_1 = 0x1
	// Position of RX14M8 field.
	CAN0_RX14MASK_RX14M8_Pos = 0x8
	// Bit mask of RX14M8 field.
	CAN0_RX14MASK_RX14M8_Msk = 0x100
	// Bit RX14M8.
	CAN0_RX14MASK_RX14M8 = 0x100
	// The corresponding bit in the filter is "don't care."
	CAN0_RX14MASK_RX14M8_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RX14MASK_RX14M8_1 = 0x1
	// Position of RX14M9 field.
	CAN0_RX14MASK_RX14M9_Pos = 0x9
	// Bit mask of RX14M9 field.
	CAN0_RX14MASK_RX14M9_Msk = 0x200
	// Bit RX14M9.
	CAN0_RX14MASK_RX14M9 = 0x200
	// The corresponding bit in the filter is "don't care."
	CAN0_RX14MASK_RX14M9_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RX14MASK_RX14M9_1 = 0x1
	// Position of RX14M10 field.
	CAN0_RX14MASK_RX14M10_Pos = 0xa
	// Bit mask of RX14M10 field.
	CAN0_RX14MASK_RX14M10_Msk = 0x400
	// Bit RX14M10.
	CAN0_RX14MASK_RX14M10 = 0x400
	// The corresponding bit in the filter is "don't care."
	CAN0_RX14MASK_RX14M10_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RX14MASK_RX14M10_1 = 0x1
	// Position of RX14M11 field.
	CAN0_RX14MASK_RX14M11_Pos = 0xb
	// Bit mask of RX14M11 field.
	CAN0_RX14MASK_RX14M11_Msk = 0x800
	// Bit RX14M11.
	CAN0_RX14MASK_RX14M11 = 0x800
	// The corresponding bit in the filter is "don't care."
	CAN0_RX14MASK_RX14M11_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RX14MASK_RX14M11_1 = 0x1
	// Position of RX14M12 field.
	CAN0_RX14MASK_RX14M12_Pos = 0xc
	// Bit mask of RX14M12 field.
	CAN0_RX14MASK_RX14M12_Msk = 0x1000
	// Bit RX14M12.
	CAN0_RX14MASK_RX14M12 = 0x1000
	// The corresponding bit in the filter is "don't care."
	CAN0_RX14MASK_RX14M12_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RX14MASK_RX14M12_1 = 0x1
	// Position of RX14M13 field.
	CAN0_RX14MASK_RX14M13_Pos = 0xd
	// Bit mask of RX14M13 field.
	CAN0_RX14MASK_RX14M13_Msk = 0x2000
	// Bit RX14M13.
	CAN0_RX14MASK_RX14M13 = 0x2000
	// The corresponding bit in the filter is "don't care."
	CAN0_RX14MASK_RX14M13_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RX14MASK_RX14M13_1 = 0x1
	// Position of RX14M14 field.
	CAN0_RX14MASK_RX14M14_Pos = 0xe
	// Bit mask of RX14M14 field.
	CAN0_RX14MASK_RX14M14_Msk = 0x4000
	// Bit RX14M14.
	CAN0_RX14MASK_RX14M14 = 0x4000
	// The corresponding bit in the filter is "don't care."
	CAN0_RX14MASK_RX14M14_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RX14MASK_RX14M14_1 = 0x1
	// Position of RX14M15 field.
	CAN0_RX14MASK_RX14M15_Pos = 0xf
	// Bit mask of RX14M15 field.
	CAN0_RX14MASK_RX14M15_Msk = 0x8000
	// Bit RX14M15.
	CAN0_RX14MASK_RX14M15 = 0x8000
	// The corresponding bit in the filter is "don't care."
	CAN0_RX14MASK_RX14M15_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RX14MASK_RX14M15_1 = 0x1
	// Position of RX14M16 field.
	CAN0_RX14MASK_RX14M16_Pos = 0x10
	// Bit mask of RX14M16 field.
	CAN0_RX14MASK_RX14M16_Msk = 0x10000
	// Bit RX14M16.
	CAN0_RX14MASK_RX14M16 = 0x10000
	// The corresponding bit in the filter is "don't care."
	CAN0_RX14MASK_RX14M16_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RX14MASK_RX14M16_1 = 0x1
	// Position of RX14M17 field.
	CAN0_RX14MASK_RX14M17_Pos = 0x11
	// Bit mask of RX14M17 field.
	CAN0_RX14MASK_RX14M17_Msk = 0x20000
	// Bit RX14M17.
	CAN0_RX14MASK_RX14M17 = 0x20000
	// The corresponding bit in the filter is "don't care."
	CAN0_RX14MASK_RX14M17_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RX14MASK_RX14M17_1 = 0x1
	// Position of RX14M18 field.
	CAN0_RX14MASK_RX14M18_Pos = 0x12
	// Bit mask of RX14M18 field.
	CAN0_RX14MASK_RX14M18_Msk = 0x40000
	// Bit RX14M18.
	CAN0_RX14MASK_RX14M18 = 0x40000
	// The corresponding bit in the filter is "don't care."
	CAN0_RX14MASK_RX14M18_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RX14MASK_RX14M18_1 = 0x1
	// Position of RX14M19 field.
	CAN0_RX14MASK_RX14M19_Pos = 0x13
	// Bit mask of RX14M19 field.
	CAN0_RX14MASK_RX14M19_Msk = 0x80000
	// Bit RX14M19.
	CAN0_RX14MASK_RX14M19 = 0x80000
	// The corresponding bit in the filter is "don't care."
	CAN0_RX14MASK_RX14M19_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RX14MASK_RX14M19_1 = 0x1
	// Position of RX14M20 field.
	CAN0_RX14MASK_RX14M20_Pos = 0x14
	// Bit mask of RX14M20 field.
	CAN0_RX14MASK_RX14M20_Msk = 0x100000
	// Bit RX14M20.
	CAN0_RX14MASK_RX14M20 = 0x100000
	// The corresponding bit in the filter is "don't care."
	CAN0_RX14MASK_RX14M20_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RX14MASK_RX14M20_1 = 0x1
	// Position of RX14M21 field.
	CAN0_RX14MASK_RX14M21_Pos = 0x15
	// Bit mask of RX14M21 field.
	CAN0_RX14MASK_RX14M21_Msk = 0x200000
	// Bit RX14M21.
	CAN0_RX14MASK_RX14M21 = 0x200000
	// The corresponding bit in the filter is "don't care."
	CAN0_RX14MASK_RX14M21_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RX14MASK_RX14M21_1 = 0x1
	// Position of RX14M22 field.
	CAN0_RX14MASK_RX14M22_Pos = 0x16
	// Bit mask of RX14M22 field.
	CAN0_RX14MASK_RX14M22_Msk = 0x400000
	// Bit RX14M22.
	CAN0_RX14MASK_RX14M22 = 0x400000
	// The corresponding bit in the filter is "don't care."
	CAN0_RX14MASK_RX14M22_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RX14MASK_RX14M22_1 = 0x1
	// Position of RX14M23 field.
	CAN0_RX14MASK_RX14M23_Pos = 0x17
	// Bit mask of RX14M23 field.
	CAN0_RX14MASK_RX14M23_Msk = 0x800000
	// Bit RX14M23.
	CAN0_RX14MASK_RX14M23 = 0x800000
	// The corresponding bit in the filter is "don't care."
	CAN0_RX14MASK_RX14M23_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RX14MASK_RX14M23_1 = 0x1
	// Position of RX14M24 field.
	CAN0_RX14MASK_RX14M24_Pos = 0x18
	// Bit mask of RX14M24 field.
	CAN0_RX14MASK_RX14M24_Msk = 0x1000000
	// Bit RX14M24.
	CAN0_RX14MASK_RX14M24 = 0x1000000
	// The corresponding bit in the filter is "don't care."
	CAN0_RX14MASK_RX14M24_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RX14MASK_RX14M24_1 = 0x1
	// Position of RX14M25 field.
	CAN0_RX14MASK_RX14M25_Pos = 0x19
	// Bit mask of RX14M25 field.
	CAN0_RX14MASK_RX14M25_Msk = 0x2000000
	// Bit RX14M25.
	CAN0_RX14MASK_RX14M25 = 0x2000000
	// The corresponding bit in the filter is "don't care."
	CAN0_RX14MASK_RX14M25_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RX14MASK_RX14M25_1 = 0x1
	// Position of RX14M26 field.
	CAN0_RX14MASK_RX14M26_Pos = 0x1a
	// Bit mask of RX14M26 field.
	CAN0_RX14MASK_RX14M26_Msk = 0x4000000
	// Bit RX14M26.
	CAN0_RX14MASK_RX14M26 = 0x4000000
	// The corresponding bit in the filter is "don't care."
	CAN0_RX14MASK_RX14M26_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RX14MASK_RX14M26_1 = 0x1
	// Position of RX14M27 field.
	CAN0_RX14MASK_RX14M27_Pos = 0x1b
	// Bit mask of RX14M27 field.
	CAN0_RX14MASK_RX14M27_Msk = 0x8000000
	// Bit RX14M27.
	CAN0_RX14MASK_RX14M27 = 0x8000000
	// The corresponding bit in the filter is "don't care."
	CAN0_RX14MASK_RX14M27_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RX14MASK_RX14M27_1 = 0x1
	// Position of RX14M28 field.
	CAN0_RX14MASK_RX14M28_Pos = 0x1c
	// Bit mask of RX14M28 field.
	CAN0_RX14MASK_RX14M28_Msk = 0x10000000
	// Bit RX14M28.
	CAN0_RX14MASK_RX14M28 = 0x10000000
	// The corresponding bit in the filter is "don't care."
	CAN0_RX14MASK_RX14M28_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RX14MASK_RX14M28_1 = 0x1
	// Position of RX14M29 field.
	CAN0_RX14MASK_RX14M29_Pos = 0x1d
	// Bit mask of RX14M29 field.
	CAN0_RX14MASK_RX14M29_Msk = 0x20000000
	// Bit RX14M29.
	CAN0_RX14MASK_RX14M29 = 0x20000000
	// The corresponding bit in the filter is "don't care."
	CAN0_RX14MASK_RX14M29_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RX14MASK_RX14M29_1 = 0x1
	// Position of RX14M30 field.
	CAN0_RX14MASK_RX14M30_Pos = 0x1e
	// Bit mask of RX14M30 field.
	CAN0_RX14MASK_RX14M30_Msk = 0x40000000
	// Bit RX14M30.
	CAN0_RX14MASK_RX14M30 = 0x40000000
	// The corresponding bit in the filter is "don't care."
	CAN0_RX14MASK_RX14M30_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RX14MASK_RX14M30_1 = 0x1
	// Position of RX14M31 field.
	CAN0_RX14MASK_RX14M31_Pos = 0x1f
	// Bit mask of RX14M31 field.
	CAN0_RX14MASK_RX14M31_Msk = 0x80000000
	// Bit RX14M31.
	CAN0_RX14MASK_RX14M31 = 0x80000000
	// The corresponding bit in the filter is "don't care."
	CAN0_RX14MASK_RX14M31_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RX14MASK_RX14M31_1 = 0x1

	// RX15MASK: Rx 15 Mask register
	// Position of RX15M0 field.
	CAN0_RX15MASK_RX15M0_Pos = 0x0
	// Bit mask of RX15M0 field.
	CAN0_RX15MASK_RX15M0_Msk = 0x1
	// Bit RX15M0.
	CAN0_RX15MASK_RX15M0 = 0x1
	// The corresponding bit in the filter is "don't care."
	CAN0_RX15MASK_RX15M0_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RX15MASK_RX15M0_1 = 0x1
	// Position of RX15M1 field.
	CAN0_RX15MASK_RX15M1_Pos = 0x1
	// Bit mask of RX15M1 field.
	CAN0_RX15MASK_RX15M1_Msk = 0x2
	// Bit RX15M1.
	CAN0_RX15MASK_RX15M1 = 0x2
	// The corresponding bit in the filter is "don't care."
	CAN0_RX15MASK_RX15M1_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RX15MASK_RX15M1_1 = 0x1
	// Position of RX15M2 field.
	CAN0_RX15MASK_RX15M2_Pos = 0x2
	// Bit mask of RX15M2 field.
	CAN0_RX15MASK_RX15M2_Msk = 0x4
	// Bit RX15M2.
	CAN0_RX15MASK_RX15M2 = 0x4
	// The corresponding bit in the filter is "don't care."
	CAN0_RX15MASK_RX15M2_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RX15MASK_RX15M2_1 = 0x1
	// Position of RX15M3 field.
	CAN0_RX15MASK_RX15M3_Pos = 0x3
	// Bit mask of RX15M3 field.
	CAN0_RX15MASK_RX15M3_Msk = 0x8
	// Bit RX15M3.
	CAN0_RX15MASK_RX15M3 = 0x8
	// The corresponding bit in the filter is "don't care."
	CAN0_RX15MASK_RX15M3_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RX15MASK_RX15M3_1 = 0x1
	// Position of RX15M4 field.
	CAN0_RX15MASK_RX15M4_Pos = 0x4
	// Bit mask of RX15M4 field.
	CAN0_RX15MASK_RX15M4_Msk = 0x10
	// Bit RX15M4.
	CAN0_RX15MASK_RX15M4 = 0x10
	// The corresponding bit in the filter is "don't care."
	CAN0_RX15MASK_RX15M4_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RX15MASK_RX15M4_1 = 0x1
	// Position of RX15M5 field.
	CAN0_RX15MASK_RX15M5_Pos = 0x5
	// Bit mask of RX15M5 field.
	CAN0_RX15MASK_RX15M5_Msk = 0x20
	// Bit RX15M5.
	CAN0_RX15MASK_RX15M5 = 0x20
	// The corresponding bit in the filter is "don't care."
	CAN0_RX15MASK_RX15M5_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RX15MASK_RX15M5_1 = 0x1
	// Position of RX15M6 field.
	CAN0_RX15MASK_RX15M6_Pos = 0x6
	// Bit mask of RX15M6 field.
	CAN0_RX15MASK_RX15M6_Msk = 0x40
	// Bit RX15M6.
	CAN0_RX15MASK_RX15M6 = 0x40
	// The corresponding bit in the filter is "don't care."
	CAN0_RX15MASK_RX15M6_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RX15MASK_RX15M6_1 = 0x1
	// Position of RX15M7 field.
	CAN0_RX15MASK_RX15M7_Pos = 0x7
	// Bit mask of RX15M7 field.
	CAN0_RX15MASK_RX15M7_Msk = 0x80
	// Bit RX15M7.
	CAN0_RX15MASK_RX15M7 = 0x80
	// The corresponding bit in the filter is "don't care."
	CAN0_RX15MASK_RX15M7_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RX15MASK_RX15M7_1 = 0x1
	// Position of RX15M8 field.
	CAN0_RX15MASK_RX15M8_Pos = 0x8
	// Bit mask of RX15M8 field.
	CAN0_RX15MASK_RX15M8_Msk = 0x100
	// Bit RX15M8.
	CAN0_RX15MASK_RX15M8 = 0x100
	// The corresponding bit in the filter is "don't care."
	CAN0_RX15MASK_RX15M8_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RX15MASK_RX15M8_1 = 0x1
	// Position of RX15M9 field.
	CAN0_RX15MASK_RX15M9_Pos = 0x9
	// Bit mask of RX15M9 field.
	CAN0_RX15MASK_RX15M9_Msk = 0x200
	// Bit RX15M9.
	CAN0_RX15MASK_RX15M9 = 0x200
	// The corresponding bit in the filter is "don't care."
	CAN0_RX15MASK_RX15M9_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RX15MASK_RX15M9_1 = 0x1
	// Position of RX15M10 field.
	CAN0_RX15MASK_RX15M10_Pos = 0xa
	// Bit mask of RX15M10 field.
	CAN0_RX15MASK_RX15M10_Msk = 0x400
	// Bit RX15M10.
	CAN0_RX15MASK_RX15M10 = 0x400
	// The corresponding bit in the filter is "don't care."
	CAN0_RX15MASK_RX15M10_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RX15MASK_RX15M10_1 = 0x1
	// Position of RX15M11 field.
	CAN0_RX15MASK_RX15M11_Pos = 0xb
	// Bit mask of RX15M11 field.
	CAN0_RX15MASK_RX15M11_Msk = 0x800
	// Bit RX15M11.
	CAN0_RX15MASK_RX15M11 = 0x800
	// The corresponding bit in the filter is "don't care."
	CAN0_RX15MASK_RX15M11_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RX15MASK_RX15M11_1 = 0x1
	// Position of RX15M12 field.
	CAN0_RX15MASK_RX15M12_Pos = 0xc
	// Bit mask of RX15M12 field.
	CAN0_RX15MASK_RX15M12_Msk = 0x1000
	// Bit RX15M12.
	CAN0_RX15MASK_RX15M12 = 0x1000
	// The corresponding bit in the filter is "don't care."
	CAN0_RX15MASK_RX15M12_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RX15MASK_RX15M12_1 = 0x1
	// Position of RX15M13 field.
	CAN0_RX15MASK_RX15M13_Pos = 0xd
	// Bit mask of RX15M13 field.
	CAN0_RX15MASK_RX15M13_Msk = 0x2000
	// Bit RX15M13.
	CAN0_RX15MASK_RX15M13 = 0x2000
	// The corresponding bit in the filter is "don't care."
	CAN0_RX15MASK_RX15M13_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RX15MASK_RX15M13_1 = 0x1
	// Position of RX15M14 field.
	CAN0_RX15MASK_RX15M14_Pos = 0xe
	// Bit mask of RX15M14 field.
	CAN0_RX15MASK_RX15M14_Msk = 0x4000
	// Bit RX15M14.
	CAN0_RX15MASK_RX15M14 = 0x4000
	// The corresponding bit in the filter is "don't care."
	CAN0_RX15MASK_RX15M14_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RX15MASK_RX15M14_1 = 0x1
	// Position of RX15M15 field.
	CAN0_RX15MASK_RX15M15_Pos = 0xf
	// Bit mask of RX15M15 field.
	CAN0_RX15MASK_RX15M15_Msk = 0x8000
	// Bit RX15M15.
	CAN0_RX15MASK_RX15M15 = 0x8000
	// The corresponding bit in the filter is "don't care."
	CAN0_RX15MASK_RX15M15_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RX15MASK_RX15M15_1 = 0x1
	// Position of RX15M16 field.
	CAN0_RX15MASK_RX15M16_Pos = 0x10
	// Bit mask of RX15M16 field.
	CAN0_RX15MASK_RX15M16_Msk = 0x10000
	// Bit RX15M16.
	CAN0_RX15MASK_RX15M16 = 0x10000
	// The corresponding bit in the filter is "don't care."
	CAN0_RX15MASK_RX15M16_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RX15MASK_RX15M16_1 = 0x1
	// Position of RX15M17 field.
	CAN0_RX15MASK_RX15M17_Pos = 0x11
	// Bit mask of RX15M17 field.
	CAN0_RX15MASK_RX15M17_Msk = 0x20000
	// Bit RX15M17.
	CAN0_RX15MASK_RX15M17 = 0x20000
	// The corresponding bit in the filter is "don't care."
	CAN0_RX15MASK_RX15M17_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RX15MASK_RX15M17_1 = 0x1
	// Position of RX15M18 field.
	CAN0_RX15MASK_RX15M18_Pos = 0x12
	// Bit mask of RX15M18 field.
	CAN0_RX15MASK_RX15M18_Msk = 0x40000
	// Bit RX15M18.
	CAN0_RX15MASK_RX15M18 = 0x40000
	// The corresponding bit in the filter is "don't care."
	CAN0_RX15MASK_RX15M18_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RX15MASK_RX15M18_1 = 0x1
	// Position of RX15M19 field.
	CAN0_RX15MASK_RX15M19_Pos = 0x13
	// Bit mask of RX15M19 field.
	CAN0_RX15MASK_RX15M19_Msk = 0x80000
	// Bit RX15M19.
	CAN0_RX15MASK_RX15M19 = 0x80000
	// The corresponding bit in the filter is "don't care."
	CAN0_RX15MASK_RX15M19_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RX15MASK_RX15M19_1 = 0x1
	// Position of RX15M20 field.
	CAN0_RX15MASK_RX15M20_Pos = 0x14
	// Bit mask of RX15M20 field.
	CAN0_RX15MASK_RX15M20_Msk = 0x100000
	// Bit RX15M20.
	CAN0_RX15MASK_RX15M20 = 0x100000
	// The corresponding bit in the filter is "don't care."
	CAN0_RX15MASK_RX15M20_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RX15MASK_RX15M20_1 = 0x1
	// Position of RX15M21 field.
	CAN0_RX15MASK_RX15M21_Pos = 0x15
	// Bit mask of RX15M21 field.
	CAN0_RX15MASK_RX15M21_Msk = 0x200000
	// Bit RX15M21.
	CAN0_RX15MASK_RX15M21 = 0x200000
	// The corresponding bit in the filter is "don't care."
	CAN0_RX15MASK_RX15M21_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RX15MASK_RX15M21_1 = 0x1
	// Position of RX15M22 field.
	CAN0_RX15MASK_RX15M22_Pos = 0x16
	// Bit mask of RX15M22 field.
	CAN0_RX15MASK_RX15M22_Msk = 0x400000
	// Bit RX15M22.
	CAN0_RX15MASK_RX15M22 = 0x400000
	// The corresponding bit in the filter is "don't care."
	CAN0_RX15MASK_RX15M22_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RX15MASK_RX15M22_1 = 0x1
	// Position of RX15M23 field.
	CAN0_RX15MASK_RX15M23_Pos = 0x17
	// Bit mask of RX15M23 field.
	CAN0_RX15MASK_RX15M23_Msk = 0x800000
	// Bit RX15M23.
	CAN0_RX15MASK_RX15M23 = 0x800000
	// The corresponding bit in the filter is "don't care."
	CAN0_RX15MASK_RX15M23_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RX15MASK_RX15M23_1 = 0x1
	// Position of RX15M24 field.
	CAN0_RX15MASK_RX15M24_Pos = 0x18
	// Bit mask of RX15M24 field.
	CAN0_RX15MASK_RX15M24_Msk = 0x1000000
	// Bit RX15M24.
	CAN0_RX15MASK_RX15M24 = 0x1000000
	// The corresponding bit in the filter is "don't care."
	CAN0_RX15MASK_RX15M24_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RX15MASK_RX15M24_1 = 0x1
	// Position of RX15M25 field.
	CAN0_RX15MASK_RX15M25_Pos = 0x19
	// Bit mask of RX15M25 field.
	CAN0_RX15MASK_RX15M25_Msk = 0x2000000
	// Bit RX15M25.
	CAN0_RX15MASK_RX15M25 = 0x2000000
	// The corresponding bit in the filter is "don't care."
	CAN0_RX15MASK_RX15M25_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RX15MASK_RX15M25_1 = 0x1
	// Position of RX15M26 field.
	CAN0_RX15MASK_RX15M26_Pos = 0x1a
	// Bit mask of RX15M26 field.
	CAN0_RX15MASK_RX15M26_Msk = 0x4000000
	// Bit RX15M26.
	CAN0_RX15MASK_RX15M26 = 0x4000000
	// The corresponding bit in the filter is "don't care."
	CAN0_RX15MASK_RX15M26_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RX15MASK_RX15M26_1 = 0x1
	// Position of RX15M27 field.
	CAN0_RX15MASK_RX15M27_Pos = 0x1b
	// Bit mask of RX15M27 field.
	CAN0_RX15MASK_RX15M27_Msk = 0x8000000
	// Bit RX15M27.
	CAN0_RX15MASK_RX15M27 = 0x8000000
	// The corresponding bit in the filter is "don't care."
	CAN0_RX15MASK_RX15M27_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RX15MASK_RX15M27_1 = 0x1
	// Position of RX15M28 field.
	CAN0_RX15MASK_RX15M28_Pos = 0x1c
	// Bit mask of RX15M28 field.
	CAN0_RX15MASK_RX15M28_Msk = 0x10000000
	// Bit RX15M28.
	CAN0_RX15MASK_RX15M28 = 0x10000000
	// The corresponding bit in the filter is "don't care."
	CAN0_RX15MASK_RX15M28_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RX15MASK_RX15M28_1 = 0x1
	// Position of RX15M29 field.
	CAN0_RX15MASK_RX15M29_Pos = 0x1d
	// Bit mask of RX15M29 field.
	CAN0_RX15MASK_RX15M29_Msk = 0x20000000
	// Bit RX15M29.
	CAN0_RX15MASK_RX15M29 = 0x20000000
	// The corresponding bit in the filter is "don't care."
	CAN0_RX15MASK_RX15M29_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RX15MASK_RX15M29_1 = 0x1
	// Position of RX15M30 field.
	CAN0_RX15MASK_RX15M30_Pos = 0x1e
	// Bit mask of RX15M30 field.
	CAN0_RX15MASK_RX15M30_Msk = 0x40000000
	// Bit RX15M30.
	CAN0_RX15MASK_RX15M30 = 0x40000000
	// The corresponding bit in the filter is "don't care."
	CAN0_RX15MASK_RX15M30_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RX15MASK_RX15M30_1 = 0x1
	// Position of RX15M31 field.
	CAN0_RX15MASK_RX15M31_Pos = 0x1f
	// Bit mask of RX15M31 field.
	CAN0_RX15MASK_RX15M31_Msk = 0x80000000
	// Bit RX15M31.
	CAN0_RX15MASK_RX15M31 = 0x80000000
	// The corresponding bit in the filter is "don't care."
	CAN0_RX15MASK_RX15M31_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RX15MASK_RX15M31_1 = 0x1

	// ECR: Error Counter
	// Position of TXERRCNT field.
	CAN0_ECR_TXERRCNT_Pos = 0x0
	// Bit mask of TXERRCNT field.
	CAN0_ECR_TXERRCNT_Msk = 0xff
	// Position of RXERRCNT field.
	CAN0_ECR_RXERRCNT_Pos = 0x8
	// Bit mask of RXERRCNT field.
	CAN0_ECR_RXERRCNT_Msk = 0xff00

	// ESR1: Error and Status 1 register
	// Position of WAKINT field.
	CAN0_ESR1_WAKINT_Pos = 0x0
	// Bit mask of WAKINT field.
	CAN0_ESR1_WAKINT_Msk = 0x1
	// Bit WAKINT.
	CAN0_ESR1_WAKINT = 0x1
	// No such occurrence.
	CAN0_ESR1_WAKINT_0 = 0x0
	// Indicates a recessive to dominant transition was received on the CAN bus.
	CAN0_ESR1_WAKINT_1 = 0x1
	// Position of ERRINT field.
	CAN0_ESR1_ERRINT_Pos = 0x1
	// Bit mask of ERRINT field.
	CAN0_ESR1_ERRINT_Msk = 0x2
	// Bit ERRINT.
	CAN0_ESR1_ERRINT = 0x2
	// No such occurrence.
	CAN0_ESR1_ERRINT_0 = 0x0
	// Indicates setting of any Error Bit in the Error and Status Register.
	CAN0_ESR1_ERRINT_1 = 0x1
	// Position of BOFFINT field.
	CAN0_ESR1_BOFFINT_Pos = 0x2
	// Bit mask of BOFFINT field.
	CAN0_ESR1_BOFFINT_Msk = 0x4
	// Bit BOFFINT.
	CAN0_ESR1_BOFFINT = 0x4
	// No such occurrence.
	CAN0_ESR1_BOFFINT_0 = 0x0
	// FlexCAN module entered Bus Off state.
	CAN0_ESR1_BOFFINT_1 = 0x1
	// Position of RX field.
	CAN0_ESR1_RX_Pos = 0x3
	// Bit mask of RX field.
	CAN0_ESR1_RX_Msk = 0x8
	// Bit RX.
	CAN0_ESR1_RX = 0x8
	// FlexCAN is not receiving a message.
	CAN0_ESR1_RX_0 = 0x0
	// FlexCAN is receiving a message.
	CAN0_ESR1_RX_1 = 0x1
	// Position of FLTCONF field.
	CAN0_ESR1_FLTCONF_Pos = 0x4
	// Bit mask of FLTCONF field.
	CAN0_ESR1_FLTCONF_Msk = 0x30
	// Error Active
	CAN0_ESR1_FLTCONF_00 = 0x0
	// Error Passive
	CAN0_ESR1_FLTCONF_01 = 0x1
	// Position of TX field.
	CAN0_ESR1_TX_Pos = 0x6
	// Bit mask of TX field.
	CAN0_ESR1_TX_Msk = 0x40
	// Bit TX.
	CAN0_ESR1_TX = 0x40
	// FlexCAN is not transmitting a message.
	CAN0_ESR1_TX_0 = 0x0
	// FlexCAN is transmitting a message.
	CAN0_ESR1_TX_1 = 0x1
	// Position of IDLE field.
	CAN0_ESR1_IDLE_Pos = 0x7
	// Bit mask of IDLE field.
	CAN0_ESR1_IDLE_Msk = 0x80
	// Bit IDLE.
	CAN0_ESR1_IDLE = 0x80
	// No such occurrence.
	CAN0_ESR1_IDLE_0 = 0x0
	// CAN bus is now IDLE.
	CAN0_ESR1_IDLE_1 = 0x1
	// Position of RXWRN field.
	CAN0_ESR1_RXWRN_Pos = 0x8
	// Bit mask of RXWRN field.
	CAN0_ESR1_RXWRN_Msk = 0x100
	// Bit RXWRN.
	CAN0_ESR1_RXWRN = 0x100
	// No such occurrence.
	CAN0_ESR1_RXWRN_0 = 0x0
	// RXERRCNT is greater than or equal to 96.
	CAN0_ESR1_RXWRN_1 = 0x1
	// Position of TXWRN field.
	CAN0_ESR1_TXWRN_Pos = 0x9
	// Bit mask of TXWRN field.
	CAN0_ESR1_TXWRN_Msk = 0x200
	// Bit TXWRN.
	CAN0_ESR1_TXWRN = 0x200
	// No such occurrence.
	CAN0_ESR1_TXWRN_0 = 0x0
	// TXERRCNT is greater than or equal to 96.
	CAN0_ESR1_TXWRN_1 = 0x1
	// Position of STFERR field.
	CAN0_ESR1_STFERR_Pos = 0xa
	// Bit mask of STFERR field.
	CAN0_ESR1_STFERR_Msk = 0x400
	// Bit STFERR.
	CAN0_ESR1_STFERR = 0x400
	// No such occurrence.
	CAN0_ESR1_STFERR_0 = 0x0
	// A Stuffing Error occurred since last read of this register.
	CAN0_ESR1_STFERR_1 = 0x1
	// Position of FRMERR field.
	CAN0_ESR1_FRMERR_Pos = 0xb
	// Bit mask of FRMERR field.
	CAN0_ESR1_FRMERR_Msk = 0x800
	// Bit FRMERR.
	CAN0_ESR1_FRMERR = 0x800
	// No such occurrence.
	CAN0_ESR1_FRMERR_0 = 0x0
	// A Form Error occurred since last read of this register.
	CAN0_ESR1_FRMERR_1 = 0x1
	// Position of CRCERR field.
	CAN0_ESR1_CRCERR_Pos = 0xc
	// Bit mask of CRCERR field.
	CAN0_ESR1_CRCERR_Msk = 0x1000
	// Bit CRCERR.
	CAN0_ESR1_CRCERR = 0x1000
	// No such occurrence.
	CAN0_ESR1_CRCERR_0 = 0x0
	// A CRC error occurred since last read of this register.
	CAN0_ESR1_CRCERR_1 = 0x1
	// Position of ACKERR field.
	CAN0_ESR1_ACKERR_Pos = 0xd
	// Bit mask of ACKERR field.
	CAN0_ESR1_ACKERR_Msk = 0x2000
	// Bit ACKERR.
	CAN0_ESR1_ACKERR = 0x2000
	// No such occurrence.
	CAN0_ESR1_ACKERR_0 = 0x0
	// An ACK error occurred since last read of this register.
	CAN0_ESR1_ACKERR_1 = 0x1
	// Position of BIT0ERR field.
	CAN0_ESR1_BIT0ERR_Pos = 0xe
	// Bit mask of BIT0ERR field.
	CAN0_ESR1_BIT0ERR_Msk = 0x4000
	// Bit BIT0ERR.
	CAN0_ESR1_BIT0ERR = 0x4000
	// No such occurrence.
	CAN0_ESR1_BIT0ERR_0 = 0x0
	// At least one bit sent as dominant is received as recessive.
	CAN0_ESR1_BIT0ERR_1 = 0x1
	// Position of BIT1ERR field.
	CAN0_ESR1_BIT1ERR_Pos = 0xf
	// Bit mask of BIT1ERR field.
	CAN0_ESR1_BIT1ERR_Msk = 0x8000
	// Bit BIT1ERR.
	CAN0_ESR1_BIT1ERR = 0x8000
	// No such occurrence.
	CAN0_ESR1_BIT1ERR_0 = 0x0
	// At least one bit sent as recessive is received as dominant.
	CAN0_ESR1_BIT1ERR_1 = 0x1
	// Position of RWRNINT field.
	CAN0_ESR1_RWRNINT_Pos = 0x10
	// Bit mask of RWRNINT field.
	CAN0_ESR1_RWRNINT_Msk = 0x10000
	// Bit RWRNINT.
	CAN0_ESR1_RWRNINT = 0x10000
	// No such occurrence.
	CAN0_ESR1_RWRNINT_0 = 0x0
	// The Rx error counter transitioned from less than 96 to greater than or equal to 96.
	CAN0_ESR1_RWRNINT_1 = 0x1
	// Position of TWRNINT field.
	CAN0_ESR1_TWRNINT_Pos = 0x11
	// Bit mask of TWRNINT field.
	CAN0_ESR1_TWRNINT_Msk = 0x20000
	// Bit TWRNINT.
	CAN0_ESR1_TWRNINT = 0x20000
	// No such occurrence.
	CAN0_ESR1_TWRNINT_0 = 0x0
	// The Tx error counter transitioned from less than 96 to greater than or equal to 96.
	CAN0_ESR1_TWRNINT_1 = 0x1
	// Position of SYNCH field.
	CAN0_ESR1_SYNCH_Pos = 0x12
	// Bit mask of SYNCH field.
	CAN0_ESR1_SYNCH_Msk = 0x40000
	// Bit SYNCH.
	CAN0_ESR1_SYNCH = 0x40000
	// FlexCAN is not synchronized to the CAN bus.
	CAN0_ESR1_SYNCH_0 = 0x0
	// FlexCAN is synchronized to the CAN bus.
	CAN0_ESR1_SYNCH_1 = 0x1

	// IMASK1: Interrupt Masks 1 register
	// Position of BUFLM0 field.
	CAN0_IMASK1_BUFLM0_Pos = 0x0
	// Bit mask of BUFLM0 field.
	CAN0_IMASK1_BUFLM0_Msk = 0x1
	// Bit BUFLM0.
	CAN0_IMASK1_BUFLM0 = 0x1
	// The corresponding buffer Interrupt is disabled.
	CAN0_IMASK1_BUFLM0_0 = 0x0
	// The corresponding buffer Interrupt is enabled.
	CAN0_IMASK1_BUFLM0_1 = 0x1
	// Position of BUFLM1 field.
	CAN0_IMASK1_BUFLM1_Pos = 0x1
	// Bit mask of BUFLM1 field.
	CAN0_IMASK1_BUFLM1_Msk = 0x2
	// Bit BUFLM1.
	CAN0_IMASK1_BUFLM1 = 0x2
	// The corresponding buffer Interrupt is disabled.
	CAN0_IMASK1_BUFLM1_0 = 0x0
	// The corresponding buffer Interrupt is enabled.
	CAN0_IMASK1_BUFLM1_1 = 0x1
	// Position of BUFLM2 field.
	CAN0_IMASK1_BUFLM2_Pos = 0x2
	// Bit mask of BUFLM2 field.
	CAN0_IMASK1_BUFLM2_Msk = 0x4
	// Bit BUFLM2.
	CAN0_IMASK1_BUFLM2 = 0x4
	// The corresponding buffer Interrupt is disabled.
	CAN0_IMASK1_BUFLM2_0 = 0x0
	// The corresponding buffer Interrupt is enabled.
	CAN0_IMASK1_BUFLM2_1 = 0x1
	// Position of BUFLM3 field.
	CAN0_IMASK1_BUFLM3_Pos = 0x3
	// Bit mask of BUFLM3 field.
	CAN0_IMASK1_BUFLM3_Msk = 0x8
	// Bit BUFLM3.
	CAN0_IMASK1_BUFLM3 = 0x8
	// The corresponding buffer Interrupt is disabled.
	CAN0_IMASK1_BUFLM3_0 = 0x0
	// The corresponding buffer Interrupt is enabled.
	CAN0_IMASK1_BUFLM3_1 = 0x1
	// Position of BUFLM4 field.
	CAN0_IMASK1_BUFLM4_Pos = 0x4
	// Bit mask of BUFLM4 field.
	CAN0_IMASK1_BUFLM4_Msk = 0x10
	// Bit BUFLM4.
	CAN0_IMASK1_BUFLM4 = 0x10
	// The corresponding buffer Interrupt is disabled.
	CAN0_IMASK1_BUFLM4_0 = 0x0
	// The corresponding buffer Interrupt is enabled.
	CAN0_IMASK1_BUFLM4_1 = 0x1
	// Position of BUFLM5 field.
	CAN0_IMASK1_BUFLM5_Pos = 0x5
	// Bit mask of BUFLM5 field.
	CAN0_IMASK1_BUFLM5_Msk = 0x20
	// Bit BUFLM5.
	CAN0_IMASK1_BUFLM5 = 0x20
	// The corresponding buffer Interrupt is disabled.
	CAN0_IMASK1_BUFLM5_0 = 0x0
	// The corresponding buffer Interrupt is enabled.
	CAN0_IMASK1_BUFLM5_1 = 0x1
	// Position of BUFLM6 field.
	CAN0_IMASK1_BUFLM6_Pos = 0x6
	// Bit mask of BUFLM6 field.
	CAN0_IMASK1_BUFLM6_Msk = 0x40
	// Bit BUFLM6.
	CAN0_IMASK1_BUFLM6 = 0x40
	// The corresponding buffer Interrupt is disabled.
	CAN0_IMASK1_BUFLM6_0 = 0x0
	// The corresponding buffer Interrupt is enabled.
	CAN0_IMASK1_BUFLM6_1 = 0x1
	// Position of BUFLM7 field.
	CAN0_IMASK1_BUFLM7_Pos = 0x7
	// Bit mask of BUFLM7 field.
	CAN0_IMASK1_BUFLM7_Msk = 0x80
	// Bit BUFLM7.
	CAN0_IMASK1_BUFLM7 = 0x80
	// The corresponding buffer Interrupt is disabled.
	CAN0_IMASK1_BUFLM7_0 = 0x0
	// The corresponding buffer Interrupt is enabled.
	CAN0_IMASK1_BUFLM7_1 = 0x1
	// Position of BUFLM8 field.
	CAN0_IMASK1_BUFLM8_Pos = 0x8
	// Bit mask of BUFLM8 field.
	CAN0_IMASK1_BUFLM8_Msk = 0x100
	// Bit BUFLM8.
	CAN0_IMASK1_BUFLM8 = 0x100
	// The corresponding buffer Interrupt is disabled.
	CAN0_IMASK1_BUFLM8_0 = 0x0
	// The corresponding buffer Interrupt is enabled.
	CAN0_IMASK1_BUFLM8_1 = 0x1
	// Position of BUFLM9 field.
	CAN0_IMASK1_BUFLM9_Pos = 0x9
	// Bit mask of BUFLM9 field.
	CAN0_IMASK1_BUFLM9_Msk = 0x200
	// Bit BUFLM9.
	CAN0_IMASK1_BUFLM9 = 0x200
	// The corresponding buffer Interrupt is disabled.
	CAN0_IMASK1_BUFLM9_0 = 0x0
	// The corresponding buffer Interrupt is enabled.
	CAN0_IMASK1_BUFLM9_1 = 0x1
	// Position of BUFLM10 field.
	CAN0_IMASK1_BUFLM10_Pos = 0xa
	// Bit mask of BUFLM10 field.
	CAN0_IMASK1_BUFLM10_Msk = 0x400
	// Bit BUFLM10.
	CAN0_IMASK1_BUFLM10 = 0x400
	// The corresponding buffer Interrupt is disabled.
	CAN0_IMASK1_BUFLM10_0 = 0x0
	// The corresponding buffer Interrupt is enabled.
	CAN0_IMASK1_BUFLM10_1 = 0x1
	// Position of BUFLM11 field.
	CAN0_IMASK1_BUFLM11_Pos = 0xb
	// Bit mask of BUFLM11 field.
	CAN0_IMASK1_BUFLM11_Msk = 0x800
	// Bit BUFLM11.
	CAN0_IMASK1_BUFLM11 = 0x800
	// The corresponding buffer Interrupt is disabled.
	CAN0_IMASK1_BUFLM11_0 = 0x0
	// The corresponding buffer Interrupt is enabled.
	CAN0_IMASK1_BUFLM11_1 = 0x1
	// Position of BUFLM12 field.
	CAN0_IMASK1_BUFLM12_Pos = 0xc
	// Bit mask of BUFLM12 field.
	CAN0_IMASK1_BUFLM12_Msk = 0x1000
	// Bit BUFLM12.
	CAN0_IMASK1_BUFLM12 = 0x1000
	// The corresponding buffer Interrupt is disabled.
	CAN0_IMASK1_BUFLM12_0 = 0x0
	// The corresponding buffer Interrupt is enabled.
	CAN0_IMASK1_BUFLM12_1 = 0x1
	// Position of BUFLM13 field.
	CAN0_IMASK1_BUFLM13_Pos = 0xd
	// Bit mask of BUFLM13 field.
	CAN0_IMASK1_BUFLM13_Msk = 0x2000
	// Bit BUFLM13.
	CAN0_IMASK1_BUFLM13 = 0x2000
	// The corresponding buffer Interrupt is disabled.
	CAN0_IMASK1_BUFLM13_0 = 0x0
	// The corresponding buffer Interrupt is enabled.
	CAN0_IMASK1_BUFLM13_1 = 0x1
	// Position of BUFLM14 field.
	CAN0_IMASK1_BUFLM14_Pos = 0xe
	// Bit mask of BUFLM14 field.
	CAN0_IMASK1_BUFLM14_Msk = 0x4000
	// Bit BUFLM14.
	CAN0_IMASK1_BUFLM14 = 0x4000
	// The corresponding buffer Interrupt is disabled.
	CAN0_IMASK1_BUFLM14_0 = 0x0
	// The corresponding buffer Interrupt is enabled.
	CAN0_IMASK1_BUFLM14_1 = 0x1
	// Position of BUFLM15 field.
	CAN0_IMASK1_BUFLM15_Pos = 0xf
	// Bit mask of BUFLM15 field.
	CAN0_IMASK1_BUFLM15_Msk = 0x8000
	// Bit BUFLM15.
	CAN0_IMASK1_BUFLM15 = 0x8000
	// The corresponding buffer Interrupt is disabled.
	CAN0_IMASK1_BUFLM15_0 = 0x0
	// The corresponding buffer Interrupt is enabled.
	CAN0_IMASK1_BUFLM15_1 = 0x1
	// Position of BUFLM16 field.
	CAN0_IMASK1_BUFLM16_Pos = 0x10
	// Bit mask of BUFLM16 field.
	CAN0_IMASK1_BUFLM16_Msk = 0x10000
	// Bit BUFLM16.
	CAN0_IMASK1_BUFLM16 = 0x10000
	// The corresponding buffer Interrupt is disabled.
	CAN0_IMASK1_BUFLM16_0 = 0x0
	// The corresponding buffer Interrupt is enabled.
	CAN0_IMASK1_BUFLM16_1 = 0x1
	// Position of BUFLM17 field.
	CAN0_IMASK1_BUFLM17_Pos = 0x11
	// Bit mask of BUFLM17 field.
	CAN0_IMASK1_BUFLM17_Msk = 0x20000
	// Bit BUFLM17.
	CAN0_IMASK1_BUFLM17 = 0x20000
	// The corresponding buffer Interrupt is disabled.
	CAN0_IMASK1_BUFLM17_0 = 0x0
	// The corresponding buffer Interrupt is enabled.
	CAN0_IMASK1_BUFLM17_1 = 0x1
	// Position of BUFLM18 field.
	CAN0_IMASK1_BUFLM18_Pos = 0x12
	// Bit mask of BUFLM18 field.
	CAN0_IMASK1_BUFLM18_Msk = 0x40000
	// Bit BUFLM18.
	CAN0_IMASK1_BUFLM18 = 0x40000
	// The corresponding buffer Interrupt is disabled.
	CAN0_IMASK1_BUFLM18_0 = 0x0
	// The corresponding buffer Interrupt is enabled.
	CAN0_IMASK1_BUFLM18_1 = 0x1
	// Position of BUFLM19 field.
	CAN0_IMASK1_BUFLM19_Pos = 0x13
	// Bit mask of BUFLM19 field.
	CAN0_IMASK1_BUFLM19_Msk = 0x80000
	// Bit BUFLM19.
	CAN0_IMASK1_BUFLM19 = 0x80000
	// The corresponding buffer Interrupt is disabled.
	CAN0_IMASK1_BUFLM19_0 = 0x0
	// The corresponding buffer Interrupt is enabled.
	CAN0_IMASK1_BUFLM19_1 = 0x1
	// Position of BUFLM20 field.
	CAN0_IMASK1_BUFLM20_Pos = 0x14
	// Bit mask of BUFLM20 field.
	CAN0_IMASK1_BUFLM20_Msk = 0x100000
	// Bit BUFLM20.
	CAN0_IMASK1_BUFLM20 = 0x100000
	// The corresponding buffer Interrupt is disabled.
	CAN0_IMASK1_BUFLM20_0 = 0x0
	// The corresponding buffer Interrupt is enabled.
	CAN0_IMASK1_BUFLM20_1 = 0x1
	// Position of BUFLM21 field.
	CAN0_IMASK1_BUFLM21_Pos = 0x15
	// Bit mask of BUFLM21 field.
	CAN0_IMASK1_BUFLM21_Msk = 0x200000
	// Bit BUFLM21.
	CAN0_IMASK1_BUFLM21 = 0x200000
	// The corresponding buffer Interrupt is disabled.
	CAN0_IMASK1_BUFLM21_0 = 0x0
	// The corresponding buffer Interrupt is enabled.
	CAN0_IMASK1_BUFLM21_1 = 0x1
	// Position of BUFLM22 field.
	CAN0_IMASK1_BUFLM22_Pos = 0x16
	// Bit mask of BUFLM22 field.
	CAN0_IMASK1_BUFLM22_Msk = 0x400000
	// Bit BUFLM22.
	CAN0_IMASK1_BUFLM22 = 0x400000
	// The corresponding buffer Interrupt is disabled.
	CAN0_IMASK1_BUFLM22_0 = 0x0
	// The corresponding buffer Interrupt is enabled.
	CAN0_IMASK1_BUFLM22_1 = 0x1
	// Position of BUFLM23 field.
	CAN0_IMASK1_BUFLM23_Pos = 0x17
	// Bit mask of BUFLM23 field.
	CAN0_IMASK1_BUFLM23_Msk = 0x800000
	// Bit BUFLM23.
	CAN0_IMASK1_BUFLM23 = 0x800000
	// The corresponding buffer Interrupt is disabled.
	CAN0_IMASK1_BUFLM23_0 = 0x0
	// The corresponding buffer Interrupt is enabled.
	CAN0_IMASK1_BUFLM23_1 = 0x1
	// Position of BUFLM24 field.
	CAN0_IMASK1_BUFLM24_Pos = 0x18
	// Bit mask of BUFLM24 field.
	CAN0_IMASK1_BUFLM24_Msk = 0x1000000
	// Bit BUFLM24.
	CAN0_IMASK1_BUFLM24 = 0x1000000
	// The corresponding buffer Interrupt is disabled.
	CAN0_IMASK1_BUFLM24_0 = 0x0
	// The corresponding buffer Interrupt is enabled.
	CAN0_IMASK1_BUFLM24_1 = 0x1
	// Position of BUFLM25 field.
	CAN0_IMASK1_BUFLM25_Pos = 0x19
	// Bit mask of BUFLM25 field.
	CAN0_IMASK1_BUFLM25_Msk = 0x2000000
	// Bit BUFLM25.
	CAN0_IMASK1_BUFLM25 = 0x2000000
	// The corresponding buffer Interrupt is disabled.
	CAN0_IMASK1_BUFLM25_0 = 0x0
	// The corresponding buffer Interrupt is enabled.
	CAN0_IMASK1_BUFLM25_1 = 0x1
	// Position of BUFLM26 field.
	CAN0_IMASK1_BUFLM26_Pos = 0x1a
	// Bit mask of BUFLM26 field.
	CAN0_IMASK1_BUFLM26_Msk = 0x4000000
	// Bit BUFLM26.
	CAN0_IMASK1_BUFLM26 = 0x4000000
	// The corresponding buffer Interrupt is disabled.
	CAN0_IMASK1_BUFLM26_0 = 0x0
	// The corresponding buffer Interrupt is enabled.
	CAN0_IMASK1_BUFLM26_1 = 0x1
	// Position of BUFLM27 field.
	CAN0_IMASK1_BUFLM27_Pos = 0x1b
	// Bit mask of BUFLM27 field.
	CAN0_IMASK1_BUFLM27_Msk = 0x8000000
	// Bit BUFLM27.
	CAN0_IMASK1_BUFLM27 = 0x8000000
	// The corresponding buffer Interrupt is disabled.
	CAN0_IMASK1_BUFLM27_0 = 0x0
	// The corresponding buffer Interrupt is enabled.
	CAN0_IMASK1_BUFLM27_1 = 0x1
	// Position of BUFLM28 field.
	CAN0_IMASK1_BUFLM28_Pos = 0x1c
	// Bit mask of BUFLM28 field.
	CAN0_IMASK1_BUFLM28_Msk = 0x10000000
	// Bit BUFLM28.
	CAN0_IMASK1_BUFLM28 = 0x10000000
	// The corresponding buffer Interrupt is disabled.
	CAN0_IMASK1_BUFLM28_0 = 0x0
	// The corresponding buffer Interrupt is enabled.
	CAN0_IMASK1_BUFLM28_1 = 0x1
	// Position of BUFLM29 field.
	CAN0_IMASK1_BUFLM29_Pos = 0x1d
	// Bit mask of BUFLM29 field.
	CAN0_IMASK1_BUFLM29_Msk = 0x20000000
	// Bit BUFLM29.
	CAN0_IMASK1_BUFLM29 = 0x20000000
	// The corresponding buffer Interrupt is disabled.
	CAN0_IMASK1_BUFLM29_0 = 0x0
	// The corresponding buffer Interrupt is enabled.
	CAN0_IMASK1_BUFLM29_1 = 0x1
	// Position of BUFLM30 field.
	CAN0_IMASK1_BUFLM30_Pos = 0x1e
	// Bit mask of BUFLM30 field.
	CAN0_IMASK1_BUFLM30_Msk = 0x40000000
	// Bit BUFLM30.
	CAN0_IMASK1_BUFLM30 = 0x40000000
	// The corresponding buffer Interrupt is disabled.
	CAN0_IMASK1_BUFLM30_0 = 0x0
	// The corresponding buffer Interrupt is enabled.
	CAN0_IMASK1_BUFLM30_1 = 0x1
	// Position of BUFLM31 field.
	CAN0_IMASK1_BUFLM31_Pos = 0x1f
	// Bit mask of BUFLM31 field.
	CAN0_IMASK1_BUFLM31_Msk = 0x80000000
	// Bit BUFLM31.
	CAN0_IMASK1_BUFLM31 = 0x80000000
	// The corresponding buffer Interrupt is disabled.
	CAN0_IMASK1_BUFLM31_0 = 0x0
	// The corresponding buffer Interrupt is enabled.
	CAN0_IMASK1_BUFLM31_1 = 0x1

	// IFLAG1: Interrupt Flags 1 register
	// Position of BUF0I field.
	CAN0_IFLAG1_BUF0I_Pos = 0x0
	// Bit mask of BUF0I field.
	CAN0_IFLAG1_BUF0I_Msk = 0x1
	// Bit BUF0I.
	CAN0_IFLAG1_BUF0I = 0x1
	// The corresponding buffer has no occurrence of successfully completed transmission or reception when MCR[RFEN]=0.
	CAN0_IFLAG1_BUF0I_0 = 0x0
	// The corresponding buffer has successfully completed transmission or reception when MCR[RFEN]=0.
	CAN0_IFLAG1_BUF0I_1 = 0x1
	// Position of BUF4TO1I0 field.
	CAN0_IFLAG1_BUF4TO1I0_Pos = 0x1
	// Bit mask of BUF4TO1I0 field.
	CAN0_IFLAG1_BUF4TO1I0_Msk = 0x2
	// Bit BUF4TO1I0.
	CAN0_IFLAG1_BUF4TO1I0 = 0x2
	// The corresponding buffer has no occurrence of successfully completed transmission or reception when MCR[RFEN]=0.
	CAN0_IFLAG1_BUF4TO1I0_0 = 0x0
	// The corresponding buffer has successfully completed transmission or reception when MCR[RFEN]=0.
	CAN0_IFLAG1_BUF4TO1I0_1 = 0x1
	// Position of BUF4TO1I1 field.
	CAN0_IFLAG1_BUF4TO1I1_Pos = 0x2
	// Bit mask of BUF4TO1I1 field.
	CAN0_IFLAG1_BUF4TO1I1_Msk = 0x4
	// Bit BUF4TO1I1.
	CAN0_IFLAG1_BUF4TO1I1 = 0x4
	// The corresponding buffer has no occurrence of successfully completed transmission or reception when MCR[RFEN]=0.
	CAN0_IFLAG1_BUF4TO1I1_0 = 0x0
	// The corresponding buffer has successfully completed transmission or reception when MCR[RFEN]=0.
	CAN0_IFLAG1_BUF4TO1I1_1 = 0x1
	// Position of BUF4TO1I2 field.
	CAN0_IFLAG1_BUF4TO1I2_Pos = 0x3
	// Bit mask of BUF4TO1I2 field.
	CAN0_IFLAG1_BUF4TO1I2_Msk = 0x8
	// Bit BUF4TO1I2.
	CAN0_IFLAG1_BUF4TO1I2 = 0x8
	// The corresponding buffer has no occurrence of successfully completed transmission or reception when MCR[RFEN]=0.
	CAN0_IFLAG1_BUF4TO1I2_0 = 0x0
	// The corresponding buffer has successfully completed transmission or reception when MCR[RFEN]=0.
	CAN0_IFLAG1_BUF4TO1I2_1 = 0x1
	// Position of BUF4TO1I3 field.
	CAN0_IFLAG1_BUF4TO1I3_Pos = 0x4
	// Bit mask of BUF4TO1I3 field.
	CAN0_IFLAG1_BUF4TO1I3_Msk = 0x10
	// Bit BUF4TO1I3.
	CAN0_IFLAG1_BUF4TO1I3 = 0x10
	// The corresponding buffer has no occurrence of successfully completed transmission or reception when MCR[RFEN]=0.
	CAN0_IFLAG1_BUF4TO1I3_0 = 0x0
	// The corresponding buffer has successfully completed transmission or reception when MCR[RFEN]=0.
	CAN0_IFLAG1_BUF4TO1I3_1 = 0x1
	// Position of BUF5I field.
	CAN0_IFLAG1_BUF5I_Pos = 0x5
	// Bit mask of BUF5I field.
	CAN0_IFLAG1_BUF5I_Msk = 0x20
	// Bit BUF5I.
	CAN0_IFLAG1_BUF5I = 0x20
	// No occurrence of MB5 completing transmission/reception when MCR[RFEN]=0, or of frame(s) available in the FIFO, when MCR[RFEN]=1
	CAN0_IFLAG1_BUF5I_0 = 0x0
	// MB5 completed transmission/reception when MCR[RFEN]=0, or frame(s) available in the Rx FIFO when MCR[RFEN]=1
	CAN0_IFLAG1_BUF5I_1 = 0x1
	// Position of BUF6I field.
	CAN0_IFLAG1_BUF6I_Pos = 0x6
	// Bit mask of BUF6I field.
	CAN0_IFLAG1_BUF6I_Msk = 0x40
	// Bit BUF6I.
	CAN0_IFLAG1_BUF6I = 0x40
	// No occurrence of MB6 completing transmission/reception when MCR[RFEN]=0, or of Rx FIFO almost full when MCR[RFEN]=1
	CAN0_IFLAG1_BUF6I_0 = 0x0
	// MB6 completed transmission/reception when MCR[RFEN]=0, or Rx FIFO almost full when MCR[RFEN]=1
	CAN0_IFLAG1_BUF6I_1 = 0x1
	// Position of BUF7I field.
	CAN0_IFLAG1_BUF7I_Pos = 0x7
	// Bit mask of BUF7I field.
	CAN0_IFLAG1_BUF7I_Msk = 0x80
	// Bit BUF7I.
	CAN0_IFLAG1_BUF7I = 0x80
	// No occurrence of MB7 completing transmission/reception when MCR[RFEN]=0, or of Rx FIFO overflow when MCR[RFEN]=1
	CAN0_IFLAG1_BUF7I_0 = 0x0
	// MB7 completed transmission/reception when MCR[RFEN]=0, or Rx FIFO overflow when MCR[RFEN]=1
	CAN0_IFLAG1_BUF7I_1 = 0x1
	// Position of BUF31TO8I0 field.
	CAN0_IFLAG1_BUF31TO8I0_Pos = 0x8
	// Bit mask of BUF31TO8I0 field.
	CAN0_IFLAG1_BUF31TO8I0_Msk = 0x100
	// Bit BUF31TO8I0.
	CAN0_IFLAG1_BUF31TO8I0 = 0x100
	// The corresponding buffer has no occurrence of successfully completed transmission or reception.
	CAN0_IFLAG1_BUF31TO8I0_0 = 0x0
	// The corresponding buffer has successfully completed transmission or reception.
	CAN0_IFLAG1_BUF31TO8I0_1 = 0x1
	// Position of BUF31TO8I1 field.
	CAN0_IFLAG1_BUF31TO8I1_Pos = 0x9
	// Bit mask of BUF31TO8I1 field.
	CAN0_IFLAG1_BUF31TO8I1_Msk = 0x200
	// Bit BUF31TO8I1.
	CAN0_IFLAG1_BUF31TO8I1 = 0x200
	// The corresponding buffer has no occurrence of successfully completed transmission or reception.
	CAN0_IFLAG1_BUF31TO8I1_0 = 0x0
	// The corresponding buffer has successfully completed transmission or reception.
	CAN0_IFLAG1_BUF31TO8I1_1 = 0x1
	// Position of BUF31TO8I2 field.
	CAN0_IFLAG1_BUF31TO8I2_Pos = 0xa
	// Bit mask of BUF31TO8I2 field.
	CAN0_IFLAG1_BUF31TO8I2_Msk = 0x400
	// Bit BUF31TO8I2.
	CAN0_IFLAG1_BUF31TO8I2 = 0x400
	// The corresponding buffer has no occurrence of successfully completed transmission or reception.
	CAN0_IFLAG1_BUF31TO8I2_0 = 0x0
	// The corresponding buffer has successfully completed transmission or reception.
	CAN0_IFLAG1_BUF31TO8I2_1 = 0x1
	// Position of BUF31TO8I3 field.
	CAN0_IFLAG1_BUF31TO8I3_Pos = 0xb
	// Bit mask of BUF31TO8I3 field.
	CAN0_IFLAG1_BUF31TO8I3_Msk = 0x800
	// Bit BUF31TO8I3.
	CAN0_IFLAG1_BUF31TO8I3 = 0x800
	// The corresponding buffer has no occurrence of successfully completed transmission or reception.
	CAN0_IFLAG1_BUF31TO8I3_0 = 0x0
	// The corresponding buffer has successfully completed transmission or reception.
	CAN0_IFLAG1_BUF31TO8I3_1 = 0x1
	// Position of BUF31TO8I4 field.
	CAN0_IFLAG1_BUF31TO8I4_Pos = 0xc
	// Bit mask of BUF31TO8I4 field.
	CAN0_IFLAG1_BUF31TO8I4_Msk = 0x1000
	// Bit BUF31TO8I4.
	CAN0_IFLAG1_BUF31TO8I4 = 0x1000
	// The corresponding buffer has no occurrence of successfully completed transmission or reception.
	CAN0_IFLAG1_BUF31TO8I4_0 = 0x0
	// The corresponding buffer has successfully completed transmission or reception.
	CAN0_IFLAG1_BUF31TO8I4_1 = 0x1
	// Position of BUF31TO8I5 field.
	CAN0_IFLAG1_BUF31TO8I5_Pos = 0xd
	// Bit mask of BUF31TO8I5 field.
	CAN0_IFLAG1_BUF31TO8I5_Msk = 0x2000
	// Bit BUF31TO8I5.
	CAN0_IFLAG1_BUF31TO8I5 = 0x2000
	// The corresponding buffer has no occurrence of successfully completed transmission or reception.
	CAN0_IFLAG1_BUF31TO8I5_0 = 0x0
	// The corresponding buffer has successfully completed transmission or reception.
	CAN0_IFLAG1_BUF31TO8I5_1 = 0x1
	// Position of BUF31TO8I6 field.
	CAN0_IFLAG1_BUF31TO8I6_Pos = 0xe
	// Bit mask of BUF31TO8I6 field.
	CAN0_IFLAG1_BUF31TO8I6_Msk = 0x4000
	// Bit BUF31TO8I6.
	CAN0_IFLAG1_BUF31TO8I6 = 0x4000
	// The corresponding buffer has no occurrence of successfully completed transmission or reception.
	CAN0_IFLAG1_BUF31TO8I6_0 = 0x0
	// The corresponding buffer has successfully completed transmission or reception.
	CAN0_IFLAG1_BUF31TO8I6_1 = 0x1
	// Position of BUF31TO8I7 field.
	CAN0_IFLAG1_BUF31TO8I7_Pos = 0xf
	// Bit mask of BUF31TO8I7 field.
	CAN0_IFLAG1_BUF31TO8I7_Msk = 0x8000
	// Bit BUF31TO8I7.
	CAN0_IFLAG1_BUF31TO8I7 = 0x8000
	// The corresponding buffer has no occurrence of successfully completed transmission or reception.
	CAN0_IFLAG1_BUF31TO8I7_0 = 0x0
	// The corresponding buffer has successfully completed transmission or reception.
	CAN0_IFLAG1_BUF31TO8I7_1 = 0x1
	// Position of BUF31TO8I8 field.
	CAN0_IFLAG1_BUF31TO8I8_Pos = 0x10
	// Bit mask of BUF31TO8I8 field.
	CAN0_IFLAG1_BUF31TO8I8_Msk = 0x10000
	// Bit BUF31TO8I8.
	CAN0_IFLAG1_BUF31TO8I8 = 0x10000
	// The corresponding buffer has no occurrence of successfully completed transmission or reception.
	CAN0_IFLAG1_BUF31TO8I8_0 = 0x0
	// The corresponding buffer has successfully completed transmission or reception.
	CAN0_IFLAG1_BUF31TO8I8_1 = 0x1
	// Position of BUF31TO8I9 field.
	CAN0_IFLAG1_BUF31TO8I9_Pos = 0x11
	// Bit mask of BUF31TO8I9 field.
	CAN0_IFLAG1_BUF31TO8I9_Msk = 0x20000
	// Bit BUF31TO8I9.
	CAN0_IFLAG1_BUF31TO8I9 = 0x20000
	// The corresponding buffer has no occurrence of successfully completed transmission or reception.
	CAN0_IFLAG1_BUF31TO8I9_0 = 0x0
	// The corresponding buffer has successfully completed transmission or reception.
	CAN0_IFLAG1_BUF31TO8I9_1 = 0x1
	// Position of BUF31TO8I10 field.
	CAN0_IFLAG1_BUF31TO8I10_Pos = 0x12
	// Bit mask of BUF31TO8I10 field.
	CAN0_IFLAG1_BUF31TO8I10_Msk = 0x40000
	// Bit BUF31TO8I10.
	CAN0_IFLAG1_BUF31TO8I10 = 0x40000
	// The corresponding buffer has no occurrence of successfully completed transmission or reception.
	CAN0_IFLAG1_BUF31TO8I10_0 = 0x0
	// The corresponding buffer has successfully completed transmission or reception.
	CAN0_IFLAG1_BUF31TO8I10_1 = 0x1
	// Position of BUF31TO8I11 field.
	CAN0_IFLAG1_BUF31TO8I11_Pos = 0x13
	// Bit mask of BUF31TO8I11 field.
	CAN0_IFLAG1_BUF31TO8I11_Msk = 0x80000
	// Bit BUF31TO8I11.
	CAN0_IFLAG1_BUF31TO8I11 = 0x80000
	// The corresponding buffer has no occurrence of successfully completed transmission or reception.
	CAN0_IFLAG1_BUF31TO8I11_0 = 0x0
	// The corresponding buffer has successfully completed transmission or reception.
	CAN0_IFLAG1_BUF31TO8I11_1 = 0x1
	// Position of BUF31TO8I12 field.
	CAN0_IFLAG1_BUF31TO8I12_Pos = 0x14
	// Bit mask of BUF31TO8I12 field.
	CAN0_IFLAG1_BUF31TO8I12_Msk = 0x100000
	// Bit BUF31TO8I12.
	CAN0_IFLAG1_BUF31TO8I12 = 0x100000
	// The corresponding buffer has no occurrence of successfully completed transmission or reception.
	CAN0_IFLAG1_BUF31TO8I12_0 = 0x0
	// The corresponding buffer has successfully completed transmission or reception.
	CAN0_IFLAG1_BUF31TO8I12_1 = 0x1
	// Position of BUF31TO8I13 field.
	CAN0_IFLAG1_BUF31TO8I13_Pos = 0x15
	// Bit mask of BUF31TO8I13 field.
	CAN0_IFLAG1_BUF31TO8I13_Msk = 0x200000
	// Bit BUF31TO8I13.
	CAN0_IFLAG1_BUF31TO8I13 = 0x200000
	// The corresponding buffer has no occurrence of successfully completed transmission or reception.
	CAN0_IFLAG1_BUF31TO8I13_0 = 0x0
	// The corresponding buffer has successfully completed transmission or reception.
	CAN0_IFLAG1_BUF31TO8I13_1 = 0x1
	// Position of BUF31TO8I14 field.
	CAN0_IFLAG1_BUF31TO8I14_Pos = 0x16
	// Bit mask of BUF31TO8I14 field.
	CAN0_IFLAG1_BUF31TO8I14_Msk = 0x400000
	// Bit BUF31TO8I14.
	CAN0_IFLAG1_BUF31TO8I14 = 0x400000
	// The corresponding buffer has no occurrence of successfully completed transmission or reception.
	CAN0_IFLAG1_BUF31TO8I14_0 = 0x0
	// The corresponding buffer has successfully completed transmission or reception.
	CAN0_IFLAG1_BUF31TO8I14_1 = 0x1
	// Position of BUF31TO8I15 field.
	CAN0_IFLAG1_BUF31TO8I15_Pos = 0x17
	// Bit mask of BUF31TO8I15 field.
	CAN0_IFLAG1_BUF31TO8I15_Msk = 0x800000
	// Bit BUF31TO8I15.
	CAN0_IFLAG1_BUF31TO8I15 = 0x800000
	// The corresponding buffer has no occurrence of successfully completed transmission or reception.
	CAN0_IFLAG1_BUF31TO8I15_0 = 0x0
	// The corresponding buffer has successfully completed transmission or reception.
	CAN0_IFLAG1_BUF31TO8I15_1 = 0x1
	// Position of BUF31TO8I16 field.
	CAN0_IFLAG1_BUF31TO8I16_Pos = 0x18
	// Bit mask of BUF31TO8I16 field.
	CAN0_IFLAG1_BUF31TO8I16_Msk = 0x1000000
	// Bit BUF31TO8I16.
	CAN0_IFLAG1_BUF31TO8I16 = 0x1000000
	// The corresponding buffer has no occurrence of successfully completed transmission or reception.
	CAN0_IFLAG1_BUF31TO8I16_0 = 0x0
	// The corresponding buffer has successfully completed transmission or reception.
	CAN0_IFLAG1_BUF31TO8I16_1 = 0x1
	// Position of BUF31TO8I17 field.
	CAN0_IFLAG1_BUF31TO8I17_Pos = 0x19
	// Bit mask of BUF31TO8I17 field.
	CAN0_IFLAG1_BUF31TO8I17_Msk = 0x2000000
	// Bit BUF31TO8I17.
	CAN0_IFLAG1_BUF31TO8I17 = 0x2000000
	// The corresponding buffer has no occurrence of successfully completed transmission or reception.
	CAN0_IFLAG1_BUF31TO8I17_0 = 0x0
	// The corresponding buffer has successfully completed transmission or reception.
	CAN0_IFLAG1_BUF31TO8I17_1 = 0x1
	// Position of BUF31TO8I18 field.
	CAN0_IFLAG1_BUF31TO8I18_Pos = 0x1a
	// Bit mask of BUF31TO8I18 field.
	CAN0_IFLAG1_BUF31TO8I18_Msk = 0x4000000
	// Bit BUF31TO8I18.
	CAN0_IFLAG1_BUF31TO8I18 = 0x4000000
	// The corresponding buffer has no occurrence of successfully completed transmission or reception.
	CAN0_IFLAG1_BUF31TO8I18_0 = 0x0
	// The corresponding buffer has successfully completed transmission or reception.
	CAN0_IFLAG1_BUF31TO8I18_1 = 0x1
	// Position of BUF31TO8I19 field.
	CAN0_IFLAG1_BUF31TO8I19_Pos = 0x1b
	// Bit mask of BUF31TO8I19 field.
	CAN0_IFLAG1_BUF31TO8I19_Msk = 0x8000000
	// Bit BUF31TO8I19.
	CAN0_IFLAG1_BUF31TO8I19 = 0x8000000
	// The corresponding buffer has no occurrence of successfully completed transmission or reception.
	CAN0_IFLAG1_BUF31TO8I19_0 = 0x0
	// The corresponding buffer has successfully completed transmission or reception.
	CAN0_IFLAG1_BUF31TO8I19_1 = 0x1
	// Position of BUF31TO8I20 field.
	CAN0_IFLAG1_BUF31TO8I20_Pos = 0x1c
	// Bit mask of BUF31TO8I20 field.
	CAN0_IFLAG1_BUF31TO8I20_Msk = 0x10000000
	// Bit BUF31TO8I20.
	CAN0_IFLAG1_BUF31TO8I20 = 0x10000000
	// The corresponding buffer has no occurrence of successfully completed transmission or reception.
	CAN0_IFLAG1_BUF31TO8I20_0 = 0x0
	// The corresponding buffer has successfully completed transmission or reception.
	CAN0_IFLAG1_BUF31TO8I20_1 = 0x1
	// Position of BUF31TO8I21 field.
	CAN0_IFLAG1_BUF31TO8I21_Pos = 0x1d
	// Bit mask of BUF31TO8I21 field.
	CAN0_IFLAG1_BUF31TO8I21_Msk = 0x20000000
	// Bit BUF31TO8I21.
	CAN0_IFLAG1_BUF31TO8I21 = 0x20000000
	// The corresponding buffer has no occurrence of successfully completed transmission or reception.
	CAN0_IFLAG1_BUF31TO8I21_0 = 0x0
	// The corresponding buffer has successfully completed transmission or reception.
	CAN0_IFLAG1_BUF31TO8I21_1 = 0x1
	// Position of BUF31TO8I22 field.
	CAN0_IFLAG1_BUF31TO8I22_Pos = 0x1e
	// Bit mask of BUF31TO8I22 field.
	CAN0_IFLAG1_BUF31TO8I22_Msk = 0x40000000
	// Bit BUF31TO8I22.
	CAN0_IFLAG1_BUF31TO8I22 = 0x40000000
	// The corresponding buffer has no occurrence of successfully completed transmission or reception.
	CAN0_IFLAG1_BUF31TO8I22_0 = 0x0
	// The corresponding buffer has successfully completed transmission or reception.
	CAN0_IFLAG1_BUF31TO8I22_1 = 0x1
	// Position of BUF31TO8I23 field.
	CAN0_IFLAG1_BUF31TO8I23_Pos = 0x1f
	// Bit mask of BUF31TO8I23 field.
	CAN0_IFLAG1_BUF31TO8I23_Msk = 0x80000000
	// Bit BUF31TO8I23.
	CAN0_IFLAG1_BUF31TO8I23 = 0x80000000
	// The corresponding buffer has no occurrence of successfully completed transmission or reception.
	CAN0_IFLAG1_BUF31TO8I23_0 = 0x0
	// The corresponding buffer has successfully completed transmission or reception.
	CAN0_IFLAG1_BUF31TO8I23_1 = 0x1

	// CTRL2: Control 2 register
	// Position of EACEN field.
	CAN0_CTRL2_EACEN_Pos = 0x10
	// Bit mask of EACEN field.
	CAN0_CTRL2_EACEN_Msk = 0x10000
	// Bit EACEN.
	CAN0_CTRL2_EACEN = 0x10000
	// Rx Mailbox filter's IDE bit is always compared and RTR is never compared despite mask bits.
	CAN0_CTRL2_EACEN_0 = 0x0
	// Enables the comparison of both Rx Mailbox filter's IDE and RTR bit with their corresponding bits within the incoming frame. Mask bits do apply.
	CAN0_CTRL2_EACEN_1 = 0x1
	// Position of RRS field.
	CAN0_CTRL2_RRS_Pos = 0x11
	// Bit mask of RRS field.
	CAN0_CTRL2_RRS_Msk = 0x20000
	// Bit RRS.
	CAN0_CTRL2_RRS = 0x20000
	// Remote Response Frame is generated.
	CAN0_CTRL2_RRS_0 = 0x0
	// Remote Request Frame is stored.
	CAN0_CTRL2_RRS_1 = 0x1
	// Position of MRP field.
	CAN0_CTRL2_MRP_Pos = 0x12
	// Bit mask of MRP field.
	CAN0_CTRL2_MRP_Msk = 0x40000
	// Bit MRP.
	CAN0_CTRL2_MRP = 0x40000
	// Matching starts from Rx FIFO and continues on Mailboxes.
	CAN0_CTRL2_MRP_0 = 0x0
	// Matching starts from Mailboxes and continues on Rx FIFO.
	CAN0_CTRL2_MRP_1 = 0x1
	// Position of TASD field.
	CAN0_CTRL2_TASD_Pos = 0x13
	// Bit mask of TASD field.
	CAN0_CTRL2_TASD_Msk = 0xf80000
	// Position of RFFN field.
	CAN0_CTRL2_RFFN_Pos = 0x18
	// Bit mask of RFFN field.
	CAN0_CTRL2_RFFN_Msk = 0xf000000
	// Position of WRMFRZ field.
	CAN0_CTRL2_WRMFRZ_Pos = 0x1c
	// Bit mask of WRMFRZ field.
	CAN0_CTRL2_WRMFRZ_Msk = 0x10000000
	// Bit WRMFRZ.
	CAN0_CTRL2_WRMFRZ = 0x10000000
	// Maintain the write access restrictions.
	CAN0_CTRL2_WRMFRZ_0 = 0x0
	// Enable unrestricted write access to FlexCAN memory.
	CAN0_CTRL2_WRMFRZ_1 = 0x1

	// ESR2: Error and Status 2 register
	// Position of IMB field.
	CAN0_ESR2_IMB_Pos = 0xd
	// Bit mask of IMB field.
	CAN0_ESR2_IMB_Msk = 0x2000
	// Bit IMB.
	CAN0_ESR2_IMB = 0x2000
	// If ESR2[VPS] is asserted, the ESR2[LPTM] is not an inactive Mailbox.
	CAN0_ESR2_IMB_0 = 0x0
	// If ESR2[VPS] is asserted, there is at least one inactive Mailbox. LPTM content is the number of the first one.
	CAN0_ESR2_IMB_1 = 0x1
	// Position of VPS field.
	CAN0_ESR2_VPS_Pos = 0xe
	// Bit mask of VPS field.
	CAN0_ESR2_VPS_Msk = 0x4000
	// Bit VPS.
	CAN0_ESR2_VPS = 0x4000
	// Contents of IMB and LPTM are invalid.
	CAN0_ESR2_VPS_0 = 0x0
	// Contents of IMB and LPTM are valid.
	CAN0_ESR2_VPS_1 = 0x1
	// Position of LPTM field.
	CAN0_ESR2_LPTM_Pos = 0x10
	// Bit mask of LPTM field.
	CAN0_ESR2_LPTM_Msk = 0x7f0000

	// CRCR: CRC Register
	// Position of TXCRC field.
	CAN0_CRCR_TXCRC_Pos = 0x0
	// Bit mask of TXCRC field.
	CAN0_CRCR_TXCRC_Msk = 0x7fff
	// Position of MBCRC field.
	CAN0_CRCR_MBCRC_Pos = 0x10
	// Bit mask of MBCRC field.
	CAN0_CRCR_MBCRC_Msk = 0x7f0000

	// RXFGMASK: Rx FIFO Global Mask register
	// Position of FGM0 field.
	CAN0_RXFGMASK_FGM0_Pos = 0x0
	// Bit mask of FGM0 field.
	CAN0_RXFGMASK_FGM0_Msk = 0x1
	// Bit FGM0.
	CAN0_RXFGMASK_FGM0 = 0x1
	// The corresponding bit in the filter is "don't care."
	CAN0_RXFGMASK_FGM0_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXFGMASK_FGM0_1 = 0x1
	// Position of FGM1 field.
	CAN0_RXFGMASK_FGM1_Pos = 0x1
	// Bit mask of FGM1 field.
	CAN0_RXFGMASK_FGM1_Msk = 0x2
	// Bit FGM1.
	CAN0_RXFGMASK_FGM1 = 0x2
	// The corresponding bit in the filter is "don't care."
	CAN0_RXFGMASK_FGM1_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXFGMASK_FGM1_1 = 0x1
	// Position of FGM2 field.
	CAN0_RXFGMASK_FGM2_Pos = 0x2
	// Bit mask of FGM2 field.
	CAN0_RXFGMASK_FGM2_Msk = 0x4
	// Bit FGM2.
	CAN0_RXFGMASK_FGM2 = 0x4
	// The corresponding bit in the filter is "don't care."
	CAN0_RXFGMASK_FGM2_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXFGMASK_FGM2_1 = 0x1
	// Position of FGM3 field.
	CAN0_RXFGMASK_FGM3_Pos = 0x3
	// Bit mask of FGM3 field.
	CAN0_RXFGMASK_FGM3_Msk = 0x8
	// Bit FGM3.
	CAN0_RXFGMASK_FGM3 = 0x8
	// The corresponding bit in the filter is "don't care."
	CAN0_RXFGMASK_FGM3_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXFGMASK_FGM3_1 = 0x1
	// Position of FGM4 field.
	CAN0_RXFGMASK_FGM4_Pos = 0x4
	// Bit mask of FGM4 field.
	CAN0_RXFGMASK_FGM4_Msk = 0x10
	// Bit FGM4.
	CAN0_RXFGMASK_FGM4 = 0x10
	// The corresponding bit in the filter is "don't care."
	CAN0_RXFGMASK_FGM4_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXFGMASK_FGM4_1 = 0x1
	// Position of FGM5 field.
	CAN0_RXFGMASK_FGM5_Pos = 0x5
	// Bit mask of FGM5 field.
	CAN0_RXFGMASK_FGM5_Msk = 0x20
	// Bit FGM5.
	CAN0_RXFGMASK_FGM5 = 0x20
	// The corresponding bit in the filter is "don't care."
	CAN0_RXFGMASK_FGM5_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXFGMASK_FGM5_1 = 0x1
	// Position of FGM6 field.
	CAN0_RXFGMASK_FGM6_Pos = 0x6
	// Bit mask of FGM6 field.
	CAN0_RXFGMASK_FGM6_Msk = 0x40
	// Bit FGM6.
	CAN0_RXFGMASK_FGM6 = 0x40
	// The corresponding bit in the filter is "don't care."
	CAN0_RXFGMASK_FGM6_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXFGMASK_FGM6_1 = 0x1
	// Position of FGM7 field.
	CAN0_RXFGMASK_FGM7_Pos = 0x7
	// Bit mask of FGM7 field.
	CAN0_RXFGMASK_FGM7_Msk = 0x80
	// Bit FGM7.
	CAN0_RXFGMASK_FGM7 = 0x80
	// The corresponding bit in the filter is "don't care."
	CAN0_RXFGMASK_FGM7_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXFGMASK_FGM7_1 = 0x1
	// Position of FGM8 field.
	CAN0_RXFGMASK_FGM8_Pos = 0x8
	// Bit mask of FGM8 field.
	CAN0_RXFGMASK_FGM8_Msk = 0x100
	// Bit FGM8.
	CAN0_RXFGMASK_FGM8 = 0x100
	// The corresponding bit in the filter is "don't care."
	CAN0_RXFGMASK_FGM8_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXFGMASK_FGM8_1 = 0x1
	// Position of FGM9 field.
	CAN0_RXFGMASK_FGM9_Pos = 0x9
	// Bit mask of FGM9 field.
	CAN0_RXFGMASK_FGM9_Msk = 0x200
	// Bit FGM9.
	CAN0_RXFGMASK_FGM9 = 0x200
	// The corresponding bit in the filter is "don't care."
	CAN0_RXFGMASK_FGM9_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXFGMASK_FGM9_1 = 0x1
	// Position of FGM10 field.
	CAN0_RXFGMASK_FGM10_Pos = 0xa
	// Bit mask of FGM10 field.
	CAN0_RXFGMASK_FGM10_Msk = 0x400
	// Bit FGM10.
	CAN0_RXFGMASK_FGM10 = 0x400
	// The corresponding bit in the filter is "don't care."
	CAN0_RXFGMASK_FGM10_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXFGMASK_FGM10_1 = 0x1
	// Position of FGM11 field.
	CAN0_RXFGMASK_FGM11_Pos = 0xb
	// Bit mask of FGM11 field.
	CAN0_RXFGMASK_FGM11_Msk = 0x800
	// Bit FGM11.
	CAN0_RXFGMASK_FGM11 = 0x800
	// The corresponding bit in the filter is "don't care."
	CAN0_RXFGMASK_FGM11_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXFGMASK_FGM11_1 = 0x1
	// Position of FGM12 field.
	CAN0_RXFGMASK_FGM12_Pos = 0xc
	// Bit mask of FGM12 field.
	CAN0_RXFGMASK_FGM12_Msk = 0x1000
	// Bit FGM12.
	CAN0_RXFGMASK_FGM12 = 0x1000
	// The corresponding bit in the filter is "don't care."
	CAN0_RXFGMASK_FGM12_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXFGMASK_FGM12_1 = 0x1
	// Position of FGM13 field.
	CAN0_RXFGMASK_FGM13_Pos = 0xd
	// Bit mask of FGM13 field.
	CAN0_RXFGMASK_FGM13_Msk = 0x2000
	// Bit FGM13.
	CAN0_RXFGMASK_FGM13 = 0x2000
	// The corresponding bit in the filter is "don't care."
	CAN0_RXFGMASK_FGM13_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXFGMASK_FGM13_1 = 0x1
	// Position of FGM14 field.
	CAN0_RXFGMASK_FGM14_Pos = 0xe
	// Bit mask of FGM14 field.
	CAN0_RXFGMASK_FGM14_Msk = 0x4000
	// Bit FGM14.
	CAN0_RXFGMASK_FGM14 = 0x4000
	// The corresponding bit in the filter is "don't care."
	CAN0_RXFGMASK_FGM14_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXFGMASK_FGM14_1 = 0x1
	// Position of FGM15 field.
	CAN0_RXFGMASK_FGM15_Pos = 0xf
	// Bit mask of FGM15 field.
	CAN0_RXFGMASK_FGM15_Msk = 0x8000
	// Bit FGM15.
	CAN0_RXFGMASK_FGM15 = 0x8000
	// The corresponding bit in the filter is "don't care."
	CAN0_RXFGMASK_FGM15_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXFGMASK_FGM15_1 = 0x1
	// Position of FGM16 field.
	CAN0_RXFGMASK_FGM16_Pos = 0x10
	// Bit mask of FGM16 field.
	CAN0_RXFGMASK_FGM16_Msk = 0x10000
	// Bit FGM16.
	CAN0_RXFGMASK_FGM16 = 0x10000
	// The corresponding bit in the filter is "don't care."
	CAN0_RXFGMASK_FGM16_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXFGMASK_FGM16_1 = 0x1
	// Position of FGM17 field.
	CAN0_RXFGMASK_FGM17_Pos = 0x11
	// Bit mask of FGM17 field.
	CAN0_RXFGMASK_FGM17_Msk = 0x20000
	// Bit FGM17.
	CAN0_RXFGMASK_FGM17 = 0x20000
	// The corresponding bit in the filter is "don't care."
	CAN0_RXFGMASK_FGM17_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXFGMASK_FGM17_1 = 0x1
	// Position of FGM18 field.
	CAN0_RXFGMASK_FGM18_Pos = 0x12
	// Bit mask of FGM18 field.
	CAN0_RXFGMASK_FGM18_Msk = 0x40000
	// Bit FGM18.
	CAN0_RXFGMASK_FGM18 = 0x40000
	// The corresponding bit in the filter is "don't care."
	CAN0_RXFGMASK_FGM18_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXFGMASK_FGM18_1 = 0x1
	// Position of FGM19 field.
	CAN0_RXFGMASK_FGM19_Pos = 0x13
	// Bit mask of FGM19 field.
	CAN0_RXFGMASK_FGM19_Msk = 0x80000
	// Bit FGM19.
	CAN0_RXFGMASK_FGM19 = 0x80000
	// The corresponding bit in the filter is "don't care."
	CAN0_RXFGMASK_FGM19_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXFGMASK_FGM19_1 = 0x1
	// Position of FGM20 field.
	CAN0_RXFGMASK_FGM20_Pos = 0x14
	// Bit mask of FGM20 field.
	CAN0_RXFGMASK_FGM20_Msk = 0x100000
	// Bit FGM20.
	CAN0_RXFGMASK_FGM20 = 0x100000
	// The corresponding bit in the filter is "don't care."
	CAN0_RXFGMASK_FGM20_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXFGMASK_FGM20_1 = 0x1
	// Position of FGM21 field.
	CAN0_RXFGMASK_FGM21_Pos = 0x15
	// Bit mask of FGM21 field.
	CAN0_RXFGMASK_FGM21_Msk = 0x200000
	// Bit FGM21.
	CAN0_RXFGMASK_FGM21 = 0x200000
	// The corresponding bit in the filter is "don't care."
	CAN0_RXFGMASK_FGM21_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXFGMASK_FGM21_1 = 0x1
	// Position of FGM22 field.
	CAN0_RXFGMASK_FGM22_Pos = 0x16
	// Bit mask of FGM22 field.
	CAN0_RXFGMASK_FGM22_Msk = 0x400000
	// Bit FGM22.
	CAN0_RXFGMASK_FGM22 = 0x400000
	// The corresponding bit in the filter is "don't care."
	CAN0_RXFGMASK_FGM22_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXFGMASK_FGM22_1 = 0x1
	// Position of FGM23 field.
	CAN0_RXFGMASK_FGM23_Pos = 0x17
	// Bit mask of FGM23 field.
	CAN0_RXFGMASK_FGM23_Msk = 0x800000
	// Bit FGM23.
	CAN0_RXFGMASK_FGM23 = 0x800000
	// The corresponding bit in the filter is "don't care."
	CAN0_RXFGMASK_FGM23_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXFGMASK_FGM23_1 = 0x1
	// Position of FGM24 field.
	CAN0_RXFGMASK_FGM24_Pos = 0x18
	// Bit mask of FGM24 field.
	CAN0_RXFGMASK_FGM24_Msk = 0x1000000
	// Bit FGM24.
	CAN0_RXFGMASK_FGM24 = 0x1000000
	// The corresponding bit in the filter is "don't care."
	CAN0_RXFGMASK_FGM24_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXFGMASK_FGM24_1 = 0x1
	// Position of FGM25 field.
	CAN0_RXFGMASK_FGM25_Pos = 0x19
	// Bit mask of FGM25 field.
	CAN0_RXFGMASK_FGM25_Msk = 0x2000000
	// Bit FGM25.
	CAN0_RXFGMASK_FGM25 = 0x2000000
	// The corresponding bit in the filter is "don't care."
	CAN0_RXFGMASK_FGM25_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXFGMASK_FGM25_1 = 0x1
	// Position of FGM26 field.
	CAN0_RXFGMASK_FGM26_Pos = 0x1a
	// Bit mask of FGM26 field.
	CAN0_RXFGMASK_FGM26_Msk = 0x4000000
	// Bit FGM26.
	CAN0_RXFGMASK_FGM26 = 0x4000000
	// The corresponding bit in the filter is "don't care."
	CAN0_RXFGMASK_FGM26_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXFGMASK_FGM26_1 = 0x1
	// Position of FGM27 field.
	CAN0_RXFGMASK_FGM27_Pos = 0x1b
	// Bit mask of FGM27 field.
	CAN0_RXFGMASK_FGM27_Msk = 0x8000000
	// Bit FGM27.
	CAN0_RXFGMASK_FGM27 = 0x8000000
	// The corresponding bit in the filter is "don't care."
	CAN0_RXFGMASK_FGM27_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXFGMASK_FGM27_1 = 0x1
	// Position of FGM28 field.
	CAN0_RXFGMASK_FGM28_Pos = 0x1c
	// Bit mask of FGM28 field.
	CAN0_RXFGMASK_FGM28_Msk = 0x10000000
	// Bit FGM28.
	CAN0_RXFGMASK_FGM28 = 0x10000000
	// The corresponding bit in the filter is "don't care."
	CAN0_RXFGMASK_FGM28_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXFGMASK_FGM28_1 = 0x1
	// Position of FGM29 field.
	CAN0_RXFGMASK_FGM29_Pos = 0x1d
	// Bit mask of FGM29 field.
	CAN0_RXFGMASK_FGM29_Msk = 0x20000000
	// Bit FGM29.
	CAN0_RXFGMASK_FGM29 = 0x20000000
	// The corresponding bit in the filter is "don't care."
	CAN0_RXFGMASK_FGM29_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXFGMASK_FGM29_1 = 0x1
	// Position of FGM30 field.
	CAN0_RXFGMASK_FGM30_Pos = 0x1e
	// Bit mask of FGM30 field.
	CAN0_RXFGMASK_FGM30_Msk = 0x40000000
	// Bit FGM30.
	CAN0_RXFGMASK_FGM30 = 0x40000000
	// The corresponding bit in the filter is "don't care."
	CAN0_RXFGMASK_FGM30_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXFGMASK_FGM30_1 = 0x1
	// Position of FGM31 field.
	CAN0_RXFGMASK_FGM31_Pos = 0x1f
	// Bit mask of FGM31 field.
	CAN0_RXFGMASK_FGM31_Msk = 0x80000000
	// Bit FGM31.
	CAN0_RXFGMASK_FGM31 = 0x80000000
	// The corresponding bit in the filter is "don't care."
	CAN0_RXFGMASK_FGM31_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXFGMASK_FGM31_1 = 0x1

	// RXFIR: Rx FIFO Information Register
	// Position of IDHIT field.
	CAN0_RXFIR_IDHIT_Pos = 0x0
	// Bit mask of IDHIT field.
	CAN0_RXFIR_IDHIT_Msk = 0x1ff

	// CS0: Message Buffer 0 CS Register
	// Position of TIME_STAMP field.
	CAN0_CS0_TIME_STAMP_Pos = 0x0
	// Bit mask of TIME_STAMP field.
	CAN0_CS0_TIME_STAMP_Msk = 0xffff
	// Position of DLC field.
	CAN0_CS0_DLC_Pos = 0x10
	// Bit mask of DLC field.
	CAN0_CS0_DLC_Msk = 0xf0000
	// Position of RTR field.
	CAN0_CS0_RTR_Pos = 0x14
	// Bit mask of RTR field.
	CAN0_CS0_RTR_Msk = 0x100000
	// Bit RTR.
	CAN0_CS0_RTR = 0x100000
	// Position of IDE field.
	CAN0_CS0_IDE_Pos = 0x15
	// Bit mask of IDE field.
	CAN0_CS0_IDE_Msk = 0x200000
	// Bit IDE.
	CAN0_CS0_IDE = 0x200000
	// Position of SRR field.
	CAN0_CS0_SRR_Pos = 0x16
	// Bit mask of SRR field.
	CAN0_CS0_SRR_Msk = 0x400000
	// Bit SRR.
	CAN0_CS0_SRR = 0x400000
	// Position of CODE field.
	CAN0_CS0_CODE_Pos = 0x18
	// Bit mask of CODE field.
	CAN0_CS0_CODE_Msk = 0xf000000

	// ID0: Message Buffer 0 ID Register
	// Position of EXT field.
	CAN0_ID0_EXT_Pos = 0x0
	// Bit mask of EXT field.
	CAN0_ID0_EXT_Msk = 0x3ffff
	// Position of STD field.
	CAN0_ID0_STD_Pos = 0x12
	// Bit mask of STD field.
	CAN0_ID0_STD_Msk = 0x1ffc0000
	// Position of PRIO field.
	CAN0_ID0_PRIO_Pos = 0x1d
	// Bit mask of PRIO field.
	CAN0_ID0_PRIO_Msk = 0xe0000000

	// WORD00: Message Buffer 0 WORD0 Register
	// Position of DATA_BYTE_3 field.
	CAN0_WORD00_DATA_BYTE_3_Pos = 0x0
	// Bit mask of DATA_BYTE_3 field.
	CAN0_WORD00_DATA_BYTE_3_Msk = 0xff
	// Position of DATA_BYTE_2 field.
	CAN0_WORD00_DATA_BYTE_2_Pos = 0x8
	// Bit mask of DATA_BYTE_2 field.
	CAN0_WORD00_DATA_BYTE_2_Msk = 0xff00
	// Position of DATA_BYTE_1 field.
	CAN0_WORD00_DATA_BYTE_1_Pos = 0x10
	// Bit mask of DATA_BYTE_1 field.
	CAN0_WORD00_DATA_BYTE_1_Msk = 0xff0000
	// Position of DATA_BYTE_0 field.
	CAN0_WORD00_DATA_BYTE_0_Pos = 0x18
	// Bit mask of DATA_BYTE_0 field.
	CAN0_WORD00_DATA_BYTE_0_Msk = 0xff000000

	// WORD10: Message Buffer 0 WORD1 Register
	// Position of DATA_BYTE_7 field.
	CAN0_WORD10_DATA_BYTE_7_Pos = 0x0
	// Bit mask of DATA_BYTE_7 field.
	CAN0_WORD10_DATA_BYTE_7_Msk = 0xff
	// Position of DATA_BYTE_6 field.
	CAN0_WORD10_DATA_BYTE_6_Pos = 0x8
	// Bit mask of DATA_BYTE_6 field.
	CAN0_WORD10_DATA_BYTE_6_Msk = 0xff00
	// Position of DATA_BYTE_5 field.
	CAN0_WORD10_DATA_BYTE_5_Pos = 0x10
	// Bit mask of DATA_BYTE_5 field.
	CAN0_WORD10_DATA_BYTE_5_Msk = 0xff0000
	// Position of DATA_BYTE_4 field.
	CAN0_WORD10_DATA_BYTE_4_Pos = 0x18
	// Bit mask of DATA_BYTE_4 field.
	CAN0_WORD10_DATA_BYTE_4_Msk = 0xff000000

	// CS1: Message Buffer 1 CS Register
	// Position of TIME_STAMP field.
	CAN0_CS1_TIME_STAMP_Pos = 0x0
	// Bit mask of TIME_STAMP field.
	CAN0_CS1_TIME_STAMP_Msk = 0xffff
	// Position of DLC field.
	CAN0_CS1_DLC_Pos = 0x10
	// Bit mask of DLC field.
	CAN0_CS1_DLC_Msk = 0xf0000
	// Position of RTR field.
	CAN0_CS1_RTR_Pos = 0x14
	// Bit mask of RTR field.
	CAN0_CS1_RTR_Msk = 0x100000
	// Bit RTR.
	CAN0_CS1_RTR = 0x100000
	// Position of IDE field.
	CAN0_CS1_IDE_Pos = 0x15
	// Bit mask of IDE field.
	CAN0_CS1_IDE_Msk = 0x200000
	// Bit IDE.
	CAN0_CS1_IDE = 0x200000
	// Position of SRR field.
	CAN0_CS1_SRR_Pos = 0x16
	// Bit mask of SRR field.
	CAN0_CS1_SRR_Msk = 0x400000
	// Bit SRR.
	CAN0_CS1_SRR = 0x400000
	// Position of CODE field.
	CAN0_CS1_CODE_Pos = 0x18
	// Bit mask of CODE field.
	CAN0_CS1_CODE_Msk = 0xf000000

	// ID1: Message Buffer 1 ID Register
	// Position of EXT field.
	CAN0_ID1_EXT_Pos = 0x0
	// Bit mask of EXT field.
	CAN0_ID1_EXT_Msk = 0x3ffff
	// Position of STD field.
	CAN0_ID1_STD_Pos = 0x12
	// Bit mask of STD field.
	CAN0_ID1_STD_Msk = 0x1ffc0000
	// Position of PRIO field.
	CAN0_ID1_PRIO_Pos = 0x1d
	// Bit mask of PRIO field.
	CAN0_ID1_PRIO_Msk = 0xe0000000

	// WORD01: Message Buffer 1 WORD0 Register
	// Position of DATA_BYTE_3 field.
	CAN0_WORD01_DATA_BYTE_3_Pos = 0x0
	// Bit mask of DATA_BYTE_3 field.
	CAN0_WORD01_DATA_BYTE_3_Msk = 0xff
	// Position of DATA_BYTE_2 field.
	CAN0_WORD01_DATA_BYTE_2_Pos = 0x8
	// Bit mask of DATA_BYTE_2 field.
	CAN0_WORD01_DATA_BYTE_2_Msk = 0xff00
	// Position of DATA_BYTE_1 field.
	CAN0_WORD01_DATA_BYTE_1_Pos = 0x10
	// Bit mask of DATA_BYTE_1 field.
	CAN0_WORD01_DATA_BYTE_1_Msk = 0xff0000
	// Position of DATA_BYTE_0 field.
	CAN0_WORD01_DATA_BYTE_0_Pos = 0x18
	// Bit mask of DATA_BYTE_0 field.
	CAN0_WORD01_DATA_BYTE_0_Msk = 0xff000000

	// WORD11: Message Buffer 1 WORD1 Register
	// Position of DATA_BYTE_7 field.
	CAN0_WORD11_DATA_BYTE_7_Pos = 0x0
	// Bit mask of DATA_BYTE_7 field.
	CAN0_WORD11_DATA_BYTE_7_Msk = 0xff
	// Position of DATA_BYTE_6 field.
	CAN0_WORD11_DATA_BYTE_6_Pos = 0x8
	// Bit mask of DATA_BYTE_6 field.
	CAN0_WORD11_DATA_BYTE_6_Msk = 0xff00
	// Position of DATA_BYTE_5 field.
	CAN0_WORD11_DATA_BYTE_5_Pos = 0x10
	// Bit mask of DATA_BYTE_5 field.
	CAN0_WORD11_DATA_BYTE_5_Msk = 0xff0000
	// Position of DATA_BYTE_4 field.
	CAN0_WORD11_DATA_BYTE_4_Pos = 0x18
	// Bit mask of DATA_BYTE_4 field.
	CAN0_WORD11_DATA_BYTE_4_Msk = 0xff000000

	// CS2: Message Buffer 2 CS Register
	// Position of TIME_STAMP field.
	CAN0_CS2_TIME_STAMP_Pos = 0x0
	// Bit mask of TIME_STAMP field.
	CAN0_CS2_TIME_STAMP_Msk = 0xffff
	// Position of DLC field.
	CAN0_CS2_DLC_Pos = 0x10
	// Bit mask of DLC field.
	CAN0_CS2_DLC_Msk = 0xf0000
	// Position of RTR field.
	CAN0_CS2_RTR_Pos = 0x14
	// Bit mask of RTR field.
	CAN0_CS2_RTR_Msk = 0x100000
	// Bit RTR.
	CAN0_CS2_RTR = 0x100000
	// Position of IDE field.
	CAN0_CS2_IDE_Pos = 0x15
	// Bit mask of IDE field.
	CAN0_CS2_IDE_Msk = 0x200000
	// Bit IDE.
	CAN0_CS2_IDE = 0x200000
	// Position of SRR field.
	CAN0_CS2_SRR_Pos = 0x16
	// Bit mask of SRR field.
	CAN0_CS2_SRR_Msk = 0x400000
	// Bit SRR.
	CAN0_CS2_SRR = 0x400000
	// Position of CODE field.
	CAN0_CS2_CODE_Pos = 0x18
	// Bit mask of CODE field.
	CAN0_CS2_CODE_Msk = 0xf000000

	// ID2: Message Buffer 2 ID Register
	// Position of EXT field.
	CAN0_ID2_EXT_Pos = 0x0
	// Bit mask of EXT field.
	CAN0_ID2_EXT_Msk = 0x3ffff
	// Position of STD field.
	CAN0_ID2_STD_Pos = 0x12
	// Bit mask of STD field.
	CAN0_ID2_STD_Msk = 0x1ffc0000
	// Position of PRIO field.
	CAN0_ID2_PRIO_Pos = 0x1d
	// Bit mask of PRIO field.
	CAN0_ID2_PRIO_Msk = 0xe0000000

	// WORD02: Message Buffer 2 WORD0 Register
	// Position of DATA_BYTE_3 field.
	CAN0_WORD02_DATA_BYTE_3_Pos = 0x0
	// Bit mask of DATA_BYTE_3 field.
	CAN0_WORD02_DATA_BYTE_3_Msk = 0xff
	// Position of DATA_BYTE_2 field.
	CAN0_WORD02_DATA_BYTE_2_Pos = 0x8
	// Bit mask of DATA_BYTE_2 field.
	CAN0_WORD02_DATA_BYTE_2_Msk = 0xff00
	// Position of DATA_BYTE_1 field.
	CAN0_WORD02_DATA_BYTE_1_Pos = 0x10
	// Bit mask of DATA_BYTE_1 field.
	CAN0_WORD02_DATA_BYTE_1_Msk = 0xff0000
	// Position of DATA_BYTE_0 field.
	CAN0_WORD02_DATA_BYTE_0_Pos = 0x18
	// Bit mask of DATA_BYTE_0 field.
	CAN0_WORD02_DATA_BYTE_0_Msk = 0xff000000

	// WORD12: Message Buffer 2 WORD1 Register
	// Position of DATA_BYTE_7 field.
	CAN0_WORD12_DATA_BYTE_7_Pos = 0x0
	// Bit mask of DATA_BYTE_7 field.
	CAN0_WORD12_DATA_BYTE_7_Msk = 0xff
	// Position of DATA_BYTE_6 field.
	CAN0_WORD12_DATA_BYTE_6_Pos = 0x8
	// Bit mask of DATA_BYTE_6 field.
	CAN0_WORD12_DATA_BYTE_6_Msk = 0xff00
	// Position of DATA_BYTE_5 field.
	CAN0_WORD12_DATA_BYTE_5_Pos = 0x10
	// Bit mask of DATA_BYTE_5 field.
	CAN0_WORD12_DATA_BYTE_5_Msk = 0xff0000
	// Position of DATA_BYTE_4 field.
	CAN0_WORD12_DATA_BYTE_4_Pos = 0x18
	// Bit mask of DATA_BYTE_4 field.
	CAN0_WORD12_DATA_BYTE_4_Msk = 0xff000000

	// CS3: Message Buffer 3 CS Register
	// Position of TIME_STAMP field.
	CAN0_CS3_TIME_STAMP_Pos = 0x0
	// Bit mask of TIME_STAMP field.
	CAN0_CS3_TIME_STAMP_Msk = 0xffff
	// Position of DLC field.
	CAN0_CS3_DLC_Pos = 0x10
	// Bit mask of DLC field.
	CAN0_CS3_DLC_Msk = 0xf0000
	// Position of RTR field.
	CAN0_CS3_RTR_Pos = 0x14
	// Bit mask of RTR field.
	CAN0_CS3_RTR_Msk = 0x100000
	// Bit RTR.
	CAN0_CS3_RTR = 0x100000
	// Position of IDE field.
	CAN0_CS3_IDE_Pos = 0x15
	// Bit mask of IDE field.
	CAN0_CS3_IDE_Msk = 0x200000
	// Bit IDE.
	CAN0_CS3_IDE = 0x200000
	// Position of SRR field.
	CAN0_CS3_SRR_Pos = 0x16
	// Bit mask of SRR field.
	CAN0_CS3_SRR_Msk = 0x400000
	// Bit SRR.
	CAN0_CS3_SRR = 0x400000
	// Position of CODE field.
	CAN0_CS3_CODE_Pos = 0x18
	// Bit mask of CODE field.
	CAN0_CS3_CODE_Msk = 0xf000000

	// ID3: Message Buffer 3 ID Register
	// Position of EXT field.
	CAN0_ID3_EXT_Pos = 0x0
	// Bit mask of EXT field.
	CAN0_ID3_EXT_Msk = 0x3ffff
	// Position of STD field.
	CAN0_ID3_STD_Pos = 0x12
	// Bit mask of STD field.
	CAN0_ID3_STD_Msk = 0x1ffc0000
	// Position of PRIO field.
	CAN0_ID3_PRIO_Pos = 0x1d
	// Bit mask of PRIO field.
	CAN0_ID3_PRIO_Msk = 0xe0000000

	// WORD03: Message Buffer 3 WORD0 Register
	// Position of DATA_BYTE_3 field.
	CAN0_WORD03_DATA_BYTE_3_Pos = 0x0
	// Bit mask of DATA_BYTE_3 field.
	CAN0_WORD03_DATA_BYTE_3_Msk = 0xff
	// Position of DATA_BYTE_2 field.
	CAN0_WORD03_DATA_BYTE_2_Pos = 0x8
	// Bit mask of DATA_BYTE_2 field.
	CAN0_WORD03_DATA_BYTE_2_Msk = 0xff00
	// Position of DATA_BYTE_1 field.
	CAN0_WORD03_DATA_BYTE_1_Pos = 0x10
	// Bit mask of DATA_BYTE_1 field.
	CAN0_WORD03_DATA_BYTE_1_Msk = 0xff0000
	// Position of DATA_BYTE_0 field.
	CAN0_WORD03_DATA_BYTE_0_Pos = 0x18
	// Bit mask of DATA_BYTE_0 field.
	CAN0_WORD03_DATA_BYTE_0_Msk = 0xff000000

	// WORD13: Message Buffer 3 WORD1 Register
	// Position of DATA_BYTE_7 field.
	CAN0_WORD13_DATA_BYTE_7_Pos = 0x0
	// Bit mask of DATA_BYTE_7 field.
	CAN0_WORD13_DATA_BYTE_7_Msk = 0xff
	// Position of DATA_BYTE_6 field.
	CAN0_WORD13_DATA_BYTE_6_Pos = 0x8
	// Bit mask of DATA_BYTE_6 field.
	CAN0_WORD13_DATA_BYTE_6_Msk = 0xff00
	// Position of DATA_BYTE_5 field.
	CAN0_WORD13_DATA_BYTE_5_Pos = 0x10
	// Bit mask of DATA_BYTE_5 field.
	CAN0_WORD13_DATA_BYTE_5_Msk = 0xff0000
	// Position of DATA_BYTE_4 field.
	CAN0_WORD13_DATA_BYTE_4_Pos = 0x18
	// Bit mask of DATA_BYTE_4 field.
	CAN0_WORD13_DATA_BYTE_4_Msk = 0xff000000

	// CS4: Message Buffer 4 CS Register
	// Position of TIME_STAMP field.
	CAN0_CS4_TIME_STAMP_Pos = 0x0
	// Bit mask of TIME_STAMP field.
	CAN0_CS4_TIME_STAMP_Msk = 0xffff
	// Position of DLC field.
	CAN0_CS4_DLC_Pos = 0x10
	// Bit mask of DLC field.
	CAN0_CS4_DLC_Msk = 0xf0000
	// Position of RTR field.
	CAN0_CS4_RTR_Pos = 0x14
	// Bit mask of RTR field.
	CAN0_CS4_RTR_Msk = 0x100000
	// Bit RTR.
	CAN0_CS4_RTR = 0x100000
	// Position of IDE field.
	CAN0_CS4_IDE_Pos = 0x15
	// Bit mask of IDE field.
	CAN0_CS4_IDE_Msk = 0x200000
	// Bit IDE.
	CAN0_CS4_IDE = 0x200000
	// Position of SRR field.
	CAN0_CS4_SRR_Pos = 0x16
	// Bit mask of SRR field.
	CAN0_CS4_SRR_Msk = 0x400000
	// Bit SRR.
	CAN0_CS4_SRR = 0x400000
	// Position of CODE field.
	CAN0_CS4_CODE_Pos = 0x18
	// Bit mask of CODE field.
	CAN0_CS4_CODE_Msk = 0xf000000

	// ID4: Message Buffer 4 ID Register
	// Position of EXT field.
	CAN0_ID4_EXT_Pos = 0x0
	// Bit mask of EXT field.
	CAN0_ID4_EXT_Msk = 0x3ffff
	// Position of STD field.
	CAN0_ID4_STD_Pos = 0x12
	// Bit mask of STD field.
	CAN0_ID4_STD_Msk = 0x1ffc0000
	// Position of PRIO field.
	CAN0_ID4_PRIO_Pos = 0x1d
	// Bit mask of PRIO field.
	CAN0_ID4_PRIO_Msk = 0xe0000000

	// WORD04: Message Buffer 4 WORD0 Register
	// Position of DATA_BYTE_3 field.
	CAN0_WORD04_DATA_BYTE_3_Pos = 0x0
	// Bit mask of DATA_BYTE_3 field.
	CAN0_WORD04_DATA_BYTE_3_Msk = 0xff
	// Position of DATA_BYTE_2 field.
	CAN0_WORD04_DATA_BYTE_2_Pos = 0x8
	// Bit mask of DATA_BYTE_2 field.
	CAN0_WORD04_DATA_BYTE_2_Msk = 0xff00
	// Position of DATA_BYTE_1 field.
	CAN0_WORD04_DATA_BYTE_1_Pos = 0x10
	// Bit mask of DATA_BYTE_1 field.
	CAN0_WORD04_DATA_BYTE_1_Msk = 0xff0000
	// Position of DATA_BYTE_0 field.
	CAN0_WORD04_DATA_BYTE_0_Pos = 0x18
	// Bit mask of DATA_BYTE_0 field.
	CAN0_WORD04_DATA_BYTE_0_Msk = 0xff000000

	// WORD14: Message Buffer 4 WORD1 Register
	// Position of DATA_BYTE_7 field.
	CAN0_WORD14_DATA_BYTE_7_Pos = 0x0
	// Bit mask of DATA_BYTE_7 field.
	CAN0_WORD14_DATA_BYTE_7_Msk = 0xff
	// Position of DATA_BYTE_6 field.
	CAN0_WORD14_DATA_BYTE_6_Pos = 0x8
	// Bit mask of DATA_BYTE_6 field.
	CAN0_WORD14_DATA_BYTE_6_Msk = 0xff00
	// Position of DATA_BYTE_5 field.
	CAN0_WORD14_DATA_BYTE_5_Pos = 0x10
	// Bit mask of DATA_BYTE_5 field.
	CAN0_WORD14_DATA_BYTE_5_Msk = 0xff0000
	// Position of DATA_BYTE_4 field.
	CAN0_WORD14_DATA_BYTE_4_Pos = 0x18
	// Bit mask of DATA_BYTE_4 field.
	CAN0_WORD14_DATA_BYTE_4_Msk = 0xff000000

	// CS5: Message Buffer 5 CS Register
	// Position of TIME_STAMP field.
	CAN0_CS5_TIME_STAMP_Pos = 0x0
	// Bit mask of TIME_STAMP field.
	CAN0_CS5_TIME_STAMP_Msk = 0xffff
	// Position of DLC field.
	CAN0_CS5_DLC_Pos = 0x10
	// Bit mask of DLC field.
	CAN0_CS5_DLC_Msk = 0xf0000
	// Position of RTR field.
	CAN0_CS5_RTR_Pos = 0x14
	// Bit mask of RTR field.
	CAN0_CS5_RTR_Msk = 0x100000
	// Bit RTR.
	CAN0_CS5_RTR = 0x100000
	// Position of IDE field.
	CAN0_CS5_IDE_Pos = 0x15
	// Bit mask of IDE field.
	CAN0_CS5_IDE_Msk = 0x200000
	// Bit IDE.
	CAN0_CS5_IDE = 0x200000
	// Position of SRR field.
	CAN0_CS5_SRR_Pos = 0x16
	// Bit mask of SRR field.
	CAN0_CS5_SRR_Msk = 0x400000
	// Bit SRR.
	CAN0_CS5_SRR = 0x400000
	// Position of CODE field.
	CAN0_CS5_CODE_Pos = 0x18
	// Bit mask of CODE field.
	CAN0_CS5_CODE_Msk = 0xf000000

	// ID5: Message Buffer 5 ID Register
	// Position of EXT field.
	CAN0_ID5_EXT_Pos = 0x0
	// Bit mask of EXT field.
	CAN0_ID5_EXT_Msk = 0x3ffff
	// Position of STD field.
	CAN0_ID5_STD_Pos = 0x12
	// Bit mask of STD field.
	CAN0_ID5_STD_Msk = 0x1ffc0000
	// Position of PRIO field.
	CAN0_ID5_PRIO_Pos = 0x1d
	// Bit mask of PRIO field.
	CAN0_ID5_PRIO_Msk = 0xe0000000

	// WORD05: Message Buffer 5 WORD0 Register
	// Position of DATA_BYTE_3 field.
	CAN0_WORD05_DATA_BYTE_3_Pos = 0x0
	// Bit mask of DATA_BYTE_3 field.
	CAN0_WORD05_DATA_BYTE_3_Msk = 0xff
	// Position of DATA_BYTE_2 field.
	CAN0_WORD05_DATA_BYTE_2_Pos = 0x8
	// Bit mask of DATA_BYTE_2 field.
	CAN0_WORD05_DATA_BYTE_2_Msk = 0xff00
	// Position of DATA_BYTE_1 field.
	CAN0_WORD05_DATA_BYTE_1_Pos = 0x10
	// Bit mask of DATA_BYTE_1 field.
	CAN0_WORD05_DATA_BYTE_1_Msk = 0xff0000
	// Position of DATA_BYTE_0 field.
	CAN0_WORD05_DATA_BYTE_0_Pos = 0x18
	// Bit mask of DATA_BYTE_0 field.
	CAN0_WORD05_DATA_BYTE_0_Msk = 0xff000000

	// WORD15: Message Buffer 5 WORD1 Register
	// Position of DATA_BYTE_7 field.
	CAN0_WORD15_DATA_BYTE_7_Pos = 0x0
	// Bit mask of DATA_BYTE_7 field.
	CAN0_WORD15_DATA_BYTE_7_Msk = 0xff
	// Position of DATA_BYTE_6 field.
	CAN0_WORD15_DATA_BYTE_6_Pos = 0x8
	// Bit mask of DATA_BYTE_6 field.
	CAN0_WORD15_DATA_BYTE_6_Msk = 0xff00
	// Position of DATA_BYTE_5 field.
	CAN0_WORD15_DATA_BYTE_5_Pos = 0x10
	// Bit mask of DATA_BYTE_5 field.
	CAN0_WORD15_DATA_BYTE_5_Msk = 0xff0000
	// Position of DATA_BYTE_4 field.
	CAN0_WORD15_DATA_BYTE_4_Pos = 0x18
	// Bit mask of DATA_BYTE_4 field.
	CAN0_WORD15_DATA_BYTE_4_Msk = 0xff000000

	// CS6: Message Buffer 6 CS Register
	// Position of TIME_STAMP field.
	CAN0_CS6_TIME_STAMP_Pos = 0x0
	// Bit mask of TIME_STAMP field.
	CAN0_CS6_TIME_STAMP_Msk = 0xffff
	// Position of DLC field.
	CAN0_CS6_DLC_Pos = 0x10
	// Bit mask of DLC field.
	CAN0_CS6_DLC_Msk = 0xf0000
	// Position of RTR field.
	CAN0_CS6_RTR_Pos = 0x14
	// Bit mask of RTR field.
	CAN0_CS6_RTR_Msk = 0x100000
	// Bit RTR.
	CAN0_CS6_RTR = 0x100000
	// Position of IDE field.
	CAN0_CS6_IDE_Pos = 0x15
	// Bit mask of IDE field.
	CAN0_CS6_IDE_Msk = 0x200000
	// Bit IDE.
	CAN0_CS6_IDE = 0x200000
	// Position of SRR field.
	CAN0_CS6_SRR_Pos = 0x16
	// Bit mask of SRR field.
	CAN0_CS6_SRR_Msk = 0x400000
	// Bit SRR.
	CAN0_CS6_SRR = 0x400000
	// Position of CODE field.
	CAN0_CS6_CODE_Pos = 0x18
	// Bit mask of CODE field.
	CAN0_CS6_CODE_Msk = 0xf000000

	// ID6: Message Buffer 6 ID Register
	// Position of EXT field.
	CAN0_ID6_EXT_Pos = 0x0
	// Bit mask of EXT field.
	CAN0_ID6_EXT_Msk = 0x3ffff
	// Position of STD field.
	CAN0_ID6_STD_Pos = 0x12
	// Bit mask of STD field.
	CAN0_ID6_STD_Msk = 0x1ffc0000
	// Position of PRIO field.
	CAN0_ID6_PRIO_Pos = 0x1d
	// Bit mask of PRIO field.
	CAN0_ID6_PRIO_Msk = 0xe0000000

	// WORD06: Message Buffer 6 WORD0 Register
	// Position of DATA_BYTE_3 field.
	CAN0_WORD06_DATA_BYTE_3_Pos = 0x0
	// Bit mask of DATA_BYTE_3 field.
	CAN0_WORD06_DATA_BYTE_3_Msk = 0xff
	// Position of DATA_BYTE_2 field.
	CAN0_WORD06_DATA_BYTE_2_Pos = 0x8
	// Bit mask of DATA_BYTE_2 field.
	CAN0_WORD06_DATA_BYTE_2_Msk = 0xff00
	// Position of DATA_BYTE_1 field.
	CAN0_WORD06_DATA_BYTE_1_Pos = 0x10
	// Bit mask of DATA_BYTE_1 field.
	CAN0_WORD06_DATA_BYTE_1_Msk = 0xff0000
	// Position of DATA_BYTE_0 field.
	CAN0_WORD06_DATA_BYTE_0_Pos = 0x18
	// Bit mask of DATA_BYTE_0 field.
	CAN0_WORD06_DATA_BYTE_0_Msk = 0xff000000

	// WORD16: Message Buffer 6 WORD1 Register
	// Position of DATA_BYTE_7 field.
	CAN0_WORD16_DATA_BYTE_7_Pos = 0x0
	// Bit mask of DATA_BYTE_7 field.
	CAN0_WORD16_DATA_BYTE_7_Msk = 0xff
	// Position of DATA_BYTE_6 field.
	CAN0_WORD16_DATA_BYTE_6_Pos = 0x8
	// Bit mask of DATA_BYTE_6 field.
	CAN0_WORD16_DATA_BYTE_6_Msk = 0xff00
	// Position of DATA_BYTE_5 field.
	CAN0_WORD16_DATA_BYTE_5_Pos = 0x10
	// Bit mask of DATA_BYTE_5 field.
	CAN0_WORD16_DATA_BYTE_5_Msk = 0xff0000
	// Position of DATA_BYTE_4 field.
	CAN0_WORD16_DATA_BYTE_4_Pos = 0x18
	// Bit mask of DATA_BYTE_4 field.
	CAN0_WORD16_DATA_BYTE_4_Msk = 0xff000000

	// CS7: Message Buffer 7 CS Register
	// Position of TIME_STAMP field.
	CAN0_CS7_TIME_STAMP_Pos = 0x0
	// Bit mask of TIME_STAMP field.
	CAN0_CS7_TIME_STAMP_Msk = 0xffff
	// Position of DLC field.
	CAN0_CS7_DLC_Pos = 0x10
	// Bit mask of DLC field.
	CAN0_CS7_DLC_Msk = 0xf0000
	// Position of RTR field.
	CAN0_CS7_RTR_Pos = 0x14
	// Bit mask of RTR field.
	CAN0_CS7_RTR_Msk = 0x100000
	// Bit RTR.
	CAN0_CS7_RTR = 0x100000
	// Position of IDE field.
	CAN0_CS7_IDE_Pos = 0x15
	// Bit mask of IDE field.
	CAN0_CS7_IDE_Msk = 0x200000
	// Bit IDE.
	CAN0_CS7_IDE = 0x200000
	// Position of SRR field.
	CAN0_CS7_SRR_Pos = 0x16
	// Bit mask of SRR field.
	CAN0_CS7_SRR_Msk = 0x400000
	// Bit SRR.
	CAN0_CS7_SRR = 0x400000
	// Position of CODE field.
	CAN0_CS7_CODE_Pos = 0x18
	// Bit mask of CODE field.
	CAN0_CS7_CODE_Msk = 0xf000000

	// ID7: Message Buffer 7 ID Register
	// Position of EXT field.
	CAN0_ID7_EXT_Pos = 0x0
	// Bit mask of EXT field.
	CAN0_ID7_EXT_Msk = 0x3ffff
	// Position of STD field.
	CAN0_ID7_STD_Pos = 0x12
	// Bit mask of STD field.
	CAN0_ID7_STD_Msk = 0x1ffc0000
	// Position of PRIO field.
	CAN0_ID7_PRIO_Pos = 0x1d
	// Bit mask of PRIO field.
	CAN0_ID7_PRIO_Msk = 0xe0000000

	// WORD07: Message Buffer 7 WORD0 Register
	// Position of DATA_BYTE_3 field.
	CAN0_WORD07_DATA_BYTE_3_Pos = 0x0
	// Bit mask of DATA_BYTE_3 field.
	CAN0_WORD07_DATA_BYTE_3_Msk = 0xff
	// Position of DATA_BYTE_2 field.
	CAN0_WORD07_DATA_BYTE_2_Pos = 0x8
	// Bit mask of DATA_BYTE_2 field.
	CAN0_WORD07_DATA_BYTE_2_Msk = 0xff00
	// Position of DATA_BYTE_1 field.
	CAN0_WORD07_DATA_BYTE_1_Pos = 0x10
	// Bit mask of DATA_BYTE_1 field.
	CAN0_WORD07_DATA_BYTE_1_Msk = 0xff0000
	// Position of DATA_BYTE_0 field.
	CAN0_WORD07_DATA_BYTE_0_Pos = 0x18
	// Bit mask of DATA_BYTE_0 field.
	CAN0_WORD07_DATA_BYTE_0_Msk = 0xff000000

	// WORD17: Message Buffer 7 WORD1 Register
	// Position of DATA_BYTE_7 field.
	CAN0_WORD17_DATA_BYTE_7_Pos = 0x0
	// Bit mask of DATA_BYTE_7 field.
	CAN0_WORD17_DATA_BYTE_7_Msk = 0xff
	// Position of DATA_BYTE_6 field.
	CAN0_WORD17_DATA_BYTE_6_Pos = 0x8
	// Bit mask of DATA_BYTE_6 field.
	CAN0_WORD17_DATA_BYTE_6_Msk = 0xff00
	// Position of DATA_BYTE_5 field.
	CAN0_WORD17_DATA_BYTE_5_Pos = 0x10
	// Bit mask of DATA_BYTE_5 field.
	CAN0_WORD17_DATA_BYTE_5_Msk = 0xff0000
	// Position of DATA_BYTE_4 field.
	CAN0_WORD17_DATA_BYTE_4_Pos = 0x18
	// Bit mask of DATA_BYTE_4 field.
	CAN0_WORD17_DATA_BYTE_4_Msk = 0xff000000

	// CS8: Message Buffer 8 CS Register
	// Position of TIME_STAMP field.
	CAN0_CS8_TIME_STAMP_Pos = 0x0
	// Bit mask of TIME_STAMP field.
	CAN0_CS8_TIME_STAMP_Msk = 0xffff
	// Position of DLC field.
	CAN0_CS8_DLC_Pos = 0x10
	// Bit mask of DLC field.
	CAN0_CS8_DLC_Msk = 0xf0000
	// Position of RTR field.
	CAN0_CS8_RTR_Pos = 0x14
	// Bit mask of RTR field.
	CAN0_CS8_RTR_Msk = 0x100000
	// Bit RTR.
	CAN0_CS8_RTR = 0x100000
	// Position of IDE field.
	CAN0_CS8_IDE_Pos = 0x15
	// Bit mask of IDE field.
	CAN0_CS8_IDE_Msk = 0x200000
	// Bit IDE.
	CAN0_CS8_IDE = 0x200000
	// Position of SRR field.
	CAN0_CS8_SRR_Pos = 0x16
	// Bit mask of SRR field.
	CAN0_CS8_SRR_Msk = 0x400000
	// Bit SRR.
	CAN0_CS8_SRR = 0x400000
	// Position of CODE field.
	CAN0_CS8_CODE_Pos = 0x18
	// Bit mask of CODE field.
	CAN0_CS8_CODE_Msk = 0xf000000

	// ID8: Message Buffer 8 ID Register
	// Position of EXT field.
	CAN0_ID8_EXT_Pos = 0x0
	// Bit mask of EXT field.
	CAN0_ID8_EXT_Msk = 0x3ffff
	// Position of STD field.
	CAN0_ID8_STD_Pos = 0x12
	// Bit mask of STD field.
	CAN0_ID8_STD_Msk = 0x1ffc0000
	// Position of PRIO field.
	CAN0_ID8_PRIO_Pos = 0x1d
	// Bit mask of PRIO field.
	CAN0_ID8_PRIO_Msk = 0xe0000000

	// WORD08: Message Buffer 8 WORD0 Register
	// Position of DATA_BYTE_3 field.
	CAN0_WORD08_DATA_BYTE_3_Pos = 0x0
	// Bit mask of DATA_BYTE_3 field.
	CAN0_WORD08_DATA_BYTE_3_Msk = 0xff
	// Position of DATA_BYTE_2 field.
	CAN0_WORD08_DATA_BYTE_2_Pos = 0x8
	// Bit mask of DATA_BYTE_2 field.
	CAN0_WORD08_DATA_BYTE_2_Msk = 0xff00
	// Position of DATA_BYTE_1 field.
	CAN0_WORD08_DATA_BYTE_1_Pos = 0x10
	// Bit mask of DATA_BYTE_1 field.
	CAN0_WORD08_DATA_BYTE_1_Msk = 0xff0000
	// Position of DATA_BYTE_0 field.
	CAN0_WORD08_DATA_BYTE_0_Pos = 0x18
	// Bit mask of DATA_BYTE_0 field.
	CAN0_WORD08_DATA_BYTE_0_Msk = 0xff000000

	// WORD18: Message Buffer 8 WORD1 Register
	// Position of DATA_BYTE_7 field.
	CAN0_WORD18_DATA_BYTE_7_Pos = 0x0
	// Bit mask of DATA_BYTE_7 field.
	CAN0_WORD18_DATA_BYTE_7_Msk = 0xff
	// Position of DATA_BYTE_6 field.
	CAN0_WORD18_DATA_BYTE_6_Pos = 0x8
	// Bit mask of DATA_BYTE_6 field.
	CAN0_WORD18_DATA_BYTE_6_Msk = 0xff00
	// Position of DATA_BYTE_5 field.
	CAN0_WORD18_DATA_BYTE_5_Pos = 0x10
	// Bit mask of DATA_BYTE_5 field.
	CAN0_WORD18_DATA_BYTE_5_Msk = 0xff0000
	// Position of DATA_BYTE_4 field.
	CAN0_WORD18_DATA_BYTE_4_Pos = 0x18
	// Bit mask of DATA_BYTE_4 field.
	CAN0_WORD18_DATA_BYTE_4_Msk = 0xff000000

	// CS9: Message Buffer 9 CS Register
	// Position of TIME_STAMP field.
	CAN0_CS9_TIME_STAMP_Pos = 0x0
	// Bit mask of TIME_STAMP field.
	CAN0_CS9_TIME_STAMP_Msk = 0xffff
	// Position of DLC field.
	CAN0_CS9_DLC_Pos = 0x10
	// Bit mask of DLC field.
	CAN0_CS9_DLC_Msk = 0xf0000
	// Position of RTR field.
	CAN0_CS9_RTR_Pos = 0x14
	// Bit mask of RTR field.
	CAN0_CS9_RTR_Msk = 0x100000
	// Bit RTR.
	CAN0_CS9_RTR = 0x100000
	// Position of IDE field.
	CAN0_CS9_IDE_Pos = 0x15
	// Bit mask of IDE field.
	CAN0_CS9_IDE_Msk = 0x200000
	// Bit IDE.
	CAN0_CS9_IDE = 0x200000
	// Position of SRR field.
	CAN0_CS9_SRR_Pos = 0x16
	// Bit mask of SRR field.
	CAN0_CS9_SRR_Msk = 0x400000
	// Bit SRR.
	CAN0_CS9_SRR = 0x400000
	// Position of CODE field.
	CAN0_CS9_CODE_Pos = 0x18
	// Bit mask of CODE field.
	CAN0_CS9_CODE_Msk = 0xf000000

	// ID9: Message Buffer 9 ID Register
	// Position of EXT field.
	CAN0_ID9_EXT_Pos = 0x0
	// Bit mask of EXT field.
	CAN0_ID9_EXT_Msk = 0x3ffff
	// Position of STD field.
	CAN0_ID9_STD_Pos = 0x12
	// Bit mask of STD field.
	CAN0_ID9_STD_Msk = 0x1ffc0000
	// Position of PRIO field.
	CAN0_ID9_PRIO_Pos = 0x1d
	// Bit mask of PRIO field.
	CAN0_ID9_PRIO_Msk = 0xe0000000

	// WORD09: Message Buffer 9 WORD0 Register
	// Position of DATA_BYTE_3 field.
	CAN0_WORD09_DATA_BYTE_3_Pos = 0x0
	// Bit mask of DATA_BYTE_3 field.
	CAN0_WORD09_DATA_BYTE_3_Msk = 0xff
	// Position of DATA_BYTE_2 field.
	CAN0_WORD09_DATA_BYTE_2_Pos = 0x8
	// Bit mask of DATA_BYTE_2 field.
	CAN0_WORD09_DATA_BYTE_2_Msk = 0xff00
	// Position of DATA_BYTE_1 field.
	CAN0_WORD09_DATA_BYTE_1_Pos = 0x10
	// Bit mask of DATA_BYTE_1 field.
	CAN0_WORD09_DATA_BYTE_1_Msk = 0xff0000
	// Position of DATA_BYTE_0 field.
	CAN0_WORD09_DATA_BYTE_0_Pos = 0x18
	// Bit mask of DATA_BYTE_0 field.
	CAN0_WORD09_DATA_BYTE_0_Msk = 0xff000000

	// WORD19: Message Buffer 9 WORD1 Register
	// Position of DATA_BYTE_7 field.
	CAN0_WORD19_DATA_BYTE_7_Pos = 0x0
	// Bit mask of DATA_BYTE_7 field.
	CAN0_WORD19_DATA_BYTE_7_Msk = 0xff
	// Position of DATA_BYTE_6 field.
	CAN0_WORD19_DATA_BYTE_6_Pos = 0x8
	// Bit mask of DATA_BYTE_6 field.
	CAN0_WORD19_DATA_BYTE_6_Msk = 0xff00
	// Position of DATA_BYTE_5 field.
	CAN0_WORD19_DATA_BYTE_5_Pos = 0x10
	// Bit mask of DATA_BYTE_5 field.
	CAN0_WORD19_DATA_BYTE_5_Msk = 0xff0000
	// Position of DATA_BYTE_4 field.
	CAN0_WORD19_DATA_BYTE_4_Pos = 0x18
	// Bit mask of DATA_BYTE_4 field.
	CAN0_WORD19_DATA_BYTE_4_Msk = 0xff000000

	// CS10: Message Buffer 10 CS Register
	// Position of TIME_STAMP field.
	CAN0_CS10_TIME_STAMP_Pos = 0x0
	// Bit mask of TIME_STAMP field.
	CAN0_CS10_TIME_STAMP_Msk = 0xffff
	// Position of DLC field.
	CAN0_CS10_DLC_Pos = 0x10
	// Bit mask of DLC field.
	CAN0_CS10_DLC_Msk = 0xf0000
	// Position of RTR field.
	CAN0_CS10_RTR_Pos = 0x14
	// Bit mask of RTR field.
	CAN0_CS10_RTR_Msk = 0x100000
	// Bit RTR.
	CAN0_CS10_RTR = 0x100000
	// Position of IDE field.
	CAN0_CS10_IDE_Pos = 0x15
	// Bit mask of IDE field.
	CAN0_CS10_IDE_Msk = 0x200000
	// Bit IDE.
	CAN0_CS10_IDE = 0x200000
	// Position of SRR field.
	CAN0_CS10_SRR_Pos = 0x16
	// Bit mask of SRR field.
	CAN0_CS10_SRR_Msk = 0x400000
	// Bit SRR.
	CAN0_CS10_SRR = 0x400000
	// Position of CODE field.
	CAN0_CS10_CODE_Pos = 0x18
	// Bit mask of CODE field.
	CAN0_CS10_CODE_Msk = 0xf000000

	// ID10: Message Buffer 10 ID Register
	// Position of EXT field.
	CAN0_ID10_EXT_Pos = 0x0
	// Bit mask of EXT field.
	CAN0_ID10_EXT_Msk = 0x3ffff
	// Position of STD field.
	CAN0_ID10_STD_Pos = 0x12
	// Bit mask of STD field.
	CAN0_ID10_STD_Msk = 0x1ffc0000
	// Position of PRIO field.
	CAN0_ID10_PRIO_Pos = 0x1d
	// Bit mask of PRIO field.
	CAN0_ID10_PRIO_Msk = 0xe0000000

	// WORD010: Message Buffer 10 WORD0 Register
	// Position of DATA_BYTE_3 field.
	CAN0_WORD010_DATA_BYTE_3_Pos = 0x0
	// Bit mask of DATA_BYTE_3 field.
	CAN0_WORD010_DATA_BYTE_3_Msk = 0xff
	// Position of DATA_BYTE_2 field.
	CAN0_WORD010_DATA_BYTE_2_Pos = 0x8
	// Bit mask of DATA_BYTE_2 field.
	CAN0_WORD010_DATA_BYTE_2_Msk = 0xff00
	// Position of DATA_BYTE_1 field.
	CAN0_WORD010_DATA_BYTE_1_Pos = 0x10
	// Bit mask of DATA_BYTE_1 field.
	CAN0_WORD010_DATA_BYTE_1_Msk = 0xff0000
	// Position of DATA_BYTE_0 field.
	CAN0_WORD010_DATA_BYTE_0_Pos = 0x18
	// Bit mask of DATA_BYTE_0 field.
	CAN0_WORD010_DATA_BYTE_0_Msk = 0xff000000

	// WORD110: Message Buffer 10 WORD1 Register
	// Position of DATA_BYTE_7 field.
	CAN0_WORD110_DATA_BYTE_7_Pos = 0x0
	// Bit mask of DATA_BYTE_7 field.
	CAN0_WORD110_DATA_BYTE_7_Msk = 0xff
	// Position of DATA_BYTE_6 field.
	CAN0_WORD110_DATA_BYTE_6_Pos = 0x8
	// Bit mask of DATA_BYTE_6 field.
	CAN0_WORD110_DATA_BYTE_6_Msk = 0xff00
	// Position of DATA_BYTE_5 field.
	CAN0_WORD110_DATA_BYTE_5_Pos = 0x10
	// Bit mask of DATA_BYTE_5 field.
	CAN0_WORD110_DATA_BYTE_5_Msk = 0xff0000
	// Position of DATA_BYTE_4 field.
	CAN0_WORD110_DATA_BYTE_4_Pos = 0x18
	// Bit mask of DATA_BYTE_4 field.
	CAN0_WORD110_DATA_BYTE_4_Msk = 0xff000000

	// CS11: Message Buffer 11 CS Register
	// Position of TIME_STAMP field.
	CAN0_CS11_TIME_STAMP_Pos = 0x0
	// Bit mask of TIME_STAMP field.
	CAN0_CS11_TIME_STAMP_Msk = 0xffff
	// Position of DLC field.
	CAN0_CS11_DLC_Pos = 0x10
	// Bit mask of DLC field.
	CAN0_CS11_DLC_Msk = 0xf0000
	// Position of RTR field.
	CAN0_CS11_RTR_Pos = 0x14
	// Bit mask of RTR field.
	CAN0_CS11_RTR_Msk = 0x100000
	// Bit RTR.
	CAN0_CS11_RTR = 0x100000
	// Position of IDE field.
	CAN0_CS11_IDE_Pos = 0x15
	// Bit mask of IDE field.
	CAN0_CS11_IDE_Msk = 0x200000
	// Bit IDE.
	CAN0_CS11_IDE = 0x200000
	// Position of SRR field.
	CAN0_CS11_SRR_Pos = 0x16
	// Bit mask of SRR field.
	CAN0_CS11_SRR_Msk = 0x400000
	// Bit SRR.
	CAN0_CS11_SRR = 0x400000
	// Position of CODE field.
	CAN0_CS11_CODE_Pos = 0x18
	// Bit mask of CODE field.
	CAN0_CS11_CODE_Msk = 0xf000000

	// ID11: Message Buffer 11 ID Register
	// Position of EXT field.
	CAN0_ID11_EXT_Pos = 0x0
	// Bit mask of EXT field.
	CAN0_ID11_EXT_Msk = 0x3ffff
	// Position of STD field.
	CAN0_ID11_STD_Pos = 0x12
	// Bit mask of STD field.
	CAN0_ID11_STD_Msk = 0x1ffc0000
	// Position of PRIO field.
	CAN0_ID11_PRIO_Pos = 0x1d
	// Bit mask of PRIO field.
	CAN0_ID11_PRIO_Msk = 0xe0000000

	// WORD011: Message Buffer 11 WORD0 Register
	// Position of DATA_BYTE_3 field.
	CAN0_WORD011_DATA_BYTE_3_Pos = 0x0
	// Bit mask of DATA_BYTE_3 field.
	CAN0_WORD011_DATA_BYTE_3_Msk = 0xff
	// Position of DATA_BYTE_2 field.
	CAN0_WORD011_DATA_BYTE_2_Pos = 0x8
	// Bit mask of DATA_BYTE_2 field.
	CAN0_WORD011_DATA_BYTE_2_Msk = 0xff00
	// Position of DATA_BYTE_1 field.
	CAN0_WORD011_DATA_BYTE_1_Pos = 0x10
	// Bit mask of DATA_BYTE_1 field.
	CAN0_WORD011_DATA_BYTE_1_Msk = 0xff0000
	// Position of DATA_BYTE_0 field.
	CAN0_WORD011_DATA_BYTE_0_Pos = 0x18
	// Bit mask of DATA_BYTE_0 field.
	CAN0_WORD011_DATA_BYTE_0_Msk = 0xff000000

	// WORD111: Message Buffer 11 WORD1 Register
	// Position of DATA_BYTE_7 field.
	CAN0_WORD111_DATA_BYTE_7_Pos = 0x0
	// Bit mask of DATA_BYTE_7 field.
	CAN0_WORD111_DATA_BYTE_7_Msk = 0xff
	// Position of DATA_BYTE_6 field.
	CAN0_WORD111_DATA_BYTE_6_Pos = 0x8
	// Bit mask of DATA_BYTE_6 field.
	CAN0_WORD111_DATA_BYTE_6_Msk = 0xff00
	// Position of DATA_BYTE_5 field.
	CAN0_WORD111_DATA_BYTE_5_Pos = 0x10
	// Bit mask of DATA_BYTE_5 field.
	CAN0_WORD111_DATA_BYTE_5_Msk = 0xff0000
	// Position of DATA_BYTE_4 field.
	CAN0_WORD111_DATA_BYTE_4_Pos = 0x18
	// Bit mask of DATA_BYTE_4 field.
	CAN0_WORD111_DATA_BYTE_4_Msk = 0xff000000

	// CS12: Message Buffer 12 CS Register
	// Position of TIME_STAMP field.
	CAN0_CS12_TIME_STAMP_Pos = 0x0
	// Bit mask of TIME_STAMP field.
	CAN0_CS12_TIME_STAMP_Msk = 0xffff
	// Position of DLC field.
	CAN0_CS12_DLC_Pos = 0x10
	// Bit mask of DLC field.
	CAN0_CS12_DLC_Msk = 0xf0000
	// Position of RTR field.
	CAN0_CS12_RTR_Pos = 0x14
	// Bit mask of RTR field.
	CAN0_CS12_RTR_Msk = 0x100000
	// Bit RTR.
	CAN0_CS12_RTR = 0x100000
	// Position of IDE field.
	CAN0_CS12_IDE_Pos = 0x15
	// Bit mask of IDE field.
	CAN0_CS12_IDE_Msk = 0x200000
	// Bit IDE.
	CAN0_CS12_IDE = 0x200000
	// Position of SRR field.
	CAN0_CS12_SRR_Pos = 0x16
	// Bit mask of SRR field.
	CAN0_CS12_SRR_Msk = 0x400000
	// Bit SRR.
	CAN0_CS12_SRR = 0x400000
	// Position of CODE field.
	CAN0_CS12_CODE_Pos = 0x18
	// Bit mask of CODE field.
	CAN0_CS12_CODE_Msk = 0xf000000

	// ID12: Message Buffer 12 ID Register
	// Position of EXT field.
	CAN0_ID12_EXT_Pos = 0x0
	// Bit mask of EXT field.
	CAN0_ID12_EXT_Msk = 0x3ffff
	// Position of STD field.
	CAN0_ID12_STD_Pos = 0x12
	// Bit mask of STD field.
	CAN0_ID12_STD_Msk = 0x1ffc0000
	// Position of PRIO field.
	CAN0_ID12_PRIO_Pos = 0x1d
	// Bit mask of PRIO field.
	CAN0_ID12_PRIO_Msk = 0xe0000000

	// WORD012: Message Buffer 12 WORD0 Register
	// Position of DATA_BYTE_3 field.
	CAN0_WORD012_DATA_BYTE_3_Pos = 0x0
	// Bit mask of DATA_BYTE_3 field.
	CAN0_WORD012_DATA_BYTE_3_Msk = 0xff
	// Position of DATA_BYTE_2 field.
	CAN0_WORD012_DATA_BYTE_2_Pos = 0x8
	// Bit mask of DATA_BYTE_2 field.
	CAN0_WORD012_DATA_BYTE_2_Msk = 0xff00
	// Position of DATA_BYTE_1 field.
	CAN0_WORD012_DATA_BYTE_1_Pos = 0x10
	// Bit mask of DATA_BYTE_1 field.
	CAN0_WORD012_DATA_BYTE_1_Msk = 0xff0000
	// Position of DATA_BYTE_0 field.
	CAN0_WORD012_DATA_BYTE_0_Pos = 0x18
	// Bit mask of DATA_BYTE_0 field.
	CAN0_WORD012_DATA_BYTE_0_Msk = 0xff000000

	// WORD112: Message Buffer 12 WORD1 Register
	// Position of DATA_BYTE_7 field.
	CAN0_WORD112_DATA_BYTE_7_Pos = 0x0
	// Bit mask of DATA_BYTE_7 field.
	CAN0_WORD112_DATA_BYTE_7_Msk = 0xff
	// Position of DATA_BYTE_6 field.
	CAN0_WORD112_DATA_BYTE_6_Pos = 0x8
	// Bit mask of DATA_BYTE_6 field.
	CAN0_WORD112_DATA_BYTE_6_Msk = 0xff00
	// Position of DATA_BYTE_5 field.
	CAN0_WORD112_DATA_BYTE_5_Pos = 0x10
	// Bit mask of DATA_BYTE_5 field.
	CAN0_WORD112_DATA_BYTE_5_Msk = 0xff0000
	// Position of DATA_BYTE_4 field.
	CAN0_WORD112_DATA_BYTE_4_Pos = 0x18
	// Bit mask of DATA_BYTE_4 field.
	CAN0_WORD112_DATA_BYTE_4_Msk = 0xff000000

	// CS13: Message Buffer 13 CS Register
	// Position of TIME_STAMP field.
	CAN0_CS13_TIME_STAMP_Pos = 0x0
	// Bit mask of TIME_STAMP field.
	CAN0_CS13_TIME_STAMP_Msk = 0xffff
	// Position of DLC field.
	CAN0_CS13_DLC_Pos = 0x10
	// Bit mask of DLC field.
	CAN0_CS13_DLC_Msk = 0xf0000
	// Position of RTR field.
	CAN0_CS13_RTR_Pos = 0x14
	// Bit mask of RTR field.
	CAN0_CS13_RTR_Msk = 0x100000
	// Bit RTR.
	CAN0_CS13_RTR = 0x100000
	// Position of IDE field.
	CAN0_CS13_IDE_Pos = 0x15
	// Bit mask of IDE field.
	CAN0_CS13_IDE_Msk = 0x200000
	// Bit IDE.
	CAN0_CS13_IDE = 0x200000
	// Position of SRR field.
	CAN0_CS13_SRR_Pos = 0x16
	// Bit mask of SRR field.
	CAN0_CS13_SRR_Msk = 0x400000
	// Bit SRR.
	CAN0_CS13_SRR = 0x400000
	// Position of CODE field.
	CAN0_CS13_CODE_Pos = 0x18
	// Bit mask of CODE field.
	CAN0_CS13_CODE_Msk = 0xf000000

	// ID13: Message Buffer 13 ID Register
	// Position of EXT field.
	CAN0_ID13_EXT_Pos = 0x0
	// Bit mask of EXT field.
	CAN0_ID13_EXT_Msk = 0x3ffff
	// Position of STD field.
	CAN0_ID13_STD_Pos = 0x12
	// Bit mask of STD field.
	CAN0_ID13_STD_Msk = 0x1ffc0000
	// Position of PRIO field.
	CAN0_ID13_PRIO_Pos = 0x1d
	// Bit mask of PRIO field.
	CAN0_ID13_PRIO_Msk = 0xe0000000

	// WORD013: Message Buffer 13 WORD0 Register
	// Position of DATA_BYTE_3 field.
	CAN0_WORD013_DATA_BYTE_3_Pos = 0x0
	// Bit mask of DATA_BYTE_3 field.
	CAN0_WORD013_DATA_BYTE_3_Msk = 0xff
	// Position of DATA_BYTE_2 field.
	CAN0_WORD013_DATA_BYTE_2_Pos = 0x8
	// Bit mask of DATA_BYTE_2 field.
	CAN0_WORD013_DATA_BYTE_2_Msk = 0xff00
	// Position of DATA_BYTE_1 field.
	CAN0_WORD013_DATA_BYTE_1_Pos = 0x10
	// Bit mask of DATA_BYTE_1 field.
	CAN0_WORD013_DATA_BYTE_1_Msk = 0xff0000
	// Position of DATA_BYTE_0 field.
	CAN0_WORD013_DATA_BYTE_0_Pos = 0x18
	// Bit mask of DATA_BYTE_0 field.
	CAN0_WORD013_DATA_BYTE_0_Msk = 0xff000000

	// WORD113: Message Buffer 13 WORD1 Register
	// Position of DATA_BYTE_7 field.
	CAN0_WORD113_DATA_BYTE_7_Pos = 0x0
	// Bit mask of DATA_BYTE_7 field.
	CAN0_WORD113_DATA_BYTE_7_Msk = 0xff
	// Position of DATA_BYTE_6 field.
	CAN0_WORD113_DATA_BYTE_6_Pos = 0x8
	// Bit mask of DATA_BYTE_6 field.
	CAN0_WORD113_DATA_BYTE_6_Msk = 0xff00
	// Position of DATA_BYTE_5 field.
	CAN0_WORD113_DATA_BYTE_5_Pos = 0x10
	// Bit mask of DATA_BYTE_5 field.
	CAN0_WORD113_DATA_BYTE_5_Msk = 0xff0000
	// Position of DATA_BYTE_4 field.
	CAN0_WORD113_DATA_BYTE_4_Pos = 0x18
	// Bit mask of DATA_BYTE_4 field.
	CAN0_WORD113_DATA_BYTE_4_Msk = 0xff000000

	// CS14: Message Buffer 14 CS Register
	// Position of TIME_STAMP field.
	CAN0_CS14_TIME_STAMP_Pos = 0x0
	// Bit mask of TIME_STAMP field.
	CAN0_CS14_TIME_STAMP_Msk = 0xffff
	// Position of DLC field.
	CAN0_CS14_DLC_Pos = 0x10
	// Bit mask of DLC field.
	CAN0_CS14_DLC_Msk = 0xf0000
	// Position of RTR field.
	CAN0_CS14_RTR_Pos = 0x14
	// Bit mask of RTR field.
	CAN0_CS14_RTR_Msk = 0x100000
	// Bit RTR.
	CAN0_CS14_RTR = 0x100000
	// Position of IDE field.
	CAN0_CS14_IDE_Pos = 0x15
	// Bit mask of IDE field.
	CAN0_CS14_IDE_Msk = 0x200000
	// Bit IDE.
	CAN0_CS14_IDE = 0x200000
	// Position of SRR field.
	CAN0_CS14_SRR_Pos = 0x16
	// Bit mask of SRR field.
	CAN0_CS14_SRR_Msk = 0x400000
	// Bit SRR.
	CAN0_CS14_SRR = 0x400000
	// Position of CODE field.
	CAN0_CS14_CODE_Pos = 0x18
	// Bit mask of CODE field.
	CAN0_CS14_CODE_Msk = 0xf000000

	// ID14: Message Buffer 14 ID Register
	// Position of EXT field.
	CAN0_ID14_EXT_Pos = 0x0
	// Bit mask of EXT field.
	CAN0_ID14_EXT_Msk = 0x3ffff
	// Position of STD field.
	CAN0_ID14_STD_Pos = 0x12
	// Bit mask of STD field.
	CAN0_ID14_STD_Msk = 0x1ffc0000
	// Position of PRIO field.
	CAN0_ID14_PRIO_Pos = 0x1d
	// Bit mask of PRIO field.
	CAN0_ID14_PRIO_Msk = 0xe0000000

	// WORD014: Message Buffer 14 WORD0 Register
	// Position of DATA_BYTE_3 field.
	CAN0_WORD014_DATA_BYTE_3_Pos = 0x0
	// Bit mask of DATA_BYTE_3 field.
	CAN0_WORD014_DATA_BYTE_3_Msk = 0xff
	// Position of DATA_BYTE_2 field.
	CAN0_WORD014_DATA_BYTE_2_Pos = 0x8
	// Bit mask of DATA_BYTE_2 field.
	CAN0_WORD014_DATA_BYTE_2_Msk = 0xff00
	// Position of DATA_BYTE_1 field.
	CAN0_WORD014_DATA_BYTE_1_Pos = 0x10
	// Bit mask of DATA_BYTE_1 field.
	CAN0_WORD014_DATA_BYTE_1_Msk = 0xff0000
	// Position of DATA_BYTE_0 field.
	CAN0_WORD014_DATA_BYTE_0_Pos = 0x18
	// Bit mask of DATA_BYTE_0 field.
	CAN0_WORD014_DATA_BYTE_0_Msk = 0xff000000

	// WORD114: Message Buffer 14 WORD1 Register
	// Position of DATA_BYTE_7 field.
	CAN0_WORD114_DATA_BYTE_7_Pos = 0x0
	// Bit mask of DATA_BYTE_7 field.
	CAN0_WORD114_DATA_BYTE_7_Msk = 0xff
	// Position of DATA_BYTE_6 field.
	CAN0_WORD114_DATA_BYTE_6_Pos = 0x8
	// Bit mask of DATA_BYTE_6 field.
	CAN0_WORD114_DATA_BYTE_6_Msk = 0xff00
	// Position of DATA_BYTE_5 field.
	CAN0_WORD114_DATA_BYTE_5_Pos = 0x10
	// Bit mask of DATA_BYTE_5 field.
	CAN0_WORD114_DATA_BYTE_5_Msk = 0xff0000
	// Position of DATA_BYTE_4 field.
	CAN0_WORD114_DATA_BYTE_4_Pos = 0x18
	// Bit mask of DATA_BYTE_4 field.
	CAN0_WORD114_DATA_BYTE_4_Msk = 0xff000000

	// CS15: Message Buffer 15 CS Register
	// Position of TIME_STAMP field.
	CAN0_CS15_TIME_STAMP_Pos = 0x0
	// Bit mask of TIME_STAMP field.
	CAN0_CS15_TIME_STAMP_Msk = 0xffff
	// Position of DLC field.
	CAN0_CS15_DLC_Pos = 0x10
	// Bit mask of DLC field.
	CAN0_CS15_DLC_Msk = 0xf0000
	// Position of RTR field.
	CAN0_CS15_RTR_Pos = 0x14
	// Bit mask of RTR field.
	CAN0_CS15_RTR_Msk = 0x100000
	// Bit RTR.
	CAN0_CS15_RTR = 0x100000
	// Position of IDE field.
	CAN0_CS15_IDE_Pos = 0x15
	// Bit mask of IDE field.
	CAN0_CS15_IDE_Msk = 0x200000
	// Bit IDE.
	CAN0_CS15_IDE = 0x200000
	// Position of SRR field.
	CAN0_CS15_SRR_Pos = 0x16
	// Bit mask of SRR field.
	CAN0_CS15_SRR_Msk = 0x400000
	// Bit SRR.
	CAN0_CS15_SRR = 0x400000
	// Position of CODE field.
	CAN0_CS15_CODE_Pos = 0x18
	// Bit mask of CODE field.
	CAN0_CS15_CODE_Msk = 0xf000000

	// ID15: Message Buffer 15 ID Register
	// Position of EXT field.
	CAN0_ID15_EXT_Pos = 0x0
	// Bit mask of EXT field.
	CAN0_ID15_EXT_Msk = 0x3ffff
	// Position of STD field.
	CAN0_ID15_STD_Pos = 0x12
	// Bit mask of STD field.
	CAN0_ID15_STD_Msk = 0x1ffc0000
	// Position of PRIO field.
	CAN0_ID15_PRIO_Pos = 0x1d
	// Bit mask of PRIO field.
	CAN0_ID15_PRIO_Msk = 0xe0000000

	// WORD015: Message Buffer 15 WORD0 Register
	// Position of DATA_BYTE_3 field.
	CAN0_WORD015_DATA_BYTE_3_Pos = 0x0
	// Bit mask of DATA_BYTE_3 field.
	CAN0_WORD015_DATA_BYTE_3_Msk = 0xff
	// Position of DATA_BYTE_2 field.
	CAN0_WORD015_DATA_BYTE_2_Pos = 0x8
	// Bit mask of DATA_BYTE_2 field.
	CAN0_WORD015_DATA_BYTE_2_Msk = 0xff00
	// Position of DATA_BYTE_1 field.
	CAN0_WORD015_DATA_BYTE_1_Pos = 0x10
	// Bit mask of DATA_BYTE_1 field.
	CAN0_WORD015_DATA_BYTE_1_Msk = 0xff0000
	// Position of DATA_BYTE_0 field.
	CAN0_WORD015_DATA_BYTE_0_Pos = 0x18
	// Bit mask of DATA_BYTE_0 field.
	CAN0_WORD015_DATA_BYTE_0_Msk = 0xff000000

	// WORD115: Message Buffer 15 WORD1 Register
	// Position of DATA_BYTE_7 field.
	CAN0_WORD115_DATA_BYTE_7_Pos = 0x0
	// Bit mask of DATA_BYTE_7 field.
	CAN0_WORD115_DATA_BYTE_7_Msk = 0xff
	// Position of DATA_BYTE_6 field.
	CAN0_WORD115_DATA_BYTE_6_Pos = 0x8
	// Bit mask of DATA_BYTE_6 field.
	CAN0_WORD115_DATA_BYTE_6_Msk = 0xff00
	// Position of DATA_BYTE_5 field.
	CAN0_WORD115_DATA_BYTE_5_Pos = 0x10
	// Bit mask of DATA_BYTE_5 field.
	CAN0_WORD115_DATA_BYTE_5_Msk = 0xff0000
	// Position of DATA_BYTE_4 field.
	CAN0_WORD115_DATA_BYTE_4_Pos = 0x18
	// Bit mask of DATA_BYTE_4 field.
	CAN0_WORD115_DATA_BYTE_4_Msk = 0xff000000

	// RXIMR0: Rx Individual Mask Registers
	// Position of MI0 field.
	CAN0_RXIMR_MI0_Pos = 0x0
	// Bit mask of MI0 field.
	CAN0_RXIMR_MI0_Msk = 0x1
	// Bit MI0.
	CAN0_RXIMR_MI0 = 0x1
	// The corresponding bit in the filter is "don't care."
	CAN0_RXIMR_MI0_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXIMR_MI0_1 = 0x1
	// Position of MI1 field.
	CAN0_RXIMR_MI1_Pos = 0x1
	// Bit mask of MI1 field.
	CAN0_RXIMR_MI1_Msk = 0x2
	// Bit MI1.
	CAN0_RXIMR_MI1 = 0x2
	// The corresponding bit in the filter is "don't care."
	CAN0_RXIMR_MI1_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXIMR_MI1_1 = 0x1
	// Position of MI2 field.
	CAN0_RXIMR_MI2_Pos = 0x2
	// Bit mask of MI2 field.
	CAN0_RXIMR_MI2_Msk = 0x4
	// Bit MI2.
	CAN0_RXIMR_MI2 = 0x4
	// The corresponding bit in the filter is "don't care."
	CAN0_RXIMR_MI2_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXIMR_MI2_1 = 0x1
	// Position of MI3 field.
	CAN0_RXIMR_MI3_Pos = 0x3
	// Bit mask of MI3 field.
	CAN0_RXIMR_MI3_Msk = 0x8
	// Bit MI3.
	CAN0_RXIMR_MI3 = 0x8
	// The corresponding bit in the filter is "don't care."
	CAN0_RXIMR_MI3_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXIMR_MI3_1 = 0x1
	// Position of MI4 field.
	CAN0_RXIMR_MI4_Pos = 0x4
	// Bit mask of MI4 field.
	CAN0_RXIMR_MI4_Msk = 0x10
	// Bit MI4.
	CAN0_RXIMR_MI4 = 0x10
	// The corresponding bit in the filter is "don't care."
	CAN0_RXIMR_MI4_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXIMR_MI4_1 = 0x1
	// Position of MI5 field.
	CAN0_RXIMR_MI5_Pos = 0x5
	// Bit mask of MI5 field.
	CAN0_RXIMR_MI5_Msk = 0x20
	// Bit MI5.
	CAN0_RXIMR_MI5 = 0x20
	// The corresponding bit in the filter is "don't care."
	CAN0_RXIMR_MI5_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXIMR_MI5_1 = 0x1
	// Position of MI6 field.
	CAN0_RXIMR_MI6_Pos = 0x6
	// Bit mask of MI6 field.
	CAN0_RXIMR_MI6_Msk = 0x40
	// Bit MI6.
	CAN0_RXIMR_MI6 = 0x40
	// The corresponding bit in the filter is "don't care."
	CAN0_RXIMR_MI6_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXIMR_MI6_1 = 0x1
	// Position of MI7 field.
	CAN0_RXIMR_MI7_Pos = 0x7
	// Bit mask of MI7 field.
	CAN0_RXIMR_MI7_Msk = 0x80
	// Bit MI7.
	CAN0_RXIMR_MI7 = 0x80
	// The corresponding bit in the filter is "don't care."
	CAN0_RXIMR_MI7_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXIMR_MI7_1 = 0x1
	// Position of MI8 field.
	CAN0_RXIMR_MI8_Pos = 0x8
	// Bit mask of MI8 field.
	CAN0_RXIMR_MI8_Msk = 0x100
	// Bit MI8.
	CAN0_RXIMR_MI8 = 0x100
	// The corresponding bit in the filter is "don't care."
	CAN0_RXIMR_MI8_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXIMR_MI8_1 = 0x1
	// Position of MI9 field.
	CAN0_RXIMR_MI9_Pos = 0x9
	// Bit mask of MI9 field.
	CAN0_RXIMR_MI9_Msk = 0x200
	// Bit MI9.
	CAN0_RXIMR_MI9 = 0x200
	// The corresponding bit in the filter is "don't care."
	CAN0_RXIMR_MI9_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXIMR_MI9_1 = 0x1
	// Position of MI10 field.
	CAN0_RXIMR_MI10_Pos = 0xa
	// Bit mask of MI10 field.
	CAN0_RXIMR_MI10_Msk = 0x400
	// Bit MI10.
	CAN0_RXIMR_MI10 = 0x400
	// The corresponding bit in the filter is "don't care."
	CAN0_RXIMR_MI10_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXIMR_MI10_1 = 0x1
	// Position of MI11 field.
	CAN0_RXIMR_MI11_Pos = 0xb
	// Bit mask of MI11 field.
	CAN0_RXIMR_MI11_Msk = 0x800
	// Bit MI11.
	CAN0_RXIMR_MI11 = 0x800
	// The corresponding bit in the filter is "don't care."
	CAN0_RXIMR_MI11_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXIMR_MI11_1 = 0x1
	// Position of MI12 field.
	CAN0_RXIMR_MI12_Pos = 0xc
	// Bit mask of MI12 field.
	CAN0_RXIMR_MI12_Msk = 0x1000
	// Bit MI12.
	CAN0_RXIMR_MI12 = 0x1000
	// The corresponding bit in the filter is "don't care."
	CAN0_RXIMR_MI12_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXIMR_MI12_1 = 0x1
	// Position of MI13 field.
	CAN0_RXIMR_MI13_Pos = 0xd
	// Bit mask of MI13 field.
	CAN0_RXIMR_MI13_Msk = 0x2000
	// Bit MI13.
	CAN0_RXIMR_MI13 = 0x2000
	// The corresponding bit in the filter is "don't care."
	CAN0_RXIMR_MI13_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXIMR_MI13_1 = 0x1
	// Position of MI14 field.
	CAN0_RXIMR_MI14_Pos = 0xe
	// Bit mask of MI14 field.
	CAN0_RXIMR_MI14_Msk = 0x4000
	// Bit MI14.
	CAN0_RXIMR_MI14 = 0x4000
	// The corresponding bit in the filter is "don't care."
	CAN0_RXIMR_MI14_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXIMR_MI14_1 = 0x1
	// Position of MI15 field.
	CAN0_RXIMR_MI15_Pos = 0xf
	// Bit mask of MI15 field.
	CAN0_RXIMR_MI15_Msk = 0x8000
	// Bit MI15.
	CAN0_RXIMR_MI15 = 0x8000
	// The corresponding bit in the filter is "don't care."
	CAN0_RXIMR_MI15_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXIMR_MI15_1 = 0x1
	// Position of MI16 field.
	CAN0_RXIMR_MI16_Pos = 0x10
	// Bit mask of MI16 field.
	CAN0_RXIMR_MI16_Msk = 0x10000
	// Bit MI16.
	CAN0_RXIMR_MI16 = 0x10000
	// The corresponding bit in the filter is "don't care."
	CAN0_RXIMR_MI16_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXIMR_MI16_1 = 0x1
	// Position of MI17 field.
	CAN0_RXIMR_MI17_Pos = 0x11
	// Bit mask of MI17 field.
	CAN0_RXIMR_MI17_Msk = 0x20000
	// Bit MI17.
	CAN0_RXIMR_MI17 = 0x20000
	// The corresponding bit in the filter is "don't care."
	CAN0_RXIMR_MI17_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXIMR_MI17_1 = 0x1
	// Position of MI18 field.
	CAN0_RXIMR_MI18_Pos = 0x12
	// Bit mask of MI18 field.
	CAN0_RXIMR_MI18_Msk = 0x40000
	// Bit MI18.
	CAN0_RXIMR_MI18 = 0x40000
	// The corresponding bit in the filter is "don't care."
	CAN0_RXIMR_MI18_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXIMR_MI18_1 = 0x1
	// Position of MI19 field.
	CAN0_RXIMR_MI19_Pos = 0x13
	// Bit mask of MI19 field.
	CAN0_RXIMR_MI19_Msk = 0x80000
	// Bit MI19.
	CAN0_RXIMR_MI19 = 0x80000
	// The corresponding bit in the filter is "don't care."
	CAN0_RXIMR_MI19_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXIMR_MI19_1 = 0x1
	// Position of MI20 field.
	CAN0_RXIMR_MI20_Pos = 0x14
	// Bit mask of MI20 field.
	CAN0_RXIMR_MI20_Msk = 0x100000
	// Bit MI20.
	CAN0_RXIMR_MI20 = 0x100000
	// The corresponding bit in the filter is "don't care."
	CAN0_RXIMR_MI20_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXIMR_MI20_1 = 0x1
	// Position of MI21 field.
	CAN0_RXIMR_MI21_Pos = 0x15
	// Bit mask of MI21 field.
	CAN0_RXIMR_MI21_Msk = 0x200000
	// Bit MI21.
	CAN0_RXIMR_MI21 = 0x200000
	// The corresponding bit in the filter is "don't care."
	CAN0_RXIMR_MI21_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXIMR_MI21_1 = 0x1
	// Position of MI22 field.
	CAN0_RXIMR_MI22_Pos = 0x16
	// Bit mask of MI22 field.
	CAN0_RXIMR_MI22_Msk = 0x400000
	// Bit MI22.
	CAN0_RXIMR_MI22 = 0x400000
	// The corresponding bit in the filter is "don't care."
	CAN0_RXIMR_MI22_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXIMR_MI22_1 = 0x1
	// Position of MI23 field.
	CAN0_RXIMR_MI23_Pos = 0x17
	// Bit mask of MI23 field.
	CAN0_RXIMR_MI23_Msk = 0x800000
	// Bit MI23.
	CAN0_RXIMR_MI23 = 0x800000
	// The corresponding bit in the filter is "don't care."
	CAN0_RXIMR_MI23_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXIMR_MI23_1 = 0x1
	// Position of MI24 field.
	CAN0_RXIMR_MI24_Pos = 0x18
	// Bit mask of MI24 field.
	CAN0_RXIMR_MI24_Msk = 0x1000000
	// Bit MI24.
	CAN0_RXIMR_MI24 = 0x1000000
	// The corresponding bit in the filter is "don't care."
	CAN0_RXIMR_MI24_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXIMR_MI24_1 = 0x1
	// Position of MI25 field.
	CAN0_RXIMR_MI25_Pos = 0x19
	// Bit mask of MI25 field.
	CAN0_RXIMR_MI25_Msk = 0x2000000
	// Bit MI25.
	CAN0_RXIMR_MI25 = 0x2000000
	// The corresponding bit in the filter is "don't care."
	CAN0_RXIMR_MI25_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXIMR_MI25_1 = 0x1
	// Position of MI26 field.
	CAN0_RXIMR_MI26_Pos = 0x1a
	// Bit mask of MI26 field.
	CAN0_RXIMR_MI26_Msk = 0x4000000
	// Bit MI26.
	CAN0_RXIMR_MI26 = 0x4000000
	// The corresponding bit in the filter is "don't care."
	CAN0_RXIMR_MI26_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXIMR_MI26_1 = 0x1
	// Position of MI27 field.
	CAN0_RXIMR_MI27_Pos = 0x1b
	// Bit mask of MI27 field.
	CAN0_RXIMR_MI27_Msk = 0x8000000
	// Bit MI27.
	CAN0_RXIMR_MI27 = 0x8000000
	// The corresponding bit in the filter is "don't care."
	CAN0_RXIMR_MI27_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXIMR_MI27_1 = 0x1
	// Position of MI28 field.
	CAN0_RXIMR_MI28_Pos = 0x1c
	// Bit mask of MI28 field.
	CAN0_RXIMR_MI28_Msk = 0x10000000
	// Bit MI28.
	CAN0_RXIMR_MI28 = 0x10000000
	// The corresponding bit in the filter is "don't care."
	CAN0_RXIMR_MI28_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXIMR_MI28_1 = 0x1
	// Position of MI29 field.
	CAN0_RXIMR_MI29_Pos = 0x1d
	// Bit mask of MI29 field.
	CAN0_RXIMR_MI29_Msk = 0x20000000
	// Bit MI29.
	CAN0_RXIMR_MI29 = 0x20000000
	// The corresponding bit in the filter is "don't care."
	CAN0_RXIMR_MI29_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXIMR_MI29_1 = 0x1
	// Position of MI30 field.
	CAN0_RXIMR_MI30_Pos = 0x1e
	// Bit mask of MI30 field.
	CAN0_RXIMR_MI30_Msk = 0x40000000
	// Bit MI30.
	CAN0_RXIMR_MI30 = 0x40000000
	// The corresponding bit in the filter is "don't care."
	CAN0_RXIMR_MI30_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXIMR_MI30_1 = 0x1
	// Position of MI31 field.
	CAN0_RXIMR_MI31_Pos = 0x1f
	// Bit mask of MI31 field.
	CAN0_RXIMR_MI31_Msk = 0x80000000
	// Bit MI31.
	CAN0_RXIMR_MI31 = 0x80000000
	// The corresponding bit in the filter is "don't care."
	CAN0_RXIMR_MI31_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN0_RXIMR_MI31_1 = 0x1
)

// Constants for RNG: Random Number Generator Accelerator
const (
	// CR: RNGA Control Register
	// Position of GO field.
	RNG_CR_GO_Pos = 0x0
	// Bit mask of GO field.
	RNG_CR_GO_Msk = 0x1
	// Bit GO.
	RNG_CR_GO = 0x1
	// Disabled
	RNG_CR_GO_0 = 0x0
	// Enabled
	RNG_CR_GO_1 = 0x1
	// Position of HA field.
	RNG_CR_HA_Pos = 0x1
	// Bit mask of HA field.
	RNG_CR_HA_Msk = 0x2
	// Bit HA.
	RNG_CR_HA = 0x2
	// Disabled
	RNG_CR_HA_0 = 0x0
	// Enabled
	RNG_CR_HA_1 = 0x1
	// Position of INTM field.
	RNG_CR_INTM_Pos = 0x2
	// Bit mask of INTM field.
	RNG_CR_INTM_Msk = 0x4
	// Bit INTM.
	RNG_CR_INTM = 0x4
	// Not masked
	RNG_CR_INTM_0 = 0x0
	// Masked
	RNG_CR_INTM_1 = 0x1
	// Position of CLRI field.
	RNG_CR_CLRI_Pos = 0x3
	// Bit mask of CLRI field.
	RNG_CR_CLRI_Msk = 0x8
	// Bit CLRI.
	RNG_CR_CLRI = 0x8
	// Do not clear the interrupt.
	RNG_CR_CLRI_0 = 0x0
	// Clear the interrupt. When you write 1 to this field, RNGA then resets the error-interrupt indicator (SR[ERRI]). This bit always reads as 0.
	RNG_CR_CLRI_1 = 0x1
	// Position of SLP field.
	RNG_CR_SLP_Pos = 0x4
	// Bit mask of SLP field.
	RNG_CR_SLP_Msk = 0x10
	// Bit SLP.
	RNG_CR_SLP = 0x10
	// Normal mode
	RNG_CR_SLP_0 = 0x0
	// Sleep (low-power) mode
	RNG_CR_SLP_1 = 0x1

	// SR: RNGA Status Register
	// Position of SECV field.
	RNG_SR_SECV_Pos = 0x0
	// Bit mask of SECV field.
	RNG_SR_SECV_Msk = 0x1
	// Bit SECV.
	RNG_SR_SECV = 0x1
	// No security violation
	RNG_SR_SECV_0 = 0x0
	// Security violation
	RNG_SR_SECV_1 = 0x1
	// Position of LRS field.
	RNG_SR_LRS_Pos = 0x1
	// Bit mask of LRS field.
	RNG_SR_LRS_Msk = 0x2
	// Bit LRS.
	RNG_SR_LRS = 0x2
	// No underflow
	RNG_SR_LRS_0 = 0x0
	// Underflow
	RNG_SR_LRS_1 = 0x1
	// Position of ORU field.
	RNG_SR_ORU_Pos = 0x2
	// Bit mask of ORU field.
	RNG_SR_ORU_Msk = 0x4
	// Bit ORU.
	RNG_SR_ORU = 0x4
	// No underflow
	RNG_SR_ORU_0 = 0x0
	// Underflow
	RNG_SR_ORU_1 = 0x1
	// Position of ERRI field.
	RNG_SR_ERRI_Pos = 0x3
	// Bit mask of ERRI field.
	RNG_SR_ERRI_Msk = 0x8
	// Bit ERRI.
	RNG_SR_ERRI = 0x8
	// No underflow
	RNG_SR_ERRI_0 = 0x0
	// Underflow
	RNG_SR_ERRI_1 = 0x1
	// Position of SLP field.
	RNG_SR_SLP_Pos = 0x4
	// Bit mask of SLP field.
	RNG_SR_SLP_Msk = 0x10
	// Bit SLP.
	RNG_SR_SLP = 0x10
	// Normal mode
	RNG_SR_SLP_0 = 0x0
	// Sleep (low-power) mode
	RNG_SR_SLP_1 = 0x1
	// Position of OREG_LVL field.
	RNG_SR_OREG_LVL_Pos = 0x8
	// Bit mask of OREG_LVL field.
	RNG_SR_OREG_LVL_Msk = 0xff00
	// No words (empty)
	RNG_SR_OREG_LVL_0 = 0x0
	// One word (valid)
	RNG_SR_OREG_LVL_1 = 0x1
	// Position of OREG_SIZE field.
	RNG_SR_OREG_SIZE_Pos = 0x10
	// Bit mask of OREG_SIZE field.
	RNG_SR_OREG_SIZE_Msk = 0xff0000
	// One word (this value is fixed)
	RNG_SR_OREG_SIZE_1 = 0x1

	// ER: RNGA Entropy Register
	// Position of EXT_ENT field.
	RNG_ER_EXT_ENT_Pos = 0x0
	// Bit mask of EXT_ENT field.
	RNG_ER_EXT_ENT_Msk = 0xffffffff

	// OR: RNGA Output Register
	// Position of RANDOUT field.
	RNG_OR_RANDOUT_Pos = 0x0
	// Bit mask of RANDOUT field.
	RNG_OR_RANDOUT_Msk = 0xffffffff
	// Invalid data (if you read this field when it is 0 and SR[OREG_LVL] is 0, RNGA then writes 1 to SR[ERRI], SR[ORU], and SR[LRS]; when the error interrupt is not masked (CR[INTM]=0), RNGA also asserts an error interrupt request to the interrupt controller).
	RNG_OR_RANDOUT_0 = 0x0
)

// Constants for SPI0: Serial Peripheral Interface
const (
	// MCR: Module Configuration Register
	// Position of HALT field.
	SPI_MCR_HALT_Pos = 0x0
	// Bit mask of HALT field.
	SPI_MCR_HALT_Msk = 0x1
	// Bit HALT.
	SPI_MCR_HALT = 0x1
	// Start transfers.
	SPI_MCR_HALT_0 = 0x0
	// Stop transfers.
	SPI_MCR_HALT_1 = 0x1
	// Position of SMPL_PT field.
	SPI_MCR_SMPL_PT_Pos = 0x8
	// Bit mask of SMPL_PT field.
	SPI_MCR_SMPL_PT_Msk = 0x300
	// 0 protocol clock cycles between SCK edge and SIN sample
	SPI_MCR_SMPL_PT_00 = 0x0
	// 1 protocol clock cycle between SCK edge and SIN sample
	SPI_MCR_SMPL_PT_01 = 0x1
	// 2 protocol clock cycles between SCK edge and SIN sample
	SPI_MCR_SMPL_PT_10 = 0x2
	// Position of CLR_RXF field.
	SPI_MCR_CLR_RXF_Pos = 0xa
	// Bit mask of CLR_RXF field.
	SPI_MCR_CLR_RXF_Msk = 0x400
	// Bit CLR_RXF.
	SPI_MCR_CLR_RXF = 0x400
	// Do not clear the RX FIFO counter.
	SPI_MCR_CLR_RXF_0 = 0x0
	// Clear the RX FIFO counter.
	SPI_MCR_CLR_RXF_1 = 0x1
	// Position of CLR_TXF field.
	SPI_MCR_CLR_TXF_Pos = 0xb
	// Bit mask of CLR_TXF field.
	SPI_MCR_CLR_TXF_Msk = 0x800
	// Bit CLR_TXF.
	SPI_MCR_CLR_TXF = 0x800
	// Do not clear the TX FIFO counter.
	SPI_MCR_CLR_TXF_0 = 0x0
	// Clear the TX FIFO counter.
	SPI_MCR_CLR_TXF_1 = 0x1
	// Position of DIS_RXF field.
	SPI_MCR_DIS_RXF_Pos = 0xc
	// Bit mask of DIS_RXF field.
	SPI_MCR_DIS_RXF_Msk = 0x1000
	// Bit DIS_RXF.
	SPI_MCR_DIS_RXF = 0x1000
	// RX FIFO is enabled.
	SPI_MCR_DIS_RXF_0 = 0x0
	// RX FIFO is disabled.
	SPI_MCR_DIS_RXF_1 = 0x1
	// Position of DIS_TXF field.
	SPI_MCR_DIS_TXF_Pos = 0xd
	// Bit mask of DIS_TXF field.
	SPI_MCR_DIS_TXF_Msk = 0x2000
	// Bit DIS_TXF.
	SPI_MCR_DIS_TXF = 0x2000
	// TX FIFO is enabled.
	SPI_MCR_DIS_TXF_0 = 0x0
	// TX FIFO is disabled.
	SPI_MCR_DIS_TXF_1 = 0x1
	// Position of MDIS field.
	SPI_MCR_MDIS_Pos = 0xe
	// Bit mask of MDIS field.
	SPI_MCR_MDIS_Msk = 0x4000
	// Bit MDIS.
	SPI_MCR_MDIS = 0x4000
	// Enables the module clocks.
	SPI_MCR_MDIS_0 = 0x0
	// Allows external logic to disable the module clocks.
	SPI_MCR_MDIS_1 = 0x1
	// Position of DOZE field.
	SPI_MCR_DOZE_Pos = 0xf
	// Bit mask of DOZE field.
	SPI_MCR_DOZE_Msk = 0x8000
	// Bit DOZE.
	SPI_MCR_DOZE = 0x8000
	// Doze mode has no effect on the module.
	SPI_MCR_DOZE_0 = 0x0
	// Doze mode disables the module.
	SPI_MCR_DOZE_1 = 0x1
	// Position of PCSIS0 field.
	SPI_MCR_PCSIS0_Pos = 0x10
	// Bit mask of PCSIS0 field.
	SPI_MCR_PCSIS0_Msk = 0x10000
	// Bit PCSIS0.
	SPI_MCR_PCSIS0 = 0x10000
	// The inactive state of PCSx is low.
	SPI_MCR_PCSIS0_0 = 0x0
	// The inactive state of PCSx is high.
	SPI_MCR_PCSIS0_1 = 0x1
	// Position of PCSIS1 field.
	SPI_MCR_PCSIS1_Pos = 0x11
	// Bit mask of PCSIS1 field.
	SPI_MCR_PCSIS1_Msk = 0x20000
	// Bit PCSIS1.
	SPI_MCR_PCSIS1 = 0x20000
	// The inactive state of PCSx is low.
	SPI_MCR_PCSIS1_0 = 0x0
	// The inactive state of PCSx is high.
	SPI_MCR_PCSIS1_1 = 0x1
	// Position of PCSIS2 field.
	SPI_MCR_PCSIS2_Pos = 0x12
	// Bit mask of PCSIS2 field.
	SPI_MCR_PCSIS2_Msk = 0x40000
	// Bit PCSIS2.
	SPI_MCR_PCSIS2 = 0x40000
	// The inactive state of PCSx is low.
	SPI_MCR_PCSIS2_0 = 0x0
	// The inactive state of PCSx is high.
	SPI_MCR_PCSIS2_1 = 0x1
	// Position of PCSIS3 field.
	SPI_MCR_PCSIS3_Pos = 0x13
	// Bit mask of PCSIS3 field.
	SPI_MCR_PCSIS3_Msk = 0x80000
	// Bit PCSIS3.
	SPI_MCR_PCSIS3 = 0x80000
	// The inactive state of PCSx is low.
	SPI_MCR_PCSIS3_0 = 0x0
	// The inactive state of PCSx is high.
	SPI_MCR_PCSIS3_1 = 0x1
	// Position of PCSIS4 field.
	SPI_MCR_PCSIS4_Pos = 0x14
	// Bit mask of PCSIS4 field.
	SPI_MCR_PCSIS4_Msk = 0x100000
	// Bit PCSIS4.
	SPI_MCR_PCSIS4 = 0x100000
	// The inactive state of PCSx is low.
	SPI_MCR_PCSIS4_0 = 0x0
	// The inactive state of PCSx is high.
	SPI_MCR_PCSIS4_1 = 0x1
	// Position of PCSIS5 field.
	SPI_MCR_PCSIS5_Pos = 0x15
	// Bit mask of PCSIS5 field.
	SPI_MCR_PCSIS5_Msk = 0x200000
	// Bit PCSIS5.
	SPI_MCR_PCSIS5 = 0x200000
	// The inactive state of PCSx is low.
	SPI_MCR_PCSIS5_0 = 0x0
	// The inactive state of PCSx is high.
	SPI_MCR_PCSIS5_1 = 0x1
	// Position of ROOE field.
	SPI_MCR_ROOE_Pos = 0x18
	// Bit mask of ROOE field.
	SPI_MCR_ROOE_Msk = 0x1000000
	// Bit ROOE.
	SPI_MCR_ROOE = 0x1000000
	// Incoming data is ignored.
	SPI_MCR_ROOE_0 = 0x0
	// Incoming data is shifted into the shift register.
	SPI_MCR_ROOE_1 = 0x1
	// Position of PCSSE field.
	SPI_MCR_PCSSE_Pos = 0x19
	// Bit mask of PCSSE field.
	SPI_MCR_PCSSE_Msk = 0x2000000
	// Bit PCSSE.
	SPI_MCR_PCSSE = 0x2000000
	// PCS5/ PCSS is used as the Peripheral Chip Select[5] signal.
	SPI_MCR_PCSSE_0 = 0x0
	// PCS5/ PCSS is used as an active-low PCS Strobe signal.
	SPI_MCR_PCSSE_1 = 0x1
	// Position of MTFE field.
	SPI_MCR_MTFE_Pos = 0x1a
	// Bit mask of MTFE field.
	SPI_MCR_MTFE_Msk = 0x4000000
	// Bit MTFE.
	SPI_MCR_MTFE = 0x4000000
	// Modified SPI transfer format disabled.
	SPI_MCR_MTFE_0 = 0x0
	// Modified SPI transfer format enabled.
	SPI_MCR_MTFE_1 = 0x1
	// Position of FRZ field.
	SPI_MCR_FRZ_Pos = 0x1b
	// Bit mask of FRZ field.
	SPI_MCR_FRZ_Msk = 0x8000000
	// Bit FRZ.
	SPI_MCR_FRZ = 0x8000000
	// Do not halt serial transfers in Debug mode.
	SPI_MCR_FRZ_0 = 0x0
	// Halt serial transfers in Debug mode.
	SPI_MCR_FRZ_1 = 0x1
	// Position of DCONF field.
	SPI_MCR_DCONF_Pos = 0x1c
	// Bit mask of DCONF field.
	SPI_MCR_DCONF_Msk = 0x30000000
	// SPI
	SPI_MCR_DCONF_00 = 0x0
	// Position of CONT_SCKE field.
	SPI_MCR_CONT_SCKE_Pos = 0x1e
	// Bit mask of CONT_SCKE field.
	SPI_MCR_CONT_SCKE_Msk = 0x40000000
	// Bit CONT_SCKE.
	SPI_MCR_CONT_SCKE = 0x40000000
	// Continuous SCK disabled.
	SPI_MCR_CONT_SCKE_0 = 0x0
	// Continuous SCK enabled.
	SPI_MCR_CONT_SCKE_1 = 0x1
	// Position of MSTR field.
	SPI_MCR_MSTR_Pos = 0x1f
	// Bit mask of MSTR field.
	SPI_MCR_MSTR_Msk = 0x80000000
	// Bit MSTR.
	SPI_MCR_MSTR = 0x80000000
	// Enables Slave mode
	SPI_MCR_MSTR_0 = 0x0
	// Enables Master mode
	SPI_MCR_MSTR_1 = 0x1

	// TCR: Transfer Count Register
	// Position of SPI_TCNT field.
	SPI_TCR_SPI_TCNT_Pos = 0x10
	// Bit mask of SPI_TCNT field.
	SPI_TCR_SPI_TCNT_Msk = 0xffff0000

	// CTAR0: Clock and Transfer Attributes Register (In Master Mode)
	// Position of BR field.
	SPI_CTAR_BR_Pos = 0x0
	// Bit mask of BR field.
	SPI_CTAR_BR_Msk = 0xf
	// Position of DT field.
	SPI_CTAR_DT_Pos = 0x4
	// Bit mask of DT field.
	SPI_CTAR_DT_Msk = 0xf0
	// Position of ASC field.
	SPI_CTAR_ASC_Pos = 0x8
	// Bit mask of ASC field.
	SPI_CTAR_ASC_Msk = 0xf00
	// Position of CSSCK field.
	SPI_CTAR_CSSCK_Pos = 0xc
	// Bit mask of CSSCK field.
	SPI_CTAR_CSSCK_Msk = 0xf000
	// Position of PBR field.
	SPI_CTAR_PBR_Pos = 0x10
	// Bit mask of PBR field.
	SPI_CTAR_PBR_Msk = 0x30000
	// Baud Rate Prescaler value is 2.
	SPI_CTAR_PBR_00 = 0x0
	// Baud Rate Prescaler value is 3.
	SPI_CTAR_PBR_01 = 0x1
	// Baud Rate Prescaler value is 5.
	SPI_CTAR_PBR_10 = 0x2
	// Baud Rate Prescaler value is 7.
	SPI_CTAR_PBR_11 = 0x3
	// Position of PDT field.
	SPI_CTAR_PDT_Pos = 0x12
	// Bit mask of PDT field.
	SPI_CTAR_PDT_Msk = 0xc0000
	// Delay after Transfer Prescaler value is 1.
	SPI_CTAR_PDT_00 = 0x0
	// Delay after Transfer Prescaler value is 3.
	SPI_CTAR_PDT_01 = 0x1
	// Delay after Transfer Prescaler value is 5.
	SPI_CTAR_PDT_10 = 0x2
	// Delay after Transfer Prescaler value is 7.
	SPI_CTAR_PDT_11 = 0x3
	// Position of PASC field.
	SPI_CTAR_PASC_Pos = 0x14
	// Bit mask of PASC field.
	SPI_CTAR_PASC_Msk = 0x300000
	// Delay after Transfer Prescaler value is 1.
	SPI_CTAR_PASC_00 = 0x0
	// Delay after Transfer Prescaler value is 3.
	SPI_CTAR_PASC_01 = 0x1
	// Delay after Transfer Prescaler value is 5.
	SPI_CTAR_PASC_10 = 0x2
	// Delay after Transfer Prescaler value is 7.
	SPI_CTAR_PASC_11 = 0x3
	// Position of PCSSCK field.
	SPI_CTAR_PCSSCK_Pos = 0x16
	// Bit mask of PCSSCK field.
	SPI_CTAR_PCSSCK_Msk = 0xc00000
	// PCS to SCK Prescaler value is 1.
	SPI_CTAR_PCSSCK_00 = 0x0
	// PCS to SCK Prescaler value is 3.
	SPI_CTAR_PCSSCK_01 = 0x1
	// PCS to SCK Prescaler value is 5.
	SPI_CTAR_PCSSCK_10 = 0x2
	// PCS to SCK Prescaler value is 7.
	SPI_CTAR_PCSSCK_11 = 0x3
	// Position of LSBFE field.
	SPI_CTAR_LSBFE_Pos = 0x18
	// Bit mask of LSBFE field.
	SPI_CTAR_LSBFE_Msk = 0x1000000
	// Bit LSBFE.
	SPI_CTAR_LSBFE = 0x1000000
	// Data is transferred MSB first.
	SPI_CTAR_LSBFE_0 = 0x0
	// Data is transferred LSB first.
	SPI_CTAR_LSBFE_1 = 0x1
	// Position of CPHA field.
	SPI_CTAR_CPHA_Pos = 0x19
	// Bit mask of CPHA field.
	SPI_CTAR_CPHA_Msk = 0x2000000
	// Bit CPHA.
	SPI_CTAR_CPHA = 0x2000000
	// Data is captured on the leading edge of SCK and changed on the following edge.
	SPI_CTAR_CPHA_0 = 0x0
	// Data is changed on the leading edge of SCK and captured on the following edge.
	SPI_CTAR_CPHA_1 = 0x1
	// Position of CPOL field.
	SPI_CTAR_CPOL_Pos = 0x1a
	// Bit mask of CPOL field.
	SPI_CTAR_CPOL_Msk = 0x4000000
	// Bit CPOL.
	SPI_CTAR_CPOL = 0x4000000
	// The inactive state value of SCK is low.
	SPI_CTAR_CPOL_0 = 0x0
	// The inactive state value of SCK is high.
	SPI_CTAR_CPOL_1 = 0x1
	// Position of FMSZ field.
	SPI_CTAR_FMSZ_Pos = 0x1b
	// Bit mask of FMSZ field.
	SPI_CTAR_FMSZ_Msk = 0x78000000
	// Position of DBR field.
	SPI_CTAR_DBR_Pos = 0x1f
	// Bit mask of DBR field.
	SPI_CTAR_DBR_Msk = 0x80000000
	// Bit DBR.
	SPI_CTAR_DBR = 0x80000000
	// The baud rate is computed normally with a 50/50 duty cycle.
	SPI_CTAR_DBR_0 = 0x0
	// The baud rate is doubled with the duty cycle depending on the Baud Rate Prescaler.
	SPI_CTAR_DBR_1 = 0x1

	// CTAR_SLAVE: Clock and Transfer Attributes Register (In Slave Mode)
	// Position of CPHA field.
	SPI_CTAR_SLAVE_CPHA_Pos = 0x19
	// Bit mask of CPHA field.
	SPI_CTAR_SLAVE_CPHA_Msk = 0x2000000
	// Bit CPHA.
	SPI_CTAR_SLAVE_CPHA = 0x2000000
	// Data is captured on the leading edge of SCK and changed on the following edge.
	SPI_CTAR_SLAVE_CPHA_0 = 0x0
	// Data is changed on the leading edge of SCK and captured on the following edge.
	SPI_CTAR_SLAVE_CPHA_1 = 0x1
	// Position of CPOL field.
	SPI_CTAR_SLAVE_CPOL_Pos = 0x1a
	// Bit mask of CPOL field.
	SPI_CTAR_SLAVE_CPOL_Msk = 0x4000000
	// Bit CPOL.
	SPI_CTAR_SLAVE_CPOL = 0x4000000
	// The inactive state value of SCK is low.
	SPI_CTAR_SLAVE_CPOL_0 = 0x0
	// The inactive state value of SCK is high.
	SPI_CTAR_SLAVE_CPOL_1 = 0x1
	// Position of FMSZ field.
	SPI_CTAR_SLAVE_FMSZ_Pos = 0x1b
	// Bit mask of FMSZ field.
	SPI_CTAR_SLAVE_FMSZ_Msk = 0xf8000000

	// SR: Status Register
	// Position of POPNXTPTR field.
	SPI_SR_POPNXTPTR_Pos = 0x0
	// Bit mask of POPNXTPTR field.
	SPI_SR_POPNXTPTR_Msk = 0xf
	// Position of RXCTR field.
	SPI_SR_RXCTR_Pos = 0x4
	// Bit mask of RXCTR field.
	SPI_SR_RXCTR_Msk = 0xf0
	// Position of TXNXTPTR field.
	SPI_SR_TXNXTPTR_Pos = 0x8
	// Bit mask of TXNXTPTR field.
	SPI_SR_TXNXTPTR_Msk = 0xf00
	// Position of TXCTR field.
	SPI_SR_TXCTR_Pos = 0xc
	// Bit mask of TXCTR field.
	SPI_SR_TXCTR_Msk = 0xf000
	// Position of RFDF field.
	SPI_SR_RFDF_Pos = 0x11
	// Bit mask of RFDF field.
	SPI_SR_RFDF_Msk = 0x20000
	// Bit RFDF.
	SPI_SR_RFDF = 0x20000
	// RX FIFO is empty.
	SPI_SR_RFDF_0 = 0x0
	// RX FIFO is not empty.
	SPI_SR_RFDF_1 = 0x1
	// Position of RFOF field.
	SPI_SR_RFOF_Pos = 0x13
	// Bit mask of RFOF field.
	SPI_SR_RFOF_Msk = 0x80000
	// Bit RFOF.
	SPI_SR_RFOF = 0x80000
	// No Rx FIFO overflow.
	SPI_SR_RFOF_0 = 0x0
	// Rx FIFO overflow has occurred.
	SPI_SR_RFOF_1 = 0x1
	// Position of TFFF field.
	SPI_SR_TFFF_Pos = 0x19
	// Bit mask of TFFF field.
	SPI_SR_TFFF_Msk = 0x2000000
	// Bit TFFF.
	SPI_SR_TFFF = 0x2000000
	// TX FIFO is full.
	SPI_SR_TFFF_0 = 0x0
	// TX FIFO is not full.
	SPI_SR_TFFF_1 = 0x1
	// Position of TFUF field.
	SPI_SR_TFUF_Pos = 0x1b
	// Bit mask of TFUF field.
	SPI_SR_TFUF_Msk = 0x8000000
	// Bit TFUF.
	SPI_SR_TFUF = 0x8000000
	// No TX FIFO underflow.
	SPI_SR_TFUF_0 = 0x0
	// TX FIFO underflow has occurred.
	SPI_SR_TFUF_1 = 0x1
	// Position of EOQF field.
	SPI_SR_EOQF_Pos = 0x1c
	// Bit mask of EOQF field.
	SPI_SR_EOQF_Msk = 0x10000000
	// Bit EOQF.
	SPI_SR_EOQF = 0x10000000
	// EOQ is not set in the executing command.
	SPI_SR_EOQF_0 = 0x0
	// EOQ is set in the executing SPI command.
	SPI_SR_EOQF_1 = 0x1
	// Position of TXRXS field.
	SPI_SR_TXRXS_Pos = 0x1e
	// Bit mask of TXRXS field.
	SPI_SR_TXRXS_Msk = 0x40000000
	// Bit TXRXS.
	SPI_SR_TXRXS = 0x40000000
	// Transmit and receive operations are disabled (The module is in Stopped state).
	SPI_SR_TXRXS_0 = 0x0
	// Transmit and receive operations are enabled (The module is in Running state).
	SPI_SR_TXRXS_1 = 0x1
	// Position of TCF field.
	SPI_SR_TCF_Pos = 0x1f
	// Bit mask of TCF field.
	SPI_SR_TCF_Msk = 0x80000000
	// Bit TCF.
	SPI_SR_TCF = 0x80000000
	// Transfer not complete.
	SPI_SR_TCF_0 = 0x0
	// Transfer complete.
	SPI_SR_TCF_1 = 0x1

	// RSER: DMA/Interrupt Request Select and Enable Register
	// Position of RFDF_DIRS field.
	SPI_RSER_RFDF_DIRS_Pos = 0x10
	// Bit mask of RFDF_DIRS field.
	SPI_RSER_RFDF_DIRS_Msk = 0x10000
	// Bit RFDF_DIRS.
	SPI_RSER_RFDF_DIRS = 0x10000
	// Interrupt request.
	SPI_RSER_RFDF_DIRS_0 = 0x0
	// DMA request.
	SPI_RSER_RFDF_DIRS_1 = 0x1
	// Position of RFDF_RE field.
	SPI_RSER_RFDF_RE_Pos = 0x11
	// Bit mask of RFDF_RE field.
	SPI_RSER_RFDF_RE_Msk = 0x20000
	// Bit RFDF_RE.
	SPI_RSER_RFDF_RE = 0x20000
	// RFDF interrupt or DMA requests are disabled.
	SPI_RSER_RFDF_RE_0 = 0x0
	// RFDF interrupt or DMA requests are enabled.
	SPI_RSER_RFDF_RE_1 = 0x1
	// Position of RFOF_RE field.
	SPI_RSER_RFOF_RE_Pos = 0x13
	// Bit mask of RFOF_RE field.
	SPI_RSER_RFOF_RE_Msk = 0x80000
	// Bit RFOF_RE.
	SPI_RSER_RFOF_RE = 0x80000
	// RFOF interrupt requests are disabled.
	SPI_RSER_RFOF_RE_0 = 0x0
	// RFOF interrupt requests are enabled.
	SPI_RSER_RFOF_RE_1 = 0x1
	// Position of TFFF_DIRS field.
	SPI_RSER_TFFF_DIRS_Pos = 0x18
	// Bit mask of TFFF_DIRS field.
	SPI_RSER_TFFF_DIRS_Msk = 0x1000000
	// Bit TFFF_DIRS.
	SPI_RSER_TFFF_DIRS = 0x1000000
	// TFFF flag generates interrupt requests.
	SPI_RSER_TFFF_DIRS_0 = 0x0
	// TFFF flag generates DMA requests.
	SPI_RSER_TFFF_DIRS_1 = 0x1
	// Position of TFFF_RE field.
	SPI_RSER_TFFF_RE_Pos = 0x19
	// Bit mask of TFFF_RE field.
	SPI_RSER_TFFF_RE_Msk = 0x2000000
	// Bit TFFF_RE.
	SPI_RSER_TFFF_RE = 0x2000000
	// TFFF interrupts or DMA requests are disabled.
	SPI_RSER_TFFF_RE_0 = 0x0
	// TFFF interrupts or DMA requests are enabled.
	SPI_RSER_TFFF_RE_1 = 0x1
	// Position of TFUF_RE field.
	SPI_RSER_TFUF_RE_Pos = 0x1b
	// Bit mask of TFUF_RE field.
	SPI_RSER_TFUF_RE_Msk = 0x8000000
	// Bit TFUF_RE.
	SPI_RSER_TFUF_RE = 0x8000000
	// TFUF interrupt requests are disabled.
	SPI_RSER_TFUF_RE_0 = 0x0
	// TFUF interrupt requests are enabled.
	SPI_RSER_TFUF_RE_1 = 0x1
	// Position of EOQF_RE field.
	SPI_RSER_EOQF_RE_Pos = 0x1c
	// Bit mask of EOQF_RE field.
	SPI_RSER_EOQF_RE_Msk = 0x10000000
	// Bit EOQF_RE.
	SPI_RSER_EOQF_RE = 0x10000000
	// EOQF interrupt requests are disabled.
	SPI_RSER_EOQF_RE_0 = 0x0
	// EOQF interrupt requests are enabled.
	SPI_RSER_EOQF_RE_1 = 0x1
	// Position of TCF_RE field.
	SPI_RSER_TCF_RE_Pos = 0x1f
	// Bit mask of TCF_RE field.
	SPI_RSER_TCF_RE_Msk = 0x80000000
	// Bit TCF_RE.
	SPI_RSER_TCF_RE = 0x80000000
	// TCF interrupt requests are disabled.
	SPI_RSER_TCF_RE_0 = 0x0
	// TCF interrupt requests are enabled.
	SPI_RSER_TCF_RE_1 = 0x1

	// PUSHR: PUSH TX FIFO Register In Master Mode
	// Position of TXDATA field.
	SPI_PUSHR_TXDATA_Pos = 0x0
	// Bit mask of TXDATA field.
	SPI_PUSHR_TXDATA_Msk = 0xffff
	// Position of PCS0 field.
	SPI_PUSHR_PCS0_Pos = 0x10
	// Bit mask of PCS0 field.
	SPI_PUSHR_PCS0_Msk = 0x10000
	// Bit PCS0.
	SPI_PUSHR_PCS0 = 0x10000
	// Negate the PCS[x] signal.
	SPI_PUSHR_PCS0_0 = 0x0
	// Assert the PCS[x] signal.
	SPI_PUSHR_PCS0_1 = 0x1
	// Position of PCS1 field.
	SPI_PUSHR_PCS1_Pos = 0x11
	// Bit mask of PCS1 field.
	SPI_PUSHR_PCS1_Msk = 0x20000
	// Bit PCS1.
	SPI_PUSHR_PCS1 = 0x20000
	// Negate the PCS[x] signal.
	SPI_PUSHR_PCS1_0 = 0x0
	// Assert the PCS[x] signal.
	SPI_PUSHR_PCS1_1 = 0x1
	// Position of PCS2 field.
	SPI_PUSHR_PCS2_Pos = 0x12
	// Bit mask of PCS2 field.
	SPI_PUSHR_PCS2_Msk = 0x40000
	// Bit PCS2.
	SPI_PUSHR_PCS2 = 0x40000
	// Negate the PCS[x] signal.
	SPI_PUSHR_PCS2_0 = 0x0
	// Assert the PCS[x] signal.
	SPI_PUSHR_PCS2_1 = 0x1
	// Position of PCS3 field.
	SPI_PUSHR_PCS3_Pos = 0x13
	// Bit mask of PCS3 field.
	SPI_PUSHR_PCS3_Msk = 0x80000
	// Bit PCS3.
	SPI_PUSHR_PCS3 = 0x80000
	// Negate the PCS[x] signal.
	SPI_PUSHR_PCS3_0 = 0x0
	// Assert the PCS[x] signal.
	SPI_PUSHR_PCS3_1 = 0x1
	// Position of PCS4 field.
	SPI_PUSHR_PCS4_Pos = 0x14
	// Bit mask of PCS4 field.
	SPI_PUSHR_PCS4_Msk = 0x100000
	// Bit PCS4.
	SPI_PUSHR_PCS4 = 0x100000
	// Negate the PCS[x] signal.
	SPI_PUSHR_PCS4_0 = 0x0
	// Assert the PCS[x] signal.
	SPI_PUSHR_PCS4_1 = 0x1
	// Position of PCS5 field.
	SPI_PUSHR_PCS5_Pos = 0x15
	// Bit mask of PCS5 field.
	SPI_PUSHR_PCS5_Msk = 0x200000
	// Bit PCS5.
	SPI_PUSHR_PCS5 = 0x200000
	// Negate the PCS[x] signal.
	SPI_PUSHR_PCS5_0 = 0x0
	// Assert the PCS[x] signal.
	SPI_PUSHR_PCS5_1 = 0x1
	// Position of CTCNT field.
	SPI_PUSHR_CTCNT_Pos = 0x1a
	// Bit mask of CTCNT field.
	SPI_PUSHR_CTCNT_Msk = 0x4000000
	// Bit CTCNT.
	SPI_PUSHR_CTCNT = 0x4000000
	// Do not clear the TCR[TCNT] field.
	SPI_PUSHR_CTCNT_0 = 0x0
	// Clear the TCR[TCNT] field.
	SPI_PUSHR_CTCNT_1 = 0x1
	// Position of EOQ field.
	SPI_PUSHR_EOQ_Pos = 0x1b
	// Bit mask of EOQ field.
	SPI_PUSHR_EOQ_Msk = 0x8000000
	// Bit EOQ.
	SPI_PUSHR_EOQ = 0x8000000
	// The SPI data is not the last data to transfer.
	SPI_PUSHR_EOQ_0 = 0x0
	// The SPI data is the last data to transfer.
	SPI_PUSHR_EOQ_1 = 0x1
	// Position of CTAS field.
	SPI_PUSHR_CTAS_Pos = 0x1c
	// Bit mask of CTAS field.
	SPI_PUSHR_CTAS_Msk = 0x70000000
	// CTAR0
	SPI_PUSHR_CTAS_000 = 0x0
	// CTAR1
	SPI_PUSHR_CTAS_001 = 0x1
	// Position of CONT field.
	SPI_PUSHR_CONT_Pos = 0x1f
	// Bit mask of CONT field.
	SPI_PUSHR_CONT_Msk = 0x80000000
	// Bit CONT.
	SPI_PUSHR_CONT = 0x80000000
	// Return PCSn signals to their inactive state between transfers.
	SPI_PUSHR_CONT_0 = 0x0
	// Keep PCSn signals asserted between transfers.
	SPI_PUSHR_CONT_1 = 0x1

	// PUSHR_SLAVE: PUSH TX FIFO Register In Slave Mode
	// Position of TXDATA field.
	SPI_PUSHR_SLAVE_TXDATA_Pos = 0x0
	// Bit mask of TXDATA field.
	SPI_PUSHR_SLAVE_TXDATA_Msk = 0xffffffff

	// POPR: POP RX FIFO Register
	// Position of RXDATA field.
	SPI_POPR_RXDATA_Pos = 0x0
	// Bit mask of RXDATA field.
	SPI_POPR_RXDATA_Msk = 0xffffffff

	// TXFR0: Transmit FIFO Registers
	// Position of TXDATA field.
	SPI_TXFR_TXDATA_Pos = 0x0
	// Bit mask of TXDATA field.
	SPI_TXFR_TXDATA_Msk = 0xffff
	// Position of TXCMD_TXDATA field.
	SPI_TXFR_TXCMD_TXDATA_Pos = 0x10
	// Bit mask of TXCMD_TXDATA field.
	SPI_TXFR_TXCMD_TXDATA_Msk = 0xffff0000

	// RXFR0: Receive FIFO Registers
	// Position of RXDATA field.
	SPI_RXFR_RXDATA_Pos = 0x0
	// Bit mask of RXDATA field.
	SPI_RXFR_RXDATA_Msk = 0xffffffff
)

// Constants for I2S0: Inter-IC Sound / Synchronous Audio Interface
const (
	// TCSR: SAI Transmit Control Register
	// Position of FRDE field.
	I2S0_TCSR_FRDE_Pos = 0x0
	// Bit mask of FRDE field.
	I2S0_TCSR_FRDE_Msk = 0x1
	// Bit FRDE.
	I2S0_TCSR_FRDE = 0x1
	// Disables the DMA request.
	I2S0_TCSR_FRDE_0 = 0x0
	// Enables the DMA request.
	I2S0_TCSR_FRDE_1 = 0x1
	// Position of FWDE field.
	I2S0_TCSR_FWDE_Pos = 0x1
	// Bit mask of FWDE field.
	I2S0_TCSR_FWDE_Msk = 0x2
	// Bit FWDE.
	I2S0_TCSR_FWDE = 0x2
	// Disables the DMA request.
	I2S0_TCSR_FWDE_0 = 0x0
	// Enables the DMA request.
	I2S0_TCSR_FWDE_1 = 0x1
	// Position of FRIE field.
	I2S0_TCSR_FRIE_Pos = 0x8
	// Bit mask of FRIE field.
	I2S0_TCSR_FRIE_Msk = 0x100
	// Bit FRIE.
	I2S0_TCSR_FRIE = 0x100
	// Disables the interrupt.
	I2S0_TCSR_FRIE_0 = 0x0
	// Enables the interrupt.
	I2S0_TCSR_FRIE_1 = 0x1
	// Position of FWIE field.
	I2S0_TCSR_FWIE_Pos = 0x9
	// Bit mask of FWIE field.
	I2S0_TCSR_FWIE_Msk = 0x200
	// Bit FWIE.
	I2S0_TCSR_FWIE = 0x200
	// Disables the interrupt.
	I2S0_TCSR_FWIE_0 = 0x0
	// Enables the interrupt.
	I2S0_TCSR_FWIE_1 = 0x1
	// Position of FEIE field.
	I2S0_TCSR_FEIE_Pos = 0xa
	// Bit mask of FEIE field.
	I2S0_TCSR_FEIE_Msk = 0x400
	// Bit FEIE.
	I2S0_TCSR_FEIE = 0x400
	// Disables the interrupt.
	I2S0_TCSR_FEIE_0 = 0x0
	// Enables the interrupt.
	I2S0_TCSR_FEIE_1 = 0x1
	// Position of SEIE field.
	I2S0_TCSR_SEIE_Pos = 0xb
	// Bit mask of SEIE field.
	I2S0_TCSR_SEIE_Msk = 0x800
	// Bit SEIE.
	I2S0_TCSR_SEIE = 0x800
	// Disables interrupt.
	I2S0_TCSR_SEIE_0 = 0x0
	// Enables interrupt.
	I2S0_TCSR_SEIE_1 = 0x1
	// Position of WSIE field.
	I2S0_TCSR_WSIE_Pos = 0xc
	// Bit mask of WSIE field.
	I2S0_TCSR_WSIE_Msk = 0x1000
	// Bit WSIE.
	I2S0_TCSR_WSIE = 0x1000
	// Disables interrupt.
	I2S0_TCSR_WSIE_0 = 0x0
	// Enables interrupt.
	I2S0_TCSR_WSIE_1 = 0x1
	// Position of FRF field.
	I2S0_TCSR_FRF_Pos = 0x10
	// Bit mask of FRF field.
	I2S0_TCSR_FRF_Msk = 0x10000
	// Bit FRF.
	I2S0_TCSR_FRF = 0x10000
	// Transmit FIFO watermark has not been reached.
	I2S0_TCSR_FRF_0 = 0x0
	// Transmit FIFO watermark has been reached.
	I2S0_TCSR_FRF_1 = 0x1
	// Position of FWF field.
	I2S0_TCSR_FWF_Pos = 0x11
	// Bit mask of FWF field.
	I2S0_TCSR_FWF_Msk = 0x20000
	// Bit FWF.
	I2S0_TCSR_FWF = 0x20000
	// No enabled transmit FIFO is empty.
	I2S0_TCSR_FWF_0 = 0x0
	// Enabled transmit FIFO is empty.
	I2S0_TCSR_FWF_1 = 0x1
	// Position of FEF field.
	I2S0_TCSR_FEF_Pos = 0x12
	// Bit mask of FEF field.
	I2S0_TCSR_FEF_Msk = 0x40000
	// Bit FEF.
	I2S0_TCSR_FEF = 0x40000
	// Transmit underrun not detected.
	I2S0_TCSR_FEF_0 = 0x0
	// Transmit underrun detected.
	I2S0_TCSR_FEF_1 = 0x1
	// Position of SEF field.
	I2S0_TCSR_SEF_Pos = 0x13
	// Bit mask of SEF field.
	I2S0_TCSR_SEF_Msk = 0x80000
	// Bit SEF.
	I2S0_TCSR_SEF = 0x80000
	// Sync error not detected.
	I2S0_TCSR_SEF_0 = 0x0
	// Frame sync error detected.
	I2S0_TCSR_SEF_1 = 0x1
	// Position of WSF field.
	I2S0_TCSR_WSF_Pos = 0x14
	// Bit mask of WSF field.
	I2S0_TCSR_WSF_Msk = 0x100000
	// Bit WSF.
	I2S0_TCSR_WSF = 0x100000
	// Start of word not detected.
	I2S0_TCSR_WSF_0 = 0x0
	// Start of word detected.
	I2S0_TCSR_WSF_1 = 0x1
	// Position of SR field.
	I2S0_TCSR_SR_Pos = 0x18
	// Bit mask of SR field.
	I2S0_TCSR_SR_Msk = 0x1000000
	// Bit SR.
	I2S0_TCSR_SR = 0x1000000
	// No effect.
	I2S0_TCSR_SR_0 = 0x0
	// Software reset.
	I2S0_TCSR_SR_1 = 0x1
	// Position of FR field.
	I2S0_TCSR_FR_Pos = 0x19
	// Bit mask of FR field.
	I2S0_TCSR_FR_Msk = 0x2000000
	// Bit FR.
	I2S0_TCSR_FR = 0x2000000
	// No effect.
	I2S0_TCSR_FR_0 = 0x0
	// FIFO reset.
	I2S0_TCSR_FR_1 = 0x1
	// Position of BCE field.
	I2S0_TCSR_BCE_Pos = 0x1c
	// Bit mask of BCE field.
	I2S0_TCSR_BCE_Msk = 0x10000000
	// Bit BCE.
	I2S0_TCSR_BCE = 0x10000000
	// Transmit bit clock is disabled.
	I2S0_TCSR_BCE_0 = 0x0
	// Transmit bit clock is enabled.
	I2S0_TCSR_BCE_1 = 0x1
	// Position of DBGE field.
	I2S0_TCSR_DBGE_Pos = 0x1d
	// Bit mask of DBGE field.
	I2S0_TCSR_DBGE_Msk = 0x20000000
	// Bit DBGE.
	I2S0_TCSR_DBGE = 0x20000000
	// Transmitter is disabled in Debug mode, after completing the current frame.
	I2S0_TCSR_DBGE_0 = 0x0
	// Transmitter is enabled in Debug mode.
	I2S0_TCSR_DBGE_1 = 0x1
	// Position of STOPE field.
	I2S0_TCSR_STOPE_Pos = 0x1e
	// Bit mask of STOPE field.
	I2S0_TCSR_STOPE_Msk = 0x40000000
	// Bit STOPE.
	I2S0_TCSR_STOPE = 0x40000000
	// Transmitter disabled in Stop mode.
	I2S0_TCSR_STOPE_0 = 0x0
	// Transmitter enabled in Stop mode.
	I2S0_TCSR_STOPE_1 = 0x1
	// Position of TE field.
	I2S0_TCSR_TE_Pos = 0x1f
	// Bit mask of TE field.
	I2S0_TCSR_TE_Msk = 0x80000000
	// Bit TE.
	I2S0_TCSR_TE = 0x80000000
	// Transmitter is disabled.
	I2S0_TCSR_TE_0 = 0x0
	// Transmitter is enabled, or transmitter has been disabled and has not yet reached end of frame.
	I2S0_TCSR_TE_1 = 0x1

	// TCR1: SAI Transmit Configuration 1 Register
	// Position of TFW field.
	I2S0_TCR1_TFW_Pos = 0x0
	// Bit mask of TFW field.
	I2S0_TCR1_TFW_Msk = 0x7

	// TCR2: SAI Transmit Configuration 2 Register
	// Position of DIV field.
	I2S0_TCR2_DIV_Pos = 0x0
	// Bit mask of DIV field.
	I2S0_TCR2_DIV_Msk = 0xff
	// Position of BCD field.
	I2S0_TCR2_BCD_Pos = 0x18
	// Bit mask of BCD field.
	I2S0_TCR2_BCD_Msk = 0x1000000
	// Bit BCD.
	I2S0_TCR2_BCD = 0x1000000
	// Bit clock is generated externally in Slave mode.
	I2S0_TCR2_BCD_0 = 0x0
	// Bit clock is generated internally in Master mode.
	I2S0_TCR2_BCD_1 = 0x1
	// Position of BCP field.
	I2S0_TCR2_BCP_Pos = 0x19
	// Bit mask of BCP field.
	I2S0_TCR2_BCP_Msk = 0x2000000
	// Bit BCP.
	I2S0_TCR2_BCP = 0x2000000
	// Bit clock is active high with drive outputs on rising edge and sample inputs on falling edge.
	I2S0_TCR2_BCP_0 = 0x0
	// Bit clock is active low with drive outputs on falling edge and sample inputs on rising edge.
	I2S0_TCR2_BCP_1 = 0x1
	// Position of MSEL field.
	I2S0_TCR2_MSEL_Pos = 0x1a
	// Bit mask of MSEL field.
	I2S0_TCR2_MSEL_Msk = 0xc000000
	// Bus Clock selected.
	I2S0_TCR2_MSEL_00 = 0x0
	// Master Clock (MCLK) 1 option selected.
	I2S0_TCR2_MSEL_01 = 0x1
	// Master Clock (MCLK) 2 option selected.
	I2S0_TCR2_MSEL_10 = 0x2
	// Master Clock (MCLK) 3 option selected.
	I2S0_TCR2_MSEL_11 = 0x3
	// Position of BCI field.
	I2S0_TCR2_BCI_Pos = 0x1c
	// Bit mask of BCI field.
	I2S0_TCR2_BCI_Msk = 0x10000000
	// Bit BCI.
	I2S0_TCR2_BCI = 0x10000000
	// No effect.
	I2S0_TCR2_BCI_0 = 0x0
	// Internal logic is clocked as if bit clock was externally generated.
	I2S0_TCR2_BCI_1 = 0x1
	// Position of BCS field.
	I2S0_TCR2_BCS_Pos = 0x1d
	// Bit mask of BCS field.
	I2S0_TCR2_BCS_Msk = 0x20000000
	// Bit BCS.
	I2S0_TCR2_BCS = 0x20000000
	// Use the normal bit clock source.
	I2S0_TCR2_BCS_0 = 0x0
	// Swap the bit clock source.
	I2S0_TCR2_BCS_1 = 0x1
	// Position of SYNC field.
	I2S0_TCR2_SYNC_Pos = 0x1e
	// Bit mask of SYNC field.
	I2S0_TCR2_SYNC_Msk = 0xc0000000
	// Asynchronous mode.
	I2S0_TCR2_SYNC_00 = 0x0
	// Synchronous with receiver.
	I2S0_TCR2_SYNC_01 = 0x1
	// Synchronous with another SAI transmitter.
	I2S0_TCR2_SYNC_10 = 0x2
	// Synchronous with another SAI receiver.
	I2S0_TCR2_SYNC_11 = 0x3

	// TCR3: SAI Transmit Configuration 3 Register
	// Position of WDFL field.
	I2S0_TCR3_WDFL_Pos = 0x0
	// Bit mask of WDFL field.
	I2S0_TCR3_WDFL_Msk = 0x1f
	// Position of TCE0 field.
	I2S0_TCR3_TCE0_Pos = 0x10
	// Bit mask of TCE0 field.
	I2S0_TCR3_TCE0_Msk = 0x10000
	// Bit TCE0.
	I2S0_TCR3_TCE0 = 0x10000
	// Transmit data channel N is disabled.
	I2S0_TCR3_TCE0_0 = 0x0
	// Transmit data channel N is enabled.
	I2S0_TCR3_TCE0_1 = 0x1
	// Position of TCE1 field.
	I2S0_TCR3_TCE1_Pos = 0x11
	// Bit mask of TCE1 field.
	I2S0_TCR3_TCE1_Msk = 0x20000
	// Bit TCE1.
	I2S0_TCR3_TCE1 = 0x20000
	// Transmit data channel N is disabled.
	I2S0_TCR3_TCE1_0 = 0x0
	// Transmit data channel N is enabled.
	I2S0_TCR3_TCE1_1 = 0x1

	// TCR4: SAI Transmit Configuration 4 Register
	// Position of FSD field.
	I2S0_TCR4_FSD_Pos = 0x0
	// Bit mask of FSD field.
	I2S0_TCR4_FSD_Msk = 0x1
	// Bit FSD.
	I2S0_TCR4_FSD = 0x1
	// Frame sync is generated externally in Slave mode.
	I2S0_TCR4_FSD_0 = 0x0
	// Frame sync is generated internally in Master mode.
	I2S0_TCR4_FSD_1 = 0x1
	// Position of FSP field.
	I2S0_TCR4_FSP_Pos = 0x1
	// Bit mask of FSP field.
	I2S0_TCR4_FSP_Msk = 0x2
	// Bit FSP.
	I2S0_TCR4_FSP = 0x2
	// Frame sync is active high.
	I2S0_TCR4_FSP_0 = 0x0
	// Frame sync is active low.
	I2S0_TCR4_FSP_1 = 0x1
	// Position of FSE field.
	I2S0_TCR4_FSE_Pos = 0x3
	// Bit mask of FSE field.
	I2S0_TCR4_FSE_Msk = 0x8
	// Bit FSE.
	I2S0_TCR4_FSE = 0x8
	// Frame sync asserts with the first bit of the frame.
	I2S0_TCR4_FSE_0 = 0x0
	// Frame sync asserts one bit before the first bit of the frame.
	I2S0_TCR4_FSE_1 = 0x1
	// Position of MF field.
	I2S0_TCR4_MF_Pos = 0x4
	// Bit mask of MF field.
	I2S0_TCR4_MF_Msk = 0x10
	// Bit MF.
	I2S0_TCR4_MF = 0x10
	// LSB is transmitted first.
	I2S0_TCR4_MF_0 = 0x0
	// MSB is transmitted first.
	I2S0_TCR4_MF_1 = 0x1
	// Position of SYWD field.
	I2S0_TCR4_SYWD_Pos = 0x8
	// Bit mask of SYWD field.
	I2S0_TCR4_SYWD_Msk = 0x1f00
	// Position of FRSZ field.
	I2S0_TCR4_FRSZ_Pos = 0x10
	// Bit mask of FRSZ field.
	I2S0_TCR4_FRSZ_Msk = 0x1f0000

	// TCR5: SAI Transmit Configuration 5 Register
	// Position of FBT field.
	I2S0_TCR5_FBT_Pos = 0x8
	// Bit mask of FBT field.
	I2S0_TCR5_FBT_Msk = 0x1f00
	// Position of W0W field.
	I2S0_TCR5_W0W_Pos = 0x10
	// Bit mask of W0W field.
	I2S0_TCR5_W0W_Msk = 0x1f0000
	// Position of WNW field.
	I2S0_TCR5_WNW_Pos = 0x18
	// Bit mask of WNW field.
	I2S0_TCR5_WNW_Msk = 0x1f000000

	// TDR0: SAI Transmit Data Register
	// Position of TDR field.
	I2S0_TDR_TDR_Pos = 0x0
	// Bit mask of TDR field.
	I2S0_TDR_TDR_Msk = 0xffffffff

	// TFR0: SAI Transmit FIFO Register
	// Position of RFP field.
	I2S0_TFR_RFP_Pos = 0x0
	// Bit mask of RFP field.
	I2S0_TFR_RFP_Msk = 0xf
	// Position of WFP field.
	I2S0_TFR_WFP_Pos = 0x10
	// Bit mask of WFP field.
	I2S0_TFR_WFP_Msk = 0xf0000

	// TMR: SAI Transmit Mask Register
	// Position of TWM0 field.
	I2S0_TMR_TWM0_Pos = 0x0
	// Bit mask of TWM0 field.
	I2S0_TMR_TWM0_Msk = 0x1
	// Bit TWM0.
	I2S0_TMR_TWM0 = 0x1
	// Word N is enabled.
	I2S0_TMR_TWM0_0 = 0x0
	// Word N is masked. The transmit data pins are tri-stated when masked.
	I2S0_TMR_TWM0_1 = 0x1
	// Position of TWM1 field.
	I2S0_TMR_TWM1_Pos = 0x1
	// Bit mask of TWM1 field.
	I2S0_TMR_TWM1_Msk = 0x2
	// Bit TWM1.
	I2S0_TMR_TWM1 = 0x2
	// Word N is enabled.
	I2S0_TMR_TWM1_0 = 0x0
	// Word N is masked. The transmit data pins are tri-stated when masked.
	I2S0_TMR_TWM1_1 = 0x1
	// Position of TWM2 field.
	I2S0_TMR_TWM2_Pos = 0x2
	// Bit mask of TWM2 field.
	I2S0_TMR_TWM2_Msk = 0x4
	// Bit TWM2.
	I2S0_TMR_TWM2 = 0x4
	// Word N is enabled.
	I2S0_TMR_TWM2_0 = 0x0
	// Word N is masked. The transmit data pins are tri-stated when masked.
	I2S0_TMR_TWM2_1 = 0x1
	// Position of TWM3 field.
	I2S0_TMR_TWM3_Pos = 0x3
	// Bit mask of TWM3 field.
	I2S0_TMR_TWM3_Msk = 0x8
	// Bit TWM3.
	I2S0_TMR_TWM3 = 0x8
	// Word N is enabled.
	I2S0_TMR_TWM3_0 = 0x0
	// Word N is masked. The transmit data pins are tri-stated when masked.
	I2S0_TMR_TWM3_1 = 0x1
	// Position of TWM4 field.
	I2S0_TMR_TWM4_Pos = 0x4
	// Bit mask of TWM4 field.
	I2S0_TMR_TWM4_Msk = 0x10
	// Bit TWM4.
	I2S0_TMR_TWM4 = 0x10
	// Word N is enabled.
	I2S0_TMR_TWM4_0 = 0x0
	// Word N is masked. The transmit data pins are tri-stated when masked.
	I2S0_TMR_TWM4_1 = 0x1
	// Position of TWM5 field.
	I2S0_TMR_TWM5_Pos = 0x5
	// Bit mask of TWM5 field.
	I2S0_TMR_TWM5_Msk = 0x20
	// Bit TWM5.
	I2S0_TMR_TWM5 = 0x20
	// Word N is enabled.
	I2S0_TMR_TWM5_0 = 0x0
	// Word N is masked. The transmit data pins are tri-stated when masked.
	I2S0_TMR_TWM5_1 = 0x1
	// Position of TWM6 field.
	I2S0_TMR_TWM6_Pos = 0x6
	// Bit mask of TWM6 field.
	I2S0_TMR_TWM6_Msk = 0x40
	// Bit TWM6.
	I2S0_TMR_TWM6 = 0x40
	// Word N is enabled.
	I2S0_TMR_TWM6_0 = 0x0
	// Word N is masked. The transmit data pins are tri-stated when masked.
	I2S0_TMR_TWM6_1 = 0x1
	// Position of TWM7 field.
	I2S0_TMR_TWM7_Pos = 0x7
	// Bit mask of TWM7 field.
	I2S0_TMR_TWM7_Msk = 0x80
	// Bit TWM7.
	I2S0_TMR_TWM7 = 0x80
	// Word N is enabled.
	I2S0_TMR_TWM7_0 = 0x0
	// Word N is masked. The transmit data pins are tri-stated when masked.
	I2S0_TMR_TWM7_1 = 0x1
	// Position of TWM8 field.
	I2S0_TMR_TWM8_Pos = 0x8
	// Bit mask of TWM8 field.
	I2S0_TMR_TWM8_Msk = 0x100
	// Bit TWM8.
	I2S0_TMR_TWM8 = 0x100
	// Word N is enabled.
	I2S0_TMR_TWM8_0 = 0x0
	// Word N is masked. The transmit data pins are tri-stated when masked.
	I2S0_TMR_TWM8_1 = 0x1
	// Position of TWM9 field.
	I2S0_TMR_TWM9_Pos = 0x9
	// Bit mask of TWM9 field.
	I2S0_TMR_TWM9_Msk = 0x200
	// Bit TWM9.
	I2S0_TMR_TWM9 = 0x200
	// Word N is enabled.
	I2S0_TMR_TWM9_0 = 0x0
	// Word N is masked. The transmit data pins are tri-stated when masked.
	I2S0_TMR_TWM9_1 = 0x1
	// Position of TWM10 field.
	I2S0_TMR_TWM10_Pos = 0xa
	// Bit mask of TWM10 field.
	I2S0_TMR_TWM10_Msk = 0x400
	// Bit TWM10.
	I2S0_TMR_TWM10 = 0x400
	// Word N is enabled.
	I2S0_TMR_TWM10_0 = 0x0
	// Word N is masked. The transmit data pins are tri-stated when masked.
	I2S0_TMR_TWM10_1 = 0x1
	// Position of TWM11 field.
	I2S0_TMR_TWM11_Pos = 0xb
	// Bit mask of TWM11 field.
	I2S0_TMR_TWM11_Msk = 0x800
	// Bit TWM11.
	I2S0_TMR_TWM11 = 0x800
	// Word N is enabled.
	I2S0_TMR_TWM11_0 = 0x0
	// Word N is masked. The transmit data pins are tri-stated when masked.
	I2S0_TMR_TWM11_1 = 0x1
	// Position of TWM12 field.
	I2S0_TMR_TWM12_Pos = 0xc
	// Bit mask of TWM12 field.
	I2S0_TMR_TWM12_Msk = 0x1000
	// Bit TWM12.
	I2S0_TMR_TWM12 = 0x1000
	// Word N is enabled.
	I2S0_TMR_TWM12_0 = 0x0
	// Word N is masked. The transmit data pins are tri-stated when masked.
	I2S0_TMR_TWM12_1 = 0x1
	// Position of TWM13 field.
	I2S0_TMR_TWM13_Pos = 0xd
	// Bit mask of TWM13 field.
	I2S0_TMR_TWM13_Msk = 0x2000
	// Bit TWM13.
	I2S0_TMR_TWM13 = 0x2000
	// Word N is enabled.
	I2S0_TMR_TWM13_0 = 0x0
	// Word N is masked. The transmit data pins are tri-stated when masked.
	I2S0_TMR_TWM13_1 = 0x1
	// Position of TWM14 field.
	I2S0_TMR_TWM14_Pos = 0xe
	// Bit mask of TWM14 field.
	I2S0_TMR_TWM14_Msk = 0x4000
	// Bit TWM14.
	I2S0_TMR_TWM14 = 0x4000
	// Word N is enabled.
	I2S0_TMR_TWM14_0 = 0x0
	// Word N is masked. The transmit data pins are tri-stated when masked.
	I2S0_TMR_TWM14_1 = 0x1
	// Position of TWM15 field.
	I2S0_TMR_TWM15_Pos = 0xf
	// Bit mask of TWM15 field.
	I2S0_TMR_TWM15_Msk = 0x8000
	// Bit TWM15.
	I2S0_TMR_TWM15 = 0x8000
	// Word N is enabled.
	I2S0_TMR_TWM15_0 = 0x0
	// Word N is masked. The transmit data pins are tri-stated when masked.
	I2S0_TMR_TWM15_1 = 0x1
	// Position of TWM16 field.
	I2S0_TMR_TWM16_Pos = 0x10
	// Bit mask of TWM16 field.
	I2S0_TMR_TWM16_Msk = 0x10000
	// Bit TWM16.
	I2S0_TMR_TWM16 = 0x10000
	// Word N is enabled.
	I2S0_TMR_TWM16_0 = 0x0
	// Word N is masked. The transmit data pins are tri-stated when masked.
	I2S0_TMR_TWM16_1 = 0x1
	// Position of TWM17 field.
	I2S0_TMR_TWM17_Pos = 0x11
	// Bit mask of TWM17 field.
	I2S0_TMR_TWM17_Msk = 0x20000
	// Bit TWM17.
	I2S0_TMR_TWM17 = 0x20000
	// Word N is enabled.
	I2S0_TMR_TWM17_0 = 0x0
	// Word N is masked. The transmit data pins are tri-stated when masked.
	I2S0_TMR_TWM17_1 = 0x1
	// Position of TWM18 field.
	I2S0_TMR_TWM18_Pos = 0x12
	// Bit mask of TWM18 field.
	I2S0_TMR_TWM18_Msk = 0x40000
	// Bit TWM18.
	I2S0_TMR_TWM18 = 0x40000
	// Word N is enabled.
	I2S0_TMR_TWM18_0 = 0x0
	// Word N is masked. The transmit data pins are tri-stated when masked.
	I2S0_TMR_TWM18_1 = 0x1
	// Position of TWM19 field.
	I2S0_TMR_TWM19_Pos = 0x13
	// Bit mask of TWM19 field.
	I2S0_TMR_TWM19_Msk = 0x80000
	// Bit TWM19.
	I2S0_TMR_TWM19 = 0x80000
	// Word N is enabled.
	I2S0_TMR_TWM19_0 = 0x0
	// Word N is masked. The transmit data pins are tri-stated when masked.
	I2S0_TMR_TWM19_1 = 0x1
	// Position of TWM20 field.
	I2S0_TMR_TWM20_Pos = 0x14
	// Bit mask of TWM20 field.
	I2S0_TMR_TWM20_Msk = 0x100000
	// Bit TWM20.
	I2S0_TMR_TWM20 = 0x100000
	// Word N is enabled.
	I2S0_TMR_TWM20_0 = 0x0
	// Word N is masked. The transmit data pins are tri-stated when masked.
	I2S0_TMR_TWM20_1 = 0x1
	// Position of TWM21 field.
	I2S0_TMR_TWM21_Pos = 0x15
	// Bit mask of TWM21 field.
	I2S0_TMR_TWM21_Msk = 0x200000
	// Bit TWM21.
	I2S0_TMR_TWM21 = 0x200000
	// Word N is enabled.
	I2S0_TMR_TWM21_0 = 0x0
	// Word N is masked. The transmit data pins are tri-stated when masked.
	I2S0_TMR_TWM21_1 = 0x1
	// Position of TWM22 field.
	I2S0_TMR_TWM22_Pos = 0x16
	// Bit mask of TWM22 field.
	I2S0_TMR_TWM22_Msk = 0x400000
	// Bit TWM22.
	I2S0_TMR_TWM22 = 0x400000
	// Word N is enabled.
	I2S0_TMR_TWM22_0 = 0x0
	// Word N is masked. The transmit data pins are tri-stated when masked.
	I2S0_TMR_TWM22_1 = 0x1
	// Position of TWM23 field.
	I2S0_TMR_TWM23_Pos = 0x17
	// Bit mask of TWM23 field.
	I2S0_TMR_TWM23_Msk = 0x800000
	// Bit TWM23.
	I2S0_TMR_TWM23 = 0x800000
	// Word N is enabled.
	I2S0_TMR_TWM23_0 = 0x0
	// Word N is masked. The transmit data pins are tri-stated when masked.
	I2S0_TMR_TWM23_1 = 0x1
	// Position of TWM24 field.
	I2S0_TMR_TWM24_Pos = 0x18
	// Bit mask of TWM24 field.
	I2S0_TMR_TWM24_Msk = 0x1000000
	// Bit TWM24.
	I2S0_TMR_TWM24 = 0x1000000
	// Word N is enabled.
	I2S0_TMR_TWM24_0 = 0x0
	// Word N is masked. The transmit data pins are tri-stated when masked.
	I2S0_TMR_TWM24_1 = 0x1
	// Position of TWM25 field.
	I2S0_TMR_TWM25_Pos = 0x19
	// Bit mask of TWM25 field.
	I2S0_TMR_TWM25_Msk = 0x2000000
	// Bit TWM25.
	I2S0_TMR_TWM25 = 0x2000000
	// Word N is enabled.
	I2S0_TMR_TWM25_0 = 0x0
	// Word N is masked. The transmit data pins are tri-stated when masked.
	I2S0_TMR_TWM25_1 = 0x1
	// Position of TWM26 field.
	I2S0_TMR_TWM26_Pos = 0x1a
	// Bit mask of TWM26 field.
	I2S0_TMR_TWM26_Msk = 0x4000000
	// Bit TWM26.
	I2S0_TMR_TWM26 = 0x4000000
	// Word N is enabled.
	I2S0_TMR_TWM26_0 = 0x0
	// Word N is masked. The transmit data pins are tri-stated when masked.
	I2S0_TMR_TWM26_1 = 0x1
	// Position of TWM27 field.
	I2S0_TMR_TWM27_Pos = 0x1b
	// Bit mask of TWM27 field.
	I2S0_TMR_TWM27_Msk = 0x8000000
	// Bit TWM27.
	I2S0_TMR_TWM27 = 0x8000000
	// Word N is enabled.
	I2S0_TMR_TWM27_0 = 0x0
	// Word N is masked. The transmit data pins are tri-stated when masked.
	I2S0_TMR_TWM27_1 = 0x1
	// Position of TWM28 field.
	I2S0_TMR_TWM28_Pos = 0x1c
	// Bit mask of TWM28 field.
	I2S0_TMR_TWM28_Msk = 0x10000000
	// Bit TWM28.
	I2S0_TMR_TWM28 = 0x10000000
	// Word N is enabled.
	I2S0_TMR_TWM28_0 = 0x0
	// Word N is masked. The transmit data pins are tri-stated when masked.
	I2S0_TMR_TWM28_1 = 0x1
	// Position of TWM29 field.
	I2S0_TMR_TWM29_Pos = 0x1d
	// Bit mask of TWM29 field.
	I2S0_TMR_TWM29_Msk = 0x20000000
	// Bit TWM29.
	I2S0_TMR_TWM29 = 0x20000000
	// Word N is enabled.
	I2S0_TMR_TWM29_0 = 0x0
	// Word N is masked. The transmit data pins are tri-stated when masked.
	I2S0_TMR_TWM29_1 = 0x1
	// Position of TWM30 field.
	I2S0_TMR_TWM30_Pos = 0x1e
	// Bit mask of TWM30 field.
	I2S0_TMR_TWM30_Msk = 0x40000000
	// Bit TWM30.
	I2S0_TMR_TWM30 = 0x40000000
	// Word N is enabled.
	I2S0_TMR_TWM30_0 = 0x0
	// Word N is masked. The transmit data pins are tri-stated when masked.
	I2S0_TMR_TWM30_1 = 0x1
	// Position of TWM31 field.
	I2S0_TMR_TWM31_Pos = 0x1f
	// Bit mask of TWM31 field.
	I2S0_TMR_TWM31_Msk = 0x80000000
	// Bit TWM31.
	I2S0_TMR_TWM31 = 0x80000000
	// Word N is enabled.
	I2S0_TMR_TWM31_0 = 0x0
	// Word N is masked. The transmit data pins are tri-stated when masked.
	I2S0_TMR_TWM31_1 = 0x1

	// RCSR: SAI Receive Control Register
	// Position of FRDE field.
	I2S0_RCSR_FRDE_Pos = 0x0
	// Bit mask of FRDE field.
	I2S0_RCSR_FRDE_Msk = 0x1
	// Bit FRDE.
	I2S0_RCSR_FRDE = 0x1
	// Disables the DMA request.
	I2S0_RCSR_FRDE_0 = 0x0
	// Enables the DMA request.
	I2S0_RCSR_FRDE_1 = 0x1
	// Position of FWDE field.
	I2S0_RCSR_FWDE_Pos = 0x1
	// Bit mask of FWDE field.
	I2S0_RCSR_FWDE_Msk = 0x2
	// Bit FWDE.
	I2S0_RCSR_FWDE = 0x2
	// Disables the DMA request.
	I2S0_RCSR_FWDE_0 = 0x0
	// Enables the DMA request.
	I2S0_RCSR_FWDE_1 = 0x1
	// Position of FRIE field.
	I2S0_RCSR_FRIE_Pos = 0x8
	// Bit mask of FRIE field.
	I2S0_RCSR_FRIE_Msk = 0x100
	// Bit FRIE.
	I2S0_RCSR_FRIE = 0x100
	// Disables the interrupt.
	I2S0_RCSR_FRIE_0 = 0x0
	// Enables the interrupt.
	I2S0_RCSR_FRIE_1 = 0x1
	// Position of FWIE field.
	I2S0_RCSR_FWIE_Pos = 0x9
	// Bit mask of FWIE field.
	I2S0_RCSR_FWIE_Msk = 0x200
	// Bit FWIE.
	I2S0_RCSR_FWIE = 0x200
	// Disables the interrupt.
	I2S0_RCSR_FWIE_0 = 0x0
	// Enables the interrupt.
	I2S0_RCSR_FWIE_1 = 0x1
	// Position of FEIE field.
	I2S0_RCSR_FEIE_Pos = 0xa
	// Bit mask of FEIE field.
	I2S0_RCSR_FEIE_Msk = 0x400
	// Bit FEIE.
	I2S0_RCSR_FEIE = 0x400
	// Disables the interrupt.
	I2S0_RCSR_FEIE_0 = 0x0
	// Enables the interrupt.
	I2S0_RCSR_FEIE_1 = 0x1
	// Position of SEIE field.
	I2S0_RCSR_SEIE_Pos = 0xb
	// Bit mask of SEIE field.
	I2S0_RCSR_SEIE_Msk = 0x800
	// Bit SEIE.
	I2S0_RCSR_SEIE = 0x800
	// Disables interrupt.
	I2S0_RCSR_SEIE_0 = 0x0
	// Enables interrupt.
	I2S0_RCSR_SEIE_1 = 0x1
	// Position of WSIE field.
	I2S0_RCSR_WSIE_Pos = 0xc
	// Bit mask of WSIE field.
	I2S0_RCSR_WSIE_Msk = 0x1000
	// Bit WSIE.
	I2S0_RCSR_WSIE = 0x1000
	// Disables interrupt.
	I2S0_RCSR_WSIE_0 = 0x0
	// Enables interrupt.
	I2S0_RCSR_WSIE_1 = 0x1
	// Position of FRF field.
	I2S0_RCSR_FRF_Pos = 0x10
	// Bit mask of FRF field.
	I2S0_RCSR_FRF_Msk = 0x10000
	// Bit FRF.
	I2S0_RCSR_FRF = 0x10000
	// Receive FIFO watermark not reached.
	I2S0_RCSR_FRF_0 = 0x0
	// Receive FIFO watermark has been reached.
	I2S0_RCSR_FRF_1 = 0x1
	// Position of FWF field.
	I2S0_RCSR_FWF_Pos = 0x11
	// Bit mask of FWF field.
	I2S0_RCSR_FWF_Msk = 0x20000
	// Bit FWF.
	I2S0_RCSR_FWF = 0x20000
	// No enabled receive FIFO is full.
	I2S0_RCSR_FWF_0 = 0x0
	// Enabled receive FIFO is full.
	I2S0_RCSR_FWF_1 = 0x1
	// Position of FEF field.
	I2S0_RCSR_FEF_Pos = 0x12
	// Bit mask of FEF field.
	I2S0_RCSR_FEF_Msk = 0x40000
	// Bit FEF.
	I2S0_RCSR_FEF = 0x40000
	// Receive overflow not detected.
	I2S0_RCSR_FEF_0 = 0x0
	// Receive overflow detected.
	I2S0_RCSR_FEF_1 = 0x1
	// Position of SEF field.
	I2S0_RCSR_SEF_Pos = 0x13
	// Bit mask of SEF field.
	I2S0_RCSR_SEF_Msk = 0x80000
	// Bit SEF.
	I2S0_RCSR_SEF = 0x80000
	// Sync error not detected.
	I2S0_RCSR_SEF_0 = 0x0
	// Frame sync error detected.
	I2S0_RCSR_SEF_1 = 0x1
	// Position of WSF field.
	I2S0_RCSR_WSF_Pos = 0x14
	// Bit mask of WSF field.
	I2S0_RCSR_WSF_Msk = 0x100000
	// Bit WSF.
	I2S0_RCSR_WSF = 0x100000
	// Start of word not detected.
	I2S0_RCSR_WSF_0 = 0x0
	// Start of word detected.
	I2S0_RCSR_WSF_1 = 0x1
	// Position of SR field.
	I2S0_RCSR_SR_Pos = 0x18
	// Bit mask of SR field.
	I2S0_RCSR_SR_Msk = 0x1000000
	// Bit SR.
	I2S0_RCSR_SR = 0x1000000
	// No effect.
	I2S0_RCSR_SR_0 = 0x0
	// Software reset.
	I2S0_RCSR_SR_1 = 0x1
	// Position of FR field.
	I2S0_RCSR_FR_Pos = 0x19
	// Bit mask of FR field.
	I2S0_RCSR_FR_Msk = 0x2000000
	// Bit FR.
	I2S0_RCSR_FR = 0x2000000
	// No effect.
	I2S0_RCSR_FR_0 = 0x0
	// FIFO reset.
	I2S0_RCSR_FR_1 = 0x1
	// Position of BCE field.
	I2S0_RCSR_BCE_Pos = 0x1c
	// Bit mask of BCE field.
	I2S0_RCSR_BCE_Msk = 0x10000000
	// Bit BCE.
	I2S0_RCSR_BCE = 0x10000000
	// Receive bit clock is disabled.
	I2S0_RCSR_BCE_0 = 0x0
	// Receive bit clock is enabled.
	I2S0_RCSR_BCE_1 = 0x1
	// Position of DBGE field.
	I2S0_RCSR_DBGE_Pos = 0x1d
	// Bit mask of DBGE field.
	I2S0_RCSR_DBGE_Msk = 0x20000000
	// Bit DBGE.
	I2S0_RCSR_DBGE = 0x20000000
	// Receiver is disabled in Debug mode, after completing the current frame.
	I2S0_RCSR_DBGE_0 = 0x0
	// Receiver is enabled in Debug mode.
	I2S0_RCSR_DBGE_1 = 0x1
	// Position of STOPE field.
	I2S0_RCSR_STOPE_Pos = 0x1e
	// Bit mask of STOPE field.
	I2S0_RCSR_STOPE_Msk = 0x40000000
	// Bit STOPE.
	I2S0_RCSR_STOPE = 0x40000000
	// Receiver disabled in Stop mode.
	I2S0_RCSR_STOPE_0 = 0x0
	// Receiver enabled in Stop mode.
	I2S0_RCSR_STOPE_1 = 0x1
	// Position of RE field.
	I2S0_RCSR_RE_Pos = 0x1f
	// Bit mask of RE field.
	I2S0_RCSR_RE_Msk = 0x80000000
	// Bit RE.
	I2S0_RCSR_RE = 0x80000000
	// Receiver is disabled.
	I2S0_RCSR_RE_0 = 0x0
	// Receiver is enabled, or receiver has been disabled and has not yet reached end of frame.
	I2S0_RCSR_RE_1 = 0x1

	// RCR1: SAI Receive Configuration 1 Register
	// Position of RFW field.
	I2S0_RCR1_RFW_Pos = 0x0
	// Bit mask of RFW field.
	I2S0_RCR1_RFW_Msk = 0x7

	// RCR2: SAI Receive Configuration 2 Register
	// Position of DIV field.
	I2S0_RCR2_DIV_Pos = 0x0
	// Bit mask of DIV field.
	I2S0_RCR2_DIV_Msk = 0xff
	// Position of BCD field.
	I2S0_RCR2_BCD_Pos = 0x18
	// Bit mask of BCD field.
	I2S0_RCR2_BCD_Msk = 0x1000000
	// Bit BCD.
	I2S0_RCR2_BCD = 0x1000000
	// Bit clock is generated externally in Slave mode.
	I2S0_RCR2_BCD_0 = 0x0
	// Bit clock is generated internally in Master mode.
	I2S0_RCR2_BCD_1 = 0x1
	// Position of BCP field.
	I2S0_RCR2_BCP_Pos = 0x19
	// Bit mask of BCP field.
	I2S0_RCR2_BCP_Msk = 0x2000000
	// Bit BCP.
	I2S0_RCR2_BCP = 0x2000000
	// Bit Clock is active high with drive outputs on rising edge and sample inputs on falling edge.
	I2S0_RCR2_BCP_0 = 0x0
	// Bit Clock is active low with drive outputs on falling edge and sample inputs on rising edge.
	I2S0_RCR2_BCP_1 = 0x1
	// Position of MSEL field.
	I2S0_RCR2_MSEL_Pos = 0x1a
	// Bit mask of MSEL field.
	I2S0_RCR2_MSEL_Msk = 0xc000000
	// Bus Clock selected.
	I2S0_RCR2_MSEL_00 = 0x0
	// Master Clock (MCLK) 1 option selected.
	I2S0_RCR2_MSEL_01 = 0x1
	// Master Clock (MCLK) 2 option selected.
	I2S0_RCR2_MSEL_10 = 0x2
	// Master Clock (MCLK) 3 option selected.
	I2S0_RCR2_MSEL_11 = 0x3
	// Position of BCI field.
	I2S0_RCR2_BCI_Pos = 0x1c
	// Bit mask of BCI field.
	I2S0_RCR2_BCI_Msk = 0x10000000
	// Bit BCI.
	I2S0_RCR2_BCI = 0x10000000
	// No effect.
	I2S0_RCR2_BCI_0 = 0x0
	// Internal logic is clocked as if bit clock was externally generated.
	I2S0_RCR2_BCI_1 = 0x1
	// Position of BCS field.
	I2S0_RCR2_BCS_Pos = 0x1d
	// Bit mask of BCS field.
	I2S0_RCR2_BCS_Msk = 0x20000000
	// Bit BCS.
	I2S0_RCR2_BCS = 0x20000000
	// Use the normal bit clock source.
	I2S0_RCR2_BCS_0 = 0x0
	// Swap the bit clock source.
	I2S0_RCR2_BCS_1 = 0x1
	// Position of SYNC field.
	I2S0_RCR2_SYNC_Pos = 0x1e
	// Bit mask of SYNC field.
	I2S0_RCR2_SYNC_Msk = 0xc0000000
	// Asynchronous mode.
	I2S0_RCR2_SYNC_00 = 0x0
	// Synchronous with transmitter.
	I2S0_RCR2_SYNC_01 = 0x1
	// Synchronous with another SAI receiver.
	I2S0_RCR2_SYNC_10 = 0x2
	// Synchronous with another SAI transmitter.
	I2S0_RCR2_SYNC_11 = 0x3

	// RCR3: SAI Receive Configuration 3 Register
	// Position of WDFL field.
	I2S0_RCR3_WDFL_Pos = 0x0
	// Bit mask of WDFL field.
	I2S0_RCR3_WDFL_Msk = 0x1f
	// Position of RCE0 field.
	I2S0_RCR3_RCE0_Pos = 0x10
	// Bit mask of RCE0 field.
	I2S0_RCR3_RCE0_Msk = 0x10000
	// Bit RCE0.
	I2S0_RCR3_RCE0 = 0x10000
	// Receive data channel N is disabled.
	I2S0_RCR3_RCE0_0 = 0x0
	// Receive data channel N is enabled.
	I2S0_RCR3_RCE0_1 = 0x1
	// Position of RCE1 field.
	I2S0_RCR3_RCE1_Pos = 0x11
	// Bit mask of RCE1 field.
	I2S0_RCR3_RCE1_Msk = 0x20000
	// Bit RCE1.
	I2S0_RCR3_RCE1 = 0x20000
	// Receive data channel N is disabled.
	I2S0_RCR3_RCE1_0 = 0x0
	// Receive data channel N is enabled.
	I2S0_RCR3_RCE1_1 = 0x1

	// RCR4: SAI Receive Configuration 4 Register
	// Position of FSD field.
	I2S0_RCR4_FSD_Pos = 0x0
	// Bit mask of FSD field.
	I2S0_RCR4_FSD_Msk = 0x1
	// Bit FSD.
	I2S0_RCR4_FSD = 0x1
	// Frame Sync is generated externally in Slave mode.
	I2S0_RCR4_FSD_0 = 0x0
	// Frame Sync is generated internally in Master mode.
	I2S0_RCR4_FSD_1 = 0x1
	// Position of FSP field.
	I2S0_RCR4_FSP_Pos = 0x1
	// Bit mask of FSP field.
	I2S0_RCR4_FSP_Msk = 0x2
	// Bit FSP.
	I2S0_RCR4_FSP = 0x2
	// Frame sync is active high.
	I2S0_RCR4_FSP_0 = 0x0
	// Frame sync is active low.
	I2S0_RCR4_FSP_1 = 0x1
	// Position of FSE field.
	I2S0_RCR4_FSE_Pos = 0x3
	// Bit mask of FSE field.
	I2S0_RCR4_FSE_Msk = 0x8
	// Bit FSE.
	I2S0_RCR4_FSE = 0x8
	// Frame sync asserts with the first bit of the frame.
	I2S0_RCR4_FSE_0 = 0x0
	// Frame sync asserts one bit before the first bit of the frame.
	I2S0_RCR4_FSE_1 = 0x1
	// Position of MF field.
	I2S0_RCR4_MF_Pos = 0x4
	// Bit mask of MF field.
	I2S0_RCR4_MF_Msk = 0x10
	// Bit MF.
	I2S0_RCR4_MF = 0x10
	// LSB is received first.
	I2S0_RCR4_MF_0 = 0x0
	// MSB is received first.
	I2S0_RCR4_MF_1 = 0x1
	// Position of SYWD field.
	I2S0_RCR4_SYWD_Pos = 0x8
	// Bit mask of SYWD field.
	I2S0_RCR4_SYWD_Msk = 0x1f00
	// Position of FRSZ field.
	I2S0_RCR4_FRSZ_Pos = 0x10
	// Bit mask of FRSZ field.
	I2S0_RCR4_FRSZ_Msk = 0x1f0000

	// RCR5: SAI Receive Configuration 5 Register
	// Position of FBT field.
	I2S0_RCR5_FBT_Pos = 0x8
	// Bit mask of FBT field.
	I2S0_RCR5_FBT_Msk = 0x1f00
	// Position of W0W field.
	I2S0_RCR5_W0W_Pos = 0x10
	// Bit mask of W0W field.
	I2S0_RCR5_W0W_Msk = 0x1f0000
	// Position of WNW field.
	I2S0_RCR5_WNW_Pos = 0x18
	// Bit mask of WNW field.
	I2S0_RCR5_WNW_Msk = 0x1f000000

	// RDR0: SAI Receive Data Register
	// Position of RDR field.
	I2S0_RDR_RDR_Pos = 0x0
	// Bit mask of RDR field.
	I2S0_RDR_RDR_Msk = 0xffffffff

	// RFR0: SAI Receive FIFO Register
	// Position of RFP field.
	I2S0_RFR_RFP_Pos = 0x0
	// Bit mask of RFP field.
	I2S0_RFR_RFP_Msk = 0xf
	// Position of WFP field.
	I2S0_RFR_WFP_Pos = 0x10
	// Bit mask of WFP field.
	I2S0_RFR_WFP_Msk = 0xf0000

	// RMR: SAI Receive Mask Register
	// Position of RWM0 field.
	I2S0_RMR_RWM0_Pos = 0x0
	// Bit mask of RWM0 field.
	I2S0_RMR_RWM0_Msk = 0x1
	// Bit RWM0.
	I2S0_RMR_RWM0 = 0x1
	// Word N is enabled.
	I2S0_RMR_RWM0_0 = 0x0
	// Word N is masked.
	I2S0_RMR_RWM0_1 = 0x1
	// Position of RWM1 field.
	I2S0_RMR_RWM1_Pos = 0x1
	// Bit mask of RWM1 field.
	I2S0_RMR_RWM1_Msk = 0x2
	// Bit RWM1.
	I2S0_RMR_RWM1 = 0x2
	// Word N is enabled.
	I2S0_RMR_RWM1_0 = 0x0
	// Word N is masked.
	I2S0_RMR_RWM1_1 = 0x1
	// Position of RWM2 field.
	I2S0_RMR_RWM2_Pos = 0x2
	// Bit mask of RWM2 field.
	I2S0_RMR_RWM2_Msk = 0x4
	// Bit RWM2.
	I2S0_RMR_RWM2 = 0x4
	// Word N is enabled.
	I2S0_RMR_RWM2_0 = 0x0
	// Word N is masked.
	I2S0_RMR_RWM2_1 = 0x1
	// Position of RWM3 field.
	I2S0_RMR_RWM3_Pos = 0x3
	// Bit mask of RWM3 field.
	I2S0_RMR_RWM3_Msk = 0x8
	// Bit RWM3.
	I2S0_RMR_RWM3 = 0x8
	// Word N is enabled.
	I2S0_RMR_RWM3_0 = 0x0
	// Word N is masked.
	I2S0_RMR_RWM3_1 = 0x1
	// Position of RWM4 field.
	I2S0_RMR_RWM4_Pos = 0x4
	// Bit mask of RWM4 field.
	I2S0_RMR_RWM4_Msk = 0x10
	// Bit RWM4.
	I2S0_RMR_RWM4 = 0x10
	// Word N is enabled.
	I2S0_RMR_RWM4_0 = 0x0
	// Word N is masked.
	I2S0_RMR_RWM4_1 = 0x1
	// Position of RWM5 field.
	I2S0_RMR_RWM5_Pos = 0x5
	// Bit mask of RWM5 field.
	I2S0_RMR_RWM5_Msk = 0x20
	// Bit RWM5.
	I2S0_RMR_RWM5 = 0x20
	// Word N is enabled.
	I2S0_RMR_RWM5_0 = 0x0
	// Word N is masked.
	I2S0_RMR_RWM5_1 = 0x1
	// Position of RWM6 field.
	I2S0_RMR_RWM6_Pos = 0x6
	// Bit mask of RWM6 field.
	I2S0_RMR_RWM6_Msk = 0x40
	// Bit RWM6.
	I2S0_RMR_RWM6 = 0x40
	// Word N is enabled.
	I2S0_RMR_RWM6_0 = 0x0
	// Word N is masked.
	I2S0_RMR_RWM6_1 = 0x1
	// Position of RWM7 field.
	I2S0_RMR_RWM7_Pos = 0x7
	// Bit mask of RWM7 field.
	I2S0_RMR_RWM7_Msk = 0x80
	// Bit RWM7.
	I2S0_RMR_RWM7 = 0x80
	// Word N is enabled.
	I2S0_RMR_RWM7_0 = 0x0
	// Word N is masked.
	I2S0_RMR_RWM7_1 = 0x1
	// Position of RWM8 field.
	I2S0_RMR_RWM8_Pos = 0x8
	// Bit mask of RWM8 field.
	I2S0_RMR_RWM8_Msk = 0x100
	// Bit RWM8.
	I2S0_RMR_RWM8 = 0x100
	// Word N is enabled.
	I2S0_RMR_RWM8_0 = 0x0
	// Word N is masked.
	I2S0_RMR_RWM8_1 = 0x1
	// Position of RWM9 field.
	I2S0_RMR_RWM9_Pos = 0x9
	// Bit mask of RWM9 field.
	I2S0_RMR_RWM9_Msk = 0x200
	// Bit RWM9.
	I2S0_RMR_RWM9 = 0x200
	// Word N is enabled.
	I2S0_RMR_RWM9_0 = 0x0
	// Word N is masked.
	I2S0_RMR_RWM9_1 = 0x1
	// Position of RWM10 field.
	I2S0_RMR_RWM10_Pos = 0xa
	// Bit mask of RWM10 field.
	I2S0_RMR_RWM10_Msk = 0x400
	// Bit RWM10.
	I2S0_RMR_RWM10 = 0x400
	// Word N is enabled.
	I2S0_RMR_RWM10_0 = 0x0
	// Word N is masked.
	I2S0_RMR_RWM10_1 = 0x1
	// Position of RWM11 field.
	I2S0_RMR_RWM11_Pos = 0xb
	// Bit mask of RWM11 field.
	I2S0_RMR_RWM11_Msk = 0x800
	// Bit RWM11.
	I2S0_RMR_RWM11 = 0x800
	// Word N is enabled.
	I2S0_RMR_RWM11_0 = 0x0
	// Word N is masked.
	I2S0_RMR_RWM11_1 = 0x1
	// Position of RWM12 field.
	I2S0_RMR_RWM12_Pos = 0xc
	// Bit mask of RWM12 field.
	I2S0_RMR_RWM12_Msk = 0x1000
	// Bit RWM12.
	I2S0_RMR_RWM12 = 0x1000
	// Word N is enabled.
	I2S0_RMR_RWM12_0 = 0x0
	// Word N is masked.
	I2S0_RMR_RWM12_1 = 0x1
	// Position of RWM13 field.
	I2S0_RMR_RWM13_Pos = 0xd
	// Bit mask of RWM13 field.
	I2S0_RMR_RWM13_Msk = 0x2000
	// Bit RWM13.
	I2S0_RMR_RWM13 = 0x2000
	// Word N is enabled.
	I2S0_RMR_RWM13_0 = 0x0
	// Word N is masked.
	I2S0_RMR_RWM13_1 = 0x1
	// Position of RWM14 field.
	I2S0_RMR_RWM14_Pos = 0xe
	// Bit mask of RWM14 field.
	I2S0_RMR_RWM14_Msk = 0x4000
	// Bit RWM14.
	I2S0_RMR_RWM14 = 0x4000
	// Word N is enabled.
	I2S0_RMR_RWM14_0 = 0x0
	// Word N is masked.
	I2S0_RMR_RWM14_1 = 0x1
	// Position of RWM15 field.
	I2S0_RMR_RWM15_Pos = 0xf
	// Bit mask of RWM15 field.
	I2S0_RMR_RWM15_Msk = 0x8000
	// Bit RWM15.
	I2S0_RMR_RWM15 = 0x8000
	// Word N is enabled.
	I2S0_RMR_RWM15_0 = 0x0
	// Word N is masked.
	I2S0_RMR_RWM15_1 = 0x1
	// Position of RWM16 field.
	I2S0_RMR_RWM16_Pos = 0x10
	// Bit mask of RWM16 field.
	I2S0_RMR_RWM16_Msk = 0x10000
	// Bit RWM16.
	I2S0_RMR_RWM16 = 0x10000
	// Word N is enabled.
	I2S0_RMR_RWM16_0 = 0x0
	// Word N is masked.
	I2S0_RMR_RWM16_1 = 0x1
	// Position of RWM17 field.
	I2S0_RMR_RWM17_Pos = 0x11
	// Bit mask of RWM17 field.
	I2S0_RMR_RWM17_Msk = 0x20000
	// Bit RWM17.
	I2S0_RMR_RWM17 = 0x20000
	// Word N is enabled.
	I2S0_RMR_RWM17_0 = 0x0
	// Word N is masked.
	I2S0_RMR_RWM17_1 = 0x1
	// Position of RWM18 field.
	I2S0_RMR_RWM18_Pos = 0x12
	// Bit mask of RWM18 field.
	I2S0_RMR_RWM18_Msk = 0x40000
	// Bit RWM18.
	I2S0_RMR_RWM18 = 0x40000
	// Word N is enabled.
	I2S0_RMR_RWM18_0 = 0x0
	// Word N is masked.
	I2S0_RMR_RWM18_1 = 0x1
	// Position of RWM19 field.
	I2S0_RMR_RWM19_Pos = 0x13
	// Bit mask of RWM19 field.
	I2S0_RMR_RWM19_Msk = 0x80000
	// Bit RWM19.
	I2S0_RMR_RWM19 = 0x80000
	// Word N is enabled.
	I2S0_RMR_RWM19_0 = 0x0
	// Word N is masked.
	I2S0_RMR_RWM19_1 = 0x1
	// Position of RWM20 field.
	I2S0_RMR_RWM20_Pos = 0x14
	// Bit mask of RWM20 field.
	I2S0_RMR_RWM20_Msk = 0x100000
	// Bit RWM20.
	I2S0_RMR_RWM20 = 0x100000
	// Word N is enabled.
	I2S0_RMR_RWM20_0 = 0x0
	// Word N is masked.
	I2S0_RMR_RWM20_1 = 0x1
	// Position of RWM21 field.
	I2S0_RMR_RWM21_Pos = 0x15
	// Bit mask of RWM21 field.
	I2S0_RMR_RWM21_Msk = 0x200000
	// Bit RWM21.
	I2S0_RMR_RWM21 = 0x200000
	// Word N is enabled.
	I2S0_RMR_RWM21_0 = 0x0
	// Word N is masked.
	I2S0_RMR_RWM21_1 = 0x1
	// Position of RWM22 field.
	I2S0_RMR_RWM22_Pos = 0x16
	// Bit mask of RWM22 field.
	I2S0_RMR_RWM22_Msk = 0x400000
	// Bit RWM22.
	I2S0_RMR_RWM22 = 0x400000
	// Word N is enabled.
	I2S0_RMR_RWM22_0 = 0x0
	// Word N is masked.
	I2S0_RMR_RWM22_1 = 0x1
	// Position of RWM23 field.
	I2S0_RMR_RWM23_Pos = 0x17
	// Bit mask of RWM23 field.
	I2S0_RMR_RWM23_Msk = 0x800000
	// Bit RWM23.
	I2S0_RMR_RWM23 = 0x800000
	// Word N is enabled.
	I2S0_RMR_RWM23_0 = 0x0
	// Word N is masked.
	I2S0_RMR_RWM23_1 = 0x1
	// Position of RWM24 field.
	I2S0_RMR_RWM24_Pos = 0x18
	// Bit mask of RWM24 field.
	I2S0_RMR_RWM24_Msk = 0x1000000
	// Bit RWM24.
	I2S0_RMR_RWM24 = 0x1000000
	// Word N is enabled.
	I2S0_RMR_RWM24_0 = 0x0
	// Word N is masked.
	I2S0_RMR_RWM24_1 = 0x1
	// Position of RWM25 field.
	I2S0_RMR_RWM25_Pos = 0x19
	// Bit mask of RWM25 field.
	I2S0_RMR_RWM25_Msk = 0x2000000
	// Bit RWM25.
	I2S0_RMR_RWM25 = 0x2000000
	// Word N is enabled.
	I2S0_RMR_RWM25_0 = 0x0
	// Word N is masked.
	I2S0_RMR_RWM25_1 = 0x1
	// Position of RWM26 field.
	I2S0_RMR_RWM26_Pos = 0x1a
	// Bit mask of RWM26 field.
	I2S0_RMR_RWM26_Msk = 0x4000000
	// Bit RWM26.
	I2S0_RMR_RWM26 = 0x4000000
	// Word N is enabled.
	I2S0_RMR_RWM26_0 = 0x0
	// Word N is masked.
	I2S0_RMR_RWM26_1 = 0x1
	// Position of RWM27 field.
	I2S0_RMR_RWM27_Pos = 0x1b
	// Bit mask of RWM27 field.
	I2S0_RMR_RWM27_Msk = 0x8000000
	// Bit RWM27.
	I2S0_RMR_RWM27 = 0x8000000
	// Word N is enabled.
	I2S0_RMR_RWM27_0 = 0x0
	// Word N is masked.
	I2S0_RMR_RWM27_1 = 0x1
	// Position of RWM28 field.
	I2S0_RMR_RWM28_Pos = 0x1c
	// Bit mask of RWM28 field.
	I2S0_RMR_RWM28_Msk = 0x10000000
	// Bit RWM28.
	I2S0_RMR_RWM28 = 0x10000000
	// Word N is enabled.
	I2S0_RMR_RWM28_0 = 0x0
	// Word N is masked.
	I2S0_RMR_RWM28_1 = 0x1
	// Position of RWM29 field.
	I2S0_RMR_RWM29_Pos = 0x1d
	// Bit mask of RWM29 field.
	I2S0_RMR_RWM29_Msk = 0x20000000
	// Bit RWM29.
	I2S0_RMR_RWM29 = 0x20000000
	// Word N is enabled.
	I2S0_RMR_RWM29_0 = 0x0
	// Word N is masked.
	I2S0_RMR_RWM29_1 = 0x1
	// Position of RWM30 field.
	I2S0_RMR_RWM30_Pos = 0x1e
	// Bit mask of RWM30 field.
	I2S0_RMR_RWM30_Msk = 0x40000000
	// Bit RWM30.
	I2S0_RMR_RWM30 = 0x40000000
	// Word N is enabled.
	I2S0_RMR_RWM30_0 = 0x0
	// Word N is masked.
	I2S0_RMR_RWM30_1 = 0x1
	// Position of RWM31 field.
	I2S0_RMR_RWM31_Pos = 0x1f
	// Bit mask of RWM31 field.
	I2S0_RMR_RWM31_Msk = 0x80000000
	// Bit RWM31.
	I2S0_RMR_RWM31 = 0x80000000
	// Word N is enabled.
	I2S0_RMR_RWM31_0 = 0x0
	// Word N is masked.
	I2S0_RMR_RWM31_1 = 0x1

	// MCR: SAI MCLK Control Register
	// Position of MICS field.
	I2S0_MCR_MICS_Pos = 0x18
	// Bit mask of MICS field.
	I2S0_MCR_MICS_Msk = 0x3000000
	// MCLK divider input clock 0 selected.
	I2S0_MCR_MICS_00 = 0x0
	// MCLK divider input clock 1 selected.
	I2S0_MCR_MICS_01 = 0x1
	// MCLK divider input clock 2 selected.
	I2S0_MCR_MICS_10 = 0x2
	// MCLK divider input clock 3 selected.
	I2S0_MCR_MICS_11 = 0x3
	// Position of MOE field.
	I2S0_MCR_MOE_Pos = 0x1e
	// Bit mask of MOE field.
	I2S0_MCR_MOE_Msk = 0x40000000
	// Bit MOE.
	I2S0_MCR_MOE = 0x40000000
	// MCLK signal pin is configured as an input that bypasses the MCLK divider.
	I2S0_MCR_MOE_0 = 0x0
	// MCLK signal pin is configured as an output from the MCLK divider and the MCLK divider is enabled.
	I2S0_MCR_MOE_1 = 0x1
	// Position of DUF field.
	I2S0_MCR_DUF_Pos = 0x1f
	// Bit mask of DUF field.
	I2S0_MCR_DUF_Msk = 0x80000000
	// Bit DUF.
	I2S0_MCR_DUF = 0x80000000
	// MCLK divider ratio is not being updated currently.
	I2S0_MCR_DUF_0 = 0x0
	// MCLK divider ratio is updating on-the-fly. Further updates to the MCLK divider ratio are blocked while this flag remains set.
	I2S0_MCR_DUF_1 = 0x1

	// MDR: SAI MCLK Divide Register
	// Position of DIVIDE field.
	I2S0_MDR_DIVIDE_Pos = 0x0
	// Bit mask of DIVIDE field.
	I2S0_MDR_DIVIDE_Msk = 0xfff
	// Position of FRACT field.
	I2S0_MDR_FRACT_Pos = 0xc
	// Bit mask of FRACT field.
	I2S0_MDR_FRACT_Msk = 0xff000
)

// Constants for CRC: Cyclic Redundancy Check
const (
	// DATA: CRC Data register
	// Position of LL field.
	CRC_DATA_LL_Pos = 0x0
	// Bit mask of LL field.
	CRC_DATA_LL_Msk = 0xff
	// Position of LU field.
	CRC_DATA_LU_Pos = 0x8
	// Bit mask of LU field.
	CRC_DATA_LU_Msk = 0xff00
	// Position of HL field.
	CRC_DATA_HL_Pos = 0x10
	// Bit mask of HL field.
	CRC_DATA_HL_Msk = 0xff0000
	// Position of HU field.
	CRC_DATA_HU_Pos = 0x18
	// Bit mask of HU field.
	CRC_DATA_HU_Msk = 0xff000000

	// DATAL: CRC_DATAL register.
	// Position of DATAL field.
	CRC_DATAL_DATAL_Pos = 0x0
	// Bit mask of DATAL field.
	CRC_DATAL_DATAL_Msk = 0xffff

	// DATALL: CRC_DATALL register.
	// Position of DATALL field.
	CRC_DATALL_DATALL_Pos = 0x0
	// Bit mask of DATALL field.
	CRC_DATALL_DATALL_Msk = 0xff

	// DATALU: CRC_DATALU register.
	// Position of DATALU field.
	CRC_DATALU_DATALU_Pos = 0x0
	// Bit mask of DATALU field.
	CRC_DATALU_DATALU_Msk = 0xff

	// DATAH: CRC_DATAH register.
	// Position of DATAH field.
	CRC_DATAH_DATAH_Pos = 0x0
	// Bit mask of DATAH field.
	CRC_DATAH_DATAH_Msk = 0xffff

	// DATAHL: CRC_DATAHL register.
	// Position of DATAHL field.
	CRC_DATAHL_DATAHL_Pos = 0x0
	// Bit mask of DATAHL field.
	CRC_DATAHL_DATAHL_Msk = 0xff

	// DATAHU: CRC_DATAHU register.
	// Position of DATAHU field.
	CRC_DATAHU_DATAHU_Pos = 0x0
	// Bit mask of DATAHU field.
	CRC_DATAHU_DATAHU_Msk = 0xff

	// GPOLY: CRC Polynomial register
	// Position of LOW field.
	CRC_GPOLY_LOW_Pos = 0x0
	// Bit mask of LOW field.
	CRC_GPOLY_LOW_Msk = 0xffff
	// Position of HIGH field.
	CRC_GPOLY_HIGH_Pos = 0x10
	// Bit mask of HIGH field.
	CRC_GPOLY_HIGH_Msk = 0xffff0000

	// GPOLYL: CRC_GPOLYL register.
	// Position of GPOLYL field.
	CRC_GPOLYL_GPOLYL_Pos = 0x0
	// Bit mask of GPOLYL field.
	CRC_GPOLYL_GPOLYL_Msk = 0xffff

	// GPOLYLL: CRC_GPOLYLL register.
	// Position of GPOLYLL field.
	CRC_GPOLYLL_GPOLYLL_Pos = 0x0
	// Bit mask of GPOLYLL field.
	CRC_GPOLYLL_GPOLYLL_Msk = 0xff

	// GPOLYLU: CRC_GPOLYLU register.
	// Position of GPOLYLU field.
	CRC_GPOLYLU_GPOLYLU_Pos = 0x0
	// Bit mask of GPOLYLU field.
	CRC_GPOLYLU_GPOLYLU_Msk = 0xff

	// GPOLYH: CRC_GPOLYH register.
	// Position of GPOLYH field.
	CRC_GPOLYH_GPOLYH_Pos = 0x0
	// Bit mask of GPOLYH field.
	CRC_GPOLYH_GPOLYH_Msk = 0xffff

	// GPOLYHL: CRC_GPOLYHL register.
	// Position of GPOLYHL field.
	CRC_GPOLYHL_GPOLYHL_Pos = 0x0
	// Bit mask of GPOLYHL field.
	CRC_GPOLYHL_GPOLYHL_Msk = 0xff

	// GPOLYHU: CRC_GPOLYHU register.
	// Position of GPOLYHU field.
	CRC_GPOLYHU_GPOLYHU_Pos = 0x0
	// Bit mask of GPOLYHU field.
	CRC_GPOLYHU_GPOLYHU_Msk = 0xff

	// CTRL: CRC Control register
	// Position of TCRC field.
	CRC_CTRL_TCRC_Pos = 0x18
	// Bit mask of TCRC field.
	CRC_CTRL_TCRC_Msk = 0x1000000
	// Bit TCRC.
	CRC_CTRL_TCRC = 0x1000000
	// 16-bit CRC protocol.
	CRC_CTRL_TCRC_0 = 0x0
	// 32-bit CRC protocol.
	CRC_CTRL_TCRC_1 = 0x1
	// Position of WAS field.
	CRC_CTRL_WAS_Pos = 0x19
	// Bit mask of WAS field.
	CRC_CTRL_WAS_Msk = 0x2000000
	// Bit WAS.
	CRC_CTRL_WAS = 0x2000000
	// Writes to the CRC data register are data values.
	CRC_CTRL_WAS_0 = 0x0
	// Writes to the CRC data register are seed values.
	CRC_CTRL_WAS_1 = 0x1
	// Position of FXOR field.
	CRC_CTRL_FXOR_Pos = 0x1a
	// Bit mask of FXOR field.
	CRC_CTRL_FXOR_Msk = 0x4000000
	// Bit FXOR.
	CRC_CTRL_FXOR = 0x4000000
	// No XOR on reading.
	CRC_CTRL_FXOR_0 = 0x0
	// Invert or complement the read value of the CRC Data register.
	CRC_CTRL_FXOR_1 = 0x1
	// Position of TOTR field.
	CRC_CTRL_TOTR_Pos = 0x1c
	// Bit mask of TOTR field.
	CRC_CTRL_TOTR_Msk = 0x30000000
	// No transposition.
	CRC_CTRL_TOTR_00 = 0x0
	// Bits in bytes are transposed; bytes are not transposed.
	CRC_CTRL_TOTR_01 = 0x1
	// Both bits in bytes and bytes are transposed.
	CRC_CTRL_TOTR_10 = 0x2
	// Only bytes are transposed; no bits in a byte are transposed.
	CRC_CTRL_TOTR_11 = 0x3
	// Position of TOT field.
	CRC_CTRL_TOT_Pos = 0x1e
	// Bit mask of TOT field.
	CRC_CTRL_TOT_Msk = 0xc0000000
	// No transposition.
	CRC_CTRL_TOT_00 = 0x0
	// Bits in bytes are transposed; bytes are not transposed.
	CRC_CTRL_TOT_01 = 0x1
	// Both bits in bytes and bytes are transposed.
	CRC_CTRL_TOT_10 = 0x2
	// Only bytes are transposed; no bits in a byte are transposed.
	CRC_CTRL_TOT_11 = 0x3

	// CTRLHU: CRC_CTRLHU register.
	// Position of TCRC field.
	CRC_CTRLHU_TCRC_Pos = 0x0
	// Bit mask of TCRC field.
	CRC_CTRLHU_TCRC_Msk = 0x1
	// Bit TCRC.
	CRC_CTRLHU_TCRC = 0x1
	// 16-bit CRC protocol.
	CRC_CTRLHU_TCRC_0 = 0x0
	// 32-bit CRC protocol.
	CRC_CTRLHU_TCRC_1 = 0x1
	// Position of WAS field.
	CRC_CTRLHU_WAS_Pos = 0x1
	// Bit mask of WAS field.
	CRC_CTRLHU_WAS_Msk = 0x2
	// Bit WAS.
	CRC_CTRLHU_WAS = 0x2
	// Writes to CRC data register are data values.
	CRC_CTRLHU_WAS_0 = 0x0
	// Writes to CRC data reguster are seed values.
	CRC_CTRLHU_WAS_1 = 0x1
	// Position of FXOR field.
	CRC_CTRLHU_FXOR_Pos = 0x2
	// Bit mask of FXOR field.
	CRC_CTRLHU_FXOR_Msk = 0x4
	// Bit FXOR.
	CRC_CTRLHU_FXOR = 0x4
	// No XOR on reading.
	CRC_CTRLHU_FXOR_0 = 0x0
	// Invert or complement the read value of CRC data register.
	CRC_CTRLHU_FXOR_1 = 0x1
	// Position of TOTR field.
	CRC_CTRLHU_TOTR_Pos = 0x4
	// Bit mask of TOTR field.
	CRC_CTRLHU_TOTR_Msk = 0x30
	// No Transposition.
	CRC_CTRLHU_TOTR_00 = 0x0
	// Bits in bytes are transposed, bytes are not transposed.
	CRC_CTRLHU_TOTR_01 = 0x1
	// Both bits in bytes and bytes are transposed.
	CRC_CTRLHU_TOTR_10 = 0x2
	// Only bytes are transposed; no bits in a byte are transposed.
	CRC_CTRLHU_TOTR_11 = 0x3
	// Position of TOT field.
	CRC_CTRLHU_TOT_Pos = 0x6
	// Bit mask of TOT field.
	CRC_CTRLHU_TOT_Msk = 0xc0
	// No Transposition.
	CRC_CTRLHU_TOT_00 = 0x0
	// Bits in bytes are transposed, bytes are not transposed.
	CRC_CTRLHU_TOT_01 = 0x1
	// Both bits in bytes and bytes are transposed.
	CRC_CTRLHU_TOT_10 = 0x2
	// Only bytes are transposed; no bits in a byte are transposed.
	CRC_CTRLHU_TOT_11 = 0x3
)

// Constants for USBDCD: USB Device Charger Detection module
const (
	// CONTROL: Control register
	// Position of IACK field.
	USBDCD_CONTROL_IACK_Pos = 0x0
	// Bit mask of IACK field.
	USBDCD_CONTROL_IACK_Msk = 0x1
	// Bit IACK.
	USBDCD_CONTROL_IACK = 0x1
	// Do not clear the interrupt.
	USBDCD_CONTROL_IACK_0 = 0x0
	// Clear the IF bit (interrupt flag).
	USBDCD_CONTROL_IACK_1 = 0x1
	// Position of IF field.
	USBDCD_CONTROL_IF_Pos = 0x8
	// Bit mask of IF field.
	USBDCD_CONTROL_IF_Msk = 0x100
	// Bit IF.
	USBDCD_CONTROL_IF = 0x100
	// No interrupt is pending.
	USBDCD_CONTROL_IF_0 = 0x0
	// An interrupt is pending.
	USBDCD_CONTROL_IF_1 = 0x1
	// Position of IE field.
	USBDCD_CONTROL_IE_Pos = 0x10
	// Bit mask of IE field.
	USBDCD_CONTROL_IE_Msk = 0x10000
	// Bit IE.
	USBDCD_CONTROL_IE = 0x10000
	// Disable interrupts to the system.
	USBDCD_CONTROL_IE_0 = 0x0
	// Enable interrupts to the system.
	USBDCD_CONTROL_IE_1 = 0x1
	// Position of BC12 field.
	USBDCD_CONTROL_BC12_Pos = 0x11
	// Bit mask of BC12 field.
	USBDCD_CONTROL_BC12_Msk = 0x20000
	// Bit BC12.
	USBDCD_CONTROL_BC12 = 0x20000
	// Compatible with BC1.1 (default)
	USBDCD_CONTROL_BC12_0 = 0x0
	// Compatible with BC1.2
	USBDCD_CONTROL_BC12_1 = 0x1
	// Position of START field.
	USBDCD_CONTROL_START_Pos = 0x18
	// Bit mask of START field.
	USBDCD_CONTROL_START_Msk = 0x1000000
	// Bit START.
	USBDCD_CONTROL_START = 0x1000000
	// Do not start the sequence. Writes of this value have no effect.
	USBDCD_CONTROL_START_0 = 0x0
	// Initiate the charger detection sequence. If the sequence is already running, writes of this value have no effect.
	USBDCD_CONTROL_START_1 = 0x1
	// Position of SR field.
	USBDCD_CONTROL_SR_Pos = 0x19
	// Bit mask of SR field.
	USBDCD_CONTROL_SR_Msk = 0x2000000
	// Bit SR.
	USBDCD_CONTROL_SR = 0x2000000
	// Do not perform a software reset.
	USBDCD_CONTROL_SR_0 = 0x0
	// Perform a software reset.
	USBDCD_CONTROL_SR_1 = 0x1

	// CLOCK: Clock register
	// Position of CLOCK_UNIT field.
	USBDCD_CLOCK_CLOCK_UNIT_Pos = 0x0
	// Bit mask of CLOCK_UNIT field.
	USBDCD_CLOCK_CLOCK_UNIT_Msk = 0x1
	// Bit CLOCK_UNIT.
	USBDCD_CLOCK_CLOCK_UNIT = 0x1
	// kHz Speed (between 1 kHz and 1023 kHz)
	USBDCD_CLOCK_CLOCK_UNIT_0 = 0x0
	// MHz Speed (between 1 MHz and 1023 MHz)
	USBDCD_CLOCK_CLOCK_UNIT_1 = 0x1
	// Position of CLOCK_SPEED field.
	USBDCD_CLOCK_CLOCK_SPEED_Pos = 0x2
	// Bit mask of CLOCK_SPEED field.
	USBDCD_CLOCK_CLOCK_SPEED_Msk = 0xffc

	// STATUS: Status register
	// Position of SEQ_RES field.
	USBDCD_STATUS_SEQ_RES_Pos = 0x10
	// Bit mask of SEQ_RES field.
	USBDCD_STATUS_SEQ_RES_Msk = 0x30000
	// No results to report.
	USBDCD_STATUS_SEQ_RES_00 = 0x0
	// Attached to a standard host. Must comply with USB 2.0 by drawing only 2.5 mA (max) until connected.
	USBDCD_STATUS_SEQ_RES_01 = 0x1
	// Attached to a charging port. The exact meaning depends on bit 18: 0: Attached to either a charging host or a dedicated charger. The charger type detection has not completed. 1: Attached to a charging host. The charger type detection has completed.
	USBDCD_STATUS_SEQ_RES_10 = 0x2
	// Attached to a dedicated charger.
	USBDCD_STATUS_SEQ_RES_11 = 0x3
	// Position of SEQ_STAT field.
	USBDCD_STATUS_SEQ_STAT_Pos = 0x12
	// Bit mask of SEQ_STAT field.
	USBDCD_STATUS_SEQ_STAT_Msk = 0xc0000
	// The module is either not enabled, or the module is enabled but the data pins have not yet been detected.
	USBDCD_STATUS_SEQ_STAT_00 = 0x0
	// Data pin contact detection is complete.
	USBDCD_STATUS_SEQ_STAT_01 = 0x1
	// Charging port detection is complete.
	USBDCD_STATUS_SEQ_STAT_10 = 0x2
	// Charger type detection is complete.
	USBDCD_STATUS_SEQ_STAT_11 = 0x3
	// Position of ERR field.
	USBDCD_STATUS_ERR_Pos = 0x14
	// Bit mask of ERR field.
	USBDCD_STATUS_ERR_Msk = 0x100000
	// Bit ERR.
	USBDCD_STATUS_ERR = 0x100000
	// No sequence errors.
	USBDCD_STATUS_ERR_0 = 0x0
	// Error in the detection sequence. See the SEQ_STAT field to determine the phase in which the error occurred.
	USBDCD_STATUS_ERR_1 = 0x1
	// Position of TO field.
	USBDCD_STATUS_TO_Pos = 0x15
	// Bit mask of TO field.
	USBDCD_STATUS_TO_Msk = 0x200000
	// Bit TO.
	USBDCD_STATUS_TO = 0x200000
	// The detection sequence has not been running for over 1 s.
	USBDCD_STATUS_TO_0 = 0x0
	// It has been over 1 s since the data pin contact was detected and debounced.
	USBDCD_STATUS_TO_1 = 0x1
	// Position of ACTIVE field.
	USBDCD_STATUS_ACTIVE_Pos = 0x16
	// Bit mask of ACTIVE field.
	USBDCD_STATUS_ACTIVE_Msk = 0x400000
	// Bit ACTIVE.
	USBDCD_STATUS_ACTIVE = 0x400000
	// The sequence is not running.
	USBDCD_STATUS_ACTIVE_0 = 0x0
	// The sequence is running.
	USBDCD_STATUS_ACTIVE_1 = 0x1

	// TIMER0: TIMER0 register
	// Position of TUNITCON field.
	USBDCD_TIMER0_TUNITCON_Pos = 0x0
	// Bit mask of TUNITCON field.
	USBDCD_TIMER0_TUNITCON_Msk = 0xfff
	// Position of TSEQ_INIT field.
	USBDCD_TIMER0_TSEQ_INIT_Pos = 0x10
	// Bit mask of TSEQ_INIT field.
	USBDCD_TIMER0_TSEQ_INIT_Msk = 0x3ff0000

	// TIMER1: TIMER1 register
	// Position of TVDPSRC_ON field.
	USBDCD_TIMER1_TVDPSRC_ON_Pos = 0x0
	// Bit mask of TVDPSRC_ON field.
	USBDCD_TIMER1_TVDPSRC_ON_Msk = 0x3ff
	// Position of TDCD_DBNC field.
	USBDCD_TIMER1_TDCD_DBNC_Pos = 0x10
	// Bit mask of TDCD_DBNC field.
	USBDCD_TIMER1_TDCD_DBNC_Msk = 0x3ff0000

	// TIMER2_BC11: TIMER2_BC11 register
	// Position of CHECK_DM field.
	USBDCD_TIMER2_BC11_CHECK_DM_Pos = 0x0
	// Bit mask of CHECK_DM field.
	USBDCD_TIMER2_BC11_CHECK_DM_Msk = 0xf
	// Position of TVDPSRC_CON field.
	USBDCD_TIMER2_BC11_TVDPSRC_CON_Pos = 0x10
	// Bit mask of TVDPSRC_CON field.
	USBDCD_TIMER2_BC11_TVDPSRC_CON_Msk = 0x3ff0000

	// TIMER2_BC12: TIMER2_BC12 register
	// Position of TVDMSRC_ON field.
	USBDCD_TIMER2_BC12_TVDMSRC_ON_Pos = 0x0
	// Bit mask of TVDMSRC_ON field.
	USBDCD_TIMER2_BC12_TVDMSRC_ON_Msk = 0x3ff
	// Position of TWAIT_AFTER_PRD field.
	USBDCD_TIMER2_BC12_TWAIT_AFTER_PRD_Pos = 0x10
	// Bit mask of TWAIT_AFTER_PRD field.
	USBDCD_TIMER2_BC12_TWAIT_AFTER_PRD_Msk = 0x3ff0000
)

// Constants for PDB0: Programmable Delay Block
const (
	// SC: Status and Control register
	// Position of LDOK field.
	PDB0_SC_LDOK_Pos = 0x0
	// Bit mask of LDOK field.
	PDB0_SC_LDOK_Msk = 0x1
	// Bit LDOK.
	PDB0_SC_LDOK = 0x1
	// Position of CONT field.
	PDB0_SC_CONT_Pos = 0x1
	// Bit mask of CONT field.
	PDB0_SC_CONT_Msk = 0x2
	// Bit CONT.
	PDB0_SC_CONT = 0x2
	// PDB operation in One-Shot mode
	PDB0_SC_CONT_0 = 0x0
	// PDB operation in Continuous mode
	PDB0_SC_CONT_1 = 0x1
	// Position of MULT field.
	PDB0_SC_MULT_Pos = 0x2
	// Bit mask of MULT field.
	PDB0_SC_MULT_Msk = 0xc
	// Multiplication factor is 1.
	PDB0_SC_MULT_00 = 0x0
	// Multiplication factor is 10.
	PDB0_SC_MULT_01 = 0x1
	// Multiplication factor is 20.
	PDB0_SC_MULT_10 = 0x2
	// Multiplication factor is 40.
	PDB0_SC_MULT_11 = 0x3
	// Position of PDBIE field.
	PDB0_SC_PDBIE_Pos = 0x5
	// Bit mask of PDBIE field.
	PDB0_SC_PDBIE_Msk = 0x20
	// Bit PDBIE.
	PDB0_SC_PDBIE = 0x20
	// PDB interrupt disabled.
	PDB0_SC_PDBIE_0 = 0x0
	// PDB interrupt enabled.
	PDB0_SC_PDBIE_1 = 0x1
	// Position of PDBIF field.
	PDB0_SC_PDBIF_Pos = 0x6
	// Bit mask of PDBIF field.
	PDB0_SC_PDBIF_Msk = 0x40
	// Bit PDBIF.
	PDB0_SC_PDBIF = 0x40
	// Position of PDBEN field.
	PDB0_SC_PDBEN_Pos = 0x7
	// Bit mask of PDBEN field.
	PDB0_SC_PDBEN_Msk = 0x80
	// Bit PDBEN.
	PDB0_SC_PDBEN = 0x80
	// PDB disabled. Counter is off.
	PDB0_SC_PDBEN_0 = 0x0
	// PDB enabled.
	PDB0_SC_PDBEN_1 = 0x1
	// Position of TRGSEL field.
	PDB0_SC_TRGSEL_Pos = 0x8
	// Bit mask of TRGSEL field.
	PDB0_SC_TRGSEL_Msk = 0xf00
	// Trigger-In 0 is selected.
	PDB0_SC_TRGSEL_0000 = 0x0
	// Trigger-In 1 is selected.
	PDB0_SC_TRGSEL_0001 = 0x1
	// Trigger-In 2 is selected.
	PDB0_SC_TRGSEL_0010 = 0x2
	// Trigger-In 3 is selected.
	PDB0_SC_TRGSEL_0011 = 0x3
	// Trigger-In 4 is selected.
	PDB0_SC_TRGSEL_0100 = 0x4
	// Trigger-In 5 is selected.
	PDB0_SC_TRGSEL_0101 = 0x5
	// Trigger-In 6 is selected.
	PDB0_SC_TRGSEL_0110 = 0x6
	// Trigger-In 7 is selected.
	PDB0_SC_TRGSEL_0111 = 0x7
	// Trigger-In 8 is selected.
	PDB0_SC_TRGSEL_1000 = 0x8
	// Trigger-In 9 is selected.
	PDB0_SC_TRGSEL_1001 = 0x9
	// Trigger-In 10 is selected.
	PDB0_SC_TRGSEL_1010 = 0xa
	// Trigger-In 11 is selected.
	PDB0_SC_TRGSEL_1011 = 0xb
	// Trigger-In 12 is selected.
	PDB0_SC_TRGSEL_1100 = 0xc
	// Trigger-In 13 is selected.
	PDB0_SC_TRGSEL_1101 = 0xd
	// Trigger-In 14 is selected.
	PDB0_SC_TRGSEL_1110 = 0xe
	// Software trigger is selected.
	PDB0_SC_TRGSEL_1111 = 0xf
	// Position of PRESCALER field.
	PDB0_SC_PRESCALER_Pos = 0xc
	// Bit mask of PRESCALER field.
	PDB0_SC_PRESCALER_Msk = 0x7000
	// Counting uses the peripheral clock divided by multiplication factor selected by MULT.
	PDB0_SC_PRESCALER_000 = 0x0
	// Counting uses the peripheral clock divided by twice of the multiplication factor selected by MULT.
	PDB0_SC_PRESCALER_001 = 0x1
	// Counting uses the peripheral clock divided by four times of the multiplication factor selected by MULT.
	PDB0_SC_PRESCALER_010 = 0x2
	// Counting uses the peripheral clock divided by eight times of the multiplication factor selected by MULT.
	PDB0_SC_PRESCALER_011 = 0x3
	// Counting uses the peripheral clock divided by 16 times of the multiplication factor selected by MULT.
	PDB0_SC_PRESCALER_100 = 0x4
	// Counting uses the peripheral clock divided by 32 times of the multiplication factor selected by MULT.
	PDB0_SC_PRESCALER_101 = 0x5
	// Counting uses the peripheral clock divided by 64 times of the multiplication factor selected by MULT.
	PDB0_SC_PRESCALER_110 = 0x6
	// Counting uses the peripheral clock divided by 128 times of the multiplication factor selected by MULT.
	PDB0_SC_PRESCALER_111 = 0x7
	// Position of DMAEN field.
	PDB0_SC_DMAEN_Pos = 0xf
	// Bit mask of DMAEN field.
	PDB0_SC_DMAEN_Msk = 0x8000
	// Bit DMAEN.
	PDB0_SC_DMAEN = 0x8000
	// DMA disabled.
	PDB0_SC_DMAEN_0 = 0x0
	// DMA enabled.
	PDB0_SC_DMAEN_1 = 0x1
	// Position of SWTRIG field.
	PDB0_SC_SWTRIG_Pos = 0x10
	// Bit mask of SWTRIG field.
	PDB0_SC_SWTRIG_Msk = 0x10000
	// Bit SWTRIG.
	PDB0_SC_SWTRIG = 0x10000
	// Position of PDBEIE field.
	PDB0_SC_PDBEIE_Pos = 0x11
	// Bit mask of PDBEIE field.
	PDB0_SC_PDBEIE_Msk = 0x20000
	// Bit PDBEIE.
	PDB0_SC_PDBEIE = 0x20000
	// PDB sequence error interrupt disabled.
	PDB0_SC_PDBEIE_0 = 0x0
	// PDB sequence error interrupt enabled.
	PDB0_SC_PDBEIE_1 = 0x1
	// Position of LDMOD field.
	PDB0_SC_LDMOD_Pos = 0x12
	// Bit mask of LDMOD field.
	PDB0_SC_LDMOD_Msk = 0xc0000
	// The internal registers are loaded with the values from their buffers immediately after 1 is written to LDOK.
	PDB0_SC_LDMOD_00 = 0x0
	// The internal registers are loaded with the values from their buffers when the PDB counter reaches the MOD register value after 1 is written to LDOK.
	PDB0_SC_LDMOD_01 = 0x1
	// The internal registers are loaded with the values from their buffers when a trigger input event is detected after 1 is written to LDOK.
	PDB0_SC_LDMOD_10 = 0x2
	// The internal registers are loaded with the values from their buffers when either the PDB counter reaches the MOD register value or a trigger input event is detected, after 1 is written to LDOK.
	PDB0_SC_LDMOD_11 = 0x3

	// MOD: Modulus register
	// Position of MOD field.
	PDB0_MOD_MOD_Pos = 0x0
	// Bit mask of MOD field.
	PDB0_MOD_MOD_Msk = 0xffff

	// CNT: Counter register
	// Position of CNT field.
	PDB0_CNT_CNT_Pos = 0x0
	// Bit mask of CNT field.
	PDB0_CNT_CNT_Msk = 0xffff

	// IDLY: Interrupt Delay register
	// Position of IDLY field.
	PDB0_IDLY_IDLY_Pos = 0x0
	// Bit mask of IDLY field.
	PDB0_IDLY_IDLY_Msk = 0xffff

	// CH0C1: Channel n Control register 1
	// Position of EN0 field.
	PDB0_CHC1_EN0_Pos = 0x0
	// Bit mask of EN0 field.
	PDB0_CHC1_EN0_Msk = 0x1
	// Bit EN0.
	PDB0_CHC1_EN0 = 0x1
	// PDB channel's corresponding pre-trigger disabled.
	PDB0_CHC1_EN0_0 = 0x0
	// PDB channel's corresponding pre-trigger enabled.
	PDB0_CHC1_EN0_1 = 0x1
	// Position of EN1 field.
	PDB0_CHC1_EN1_Pos = 0x1
	// Bit mask of EN1 field.
	PDB0_CHC1_EN1_Msk = 0x2
	// Bit EN1.
	PDB0_CHC1_EN1 = 0x2
	// PDB channel's corresponding pre-trigger disabled.
	PDB0_CHC1_EN1_0 = 0x0
	// PDB channel's corresponding pre-trigger enabled.
	PDB0_CHC1_EN1_1 = 0x1
	// Position of EN2 field.
	PDB0_CHC1_EN2_Pos = 0x2
	// Bit mask of EN2 field.
	PDB0_CHC1_EN2_Msk = 0x4
	// Bit EN2.
	PDB0_CHC1_EN2 = 0x4
	// PDB channel's corresponding pre-trigger disabled.
	PDB0_CHC1_EN2_0 = 0x0
	// PDB channel's corresponding pre-trigger enabled.
	PDB0_CHC1_EN2_1 = 0x1
	// Position of EN3 field.
	PDB0_CHC1_EN3_Pos = 0x3
	// Bit mask of EN3 field.
	PDB0_CHC1_EN3_Msk = 0x8
	// Bit EN3.
	PDB0_CHC1_EN3 = 0x8
	// PDB channel's corresponding pre-trigger disabled.
	PDB0_CHC1_EN3_0 = 0x0
	// PDB channel's corresponding pre-trigger enabled.
	PDB0_CHC1_EN3_1 = 0x1
	// Position of EN4 field.
	PDB0_CHC1_EN4_Pos = 0x4
	// Bit mask of EN4 field.
	PDB0_CHC1_EN4_Msk = 0x10
	// Bit EN4.
	PDB0_CHC1_EN4 = 0x10
	// PDB channel's corresponding pre-trigger disabled.
	PDB0_CHC1_EN4_0 = 0x0
	// PDB channel's corresponding pre-trigger enabled.
	PDB0_CHC1_EN4_1 = 0x1
	// Position of EN5 field.
	PDB0_CHC1_EN5_Pos = 0x5
	// Bit mask of EN5 field.
	PDB0_CHC1_EN5_Msk = 0x20
	// Bit EN5.
	PDB0_CHC1_EN5 = 0x20
	// PDB channel's corresponding pre-trigger disabled.
	PDB0_CHC1_EN5_0 = 0x0
	// PDB channel's corresponding pre-trigger enabled.
	PDB0_CHC1_EN5_1 = 0x1
	// Position of EN6 field.
	PDB0_CHC1_EN6_Pos = 0x6
	// Bit mask of EN6 field.
	PDB0_CHC1_EN6_Msk = 0x40
	// Bit EN6.
	PDB0_CHC1_EN6 = 0x40
	// PDB channel's corresponding pre-trigger disabled.
	PDB0_CHC1_EN6_0 = 0x0
	// PDB channel's corresponding pre-trigger enabled.
	PDB0_CHC1_EN6_1 = 0x1
	// Position of EN7 field.
	PDB0_CHC1_EN7_Pos = 0x7
	// Bit mask of EN7 field.
	PDB0_CHC1_EN7_Msk = 0x80
	// Bit EN7.
	PDB0_CHC1_EN7 = 0x80
	// PDB channel's corresponding pre-trigger disabled.
	PDB0_CHC1_EN7_0 = 0x0
	// PDB channel's corresponding pre-trigger enabled.
	PDB0_CHC1_EN7_1 = 0x1
	// Position of TOS0 field.
	PDB0_CHC1_TOS0_Pos = 0x8
	// Bit mask of TOS0 field.
	PDB0_CHC1_TOS0_Msk = 0x100
	// Bit TOS0.
	PDB0_CHC1_TOS0 = 0x100
	// PDB channel's corresponding pre-trigger is in bypassed mode. The pre-trigger asserts one peripheral clock cycle after a rising edge is detected on selected trigger input source or software trigger is selected and SWTRIG is written with 1.
	PDB0_CHC1_TOS0_0 = 0x0
	// PDB channel's corresponding pre-trigger asserts when the counter reaches the channel delay register and one peripheral clock cycle after a rising edge is detected on selected trigger input source or software trigger is selected and SETRIG is written with 1.
	PDB0_CHC1_TOS0_1 = 0x1
	// Position of TOS1 field.
	PDB0_CHC1_TOS1_Pos = 0x9
	// Bit mask of TOS1 field.
	PDB0_CHC1_TOS1_Msk = 0x200
	// Bit TOS1.
	PDB0_CHC1_TOS1 = 0x200
	// PDB channel's corresponding pre-trigger is in bypassed mode. The pre-trigger asserts one peripheral clock cycle after a rising edge is detected on selected trigger input source or software trigger is selected and SWTRIG is written with 1.
	PDB0_CHC1_TOS1_0 = 0x0
	// PDB channel's corresponding pre-trigger asserts when the counter reaches the channel delay register and one peripheral clock cycle after a rising edge is detected on selected trigger input source or software trigger is selected and SETRIG is written with 1.
	PDB0_CHC1_TOS1_1 = 0x1
	// Position of TOS2 field.
	PDB0_CHC1_TOS2_Pos = 0xa
	// Bit mask of TOS2 field.
	PDB0_CHC1_TOS2_Msk = 0x400
	// Bit TOS2.
	PDB0_CHC1_TOS2 = 0x400
	// PDB channel's corresponding pre-trigger is in bypassed mode. The pre-trigger asserts one peripheral clock cycle after a rising edge is detected on selected trigger input source or software trigger is selected and SWTRIG is written with 1.
	PDB0_CHC1_TOS2_0 = 0x0
	// PDB channel's corresponding pre-trigger asserts when the counter reaches the channel delay register and one peripheral clock cycle after a rising edge is detected on selected trigger input source or software trigger is selected and SETRIG is written with 1.
	PDB0_CHC1_TOS2_1 = 0x1
	// Position of TOS3 field.
	PDB0_CHC1_TOS3_Pos = 0xb
	// Bit mask of TOS3 field.
	PDB0_CHC1_TOS3_Msk = 0x800
	// Bit TOS3.
	PDB0_CHC1_TOS3 = 0x800
	// PDB channel's corresponding pre-trigger is in bypassed mode. The pre-trigger asserts one peripheral clock cycle after a rising edge is detected on selected trigger input source or software trigger is selected and SWTRIG is written with 1.
	PDB0_CHC1_TOS3_0 = 0x0
	// PDB channel's corresponding pre-trigger asserts when the counter reaches the channel delay register and one peripheral clock cycle after a rising edge is detected on selected trigger input source or software trigger is selected and SETRIG is written with 1.
	PDB0_CHC1_TOS3_1 = 0x1
	// Position of TOS4 field.
	PDB0_CHC1_TOS4_Pos = 0xc
	// Bit mask of TOS4 field.
	PDB0_CHC1_TOS4_Msk = 0x1000
	// Bit TOS4.
	PDB0_CHC1_TOS4 = 0x1000
	// PDB channel's corresponding pre-trigger is in bypassed mode. The pre-trigger asserts one peripheral clock cycle after a rising edge is detected on selected trigger input source or software trigger is selected and SWTRIG is written with 1.
	PDB0_CHC1_TOS4_0 = 0x0
	// PDB channel's corresponding pre-trigger asserts when the counter reaches the channel delay register and one peripheral clock cycle after a rising edge is detected on selected trigger input source or software trigger is selected and SETRIG is written with 1.
	PDB0_CHC1_TOS4_1 = 0x1
	// Position of TOS5 field.
	PDB0_CHC1_TOS5_Pos = 0xd
	// Bit mask of TOS5 field.
	PDB0_CHC1_TOS5_Msk = 0x2000
	// Bit TOS5.
	PDB0_CHC1_TOS5 = 0x2000
	// PDB channel's corresponding pre-trigger is in bypassed mode. The pre-trigger asserts one peripheral clock cycle after a rising edge is detected on selected trigger input source or software trigger is selected and SWTRIG is written with 1.
	PDB0_CHC1_TOS5_0 = 0x0
	// PDB channel's corresponding pre-trigger asserts when the counter reaches the channel delay register and one peripheral clock cycle after a rising edge is detected on selected trigger input source or software trigger is selected and SETRIG is written with 1.
	PDB0_CHC1_TOS5_1 = 0x1
	// Position of TOS6 field.
	PDB0_CHC1_TOS6_Pos = 0xe
	// Bit mask of TOS6 field.
	PDB0_CHC1_TOS6_Msk = 0x4000
	// Bit TOS6.
	PDB0_CHC1_TOS6 = 0x4000
	// PDB channel's corresponding pre-trigger is in bypassed mode. The pre-trigger asserts one peripheral clock cycle after a rising edge is detected on selected trigger input source or software trigger is selected and SWTRIG is written with 1.
	PDB0_CHC1_TOS6_0 = 0x0
	// PDB channel's corresponding pre-trigger asserts when the counter reaches the channel delay register and one peripheral clock cycle after a rising edge is detected on selected trigger input source or software trigger is selected and SETRIG is written with 1.
	PDB0_CHC1_TOS6_1 = 0x1
	// Position of TOS7 field.
	PDB0_CHC1_TOS7_Pos = 0xf
	// Bit mask of TOS7 field.
	PDB0_CHC1_TOS7_Msk = 0x8000
	// Bit TOS7.
	PDB0_CHC1_TOS7 = 0x8000
	// PDB channel's corresponding pre-trigger is in bypassed mode. The pre-trigger asserts one peripheral clock cycle after a rising edge is detected on selected trigger input source or software trigger is selected and SWTRIG is written with 1.
	PDB0_CHC1_TOS7_0 = 0x0
	// PDB channel's corresponding pre-trigger asserts when the counter reaches the channel delay register and one peripheral clock cycle after a rising edge is detected on selected trigger input source or software trigger is selected and SETRIG is written with 1.
	PDB0_CHC1_TOS7_1 = 0x1
	// Position of BB0 field.
	PDB0_CHC1_BB0_Pos = 0x10
	// Bit mask of BB0 field.
	PDB0_CHC1_BB0_Msk = 0x10000
	// Bit BB0.
	PDB0_CHC1_BB0 = 0x10000
	// PDB channel's corresponding pre-trigger back-to-back operation disabled.
	PDB0_CHC1_BB0_0 = 0x0
	// PDB channel's corresponding pre-trigger back-to-back operation enabled.
	PDB0_CHC1_BB0_1 = 0x1
	// Position of BB1 field.
	PDB0_CHC1_BB1_Pos = 0x11
	// Bit mask of BB1 field.
	PDB0_CHC1_BB1_Msk = 0x20000
	// Bit BB1.
	PDB0_CHC1_BB1 = 0x20000
	// PDB channel's corresponding pre-trigger back-to-back operation disabled.
	PDB0_CHC1_BB1_0 = 0x0
	// PDB channel's corresponding pre-trigger back-to-back operation enabled.
	PDB0_CHC1_BB1_1 = 0x1
	// Position of BB2 field.
	PDB0_CHC1_BB2_Pos = 0x12
	// Bit mask of BB2 field.
	PDB0_CHC1_BB2_Msk = 0x40000
	// Bit BB2.
	PDB0_CHC1_BB2 = 0x40000
	// PDB channel's corresponding pre-trigger back-to-back operation disabled.
	PDB0_CHC1_BB2_0 = 0x0
	// PDB channel's corresponding pre-trigger back-to-back operation enabled.
	PDB0_CHC1_BB2_1 = 0x1
	// Position of BB3 field.
	PDB0_CHC1_BB3_Pos = 0x13
	// Bit mask of BB3 field.
	PDB0_CHC1_BB3_Msk = 0x80000
	// Bit BB3.
	PDB0_CHC1_BB3 = 0x80000
	// PDB channel's corresponding pre-trigger back-to-back operation disabled.
	PDB0_CHC1_BB3_0 = 0x0
	// PDB channel's corresponding pre-trigger back-to-back operation enabled.
	PDB0_CHC1_BB3_1 = 0x1
	// Position of BB4 field.
	PDB0_CHC1_BB4_Pos = 0x14
	// Bit mask of BB4 field.
	PDB0_CHC1_BB4_Msk = 0x100000
	// Bit BB4.
	PDB0_CHC1_BB4 = 0x100000
	// PDB channel's corresponding pre-trigger back-to-back operation disabled.
	PDB0_CHC1_BB4_0 = 0x0
	// PDB channel's corresponding pre-trigger back-to-back operation enabled.
	PDB0_CHC1_BB4_1 = 0x1
	// Position of BB5 field.
	PDB0_CHC1_BB5_Pos = 0x15
	// Bit mask of BB5 field.
	PDB0_CHC1_BB5_Msk = 0x200000
	// Bit BB5.
	PDB0_CHC1_BB5 = 0x200000
	// PDB channel's corresponding pre-trigger back-to-back operation disabled.
	PDB0_CHC1_BB5_0 = 0x0
	// PDB channel's corresponding pre-trigger back-to-back operation enabled.
	PDB0_CHC1_BB5_1 = 0x1
	// Position of BB6 field.
	PDB0_CHC1_BB6_Pos = 0x16
	// Bit mask of BB6 field.
	PDB0_CHC1_BB6_Msk = 0x400000
	// Bit BB6.
	PDB0_CHC1_BB6 = 0x400000
	// PDB channel's corresponding pre-trigger back-to-back operation disabled.
	PDB0_CHC1_BB6_0 = 0x0
	// PDB channel's corresponding pre-trigger back-to-back operation enabled.
	PDB0_CHC1_BB6_1 = 0x1
	// Position of BB7 field.
	PDB0_CHC1_BB7_Pos = 0x17
	// Bit mask of BB7 field.
	PDB0_CHC1_BB7_Msk = 0x800000
	// Bit BB7.
	PDB0_CHC1_BB7 = 0x800000
	// PDB channel's corresponding pre-trigger back-to-back operation disabled.
	PDB0_CHC1_BB7_0 = 0x0
	// PDB channel's corresponding pre-trigger back-to-back operation enabled.
	PDB0_CHC1_BB7_1 = 0x1

	// CH0S: Channel n Status register
	// Position of ERR0 field.
	PDB0_CHS_ERR0_Pos = 0x0
	// Bit mask of ERR0 field.
	PDB0_CHS_ERR0_Msk = 0x1
	// Bit ERR0.
	PDB0_CHS_ERR0 = 0x1
	// Sequence error not detected on PDB channel's corresponding pre-trigger.
	PDB0_CHS_ERR0_0 = 0x0
	// Sequence error detected on PDB channel's corresponding pre-trigger. ADCn block can be triggered for a conversion by one pre-trigger from PDB channel n. When one conversion, which is triggered by one of the pre-triggers from PDB channel n, is in progress, new trigger from PDB channel's corresponding pre-trigger m cannot be accepted by ADCn, and ERR[m] is set. Writing 0's to clear the sequence error flags.
	PDB0_CHS_ERR0_1 = 0x1
	// Position of ERR1 field.
	PDB0_CHS_ERR1_Pos = 0x1
	// Bit mask of ERR1 field.
	PDB0_CHS_ERR1_Msk = 0x2
	// Bit ERR1.
	PDB0_CHS_ERR1 = 0x2
	// Sequence error not detected on PDB channel's corresponding pre-trigger.
	PDB0_CHS_ERR1_0 = 0x0
	// Sequence error detected on PDB channel's corresponding pre-trigger. ADCn block can be triggered for a conversion by one pre-trigger from PDB channel n. When one conversion, which is triggered by one of the pre-triggers from PDB channel n, is in progress, new trigger from PDB channel's corresponding pre-trigger m cannot be accepted by ADCn, and ERR[m] is set. Writing 0's to clear the sequence error flags.
	PDB0_CHS_ERR1_1 = 0x1
	// Position of ERR2 field.
	PDB0_CHS_ERR2_Pos = 0x2
	// Bit mask of ERR2 field.
	PDB0_CHS_ERR2_Msk = 0x4
	// Bit ERR2.
	PDB0_CHS_ERR2 = 0x4
	// Sequence error not detected on PDB channel's corresponding pre-trigger.
	PDB0_CHS_ERR2_0 = 0x0
	// Sequence error detected on PDB channel's corresponding pre-trigger. ADCn block can be triggered for a conversion by one pre-trigger from PDB channel n. When one conversion, which is triggered by one of the pre-triggers from PDB channel n, is in progress, new trigger from PDB channel's corresponding pre-trigger m cannot be accepted by ADCn, and ERR[m] is set. Writing 0's to clear the sequence error flags.
	PDB0_CHS_ERR2_1 = 0x1
	// Position of ERR3 field.
	PDB0_CHS_ERR3_Pos = 0x3
	// Bit mask of ERR3 field.
	PDB0_CHS_ERR3_Msk = 0x8
	// Bit ERR3.
	PDB0_CHS_ERR3 = 0x8
	// Sequence error not detected on PDB channel's corresponding pre-trigger.
	PDB0_CHS_ERR3_0 = 0x0
	// Sequence error detected on PDB channel's corresponding pre-trigger. ADCn block can be triggered for a conversion by one pre-trigger from PDB channel n. When one conversion, which is triggered by one of the pre-triggers from PDB channel n, is in progress, new trigger from PDB channel's corresponding pre-trigger m cannot be accepted by ADCn, and ERR[m] is set. Writing 0's to clear the sequence error flags.
	PDB0_CHS_ERR3_1 = 0x1
	// Position of ERR4 field.
	PDB0_CHS_ERR4_Pos = 0x4
	// Bit mask of ERR4 field.
	PDB0_CHS_ERR4_Msk = 0x10
	// Bit ERR4.
	PDB0_CHS_ERR4 = 0x10
	// Sequence error not detected on PDB channel's corresponding pre-trigger.
	PDB0_CHS_ERR4_0 = 0x0
	// Sequence error detected on PDB channel's corresponding pre-trigger. ADCn block can be triggered for a conversion by one pre-trigger from PDB channel n. When one conversion, which is triggered by one of the pre-triggers from PDB channel n, is in progress, new trigger from PDB channel's corresponding pre-trigger m cannot be accepted by ADCn, and ERR[m] is set. Writing 0's to clear the sequence error flags.
	PDB0_CHS_ERR4_1 = 0x1
	// Position of ERR5 field.
	PDB0_CHS_ERR5_Pos = 0x5
	// Bit mask of ERR5 field.
	PDB0_CHS_ERR5_Msk = 0x20
	// Bit ERR5.
	PDB0_CHS_ERR5 = 0x20
	// Sequence error not detected on PDB channel's corresponding pre-trigger.
	PDB0_CHS_ERR5_0 = 0x0
	// Sequence error detected on PDB channel's corresponding pre-trigger. ADCn block can be triggered for a conversion by one pre-trigger from PDB channel n. When one conversion, which is triggered by one of the pre-triggers from PDB channel n, is in progress, new trigger from PDB channel's corresponding pre-trigger m cannot be accepted by ADCn, and ERR[m] is set. Writing 0's to clear the sequence error flags.
	PDB0_CHS_ERR5_1 = 0x1
	// Position of ERR6 field.
	PDB0_CHS_ERR6_Pos = 0x6
	// Bit mask of ERR6 field.
	PDB0_CHS_ERR6_Msk = 0x40
	// Bit ERR6.
	PDB0_CHS_ERR6 = 0x40
	// Sequence error not detected on PDB channel's corresponding pre-trigger.
	PDB0_CHS_ERR6_0 = 0x0
	// Sequence error detected on PDB channel's corresponding pre-trigger. ADCn block can be triggered for a conversion by one pre-trigger from PDB channel n. When one conversion, which is triggered by one of the pre-triggers from PDB channel n, is in progress, new trigger from PDB channel's corresponding pre-trigger m cannot be accepted by ADCn, and ERR[m] is set. Writing 0's to clear the sequence error flags.
	PDB0_CHS_ERR6_1 = 0x1
	// Position of ERR7 field.
	PDB0_CHS_ERR7_Pos = 0x7
	// Bit mask of ERR7 field.
	PDB0_CHS_ERR7_Msk = 0x80
	// Bit ERR7.
	PDB0_CHS_ERR7 = 0x80
	// Sequence error not detected on PDB channel's corresponding pre-trigger.
	PDB0_CHS_ERR7_0 = 0x0
	// Sequence error detected on PDB channel's corresponding pre-trigger. ADCn block can be triggered for a conversion by one pre-trigger from PDB channel n. When one conversion, which is triggered by one of the pre-triggers from PDB channel n, is in progress, new trigger from PDB channel's corresponding pre-trigger m cannot be accepted by ADCn, and ERR[m] is set. Writing 0's to clear the sequence error flags.
	PDB0_CHS_ERR7_1 = 0x1
	// Position of CF field.
	PDB0_CHS_CF_Pos = 0x10
	// Bit mask of CF field.
	PDB0_CHS_CF_Msk = 0xff0000

	// CH0DLY0: Channel n Delay 0 register
	// Position of DLY field.
	PDB0_CHDLY0_DLY_Pos = 0x0
	// Bit mask of DLY field.
	PDB0_CHDLY0_DLY_Msk = 0xffff

	// CH0DLY1: Channel n Delay 1 register
	// Position of DLY field.
	PDB0_CHDLY1_DLY_Pos = 0x0
	// Bit mask of DLY field.
	PDB0_CHDLY1_DLY_Msk = 0xffff

	// DACINTC0: DAC Interval Trigger n Control register
	// Position of TOE field.
	PDB0_DACINTC_TOE_Pos = 0x0
	// Bit mask of TOE field.
	PDB0_DACINTC_TOE_Msk = 0x1
	// Bit TOE.
	PDB0_DACINTC_TOE = 0x1
	// DAC interval trigger disabled.
	PDB0_DACINTC_TOE_0 = 0x0
	// DAC interval trigger enabled.
	PDB0_DACINTC_TOE_1 = 0x1
	// Position of EXT field.
	PDB0_DACINTC_EXT_Pos = 0x1
	// Bit mask of EXT field.
	PDB0_DACINTC_EXT_Msk = 0x2
	// Bit EXT.
	PDB0_DACINTC_EXT = 0x2
	// DAC external trigger input disabled. DAC interval counter is reset and counting starts when a rising edge is detected on selected trigger input source or software trigger is selected and SWTRIG is written with 1.
	PDB0_DACINTC_EXT_0 = 0x0
	// DAC external trigger input enabled. DAC interval counter is bypassed and DAC external trigger input triggers the DAC interval trigger.
	PDB0_DACINTC_EXT_1 = 0x1

	// DACINT0: DAC Interval n register
	// Position of INT field.
	PDB0_DACINT_INT_Pos = 0x0
	// Bit mask of INT field.
	PDB0_DACINT_INT_Msk = 0xffff

	// POEN: Pulse-Out n Enable register
	// Position of POEN0 field.
	PDB0_POEN_POEN0_Pos = 0x0
	// Bit mask of POEN0 field.
	PDB0_POEN_POEN0_Msk = 0x1
	// Bit POEN0.
	PDB0_POEN_POEN0 = 0x1
	// PDB Pulse-Out disabled
	PDB0_POEN_POEN0_0 = 0x0
	// PDB Pulse-Out enabled
	PDB0_POEN_POEN0_1 = 0x1
	// Position of POEN1 field.
	PDB0_POEN_POEN1_Pos = 0x1
	// Bit mask of POEN1 field.
	PDB0_POEN_POEN1_Msk = 0x2
	// Bit POEN1.
	PDB0_POEN_POEN1 = 0x2
	// PDB Pulse-Out disabled
	PDB0_POEN_POEN1_0 = 0x0
	// PDB Pulse-Out enabled
	PDB0_POEN_POEN1_1 = 0x1
	// Position of POEN2 field.
	PDB0_POEN_POEN2_Pos = 0x2
	// Bit mask of POEN2 field.
	PDB0_POEN_POEN2_Msk = 0x4
	// Bit POEN2.
	PDB0_POEN_POEN2 = 0x4
	// PDB Pulse-Out disabled
	PDB0_POEN_POEN2_0 = 0x0
	// PDB Pulse-Out enabled
	PDB0_POEN_POEN2_1 = 0x1
	// Position of POEN3 field.
	PDB0_POEN_POEN3_Pos = 0x3
	// Bit mask of POEN3 field.
	PDB0_POEN_POEN3_Msk = 0x8
	// Bit POEN3.
	PDB0_POEN_POEN3 = 0x8
	// PDB Pulse-Out disabled
	PDB0_POEN_POEN3_0 = 0x0
	// PDB Pulse-Out enabled
	PDB0_POEN_POEN3_1 = 0x1
	// Position of POEN4 field.
	PDB0_POEN_POEN4_Pos = 0x4
	// Bit mask of POEN4 field.
	PDB0_POEN_POEN4_Msk = 0x10
	// Bit POEN4.
	PDB0_POEN_POEN4 = 0x10
	// PDB Pulse-Out disabled
	PDB0_POEN_POEN4_0 = 0x0
	// PDB Pulse-Out enabled
	PDB0_POEN_POEN4_1 = 0x1
	// Position of POEN5 field.
	PDB0_POEN_POEN5_Pos = 0x5
	// Bit mask of POEN5 field.
	PDB0_POEN_POEN5_Msk = 0x20
	// Bit POEN5.
	PDB0_POEN_POEN5 = 0x20
	// PDB Pulse-Out disabled
	PDB0_POEN_POEN5_0 = 0x0
	// PDB Pulse-Out enabled
	PDB0_POEN_POEN5_1 = 0x1
	// Position of POEN6 field.
	PDB0_POEN_POEN6_Pos = 0x6
	// Bit mask of POEN6 field.
	PDB0_POEN_POEN6_Msk = 0x40
	// Bit POEN6.
	PDB0_POEN_POEN6 = 0x40
	// PDB Pulse-Out disabled
	PDB0_POEN_POEN6_0 = 0x0
	// PDB Pulse-Out enabled
	PDB0_POEN_POEN6_1 = 0x1
	// Position of POEN7 field.
	PDB0_POEN_POEN7_Pos = 0x7
	// Bit mask of POEN7 field.
	PDB0_POEN_POEN7_Msk = 0x80
	// Bit POEN7.
	PDB0_POEN_POEN7 = 0x80
	// PDB Pulse-Out disabled
	PDB0_POEN_POEN7_0 = 0x0
	// PDB Pulse-Out enabled
	PDB0_POEN_POEN7_1 = 0x1

	// PO0DLY: Pulse-Out n Delay register
	// Position of DLY2 field.
	PDB0_PODLY_DLY2_Pos = 0x0
	// Bit mask of DLY2 field.
	PDB0_PODLY_DLY2_Msk = 0xffff
	// Position of DLY1 field.
	PDB0_PODLY_DLY1_Pos = 0x10
	// Bit mask of DLY1 field.
	PDB0_PODLY_DLY1_Msk = 0xffff0000
)

// Constants for PIT: Periodic Interrupt Timer
const (
	// MCR: PIT Module Control Register
	// Position of FRZ field.
	PIT_MCR_FRZ_Pos = 0x0
	// Bit mask of FRZ field.
	PIT_MCR_FRZ_Msk = 0x1
	// Bit FRZ.
	PIT_MCR_FRZ = 0x1
	// Timers continue to run in Debug mode.
	PIT_MCR_FRZ_0 = 0x0
	// Timers are stopped in Debug mode.
	PIT_MCR_FRZ_1 = 0x1
	// Position of MDIS field.
	PIT_MCR_MDIS_Pos = 0x1
	// Bit mask of MDIS field.
	PIT_MCR_MDIS_Msk = 0x2
	// Bit MDIS.
	PIT_MCR_MDIS = 0x2
	// Clock for standard PIT timers is enabled.
	PIT_MCR_MDIS_0 = 0x0
	// Clock for standard PIT timers is disabled.
	PIT_MCR_MDIS_1 = 0x1

	// LDVAL0: Timer Load Value Register
	// Position of TSV field.
	PIT_LDVAL_TSV_Pos = 0x0
	// Bit mask of TSV field.
	PIT_LDVAL_TSV_Msk = 0xffffffff

	// CVAL0: Current Timer Value Register
	// Position of TVL field.
	PIT_CVAL_TVL_Pos = 0x0
	// Bit mask of TVL field.
	PIT_CVAL_TVL_Msk = 0xffffffff

	// TCTRL0: Timer Control Register
	// Position of TEN field.
	PIT_TCTRL_TEN_Pos = 0x0
	// Bit mask of TEN field.
	PIT_TCTRL_TEN_Msk = 0x1
	// Bit TEN.
	PIT_TCTRL_TEN = 0x1
	// Timer n is disabled.
	PIT_TCTRL_TEN_0 = 0x0
	// Timer n is enabled.
	PIT_TCTRL_TEN_1 = 0x1
	// Position of TIE field.
	PIT_TCTRL_TIE_Pos = 0x1
	// Bit mask of TIE field.
	PIT_TCTRL_TIE_Msk = 0x2
	// Bit TIE.
	PIT_TCTRL_TIE = 0x2
	// Interrupt requests from Timer n are disabled.
	PIT_TCTRL_TIE_0 = 0x0
	// Interrupt will be requested whenever TIF is set.
	PIT_TCTRL_TIE_1 = 0x1
	// Position of CHN field.
	PIT_TCTRL_CHN_Pos = 0x2
	// Bit mask of CHN field.
	PIT_TCTRL_CHN_Msk = 0x4
	// Bit CHN.
	PIT_TCTRL_CHN = 0x4
	// Timer is not chained.
	PIT_TCTRL_CHN_0 = 0x0
	// Timer is chained to previous timer. For example, for Channel 2, if this field is set, Timer 2 is chained to Timer 1.
	PIT_TCTRL_CHN_1 = 0x1

	// TFLG0: Timer Flag Register
	// Position of TIF field.
	PIT_TFLG_TIF_Pos = 0x0
	// Bit mask of TIF field.
	PIT_TFLG_TIF_Msk = 0x1
	// Bit TIF.
	PIT_TFLG_TIF = 0x1
	// Timeout has not yet occurred.
	PIT_TFLG_TIF_0 = 0x0
	// Timeout has occurred.
	PIT_TFLG_TIF_1 = 0x1
)

// Constants for FTM0: FlexTimer Module
const (
	// SC: Status And Control
	// Position of PS field.
	FTM_SC_PS_Pos = 0x0
	// Bit mask of PS field.
	FTM_SC_PS_Msk = 0x7
	// Divide by 1
	FTM_SC_PS_000 = 0x0
	// Divide by 2
	FTM_SC_PS_001 = 0x1
	// Divide by 4
	FTM_SC_PS_010 = 0x2
	// Divide by 8
	FTM_SC_PS_011 = 0x3
	// Divide by 16
	FTM_SC_PS_100 = 0x4
	// Divide by 32
	FTM_SC_PS_101 = 0x5
	// Divide by 64
	FTM_SC_PS_110 = 0x6
	// Divide by 128
	FTM_SC_PS_111 = 0x7
	// Position of CLKS field.
	FTM_SC_CLKS_Pos = 0x3
	// Bit mask of CLKS field.
	FTM_SC_CLKS_Msk = 0x18
	// No clock selected. This in effect disables the FTM counter.
	FTM_SC_CLKS_00 = 0x0
	// System clock
	FTM_SC_CLKS_01 = 0x1
	// Fixed frequency clock
	FTM_SC_CLKS_10 = 0x2
	// External clock
	FTM_SC_CLKS_11 = 0x3
	// Position of CPWMS field.
	FTM_SC_CPWMS_Pos = 0x5
	// Bit mask of CPWMS field.
	FTM_SC_CPWMS_Msk = 0x20
	// Bit CPWMS.
	FTM_SC_CPWMS = 0x20
	// FTM counter operates in Up Counting mode.
	FTM_SC_CPWMS_0 = 0x0
	// FTM counter operates in Up-Down Counting mode.
	FTM_SC_CPWMS_1 = 0x1
	// Position of TOIE field.
	FTM_SC_TOIE_Pos = 0x6
	// Bit mask of TOIE field.
	FTM_SC_TOIE_Msk = 0x40
	// Bit TOIE.
	FTM_SC_TOIE = 0x40
	// Disable TOF interrupts. Use software polling.
	FTM_SC_TOIE_0 = 0x0
	// Enable TOF interrupts. An interrupt is generated when TOF equals one.
	FTM_SC_TOIE_1 = 0x1
	// Position of TOF field.
	FTM_SC_TOF_Pos = 0x7
	// Bit mask of TOF field.
	FTM_SC_TOF_Msk = 0x80
	// Bit TOF.
	FTM_SC_TOF = 0x80
	// FTM counter has not overflowed.
	FTM_SC_TOF_0 = 0x0
	// FTM counter has overflowed.
	FTM_SC_TOF_1 = 0x1

	// CNT: Counter
	// Position of COUNT field.
	FTM_CNT_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	FTM_CNT_COUNT_Msk = 0xffff

	// MOD: Modulo
	// Position of MOD field.
	FTM_MOD_MOD_Pos = 0x0
	// Bit mask of MOD field.
	FTM_MOD_MOD_Msk = 0xffff

	// C0SC: Channel (n) Status And Control
	// Position of DMA field.
	FTM_CSC_DMA_Pos = 0x0
	// Bit mask of DMA field.
	FTM_CSC_DMA_Msk = 0x1
	// Bit DMA.
	FTM_CSC_DMA = 0x1
	// Disable DMA transfers.
	FTM_CSC_DMA_0 = 0x0
	// Enable DMA transfers.
	FTM_CSC_DMA_1 = 0x1
	// Position of ELSA field.
	FTM_CSC_ELSA_Pos = 0x2
	// Bit mask of ELSA field.
	FTM_CSC_ELSA_Msk = 0x4
	// Bit ELSA.
	FTM_CSC_ELSA = 0x4
	// Position of ELSB field.
	FTM_CSC_ELSB_Pos = 0x3
	// Bit mask of ELSB field.
	FTM_CSC_ELSB_Msk = 0x8
	// Bit ELSB.
	FTM_CSC_ELSB = 0x8
	// Position of MSA field.
	FTM_CSC_MSA_Pos = 0x4
	// Bit mask of MSA field.
	FTM_CSC_MSA_Msk = 0x10
	// Bit MSA.
	FTM_CSC_MSA = 0x10
	// Position of MSB field.
	FTM_CSC_MSB_Pos = 0x5
	// Bit mask of MSB field.
	FTM_CSC_MSB_Msk = 0x20
	// Bit MSB.
	FTM_CSC_MSB = 0x20
	// Position of CHIE field.
	FTM_CSC_CHIE_Pos = 0x6
	// Bit mask of CHIE field.
	FTM_CSC_CHIE_Msk = 0x40
	// Bit CHIE.
	FTM_CSC_CHIE = 0x40
	// Disable channel interrupts. Use software polling.
	FTM_CSC_CHIE_0 = 0x0
	// Enable channel interrupts.
	FTM_CSC_CHIE_1 = 0x1
	// Position of CHF field.
	FTM_CSC_CHF_Pos = 0x7
	// Bit mask of CHF field.
	FTM_CSC_CHF_Msk = 0x80
	// Bit CHF.
	FTM_CSC_CHF = 0x80
	// No channel event has occurred.
	FTM_CSC_CHF_0 = 0x0
	// A channel event has occurred.
	FTM_CSC_CHF_1 = 0x1

	// C0V: Channel (n) Value
	// Position of VAL field.
	FTM_CV_VAL_Pos = 0x0
	// Bit mask of VAL field.
	FTM_CV_VAL_Msk = 0xffff

	// CNTIN: Counter Initial Value
	// Position of INIT field.
	FTM_CNTIN_INIT_Pos = 0x0
	// Bit mask of INIT field.
	FTM_CNTIN_INIT_Msk = 0xffff

	// STATUS: Capture And Compare Status
	// Position of CH0F field.
	FTM_STATUS_CH0F_Pos = 0x0
	// Bit mask of CH0F field.
	FTM_STATUS_CH0F_Msk = 0x1
	// Bit CH0F.
	FTM_STATUS_CH0F = 0x1
	// No channel event has occurred.
	FTM_STATUS_CH0F_0 = 0x0
	// A channel event has occurred.
	FTM_STATUS_CH0F_1 = 0x1
	// Position of CH1F field.
	FTM_STATUS_CH1F_Pos = 0x1
	// Bit mask of CH1F field.
	FTM_STATUS_CH1F_Msk = 0x2
	// Bit CH1F.
	FTM_STATUS_CH1F = 0x2
	// No channel event has occurred.
	FTM_STATUS_CH1F_0 = 0x0
	// A channel event has occurred.
	FTM_STATUS_CH1F_1 = 0x1
	// Position of CH2F field.
	FTM_STATUS_CH2F_Pos = 0x2
	// Bit mask of CH2F field.
	FTM_STATUS_CH2F_Msk = 0x4
	// Bit CH2F.
	FTM_STATUS_CH2F = 0x4
	// No channel event has occurred.
	FTM_STATUS_CH2F_0 = 0x0
	// A channel event has occurred.
	FTM_STATUS_CH2F_1 = 0x1
	// Position of CH3F field.
	FTM_STATUS_CH3F_Pos = 0x3
	// Bit mask of CH3F field.
	FTM_STATUS_CH3F_Msk = 0x8
	// Bit CH3F.
	FTM_STATUS_CH3F = 0x8
	// No channel event has occurred.
	FTM_STATUS_CH3F_0 = 0x0
	// A channel event has occurred.
	FTM_STATUS_CH3F_1 = 0x1
	// Position of CH4F field.
	FTM_STATUS_CH4F_Pos = 0x4
	// Bit mask of CH4F field.
	FTM_STATUS_CH4F_Msk = 0x10
	// Bit CH4F.
	FTM_STATUS_CH4F = 0x10
	// No channel event has occurred.
	FTM_STATUS_CH4F_0 = 0x0
	// A channel event has occurred.
	FTM_STATUS_CH4F_1 = 0x1
	// Position of CH5F field.
	FTM_STATUS_CH5F_Pos = 0x5
	// Bit mask of CH5F field.
	FTM_STATUS_CH5F_Msk = 0x20
	// Bit CH5F.
	FTM_STATUS_CH5F = 0x20
	// No channel event has occurred.
	FTM_STATUS_CH5F_0 = 0x0
	// A channel event has occurred.
	FTM_STATUS_CH5F_1 = 0x1
	// Position of CH6F field.
	FTM_STATUS_CH6F_Pos = 0x6
	// Bit mask of CH6F field.
	FTM_STATUS_CH6F_Msk = 0x40
	// Bit CH6F.
	FTM_STATUS_CH6F = 0x40
	// No channel event has occurred.
	FTM_STATUS_CH6F_0 = 0x0
	// A channel event has occurred.
	FTM_STATUS_CH6F_1 = 0x1
	// Position of CH7F field.
	FTM_STATUS_CH7F_Pos = 0x7
	// Bit mask of CH7F field.
	FTM_STATUS_CH7F_Msk = 0x80
	// Bit CH7F.
	FTM_STATUS_CH7F = 0x80
	// No channel event has occurred.
	FTM_STATUS_CH7F_0 = 0x0
	// A channel event has occurred.
	FTM_STATUS_CH7F_1 = 0x1

	// MODE: Features Mode Selection
	// Position of FTMEN field.
	FTM_MODE_FTMEN_Pos = 0x0
	// Bit mask of FTMEN field.
	FTM_MODE_FTMEN_Msk = 0x1
	// Bit FTMEN.
	FTM_MODE_FTMEN = 0x1
	// Only the TPM-compatible registers (first set of registers) can be used without any restriction. Do not use the FTM-specific registers.
	FTM_MODE_FTMEN_0 = 0x0
	// All registers including the FTM-specific registers (second set of registers) are available for use with no restrictions.
	FTM_MODE_FTMEN_1 = 0x1
	// Position of INIT field.
	FTM_MODE_INIT_Pos = 0x1
	// Bit mask of INIT field.
	FTM_MODE_INIT_Msk = 0x2
	// Bit INIT.
	FTM_MODE_INIT = 0x2
	// Position of WPDIS field.
	FTM_MODE_WPDIS_Pos = 0x2
	// Bit mask of WPDIS field.
	FTM_MODE_WPDIS_Msk = 0x4
	// Bit WPDIS.
	FTM_MODE_WPDIS = 0x4
	// Write protection is enabled.
	FTM_MODE_WPDIS_0 = 0x0
	// Write protection is disabled.
	FTM_MODE_WPDIS_1 = 0x1
	// Position of PWMSYNC field.
	FTM_MODE_PWMSYNC_Pos = 0x3
	// Bit mask of PWMSYNC field.
	FTM_MODE_PWMSYNC_Msk = 0x8
	// Bit PWMSYNC.
	FTM_MODE_PWMSYNC = 0x8
	// No restrictions. Software and hardware triggers can be used by MOD, CnV, OUTMASK, and FTM counter synchronization.
	FTM_MODE_PWMSYNC_0 = 0x0
	// Software trigger can only be used by MOD and CnV synchronization, and hardware triggers can only be used by OUTMASK and FTM counter synchronization.
	FTM_MODE_PWMSYNC_1 = 0x1
	// Position of CAPTEST field.
	FTM_MODE_CAPTEST_Pos = 0x4
	// Bit mask of CAPTEST field.
	FTM_MODE_CAPTEST_Msk = 0x10
	// Bit CAPTEST.
	FTM_MODE_CAPTEST = 0x10
	// Capture test mode is disabled.
	FTM_MODE_CAPTEST_0 = 0x0
	// Capture test mode is enabled.
	FTM_MODE_CAPTEST_1 = 0x1
	// Position of FAULTM field.
	FTM_MODE_FAULTM_Pos = 0x5
	// Bit mask of FAULTM field.
	FTM_MODE_FAULTM_Msk = 0x60
	// Fault control is disabled for all channels.
	FTM_MODE_FAULTM_00 = 0x0
	// Fault control is enabled for even channels only (channels 0, 2, 4, and 6), and the selected mode is the manual fault clearing.
	FTM_MODE_FAULTM_01 = 0x1
	// Fault control is enabled for all channels, and the selected mode is the manual fault clearing.
	FTM_MODE_FAULTM_10 = 0x2
	// Fault control is enabled for all channels, and the selected mode is the automatic fault clearing.
	FTM_MODE_FAULTM_11 = 0x3
	// Position of FAULTIE field.
	FTM_MODE_FAULTIE_Pos = 0x7
	// Bit mask of FAULTIE field.
	FTM_MODE_FAULTIE_Msk = 0x80
	// Bit FAULTIE.
	FTM_MODE_FAULTIE = 0x80
	// Fault control interrupt is disabled.
	FTM_MODE_FAULTIE_0 = 0x0
	// Fault control interrupt is enabled.
	FTM_MODE_FAULTIE_1 = 0x1

	// SYNC: Synchronization
	// Position of CNTMIN field.
	FTM_SYNC_CNTMIN_Pos = 0x0
	// Bit mask of CNTMIN field.
	FTM_SYNC_CNTMIN_Msk = 0x1
	// Bit CNTMIN.
	FTM_SYNC_CNTMIN = 0x1
	// The minimum loading point is disabled.
	FTM_SYNC_CNTMIN_0 = 0x0
	// The minimum loading point is enabled.
	FTM_SYNC_CNTMIN_1 = 0x1
	// Position of CNTMAX field.
	FTM_SYNC_CNTMAX_Pos = 0x1
	// Bit mask of CNTMAX field.
	FTM_SYNC_CNTMAX_Msk = 0x2
	// Bit CNTMAX.
	FTM_SYNC_CNTMAX = 0x2
	// The maximum loading point is disabled.
	FTM_SYNC_CNTMAX_0 = 0x0
	// The maximum loading point is enabled.
	FTM_SYNC_CNTMAX_1 = 0x1
	// Position of REINIT field.
	FTM_SYNC_REINIT_Pos = 0x2
	// Bit mask of REINIT field.
	FTM_SYNC_REINIT_Msk = 0x4
	// Bit REINIT.
	FTM_SYNC_REINIT = 0x4
	// FTM counter continues to count normally.
	FTM_SYNC_REINIT_0 = 0x0
	// FTM counter is updated with its initial value when the selected trigger is detected.
	FTM_SYNC_REINIT_1 = 0x1
	// Position of SYNCHOM field.
	FTM_SYNC_SYNCHOM_Pos = 0x3
	// Bit mask of SYNCHOM field.
	FTM_SYNC_SYNCHOM_Msk = 0x8
	// Bit SYNCHOM.
	FTM_SYNC_SYNCHOM = 0x8
	// OUTMASK register is updated with the value of its buffer in all rising edges of the system clock.
	FTM_SYNC_SYNCHOM_0 = 0x0
	// OUTMASK register is updated with the value of its buffer only by the PWM synchronization.
	FTM_SYNC_SYNCHOM_1 = 0x1
	// Position of TRIG0 field.
	FTM_SYNC_TRIG0_Pos = 0x4
	// Bit mask of TRIG0 field.
	FTM_SYNC_TRIG0_Msk = 0x10
	// Bit TRIG0.
	FTM_SYNC_TRIG0 = 0x10
	// Trigger is disabled.
	FTM_SYNC_TRIG0_0 = 0x0
	// Trigger is enabled.
	FTM_SYNC_TRIG0_1 = 0x1
	// Position of TRIG1 field.
	FTM_SYNC_TRIG1_Pos = 0x5
	// Bit mask of TRIG1 field.
	FTM_SYNC_TRIG1_Msk = 0x20
	// Bit TRIG1.
	FTM_SYNC_TRIG1 = 0x20
	// Trigger is disabled.
	FTM_SYNC_TRIG1_0 = 0x0
	// Trigger is enabled.
	FTM_SYNC_TRIG1_1 = 0x1
	// Position of TRIG2 field.
	FTM_SYNC_TRIG2_Pos = 0x6
	// Bit mask of TRIG2 field.
	FTM_SYNC_TRIG2_Msk = 0x40
	// Bit TRIG2.
	FTM_SYNC_TRIG2 = 0x40
	// Trigger is disabled.
	FTM_SYNC_TRIG2_0 = 0x0
	// Trigger is enabled.
	FTM_SYNC_TRIG2_1 = 0x1
	// Position of SWSYNC field.
	FTM_SYNC_SWSYNC_Pos = 0x7
	// Bit mask of SWSYNC field.
	FTM_SYNC_SWSYNC_Msk = 0x80
	// Bit SWSYNC.
	FTM_SYNC_SWSYNC = 0x80
	// Software trigger is not selected.
	FTM_SYNC_SWSYNC_0 = 0x0
	// Software trigger is selected.
	FTM_SYNC_SWSYNC_1 = 0x1

	// OUTINIT: Initial State For Channels Output
	// Position of CH0OI field.
	FTM_OUTINIT_CH0OI_Pos = 0x0
	// Bit mask of CH0OI field.
	FTM_OUTINIT_CH0OI_Msk = 0x1
	// Bit CH0OI.
	FTM_OUTINIT_CH0OI = 0x1
	// The initialization value is 0.
	FTM_OUTINIT_CH0OI_0 = 0x0
	// The initialization value is 1.
	FTM_OUTINIT_CH0OI_1 = 0x1
	// Position of CH1OI field.
	FTM_OUTINIT_CH1OI_Pos = 0x1
	// Bit mask of CH1OI field.
	FTM_OUTINIT_CH1OI_Msk = 0x2
	// Bit CH1OI.
	FTM_OUTINIT_CH1OI = 0x2
	// The initialization value is 0.
	FTM_OUTINIT_CH1OI_0 = 0x0
	// The initialization value is 1.
	FTM_OUTINIT_CH1OI_1 = 0x1
	// Position of CH2OI field.
	FTM_OUTINIT_CH2OI_Pos = 0x2
	// Bit mask of CH2OI field.
	FTM_OUTINIT_CH2OI_Msk = 0x4
	// Bit CH2OI.
	FTM_OUTINIT_CH2OI = 0x4
	// The initialization value is 0.
	FTM_OUTINIT_CH2OI_0 = 0x0
	// The initialization value is 1.
	FTM_OUTINIT_CH2OI_1 = 0x1
	// Position of CH3OI field.
	FTM_OUTINIT_CH3OI_Pos = 0x3
	// Bit mask of CH3OI field.
	FTM_OUTINIT_CH3OI_Msk = 0x8
	// Bit CH3OI.
	FTM_OUTINIT_CH3OI = 0x8
	// The initialization value is 0.
	FTM_OUTINIT_CH3OI_0 = 0x0
	// The initialization value is 1.
	FTM_OUTINIT_CH3OI_1 = 0x1
	// Position of CH4OI field.
	FTM_OUTINIT_CH4OI_Pos = 0x4
	// Bit mask of CH4OI field.
	FTM_OUTINIT_CH4OI_Msk = 0x10
	// Bit CH4OI.
	FTM_OUTINIT_CH4OI = 0x10
	// The initialization value is 0.
	FTM_OUTINIT_CH4OI_0 = 0x0
	// The initialization value is 1.
	FTM_OUTINIT_CH4OI_1 = 0x1
	// Position of CH5OI field.
	FTM_OUTINIT_CH5OI_Pos = 0x5
	// Bit mask of CH5OI field.
	FTM_OUTINIT_CH5OI_Msk = 0x20
	// Bit CH5OI.
	FTM_OUTINIT_CH5OI = 0x20
	// The initialization value is 0.
	FTM_OUTINIT_CH5OI_0 = 0x0
	// The initialization value is 1.
	FTM_OUTINIT_CH5OI_1 = 0x1
	// Position of CH6OI field.
	FTM_OUTINIT_CH6OI_Pos = 0x6
	// Bit mask of CH6OI field.
	FTM_OUTINIT_CH6OI_Msk = 0x40
	// Bit CH6OI.
	FTM_OUTINIT_CH6OI = 0x40
	// The initialization value is 0.
	FTM_OUTINIT_CH6OI_0 = 0x0
	// The initialization value is 1.
	FTM_OUTINIT_CH6OI_1 = 0x1
	// Position of CH7OI field.
	FTM_OUTINIT_CH7OI_Pos = 0x7
	// Bit mask of CH7OI field.
	FTM_OUTINIT_CH7OI_Msk = 0x80
	// Bit CH7OI.
	FTM_OUTINIT_CH7OI = 0x80
	// The initialization value is 0.
	FTM_OUTINIT_CH7OI_0 = 0x0
	// The initialization value is 1.
	FTM_OUTINIT_CH7OI_1 = 0x1

	// OUTMASK: Output Mask
	// Position of CH0OM field.
	FTM_OUTMASK_CH0OM_Pos = 0x0
	// Bit mask of CH0OM field.
	FTM_OUTMASK_CH0OM_Msk = 0x1
	// Bit CH0OM.
	FTM_OUTMASK_CH0OM = 0x1
	// Channel output is not masked. It continues to operate normally.
	FTM_OUTMASK_CH0OM_0 = 0x0
	// Channel output is masked. It is forced to its inactive state.
	FTM_OUTMASK_CH0OM_1 = 0x1
	// Position of CH1OM field.
	FTM_OUTMASK_CH1OM_Pos = 0x1
	// Bit mask of CH1OM field.
	FTM_OUTMASK_CH1OM_Msk = 0x2
	// Bit CH1OM.
	FTM_OUTMASK_CH1OM = 0x2
	// Channel output is not masked. It continues to operate normally.
	FTM_OUTMASK_CH1OM_0 = 0x0
	// Channel output is masked. It is forced to its inactive state.
	FTM_OUTMASK_CH1OM_1 = 0x1
	// Position of CH2OM field.
	FTM_OUTMASK_CH2OM_Pos = 0x2
	// Bit mask of CH2OM field.
	FTM_OUTMASK_CH2OM_Msk = 0x4
	// Bit CH2OM.
	FTM_OUTMASK_CH2OM = 0x4
	// Channel output is not masked. It continues to operate normally.
	FTM_OUTMASK_CH2OM_0 = 0x0
	// Channel output is masked. It is forced to its inactive state.
	FTM_OUTMASK_CH2OM_1 = 0x1
	// Position of CH3OM field.
	FTM_OUTMASK_CH3OM_Pos = 0x3
	// Bit mask of CH3OM field.
	FTM_OUTMASK_CH3OM_Msk = 0x8
	// Bit CH3OM.
	FTM_OUTMASK_CH3OM = 0x8
	// Channel output is not masked. It continues to operate normally.
	FTM_OUTMASK_CH3OM_0 = 0x0
	// Channel output is masked. It is forced to its inactive state.
	FTM_OUTMASK_CH3OM_1 = 0x1
	// Position of CH4OM field.
	FTM_OUTMASK_CH4OM_Pos = 0x4
	// Bit mask of CH4OM field.
	FTM_OUTMASK_CH4OM_Msk = 0x10
	// Bit CH4OM.
	FTM_OUTMASK_CH4OM = 0x10
	// Channel output is not masked. It continues to operate normally.
	FTM_OUTMASK_CH4OM_0 = 0x0
	// Channel output is masked. It is forced to its inactive state.
	FTM_OUTMASK_CH4OM_1 = 0x1
	// Position of CH5OM field.
	FTM_OUTMASK_CH5OM_Pos = 0x5
	// Bit mask of CH5OM field.
	FTM_OUTMASK_CH5OM_Msk = 0x20
	// Bit CH5OM.
	FTM_OUTMASK_CH5OM = 0x20
	// Channel output is not masked. It continues to operate normally.
	FTM_OUTMASK_CH5OM_0 = 0x0
	// Channel output is masked. It is forced to its inactive state.
	FTM_OUTMASK_CH5OM_1 = 0x1
	// Position of CH6OM field.
	FTM_OUTMASK_CH6OM_Pos = 0x6
	// Bit mask of CH6OM field.
	FTM_OUTMASK_CH6OM_Msk = 0x40
	// Bit CH6OM.
	FTM_OUTMASK_CH6OM = 0x40
	// Channel output is not masked. It continues to operate normally.
	FTM_OUTMASK_CH6OM_0 = 0x0
	// Channel output is masked. It is forced to its inactive state.
	FTM_OUTMASK_CH6OM_1 = 0x1
	// Position of CH7OM field.
	FTM_OUTMASK_CH7OM_Pos = 0x7
	// Bit mask of CH7OM field.
	FTM_OUTMASK_CH7OM_Msk = 0x80
	// Bit CH7OM.
	FTM_OUTMASK_CH7OM = 0x80
	// Channel output is not masked. It continues to operate normally.
	FTM_OUTMASK_CH7OM_0 = 0x0
	// Channel output is masked. It is forced to its inactive state.
	FTM_OUTMASK_CH7OM_1 = 0x1

	// COMBINE: Function For Linked Channels
	// Position of COMBINE0 field.
	FTM_COMBINE_COMBINE0_Pos = 0x0
	// Bit mask of COMBINE0 field.
	FTM_COMBINE_COMBINE0_Msk = 0x1
	// Bit COMBINE0.
	FTM_COMBINE_COMBINE0 = 0x1
	// Channels (n) and (n+1) are independent.
	FTM_COMBINE_COMBINE0_0 = 0x0
	// Channels (n) and (n+1) are combined.
	FTM_COMBINE_COMBINE0_1 = 0x1
	// Position of COMP0 field.
	FTM_COMBINE_COMP0_Pos = 0x1
	// Bit mask of COMP0 field.
	FTM_COMBINE_COMP0_Msk = 0x2
	// Bit COMP0.
	FTM_COMBINE_COMP0 = 0x2
	// The channel (n+1) output is the same as the channel (n) output.
	FTM_COMBINE_COMP0_0 = 0x0
	// The channel (n+1) output is the complement of the channel (n) output.
	FTM_COMBINE_COMP0_1 = 0x1
	// Position of DECAPEN0 field.
	FTM_COMBINE_DECAPEN0_Pos = 0x2
	// Bit mask of DECAPEN0 field.
	FTM_COMBINE_DECAPEN0_Msk = 0x4
	// Bit DECAPEN0.
	FTM_COMBINE_DECAPEN0 = 0x4
	// The Dual Edge Capture mode in this pair of channels is disabled.
	FTM_COMBINE_DECAPEN0_0 = 0x0
	// The Dual Edge Capture mode in this pair of channels is enabled.
	FTM_COMBINE_DECAPEN0_1 = 0x1
	// Position of DECAP0 field.
	FTM_COMBINE_DECAP0_Pos = 0x3
	// Bit mask of DECAP0 field.
	FTM_COMBINE_DECAP0_Msk = 0x8
	// Bit DECAP0.
	FTM_COMBINE_DECAP0 = 0x8
	// The dual edge captures are inactive.
	FTM_COMBINE_DECAP0_0 = 0x0
	// The dual edge captures are active.
	FTM_COMBINE_DECAP0_1 = 0x1
	// Position of DTEN0 field.
	FTM_COMBINE_DTEN0_Pos = 0x4
	// Bit mask of DTEN0 field.
	FTM_COMBINE_DTEN0_Msk = 0x10
	// Bit DTEN0.
	FTM_COMBINE_DTEN0 = 0x10
	// The deadtime insertion in this pair of channels is disabled.
	FTM_COMBINE_DTEN0_0 = 0x0
	// The deadtime insertion in this pair of channels is enabled.
	FTM_COMBINE_DTEN0_1 = 0x1
	// Position of SYNCEN0 field.
	FTM_COMBINE_SYNCEN0_Pos = 0x5
	// Bit mask of SYNCEN0 field.
	FTM_COMBINE_SYNCEN0_Msk = 0x20
	// Bit SYNCEN0.
	FTM_COMBINE_SYNCEN0 = 0x20
	// The PWM synchronization in this pair of channels is disabled.
	FTM_COMBINE_SYNCEN0_0 = 0x0
	// The PWM synchronization in this pair of channels is enabled.
	FTM_COMBINE_SYNCEN0_1 = 0x1
	// Position of FAULTEN0 field.
	FTM_COMBINE_FAULTEN0_Pos = 0x6
	// Bit mask of FAULTEN0 field.
	FTM_COMBINE_FAULTEN0_Msk = 0x40
	// Bit FAULTEN0.
	FTM_COMBINE_FAULTEN0 = 0x40
	// The fault control in this pair of channels is disabled.
	FTM_COMBINE_FAULTEN0_0 = 0x0
	// The fault control in this pair of channels is enabled.
	FTM_COMBINE_FAULTEN0_1 = 0x1
	// Position of COMBINE1 field.
	FTM_COMBINE_COMBINE1_Pos = 0x8
	// Bit mask of COMBINE1 field.
	FTM_COMBINE_COMBINE1_Msk = 0x100
	// Bit COMBINE1.
	FTM_COMBINE_COMBINE1 = 0x100
	// Channels (n) and (n+1) are independent.
	FTM_COMBINE_COMBINE1_0 = 0x0
	// Channels (n) and (n+1) are combined.
	FTM_COMBINE_COMBINE1_1 = 0x1
	// Position of COMP1 field.
	FTM_COMBINE_COMP1_Pos = 0x9
	// Bit mask of COMP1 field.
	FTM_COMBINE_COMP1_Msk = 0x200
	// Bit COMP1.
	FTM_COMBINE_COMP1 = 0x200
	// The channel (n+1) output is the same as the channel (n) output.
	FTM_COMBINE_COMP1_0 = 0x0
	// The channel (n+1) output is the complement of the channel (n) output.
	FTM_COMBINE_COMP1_1 = 0x1
	// Position of DECAPEN1 field.
	FTM_COMBINE_DECAPEN1_Pos = 0xa
	// Bit mask of DECAPEN1 field.
	FTM_COMBINE_DECAPEN1_Msk = 0x400
	// Bit DECAPEN1.
	FTM_COMBINE_DECAPEN1 = 0x400
	// The Dual Edge Capture mode in this pair of channels is disabled.
	FTM_COMBINE_DECAPEN1_0 = 0x0
	// The Dual Edge Capture mode in this pair of channels is enabled.
	FTM_COMBINE_DECAPEN1_1 = 0x1
	// Position of DECAP1 field.
	FTM_COMBINE_DECAP1_Pos = 0xb
	// Bit mask of DECAP1 field.
	FTM_COMBINE_DECAP1_Msk = 0x800
	// Bit DECAP1.
	FTM_COMBINE_DECAP1 = 0x800
	// The dual edge captures are inactive.
	FTM_COMBINE_DECAP1_0 = 0x0
	// The dual edge captures are active.
	FTM_COMBINE_DECAP1_1 = 0x1
	// Position of DTEN1 field.
	FTM_COMBINE_DTEN1_Pos = 0xc
	// Bit mask of DTEN1 field.
	FTM_COMBINE_DTEN1_Msk = 0x1000
	// Bit DTEN1.
	FTM_COMBINE_DTEN1 = 0x1000
	// The deadtime insertion in this pair of channels is disabled.
	FTM_COMBINE_DTEN1_0 = 0x0
	// The deadtime insertion in this pair of channels is enabled.
	FTM_COMBINE_DTEN1_1 = 0x1
	// Position of SYNCEN1 field.
	FTM_COMBINE_SYNCEN1_Pos = 0xd
	// Bit mask of SYNCEN1 field.
	FTM_COMBINE_SYNCEN1_Msk = 0x2000
	// Bit SYNCEN1.
	FTM_COMBINE_SYNCEN1 = 0x2000
	// The PWM synchronization in this pair of channels is disabled.
	FTM_COMBINE_SYNCEN1_0 = 0x0
	// The PWM synchronization in this pair of channels is enabled.
	FTM_COMBINE_SYNCEN1_1 = 0x1
	// Position of FAULTEN1 field.
	FTM_COMBINE_FAULTEN1_Pos = 0xe
	// Bit mask of FAULTEN1 field.
	FTM_COMBINE_FAULTEN1_Msk = 0x4000
	// Bit FAULTEN1.
	FTM_COMBINE_FAULTEN1 = 0x4000
	// The fault control in this pair of channels is disabled.
	FTM_COMBINE_FAULTEN1_0 = 0x0
	// The fault control in this pair of channels is enabled.
	FTM_COMBINE_FAULTEN1_1 = 0x1
	// Position of COMBINE2 field.
	FTM_COMBINE_COMBINE2_Pos = 0x10
	// Bit mask of COMBINE2 field.
	FTM_COMBINE_COMBINE2_Msk = 0x10000
	// Bit COMBINE2.
	FTM_COMBINE_COMBINE2 = 0x10000
	// Channels (n) and (n+1) are independent.
	FTM_COMBINE_COMBINE2_0 = 0x0
	// Channels (n) and (n+1) are combined.
	FTM_COMBINE_COMBINE2_1 = 0x1
	// Position of COMP2 field.
	FTM_COMBINE_COMP2_Pos = 0x11
	// Bit mask of COMP2 field.
	FTM_COMBINE_COMP2_Msk = 0x20000
	// Bit COMP2.
	FTM_COMBINE_COMP2 = 0x20000
	// The channel (n+1) output is the same as the channel (n) output.
	FTM_COMBINE_COMP2_0 = 0x0
	// The channel (n+1) output is the complement of the channel (n) output.
	FTM_COMBINE_COMP2_1 = 0x1
	// Position of DECAPEN2 field.
	FTM_COMBINE_DECAPEN2_Pos = 0x12
	// Bit mask of DECAPEN2 field.
	FTM_COMBINE_DECAPEN2_Msk = 0x40000
	// Bit DECAPEN2.
	FTM_COMBINE_DECAPEN2 = 0x40000
	// The Dual Edge Capture mode in this pair of channels is disabled.
	FTM_COMBINE_DECAPEN2_0 = 0x0
	// The Dual Edge Capture mode in this pair of channels is enabled.
	FTM_COMBINE_DECAPEN2_1 = 0x1
	// Position of DECAP2 field.
	FTM_COMBINE_DECAP2_Pos = 0x13
	// Bit mask of DECAP2 field.
	FTM_COMBINE_DECAP2_Msk = 0x80000
	// Bit DECAP2.
	FTM_COMBINE_DECAP2 = 0x80000
	// The dual edge captures are inactive.
	FTM_COMBINE_DECAP2_0 = 0x0
	// The dual edge captures are active.
	FTM_COMBINE_DECAP2_1 = 0x1
	// Position of DTEN2 field.
	FTM_COMBINE_DTEN2_Pos = 0x14
	// Bit mask of DTEN2 field.
	FTM_COMBINE_DTEN2_Msk = 0x100000
	// Bit DTEN2.
	FTM_COMBINE_DTEN2 = 0x100000
	// The deadtime insertion in this pair of channels is disabled.
	FTM_COMBINE_DTEN2_0 = 0x0
	// The deadtime insertion in this pair of channels is enabled.
	FTM_COMBINE_DTEN2_1 = 0x1
	// Position of SYNCEN2 field.
	FTM_COMBINE_SYNCEN2_Pos = 0x15
	// Bit mask of SYNCEN2 field.
	FTM_COMBINE_SYNCEN2_Msk = 0x200000
	// Bit SYNCEN2.
	FTM_COMBINE_SYNCEN2 = 0x200000
	// The PWM synchronization in this pair of channels is disabled.
	FTM_COMBINE_SYNCEN2_0 = 0x0
	// The PWM synchronization in this pair of channels is enabled.
	FTM_COMBINE_SYNCEN2_1 = 0x1
	// Position of FAULTEN2 field.
	FTM_COMBINE_FAULTEN2_Pos = 0x16
	// Bit mask of FAULTEN2 field.
	FTM_COMBINE_FAULTEN2_Msk = 0x400000
	// Bit FAULTEN2.
	FTM_COMBINE_FAULTEN2 = 0x400000
	// The fault control in this pair of channels is disabled.
	FTM_COMBINE_FAULTEN2_0 = 0x0
	// The fault control in this pair of channels is enabled.
	FTM_COMBINE_FAULTEN2_1 = 0x1
	// Position of COMBINE3 field.
	FTM_COMBINE_COMBINE3_Pos = 0x18
	// Bit mask of COMBINE3 field.
	FTM_COMBINE_COMBINE3_Msk = 0x1000000
	// Bit COMBINE3.
	FTM_COMBINE_COMBINE3 = 0x1000000
	// Channels (n) and (n+1) are independent.
	FTM_COMBINE_COMBINE3_0 = 0x0
	// Channels (n) and (n+1) are combined.
	FTM_COMBINE_COMBINE3_1 = 0x1
	// Position of COMP3 field.
	FTM_COMBINE_COMP3_Pos = 0x19
	// Bit mask of COMP3 field.
	FTM_COMBINE_COMP3_Msk = 0x2000000
	// Bit COMP3.
	FTM_COMBINE_COMP3 = 0x2000000
	// The channel (n+1) output is the same as the channel (n) output.
	FTM_COMBINE_COMP3_0 = 0x0
	// The channel (n+1) output is the complement of the channel (n) output.
	FTM_COMBINE_COMP3_1 = 0x1
	// Position of DECAPEN3 field.
	FTM_COMBINE_DECAPEN3_Pos = 0x1a
	// Bit mask of DECAPEN3 field.
	FTM_COMBINE_DECAPEN3_Msk = 0x4000000
	// Bit DECAPEN3.
	FTM_COMBINE_DECAPEN3 = 0x4000000
	// The Dual Edge Capture mode in this pair of channels is disabled.
	FTM_COMBINE_DECAPEN3_0 = 0x0
	// The Dual Edge Capture mode in this pair of channels is enabled.
	FTM_COMBINE_DECAPEN3_1 = 0x1
	// Position of DECAP3 field.
	FTM_COMBINE_DECAP3_Pos = 0x1b
	// Bit mask of DECAP3 field.
	FTM_COMBINE_DECAP3_Msk = 0x8000000
	// Bit DECAP3.
	FTM_COMBINE_DECAP3 = 0x8000000
	// The dual edge captures are inactive.
	FTM_COMBINE_DECAP3_0 = 0x0
	// The dual edge captures are active.
	FTM_COMBINE_DECAP3_1 = 0x1
	// Position of DTEN3 field.
	FTM_COMBINE_DTEN3_Pos = 0x1c
	// Bit mask of DTEN3 field.
	FTM_COMBINE_DTEN3_Msk = 0x10000000
	// Bit DTEN3.
	FTM_COMBINE_DTEN3 = 0x10000000
	// The deadtime insertion in this pair of channels is disabled.
	FTM_COMBINE_DTEN3_0 = 0x0
	// The deadtime insertion in this pair of channels is enabled.
	FTM_COMBINE_DTEN3_1 = 0x1
	// Position of SYNCEN3 field.
	FTM_COMBINE_SYNCEN3_Pos = 0x1d
	// Bit mask of SYNCEN3 field.
	FTM_COMBINE_SYNCEN3_Msk = 0x20000000
	// Bit SYNCEN3.
	FTM_COMBINE_SYNCEN3 = 0x20000000
	// The PWM synchronization in this pair of channels is disabled.
	FTM_COMBINE_SYNCEN3_0 = 0x0
	// The PWM synchronization in this pair of channels is enabled.
	FTM_COMBINE_SYNCEN3_1 = 0x1
	// Position of FAULTEN3 field.
	FTM_COMBINE_FAULTEN3_Pos = 0x1e
	// Bit mask of FAULTEN3 field.
	FTM_COMBINE_FAULTEN3_Msk = 0x40000000
	// Bit FAULTEN3.
	FTM_COMBINE_FAULTEN3 = 0x40000000
	// The fault control in this pair of channels is disabled.
	FTM_COMBINE_FAULTEN3_0 = 0x0
	// The fault control in this pair of channels is enabled.
	FTM_COMBINE_FAULTEN3_1 = 0x1

	// DEADTIME: Deadtime Insertion Control
	// Position of DTVAL field.
	FTM_DEADTIME_DTVAL_Pos = 0x0
	// Bit mask of DTVAL field.
	FTM_DEADTIME_DTVAL_Msk = 0x3f
	// Position of DTPS field.
	FTM_DEADTIME_DTPS_Pos = 0x6
	// Bit mask of DTPS field.
	FTM_DEADTIME_DTPS_Msk = 0xc0
	// Divide the system clock by 4.
	FTM_DEADTIME_DTPS_10 = 0x2
	// Divide the system clock by 16.
	FTM_DEADTIME_DTPS_11 = 0x3

	// EXTTRIG: FTM External Trigger
	// Position of CH2TRIG field.
	FTM_EXTTRIG_CH2TRIG_Pos = 0x0
	// Bit mask of CH2TRIG field.
	FTM_EXTTRIG_CH2TRIG_Msk = 0x1
	// Bit CH2TRIG.
	FTM_EXTTRIG_CH2TRIG = 0x1
	// The generation of the channel trigger is disabled.
	FTM_EXTTRIG_CH2TRIG_0 = 0x0
	// The generation of the channel trigger is enabled.
	FTM_EXTTRIG_CH2TRIG_1 = 0x1
	// Position of CH3TRIG field.
	FTM_EXTTRIG_CH3TRIG_Pos = 0x1
	// Bit mask of CH3TRIG field.
	FTM_EXTTRIG_CH3TRIG_Msk = 0x2
	// Bit CH3TRIG.
	FTM_EXTTRIG_CH3TRIG = 0x2
	// The generation of the channel trigger is disabled.
	FTM_EXTTRIG_CH3TRIG_0 = 0x0
	// The generation of the channel trigger is enabled.
	FTM_EXTTRIG_CH3TRIG_1 = 0x1
	// Position of CH4TRIG field.
	FTM_EXTTRIG_CH4TRIG_Pos = 0x2
	// Bit mask of CH4TRIG field.
	FTM_EXTTRIG_CH4TRIG_Msk = 0x4
	// Bit CH4TRIG.
	FTM_EXTTRIG_CH4TRIG = 0x4
	// The generation of the channel trigger is disabled.
	FTM_EXTTRIG_CH4TRIG_0 = 0x0
	// The generation of the channel trigger is enabled.
	FTM_EXTTRIG_CH4TRIG_1 = 0x1
	// Position of CH5TRIG field.
	FTM_EXTTRIG_CH5TRIG_Pos = 0x3
	// Bit mask of CH5TRIG field.
	FTM_EXTTRIG_CH5TRIG_Msk = 0x8
	// Bit CH5TRIG.
	FTM_EXTTRIG_CH5TRIG = 0x8
	// The generation of the channel trigger is disabled.
	FTM_EXTTRIG_CH5TRIG_0 = 0x0
	// The generation of the channel trigger is enabled.
	FTM_EXTTRIG_CH5TRIG_1 = 0x1
	// Position of CH0TRIG field.
	FTM_EXTTRIG_CH0TRIG_Pos = 0x4
	// Bit mask of CH0TRIG field.
	FTM_EXTTRIG_CH0TRIG_Msk = 0x10
	// Bit CH0TRIG.
	FTM_EXTTRIG_CH0TRIG = 0x10
	// The generation of the channel trigger is disabled.
	FTM_EXTTRIG_CH0TRIG_0 = 0x0
	// The generation of the channel trigger is enabled.
	FTM_EXTTRIG_CH0TRIG_1 = 0x1
	// Position of CH1TRIG field.
	FTM_EXTTRIG_CH1TRIG_Pos = 0x5
	// Bit mask of CH1TRIG field.
	FTM_EXTTRIG_CH1TRIG_Msk = 0x20
	// Bit CH1TRIG.
	FTM_EXTTRIG_CH1TRIG = 0x20
	// The generation of the channel trigger is disabled.
	FTM_EXTTRIG_CH1TRIG_0 = 0x0
	// The generation of the channel trigger is enabled.
	FTM_EXTTRIG_CH1TRIG_1 = 0x1
	// Position of INITTRIGEN field.
	FTM_EXTTRIG_INITTRIGEN_Pos = 0x6
	// Bit mask of INITTRIGEN field.
	FTM_EXTTRIG_INITTRIGEN_Msk = 0x40
	// Bit INITTRIGEN.
	FTM_EXTTRIG_INITTRIGEN = 0x40
	// The generation of initialization trigger is disabled.
	FTM_EXTTRIG_INITTRIGEN_0 = 0x0
	// The generation of initialization trigger is enabled.
	FTM_EXTTRIG_INITTRIGEN_1 = 0x1
	// Position of TRIGF field.
	FTM_EXTTRIG_TRIGF_Pos = 0x7
	// Bit mask of TRIGF field.
	FTM_EXTTRIG_TRIGF_Msk = 0x80
	// Bit TRIGF.
	FTM_EXTTRIG_TRIGF = 0x80
	// No channel trigger was generated.
	FTM_EXTTRIG_TRIGF_0 = 0x0
	// A channel trigger was generated.
	FTM_EXTTRIG_TRIGF_1 = 0x1

	// POL: Channels Polarity
	// Position of POL0 field.
	FTM_POL_POL0_Pos = 0x0
	// Bit mask of POL0 field.
	FTM_POL_POL0_Msk = 0x1
	// Bit POL0.
	FTM_POL_POL0 = 0x1
	// The channel polarity is active high.
	FTM_POL_POL0_0 = 0x0
	// The channel polarity is active low.
	FTM_POL_POL0_1 = 0x1
	// Position of POL1 field.
	FTM_POL_POL1_Pos = 0x1
	// Bit mask of POL1 field.
	FTM_POL_POL1_Msk = 0x2
	// Bit POL1.
	FTM_POL_POL1 = 0x2
	// The channel polarity is active high.
	FTM_POL_POL1_0 = 0x0
	// The channel polarity is active low.
	FTM_POL_POL1_1 = 0x1
	// Position of POL2 field.
	FTM_POL_POL2_Pos = 0x2
	// Bit mask of POL2 field.
	FTM_POL_POL2_Msk = 0x4
	// Bit POL2.
	FTM_POL_POL2 = 0x4
	// The channel polarity is active high.
	FTM_POL_POL2_0 = 0x0
	// The channel polarity is active low.
	FTM_POL_POL2_1 = 0x1
	// Position of POL3 field.
	FTM_POL_POL3_Pos = 0x3
	// Bit mask of POL3 field.
	FTM_POL_POL3_Msk = 0x8
	// Bit POL3.
	FTM_POL_POL3 = 0x8
	// The channel polarity is active high.
	FTM_POL_POL3_0 = 0x0
	// The channel polarity is active low.
	FTM_POL_POL3_1 = 0x1
	// Position of POL4 field.
	FTM_POL_POL4_Pos = 0x4
	// Bit mask of POL4 field.
	FTM_POL_POL4_Msk = 0x10
	// Bit POL4.
	FTM_POL_POL4 = 0x10
	// The channel polarity is active high.
	FTM_POL_POL4_0 = 0x0
	// The channel polarity is active low.
	FTM_POL_POL4_1 = 0x1
	// Position of POL5 field.
	FTM_POL_POL5_Pos = 0x5
	// Bit mask of POL5 field.
	FTM_POL_POL5_Msk = 0x20
	// Bit POL5.
	FTM_POL_POL5 = 0x20
	// The channel polarity is active high.
	FTM_POL_POL5_0 = 0x0
	// The channel polarity is active low.
	FTM_POL_POL5_1 = 0x1
	// Position of POL6 field.
	FTM_POL_POL6_Pos = 0x6
	// Bit mask of POL6 field.
	FTM_POL_POL6_Msk = 0x40
	// Bit POL6.
	FTM_POL_POL6 = 0x40
	// The channel polarity is active high.
	FTM_POL_POL6_0 = 0x0
	// The channel polarity is active low.
	FTM_POL_POL6_1 = 0x1
	// Position of POL7 field.
	FTM_POL_POL7_Pos = 0x7
	// Bit mask of POL7 field.
	FTM_POL_POL7_Msk = 0x80
	// Bit POL7.
	FTM_POL_POL7 = 0x80
	// The channel polarity is active high.
	FTM_POL_POL7_0 = 0x0
	// The channel polarity is active low.
	FTM_POL_POL7_1 = 0x1

	// FMS: Fault Mode Status
	// Position of FAULTF0 field.
	FTM_FMS_FAULTF0_Pos = 0x0
	// Bit mask of FAULTF0 field.
	FTM_FMS_FAULTF0_Msk = 0x1
	// Bit FAULTF0.
	FTM_FMS_FAULTF0 = 0x1
	// No fault condition was detected at the fault input.
	FTM_FMS_FAULTF0_0 = 0x0
	// A fault condition was detected at the fault input.
	FTM_FMS_FAULTF0_1 = 0x1
	// Position of FAULTF1 field.
	FTM_FMS_FAULTF1_Pos = 0x1
	// Bit mask of FAULTF1 field.
	FTM_FMS_FAULTF1_Msk = 0x2
	// Bit FAULTF1.
	FTM_FMS_FAULTF1 = 0x2
	// No fault condition was detected at the fault input.
	FTM_FMS_FAULTF1_0 = 0x0
	// A fault condition was detected at the fault input.
	FTM_FMS_FAULTF1_1 = 0x1
	// Position of FAULTF2 field.
	FTM_FMS_FAULTF2_Pos = 0x2
	// Bit mask of FAULTF2 field.
	FTM_FMS_FAULTF2_Msk = 0x4
	// Bit FAULTF2.
	FTM_FMS_FAULTF2 = 0x4
	// No fault condition was detected at the fault input.
	FTM_FMS_FAULTF2_0 = 0x0
	// A fault condition was detected at the fault input.
	FTM_FMS_FAULTF2_1 = 0x1
	// Position of FAULTF3 field.
	FTM_FMS_FAULTF3_Pos = 0x3
	// Bit mask of FAULTF3 field.
	FTM_FMS_FAULTF3_Msk = 0x8
	// Bit FAULTF3.
	FTM_FMS_FAULTF3 = 0x8
	// No fault condition was detected at the fault input.
	FTM_FMS_FAULTF3_0 = 0x0
	// A fault condition was detected at the fault input.
	FTM_FMS_FAULTF3_1 = 0x1
	// Position of FAULTIN field.
	FTM_FMS_FAULTIN_Pos = 0x5
	// Bit mask of FAULTIN field.
	FTM_FMS_FAULTIN_Msk = 0x20
	// Bit FAULTIN.
	FTM_FMS_FAULTIN = 0x20
	// The logic OR of the enabled fault inputs is 0.
	FTM_FMS_FAULTIN_0 = 0x0
	// The logic OR of the enabled fault inputs is 1.
	FTM_FMS_FAULTIN_1 = 0x1
	// Position of WPEN field.
	FTM_FMS_WPEN_Pos = 0x6
	// Bit mask of WPEN field.
	FTM_FMS_WPEN_Msk = 0x40
	// Bit WPEN.
	FTM_FMS_WPEN = 0x40
	// Write protection is disabled. Write protected bits can be written.
	FTM_FMS_WPEN_0 = 0x0
	// Write protection is enabled. Write protected bits cannot be written.
	FTM_FMS_WPEN_1 = 0x1
	// Position of FAULTF field.
	FTM_FMS_FAULTF_Pos = 0x7
	// Bit mask of FAULTF field.
	FTM_FMS_FAULTF_Msk = 0x80
	// Bit FAULTF.
	FTM_FMS_FAULTF = 0x80
	// No fault condition was detected.
	FTM_FMS_FAULTF_0 = 0x0
	// A fault condition was detected.
	FTM_FMS_FAULTF_1 = 0x1

	// FILTER: Input Capture Filter Control
	// Position of CH0FVAL field.
	FTM_FILTER_CH0FVAL_Pos = 0x0
	// Bit mask of CH0FVAL field.
	FTM_FILTER_CH0FVAL_Msk = 0xf
	// Position of CH1FVAL field.
	FTM_FILTER_CH1FVAL_Pos = 0x4
	// Bit mask of CH1FVAL field.
	FTM_FILTER_CH1FVAL_Msk = 0xf0
	// Position of CH2FVAL field.
	FTM_FILTER_CH2FVAL_Pos = 0x8
	// Bit mask of CH2FVAL field.
	FTM_FILTER_CH2FVAL_Msk = 0xf00
	// Position of CH3FVAL field.
	FTM_FILTER_CH3FVAL_Pos = 0xc
	// Bit mask of CH3FVAL field.
	FTM_FILTER_CH3FVAL_Msk = 0xf000

	// FLTCTRL: Fault Control
	// Position of FAULT0EN field.
	FTM_FLTCTRL_FAULT0EN_Pos = 0x0
	// Bit mask of FAULT0EN field.
	FTM_FLTCTRL_FAULT0EN_Msk = 0x1
	// Bit FAULT0EN.
	FTM_FLTCTRL_FAULT0EN = 0x1
	// Fault input is disabled.
	FTM_FLTCTRL_FAULT0EN_0 = 0x0
	// Fault input is enabled.
	FTM_FLTCTRL_FAULT0EN_1 = 0x1
	// Position of FAULT1EN field.
	FTM_FLTCTRL_FAULT1EN_Pos = 0x1
	// Bit mask of FAULT1EN field.
	FTM_FLTCTRL_FAULT1EN_Msk = 0x2
	// Bit FAULT1EN.
	FTM_FLTCTRL_FAULT1EN = 0x2
	// Fault input is disabled.
	FTM_FLTCTRL_FAULT1EN_0 = 0x0
	// Fault input is enabled.
	FTM_FLTCTRL_FAULT1EN_1 = 0x1
	// Position of FAULT2EN field.
	FTM_FLTCTRL_FAULT2EN_Pos = 0x2
	// Bit mask of FAULT2EN field.
	FTM_FLTCTRL_FAULT2EN_Msk = 0x4
	// Bit FAULT2EN.
	FTM_FLTCTRL_FAULT2EN = 0x4
	// Fault input is disabled.
	FTM_FLTCTRL_FAULT2EN_0 = 0x0
	// Fault input is enabled.
	FTM_FLTCTRL_FAULT2EN_1 = 0x1
	// Position of FAULT3EN field.
	FTM_FLTCTRL_FAULT3EN_Pos = 0x3
	// Bit mask of FAULT3EN field.
	FTM_FLTCTRL_FAULT3EN_Msk = 0x8
	// Bit FAULT3EN.
	FTM_FLTCTRL_FAULT3EN = 0x8
	// Fault input is disabled.
	FTM_FLTCTRL_FAULT3EN_0 = 0x0
	// Fault input is enabled.
	FTM_FLTCTRL_FAULT3EN_1 = 0x1
	// Position of FFLTR0EN field.
	FTM_FLTCTRL_FFLTR0EN_Pos = 0x4
	// Bit mask of FFLTR0EN field.
	FTM_FLTCTRL_FFLTR0EN_Msk = 0x10
	// Bit FFLTR0EN.
	FTM_FLTCTRL_FFLTR0EN = 0x10
	// Fault input filter is disabled.
	FTM_FLTCTRL_FFLTR0EN_0 = 0x0
	// Fault input filter is enabled.
	FTM_FLTCTRL_FFLTR0EN_1 = 0x1
	// Position of FFLTR1EN field.
	FTM_FLTCTRL_FFLTR1EN_Pos = 0x5
	// Bit mask of FFLTR1EN field.
	FTM_FLTCTRL_FFLTR1EN_Msk = 0x20
	// Bit FFLTR1EN.
	FTM_FLTCTRL_FFLTR1EN = 0x20
	// Fault input filter is disabled.
	FTM_FLTCTRL_FFLTR1EN_0 = 0x0
	// Fault input filter is enabled.
	FTM_FLTCTRL_FFLTR1EN_1 = 0x1
	// Position of FFLTR2EN field.
	FTM_FLTCTRL_FFLTR2EN_Pos = 0x6
	// Bit mask of FFLTR2EN field.
	FTM_FLTCTRL_FFLTR2EN_Msk = 0x40
	// Bit FFLTR2EN.
	FTM_FLTCTRL_FFLTR2EN = 0x40
	// Fault input filter is disabled.
	FTM_FLTCTRL_FFLTR2EN_0 = 0x0
	// Fault input filter is enabled.
	FTM_FLTCTRL_FFLTR2EN_1 = 0x1
	// Position of FFLTR3EN field.
	FTM_FLTCTRL_FFLTR3EN_Pos = 0x7
	// Bit mask of FFLTR3EN field.
	FTM_FLTCTRL_FFLTR3EN_Msk = 0x80
	// Bit FFLTR3EN.
	FTM_FLTCTRL_FFLTR3EN = 0x80
	// Fault input filter is disabled.
	FTM_FLTCTRL_FFLTR3EN_0 = 0x0
	// Fault input filter is enabled.
	FTM_FLTCTRL_FFLTR3EN_1 = 0x1
	// Position of FFVAL field.
	FTM_FLTCTRL_FFVAL_Pos = 0x8
	// Bit mask of FFVAL field.
	FTM_FLTCTRL_FFVAL_Msk = 0xf00

	// QDCTRL: Quadrature Decoder Control And Status
	// Position of QUADEN field.
	FTM_QDCTRL_QUADEN_Pos = 0x0
	// Bit mask of QUADEN field.
	FTM_QDCTRL_QUADEN_Msk = 0x1
	// Bit QUADEN.
	FTM_QDCTRL_QUADEN = 0x1
	// Quadrature Decoder mode is disabled.
	FTM_QDCTRL_QUADEN_0 = 0x0
	// Quadrature Decoder mode is enabled.
	FTM_QDCTRL_QUADEN_1 = 0x1
	// Position of TOFDIR field.
	FTM_QDCTRL_TOFDIR_Pos = 0x1
	// Bit mask of TOFDIR field.
	FTM_QDCTRL_TOFDIR_Msk = 0x2
	// Bit TOFDIR.
	FTM_QDCTRL_TOFDIR = 0x2
	// TOF bit was set on the bottom of counting. There was an FTM counter decrement and FTM counter changes from its minimum value (CNTIN register) to its maximum value (MOD register).
	FTM_QDCTRL_TOFDIR_0 = 0x0
	// TOF bit was set on the top of counting. There was an FTM counter increment and FTM counter changes from its maximum value (MOD register) to its minimum value (CNTIN register).
	FTM_QDCTRL_TOFDIR_1 = 0x1
	// Position of QUADIR field.
	FTM_QDCTRL_QUADIR_Pos = 0x2
	// Bit mask of QUADIR field.
	FTM_QDCTRL_QUADIR_Msk = 0x4
	// Bit QUADIR.
	FTM_QDCTRL_QUADIR = 0x4
	// Counting direction is decreasing (FTM counter decrement).
	FTM_QDCTRL_QUADIR_0 = 0x0
	// Counting direction is increasing (FTM counter increment).
	FTM_QDCTRL_QUADIR_1 = 0x1
	// Position of QUADMODE field.
	FTM_QDCTRL_QUADMODE_Pos = 0x3
	// Bit mask of QUADMODE field.
	FTM_QDCTRL_QUADMODE_Msk = 0x8
	// Bit QUADMODE.
	FTM_QDCTRL_QUADMODE = 0x8
	// Phase A and phase B encoding mode.
	FTM_QDCTRL_QUADMODE_0 = 0x0
	// Count and direction encoding mode.
	FTM_QDCTRL_QUADMODE_1 = 0x1
	// Position of PHBPOL field.
	FTM_QDCTRL_PHBPOL_Pos = 0x4
	// Bit mask of PHBPOL field.
	FTM_QDCTRL_PHBPOL_Msk = 0x10
	// Bit PHBPOL.
	FTM_QDCTRL_PHBPOL = 0x10
	// Normal polarity. Phase B input signal is not inverted before identifying the rising and falling edges of this signal.
	FTM_QDCTRL_PHBPOL_0 = 0x0
	// Inverted polarity. Phase B input signal is inverted before identifying the rising and falling edges of this signal.
	FTM_QDCTRL_PHBPOL_1 = 0x1
	// Position of PHAPOL field.
	FTM_QDCTRL_PHAPOL_Pos = 0x5
	// Bit mask of PHAPOL field.
	FTM_QDCTRL_PHAPOL_Msk = 0x20
	// Bit PHAPOL.
	FTM_QDCTRL_PHAPOL = 0x20
	// Normal polarity. Phase A input signal is not inverted before identifying the rising and falling edges of this signal.
	FTM_QDCTRL_PHAPOL_0 = 0x0
	// Inverted polarity. Phase A input signal is inverted before identifying the rising and falling edges of this signal.
	FTM_QDCTRL_PHAPOL_1 = 0x1
	// Position of PHBFLTREN field.
	FTM_QDCTRL_PHBFLTREN_Pos = 0x6
	// Bit mask of PHBFLTREN field.
	FTM_QDCTRL_PHBFLTREN_Msk = 0x40
	// Bit PHBFLTREN.
	FTM_QDCTRL_PHBFLTREN = 0x40
	// Phase B input filter is disabled.
	FTM_QDCTRL_PHBFLTREN_0 = 0x0
	// Phase B input filter is enabled.
	FTM_QDCTRL_PHBFLTREN_1 = 0x1
	// Position of PHAFLTREN field.
	FTM_QDCTRL_PHAFLTREN_Pos = 0x7
	// Bit mask of PHAFLTREN field.
	FTM_QDCTRL_PHAFLTREN_Msk = 0x80
	// Bit PHAFLTREN.
	FTM_QDCTRL_PHAFLTREN = 0x80
	// Phase A input filter is disabled.
	FTM_QDCTRL_PHAFLTREN_0 = 0x0
	// Phase A input filter is enabled.
	FTM_QDCTRL_PHAFLTREN_1 = 0x1

	// CONF: Configuration
	// Position of NUMTOF field.
	FTM_CONF_NUMTOF_Pos = 0x0
	// Bit mask of NUMTOF field.
	FTM_CONF_NUMTOF_Msk = 0x1f
	// Position of BDMMODE field.
	FTM_CONF_BDMMODE_Pos = 0x6
	// Bit mask of BDMMODE field.
	FTM_CONF_BDMMODE_Msk = 0xc0
	// Position of GTBEEN field.
	FTM_CONF_GTBEEN_Pos = 0x9
	// Bit mask of GTBEEN field.
	FTM_CONF_GTBEEN_Msk = 0x200
	// Bit GTBEEN.
	FTM_CONF_GTBEEN = 0x200
	// Use of an external global time base is disabled.
	FTM_CONF_GTBEEN_0 = 0x0
	// Use of an external global time base is enabled.
	FTM_CONF_GTBEEN_1 = 0x1
	// Position of GTBEOUT field.
	FTM_CONF_GTBEOUT_Pos = 0xa
	// Bit mask of GTBEOUT field.
	FTM_CONF_GTBEOUT_Msk = 0x400
	// Bit GTBEOUT.
	FTM_CONF_GTBEOUT = 0x400
	// A global time base signal generation is disabled.
	FTM_CONF_GTBEOUT_0 = 0x0
	// A global time base signal generation is enabled.
	FTM_CONF_GTBEOUT_1 = 0x1

	// FLTPOL: FTM Fault Input Polarity
	// Position of FLT0POL field.
	FTM_FLTPOL_FLT0POL_Pos = 0x0
	// Bit mask of FLT0POL field.
	FTM_FLTPOL_FLT0POL_Msk = 0x1
	// Bit FLT0POL.
	FTM_FLTPOL_FLT0POL = 0x1
	// The fault input polarity is active high. A 1 at the fault input indicates a fault.
	FTM_FLTPOL_FLT0POL_0 = 0x0
	// The fault input polarity is active low. A 0 at the fault input indicates a fault.
	FTM_FLTPOL_FLT0POL_1 = 0x1
	// Position of FLT1POL field.
	FTM_FLTPOL_FLT1POL_Pos = 0x1
	// Bit mask of FLT1POL field.
	FTM_FLTPOL_FLT1POL_Msk = 0x2
	// Bit FLT1POL.
	FTM_FLTPOL_FLT1POL = 0x2
	// The fault input polarity is active high. A 1 at the fault input indicates a fault.
	FTM_FLTPOL_FLT1POL_0 = 0x0
	// The fault input polarity is active low. A 0 at the fault input indicates a fault.
	FTM_FLTPOL_FLT1POL_1 = 0x1
	// Position of FLT2POL field.
	FTM_FLTPOL_FLT2POL_Pos = 0x2
	// Bit mask of FLT2POL field.
	FTM_FLTPOL_FLT2POL_Msk = 0x4
	// Bit FLT2POL.
	FTM_FLTPOL_FLT2POL = 0x4
	// The fault input polarity is active high. A 1 at the fault input indicates a fault.
	FTM_FLTPOL_FLT2POL_0 = 0x0
	// The fault input polarity is active low. A 0 at the fault input indicates a fault.
	FTM_FLTPOL_FLT2POL_1 = 0x1
	// Position of FLT3POL field.
	FTM_FLTPOL_FLT3POL_Pos = 0x3
	// Bit mask of FLT3POL field.
	FTM_FLTPOL_FLT3POL_Msk = 0x8
	// Bit FLT3POL.
	FTM_FLTPOL_FLT3POL = 0x8
	// The fault input polarity is active high. A 1 at the fault input indicates a fault.
	FTM_FLTPOL_FLT3POL_0 = 0x0
	// The fault input polarity is active low. A 0 at the fault input indicates a fault.
	FTM_FLTPOL_FLT3POL_1 = 0x1

	// SYNCONF: Synchronization Configuration
	// Position of HWTRIGMODE field.
	FTM_SYNCONF_HWTRIGMODE_Pos = 0x0
	// Bit mask of HWTRIGMODE field.
	FTM_SYNCONF_HWTRIGMODE_Msk = 0x1
	// Bit HWTRIGMODE.
	FTM_SYNCONF_HWTRIGMODE = 0x1
	// FTM clears the TRIGj bit when the hardware trigger j is detected, where j = 0, 1,2.
	FTM_SYNCONF_HWTRIGMODE_0 = 0x0
	// FTM does not clear the TRIGj bit when the hardware trigger j is detected, where j = 0, 1,2.
	FTM_SYNCONF_HWTRIGMODE_1 = 0x1
	// Position of CNTINC field.
	FTM_SYNCONF_CNTINC_Pos = 0x2
	// Bit mask of CNTINC field.
	FTM_SYNCONF_CNTINC_Msk = 0x4
	// Bit CNTINC.
	FTM_SYNCONF_CNTINC = 0x4
	// CNTIN register is updated with its buffer value at all rising edges of system clock.
	FTM_SYNCONF_CNTINC_0 = 0x0
	// CNTIN register is updated with its buffer value by the PWM synchronization.
	FTM_SYNCONF_CNTINC_1 = 0x1
	// Position of INVC field.
	FTM_SYNCONF_INVC_Pos = 0x4
	// Bit mask of INVC field.
	FTM_SYNCONF_INVC_Msk = 0x10
	// Bit INVC.
	FTM_SYNCONF_INVC = 0x10
	// INVCTRL register is updated with its buffer value at all rising edges of system clock.
	FTM_SYNCONF_INVC_0 = 0x0
	// INVCTRL register is updated with its buffer value by the PWM synchronization.
	FTM_SYNCONF_INVC_1 = 0x1
	// Position of SWOC field.
	FTM_SYNCONF_SWOC_Pos = 0x5
	// Bit mask of SWOC field.
	FTM_SYNCONF_SWOC_Msk = 0x20
	// Bit SWOC.
	FTM_SYNCONF_SWOC = 0x20
	// SWOCTRL register is updated with its buffer value at all rising edges of system clock.
	FTM_SYNCONF_SWOC_0 = 0x0
	// SWOCTRL register is updated with its buffer value by the PWM synchronization.
	FTM_SYNCONF_SWOC_1 = 0x1
	// Position of SYNCMODE field.
	FTM_SYNCONF_SYNCMODE_Pos = 0x7
	// Bit mask of SYNCMODE field.
	FTM_SYNCONF_SYNCMODE_Msk = 0x80
	// Bit SYNCMODE.
	FTM_SYNCONF_SYNCMODE = 0x80
	// Legacy PWM synchronization is selected.
	FTM_SYNCONF_SYNCMODE_0 = 0x0
	// Enhanced PWM synchronization is selected.
	FTM_SYNCONF_SYNCMODE_1 = 0x1
	// Position of SWRSTCNT field.
	FTM_SYNCONF_SWRSTCNT_Pos = 0x8
	// Bit mask of SWRSTCNT field.
	FTM_SYNCONF_SWRSTCNT_Msk = 0x100
	// Bit SWRSTCNT.
	FTM_SYNCONF_SWRSTCNT = 0x100
	// The software trigger does not activate the FTM counter synchronization.
	FTM_SYNCONF_SWRSTCNT_0 = 0x0
	// The software trigger activates the FTM counter synchronization.
	FTM_SYNCONF_SWRSTCNT_1 = 0x1
	// Position of SWWRBUF field.
	FTM_SYNCONF_SWWRBUF_Pos = 0x9
	// Bit mask of SWWRBUF field.
	FTM_SYNCONF_SWWRBUF_Msk = 0x200
	// Bit SWWRBUF.
	FTM_SYNCONF_SWWRBUF = 0x200
	// The software trigger does not activate MOD, CNTIN, and CV registers synchronization.
	FTM_SYNCONF_SWWRBUF_0 = 0x0
	// The software trigger activates MOD, CNTIN, and CV registers synchronization.
	FTM_SYNCONF_SWWRBUF_1 = 0x1
	// Position of SWOM field.
	FTM_SYNCONF_SWOM_Pos = 0xa
	// Bit mask of SWOM field.
	FTM_SYNCONF_SWOM_Msk = 0x400
	// Bit SWOM.
	FTM_SYNCONF_SWOM = 0x400
	// The software trigger does not activate the OUTMASK register synchronization.
	FTM_SYNCONF_SWOM_0 = 0x0
	// The software trigger activates the OUTMASK register synchronization.
	FTM_SYNCONF_SWOM_1 = 0x1
	// Position of SWINVC field.
	FTM_SYNCONF_SWINVC_Pos = 0xb
	// Bit mask of SWINVC field.
	FTM_SYNCONF_SWINVC_Msk = 0x800
	// Bit SWINVC.
	FTM_SYNCONF_SWINVC = 0x800
	// The software trigger does not activate the INVCTRL register synchronization.
	FTM_SYNCONF_SWINVC_0 = 0x0
	// The software trigger activates the INVCTRL register synchronization.
	FTM_SYNCONF_SWINVC_1 = 0x1
	// Position of SWSOC field.
	FTM_SYNCONF_SWSOC_Pos = 0xc
	// Bit mask of SWSOC field.
	FTM_SYNCONF_SWSOC_Msk = 0x1000
	// Bit SWSOC.
	FTM_SYNCONF_SWSOC = 0x1000
	// The software trigger does not activate the SWOCTRL register synchronization.
	FTM_SYNCONF_SWSOC_0 = 0x0
	// The software trigger activates the SWOCTRL register synchronization.
	FTM_SYNCONF_SWSOC_1 = 0x1
	// Position of HWRSTCNT field.
	FTM_SYNCONF_HWRSTCNT_Pos = 0x10
	// Bit mask of HWRSTCNT field.
	FTM_SYNCONF_HWRSTCNT_Msk = 0x10000
	// Bit HWRSTCNT.
	FTM_SYNCONF_HWRSTCNT = 0x10000
	// A hardware trigger does not activate the FTM counter synchronization.
	FTM_SYNCONF_HWRSTCNT_0 = 0x0
	// A hardware trigger activates the FTM counter synchronization.
	FTM_SYNCONF_HWRSTCNT_1 = 0x1
	// Position of HWWRBUF field.
	FTM_SYNCONF_HWWRBUF_Pos = 0x11
	// Bit mask of HWWRBUF field.
	FTM_SYNCONF_HWWRBUF_Msk = 0x20000
	// Bit HWWRBUF.
	FTM_SYNCONF_HWWRBUF = 0x20000
	// A hardware trigger does not activate MOD, CNTIN, and CV registers synchronization.
	FTM_SYNCONF_HWWRBUF_0 = 0x0
	// A hardware trigger activates MOD, CNTIN, and CV registers synchronization.
	FTM_SYNCONF_HWWRBUF_1 = 0x1
	// Position of HWOM field.
	FTM_SYNCONF_HWOM_Pos = 0x12
	// Bit mask of HWOM field.
	FTM_SYNCONF_HWOM_Msk = 0x40000
	// Bit HWOM.
	FTM_SYNCONF_HWOM = 0x40000
	// A hardware trigger does not activate the OUTMASK register synchronization.
	FTM_SYNCONF_HWOM_0 = 0x0
	// A hardware trigger activates the OUTMASK register synchronization.
	FTM_SYNCONF_HWOM_1 = 0x1
	// Position of HWINVC field.
	FTM_SYNCONF_HWINVC_Pos = 0x13
	// Bit mask of HWINVC field.
	FTM_SYNCONF_HWINVC_Msk = 0x80000
	// Bit HWINVC.
	FTM_SYNCONF_HWINVC = 0x80000
	// A hardware trigger does not activate the INVCTRL register synchronization.
	FTM_SYNCONF_HWINVC_0 = 0x0
	// A hardware trigger activates the INVCTRL register synchronization.
	FTM_SYNCONF_HWINVC_1 = 0x1
	// Position of HWSOC field.
	FTM_SYNCONF_HWSOC_Pos = 0x14
	// Bit mask of HWSOC field.
	FTM_SYNCONF_HWSOC_Msk = 0x100000
	// Bit HWSOC.
	FTM_SYNCONF_HWSOC = 0x100000
	// A hardware trigger does not activate the SWOCTRL register synchronization.
	FTM_SYNCONF_HWSOC_0 = 0x0
	// A hardware trigger activates the SWOCTRL register synchronization.
	FTM_SYNCONF_HWSOC_1 = 0x1

	// INVCTRL: FTM Inverting Control
	// Position of INV0EN field.
	FTM_INVCTRL_INV0EN_Pos = 0x0
	// Bit mask of INV0EN field.
	FTM_INVCTRL_INV0EN_Msk = 0x1
	// Bit INV0EN.
	FTM_INVCTRL_INV0EN = 0x1
	// Inverting is disabled.
	FTM_INVCTRL_INV0EN_0 = 0x0
	// Inverting is enabled.
	FTM_INVCTRL_INV0EN_1 = 0x1
	// Position of INV1EN field.
	FTM_INVCTRL_INV1EN_Pos = 0x1
	// Bit mask of INV1EN field.
	FTM_INVCTRL_INV1EN_Msk = 0x2
	// Bit INV1EN.
	FTM_INVCTRL_INV1EN = 0x2
	// Inverting is disabled.
	FTM_INVCTRL_INV1EN_0 = 0x0
	// Inverting is enabled.
	FTM_INVCTRL_INV1EN_1 = 0x1
	// Position of INV2EN field.
	FTM_INVCTRL_INV2EN_Pos = 0x2
	// Bit mask of INV2EN field.
	FTM_INVCTRL_INV2EN_Msk = 0x4
	// Bit INV2EN.
	FTM_INVCTRL_INV2EN = 0x4
	// Inverting is disabled.
	FTM_INVCTRL_INV2EN_0 = 0x0
	// Inverting is enabled.
	FTM_INVCTRL_INV2EN_1 = 0x1
	// Position of INV3EN field.
	FTM_INVCTRL_INV3EN_Pos = 0x3
	// Bit mask of INV3EN field.
	FTM_INVCTRL_INV3EN_Msk = 0x8
	// Bit INV3EN.
	FTM_INVCTRL_INV3EN = 0x8
	// Inverting is disabled.
	FTM_INVCTRL_INV3EN_0 = 0x0
	// Inverting is enabled.
	FTM_INVCTRL_INV3EN_1 = 0x1

	// SWOCTRL: FTM Software Output Control
	// Position of CH0OC field.
	FTM_SWOCTRL_CH0OC_Pos = 0x0
	// Bit mask of CH0OC field.
	FTM_SWOCTRL_CH0OC_Msk = 0x1
	// Bit CH0OC.
	FTM_SWOCTRL_CH0OC = 0x1
	// The channel output is not affected by software output control.
	FTM_SWOCTRL_CH0OC_0 = 0x0
	// The channel output is affected by software output control.
	FTM_SWOCTRL_CH0OC_1 = 0x1
	// Position of CH1OC field.
	FTM_SWOCTRL_CH1OC_Pos = 0x1
	// Bit mask of CH1OC field.
	FTM_SWOCTRL_CH1OC_Msk = 0x2
	// Bit CH1OC.
	FTM_SWOCTRL_CH1OC = 0x2
	// The channel output is not affected by software output control.
	FTM_SWOCTRL_CH1OC_0 = 0x0
	// The channel output is affected by software output control.
	FTM_SWOCTRL_CH1OC_1 = 0x1
	// Position of CH2OC field.
	FTM_SWOCTRL_CH2OC_Pos = 0x2
	// Bit mask of CH2OC field.
	FTM_SWOCTRL_CH2OC_Msk = 0x4
	// Bit CH2OC.
	FTM_SWOCTRL_CH2OC = 0x4
	// The channel output is not affected by software output control.
	FTM_SWOCTRL_CH2OC_0 = 0x0
	// The channel output is affected by software output control.
	FTM_SWOCTRL_CH2OC_1 = 0x1
	// Position of CH3OC field.
	FTM_SWOCTRL_CH3OC_Pos = 0x3
	// Bit mask of CH3OC field.
	FTM_SWOCTRL_CH3OC_Msk = 0x8
	// Bit CH3OC.
	FTM_SWOCTRL_CH3OC = 0x8
	// The channel output is not affected by software output control.
	FTM_SWOCTRL_CH3OC_0 = 0x0
	// The channel output is affected by software output control.
	FTM_SWOCTRL_CH3OC_1 = 0x1
	// Position of CH4OC field.
	FTM_SWOCTRL_CH4OC_Pos = 0x4
	// Bit mask of CH4OC field.
	FTM_SWOCTRL_CH4OC_Msk = 0x10
	// Bit CH4OC.
	FTM_SWOCTRL_CH4OC = 0x10
	// The channel output is not affected by software output control.
	FTM_SWOCTRL_CH4OC_0 = 0x0
	// The channel output is affected by software output control.
	FTM_SWOCTRL_CH4OC_1 = 0x1
	// Position of CH5OC field.
	FTM_SWOCTRL_CH5OC_Pos = 0x5
	// Bit mask of CH5OC field.
	FTM_SWOCTRL_CH5OC_Msk = 0x20
	// Bit CH5OC.
	FTM_SWOCTRL_CH5OC = 0x20
	// The channel output is not affected by software output control.
	FTM_SWOCTRL_CH5OC_0 = 0x0
	// The channel output is affected by software output control.
	FTM_SWOCTRL_CH5OC_1 = 0x1
	// Position of CH6OC field.
	FTM_SWOCTRL_CH6OC_Pos = 0x6
	// Bit mask of CH6OC field.
	FTM_SWOCTRL_CH6OC_Msk = 0x40
	// Bit CH6OC.
	FTM_SWOCTRL_CH6OC = 0x40
	// The channel output is not affected by software output control.
	FTM_SWOCTRL_CH6OC_0 = 0x0
	// The channel output is affected by software output control.
	FTM_SWOCTRL_CH6OC_1 = 0x1
	// Position of CH7OC field.
	FTM_SWOCTRL_CH7OC_Pos = 0x7
	// Bit mask of CH7OC field.
	FTM_SWOCTRL_CH7OC_Msk = 0x80
	// Bit CH7OC.
	FTM_SWOCTRL_CH7OC = 0x80
	// The channel output is not affected by software output control.
	FTM_SWOCTRL_CH7OC_0 = 0x0
	// The channel output is affected by software output control.
	FTM_SWOCTRL_CH7OC_1 = 0x1
	// Position of CH0OCV field.
	FTM_SWOCTRL_CH0OCV_Pos = 0x8
	// Bit mask of CH0OCV field.
	FTM_SWOCTRL_CH0OCV_Msk = 0x100
	// Bit CH0OCV.
	FTM_SWOCTRL_CH0OCV = 0x100
	// The software output control forces 0 to the channel output.
	FTM_SWOCTRL_CH0OCV_0 = 0x0
	// The software output control forces 1 to the channel output.
	FTM_SWOCTRL_CH0OCV_1 = 0x1
	// Position of CH1OCV field.
	FTM_SWOCTRL_CH1OCV_Pos = 0x9
	// Bit mask of CH1OCV field.
	FTM_SWOCTRL_CH1OCV_Msk = 0x200
	// Bit CH1OCV.
	FTM_SWOCTRL_CH1OCV = 0x200
	// The software output control forces 0 to the channel output.
	FTM_SWOCTRL_CH1OCV_0 = 0x0
	// The software output control forces 1 to the channel output.
	FTM_SWOCTRL_CH1OCV_1 = 0x1
	// Position of CH2OCV field.
	FTM_SWOCTRL_CH2OCV_Pos = 0xa
	// Bit mask of CH2OCV field.
	FTM_SWOCTRL_CH2OCV_Msk = 0x400
	// Bit CH2OCV.
	FTM_SWOCTRL_CH2OCV = 0x400
	// The software output control forces 0 to the channel output.
	FTM_SWOCTRL_CH2OCV_0 = 0x0
	// The software output control forces 1 to the channel output.
	FTM_SWOCTRL_CH2OCV_1 = 0x1
	// Position of CH3OCV field.
	FTM_SWOCTRL_CH3OCV_Pos = 0xb
	// Bit mask of CH3OCV field.
	FTM_SWOCTRL_CH3OCV_Msk = 0x800
	// Bit CH3OCV.
	FTM_SWOCTRL_CH3OCV = 0x800
	// The software output control forces 0 to the channel output.
	FTM_SWOCTRL_CH3OCV_0 = 0x0
	// The software output control forces 1 to the channel output.
	FTM_SWOCTRL_CH3OCV_1 = 0x1
	// Position of CH4OCV field.
	FTM_SWOCTRL_CH4OCV_Pos = 0xc
	// Bit mask of CH4OCV field.
	FTM_SWOCTRL_CH4OCV_Msk = 0x1000
	// Bit CH4OCV.
	FTM_SWOCTRL_CH4OCV = 0x1000
	// The software output control forces 0 to the channel output.
	FTM_SWOCTRL_CH4OCV_0 = 0x0
	// The software output control forces 1 to the channel output.
	FTM_SWOCTRL_CH4OCV_1 = 0x1
	// Position of CH5OCV field.
	FTM_SWOCTRL_CH5OCV_Pos = 0xd
	// Bit mask of CH5OCV field.
	FTM_SWOCTRL_CH5OCV_Msk = 0x2000
	// Bit CH5OCV.
	FTM_SWOCTRL_CH5OCV = 0x2000
	// The software output control forces 0 to the channel output.
	FTM_SWOCTRL_CH5OCV_0 = 0x0
	// The software output control forces 1 to the channel output.
	FTM_SWOCTRL_CH5OCV_1 = 0x1
	// Position of CH6OCV field.
	FTM_SWOCTRL_CH6OCV_Pos = 0xe
	// Bit mask of CH6OCV field.
	FTM_SWOCTRL_CH6OCV_Msk = 0x4000
	// Bit CH6OCV.
	FTM_SWOCTRL_CH6OCV = 0x4000
	// The software output control forces 0 to the channel output.
	FTM_SWOCTRL_CH6OCV_0 = 0x0
	// The software output control forces 1 to the channel output.
	FTM_SWOCTRL_CH6OCV_1 = 0x1
	// Position of CH7OCV field.
	FTM_SWOCTRL_CH7OCV_Pos = 0xf
	// Bit mask of CH7OCV field.
	FTM_SWOCTRL_CH7OCV_Msk = 0x8000
	// Bit CH7OCV.
	FTM_SWOCTRL_CH7OCV = 0x8000
	// The software output control forces 0 to the channel output.
	FTM_SWOCTRL_CH7OCV_0 = 0x0
	// The software output control forces 1 to the channel output.
	FTM_SWOCTRL_CH7OCV_1 = 0x1

	// PWMLOAD: FTM PWM Load
	// Position of CH0SEL field.
	FTM_PWMLOAD_CH0SEL_Pos = 0x0
	// Bit mask of CH0SEL field.
	FTM_PWMLOAD_CH0SEL_Msk = 0x1
	// Bit CH0SEL.
	FTM_PWMLOAD_CH0SEL = 0x1
	// Do not include the channel in the matching process.
	FTM_PWMLOAD_CH0SEL_0 = 0x0
	// Include the channel in the matching process.
	FTM_PWMLOAD_CH0SEL_1 = 0x1
	// Position of CH1SEL field.
	FTM_PWMLOAD_CH1SEL_Pos = 0x1
	// Bit mask of CH1SEL field.
	FTM_PWMLOAD_CH1SEL_Msk = 0x2
	// Bit CH1SEL.
	FTM_PWMLOAD_CH1SEL = 0x2
	// Do not include the channel in the matching process.
	FTM_PWMLOAD_CH1SEL_0 = 0x0
	// Include the channel in the matching process.
	FTM_PWMLOAD_CH1SEL_1 = 0x1
	// Position of CH2SEL field.
	FTM_PWMLOAD_CH2SEL_Pos = 0x2
	// Bit mask of CH2SEL field.
	FTM_PWMLOAD_CH2SEL_Msk = 0x4
	// Bit CH2SEL.
	FTM_PWMLOAD_CH2SEL = 0x4
	// Do not include the channel in the matching process.
	FTM_PWMLOAD_CH2SEL_0 = 0x0
	// Include the channel in the matching process.
	FTM_PWMLOAD_CH2SEL_1 = 0x1
	// Position of CH3SEL field.
	FTM_PWMLOAD_CH3SEL_Pos = 0x3
	// Bit mask of CH3SEL field.
	FTM_PWMLOAD_CH3SEL_Msk = 0x8
	// Bit CH3SEL.
	FTM_PWMLOAD_CH3SEL = 0x8
	// Do not include the channel in the matching process.
	FTM_PWMLOAD_CH3SEL_0 = 0x0
	// Include the channel in the matching process.
	FTM_PWMLOAD_CH3SEL_1 = 0x1
	// Position of CH4SEL field.
	FTM_PWMLOAD_CH4SEL_Pos = 0x4
	// Bit mask of CH4SEL field.
	FTM_PWMLOAD_CH4SEL_Msk = 0x10
	// Bit CH4SEL.
	FTM_PWMLOAD_CH4SEL = 0x10
	// Do not include the channel in the matching process.
	FTM_PWMLOAD_CH4SEL_0 = 0x0
	// Include the channel in the matching process.
	FTM_PWMLOAD_CH4SEL_1 = 0x1
	// Position of CH5SEL field.
	FTM_PWMLOAD_CH5SEL_Pos = 0x5
	// Bit mask of CH5SEL field.
	FTM_PWMLOAD_CH5SEL_Msk = 0x20
	// Bit CH5SEL.
	FTM_PWMLOAD_CH5SEL = 0x20
	// Do not include the channel in the matching process.
	FTM_PWMLOAD_CH5SEL_0 = 0x0
	// Include the channel in the matching process.
	FTM_PWMLOAD_CH5SEL_1 = 0x1
	// Position of CH6SEL field.
	FTM_PWMLOAD_CH6SEL_Pos = 0x6
	// Bit mask of CH6SEL field.
	FTM_PWMLOAD_CH6SEL_Msk = 0x40
	// Bit CH6SEL.
	FTM_PWMLOAD_CH6SEL = 0x40
	// Do not include the channel in the matching process.
	FTM_PWMLOAD_CH6SEL_0 = 0x0
	// Include the channel in the matching process.
	FTM_PWMLOAD_CH6SEL_1 = 0x1
	// Position of CH7SEL field.
	FTM_PWMLOAD_CH7SEL_Pos = 0x7
	// Bit mask of CH7SEL field.
	FTM_PWMLOAD_CH7SEL_Msk = 0x80
	// Bit CH7SEL.
	FTM_PWMLOAD_CH7SEL = 0x80
	// Do not include the channel in the matching process.
	FTM_PWMLOAD_CH7SEL_0 = 0x0
	// Include the channel in the matching process.
	FTM_PWMLOAD_CH7SEL_1 = 0x1
	// Position of LDOK field.
	FTM_PWMLOAD_LDOK_Pos = 0x9
	// Bit mask of LDOK field.
	FTM_PWMLOAD_LDOK_Msk = 0x200
	// Bit LDOK.
	FTM_PWMLOAD_LDOK = 0x200
	// Loading updated values is disabled.
	FTM_PWMLOAD_LDOK_0 = 0x0
	// Loading updated values is enabled.
	FTM_PWMLOAD_LDOK_1 = 0x1
)

// Constants for ADC0: Analog-to-Digital Converter
const (
	// SC1A: ADC Status and Control Registers 1
	// Position of ADCH field.
	ADC_SC1_ADCH_Pos = 0x0
	// Bit mask of ADCH field.
	ADC_SC1_ADCH_Msk = 0x1f
	// When DIFF=0, DADP0 is selected as input; when DIFF=1, DAD0 is selected as input.
	ADC_SC1_ADCH_00000 = 0x0
	// When DIFF=0, DADP1 is selected as input; when DIFF=1, DAD1 is selected as input.
	ADC_SC1_ADCH_00001 = 0x1
	// When DIFF=0, DADP2 is selected as input; when DIFF=1, DAD2 is selected as input.
	ADC_SC1_ADCH_00010 = 0x2
	// When DIFF=0, DADP3 is selected as input; when DIFF=1, DAD3 is selected as input.
	ADC_SC1_ADCH_00011 = 0x3
	// When DIFF=0, AD4 is selected as input; when DIFF=1, it is reserved.
	ADC_SC1_ADCH_00100 = 0x4
	// When DIFF=0, AD5 is selected as input; when DIFF=1, it is reserved.
	ADC_SC1_ADCH_00101 = 0x5
	// When DIFF=0, AD6 is selected as input; when DIFF=1, it is reserved.
	ADC_SC1_ADCH_00110 = 0x6
	// When DIFF=0, AD7 is selected as input; when DIFF=1, it is reserved.
	ADC_SC1_ADCH_00111 = 0x7
	// When DIFF=0, AD8 is selected as input; when DIFF=1, it is reserved.
	ADC_SC1_ADCH_01000 = 0x8
	// When DIFF=0, AD9 is selected as input; when DIFF=1, it is reserved.
	ADC_SC1_ADCH_01001 = 0x9
	// When DIFF=0, AD10 is selected as input; when DIFF=1, it is reserved.
	ADC_SC1_ADCH_01010 = 0xa
	// When DIFF=0, AD11 is selected as input; when DIFF=1, it is reserved.
	ADC_SC1_ADCH_01011 = 0xb
	// When DIFF=0, AD12 is selected as input; when DIFF=1, it is reserved.
	ADC_SC1_ADCH_01100 = 0xc
	// When DIFF=0, AD13 is selected as input; when DIFF=1, it is reserved.
	ADC_SC1_ADCH_01101 = 0xd
	// When DIFF=0, AD14 is selected as input; when DIFF=1, it is reserved.
	ADC_SC1_ADCH_01110 = 0xe
	// When DIFF=0, AD15 is selected as input; when DIFF=1, it is reserved.
	ADC_SC1_ADCH_01111 = 0xf
	// When DIFF=0, AD16 is selected as input; when DIFF=1, it is reserved.
	ADC_SC1_ADCH_10000 = 0x10
	// When DIFF=0, AD17 is selected as input; when DIFF=1, it is reserved.
	ADC_SC1_ADCH_10001 = 0x11
	// When DIFF=0, AD18 is selected as input; when DIFF=1, it is reserved.
	ADC_SC1_ADCH_10010 = 0x12
	// When DIFF=0, AD19 is selected as input; when DIFF=1, it is reserved.
	ADC_SC1_ADCH_10011 = 0x13
	// When DIFF=0, AD20 is selected as input; when DIFF=1, it is reserved.
	ADC_SC1_ADCH_10100 = 0x14
	// When DIFF=0, AD21 is selected as input; when DIFF=1, it is reserved.
	ADC_SC1_ADCH_10101 = 0x15
	// When DIFF=0, AD22 is selected as input; when DIFF=1, it is reserved.
	ADC_SC1_ADCH_10110 = 0x16
	// When DIFF=0, AD23 is selected as input; when DIFF=1, it is reserved.
	ADC_SC1_ADCH_10111 = 0x17
	// When DIFF=0, Temp Sensor (single-ended) is selected as input; when DIFF=1, Temp Sensor (differential) is selected as input.
	ADC_SC1_ADCH_11010 = 0x1a
	// When DIFF=0, Bandgap (single-ended) is selected as input; when DIFF=1, Bandgap (differential) is selected as input.
	ADC_SC1_ADCH_11011 = 0x1b
	// When DIFF=0,VREFSH is selected as input; when DIFF=1, -VREFSH (differential) is selected as input. Voltage reference selected is determined by SC2[REFSEL].
	ADC_SC1_ADCH_11101 = 0x1d
	// When DIFF=0,VREFSL is selected as input; when DIFF=1, it is reserved. Voltage reference selected is determined by SC2[REFSEL].
	ADC_SC1_ADCH_11110 = 0x1e
	// Module is disabled.
	ADC_SC1_ADCH_11111 = 0x1f
	// Position of DIFF field.
	ADC_SC1_DIFF_Pos = 0x5
	// Bit mask of DIFF field.
	ADC_SC1_DIFF_Msk = 0x20
	// Bit DIFF.
	ADC_SC1_DIFF = 0x20
	// Single-ended conversions and input channels are selected.
	ADC_SC1_DIFF_0 = 0x0
	// Differential conversions and input channels are selected.
	ADC_SC1_DIFF_1 = 0x1
	// Position of AIEN field.
	ADC_SC1_AIEN_Pos = 0x6
	// Bit mask of AIEN field.
	ADC_SC1_AIEN_Msk = 0x40
	// Bit AIEN.
	ADC_SC1_AIEN = 0x40
	// Conversion complete interrupt is disabled.
	ADC_SC1_AIEN_0 = 0x0
	// Conversion complete interrupt is enabled.
	ADC_SC1_AIEN_1 = 0x1
	// Position of COCO field.
	ADC_SC1_COCO_Pos = 0x7
	// Bit mask of COCO field.
	ADC_SC1_COCO_Msk = 0x80
	// Bit COCO.
	ADC_SC1_COCO = 0x80
	// Conversion is not completed.
	ADC_SC1_COCO_0 = 0x0
	// Conversion is completed.
	ADC_SC1_COCO_1 = 0x1

	// CFG1: ADC Configuration Register 1
	// Position of ADICLK field.
	ADC_CFG1_ADICLK_Pos = 0x0
	// Bit mask of ADICLK field.
	ADC_CFG1_ADICLK_Msk = 0x3
	// Bus clock
	ADC_CFG1_ADICLK_00 = 0x0
	// Alternate clock 2 (ALTCLK2)
	ADC_CFG1_ADICLK_01 = 0x1
	// Alternate clock (ALTCLK)
	ADC_CFG1_ADICLK_10 = 0x2
	// Asynchronous clock (ADACK)
	ADC_CFG1_ADICLK_11 = 0x3
	// Position of MODE field.
	ADC_CFG1_MODE_Pos = 0x2
	// Bit mask of MODE field.
	ADC_CFG1_MODE_Msk = 0xc
	// When DIFF=0:It is single-ended 8-bit conversion; when DIFF=1, it is differential 9-bit conversion with 2's complement output.
	ADC_CFG1_MODE_00 = 0x0
	// When DIFF=0:It is single-ended 12-bit conversion ; when DIFF=1, it is differential 13-bit conversion with 2's complement output.
	ADC_CFG1_MODE_01 = 0x1
	// When DIFF=0:It is single-ended 10-bit conversion. ; when DIFF=1, it is differential 11-bit conversion with 2's complement output
	ADC_CFG1_MODE_10 = 0x2
	// When DIFF=0:It is single-ended 16-bit conversion..; when DIFF=1, it is differential 16-bit conversion with 2's complement output
	ADC_CFG1_MODE_11 = 0x3
	// Position of ADLSMP field.
	ADC_CFG1_ADLSMP_Pos = 0x4
	// Bit mask of ADLSMP field.
	ADC_CFG1_ADLSMP_Msk = 0x10
	// Bit ADLSMP.
	ADC_CFG1_ADLSMP = 0x10
	// Short sample time.
	ADC_CFG1_ADLSMP_0 = 0x0
	// Long sample time.
	ADC_CFG1_ADLSMP_1 = 0x1
	// Position of ADIV field.
	ADC_CFG1_ADIV_Pos = 0x5
	// Bit mask of ADIV field.
	ADC_CFG1_ADIV_Msk = 0x60
	// The divide ratio is 1 and the clock rate is input clock.
	ADC_CFG1_ADIV_00 = 0x0
	// The divide ratio is 2 and the clock rate is (input clock)/2.
	ADC_CFG1_ADIV_01 = 0x1
	// The divide ratio is 4 and the clock rate is (input clock)/4.
	ADC_CFG1_ADIV_10 = 0x2
	// The divide ratio is 8 and the clock rate is (input clock)/8.
	ADC_CFG1_ADIV_11 = 0x3
	// Position of ADLPC field.
	ADC_CFG1_ADLPC_Pos = 0x7
	// Bit mask of ADLPC field.
	ADC_CFG1_ADLPC_Msk = 0x80
	// Bit ADLPC.
	ADC_CFG1_ADLPC = 0x80
	// Normal power configuration.
	ADC_CFG1_ADLPC_0 = 0x0
	// Low-power configuration. The power is reduced at the expense of maximum clock speed.
	ADC_CFG1_ADLPC_1 = 0x1

	// CFG2: ADC Configuration Register 2
	// Position of ADLSTS field.
	ADC_CFG2_ADLSTS_Pos = 0x0
	// Bit mask of ADLSTS field.
	ADC_CFG2_ADLSTS_Msk = 0x3
	// Default longest sample time; 20 extra ADCK cycles; 24 ADCK cycles total.
	ADC_CFG2_ADLSTS_00 = 0x0
	// 12 extra ADCK cycles; 16 ADCK cycles total sample time.
	ADC_CFG2_ADLSTS_01 = 0x1
	// 6 extra ADCK cycles; 10 ADCK cycles total sample time.
	ADC_CFG2_ADLSTS_10 = 0x2
	// 2 extra ADCK cycles; 6 ADCK cycles total sample time.
	ADC_CFG2_ADLSTS_11 = 0x3
	// Position of ADHSC field.
	ADC_CFG2_ADHSC_Pos = 0x2
	// Bit mask of ADHSC field.
	ADC_CFG2_ADHSC_Msk = 0x4
	// Bit ADHSC.
	ADC_CFG2_ADHSC = 0x4
	// Normal conversion sequence selected.
	ADC_CFG2_ADHSC_0 = 0x0
	// High-speed conversion sequence selected with 2 additional ADCK cycles to total conversion time.
	ADC_CFG2_ADHSC_1 = 0x1
	// Position of ADACKEN field.
	ADC_CFG2_ADACKEN_Pos = 0x3
	// Bit mask of ADACKEN field.
	ADC_CFG2_ADACKEN_Msk = 0x8
	// Bit ADACKEN.
	ADC_CFG2_ADACKEN = 0x8
	// Asynchronous clock output disabled; Asynchronous clock is enabled only if selected by ADICLK and a conversion is active.
	ADC_CFG2_ADACKEN_0 = 0x0
	// Asynchronous clock and clock output is enabled regardless of the state of the ADC.
	ADC_CFG2_ADACKEN_1 = 0x1
	// Position of MUXSEL field.
	ADC_CFG2_MUXSEL_Pos = 0x4
	// Bit mask of MUXSEL field.
	ADC_CFG2_MUXSEL_Msk = 0x10
	// Bit MUXSEL.
	ADC_CFG2_MUXSEL = 0x10
	// ADxxa channels are selected.
	ADC_CFG2_MUXSEL_0 = 0x0
	// ADxxb channels are selected.
	ADC_CFG2_MUXSEL_1 = 0x1

	// RA: ADC Data Result Register
	// Position of D field.
	ADC_R_D_Pos = 0x0
	// Bit mask of D field.
	ADC_R_D_Msk = 0xffff

	// CV1: Compare Value Registers
	// Position of CV field.
	ADC_CV_CV_Pos = 0x0
	// Bit mask of CV field.
	ADC_CV_CV_Msk = 0xffff

	// SC2: Status and Control Register 2
	// Position of REFSEL field.
	ADC_SC2_REFSEL_Pos = 0x0
	// Bit mask of REFSEL field.
	ADC_SC2_REFSEL_Msk = 0x3
	// Default voltage reference pin pair, that is, external pins VREFH and VREFL
	ADC_SC2_REFSEL_00 = 0x0
	// Alternate reference pair, that is, VALTH and VALTL . This pair may be additional external pins or internal sources depending on the MCU configuration. See the chip configuration information for details specific to this MCU
	ADC_SC2_REFSEL_01 = 0x1
	// Position of DMAEN field.
	ADC_SC2_DMAEN_Pos = 0x2
	// Bit mask of DMAEN field.
	ADC_SC2_DMAEN_Msk = 0x4
	// Bit DMAEN.
	ADC_SC2_DMAEN = 0x4
	// DMA is disabled.
	ADC_SC2_DMAEN_0 = 0x0
	// DMA is enabled and will assert the ADC DMA request during an ADC conversion complete event noted when any of the SC1n[COCO] flags is asserted.
	ADC_SC2_DMAEN_1 = 0x1
	// Position of ACREN field.
	ADC_SC2_ACREN_Pos = 0x3
	// Bit mask of ACREN field.
	ADC_SC2_ACREN_Msk = 0x8
	// Bit ACREN.
	ADC_SC2_ACREN = 0x8
	// Range function disabled. Only CV1 is compared.
	ADC_SC2_ACREN_0 = 0x0
	// Range function enabled. Both CV1 and CV2 are compared.
	ADC_SC2_ACREN_1 = 0x1
	// Position of ACFGT field.
	ADC_SC2_ACFGT_Pos = 0x4
	// Bit mask of ACFGT field.
	ADC_SC2_ACFGT_Msk = 0x10
	// Bit ACFGT.
	ADC_SC2_ACFGT = 0x10
	// Configures less than threshold, outside range not inclusive and inside range not inclusive; functionality based on the values placed in CV1 and CV2.
	ADC_SC2_ACFGT_0 = 0x0
	// Configures greater than or equal to threshold, outside and inside ranges inclusive; functionality based on the values placed in CV1 and CV2.
	ADC_SC2_ACFGT_1 = 0x1
	// Position of ACFE field.
	ADC_SC2_ACFE_Pos = 0x5
	// Bit mask of ACFE field.
	ADC_SC2_ACFE_Msk = 0x20
	// Bit ACFE.
	ADC_SC2_ACFE = 0x20
	// Compare function disabled.
	ADC_SC2_ACFE_0 = 0x0
	// Compare function enabled.
	ADC_SC2_ACFE_1 = 0x1
	// Position of ADTRG field.
	ADC_SC2_ADTRG_Pos = 0x6
	// Bit mask of ADTRG field.
	ADC_SC2_ADTRG_Msk = 0x40
	// Bit ADTRG.
	ADC_SC2_ADTRG = 0x40
	// Software trigger selected.
	ADC_SC2_ADTRG_0 = 0x0
	// Hardware trigger selected.
	ADC_SC2_ADTRG_1 = 0x1
	// Position of ADACT field.
	ADC_SC2_ADACT_Pos = 0x7
	// Bit mask of ADACT field.
	ADC_SC2_ADACT_Msk = 0x80
	// Bit ADACT.
	ADC_SC2_ADACT = 0x80
	// Conversion not in progress.
	ADC_SC2_ADACT_0 = 0x0
	// Conversion in progress.
	ADC_SC2_ADACT_1 = 0x1

	// SC3: Status and Control Register 3
	// Position of AVGS field.
	ADC_SC3_AVGS_Pos = 0x0
	// Bit mask of AVGS field.
	ADC_SC3_AVGS_Msk = 0x3
	// 4 samples averaged.
	ADC_SC3_AVGS_00 = 0x0
	// 8 samples averaged.
	ADC_SC3_AVGS_01 = 0x1
	// 16 samples averaged.
	ADC_SC3_AVGS_10 = 0x2
	// 32 samples averaged.
	ADC_SC3_AVGS_11 = 0x3
	// Position of AVGE field.
	ADC_SC3_AVGE_Pos = 0x2
	// Bit mask of AVGE field.
	ADC_SC3_AVGE_Msk = 0x4
	// Bit AVGE.
	ADC_SC3_AVGE = 0x4
	// Hardware average function disabled.
	ADC_SC3_AVGE_0 = 0x0
	// Hardware average function enabled.
	ADC_SC3_AVGE_1 = 0x1
	// Position of ADCO field.
	ADC_SC3_ADCO_Pos = 0x3
	// Bit mask of ADCO field.
	ADC_SC3_ADCO_Msk = 0x8
	// Bit ADCO.
	ADC_SC3_ADCO = 0x8
	// One conversion or one set of conversions if the hardware average function is enabled, that is, AVGE=1, after initiating a conversion.
	ADC_SC3_ADCO_0 = 0x0
	// Continuous conversions or sets of conversions if the hardware average function is enabled, that is, AVGE=1, after initiating a conversion.
	ADC_SC3_ADCO_1 = 0x1
	// Position of CALF field.
	ADC_SC3_CALF_Pos = 0x6
	// Bit mask of CALF field.
	ADC_SC3_CALF_Msk = 0x40
	// Bit CALF.
	ADC_SC3_CALF = 0x40
	// Calibration completed normally.
	ADC_SC3_CALF_0 = 0x0
	// Calibration failed. ADC accuracy specifications are not guaranteed.
	ADC_SC3_CALF_1 = 0x1
	// Position of CAL field.
	ADC_SC3_CAL_Pos = 0x7
	// Bit mask of CAL field.
	ADC_SC3_CAL_Msk = 0x80
	// Bit CAL.
	ADC_SC3_CAL = 0x80

	// OFS: ADC Offset Correction Register
	// Position of OFS field.
	ADC_OFS_OFS_Pos = 0x0
	// Bit mask of OFS field.
	ADC_OFS_OFS_Msk = 0xffff

	// PG: ADC Plus-Side Gain Register
	// Position of PG field.
	ADC_PG_PG_Pos = 0x0
	// Bit mask of PG field.
	ADC_PG_PG_Msk = 0xffff

	// MG: ADC Minus-Side Gain Register
	// Position of MG field.
	ADC_MG_MG_Pos = 0x0
	// Bit mask of MG field.
	ADC_MG_MG_Msk = 0xffff

	// CLPD: ADC Plus-Side General Calibration Value Register
	// Position of CLPD field.
	ADC_CLPD_CLPD_Pos = 0x0
	// Bit mask of CLPD field.
	ADC_CLPD_CLPD_Msk = 0x3f

	// CLPS: ADC Plus-Side General Calibration Value Register
	// Position of CLPS field.
	ADC_CLPS_CLPS_Pos = 0x0
	// Bit mask of CLPS field.
	ADC_CLPS_CLPS_Msk = 0x3f

	// CLP4: ADC Plus-Side General Calibration Value Register
	// Position of CLP4 field.
	ADC_CLP4_CLP4_Pos = 0x0
	// Bit mask of CLP4 field.
	ADC_CLP4_CLP4_Msk = 0x3ff

	// CLP3: ADC Plus-Side General Calibration Value Register
	// Position of CLP3 field.
	ADC_CLP3_CLP3_Pos = 0x0
	// Bit mask of CLP3 field.
	ADC_CLP3_CLP3_Msk = 0x1ff

	// CLP2: ADC Plus-Side General Calibration Value Register
	// Position of CLP2 field.
	ADC_CLP2_CLP2_Pos = 0x0
	// Bit mask of CLP2 field.
	ADC_CLP2_CLP2_Msk = 0xff

	// CLP1: ADC Plus-Side General Calibration Value Register
	// Position of CLP1 field.
	ADC_CLP1_CLP1_Pos = 0x0
	// Bit mask of CLP1 field.
	ADC_CLP1_CLP1_Msk = 0x7f

	// CLP0: ADC Plus-Side General Calibration Value Register
	// Position of CLP0 field.
	ADC_CLP0_CLP0_Pos = 0x0
	// Bit mask of CLP0 field.
	ADC_CLP0_CLP0_Msk = 0x3f

	// CLMD: ADC Minus-Side General Calibration Value Register
	// Position of CLMD field.
	ADC_CLMD_CLMD_Pos = 0x0
	// Bit mask of CLMD field.
	ADC_CLMD_CLMD_Msk = 0x3f

	// CLMS: ADC Minus-Side General Calibration Value Register
	// Position of CLMS field.
	ADC_CLMS_CLMS_Pos = 0x0
	// Bit mask of CLMS field.
	ADC_CLMS_CLMS_Msk = 0x3f

	// CLM4: ADC Minus-Side General Calibration Value Register
	// Position of CLM4 field.
	ADC_CLM4_CLM4_Pos = 0x0
	// Bit mask of CLM4 field.
	ADC_CLM4_CLM4_Msk = 0x3ff

	// CLM3: ADC Minus-Side General Calibration Value Register
	// Position of CLM3 field.
	ADC_CLM3_CLM3_Pos = 0x0
	// Bit mask of CLM3 field.
	ADC_CLM3_CLM3_Msk = 0x1ff

	// CLM2: ADC Minus-Side General Calibration Value Register
	// Position of CLM2 field.
	ADC_CLM2_CLM2_Pos = 0x0
	// Bit mask of CLM2 field.
	ADC_CLM2_CLM2_Msk = 0xff

	// CLM1: ADC Minus-Side General Calibration Value Register
	// Position of CLM1 field.
	ADC_CLM1_CLM1_Pos = 0x0
	// Bit mask of CLM1 field.
	ADC_CLM1_CLM1_Msk = 0x7f

	// CLM0: ADC Minus-Side General Calibration Value Register
	// Position of CLM0 field.
	ADC_CLM0_CLM0_Pos = 0x0
	// Bit mask of CLM0 field.
	ADC_CLM0_CLM0_Msk = 0x3f
)

// Constants for RTC: Secure Real Time Clock
const (
	// TSR: RTC Time Seconds Register
	// Position of TSR field.
	RTC_TSR_TSR_Pos = 0x0
	// Bit mask of TSR field.
	RTC_TSR_TSR_Msk = 0xffffffff

	// TPR: RTC Time Prescaler Register
	// Position of TPR field.
	RTC_TPR_TPR_Pos = 0x0
	// Bit mask of TPR field.
	RTC_TPR_TPR_Msk = 0xffff

	// TAR: RTC Time Alarm Register
	// Position of TAR field.
	RTC_TAR_TAR_Pos = 0x0
	// Bit mask of TAR field.
	RTC_TAR_TAR_Msk = 0xffffffff

	// TCR: RTC Time Compensation Register
	// Position of TCR field.
	RTC_TCR_TCR_Pos = 0x0
	// Bit mask of TCR field.
	RTC_TCR_TCR_Msk = 0xff
	// Time Prescaler Register overflows every 32896 clock cycles.
	RTC_TCR_TCR_10000000 = 0x80
	// Time Prescaler Register overflows every 32769 clock cycles.
	RTC_TCR_TCR_11111111 = 0xff
	// Time Prescaler Register overflows every 32768 clock cycles.
	RTC_TCR_TCR_0 = 0x0
	// Time Prescaler Register overflows every 32767 clock cycles.
	RTC_TCR_TCR_1 = 0x1
	// Time Prescaler Register overflows every 32641 clock cycles.
	RTC_TCR_TCR_1111111 = 0x7f
	// Position of CIR field.
	RTC_TCR_CIR_Pos = 0x8
	// Bit mask of CIR field.
	RTC_TCR_CIR_Msk = 0xff00
	// Position of TCV field.
	RTC_TCR_TCV_Pos = 0x10
	// Bit mask of TCV field.
	RTC_TCR_TCV_Msk = 0xff0000
	// Position of CIC field.
	RTC_TCR_CIC_Pos = 0x18
	// Bit mask of CIC field.
	RTC_TCR_CIC_Msk = 0xff000000

	// CR: RTC Control Register
	// Position of SWR field.
	RTC_CR_SWR_Pos = 0x0
	// Bit mask of SWR field.
	RTC_CR_SWR_Msk = 0x1
	// Bit SWR.
	RTC_CR_SWR = 0x1
	// No effect.
	RTC_CR_SWR_0 = 0x0
	// Resets all RTC registers except for the SWR bit and the RTC_WAR and RTC_RAR registers . The SWR bit is cleared by VBAT POR and by software explicitly clearing it.
	RTC_CR_SWR_1 = 0x1
	// Position of WPE field.
	RTC_CR_WPE_Pos = 0x1
	// Bit mask of WPE field.
	RTC_CR_WPE_Msk = 0x2
	// Bit WPE.
	RTC_CR_WPE = 0x2
	// Wakeup pin is disabled.
	RTC_CR_WPE_0 = 0x0
	// Wakeup pin is enabled and wakeup pin asserts if the RTC interrupt asserts or the wakeup pin is turned on.
	RTC_CR_WPE_1 = 0x1
	// Position of SUP field.
	RTC_CR_SUP_Pos = 0x2
	// Bit mask of SUP field.
	RTC_CR_SUP_Msk = 0x4
	// Bit SUP.
	RTC_CR_SUP = 0x4
	// Non-supervisor mode write accesses are not supported and generate a bus error.
	RTC_CR_SUP_0 = 0x0
	// Non-supervisor mode write accesses are supported.
	RTC_CR_SUP_1 = 0x1
	// Position of UM field.
	RTC_CR_UM_Pos = 0x3
	// Bit mask of UM field.
	RTC_CR_UM_Msk = 0x8
	// Bit UM.
	RTC_CR_UM = 0x8
	// Registers cannot be written when locked.
	RTC_CR_UM_0 = 0x0
	// Registers can be written when locked under limited conditions.
	RTC_CR_UM_1 = 0x1
	// Position of WPS field.
	RTC_CR_WPS_Pos = 0x4
	// Bit mask of WPS field.
	RTC_CR_WPS_Msk = 0x10
	// Bit WPS.
	RTC_CR_WPS = 0x10
	// Wakeup pin asserts (active low, open drain) if the RTC interrupt asserts or the wakeup pin is turned on.
	RTC_CR_WPS_0 = 0x0
	// Wakeup pin instead outputs the RTC 32kHz clock, provided the wakeup pin is turned on and the 32kHz clock is output to other peripherals.
	RTC_CR_WPS_1 = 0x1
	// Position of OSCE field.
	RTC_CR_OSCE_Pos = 0x8
	// Bit mask of OSCE field.
	RTC_CR_OSCE_Msk = 0x100
	// Bit OSCE.
	RTC_CR_OSCE = 0x100
	// 32.768 kHz oscillator is disabled.
	RTC_CR_OSCE_0 = 0x0
	// 32.768 kHz oscillator is enabled. After setting this bit, wait the oscillator startup time before enabling the time counter to allow the 32.768 kHz clock time to stabilize.
	RTC_CR_OSCE_1 = 0x1
	// Position of CLKO field.
	RTC_CR_CLKO_Pos = 0x9
	// Bit mask of CLKO field.
	RTC_CR_CLKO_Msk = 0x200
	// Bit CLKO.
	RTC_CR_CLKO = 0x200
	// The 32 kHz clock is output to other peripherals.
	RTC_CR_CLKO_0 = 0x0
	// The 32 kHz clock is not output to other peripherals.
	RTC_CR_CLKO_1 = 0x1
	// Position of SC16P field.
	RTC_CR_SC16P_Pos = 0xa
	// Bit mask of SC16P field.
	RTC_CR_SC16P_Msk = 0x400
	// Bit SC16P.
	RTC_CR_SC16P = 0x400
	// Disable the load.
	RTC_CR_SC16P_0 = 0x0
	// Enable the additional load.
	RTC_CR_SC16P_1 = 0x1
	// Position of SC8P field.
	RTC_CR_SC8P_Pos = 0xb
	// Bit mask of SC8P field.
	RTC_CR_SC8P_Msk = 0x800
	// Bit SC8P.
	RTC_CR_SC8P = 0x800
	// Disable the load.
	RTC_CR_SC8P_0 = 0x0
	// Enable the additional load.
	RTC_CR_SC8P_1 = 0x1
	// Position of SC4P field.
	RTC_CR_SC4P_Pos = 0xc
	// Bit mask of SC4P field.
	RTC_CR_SC4P_Msk = 0x1000
	// Bit SC4P.
	RTC_CR_SC4P = 0x1000
	// Disable the load.
	RTC_CR_SC4P_0 = 0x0
	// Enable the additional load.
	RTC_CR_SC4P_1 = 0x1
	// Position of SC2P field.
	RTC_CR_SC2P_Pos = 0xd
	// Bit mask of SC2P field.
	RTC_CR_SC2P_Msk = 0x2000
	// Bit SC2P.
	RTC_CR_SC2P = 0x2000
	// Disable the load.
	RTC_CR_SC2P_0 = 0x0
	// Enable the additional load.
	RTC_CR_SC2P_1 = 0x1

	// SR: RTC Status Register
	// Position of TIF field.
	RTC_SR_TIF_Pos = 0x0
	// Bit mask of TIF field.
	RTC_SR_TIF_Msk = 0x1
	// Bit TIF.
	RTC_SR_TIF = 0x1
	// Time is valid.
	RTC_SR_TIF_0 = 0x0
	// Time is invalid and time counter is read as zero.
	RTC_SR_TIF_1 = 0x1
	// Position of TOF field.
	RTC_SR_TOF_Pos = 0x1
	// Bit mask of TOF field.
	RTC_SR_TOF_Msk = 0x2
	// Bit TOF.
	RTC_SR_TOF = 0x2
	// Time overflow has not occurred.
	RTC_SR_TOF_0 = 0x0
	// Time overflow has occurred and time counter is read as zero.
	RTC_SR_TOF_1 = 0x1
	// Position of TAF field.
	RTC_SR_TAF_Pos = 0x2
	// Bit mask of TAF field.
	RTC_SR_TAF_Msk = 0x4
	// Bit TAF.
	RTC_SR_TAF = 0x4
	// Time alarm has not occurred.
	RTC_SR_TAF_0 = 0x0
	// Time alarm has occurred.
	RTC_SR_TAF_1 = 0x1
	// Position of TCE field.
	RTC_SR_TCE_Pos = 0x4
	// Bit mask of TCE field.
	RTC_SR_TCE_Msk = 0x10
	// Bit TCE.
	RTC_SR_TCE = 0x10
	// Time counter is disabled.
	RTC_SR_TCE_0 = 0x0
	// Time counter is enabled.
	RTC_SR_TCE_1 = 0x1

	// LR: RTC Lock Register
	// Position of TCL field.
	RTC_LR_TCL_Pos = 0x3
	// Bit mask of TCL field.
	RTC_LR_TCL_Msk = 0x8
	// Bit TCL.
	RTC_LR_TCL = 0x8
	// Time Compensation Register is locked and writes are ignored.
	RTC_LR_TCL_0 = 0x0
	// Time Compensation Register is not locked and writes complete as normal.
	RTC_LR_TCL_1 = 0x1
	// Position of CRL field.
	RTC_LR_CRL_Pos = 0x4
	// Bit mask of CRL field.
	RTC_LR_CRL_Msk = 0x10
	// Bit CRL.
	RTC_LR_CRL = 0x10
	// Control Register is locked and writes are ignored.
	RTC_LR_CRL_0 = 0x0
	// Control Register is not locked and writes complete as normal.
	RTC_LR_CRL_1 = 0x1
	// Position of SRL field.
	RTC_LR_SRL_Pos = 0x5
	// Bit mask of SRL field.
	RTC_LR_SRL_Msk = 0x20
	// Bit SRL.
	RTC_LR_SRL = 0x20
	// Status Register is locked and writes are ignored.
	RTC_LR_SRL_0 = 0x0
	// Status Register is not locked and writes complete as normal.
	RTC_LR_SRL_1 = 0x1
	// Position of LRL field.
	RTC_LR_LRL_Pos = 0x6
	// Bit mask of LRL field.
	RTC_LR_LRL_Msk = 0x40
	// Bit LRL.
	RTC_LR_LRL = 0x40
	// Lock Register is locked and writes are ignored.
	RTC_LR_LRL_0 = 0x0
	// Lock Register is not locked and writes complete as normal.
	RTC_LR_LRL_1 = 0x1

	// IER: RTC Interrupt Enable Register
	// Position of TIIE field.
	RTC_IER_TIIE_Pos = 0x0
	// Bit mask of TIIE field.
	RTC_IER_TIIE_Msk = 0x1
	// Bit TIIE.
	RTC_IER_TIIE = 0x1
	// Time invalid flag does not generate an interrupt.
	RTC_IER_TIIE_0 = 0x0
	// Time invalid flag does generate an interrupt.
	RTC_IER_TIIE_1 = 0x1
	// Position of TOIE field.
	RTC_IER_TOIE_Pos = 0x1
	// Bit mask of TOIE field.
	RTC_IER_TOIE_Msk = 0x2
	// Bit TOIE.
	RTC_IER_TOIE = 0x2
	// Time overflow flag does not generate an interrupt.
	RTC_IER_TOIE_0 = 0x0
	// Time overflow flag does generate an interrupt.
	RTC_IER_TOIE_1 = 0x1
	// Position of TAIE field.
	RTC_IER_TAIE_Pos = 0x2
	// Bit mask of TAIE field.
	RTC_IER_TAIE_Msk = 0x4
	// Bit TAIE.
	RTC_IER_TAIE = 0x4
	// Time alarm flag does not generate an interrupt.
	RTC_IER_TAIE_0 = 0x0
	// Time alarm flag does generate an interrupt.
	RTC_IER_TAIE_1 = 0x1
	// Position of TSIE field.
	RTC_IER_TSIE_Pos = 0x4
	// Bit mask of TSIE field.
	RTC_IER_TSIE_Msk = 0x10
	// Bit TSIE.
	RTC_IER_TSIE = 0x10
	// Seconds interrupt is disabled.
	RTC_IER_TSIE_0 = 0x0
	// Seconds interrupt is enabled.
	RTC_IER_TSIE_1 = 0x1
	// Position of WPON field.
	RTC_IER_WPON_Pos = 0x7
	// Bit mask of WPON field.
	RTC_IER_WPON_Msk = 0x80
	// Bit WPON.
	RTC_IER_WPON = 0x80
	// No effect.
	RTC_IER_WPON_0 = 0x0
	// If the wakeup pin is enabled, then the wakeup pin will assert.
	RTC_IER_WPON_1 = 0x1

	// WAR: RTC Write Access Register
	// Position of TSRW field.
	RTC_WAR_TSRW_Pos = 0x0
	// Bit mask of TSRW field.
	RTC_WAR_TSRW_Msk = 0x1
	// Bit TSRW.
	RTC_WAR_TSRW = 0x1
	// Writes to the Time Seconds Register are ignored.
	RTC_WAR_TSRW_0 = 0x0
	// Writes to the Time Seconds Register complete as normal.
	RTC_WAR_TSRW_1 = 0x1
	// Position of TPRW field.
	RTC_WAR_TPRW_Pos = 0x1
	// Bit mask of TPRW field.
	RTC_WAR_TPRW_Msk = 0x2
	// Bit TPRW.
	RTC_WAR_TPRW = 0x2
	// Writes to the Time Prescaler Register are ignored.
	RTC_WAR_TPRW_0 = 0x0
	// Writes to the Time Prescaler Register complete as normal.
	RTC_WAR_TPRW_1 = 0x1
	// Position of TARW field.
	RTC_WAR_TARW_Pos = 0x2
	// Bit mask of TARW field.
	RTC_WAR_TARW_Msk = 0x4
	// Bit TARW.
	RTC_WAR_TARW = 0x4
	// Writes to the Time Alarm Register are ignored.
	RTC_WAR_TARW_0 = 0x0
	// Writes to the Time Alarm Register complete as normal.
	RTC_WAR_TARW_1 = 0x1
	// Position of TCRW field.
	RTC_WAR_TCRW_Pos = 0x3
	// Bit mask of TCRW field.
	RTC_WAR_TCRW_Msk = 0x8
	// Bit TCRW.
	RTC_WAR_TCRW = 0x8
	// Writes to the Time Compensation Register are ignored.
	RTC_WAR_TCRW_0 = 0x0
	// Writes to the Time Compensation Register complete as normal.
	RTC_WAR_TCRW_1 = 0x1
	// Position of CRW field.
	RTC_WAR_CRW_Pos = 0x4
	// Bit mask of CRW field.
	RTC_WAR_CRW_Msk = 0x10
	// Bit CRW.
	RTC_WAR_CRW = 0x10
	// Writes to the Control Register are ignored.
	RTC_WAR_CRW_0 = 0x0
	// Writes to the Control Register complete as normal.
	RTC_WAR_CRW_1 = 0x1
	// Position of SRW field.
	RTC_WAR_SRW_Pos = 0x5
	// Bit mask of SRW field.
	RTC_WAR_SRW_Msk = 0x20
	// Bit SRW.
	RTC_WAR_SRW = 0x20
	// Writes to the Status Register are ignored.
	RTC_WAR_SRW_0 = 0x0
	// Writes to the Status Register complete as normal.
	RTC_WAR_SRW_1 = 0x1
	// Position of LRW field.
	RTC_WAR_LRW_Pos = 0x6
	// Bit mask of LRW field.
	RTC_WAR_LRW_Msk = 0x40
	// Bit LRW.
	RTC_WAR_LRW = 0x40
	// Writes to the Lock Register are ignored.
	RTC_WAR_LRW_0 = 0x0
	// Writes to the Lock Register complete as normal.
	RTC_WAR_LRW_1 = 0x1
	// Position of IERW field.
	RTC_WAR_IERW_Pos = 0x7
	// Bit mask of IERW field.
	RTC_WAR_IERW_Msk = 0x80
	// Bit IERW.
	RTC_WAR_IERW = 0x80
	// Writes to the Interupt Enable Register are ignored.
	RTC_WAR_IERW_0 = 0x0
	// Writes to the Interrupt Enable Register complete as normal.
	RTC_WAR_IERW_1 = 0x1

	// RAR: RTC Read Access Register
	// Position of TSRR field.
	RTC_RAR_TSRR_Pos = 0x0
	// Bit mask of TSRR field.
	RTC_RAR_TSRR_Msk = 0x1
	// Bit TSRR.
	RTC_RAR_TSRR = 0x1
	// Reads to the Time Seconds Register are ignored.
	RTC_RAR_TSRR_0 = 0x0
	// Reads to the Time Seconds Register complete as normal.
	RTC_RAR_TSRR_1 = 0x1
	// Position of TPRR field.
	RTC_RAR_TPRR_Pos = 0x1
	// Bit mask of TPRR field.
	RTC_RAR_TPRR_Msk = 0x2
	// Bit TPRR.
	RTC_RAR_TPRR = 0x2
	// Reads to the Time Pprescaler Register are ignored.
	RTC_RAR_TPRR_0 = 0x0
	// Reads to the Time Prescaler Register complete as normal.
	RTC_RAR_TPRR_1 = 0x1
	// Position of TARR field.
	RTC_RAR_TARR_Pos = 0x2
	// Bit mask of TARR field.
	RTC_RAR_TARR_Msk = 0x4
	// Bit TARR.
	RTC_RAR_TARR = 0x4
	// Reads to the Time Alarm Register are ignored.
	RTC_RAR_TARR_0 = 0x0
	// Reads to the Time Alarm Register complete as normal.
	RTC_RAR_TARR_1 = 0x1
	// Position of TCRR field.
	RTC_RAR_TCRR_Pos = 0x3
	// Bit mask of TCRR field.
	RTC_RAR_TCRR_Msk = 0x8
	// Bit TCRR.
	RTC_RAR_TCRR = 0x8
	// Reads to the Time Compensation Register are ignored.
	RTC_RAR_TCRR_0 = 0x0
	// Reads to the Time Compensation Register complete as normal.
	RTC_RAR_TCRR_1 = 0x1
	// Position of CRR field.
	RTC_RAR_CRR_Pos = 0x4
	// Bit mask of CRR field.
	RTC_RAR_CRR_Msk = 0x10
	// Bit CRR.
	RTC_RAR_CRR = 0x10
	// Reads to the Control Register are ignored.
	RTC_RAR_CRR_0 = 0x0
	// Reads to the Control Register complete as normal.
	RTC_RAR_CRR_1 = 0x1
	// Position of SRR field.
	RTC_RAR_SRR_Pos = 0x5
	// Bit mask of SRR field.
	RTC_RAR_SRR_Msk = 0x20
	// Bit SRR.
	RTC_RAR_SRR = 0x20
	// Reads to the Status Register are ignored.
	RTC_RAR_SRR_0 = 0x0
	// Reads to the Status Register complete as normal.
	RTC_RAR_SRR_1 = 0x1
	// Position of LRR field.
	RTC_RAR_LRR_Pos = 0x6
	// Bit mask of LRR field.
	RTC_RAR_LRR_Msk = 0x40
	// Bit LRR.
	RTC_RAR_LRR = 0x40
	// Reads to the Lock Register are ignored.
	RTC_RAR_LRR_0 = 0x0
	// Reads to the Lock Register complete as normal.
	RTC_RAR_LRR_1 = 0x1
	// Position of IERR field.
	RTC_RAR_IERR_Pos = 0x7
	// Bit mask of IERR field.
	RTC_RAR_IERR_Msk = 0x80
	// Bit IERR.
	RTC_RAR_IERR = 0x80
	// Reads to the Interrupt Enable Register are ignored.
	RTC_RAR_IERR_0 = 0x0
	// Reads to the Interrupt Enable Register complete as normal.
	RTC_RAR_IERR_1 = 0x1
)

// Constants for RFVBAT: VBAT register file
const (
	// REG0: VBAT register file register
	// Position of LL field.
	RFVBAT_REG_LL_Pos = 0x0
	// Bit mask of LL field.
	RFVBAT_REG_LL_Msk = 0xff
	// Position of LH field.
	RFVBAT_REG_LH_Pos = 0x8
	// Bit mask of LH field.
	RFVBAT_REG_LH_Msk = 0xff00
	// Position of HL field.
	RFVBAT_REG_HL_Pos = 0x10
	// Bit mask of HL field.
	RFVBAT_REG_HL_Msk = 0xff0000
	// Position of HH field.
	RFVBAT_REG_HH_Pos = 0x18
	// Bit mask of HH field.
	RFVBAT_REG_HH_Msk = 0xff000000
)

// Constants for LPTMR0: Low Power Timer
const (
	// CSR: Low Power Timer Control Status Register
	// Position of TEN field.
	LPTMR0_CSR_TEN_Pos = 0x0
	// Bit mask of TEN field.
	LPTMR0_CSR_TEN_Msk = 0x1
	// Bit TEN.
	LPTMR0_CSR_TEN = 0x1
	// LPTMR is disabled and internal logic is reset.
	LPTMR0_CSR_TEN_0 = 0x0
	// LPTMR is enabled.
	LPTMR0_CSR_TEN_1 = 0x1
	// Position of TMS field.
	LPTMR0_CSR_TMS_Pos = 0x1
	// Bit mask of TMS field.
	LPTMR0_CSR_TMS_Msk = 0x2
	// Bit TMS.
	LPTMR0_CSR_TMS = 0x2
	// Time Counter mode.
	LPTMR0_CSR_TMS_0 = 0x0
	// Pulse Counter mode.
	LPTMR0_CSR_TMS_1 = 0x1
	// Position of TFC field.
	LPTMR0_CSR_TFC_Pos = 0x2
	// Bit mask of TFC field.
	LPTMR0_CSR_TFC_Msk = 0x4
	// Bit TFC.
	LPTMR0_CSR_TFC = 0x4
	// CNR is reset whenever TCF is set.
	LPTMR0_CSR_TFC_0 = 0x0
	// CNR is reset on overflow.
	LPTMR0_CSR_TFC_1 = 0x1
	// Position of TPP field.
	LPTMR0_CSR_TPP_Pos = 0x3
	// Bit mask of TPP field.
	LPTMR0_CSR_TPP_Msk = 0x8
	// Bit TPP.
	LPTMR0_CSR_TPP = 0x8
	// Pulse Counter input source is active-high, and the CNR will increment on the rising-edge.
	LPTMR0_CSR_TPP_0 = 0x0
	// Pulse Counter input source is active-low, and the CNR will increment on the falling-edge.
	LPTMR0_CSR_TPP_1 = 0x1
	// Position of TPS field.
	LPTMR0_CSR_TPS_Pos = 0x4
	// Bit mask of TPS field.
	LPTMR0_CSR_TPS_Msk = 0x30
	// Pulse counter input 0 is selected.
	LPTMR0_CSR_TPS_00 = 0x0
	// Pulse counter input 1 is selected.
	LPTMR0_CSR_TPS_01 = 0x1
	// Pulse counter input 2 is selected.
	LPTMR0_CSR_TPS_10 = 0x2
	// Pulse counter input 3 is selected.
	LPTMR0_CSR_TPS_11 = 0x3
	// Position of TIE field.
	LPTMR0_CSR_TIE_Pos = 0x6
	// Bit mask of TIE field.
	LPTMR0_CSR_TIE_Msk = 0x40
	// Bit TIE.
	LPTMR0_CSR_TIE = 0x40
	// Timer interrupt disabled.
	LPTMR0_CSR_TIE_0 = 0x0
	// Timer interrupt enabled.
	LPTMR0_CSR_TIE_1 = 0x1
	// Position of TCF field.
	LPTMR0_CSR_TCF_Pos = 0x7
	// Bit mask of TCF field.
	LPTMR0_CSR_TCF_Msk = 0x80
	// Bit TCF.
	LPTMR0_CSR_TCF = 0x80
	// The value of CNR is not equal to CMR and increments.
	LPTMR0_CSR_TCF_0 = 0x0
	// The value of CNR is equal to CMR and increments.
	LPTMR0_CSR_TCF_1 = 0x1

	// PSR: Low Power Timer Prescale Register
	// Position of PCS field.
	LPTMR0_PSR_PCS_Pos = 0x0
	// Bit mask of PCS field.
	LPTMR0_PSR_PCS_Msk = 0x3
	// Prescaler/glitch filter clock 0 selected.
	LPTMR0_PSR_PCS_00 = 0x0
	// Prescaler/glitch filter clock 1 selected.
	LPTMR0_PSR_PCS_01 = 0x1
	// Prescaler/glitch filter clock 2 selected.
	LPTMR0_PSR_PCS_10 = 0x2
	// Prescaler/glitch filter clock 3 selected.
	LPTMR0_PSR_PCS_11 = 0x3
	// Position of PBYP field.
	LPTMR0_PSR_PBYP_Pos = 0x2
	// Bit mask of PBYP field.
	LPTMR0_PSR_PBYP_Msk = 0x4
	// Bit PBYP.
	LPTMR0_PSR_PBYP = 0x4
	// Prescaler/glitch filter is enabled.
	LPTMR0_PSR_PBYP_0 = 0x0
	// Prescaler/glitch filter is bypassed.
	LPTMR0_PSR_PBYP_1 = 0x1
	// Position of PRESCALE field.
	LPTMR0_PSR_PRESCALE_Pos = 0x3
	// Bit mask of PRESCALE field.
	LPTMR0_PSR_PRESCALE_Msk = 0x78
	// Prescaler divides the prescaler clock by 2; glitch filter does not support this configuration.
	LPTMR0_PSR_PRESCALE_0000 = 0x0
	// Prescaler divides the prescaler clock by 4; glitch filter recognizes change on input pin after 2 rising clock edges.
	LPTMR0_PSR_PRESCALE_0001 = 0x1
	// Prescaler divides the prescaler clock by 8; glitch filter recognizes change on input pin after 4 rising clock edges.
	LPTMR0_PSR_PRESCALE_0010 = 0x2
	// Prescaler divides the prescaler clock by 16; glitch filter recognizes change on input pin after 8 rising clock edges.
	LPTMR0_PSR_PRESCALE_0011 = 0x3
	// Prescaler divides the prescaler clock by 32; glitch filter recognizes change on input pin after 16 rising clock edges.
	LPTMR0_PSR_PRESCALE_0100 = 0x4
	// Prescaler divides the prescaler clock by 64; glitch filter recognizes change on input pin after 32 rising clock edges.
	LPTMR0_PSR_PRESCALE_0101 = 0x5
	// Prescaler divides the prescaler clock by 128; glitch filter recognizes change on input pin after 64 rising clock edges.
	LPTMR0_PSR_PRESCALE_0110 = 0x6
	// Prescaler divides the prescaler clock by 256; glitch filter recognizes change on input pin after 128 rising clock edges.
	LPTMR0_PSR_PRESCALE_0111 = 0x7
	// Prescaler divides the prescaler clock by 512; glitch filter recognizes change on input pin after 256 rising clock edges.
	LPTMR0_PSR_PRESCALE_1000 = 0x8
	// Prescaler divides the prescaler clock by 1024; glitch filter recognizes change on input pin after 512 rising clock edges.
	LPTMR0_PSR_PRESCALE_1001 = 0x9
	// Prescaler divides the prescaler clock by 2048; glitch filter recognizes change on input pin after 1024 rising clock edges.
	LPTMR0_PSR_PRESCALE_1010 = 0xa
	// Prescaler divides the prescaler clock by 4096; glitch filter recognizes change on input pin after 2048 rising clock edges.
	LPTMR0_PSR_PRESCALE_1011 = 0xb
	// Prescaler divides the prescaler clock by 8192; glitch filter recognizes change on input pin after 4096 rising clock edges.
	LPTMR0_PSR_PRESCALE_1100 = 0xc
	// Prescaler divides the prescaler clock by 16,384; glitch filter recognizes change on input pin after 8192 rising clock edges.
	LPTMR0_PSR_PRESCALE_1101 = 0xd
	// Prescaler divides the prescaler clock by 32,768; glitch filter recognizes change on input pin after 16,384 rising clock edges.
	LPTMR0_PSR_PRESCALE_1110 = 0xe
	// Prescaler divides the prescaler clock by 65,536; glitch filter recognizes change on input pin after 32,768 rising clock edges.
	LPTMR0_PSR_PRESCALE_1111 = 0xf

	// CMR: Low Power Timer Compare Register
	// Position of COMPARE field.
	LPTMR0_CMR_COMPARE_Pos = 0x0
	// Bit mask of COMPARE field.
	LPTMR0_CMR_COMPARE_Msk = 0xffff

	// CNR: Low Power Timer Counter Register
	// Position of COUNTER field.
	LPTMR0_CNR_COUNTER_Pos = 0x0
	// Bit mask of COUNTER field.
	LPTMR0_CNR_COUNTER_Msk = 0xffff
)

// Constants for RFSYS: System register file
const (
	// REG0: Register file register
	// Position of LL field.
	RFSYS_REG_LL_Pos = 0x0
	// Bit mask of LL field.
	RFSYS_REG_LL_Msk = 0xff
	// Position of LH field.
	RFSYS_REG_LH_Pos = 0x8
	// Bit mask of LH field.
	RFSYS_REG_LH_Msk = 0xff00
	// Position of HL field.
	RFSYS_REG_HL_Pos = 0x10
	// Bit mask of HL field.
	RFSYS_REG_HL_Msk = 0xff0000
	// Position of HH field.
	RFSYS_REG_HH_Pos = 0x18
	// Bit mask of HH field.
	RFSYS_REG_HH_Msk = 0xff000000
)

// Constants for SIM: System Integration Module
const (
	// SOPT1: System Options Register 1
	// Position of RAMSIZE field.
	SIM_SOPT1_RAMSIZE_Pos = 0xc
	// Bit mask of RAMSIZE field.
	SIM_SOPT1_RAMSIZE_Msk = 0xf000
	// 8 KB
	SIM_SOPT1_RAMSIZE_0001 = 0x1
	// 16 KB
	SIM_SOPT1_RAMSIZE_0011 = 0x3
	// 24 KB
	SIM_SOPT1_RAMSIZE_0100 = 0x4
	// 32 KB
	SIM_SOPT1_RAMSIZE_0101 = 0x5
	// 48 KB
	SIM_SOPT1_RAMSIZE_0110 = 0x6
	// 64 KB
	SIM_SOPT1_RAMSIZE_0111 = 0x7
	// 96 KB
	SIM_SOPT1_RAMSIZE_1000 = 0x8
	// 128 KB
	SIM_SOPT1_RAMSIZE_1001 = 0x9
	// 256 KB
	SIM_SOPT1_RAMSIZE_1011 = 0xb
	// Position of OSC32KSEL field.
	SIM_SOPT1_OSC32KSEL_Pos = 0x12
	// Bit mask of OSC32KSEL field.
	SIM_SOPT1_OSC32KSEL_Msk = 0xc0000
	// System oscillator (OSC32KCLK)
	SIM_SOPT1_OSC32KSEL_00 = 0x0
	// RTC 32.768kHz oscillator
	SIM_SOPT1_OSC32KSEL_10 = 0x2
	// LPO 1 kHz
	SIM_SOPT1_OSC32KSEL_11 = 0x3
	// Position of USBVSTBY field.
	SIM_SOPT1_USBVSTBY_Pos = 0x1d
	// Bit mask of USBVSTBY field.
	SIM_SOPT1_USBVSTBY_Msk = 0x20000000
	// Bit USBVSTBY.
	SIM_SOPT1_USBVSTBY = 0x20000000
	// USB voltage regulator not in standby during VLPR and VLPW modes.
	SIM_SOPT1_USBVSTBY_0 = 0x0
	// USB voltage regulator in standby during VLPR and VLPW modes.
	SIM_SOPT1_USBVSTBY_1 = 0x1
	// Position of USBSSTBY field.
	SIM_SOPT1_USBSSTBY_Pos = 0x1e
	// Bit mask of USBSSTBY field.
	SIM_SOPT1_USBSSTBY_Msk = 0x40000000
	// Bit USBSSTBY.
	SIM_SOPT1_USBSSTBY = 0x40000000
	// USB voltage regulator not in standby during Stop, VLPS, LLS and VLLS modes.
	SIM_SOPT1_USBSSTBY_0 = 0x0
	// USB voltage regulator in standby during Stop, VLPS, LLS and VLLS modes.
	SIM_SOPT1_USBSSTBY_1 = 0x1
	// Position of USBREGEN field.
	SIM_SOPT1_USBREGEN_Pos = 0x1f
	// Bit mask of USBREGEN field.
	SIM_SOPT1_USBREGEN_Msk = 0x80000000
	// Bit USBREGEN.
	SIM_SOPT1_USBREGEN = 0x80000000
	// USB voltage regulator is disabled.
	SIM_SOPT1_USBREGEN_0 = 0x0
	// USB voltage regulator is enabled.
	SIM_SOPT1_USBREGEN_1 = 0x1

	// SOPT1CFG: SOPT1 Configuration Register
	// Position of URWE field.
	SIM_SOPT1CFG_URWE_Pos = 0x18
	// Bit mask of URWE field.
	SIM_SOPT1CFG_URWE_Msk = 0x1000000
	// Bit URWE.
	SIM_SOPT1CFG_URWE = 0x1000000
	// SOPT1 USBREGEN cannot be written.
	SIM_SOPT1CFG_URWE_0 = 0x0
	// SOPT1 USBREGEN can be written.
	SIM_SOPT1CFG_URWE_1 = 0x1
	// Position of UVSWE field.
	SIM_SOPT1CFG_UVSWE_Pos = 0x19
	// Bit mask of UVSWE field.
	SIM_SOPT1CFG_UVSWE_Msk = 0x2000000
	// Bit UVSWE.
	SIM_SOPT1CFG_UVSWE = 0x2000000
	// SOPT1 USBVSTBY cannot be written.
	SIM_SOPT1CFG_UVSWE_0 = 0x0
	// SOPT1 USBVSTBY can be written.
	SIM_SOPT1CFG_UVSWE_1 = 0x1
	// Position of USSWE field.
	SIM_SOPT1CFG_USSWE_Pos = 0x1a
	// Bit mask of USSWE field.
	SIM_SOPT1CFG_USSWE_Msk = 0x4000000
	// Bit USSWE.
	SIM_SOPT1CFG_USSWE = 0x4000000
	// SOPT1 USBSSTBY cannot be written.
	SIM_SOPT1CFG_USSWE_0 = 0x0
	// SOPT1 USBSSTBY can be written.
	SIM_SOPT1CFG_USSWE_1 = 0x1

	// SOPT2: System Options Register 2
	// Position of RTCCLKOUTSEL field.
	SIM_SOPT2_RTCCLKOUTSEL_Pos = 0x4
	// Bit mask of RTCCLKOUTSEL field.
	SIM_SOPT2_RTCCLKOUTSEL_Msk = 0x10
	// Bit RTCCLKOUTSEL.
	SIM_SOPT2_RTCCLKOUTSEL = 0x10
	// RTC 1 Hz clock is output on the RTC_CLKOUT pin.
	SIM_SOPT2_RTCCLKOUTSEL_0 = 0x0
	// RTC 32.768kHz clock is output on the RTC_CLKOUT pin.
	SIM_SOPT2_RTCCLKOUTSEL_1 = 0x1
	// Position of CLKOUTSEL field.
	SIM_SOPT2_CLKOUTSEL_Pos = 0x5
	// Bit mask of CLKOUTSEL field.
	SIM_SOPT2_CLKOUTSEL_Msk = 0xe0
	// FlexBus CLKOUT
	SIM_SOPT2_CLKOUTSEL_000 = 0x0
	// Flash clock
	SIM_SOPT2_CLKOUTSEL_010 = 0x2
	// LPO clock (1 kHz)
	SIM_SOPT2_CLKOUTSEL_011 = 0x3
	// MCGIRCLK
	SIM_SOPT2_CLKOUTSEL_100 = 0x4
	// RTC 32.768kHz clock
	SIM_SOPT2_CLKOUTSEL_101 = 0x5
	// OSCERCLK0
	SIM_SOPT2_CLKOUTSEL_110 = 0x6
	// IRC 48 MHz clock
	SIM_SOPT2_CLKOUTSEL_111 = 0x7
	// Position of FBSL field.
	SIM_SOPT2_FBSL_Pos = 0x8
	// Bit mask of FBSL field.
	SIM_SOPT2_FBSL_Msk = 0x300
	// All off-chip accesses (instruction and data) via the FlexBus are disallowed.
	SIM_SOPT2_FBSL_00 = 0x0
	// All off-chip accesses (instruction and data) via the FlexBus are disallowed.
	SIM_SOPT2_FBSL_01 = 0x1
	// Off-chip instruction accesses are disallowed. Data accesses are allowed.
	SIM_SOPT2_FBSL_10 = 0x2
	// Off-chip instruction accesses and data accesses are allowed.
	SIM_SOPT2_FBSL_11 = 0x3
	// Position of PTD7PAD field.
	SIM_SOPT2_PTD7PAD_Pos = 0xb
	// Bit mask of PTD7PAD field.
	SIM_SOPT2_PTD7PAD_Msk = 0x800
	// Bit PTD7PAD.
	SIM_SOPT2_PTD7PAD = 0x800
	// Single-pad drive strength for PTD7.
	SIM_SOPT2_PTD7PAD_0 = 0x0
	// Double pad drive strength for PTD7.
	SIM_SOPT2_PTD7PAD_1 = 0x1
	// Position of TRACECLKSEL field.
	SIM_SOPT2_TRACECLKSEL_Pos = 0xc
	// Bit mask of TRACECLKSEL field.
	SIM_SOPT2_TRACECLKSEL_Msk = 0x1000
	// Bit TRACECLKSEL.
	SIM_SOPT2_TRACECLKSEL = 0x1000
	// MCGOUTCLK
	SIM_SOPT2_TRACECLKSEL_0 = 0x0
	// Core/system clock
	SIM_SOPT2_TRACECLKSEL_1 = 0x1
	// Position of PLLFLLSEL field.
	SIM_SOPT2_PLLFLLSEL_Pos = 0x10
	// Bit mask of PLLFLLSEL field.
	SIM_SOPT2_PLLFLLSEL_Msk = 0x30000
	// MCGFLLCLK clock
	SIM_SOPT2_PLLFLLSEL_00 = 0x0
	// MCGPLLCLK clock
	SIM_SOPT2_PLLFLLSEL_01 = 0x1
	// IRC48 MHz clock
	SIM_SOPT2_PLLFLLSEL_11 = 0x3
	// Position of USBSRC field.
	SIM_SOPT2_USBSRC_Pos = 0x12
	// Bit mask of USBSRC field.
	SIM_SOPT2_USBSRC_Msk = 0x40000
	// Bit USBSRC.
	SIM_SOPT2_USBSRC = 0x40000
	// External bypass clock (USB_CLKIN).
	SIM_SOPT2_USBSRC_0 = 0x0
	// MCGFLLCLK , or MCGPLLCLK , or IRC48M clock as selected by SOPT2[PLLFLLSEL], and then divided by the USB fractional divider as configured by SIM_CLKDIV2[USBFRAC, USBDIV].
	SIM_SOPT2_USBSRC_1 = 0x1
	// Position of RMIISRC field.
	SIM_SOPT2_RMIISRC_Pos = 0x13
	// Bit mask of RMIISRC field.
	SIM_SOPT2_RMIISRC_Msk = 0x80000
	// Bit RMIISRC.
	SIM_SOPT2_RMIISRC = 0x80000
	// EXTAL clock
	SIM_SOPT2_RMIISRC_0 = 0x0
	// External bypass clock (ENET_1588_CLKIN).
	SIM_SOPT2_RMIISRC_1 = 0x1
	// Position of TIMESRC field.
	SIM_SOPT2_TIMESRC_Pos = 0x14
	// Bit mask of TIMESRC field.
	SIM_SOPT2_TIMESRC_Msk = 0x300000
	// Core/system clock.
	SIM_SOPT2_TIMESRC_00 = 0x0
	// MCGFLLCLK , or MCGPLLCLK , or IRC48M clock as selected by SOPT2[PLLFLLSEL].
	SIM_SOPT2_TIMESRC_01 = 0x1
	// OSCERCLK clock
	SIM_SOPT2_TIMESRC_10 = 0x2
	// External bypass clock (ENET_1588_CLKIN).
	SIM_SOPT2_TIMESRC_11 = 0x3
	// Position of SDHCSRC field.
	SIM_SOPT2_SDHCSRC_Pos = 0x1c
	// Bit mask of SDHCSRC field.
	SIM_SOPT2_SDHCSRC_Msk = 0x30000000
	// Core/system clock.
	SIM_SOPT2_SDHCSRC_00 = 0x0
	// MCGFLLCLK, or MCGPLLCLK , or IRC48M clock as selected by SOPT2[PLLFLLSEL].
	SIM_SOPT2_SDHCSRC_01 = 0x1
	// OSCERCLK clock
	SIM_SOPT2_SDHCSRC_10 = 0x2
	// External bypass clock (SDHC0_CLKIN)
	SIM_SOPT2_SDHCSRC_11 = 0x3

	// SOPT4: System Options Register 4
	// Position of FTM0FLT0 field.
	SIM_SOPT4_FTM0FLT0_Pos = 0x0
	// Bit mask of FTM0FLT0 field.
	SIM_SOPT4_FTM0FLT0_Msk = 0x1
	// Bit FTM0FLT0.
	SIM_SOPT4_FTM0FLT0 = 0x1
	// FTM0_FLT0 pin
	SIM_SOPT4_FTM0FLT0_0 = 0x0
	// CMP0 out
	SIM_SOPT4_FTM0FLT0_1 = 0x1
	// Position of FTM0FLT1 field.
	SIM_SOPT4_FTM0FLT1_Pos = 0x1
	// Bit mask of FTM0FLT1 field.
	SIM_SOPT4_FTM0FLT1_Msk = 0x2
	// Bit FTM0FLT1.
	SIM_SOPT4_FTM0FLT1 = 0x2
	// FTM0_FLT1 pin
	SIM_SOPT4_FTM0FLT1_0 = 0x0
	// CMP1 out
	SIM_SOPT4_FTM0FLT1_1 = 0x1
	// Position of FTM0FLT2 field.
	SIM_SOPT4_FTM0FLT2_Pos = 0x2
	// Bit mask of FTM0FLT2 field.
	SIM_SOPT4_FTM0FLT2_Msk = 0x4
	// Bit FTM0FLT2.
	SIM_SOPT4_FTM0FLT2 = 0x4
	// FTM0_FLT2 pin
	SIM_SOPT4_FTM0FLT2_0 = 0x0
	// CMP2 out
	SIM_SOPT4_FTM0FLT2_1 = 0x1
	// Position of FTM1FLT0 field.
	SIM_SOPT4_FTM1FLT0_Pos = 0x4
	// Bit mask of FTM1FLT0 field.
	SIM_SOPT4_FTM1FLT0_Msk = 0x10
	// Bit FTM1FLT0.
	SIM_SOPT4_FTM1FLT0 = 0x10
	// FTM1_FLT0 pin
	SIM_SOPT4_FTM1FLT0_0 = 0x0
	// CMP0 out
	SIM_SOPT4_FTM1FLT0_1 = 0x1
	// Position of FTM2FLT0 field.
	SIM_SOPT4_FTM2FLT0_Pos = 0x8
	// Bit mask of FTM2FLT0 field.
	SIM_SOPT4_FTM2FLT0_Msk = 0x100
	// Bit FTM2FLT0.
	SIM_SOPT4_FTM2FLT0 = 0x100
	// FTM2_FLT0 pin
	SIM_SOPT4_FTM2FLT0_0 = 0x0
	// CMP0 out
	SIM_SOPT4_FTM2FLT0_1 = 0x1
	// Position of FTM3FLT0 field.
	SIM_SOPT4_FTM3FLT0_Pos = 0xc
	// Bit mask of FTM3FLT0 field.
	SIM_SOPT4_FTM3FLT0_Msk = 0x1000
	// Bit FTM3FLT0.
	SIM_SOPT4_FTM3FLT0 = 0x1000
	// FTM3_FLT0 pin
	SIM_SOPT4_FTM3FLT0_0 = 0x0
	// CMP0 out
	SIM_SOPT4_FTM3FLT0_1 = 0x1
	// Position of FTM1CH0SRC field.
	SIM_SOPT4_FTM1CH0SRC_Pos = 0x12
	// Bit mask of FTM1CH0SRC field.
	SIM_SOPT4_FTM1CH0SRC_Msk = 0xc0000
	// FTM1_CH0 signal
	SIM_SOPT4_FTM1CH0SRC_00 = 0x0
	// CMP0 output
	SIM_SOPT4_FTM1CH0SRC_01 = 0x1
	// CMP1 output
	SIM_SOPT4_FTM1CH0SRC_10 = 0x2
	// USB start of frame pulse
	SIM_SOPT4_FTM1CH0SRC_11 = 0x3
	// Position of FTM2CH0SRC field.
	SIM_SOPT4_FTM2CH0SRC_Pos = 0x14
	// Bit mask of FTM2CH0SRC field.
	SIM_SOPT4_FTM2CH0SRC_Msk = 0x300000
	// FTM2_CH0 signal
	SIM_SOPT4_FTM2CH0SRC_00 = 0x0
	// CMP0 output
	SIM_SOPT4_FTM2CH0SRC_01 = 0x1
	// CMP1 output
	SIM_SOPT4_FTM2CH0SRC_10 = 0x2
	// Position of FTM0CLKSEL field.
	SIM_SOPT4_FTM0CLKSEL_Pos = 0x18
	// Bit mask of FTM0CLKSEL field.
	SIM_SOPT4_FTM0CLKSEL_Msk = 0x1000000
	// Bit FTM0CLKSEL.
	SIM_SOPT4_FTM0CLKSEL = 0x1000000
	// FTM_CLK0 pin
	SIM_SOPT4_FTM0CLKSEL_0 = 0x0
	// FTM_CLK1 pin
	SIM_SOPT4_FTM0CLKSEL_1 = 0x1
	// Position of FTM1CLKSEL field.
	SIM_SOPT4_FTM1CLKSEL_Pos = 0x19
	// Bit mask of FTM1CLKSEL field.
	SIM_SOPT4_FTM1CLKSEL_Msk = 0x2000000
	// Bit FTM1CLKSEL.
	SIM_SOPT4_FTM1CLKSEL = 0x2000000
	// FTM_CLK0 pin
	SIM_SOPT4_FTM1CLKSEL_0 = 0x0
	// FTM_CLK1 pin
	SIM_SOPT4_FTM1CLKSEL_1 = 0x1
	// Position of FTM2CLKSEL field.
	SIM_SOPT4_FTM2CLKSEL_Pos = 0x1a
	// Bit mask of FTM2CLKSEL field.
	SIM_SOPT4_FTM2CLKSEL_Msk = 0x4000000
	// Bit FTM2CLKSEL.
	SIM_SOPT4_FTM2CLKSEL = 0x4000000
	// FTM2 external clock driven by FTM_CLK0 pin.
	SIM_SOPT4_FTM2CLKSEL_0 = 0x0
	// FTM2 external clock driven by FTM_CLK1 pin.
	SIM_SOPT4_FTM2CLKSEL_1 = 0x1
	// Position of FTM3CLKSEL field.
	SIM_SOPT4_FTM3CLKSEL_Pos = 0x1b
	// Bit mask of FTM3CLKSEL field.
	SIM_SOPT4_FTM3CLKSEL_Msk = 0x8000000
	// Bit FTM3CLKSEL.
	SIM_SOPT4_FTM3CLKSEL = 0x8000000
	// FTM3 external clock driven by FTM_CLK0 pin.
	SIM_SOPT4_FTM3CLKSEL_0 = 0x0
	// FTM3 external clock driven by FTM_CLK1 pin.
	SIM_SOPT4_FTM3CLKSEL_1 = 0x1
	// Position of FTM0TRG0SRC field.
	SIM_SOPT4_FTM0TRG0SRC_Pos = 0x1c
	// Bit mask of FTM0TRG0SRC field.
	SIM_SOPT4_FTM0TRG0SRC_Msk = 0x10000000
	// Bit FTM0TRG0SRC.
	SIM_SOPT4_FTM0TRG0SRC = 0x10000000
	// HSCMP0 output drives FTM0 hardware trigger 0
	SIM_SOPT4_FTM0TRG0SRC_0 = 0x0
	// FTM1 channel match drives FTM0 hardware trigger 0
	SIM_SOPT4_FTM0TRG0SRC_1 = 0x1
	// Position of FTM0TRG1SRC field.
	SIM_SOPT4_FTM0TRG1SRC_Pos = 0x1d
	// Bit mask of FTM0TRG1SRC field.
	SIM_SOPT4_FTM0TRG1SRC_Msk = 0x20000000
	// Bit FTM0TRG1SRC.
	SIM_SOPT4_FTM0TRG1SRC = 0x20000000
	// PDB output trigger 1 drives FTM0 hardware trigger 1
	SIM_SOPT4_FTM0TRG1SRC_0 = 0x0
	// FTM2 channel match drives FTM0 hardware trigger 1
	SIM_SOPT4_FTM0TRG1SRC_1 = 0x1
	// Position of FTM3TRG0SRC field.
	SIM_SOPT4_FTM3TRG0SRC_Pos = 0x1e
	// Bit mask of FTM3TRG0SRC field.
	SIM_SOPT4_FTM3TRG0SRC_Msk = 0x40000000
	// Bit FTM3TRG0SRC.
	SIM_SOPT4_FTM3TRG0SRC = 0x40000000
	// FTM1 channel match drives FTM3 hardware trigger 0
	SIM_SOPT4_FTM3TRG0SRC_1 = 0x1
	// Position of FTM3TRG1SRC field.
	SIM_SOPT4_FTM3TRG1SRC_Pos = 0x1f
	// Bit mask of FTM3TRG1SRC field.
	SIM_SOPT4_FTM3TRG1SRC_Msk = 0x80000000
	// Bit FTM3TRG1SRC.
	SIM_SOPT4_FTM3TRG1SRC = 0x80000000
	// FTM2 channel match drives FTM3 hardware trigger 1
	SIM_SOPT4_FTM3TRG1SRC_1 = 0x1

	// SOPT5: System Options Register 5
	// Position of UART0TXSRC field.
	SIM_SOPT5_UART0TXSRC_Pos = 0x0
	// Bit mask of UART0TXSRC field.
	SIM_SOPT5_UART0TXSRC_Msk = 0x3
	// UART0_TX pin
	SIM_SOPT5_UART0TXSRC_00 = 0x0
	// UART0_TX pin modulated with FTM1 channel 0 output
	SIM_SOPT5_UART0TXSRC_01 = 0x1
	// UART0_TX pin modulated with FTM2 channel 0 output
	SIM_SOPT5_UART0TXSRC_10 = 0x2
	// Position of UART0RXSRC field.
	SIM_SOPT5_UART0RXSRC_Pos = 0x2
	// Bit mask of UART0RXSRC field.
	SIM_SOPT5_UART0RXSRC_Msk = 0xc
	// UART0_RX pin
	SIM_SOPT5_UART0RXSRC_00 = 0x0
	// CMP0
	SIM_SOPT5_UART0RXSRC_01 = 0x1
	// CMP1
	SIM_SOPT5_UART0RXSRC_10 = 0x2
	// Position of UART1TXSRC field.
	SIM_SOPT5_UART1TXSRC_Pos = 0x4
	// Bit mask of UART1TXSRC field.
	SIM_SOPT5_UART1TXSRC_Msk = 0x30
	// UART1_TX pin
	SIM_SOPT5_UART1TXSRC_00 = 0x0
	// UART1_TX pin modulated with FTM1 channel 0 output
	SIM_SOPT5_UART1TXSRC_01 = 0x1
	// UART1_TX pin modulated with FTM2 channel 0 output
	SIM_SOPT5_UART1TXSRC_10 = 0x2
	// Position of UART1RXSRC field.
	SIM_SOPT5_UART1RXSRC_Pos = 0x6
	// Bit mask of UART1RXSRC field.
	SIM_SOPT5_UART1RXSRC_Msk = 0xc0
	// UART1_RX pin
	SIM_SOPT5_UART1RXSRC_00 = 0x0
	// CMP0
	SIM_SOPT5_UART1RXSRC_01 = 0x1
	// CMP1
	SIM_SOPT5_UART1RXSRC_10 = 0x2

	// SOPT7: System Options Register 7
	// Position of ADC0TRGSEL field.
	SIM_SOPT7_ADC0TRGSEL_Pos = 0x0
	// Bit mask of ADC0TRGSEL field.
	SIM_SOPT7_ADC0TRGSEL_Msk = 0xf
	// PDB external trigger pin input (PDB0_EXTRG)
	SIM_SOPT7_ADC0TRGSEL_0000 = 0x0
	// High speed comparator 0 output
	SIM_SOPT7_ADC0TRGSEL_0001 = 0x1
	// High speed comparator 1 output
	SIM_SOPT7_ADC0TRGSEL_0010 = 0x2
	// High speed comparator 2 output
	SIM_SOPT7_ADC0TRGSEL_0011 = 0x3
	// PIT trigger 0
	SIM_SOPT7_ADC0TRGSEL_0100 = 0x4
	// PIT trigger 1
	SIM_SOPT7_ADC0TRGSEL_0101 = 0x5
	// PIT trigger 2
	SIM_SOPT7_ADC0TRGSEL_0110 = 0x6
	// PIT trigger 3
	SIM_SOPT7_ADC0TRGSEL_0111 = 0x7
	// FTM0 trigger
	SIM_SOPT7_ADC0TRGSEL_1000 = 0x8
	// FTM1 trigger
	SIM_SOPT7_ADC0TRGSEL_1001 = 0x9
	// FTM2 trigger
	SIM_SOPT7_ADC0TRGSEL_1010 = 0xa
	// FTM3 trigger
	SIM_SOPT7_ADC0TRGSEL_1011 = 0xb
	// RTC alarm
	SIM_SOPT7_ADC0TRGSEL_1100 = 0xc
	// RTC seconds
	SIM_SOPT7_ADC0TRGSEL_1101 = 0xd
	// Low-power timer (LPTMR) trigger
	SIM_SOPT7_ADC0TRGSEL_1110 = 0xe
	// Position of ADC0PRETRGSEL field.
	SIM_SOPT7_ADC0PRETRGSEL_Pos = 0x4
	// Bit mask of ADC0PRETRGSEL field.
	SIM_SOPT7_ADC0PRETRGSEL_Msk = 0x10
	// Bit ADC0PRETRGSEL.
	SIM_SOPT7_ADC0PRETRGSEL = 0x10
	// Pre-trigger A
	SIM_SOPT7_ADC0PRETRGSEL_0 = 0x0
	// Pre-trigger B
	SIM_SOPT7_ADC0PRETRGSEL_1 = 0x1
	// Position of ADC0ALTTRGEN field.
	SIM_SOPT7_ADC0ALTTRGEN_Pos = 0x7
	// Bit mask of ADC0ALTTRGEN field.
	SIM_SOPT7_ADC0ALTTRGEN_Msk = 0x80
	// Bit ADC0ALTTRGEN.
	SIM_SOPT7_ADC0ALTTRGEN = 0x80
	// PDB trigger selected for ADC0.
	SIM_SOPT7_ADC0ALTTRGEN_0 = 0x0
	// Alternate trigger selected for ADC0.
	SIM_SOPT7_ADC0ALTTRGEN_1 = 0x1
	// Position of ADC1TRGSEL field.
	SIM_SOPT7_ADC1TRGSEL_Pos = 0x8
	// Bit mask of ADC1TRGSEL field.
	SIM_SOPT7_ADC1TRGSEL_Msk = 0xf00
	// PDB external trigger pin input (PDB0_EXTRG)
	SIM_SOPT7_ADC1TRGSEL_0000 = 0x0
	// High speed comparator 0 output
	SIM_SOPT7_ADC1TRGSEL_0001 = 0x1
	// High speed comparator 1 output
	SIM_SOPT7_ADC1TRGSEL_0010 = 0x2
	// High speed comparator 2 output
	SIM_SOPT7_ADC1TRGSEL_0011 = 0x3
	// PIT trigger 0
	SIM_SOPT7_ADC1TRGSEL_0100 = 0x4
	// PIT trigger 1
	SIM_SOPT7_ADC1TRGSEL_0101 = 0x5
	// PIT trigger 2
	SIM_SOPT7_ADC1TRGSEL_0110 = 0x6
	// PIT trigger 3
	SIM_SOPT7_ADC1TRGSEL_0111 = 0x7
	// FTM0 trigger
	SIM_SOPT7_ADC1TRGSEL_1000 = 0x8
	// FTM1 trigger
	SIM_SOPT7_ADC1TRGSEL_1001 = 0x9
	// FTM2 trigger
	SIM_SOPT7_ADC1TRGSEL_1010 = 0xa
	// FTM3 trigger
	SIM_SOPT7_ADC1TRGSEL_1011 = 0xb
	// RTC alarm
	SIM_SOPT7_ADC1TRGSEL_1100 = 0xc
	// RTC seconds
	SIM_SOPT7_ADC1TRGSEL_1101 = 0xd
	// Low-power timer (LPTMR) trigger
	SIM_SOPT7_ADC1TRGSEL_1110 = 0xe
	// Position of ADC1PRETRGSEL field.
	SIM_SOPT7_ADC1PRETRGSEL_Pos = 0xc
	// Bit mask of ADC1PRETRGSEL field.
	SIM_SOPT7_ADC1PRETRGSEL_Msk = 0x1000
	// Bit ADC1PRETRGSEL.
	SIM_SOPT7_ADC1PRETRGSEL = 0x1000
	// Pre-trigger A selected for ADC1.
	SIM_SOPT7_ADC1PRETRGSEL_0 = 0x0
	// Pre-trigger B selected for ADC1.
	SIM_SOPT7_ADC1PRETRGSEL_1 = 0x1
	// Position of ADC1ALTTRGEN field.
	SIM_SOPT7_ADC1ALTTRGEN_Pos = 0xf
	// Bit mask of ADC1ALTTRGEN field.
	SIM_SOPT7_ADC1ALTTRGEN_Msk = 0x8000
	// Bit ADC1ALTTRGEN.
	SIM_SOPT7_ADC1ALTTRGEN = 0x8000
	// PDB trigger selected for ADC1
	SIM_SOPT7_ADC1ALTTRGEN_0 = 0x0
	// Alternate trigger selected for ADC1 as defined by ADC1TRGSEL.
	SIM_SOPT7_ADC1ALTTRGEN_1 = 0x1

	// SDID: System Device Identification Register
	// Position of PINID field.
	SIM_SDID_PINID_Pos = 0x0
	// Bit mask of PINID field.
	SIM_SDID_PINID_Msk = 0xf
	// 32-pin
	SIM_SDID_PINID_0010 = 0x2
	// 48-pin
	SIM_SDID_PINID_0100 = 0x4
	// 64-pin
	SIM_SDID_PINID_0101 = 0x5
	// 80-pin
	SIM_SDID_PINID_0110 = 0x6
	// 81-pin or 121-pin
	SIM_SDID_PINID_0111 = 0x7
	// 100-pin
	SIM_SDID_PINID_1000 = 0x8
	// 121-pin
	SIM_SDID_PINID_1001 = 0x9
	// 144-pin
	SIM_SDID_PINID_1010 = 0xa
	// Custom pinout (WLCSP)
	SIM_SDID_PINID_1011 = 0xb
	// 169-pin
	SIM_SDID_PINID_1100 = 0xc
	// 256-pin
	SIM_SDID_PINID_1110 = 0xe
	// Position of FAMID field.
	SIM_SDID_FAMID_Pos = 0x4
	// Bit mask of FAMID field.
	SIM_SDID_FAMID_Msk = 0x70
	// K1x Family (without tamper)
	SIM_SDID_FAMID_000 = 0x0
	// K2x Family (without tamper)
	SIM_SDID_FAMID_001 = 0x1
	// K3x Family or K1x/K6x Family (with tamper)
	SIM_SDID_FAMID_010 = 0x2
	// K4x Family or K2x Family (with tamper)
	SIM_SDID_FAMID_011 = 0x3
	// K6x Family (without tamper)
	SIM_SDID_FAMID_100 = 0x4
	// K7x Family
	SIM_SDID_FAMID_101 = 0x5
	// Position of DIEID field.
	SIM_SDID_DIEID_Pos = 0x7
	// Bit mask of DIEID field.
	SIM_SDID_DIEID_Msk = 0xf80
	// Position of REVID field.
	SIM_SDID_REVID_Pos = 0xc
	// Bit mask of REVID field.
	SIM_SDID_REVID_Msk = 0xf000
	// Position of SERIESID field.
	SIM_SDID_SERIESID_Pos = 0x14
	// Bit mask of SERIESID field.
	SIM_SDID_SERIESID_Msk = 0xf00000
	// Kinetis K series
	SIM_SDID_SERIESID_0000 = 0x0
	// Kinetis L series
	SIM_SDID_SERIESID_0001 = 0x1
	// Kinetis W series
	SIM_SDID_SERIESID_0101 = 0x5
	// Kinetis V series
	SIM_SDID_SERIESID_0110 = 0x6
	// Position of SUBFAMID field.
	SIM_SDID_SUBFAMID_Pos = 0x18
	// Bit mask of SUBFAMID field.
	SIM_SDID_SUBFAMID_Msk = 0xf000000
	// Kx0 Subfamily
	SIM_SDID_SUBFAMID_0000 = 0x0
	// Kx1 Subfamily (tamper detect)
	SIM_SDID_SUBFAMID_0001 = 0x1
	// Kx2 Subfamily
	SIM_SDID_SUBFAMID_0010 = 0x2
	// Kx3 Subfamily (tamper detect)
	SIM_SDID_SUBFAMID_0011 = 0x3
	// Kx4 Subfamily
	SIM_SDID_SUBFAMID_0100 = 0x4
	// Kx5 Subfamily (tamper detect)
	SIM_SDID_SUBFAMID_0101 = 0x5
	// Kx6 Subfamily
	SIM_SDID_SUBFAMID_0110 = 0x6
	// Position of FAMILYID field.
	SIM_SDID_FAMILYID_Pos = 0x1c
	// Bit mask of FAMILYID field.
	SIM_SDID_FAMILYID_Msk = 0xf0000000
	// K1x Family
	SIM_SDID_FAMILYID_0001 = 0x1
	// K2x Family
	SIM_SDID_FAMILYID_0010 = 0x2
	// K3x Family
	SIM_SDID_FAMILYID_0011 = 0x3
	// K4x Family
	SIM_SDID_FAMILYID_0100 = 0x4
	// K6x Family
	SIM_SDID_FAMILYID_0110 = 0x6
	// K7x Family
	SIM_SDID_FAMILYID_0111 = 0x7

	// SCGC1: System Clock Gating Control Register 1
	// Position of I2C2 field.
	SIM_SCGC1_I2C2_Pos = 0x6
	// Bit mask of I2C2 field.
	SIM_SCGC1_I2C2_Msk = 0x40
	// Bit I2C2.
	SIM_SCGC1_I2C2 = 0x40
	// Clock disabled
	SIM_SCGC1_I2C2_0 = 0x0
	// Clock enabled
	SIM_SCGC1_I2C2_1 = 0x1
	// Position of UART4 field.
	SIM_SCGC1_UART4_Pos = 0xa
	// Bit mask of UART4 field.
	SIM_SCGC1_UART4_Msk = 0x400
	// Bit UART4.
	SIM_SCGC1_UART4 = 0x400
	// Clock disabled
	SIM_SCGC1_UART4_0 = 0x0
	// Clock enabled
	SIM_SCGC1_UART4_1 = 0x1
	// Position of UART5 field.
	SIM_SCGC1_UART5_Pos = 0xb
	// Bit mask of UART5 field.
	SIM_SCGC1_UART5_Msk = 0x800
	// Bit UART5.
	SIM_SCGC1_UART5 = 0x800
	// Clock disabled
	SIM_SCGC1_UART5_0 = 0x0
	// Clock enabled
	SIM_SCGC1_UART5_1 = 0x1

	// SCGC2: System Clock Gating Control Register 2
	// Position of ENET field.
	SIM_SCGC2_ENET_Pos = 0x0
	// Bit mask of ENET field.
	SIM_SCGC2_ENET_Msk = 0x1
	// Bit ENET.
	SIM_SCGC2_ENET = 0x1
	// Clock disabled
	SIM_SCGC2_ENET_0 = 0x0
	// Clock enabled
	SIM_SCGC2_ENET_1 = 0x1
	// Position of DAC0 field.
	SIM_SCGC2_DAC0_Pos = 0xc
	// Bit mask of DAC0 field.
	SIM_SCGC2_DAC0_Msk = 0x1000
	// Bit DAC0.
	SIM_SCGC2_DAC0 = 0x1000
	// Clock disabled
	SIM_SCGC2_DAC0_0 = 0x0
	// Clock enabled
	SIM_SCGC2_DAC0_1 = 0x1
	// Position of DAC1 field.
	SIM_SCGC2_DAC1_Pos = 0xd
	// Bit mask of DAC1 field.
	SIM_SCGC2_DAC1_Msk = 0x2000
	// Bit DAC1.
	SIM_SCGC2_DAC1 = 0x2000
	// Clock disabled
	SIM_SCGC2_DAC1_0 = 0x0
	// Clock enabled
	SIM_SCGC2_DAC1_1 = 0x1

	// SCGC3: System Clock Gating Control Register 3
	// Position of RNGA field.
	SIM_SCGC3_RNGA_Pos = 0x0
	// Bit mask of RNGA field.
	SIM_SCGC3_RNGA_Msk = 0x1
	// Bit RNGA.
	SIM_SCGC3_RNGA = 0x1
	// Clock disabled
	SIM_SCGC3_RNGA_0 = 0x0
	// Clock enabled
	SIM_SCGC3_RNGA_1 = 0x1
	// Position of SPI2 field.
	SIM_SCGC3_SPI2_Pos = 0xc
	// Bit mask of SPI2 field.
	SIM_SCGC3_SPI2_Msk = 0x1000
	// Bit SPI2.
	SIM_SCGC3_SPI2 = 0x1000
	// Clock disabled
	SIM_SCGC3_SPI2_0 = 0x0
	// Clock enabled
	SIM_SCGC3_SPI2_1 = 0x1
	// Position of SDHC field.
	SIM_SCGC3_SDHC_Pos = 0x11
	// Bit mask of SDHC field.
	SIM_SCGC3_SDHC_Msk = 0x20000
	// Bit SDHC.
	SIM_SCGC3_SDHC = 0x20000
	// Clock disabled
	SIM_SCGC3_SDHC_0 = 0x0
	// Clock enabled
	SIM_SCGC3_SDHC_1 = 0x1
	// Position of FTM2 field.
	SIM_SCGC3_FTM2_Pos = 0x18
	// Bit mask of FTM2 field.
	SIM_SCGC3_FTM2_Msk = 0x1000000
	// Bit FTM2.
	SIM_SCGC3_FTM2 = 0x1000000
	// Clock disabled
	SIM_SCGC3_FTM2_0 = 0x0
	// Clock enabled
	SIM_SCGC3_FTM2_1 = 0x1
	// Position of FTM3 field.
	SIM_SCGC3_FTM3_Pos = 0x19
	// Bit mask of FTM3 field.
	SIM_SCGC3_FTM3_Msk = 0x2000000
	// Bit FTM3.
	SIM_SCGC3_FTM3 = 0x2000000
	// Clock disabled
	SIM_SCGC3_FTM3_0 = 0x0
	// Clock enabled
	SIM_SCGC3_FTM3_1 = 0x1
	// Position of ADC1 field.
	SIM_SCGC3_ADC1_Pos = 0x1b
	// Bit mask of ADC1 field.
	SIM_SCGC3_ADC1_Msk = 0x8000000
	// Bit ADC1.
	SIM_SCGC3_ADC1 = 0x8000000
	// Clock disabled
	SIM_SCGC3_ADC1_0 = 0x0
	// Clock enabled
	SIM_SCGC3_ADC1_1 = 0x1

	// SCGC4: System Clock Gating Control Register 4
	// Position of EWM field.
	SIM_SCGC4_EWM_Pos = 0x1
	// Bit mask of EWM field.
	SIM_SCGC4_EWM_Msk = 0x2
	// Bit EWM.
	SIM_SCGC4_EWM = 0x2
	// Clock disabled
	SIM_SCGC4_EWM_0 = 0x0
	// Clock enabled
	SIM_SCGC4_EWM_1 = 0x1
	// Position of CMT field.
	SIM_SCGC4_CMT_Pos = 0x2
	// Bit mask of CMT field.
	SIM_SCGC4_CMT_Msk = 0x4
	// Bit CMT.
	SIM_SCGC4_CMT = 0x4
	// Clock disabled
	SIM_SCGC4_CMT_0 = 0x0
	// Clock enabled
	SIM_SCGC4_CMT_1 = 0x1
	// Position of I2C0 field.
	SIM_SCGC4_I2C0_Pos = 0x6
	// Bit mask of I2C0 field.
	SIM_SCGC4_I2C0_Msk = 0x40
	// Bit I2C0.
	SIM_SCGC4_I2C0 = 0x40
	// Clock disabled
	SIM_SCGC4_I2C0_0 = 0x0
	// Clock enabled
	SIM_SCGC4_I2C0_1 = 0x1
	// Position of I2C1 field.
	SIM_SCGC4_I2C1_Pos = 0x7
	// Bit mask of I2C1 field.
	SIM_SCGC4_I2C1_Msk = 0x80
	// Bit I2C1.
	SIM_SCGC4_I2C1 = 0x80
	// Clock disabled
	SIM_SCGC4_I2C1_0 = 0x0
	// Clock enabled
	SIM_SCGC4_I2C1_1 = 0x1
	// Position of UART0 field.
	SIM_SCGC4_UART0_Pos = 0xa
	// Bit mask of UART0 field.
	SIM_SCGC4_UART0_Msk = 0x400
	// Bit UART0.
	SIM_SCGC4_UART0 = 0x400
	// Clock disabled
	SIM_SCGC4_UART0_0 = 0x0
	// Clock enabled
	SIM_SCGC4_UART0_1 = 0x1
	// Position of UART1 field.
	SIM_SCGC4_UART1_Pos = 0xb
	// Bit mask of UART1 field.
	SIM_SCGC4_UART1_Msk = 0x800
	// Bit UART1.
	SIM_SCGC4_UART1 = 0x800
	// Clock disabled
	SIM_SCGC4_UART1_0 = 0x0
	// Clock enabled
	SIM_SCGC4_UART1_1 = 0x1
	// Position of UART2 field.
	SIM_SCGC4_UART2_Pos = 0xc
	// Bit mask of UART2 field.
	SIM_SCGC4_UART2_Msk = 0x1000
	// Bit UART2.
	SIM_SCGC4_UART2 = 0x1000
	// Clock disabled
	SIM_SCGC4_UART2_0 = 0x0
	// Clock enabled
	SIM_SCGC4_UART2_1 = 0x1
	// Position of UART3 field.
	SIM_SCGC4_UART3_Pos = 0xd
	// Bit mask of UART3 field.
	SIM_SCGC4_UART3_Msk = 0x2000
	// Bit UART3.
	SIM_SCGC4_UART3 = 0x2000
	// Clock disabled
	SIM_SCGC4_UART3_0 = 0x0
	// Clock enabled
	SIM_SCGC4_UART3_1 = 0x1
	// Position of USBOTG field.
	SIM_SCGC4_USBOTG_Pos = 0x12
	// Bit mask of USBOTG field.
	SIM_SCGC4_USBOTG_Msk = 0x40000
	// Bit USBOTG.
	SIM_SCGC4_USBOTG = 0x40000
	// Clock disabled
	SIM_SCGC4_USBOTG_0 = 0x0
	// Clock enabled
	SIM_SCGC4_USBOTG_1 = 0x1
	// Position of CMP field.
	SIM_SCGC4_CMP_Pos = 0x13
	// Bit mask of CMP field.
	SIM_SCGC4_CMP_Msk = 0x80000
	// Bit CMP.
	SIM_SCGC4_CMP = 0x80000
	// Clock disabled
	SIM_SCGC4_CMP_0 = 0x0
	// Clock enabled
	SIM_SCGC4_CMP_1 = 0x1
	// Position of VREF field.
	SIM_SCGC4_VREF_Pos = 0x14
	// Bit mask of VREF field.
	SIM_SCGC4_VREF_Msk = 0x100000
	// Bit VREF.
	SIM_SCGC4_VREF = 0x100000
	// Clock disabled
	SIM_SCGC4_VREF_0 = 0x0
	// Clock enabled
	SIM_SCGC4_VREF_1 = 0x1

	// SCGC5: System Clock Gating Control Register 5
	// Position of LPTMR field.
	SIM_SCGC5_LPTMR_Pos = 0x0
	// Bit mask of LPTMR field.
	SIM_SCGC5_LPTMR_Msk = 0x1
	// Bit LPTMR.
	SIM_SCGC5_LPTMR = 0x1
	// Access disabled
	SIM_SCGC5_LPTMR_0 = 0x0
	// Access enabled
	SIM_SCGC5_LPTMR_1 = 0x1
	// Position of PORTA field.
	SIM_SCGC5_PORTA_Pos = 0x9
	// Bit mask of PORTA field.
	SIM_SCGC5_PORTA_Msk = 0x200
	// Bit PORTA.
	SIM_SCGC5_PORTA = 0x200
	// Clock disabled
	SIM_SCGC5_PORTA_0 = 0x0
	// Clock enabled
	SIM_SCGC5_PORTA_1 = 0x1
	// Position of PORTB field.
	SIM_SCGC5_PORTB_Pos = 0xa
	// Bit mask of PORTB field.
	SIM_SCGC5_PORTB_Msk = 0x400
	// Bit PORTB.
	SIM_SCGC5_PORTB = 0x400
	// Clock disabled
	SIM_SCGC5_PORTB_0 = 0x0
	// Clock enabled
	SIM_SCGC5_PORTB_1 = 0x1
	// Position of PORTC field.
	SIM_SCGC5_PORTC_Pos = 0xb
	// Bit mask of PORTC field.
	SIM_SCGC5_PORTC_Msk = 0x800
	// Bit PORTC.
	SIM_SCGC5_PORTC = 0x800
	// Clock disabled
	SIM_SCGC5_PORTC_0 = 0x0
	// Clock enabled
	SIM_SCGC5_PORTC_1 = 0x1
	// Position of PORTD field.
	SIM_SCGC5_PORTD_Pos = 0xc
	// Bit mask of PORTD field.
	SIM_SCGC5_PORTD_Msk = 0x1000
	// Bit PORTD.
	SIM_SCGC5_PORTD = 0x1000
	// Clock disabled
	SIM_SCGC5_PORTD_0 = 0x0
	// Clock enabled
	SIM_SCGC5_PORTD_1 = 0x1
	// Position of PORTE field.
	SIM_SCGC5_PORTE_Pos = 0xd
	// Bit mask of PORTE field.
	SIM_SCGC5_PORTE_Msk = 0x2000
	// Bit PORTE.
	SIM_SCGC5_PORTE = 0x2000
	// Clock disabled
	SIM_SCGC5_PORTE_0 = 0x0
	// Clock enabled
	SIM_SCGC5_PORTE_1 = 0x1

	// SCGC6: System Clock Gating Control Register 6
	// Position of FTF field.
	SIM_SCGC6_FTF_Pos = 0x0
	// Bit mask of FTF field.
	SIM_SCGC6_FTF_Msk = 0x1
	// Bit FTF.
	SIM_SCGC6_FTF = 0x1
	// Clock disabled
	SIM_SCGC6_FTF_0 = 0x0
	// Clock enabled
	SIM_SCGC6_FTF_1 = 0x1
	// Position of DMAMUX field.
	SIM_SCGC6_DMAMUX_Pos = 0x1
	// Bit mask of DMAMUX field.
	SIM_SCGC6_DMAMUX_Msk = 0x2
	// Bit DMAMUX.
	SIM_SCGC6_DMAMUX = 0x2
	// Clock disabled
	SIM_SCGC6_DMAMUX_0 = 0x0
	// Clock enabled
	SIM_SCGC6_DMAMUX_1 = 0x1
	// Position of FLEXCAN0 field.
	SIM_SCGC6_FLEXCAN0_Pos = 0x4
	// Bit mask of FLEXCAN0 field.
	SIM_SCGC6_FLEXCAN0_Msk = 0x10
	// Bit FLEXCAN0.
	SIM_SCGC6_FLEXCAN0 = 0x10
	// Clock disabled
	SIM_SCGC6_FLEXCAN0_0 = 0x0
	// Clock enabled
	SIM_SCGC6_FLEXCAN0_1 = 0x1
	// Position of RNGA field.
	SIM_SCGC6_RNGA_Pos = 0x9
	// Bit mask of RNGA field.
	SIM_SCGC6_RNGA_Msk = 0x200
	// Bit RNGA.
	SIM_SCGC6_RNGA = 0x200
	// Position of SPI0 field.
	SIM_SCGC6_SPI0_Pos = 0xc
	// Bit mask of SPI0 field.
	SIM_SCGC6_SPI0_Msk = 0x1000
	// Bit SPI0.
	SIM_SCGC6_SPI0 = 0x1000
	// Clock disabled
	SIM_SCGC6_SPI0_0 = 0x0
	// Clock enabled
	SIM_SCGC6_SPI0_1 = 0x1
	// Position of SPI1 field.
	SIM_SCGC6_SPI1_Pos = 0xd
	// Bit mask of SPI1 field.
	SIM_SCGC6_SPI1_Msk = 0x2000
	// Bit SPI1.
	SIM_SCGC6_SPI1 = 0x2000
	// Clock disabled
	SIM_SCGC6_SPI1_0 = 0x0
	// Clock enabled
	SIM_SCGC6_SPI1_1 = 0x1
	// Position of I2S field.
	SIM_SCGC6_I2S_Pos = 0xf
	// Bit mask of I2S field.
	SIM_SCGC6_I2S_Msk = 0x8000
	// Bit I2S.
	SIM_SCGC6_I2S = 0x8000
	// Clock disabled
	SIM_SCGC6_I2S_0 = 0x0
	// Clock enabled
	SIM_SCGC6_I2S_1 = 0x1
	// Position of CRC field.
	SIM_SCGC6_CRC_Pos = 0x12
	// Bit mask of CRC field.
	SIM_SCGC6_CRC_Msk = 0x40000
	// Bit CRC.
	SIM_SCGC6_CRC = 0x40000
	// Clock disabled
	SIM_SCGC6_CRC_0 = 0x0
	// Clock enabled
	SIM_SCGC6_CRC_1 = 0x1
	// Position of USBDCD field.
	SIM_SCGC6_USBDCD_Pos = 0x15
	// Bit mask of USBDCD field.
	SIM_SCGC6_USBDCD_Msk = 0x200000
	// Bit USBDCD.
	SIM_SCGC6_USBDCD = 0x200000
	// Clock disabled
	SIM_SCGC6_USBDCD_0 = 0x0
	// Clock enabled
	SIM_SCGC6_USBDCD_1 = 0x1
	// Position of PDB field.
	SIM_SCGC6_PDB_Pos = 0x16
	// Bit mask of PDB field.
	SIM_SCGC6_PDB_Msk = 0x400000
	// Bit PDB.
	SIM_SCGC6_PDB = 0x400000
	// Clock disabled
	SIM_SCGC6_PDB_0 = 0x0
	// Clock enabled
	SIM_SCGC6_PDB_1 = 0x1
	// Position of PIT field.
	SIM_SCGC6_PIT_Pos = 0x17
	// Bit mask of PIT field.
	SIM_SCGC6_PIT_Msk = 0x800000
	// Bit PIT.
	SIM_SCGC6_PIT = 0x800000
	// Clock disabled
	SIM_SCGC6_PIT_0 = 0x0
	// Clock enabled
	SIM_SCGC6_PIT_1 = 0x1
	// Position of FTM0 field.
	SIM_SCGC6_FTM0_Pos = 0x18
	// Bit mask of FTM0 field.
	SIM_SCGC6_FTM0_Msk = 0x1000000
	// Bit FTM0.
	SIM_SCGC6_FTM0 = 0x1000000
	// Clock disabled
	SIM_SCGC6_FTM0_0 = 0x0
	// Clock enabled
	SIM_SCGC6_FTM0_1 = 0x1
	// Position of FTM1 field.
	SIM_SCGC6_FTM1_Pos = 0x19
	// Bit mask of FTM1 field.
	SIM_SCGC6_FTM1_Msk = 0x2000000
	// Bit FTM1.
	SIM_SCGC6_FTM1 = 0x2000000
	// Clock disabled
	SIM_SCGC6_FTM1_0 = 0x0
	// Clock enabled
	SIM_SCGC6_FTM1_1 = 0x1
	// Position of FTM2 field.
	SIM_SCGC6_FTM2_Pos = 0x1a
	// Bit mask of FTM2 field.
	SIM_SCGC6_FTM2_Msk = 0x4000000
	// Bit FTM2.
	SIM_SCGC6_FTM2 = 0x4000000
	// Clock disabled
	SIM_SCGC6_FTM2_0 = 0x0
	// Clock enabled
	SIM_SCGC6_FTM2_1 = 0x1
	// Position of ADC0 field.
	SIM_SCGC6_ADC0_Pos = 0x1b
	// Bit mask of ADC0 field.
	SIM_SCGC6_ADC0_Msk = 0x8000000
	// Bit ADC0.
	SIM_SCGC6_ADC0 = 0x8000000
	// Clock disabled
	SIM_SCGC6_ADC0_0 = 0x0
	// Clock enabled
	SIM_SCGC6_ADC0_1 = 0x1
	// Position of RTC field.
	SIM_SCGC6_RTC_Pos = 0x1d
	// Bit mask of RTC field.
	SIM_SCGC6_RTC_Msk = 0x20000000
	// Bit RTC.
	SIM_SCGC6_RTC = 0x20000000
	// Access and interrupts disabled
	SIM_SCGC6_RTC_0 = 0x0
	// Access and interrupts enabled
	SIM_SCGC6_RTC_1 = 0x1
	// Position of DAC0 field.
	SIM_SCGC6_DAC0_Pos = 0x1f
	// Bit mask of DAC0 field.
	SIM_SCGC6_DAC0_Msk = 0x80000000
	// Bit DAC0.
	SIM_SCGC6_DAC0 = 0x80000000
	// Clock disabled
	SIM_SCGC6_DAC0_0 = 0x0
	// Clock enabled
	SIM_SCGC6_DAC0_1 = 0x1

	// SCGC7: System Clock Gating Control Register 7
	// Position of FLEXBUS field.
	SIM_SCGC7_FLEXBUS_Pos = 0x0
	// Bit mask of FLEXBUS field.
	SIM_SCGC7_FLEXBUS_Msk = 0x1
	// Bit FLEXBUS.
	SIM_SCGC7_FLEXBUS = 0x1
	// Clock disabled
	SIM_SCGC7_FLEXBUS_0 = 0x0
	// Clock enabled
	SIM_SCGC7_FLEXBUS_1 = 0x1
	// Position of DMA field.
	SIM_SCGC7_DMA_Pos = 0x1
	// Bit mask of DMA field.
	SIM_SCGC7_DMA_Msk = 0x2
	// Bit DMA.
	SIM_SCGC7_DMA = 0x2
	// Clock disabled
	SIM_SCGC7_DMA_0 = 0x0
	// Clock enabled
	SIM_SCGC7_DMA_1 = 0x1
	// Position of MPU field.
	SIM_SCGC7_MPU_Pos = 0x2
	// Bit mask of MPU field.
	SIM_SCGC7_MPU_Msk = 0x4
	// Bit MPU.
	SIM_SCGC7_MPU = 0x4
	// Clock disabled
	SIM_SCGC7_MPU_0 = 0x0
	// Clock enabled
	SIM_SCGC7_MPU_1 = 0x1

	// CLKDIV1: System Clock Divider Register 1
	// Position of OUTDIV4 field.
	SIM_CLKDIV1_OUTDIV4_Pos = 0x10
	// Bit mask of OUTDIV4 field.
	SIM_CLKDIV1_OUTDIV4_Msk = 0xf0000
	// Divide-by-1.
	SIM_CLKDIV1_OUTDIV4_0000 = 0x0
	// Divide-by-2.
	SIM_CLKDIV1_OUTDIV4_0001 = 0x1
	// Divide-by-3.
	SIM_CLKDIV1_OUTDIV4_0010 = 0x2
	// Divide-by-4.
	SIM_CLKDIV1_OUTDIV4_0011 = 0x3
	// Divide-by-5.
	SIM_CLKDIV1_OUTDIV4_0100 = 0x4
	// Divide-by-6.
	SIM_CLKDIV1_OUTDIV4_0101 = 0x5
	// Divide-by-7.
	SIM_CLKDIV1_OUTDIV4_0110 = 0x6
	// Divide-by-8.
	SIM_CLKDIV1_OUTDIV4_0111 = 0x7
	// Divide-by-9.
	SIM_CLKDIV1_OUTDIV4_1000 = 0x8
	// Divide-by-10.
	SIM_CLKDIV1_OUTDIV4_1001 = 0x9
	// Divide-by-11.
	SIM_CLKDIV1_OUTDIV4_1010 = 0xa
	// Divide-by-12.
	SIM_CLKDIV1_OUTDIV4_1011 = 0xb
	// Divide-by-13.
	SIM_CLKDIV1_OUTDIV4_1100 = 0xc
	// Divide-by-14.
	SIM_CLKDIV1_OUTDIV4_1101 = 0xd
	// Divide-by-15.
	SIM_CLKDIV1_OUTDIV4_1110 = 0xe
	// Divide-by-16.
	SIM_CLKDIV1_OUTDIV4_1111 = 0xf
	// Position of OUTDIV3 field.
	SIM_CLKDIV1_OUTDIV3_Pos = 0x14
	// Bit mask of OUTDIV3 field.
	SIM_CLKDIV1_OUTDIV3_Msk = 0xf00000
	// Divide-by-1.
	SIM_CLKDIV1_OUTDIV3_0000 = 0x0
	// Divide-by-2.
	SIM_CLKDIV1_OUTDIV3_0001 = 0x1
	// Divide-by-3.
	SIM_CLKDIV1_OUTDIV3_0010 = 0x2
	// Divide-by-4.
	SIM_CLKDIV1_OUTDIV3_0011 = 0x3
	// Divide-by-5.
	SIM_CLKDIV1_OUTDIV3_0100 = 0x4
	// Divide-by-6.
	SIM_CLKDIV1_OUTDIV3_0101 = 0x5
	// Divide-by-7.
	SIM_CLKDIV1_OUTDIV3_0110 = 0x6
	// Divide-by-8.
	SIM_CLKDIV1_OUTDIV3_0111 = 0x7
	// Divide-by-9.
	SIM_CLKDIV1_OUTDIV3_1000 = 0x8
	// Divide-by-10.
	SIM_CLKDIV1_OUTDIV3_1001 = 0x9
	// Divide-by-11.
	SIM_CLKDIV1_OUTDIV3_1010 = 0xa
	// Divide-by-12.
	SIM_CLKDIV1_OUTDIV3_1011 = 0xb
	// Divide-by-13.
	SIM_CLKDIV1_OUTDIV3_1100 = 0xc
	// Divide-by-14.
	SIM_CLKDIV1_OUTDIV3_1101 = 0xd
	// Divide-by-15.
	SIM_CLKDIV1_OUTDIV3_1110 = 0xe
	// Divide-by-16.
	SIM_CLKDIV1_OUTDIV3_1111 = 0xf
	// Position of OUTDIV2 field.
	SIM_CLKDIV1_OUTDIV2_Pos = 0x18
	// Bit mask of OUTDIV2 field.
	SIM_CLKDIV1_OUTDIV2_Msk = 0xf000000
	// Divide-by-1.
	SIM_CLKDIV1_OUTDIV2_0000 = 0x0
	// Divide-by-2.
	SIM_CLKDIV1_OUTDIV2_0001 = 0x1
	// Divide-by-3.
	SIM_CLKDIV1_OUTDIV2_0010 = 0x2
	// Divide-by-4.
	SIM_CLKDIV1_OUTDIV2_0011 = 0x3
	// Divide-by-5.
	SIM_CLKDIV1_OUTDIV2_0100 = 0x4
	// Divide-by-6.
	SIM_CLKDIV1_OUTDIV2_0101 = 0x5
	// Divide-by-7.
	SIM_CLKDIV1_OUTDIV2_0110 = 0x6
	// Divide-by-8.
	SIM_CLKDIV1_OUTDIV2_0111 = 0x7
	// Divide-by-9.
	SIM_CLKDIV1_OUTDIV2_1000 = 0x8
	// Divide-by-10.
	SIM_CLKDIV1_OUTDIV2_1001 = 0x9
	// Divide-by-11.
	SIM_CLKDIV1_OUTDIV2_1010 = 0xa
	// Divide-by-12.
	SIM_CLKDIV1_OUTDIV2_1011 = 0xb
	// Divide-by-13.
	SIM_CLKDIV1_OUTDIV2_1100 = 0xc
	// Divide-by-14.
	SIM_CLKDIV1_OUTDIV2_1101 = 0xd
	// Divide-by-15.
	SIM_CLKDIV1_OUTDIV2_1110 = 0xe
	// Divide-by-16.
	SIM_CLKDIV1_OUTDIV2_1111 = 0xf
	// Position of OUTDIV1 field.
	SIM_CLKDIV1_OUTDIV1_Pos = 0x1c
	// Bit mask of OUTDIV1 field.
	SIM_CLKDIV1_OUTDIV1_Msk = 0xf0000000
	// Divide-by-1.
	SIM_CLKDIV1_OUTDIV1_0000 = 0x0
	// Divide-by-2.
	SIM_CLKDIV1_OUTDIV1_0001 = 0x1
	// Divide-by-3.
	SIM_CLKDIV1_OUTDIV1_0010 = 0x2
	// Divide-by-4.
	SIM_CLKDIV1_OUTDIV1_0011 = 0x3
	// Divide-by-5.
	SIM_CLKDIV1_OUTDIV1_0100 = 0x4
	// Divide-by-6.
	SIM_CLKDIV1_OUTDIV1_0101 = 0x5
	// Divide-by-7.
	SIM_CLKDIV1_OUTDIV1_0110 = 0x6
	// Divide-by-8.
	SIM_CLKDIV1_OUTDIV1_0111 = 0x7
	// Divide-by-9.
	SIM_CLKDIV1_OUTDIV1_1000 = 0x8
	// Divide-by-10.
	SIM_CLKDIV1_OUTDIV1_1001 = 0x9
	// Divide-by-11.
	SIM_CLKDIV1_OUTDIV1_1010 = 0xa
	// Divide-by-12.
	SIM_CLKDIV1_OUTDIV1_1011 = 0xb
	// Divide-by-13.
	SIM_CLKDIV1_OUTDIV1_1100 = 0xc
	// Divide-by-14.
	SIM_CLKDIV1_OUTDIV1_1101 = 0xd
	// Divide-by-15.
	SIM_CLKDIV1_OUTDIV1_1110 = 0xe
	// Divide-by-16.
	SIM_CLKDIV1_OUTDIV1_1111 = 0xf

	// CLKDIV2: System Clock Divider Register 2
	// Position of USBFRAC field.
	SIM_CLKDIV2_USBFRAC_Pos = 0x0
	// Bit mask of USBFRAC field.
	SIM_CLKDIV2_USBFRAC_Msk = 0x1
	// Bit USBFRAC.
	SIM_CLKDIV2_USBFRAC = 0x1
	// Position of USBDIV field.
	SIM_CLKDIV2_USBDIV_Pos = 0x1
	// Bit mask of USBDIV field.
	SIM_CLKDIV2_USBDIV_Msk = 0xe

	// FCFG1: Flash Configuration Register 1
	// Position of FLASHDIS field.
	SIM_FCFG1_FLASHDIS_Pos = 0x0
	// Bit mask of FLASHDIS field.
	SIM_FCFG1_FLASHDIS_Msk = 0x1
	// Bit FLASHDIS.
	SIM_FCFG1_FLASHDIS = 0x1
	// Flash is enabled
	SIM_FCFG1_FLASHDIS_0 = 0x0
	// Flash is disabled
	SIM_FCFG1_FLASHDIS_1 = 0x1
	// Position of FLASHDOZE field.
	SIM_FCFG1_FLASHDOZE_Pos = 0x1
	// Bit mask of FLASHDOZE field.
	SIM_FCFG1_FLASHDOZE_Msk = 0x2
	// Bit FLASHDOZE.
	SIM_FCFG1_FLASHDOZE = 0x2
	// Flash remains enabled during Wait mode
	SIM_FCFG1_FLASHDOZE_0 = 0x0
	// Flash is disabled for the duration of Wait mode
	SIM_FCFG1_FLASHDOZE_1 = 0x1
	// Position of DEPART field.
	SIM_FCFG1_DEPART_Pos = 0x8
	// Bit mask of DEPART field.
	SIM_FCFG1_DEPART_Msk = 0xf00
	// Position of EESIZE field.
	SIM_FCFG1_EESIZE_Pos = 0x10
	// Bit mask of EESIZE field.
	SIM_FCFG1_EESIZE_Msk = 0xf0000
	// 16 KB
	SIM_FCFG1_EESIZE_0000 = 0x0
	// 8 KB
	SIM_FCFG1_EESIZE_0001 = 0x1
	// 4 KB
	SIM_FCFG1_EESIZE_0010 = 0x2
	// 2 KB
	SIM_FCFG1_EESIZE_0011 = 0x3
	// 1 KB
	SIM_FCFG1_EESIZE_0100 = 0x4
	// 512 Bytes
	SIM_FCFG1_EESIZE_0101 = 0x5
	// 256 Bytes
	SIM_FCFG1_EESIZE_0110 = 0x6
	// 128 Bytes
	SIM_FCFG1_EESIZE_0111 = 0x7
	// 64 Bytes
	SIM_FCFG1_EESIZE_1000 = 0x8
	// 32 Bytes
	SIM_FCFG1_EESIZE_1001 = 0x9
	// 0 Bytes
	SIM_FCFG1_EESIZE_1111 = 0xf
	// Position of PFSIZE field.
	SIM_FCFG1_PFSIZE_Pos = 0x18
	// Bit mask of PFSIZE field.
	SIM_FCFG1_PFSIZE_Msk = 0xf000000
	// 32 KB of program flash memory
	SIM_FCFG1_PFSIZE_0011 = 0x3
	// 64 KB of program flash memory
	SIM_FCFG1_PFSIZE_0101 = 0x5
	// 128 KB of program flash memory
	SIM_FCFG1_PFSIZE_0111 = 0x7
	// 256 KB of program flash memory
	SIM_FCFG1_PFSIZE_1001 = 0x9
	// 512 KB of program flash memory
	SIM_FCFG1_PFSIZE_1011 = 0xb
	// 1024 KB of program flash memory
	SIM_FCFG1_PFSIZE_1101 = 0xd
	// 1024 KB of program flash memory
	SIM_FCFG1_PFSIZE_1111 = 0xf
	// Position of NVMSIZE field.
	SIM_FCFG1_NVMSIZE_Pos = 0x1c
	// Bit mask of NVMSIZE field.
	SIM_FCFG1_NVMSIZE_Msk = 0xf0000000
	// 0 KB of FlexNVM
	SIM_FCFG1_NVMSIZE_0000 = 0x0
	// 32 KB of FlexNVM
	SIM_FCFG1_NVMSIZE_0011 = 0x3
	// 64 KB of FlexNVM
	SIM_FCFG1_NVMSIZE_0101 = 0x5
	// 128 KB of FlexNVM
	SIM_FCFG1_NVMSIZE_0111 = 0x7
	// 256 KB of FlexNVM
	SIM_FCFG1_NVMSIZE_1001 = 0x9
	// 512 KB of FlexNVM
	SIM_FCFG1_NVMSIZE_1011 = 0xb
	// 512 KB of FlexNVM
	SIM_FCFG1_NVMSIZE_1111 = 0xf

	// FCFG2: Flash Configuration Register 2
	// Position of MAXADDR1 field.
	SIM_FCFG2_MAXADDR1_Pos = 0x10
	// Bit mask of MAXADDR1 field.
	SIM_FCFG2_MAXADDR1_Msk = 0x7f0000
	// Position of PFLSH field.
	SIM_FCFG2_PFLSH_Pos = 0x17
	// Bit mask of PFLSH field.
	SIM_FCFG2_PFLSH_Msk = 0x800000
	// Bit PFLSH.
	SIM_FCFG2_PFLSH = 0x800000
	// Device supports FlexNVM
	SIM_FCFG2_PFLSH_0 = 0x0
	// Program Flash only, device does not support FlexNVM
	SIM_FCFG2_PFLSH_1 = 0x1
	// Position of MAXADDR0 field.
	SIM_FCFG2_MAXADDR0_Pos = 0x18
	// Bit mask of MAXADDR0 field.
	SIM_FCFG2_MAXADDR0_Msk = 0x7f000000

	// UIDH: Unique Identification Register High
	// Position of UID field.
	SIM_UIDH_UID_Pos = 0x0
	// Bit mask of UID field.
	SIM_UIDH_UID_Msk = 0xffffffff

	// UIDMH: Unique Identification Register Mid-High
	// Position of UID field.
	SIM_UIDMH_UID_Pos = 0x0
	// Bit mask of UID field.
	SIM_UIDMH_UID_Msk = 0xffffffff

	// UIDML: Unique Identification Register Mid Low
	// Position of UID field.
	SIM_UIDML_UID_Pos = 0x0
	// Bit mask of UID field.
	SIM_UIDML_UID_Msk = 0xffffffff

	// UIDL: Unique Identification Register Low
	// Position of UID field.
	SIM_UIDL_UID_Pos = 0x0
	// Bit mask of UID field.
	SIM_UIDL_UID_Msk = 0xffffffff
)

// Constants for PORTA: Pin Control and Interrupts
const (
	// PCR0: Pin Control Register n
	// Position of PS field.
	PORT_PCR0_PS_Pos = 0x0
	// Bit mask of PS field.
	PORT_PCR0_PS_Msk = 0x1
	// Bit PS.
	PORT_PCR0_PS = 0x1
	// Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR0_PS_0 = 0x0
	// Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR0_PS_1 = 0x1
	// Position of PE field.
	PORT_PCR0_PE_Pos = 0x1
	// Bit mask of PE field.
	PORT_PCR0_PE_Msk = 0x2
	// Bit PE.
	PORT_PCR0_PE = 0x2
	// Internal pullup or pulldown resistor is not enabled on the corresponding pin.
	PORT_PCR0_PE_0 = 0x0
	// Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
	PORT_PCR0_PE_1 = 0x1
	// Position of SRE field.
	PORT_PCR0_SRE_Pos = 0x2
	// Bit mask of SRE field.
	PORT_PCR0_SRE_Msk = 0x4
	// Bit SRE.
	PORT_PCR0_SRE = 0x4
	// Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR0_SRE_0 = 0x0
	// Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR0_SRE_1 = 0x1
	// Position of PFE field.
	PORT_PCR0_PFE_Pos = 0x4
	// Bit mask of PFE field.
	PORT_PCR0_PFE_Msk = 0x10
	// Bit PFE.
	PORT_PCR0_PFE = 0x10
	// Passive input filter is disabled on the corresponding pin.
	PORT_PCR0_PFE_0 = 0x0
	// Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
	PORT_PCR0_PFE_1 = 0x1
	// Position of ODE field.
	PORT_PCR0_ODE_Pos = 0x5
	// Bit mask of ODE field.
	PORT_PCR0_ODE_Msk = 0x20
	// Bit ODE.
	PORT_PCR0_ODE = 0x20
	// Open drain output is disabled on the corresponding pin.
	PORT_PCR0_ODE_0 = 0x0
	// Open drain output is enabled on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR0_ODE_1 = 0x1
	// Position of DSE field.
	PORT_PCR0_DSE_Pos = 0x6
	// Bit mask of DSE field.
	PORT_PCR0_DSE_Msk = 0x40
	// Bit DSE.
	PORT_PCR0_DSE = 0x40
	// Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR0_DSE_0 = 0x0
	// High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR0_DSE_1 = 0x1
	// Position of MUX field.
	PORT_PCR0_MUX_Pos = 0x8
	// Bit mask of MUX field.
	PORT_PCR0_MUX_Msk = 0x700
	// Pin disabled (analog).
	PORT_PCR0_MUX_000 = 0x0
	// Alternative 1 (GPIO).
	PORT_PCR0_MUX_001 = 0x1
	// Alternative 2 (chip-specific).
	PORT_PCR0_MUX_010 = 0x2
	// Alternative 3 (chip-specific).
	PORT_PCR0_MUX_011 = 0x3
	// Alternative 4 (chip-specific).
	PORT_PCR0_MUX_100 = 0x4
	// Alternative 5 (chip-specific).
	PORT_PCR0_MUX_101 = 0x5
	// Alternative 6 (chip-specific).
	PORT_PCR0_MUX_110 = 0x6
	// Alternative 7 (chip-specific).
	PORT_PCR0_MUX_111 = 0x7
	// Position of LK field.
	PORT_PCR0_LK_Pos = 0xf
	// Bit mask of LK field.
	PORT_PCR0_LK_Msk = 0x8000
	// Bit LK.
	PORT_PCR0_LK = 0x8000
	// Pin Control Register fields [15:0] are not locked.
	PORT_PCR0_LK_0 = 0x0
	// Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
	PORT_PCR0_LK_1 = 0x1
	// Position of IRQC field.
	PORT_PCR0_IRQC_Pos = 0x10
	// Bit mask of IRQC field.
	PORT_PCR0_IRQC_Msk = 0xf0000
	// Interrupt/DMA request disabled.
	PORT_PCR0_IRQC_0000 = 0x0
	// DMA request on rising edge.
	PORT_PCR0_IRQC_0001 = 0x1
	// DMA request on falling edge.
	PORT_PCR0_IRQC_0010 = 0x2
	// DMA request on either edge.
	PORT_PCR0_IRQC_0011 = 0x3
	// Interrupt when logic 0.
	PORT_PCR0_IRQC_1000 = 0x8
	// Interrupt on rising-edge.
	PORT_PCR0_IRQC_1001 = 0x9
	// Interrupt on falling-edge.
	PORT_PCR0_IRQC_1010 = 0xa
	// Interrupt on either edge.
	PORT_PCR0_IRQC_1011 = 0xb
	// Interrupt when logic 1.
	PORT_PCR0_IRQC_1100 = 0xc
	// Position of ISF field.
	PORT_PCR0_ISF_Pos = 0x18
	// Bit mask of ISF field.
	PORT_PCR0_ISF_Msk = 0x1000000
	// Bit ISF.
	PORT_PCR0_ISF = 0x1000000
	// Configured interrupt is not detected.
	PORT_PCR0_ISF_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_PCR0_ISF_1 = 0x1

	// PCR1: Pin Control Register n
	// Position of PS field.
	PORT_PCR1_PS_Pos = 0x0
	// Bit mask of PS field.
	PORT_PCR1_PS_Msk = 0x1
	// Bit PS.
	PORT_PCR1_PS = 0x1
	// Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR1_PS_0 = 0x0
	// Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR1_PS_1 = 0x1
	// Position of PE field.
	PORT_PCR1_PE_Pos = 0x1
	// Bit mask of PE field.
	PORT_PCR1_PE_Msk = 0x2
	// Bit PE.
	PORT_PCR1_PE = 0x2
	// Internal pullup or pulldown resistor is not enabled on the corresponding pin.
	PORT_PCR1_PE_0 = 0x0
	// Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
	PORT_PCR1_PE_1 = 0x1
	// Position of SRE field.
	PORT_PCR1_SRE_Pos = 0x2
	// Bit mask of SRE field.
	PORT_PCR1_SRE_Msk = 0x4
	// Bit SRE.
	PORT_PCR1_SRE = 0x4
	// Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR1_SRE_0 = 0x0
	// Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR1_SRE_1 = 0x1
	// Position of PFE field.
	PORT_PCR1_PFE_Pos = 0x4
	// Bit mask of PFE field.
	PORT_PCR1_PFE_Msk = 0x10
	// Bit PFE.
	PORT_PCR1_PFE = 0x10
	// Passive input filter is disabled on the corresponding pin.
	PORT_PCR1_PFE_0 = 0x0
	// Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
	PORT_PCR1_PFE_1 = 0x1
	// Position of ODE field.
	PORT_PCR1_ODE_Pos = 0x5
	// Bit mask of ODE field.
	PORT_PCR1_ODE_Msk = 0x20
	// Bit ODE.
	PORT_PCR1_ODE = 0x20
	// Open drain output is disabled on the corresponding pin.
	PORT_PCR1_ODE_0 = 0x0
	// Open drain output is enabled on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR1_ODE_1 = 0x1
	// Position of DSE field.
	PORT_PCR1_DSE_Pos = 0x6
	// Bit mask of DSE field.
	PORT_PCR1_DSE_Msk = 0x40
	// Bit DSE.
	PORT_PCR1_DSE = 0x40
	// Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR1_DSE_0 = 0x0
	// High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR1_DSE_1 = 0x1
	// Position of MUX field.
	PORT_PCR1_MUX_Pos = 0x8
	// Bit mask of MUX field.
	PORT_PCR1_MUX_Msk = 0x700
	// Pin disabled (analog).
	PORT_PCR1_MUX_000 = 0x0
	// Alternative 1 (GPIO).
	PORT_PCR1_MUX_001 = 0x1
	// Alternative 2 (chip-specific).
	PORT_PCR1_MUX_010 = 0x2
	// Alternative 3 (chip-specific).
	PORT_PCR1_MUX_011 = 0x3
	// Alternative 4 (chip-specific).
	PORT_PCR1_MUX_100 = 0x4
	// Alternative 5 (chip-specific).
	PORT_PCR1_MUX_101 = 0x5
	// Alternative 6 (chip-specific).
	PORT_PCR1_MUX_110 = 0x6
	// Alternative 7 (chip-specific).
	PORT_PCR1_MUX_111 = 0x7
	// Position of LK field.
	PORT_PCR1_LK_Pos = 0xf
	// Bit mask of LK field.
	PORT_PCR1_LK_Msk = 0x8000
	// Bit LK.
	PORT_PCR1_LK = 0x8000
	// Pin Control Register fields [15:0] are not locked.
	PORT_PCR1_LK_0 = 0x0
	// Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
	PORT_PCR1_LK_1 = 0x1
	// Position of IRQC field.
	PORT_PCR1_IRQC_Pos = 0x10
	// Bit mask of IRQC field.
	PORT_PCR1_IRQC_Msk = 0xf0000
	// Interrupt/DMA request disabled.
	PORT_PCR1_IRQC_0000 = 0x0
	// DMA request on rising edge.
	PORT_PCR1_IRQC_0001 = 0x1
	// DMA request on falling edge.
	PORT_PCR1_IRQC_0010 = 0x2
	// DMA request on either edge.
	PORT_PCR1_IRQC_0011 = 0x3
	// Interrupt when logic 0.
	PORT_PCR1_IRQC_1000 = 0x8
	// Interrupt on rising-edge.
	PORT_PCR1_IRQC_1001 = 0x9
	// Interrupt on falling-edge.
	PORT_PCR1_IRQC_1010 = 0xa
	// Interrupt on either edge.
	PORT_PCR1_IRQC_1011 = 0xb
	// Interrupt when logic 1.
	PORT_PCR1_IRQC_1100 = 0xc
	// Position of ISF field.
	PORT_PCR1_ISF_Pos = 0x18
	// Bit mask of ISF field.
	PORT_PCR1_ISF_Msk = 0x1000000
	// Bit ISF.
	PORT_PCR1_ISF = 0x1000000
	// Configured interrupt is not detected.
	PORT_PCR1_ISF_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_PCR1_ISF_1 = 0x1

	// PCR2: Pin Control Register n
	// Position of PS field.
	PORT_PCR2_PS_Pos = 0x0
	// Bit mask of PS field.
	PORT_PCR2_PS_Msk = 0x1
	// Bit PS.
	PORT_PCR2_PS = 0x1
	// Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR2_PS_0 = 0x0
	// Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR2_PS_1 = 0x1
	// Position of PE field.
	PORT_PCR2_PE_Pos = 0x1
	// Bit mask of PE field.
	PORT_PCR2_PE_Msk = 0x2
	// Bit PE.
	PORT_PCR2_PE = 0x2
	// Internal pullup or pulldown resistor is not enabled on the corresponding pin.
	PORT_PCR2_PE_0 = 0x0
	// Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
	PORT_PCR2_PE_1 = 0x1
	// Position of SRE field.
	PORT_PCR2_SRE_Pos = 0x2
	// Bit mask of SRE field.
	PORT_PCR2_SRE_Msk = 0x4
	// Bit SRE.
	PORT_PCR2_SRE = 0x4
	// Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR2_SRE_0 = 0x0
	// Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR2_SRE_1 = 0x1
	// Position of PFE field.
	PORT_PCR2_PFE_Pos = 0x4
	// Bit mask of PFE field.
	PORT_PCR2_PFE_Msk = 0x10
	// Bit PFE.
	PORT_PCR2_PFE = 0x10
	// Passive input filter is disabled on the corresponding pin.
	PORT_PCR2_PFE_0 = 0x0
	// Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
	PORT_PCR2_PFE_1 = 0x1
	// Position of ODE field.
	PORT_PCR2_ODE_Pos = 0x5
	// Bit mask of ODE field.
	PORT_PCR2_ODE_Msk = 0x20
	// Bit ODE.
	PORT_PCR2_ODE = 0x20
	// Open drain output is disabled on the corresponding pin.
	PORT_PCR2_ODE_0 = 0x0
	// Open drain output is enabled on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR2_ODE_1 = 0x1
	// Position of DSE field.
	PORT_PCR2_DSE_Pos = 0x6
	// Bit mask of DSE field.
	PORT_PCR2_DSE_Msk = 0x40
	// Bit DSE.
	PORT_PCR2_DSE = 0x40
	// Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR2_DSE_0 = 0x0
	// High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR2_DSE_1 = 0x1
	// Position of MUX field.
	PORT_PCR2_MUX_Pos = 0x8
	// Bit mask of MUX field.
	PORT_PCR2_MUX_Msk = 0x700
	// Pin disabled (analog).
	PORT_PCR2_MUX_000 = 0x0
	// Alternative 1 (GPIO).
	PORT_PCR2_MUX_001 = 0x1
	// Alternative 2 (chip-specific).
	PORT_PCR2_MUX_010 = 0x2
	// Alternative 3 (chip-specific).
	PORT_PCR2_MUX_011 = 0x3
	// Alternative 4 (chip-specific).
	PORT_PCR2_MUX_100 = 0x4
	// Alternative 5 (chip-specific).
	PORT_PCR2_MUX_101 = 0x5
	// Alternative 6 (chip-specific).
	PORT_PCR2_MUX_110 = 0x6
	// Alternative 7 (chip-specific).
	PORT_PCR2_MUX_111 = 0x7
	// Position of LK field.
	PORT_PCR2_LK_Pos = 0xf
	// Bit mask of LK field.
	PORT_PCR2_LK_Msk = 0x8000
	// Bit LK.
	PORT_PCR2_LK = 0x8000
	// Pin Control Register fields [15:0] are not locked.
	PORT_PCR2_LK_0 = 0x0
	// Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
	PORT_PCR2_LK_1 = 0x1
	// Position of IRQC field.
	PORT_PCR2_IRQC_Pos = 0x10
	// Bit mask of IRQC field.
	PORT_PCR2_IRQC_Msk = 0xf0000
	// Interrupt/DMA request disabled.
	PORT_PCR2_IRQC_0000 = 0x0
	// DMA request on rising edge.
	PORT_PCR2_IRQC_0001 = 0x1
	// DMA request on falling edge.
	PORT_PCR2_IRQC_0010 = 0x2
	// DMA request on either edge.
	PORT_PCR2_IRQC_0011 = 0x3
	// Interrupt when logic 0.
	PORT_PCR2_IRQC_1000 = 0x8
	// Interrupt on rising-edge.
	PORT_PCR2_IRQC_1001 = 0x9
	// Interrupt on falling-edge.
	PORT_PCR2_IRQC_1010 = 0xa
	// Interrupt on either edge.
	PORT_PCR2_IRQC_1011 = 0xb
	// Interrupt when logic 1.
	PORT_PCR2_IRQC_1100 = 0xc
	// Position of ISF field.
	PORT_PCR2_ISF_Pos = 0x18
	// Bit mask of ISF field.
	PORT_PCR2_ISF_Msk = 0x1000000
	// Bit ISF.
	PORT_PCR2_ISF = 0x1000000
	// Configured interrupt is not detected.
	PORT_PCR2_ISF_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_PCR2_ISF_1 = 0x1

	// PCR3: Pin Control Register n
	// Position of PS field.
	PORT_PCR3_PS_Pos = 0x0
	// Bit mask of PS field.
	PORT_PCR3_PS_Msk = 0x1
	// Bit PS.
	PORT_PCR3_PS = 0x1
	// Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR3_PS_0 = 0x0
	// Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR3_PS_1 = 0x1
	// Position of PE field.
	PORT_PCR3_PE_Pos = 0x1
	// Bit mask of PE field.
	PORT_PCR3_PE_Msk = 0x2
	// Bit PE.
	PORT_PCR3_PE = 0x2
	// Internal pullup or pulldown resistor is not enabled on the corresponding pin.
	PORT_PCR3_PE_0 = 0x0
	// Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
	PORT_PCR3_PE_1 = 0x1
	// Position of SRE field.
	PORT_PCR3_SRE_Pos = 0x2
	// Bit mask of SRE field.
	PORT_PCR3_SRE_Msk = 0x4
	// Bit SRE.
	PORT_PCR3_SRE = 0x4
	// Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR3_SRE_0 = 0x0
	// Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR3_SRE_1 = 0x1
	// Position of PFE field.
	PORT_PCR3_PFE_Pos = 0x4
	// Bit mask of PFE field.
	PORT_PCR3_PFE_Msk = 0x10
	// Bit PFE.
	PORT_PCR3_PFE = 0x10
	// Passive input filter is disabled on the corresponding pin.
	PORT_PCR3_PFE_0 = 0x0
	// Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
	PORT_PCR3_PFE_1 = 0x1
	// Position of ODE field.
	PORT_PCR3_ODE_Pos = 0x5
	// Bit mask of ODE field.
	PORT_PCR3_ODE_Msk = 0x20
	// Bit ODE.
	PORT_PCR3_ODE = 0x20
	// Open drain output is disabled on the corresponding pin.
	PORT_PCR3_ODE_0 = 0x0
	// Open drain output is enabled on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR3_ODE_1 = 0x1
	// Position of DSE field.
	PORT_PCR3_DSE_Pos = 0x6
	// Bit mask of DSE field.
	PORT_PCR3_DSE_Msk = 0x40
	// Bit DSE.
	PORT_PCR3_DSE = 0x40
	// Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR3_DSE_0 = 0x0
	// High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR3_DSE_1 = 0x1
	// Position of MUX field.
	PORT_PCR3_MUX_Pos = 0x8
	// Bit mask of MUX field.
	PORT_PCR3_MUX_Msk = 0x700
	// Pin disabled (analog).
	PORT_PCR3_MUX_000 = 0x0
	// Alternative 1 (GPIO).
	PORT_PCR3_MUX_001 = 0x1
	// Alternative 2 (chip-specific).
	PORT_PCR3_MUX_010 = 0x2
	// Alternative 3 (chip-specific).
	PORT_PCR3_MUX_011 = 0x3
	// Alternative 4 (chip-specific).
	PORT_PCR3_MUX_100 = 0x4
	// Alternative 5 (chip-specific).
	PORT_PCR3_MUX_101 = 0x5
	// Alternative 6 (chip-specific).
	PORT_PCR3_MUX_110 = 0x6
	// Alternative 7 (chip-specific).
	PORT_PCR3_MUX_111 = 0x7
	// Position of LK field.
	PORT_PCR3_LK_Pos = 0xf
	// Bit mask of LK field.
	PORT_PCR3_LK_Msk = 0x8000
	// Bit LK.
	PORT_PCR3_LK = 0x8000
	// Pin Control Register fields [15:0] are not locked.
	PORT_PCR3_LK_0 = 0x0
	// Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
	PORT_PCR3_LK_1 = 0x1
	// Position of IRQC field.
	PORT_PCR3_IRQC_Pos = 0x10
	// Bit mask of IRQC field.
	PORT_PCR3_IRQC_Msk = 0xf0000
	// Interrupt/DMA request disabled.
	PORT_PCR3_IRQC_0000 = 0x0
	// DMA request on rising edge.
	PORT_PCR3_IRQC_0001 = 0x1
	// DMA request on falling edge.
	PORT_PCR3_IRQC_0010 = 0x2
	// DMA request on either edge.
	PORT_PCR3_IRQC_0011 = 0x3
	// Interrupt when logic 0.
	PORT_PCR3_IRQC_1000 = 0x8
	// Interrupt on rising-edge.
	PORT_PCR3_IRQC_1001 = 0x9
	// Interrupt on falling-edge.
	PORT_PCR3_IRQC_1010 = 0xa
	// Interrupt on either edge.
	PORT_PCR3_IRQC_1011 = 0xb
	// Interrupt when logic 1.
	PORT_PCR3_IRQC_1100 = 0xc
	// Position of ISF field.
	PORT_PCR3_ISF_Pos = 0x18
	// Bit mask of ISF field.
	PORT_PCR3_ISF_Msk = 0x1000000
	// Bit ISF.
	PORT_PCR3_ISF = 0x1000000
	// Configured interrupt is not detected.
	PORT_PCR3_ISF_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_PCR3_ISF_1 = 0x1

	// PCR4: Pin Control Register n
	// Position of PS field.
	PORT_PCR4_PS_Pos = 0x0
	// Bit mask of PS field.
	PORT_PCR4_PS_Msk = 0x1
	// Bit PS.
	PORT_PCR4_PS = 0x1
	// Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR4_PS_0 = 0x0
	// Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR4_PS_1 = 0x1
	// Position of PE field.
	PORT_PCR4_PE_Pos = 0x1
	// Bit mask of PE field.
	PORT_PCR4_PE_Msk = 0x2
	// Bit PE.
	PORT_PCR4_PE = 0x2
	// Internal pullup or pulldown resistor is not enabled on the corresponding pin.
	PORT_PCR4_PE_0 = 0x0
	// Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
	PORT_PCR4_PE_1 = 0x1
	// Position of SRE field.
	PORT_PCR4_SRE_Pos = 0x2
	// Bit mask of SRE field.
	PORT_PCR4_SRE_Msk = 0x4
	// Bit SRE.
	PORT_PCR4_SRE = 0x4
	// Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR4_SRE_0 = 0x0
	// Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR4_SRE_1 = 0x1
	// Position of PFE field.
	PORT_PCR4_PFE_Pos = 0x4
	// Bit mask of PFE field.
	PORT_PCR4_PFE_Msk = 0x10
	// Bit PFE.
	PORT_PCR4_PFE = 0x10
	// Passive input filter is disabled on the corresponding pin.
	PORT_PCR4_PFE_0 = 0x0
	// Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
	PORT_PCR4_PFE_1 = 0x1
	// Position of ODE field.
	PORT_PCR4_ODE_Pos = 0x5
	// Bit mask of ODE field.
	PORT_PCR4_ODE_Msk = 0x20
	// Bit ODE.
	PORT_PCR4_ODE = 0x20
	// Open drain output is disabled on the corresponding pin.
	PORT_PCR4_ODE_0 = 0x0
	// Open drain output is enabled on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR4_ODE_1 = 0x1
	// Position of DSE field.
	PORT_PCR4_DSE_Pos = 0x6
	// Bit mask of DSE field.
	PORT_PCR4_DSE_Msk = 0x40
	// Bit DSE.
	PORT_PCR4_DSE = 0x40
	// Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR4_DSE_0 = 0x0
	// High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR4_DSE_1 = 0x1
	// Position of MUX field.
	PORT_PCR4_MUX_Pos = 0x8
	// Bit mask of MUX field.
	PORT_PCR4_MUX_Msk = 0x700
	// Pin disabled (analog).
	PORT_PCR4_MUX_000 = 0x0
	// Alternative 1 (GPIO).
	PORT_PCR4_MUX_001 = 0x1
	// Alternative 2 (chip-specific).
	PORT_PCR4_MUX_010 = 0x2
	// Alternative 3 (chip-specific).
	PORT_PCR4_MUX_011 = 0x3
	// Alternative 4 (chip-specific).
	PORT_PCR4_MUX_100 = 0x4
	// Alternative 5 (chip-specific).
	PORT_PCR4_MUX_101 = 0x5
	// Alternative 6 (chip-specific).
	PORT_PCR4_MUX_110 = 0x6
	// Alternative 7 (chip-specific).
	PORT_PCR4_MUX_111 = 0x7
	// Position of LK field.
	PORT_PCR4_LK_Pos = 0xf
	// Bit mask of LK field.
	PORT_PCR4_LK_Msk = 0x8000
	// Bit LK.
	PORT_PCR4_LK = 0x8000
	// Pin Control Register fields [15:0] are not locked.
	PORT_PCR4_LK_0 = 0x0
	// Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
	PORT_PCR4_LK_1 = 0x1
	// Position of IRQC field.
	PORT_PCR4_IRQC_Pos = 0x10
	// Bit mask of IRQC field.
	PORT_PCR4_IRQC_Msk = 0xf0000
	// Interrupt/DMA request disabled.
	PORT_PCR4_IRQC_0000 = 0x0
	// DMA request on rising edge.
	PORT_PCR4_IRQC_0001 = 0x1
	// DMA request on falling edge.
	PORT_PCR4_IRQC_0010 = 0x2
	// DMA request on either edge.
	PORT_PCR4_IRQC_0011 = 0x3
	// Interrupt when logic 0.
	PORT_PCR4_IRQC_1000 = 0x8
	// Interrupt on rising-edge.
	PORT_PCR4_IRQC_1001 = 0x9
	// Interrupt on falling-edge.
	PORT_PCR4_IRQC_1010 = 0xa
	// Interrupt on either edge.
	PORT_PCR4_IRQC_1011 = 0xb
	// Interrupt when logic 1.
	PORT_PCR4_IRQC_1100 = 0xc
	// Position of ISF field.
	PORT_PCR4_ISF_Pos = 0x18
	// Bit mask of ISF field.
	PORT_PCR4_ISF_Msk = 0x1000000
	// Bit ISF.
	PORT_PCR4_ISF = 0x1000000
	// Configured interrupt is not detected.
	PORT_PCR4_ISF_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_PCR4_ISF_1 = 0x1

	// PCR5: Pin Control Register n
	// Position of PS field.
	PORT_PCR5_PS_Pos = 0x0
	// Bit mask of PS field.
	PORT_PCR5_PS_Msk = 0x1
	// Bit PS.
	PORT_PCR5_PS = 0x1
	// Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR5_PS_0 = 0x0
	// Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR5_PS_1 = 0x1
	// Position of PE field.
	PORT_PCR5_PE_Pos = 0x1
	// Bit mask of PE field.
	PORT_PCR5_PE_Msk = 0x2
	// Bit PE.
	PORT_PCR5_PE = 0x2
	// Internal pullup or pulldown resistor is not enabled on the corresponding pin.
	PORT_PCR5_PE_0 = 0x0
	// Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
	PORT_PCR5_PE_1 = 0x1
	// Position of SRE field.
	PORT_PCR5_SRE_Pos = 0x2
	// Bit mask of SRE field.
	PORT_PCR5_SRE_Msk = 0x4
	// Bit SRE.
	PORT_PCR5_SRE = 0x4
	// Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR5_SRE_0 = 0x0
	// Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR5_SRE_1 = 0x1
	// Position of PFE field.
	PORT_PCR5_PFE_Pos = 0x4
	// Bit mask of PFE field.
	PORT_PCR5_PFE_Msk = 0x10
	// Bit PFE.
	PORT_PCR5_PFE = 0x10
	// Passive input filter is disabled on the corresponding pin.
	PORT_PCR5_PFE_0 = 0x0
	// Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
	PORT_PCR5_PFE_1 = 0x1
	// Position of ODE field.
	PORT_PCR5_ODE_Pos = 0x5
	// Bit mask of ODE field.
	PORT_PCR5_ODE_Msk = 0x20
	// Bit ODE.
	PORT_PCR5_ODE = 0x20
	// Open drain output is disabled on the corresponding pin.
	PORT_PCR5_ODE_0 = 0x0
	// Open drain output is enabled on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR5_ODE_1 = 0x1
	// Position of DSE field.
	PORT_PCR5_DSE_Pos = 0x6
	// Bit mask of DSE field.
	PORT_PCR5_DSE_Msk = 0x40
	// Bit DSE.
	PORT_PCR5_DSE = 0x40
	// Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR5_DSE_0 = 0x0
	// High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR5_DSE_1 = 0x1
	// Position of MUX field.
	PORT_PCR5_MUX_Pos = 0x8
	// Bit mask of MUX field.
	PORT_PCR5_MUX_Msk = 0x700
	// Pin disabled (analog).
	PORT_PCR5_MUX_000 = 0x0
	// Alternative 1 (GPIO).
	PORT_PCR5_MUX_001 = 0x1
	// Alternative 2 (chip-specific).
	PORT_PCR5_MUX_010 = 0x2
	// Alternative 3 (chip-specific).
	PORT_PCR5_MUX_011 = 0x3
	// Alternative 4 (chip-specific).
	PORT_PCR5_MUX_100 = 0x4
	// Alternative 5 (chip-specific).
	PORT_PCR5_MUX_101 = 0x5
	// Alternative 6 (chip-specific).
	PORT_PCR5_MUX_110 = 0x6
	// Alternative 7 (chip-specific).
	PORT_PCR5_MUX_111 = 0x7
	// Position of LK field.
	PORT_PCR5_LK_Pos = 0xf
	// Bit mask of LK field.
	PORT_PCR5_LK_Msk = 0x8000
	// Bit LK.
	PORT_PCR5_LK = 0x8000
	// Pin Control Register fields [15:0] are not locked.
	PORT_PCR5_LK_0 = 0x0
	// Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
	PORT_PCR5_LK_1 = 0x1
	// Position of IRQC field.
	PORT_PCR5_IRQC_Pos = 0x10
	// Bit mask of IRQC field.
	PORT_PCR5_IRQC_Msk = 0xf0000
	// Interrupt/DMA request disabled.
	PORT_PCR5_IRQC_0000 = 0x0
	// DMA request on rising edge.
	PORT_PCR5_IRQC_0001 = 0x1
	// DMA request on falling edge.
	PORT_PCR5_IRQC_0010 = 0x2
	// DMA request on either edge.
	PORT_PCR5_IRQC_0011 = 0x3
	// Interrupt when logic 0.
	PORT_PCR5_IRQC_1000 = 0x8
	// Interrupt on rising-edge.
	PORT_PCR5_IRQC_1001 = 0x9
	// Interrupt on falling-edge.
	PORT_PCR5_IRQC_1010 = 0xa
	// Interrupt on either edge.
	PORT_PCR5_IRQC_1011 = 0xb
	// Interrupt when logic 1.
	PORT_PCR5_IRQC_1100 = 0xc
	// Position of ISF field.
	PORT_PCR5_ISF_Pos = 0x18
	// Bit mask of ISF field.
	PORT_PCR5_ISF_Msk = 0x1000000
	// Bit ISF.
	PORT_PCR5_ISF = 0x1000000
	// Configured interrupt is not detected.
	PORT_PCR5_ISF_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_PCR5_ISF_1 = 0x1

	// PCR6: Pin Control Register n
	// Position of PS field.
	PORT_PCR6_PS_Pos = 0x0
	// Bit mask of PS field.
	PORT_PCR6_PS_Msk = 0x1
	// Bit PS.
	PORT_PCR6_PS = 0x1
	// Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR6_PS_0 = 0x0
	// Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR6_PS_1 = 0x1
	// Position of PE field.
	PORT_PCR6_PE_Pos = 0x1
	// Bit mask of PE field.
	PORT_PCR6_PE_Msk = 0x2
	// Bit PE.
	PORT_PCR6_PE = 0x2
	// Internal pullup or pulldown resistor is not enabled on the corresponding pin.
	PORT_PCR6_PE_0 = 0x0
	// Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
	PORT_PCR6_PE_1 = 0x1
	// Position of SRE field.
	PORT_PCR6_SRE_Pos = 0x2
	// Bit mask of SRE field.
	PORT_PCR6_SRE_Msk = 0x4
	// Bit SRE.
	PORT_PCR6_SRE = 0x4
	// Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR6_SRE_0 = 0x0
	// Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR6_SRE_1 = 0x1
	// Position of PFE field.
	PORT_PCR6_PFE_Pos = 0x4
	// Bit mask of PFE field.
	PORT_PCR6_PFE_Msk = 0x10
	// Bit PFE.
	PORT_PCR6_PFE = 0x10
	// Passive input filter is disabled on the corresponding pin.
	PORT_PCR6_PFE_0 = 0x0
	// Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
	PORT_PCR6_PFE_1 = 0x1
	// Position of ODE field.
	PORT_PCR6_ODE_Pos = 0x5
	// Bit mask of ODE field.
	PORT_PCR6_ODE_Msk = 0x20
	// Bit ODE.
	PORT_PCR6_ODE = 0x20
	// Open drain output is disabled on the corresponding pin.
	PORT_PCR6_ODE_0 = 0x0
	// Open drain output is enabled on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR6_ODE_1 = 0x1
	// Position of DSE field.
	PORT_PCR6_DSE_Pos = 0x6
	// Bit mask of DSE field.
	PORT_PCR6_DSE_Msk = 0x40
	// Bit DSE.
	PORT_PCR6_DSE = 0x40
	// Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR6_DSE_0 = 0x0
	// High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR6_DSE_1 = 0x1
	// Position of MUX field.
	PORT_PCR6_MUX_Pos = 0x8
	// Bit mask of MUX field.
	PORT_PCR6_MUX_Msk = 0x700
	// Pin disabled (analog).
	PORT_PCR6_MUX_000 = 0x0
	// Alternative 1 (GPIO).
	PORT_PCR6_MUX_001 = 0x1
	// Alternative 2 (chip-specific).
	PORT_PCR6_MUX_010 = 0x2
	// Alternative 3 (chip-specific).
	PORT_PCR6_MUX_011 = 0x3
	// Alternative 4 (chip-specific).
	PORT_PCR6_MUX_100 = 0x4
	// Alternative 5 (chip-specific).
	PORT_PCR6_MUX_101 = 0x5
	// Alternative 6 (chip-specific).
	PORT_PCR6_MUX_110 = 0x6
	// Alternative 7 (chip-specific).
	PORT_PCR6_MUX_111 = 0x7
	// Position of LK field.
	PORT_PCR6_LK_Pos = 0xf
	// Bit mask of LK field.
	PORT_PCR6_LK_Msk = 0x8000
	// Bit LK.
	PORT_PCR6_LK = 0x8000
	// Pin Control Register fields [15:0] are not locked.
	PORT_PCR6_LK_0 = 0x0
	// Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
	PORT_PCR6_LK_1 = 0x1
	// Position of IRQC field.
	PORT_PCR6_IRQC_Pos = 0x10
	// Bit mask of IRQC field.
	PORT_PCR6_IRQC_Msk = 0xf0000
	// Interrupt/DMA request disabled.
	PORT_PCR6_IRQC_0000 = 0x0
	// DMA request on rising edge.
	PORT_PCR6_IRQC_0001 = 0x1
	// DMA request on falling edge.
	PORT_PCR6_IRQC_0010 = 0x2
	// DMA request on either edge.
	PORT_PCR6_IRQC_0011 = 0x3
	// Interrupt when logic 0.
	PORT_PCR6_IRQC_1000 = 0x8
	// Interrupt on rising-edge.
	PORT_PCR6_IRQC_1001 = 0x9
	// Interrupt on falling-edge.
	PORT_PCR6_IRQC_1010 = 0xa
	// Interrupt on either edge.
	PORT_PCR6_IRQC_1011 = 0xb
	// Interrupt when logic 1.
	PORT_PCR6_IRQC_1100 = 0xc
	// Position of ISF field.
	PORT_PCR6_ISF_Pos = 0x18
	// Bit mask of ISF field.
	PORT_PCR6_ISF_Msk = 0x1000000
	// Bit ISF.
	PORT_PCR6_ISF = 0x1000000
	// Configured interrupt is not detected.
	PORT_PCR6_ISF_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_PCR6_ISF_1 = 0x1

	// PCR7: Pin Control Register n
	// Position of PS field.
	PORT_PCR7_PS_Pos = 0x0
	// Bit mask of PS field.
	PORT_PCR7_PS_Msk = 0x1
	// Bit PS.
	PORT_PCR7_PS = 0x1
	// Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR7_PS_0 = 0x0
	// Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR7_PS_1 = 0x1
	// Position of PE field.
	PORT_PCR7_PE_Pos = 0x1
	// Bit mask of PE field.
	PORT_PCR7_PE_Msk = 0x2
	// Bit PE.
	PORT_PCR7_PE = 0x2
	// Internal pullup or pulldown resistor is not enabled on the corresponding pin.
	PORT_PCR7_PE_0 = 0x0
	// Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
	PORT_PCR7_PE_1 = 0x1
	// Position of SRE field.
	PORT_PCR7_SRE_Pos = 0x2
	// Bit mask of SRE field.
	PORT_PCR7_SRE_Msk = 0x4
	// Bit SRE.
	PORT_PCR7_SRE = 0x4
	// Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR7_SRE_0 = 0x0
	// Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR7_SRE_1 = 0x1
	// Position of PFE field.
	PORT_PCR7_PFE_Pos = 0x4
	// Bit mask of PFE field.
	PORT_PCR7_PFE_Msk = 0x10
	// Bit PFE.
	PORT_PCR7_PFE = 0x10
	// Passive input filter is disabled on the corresponding pin.
	PORT_PCR7_PFE_0 = 0x0
	// Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
	PORT_PCR7_PFE_1 = 0x1
	// Position of ODE field.
	PORT_PCR7_ODE_Pos = 0x5
	// Bit mask of ODE field.
	PORT_PCR7_ODE_Msk = 0x20
	// Bit ODE.
	PORT_PCR7_ODE = 0x20
	// Open drain output is disabled on the corresponding pin.
	PORT_PCR7_ODE_0 = 0x0
	// Open drain output is enabled on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR7_ODE_1 = 0x1
	// Position of DSE field.
	PORT_PCR7_DSE_Pos = 0x6
	// Bit mask of DSE field.
	PORT_PCR7_DSE_Msk = 0x40
	// Bit DSE.
	PORT_PCR7_DSE = 0x40
	// Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR7_DSE_0 = 0x0
	// High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR7_DSE_1 = 0x1
	// Position of MUX field.
	PORT_PCR7_MUX_Pos = 0x8
	// Bit mask of MUX field.
	PORT_PCR7_MUX_Msk = 0x700
	// Pin disabled (analog).
	PORT_PCR7_MUX_000 = 0x0
	// Alternative 1 (GPIO).
	PORT_PCR7_MUX_001 = 0x1
	// Alternative 2 (chip-specific).
	PORT_PCR7_MUX_010 = 0x2
	// Alternative 3 (chip-specific).
	PORT_PCR7_MUX_011 = 0x3
	// Alternative 4 (chip-specific).
	PORT_PCR7_MUX_100 = 0x4
	// Alternative 5 (chip-specific).
	PORT_PCR7_MUX_101 = 0x5
	// Alternative 6 (chip-specific).
	PORT_PCR7_MUX_110 = 0x6
	// Alternative 7 (chip-specific).
	PORT_PCR7_MUX_111 = 0x7
	// Position of LK field.
	PORT_PCR7_LK_Pos = 0xf
	// Bit mask of LK field.
	PORT_PCR7_LK_Msk = 0x8000
	// Bit LK.
	PORT_PCR7_LK = 0x8000
	// Pin Control Register fields [15:0] are not locked.
	PORT_PCR7_LK_0 = 0x0
	// Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
	PORT_PCR7_LK_1 = 0x1
	// Position of IRQC field.
	PORT_PCR7_IRQC_Pos = 0x10
	// Bit mask of IRQC field.
	PORT_PCR7_IRQC_Msk = 0xf0000
	// Interrupt/DMA request disabled.
	PORT_PCR7_IRQC_0000 = 0x0
	// DMA request on rising edge.
	PORT_PCR7_IRQC_0001 = 0x1
	// DMA request on falling edge.
	PORT_PCR7_IRQC_0010 = 0x2
	// DMA request on either edge.
	PORT_PCR7_IRQC_0011 = 0x3
	// Interrupt when logic 0.
	PORT_PCR7_IRQC_1000 = 0x8
	// Interrupt on rising-edge.
	PORT_PCR7_IRQC_1001 = 0x9
	// Interrupt on falling-edge.
	PORT_PCR7_IRQC_1010 = 0xa
	// Interrupt on either edge.
	PORT_PCR7_IRQC_1011 = 0xb
	// Interrupt when logic 1.
	PORT_PCR7_IRQC_1100 = 0xc
	// Position of ISF field.
	PORT_PCR7_ISF_Pos = 0x18
	// Bit mask of ISF field.
	PORT_PCR7_ISF_Msk = 0x1000000
	// Bit ISF.
	PORT_PCR7_ISF = 0x1000000
	// Configured interrupt is not detected.
	PORT_PCR7_ISF_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_PCR7_ISF_1 = 0x1

	// PCR8: Pin Control Register n
	// Position of PS field.
	PORT_PCR8_PS_Pos = 0x0
	// Bit mask of PS field.
	PORT_PCR8_PS_Msk = 0x1
	// Bit PS.
	PORT_PCR8_PS = 0x1
	// Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR8_PS_0 = 0x0
	// Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR8_PS_1 = 0x1
	// Position of PE field.
	PORT_PCR8_PE_Pos = 0x1
	// Bit mask of PE field.
	PORT_PCR8_PE_Msk = 0x2
	// Bit PE.
	PORT_PCR8_PE = 0x2
	// Internal pullup or pulldown resistor is not enabled on the corresponding pin.
	PORT_PCR8_PE_0 = 0x0
	// Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
	PORT_PCR8_PE_1 = 0x1
	// Position of SRE field.
	PORT_PCR8_SRE_Pos = 0x2
	// Bit mask of SRE field.
	PORT_PCR8_SRE_Msk = 0x4
	// Bit SRE.
	PORT_PCR8_SRE = 0x4
	// Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR8_SRE_0 = 0x0
	// Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR8_SRE_1 = 0x1
	// Position of PFE field.
	PORT_PCR8_PFE_Pos = 0x4
	// Bit mask of PFE field.
	PORT_PCR8_PFE_Msk = 0x10
	// Bit PFE.
	PORT_PCR8_PFE = 0x10
	// Passive input filter is disabled on the corresponding pin.
	PORT_PCR8_PFE_0 = 0x0
	// Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
	PORT_PCR8_PFE_1 = 0x1
	// Position of ODE field.
	PORT_PCR8_ODE_Pos = 0x5
	// Bit mask of ODE field.
	PORT_PCR8_ODE_Msk = 0x20
	// Bit ODE.
	PORT_PCR8_ODE = 0x20
	// Open drain output is disabled on the corresponding pin.
	PORT_PCR8_ODE_0 = 0x0
	// Open drain output is enabled on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR8_ODE_1 = 0x1
	// Position of DSE field.
	PORT_PCR8_DSE_Pos = 0x6
	// Bit mask of DSE field.
	PORT_PCR8_DSE_Msk = 0x40
	// Bit DSE.
	PORT_PCR8_DSE = 0x40
	// Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR8_DSE_0 = 0x0
	// High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR8_DSE_1 = 0x1
	// Position of MUX field.
	PORT_PCR8_MUX_Pos = 0x8
	// Bit mask of MUX field.
	PORT_PCR8_MUX_Msk = 0x700
	// Pin disabled (analog).
	PORT_PCR8_MUX_000 = 0x0
	// Alternative 1 (GPIO).
	PORT_PCR8_MUX_001 = 0x1
	// Alternative 2 (chip-specific).
	PORT_PCR8_MUX_010 = 0x2
	// Alternative 3 (chip-specific).
	PORT_PCR8_MUX_011 = 0x3
	// Alternative 4 (chip-specific).
	PORT_PCR8_MUX_100 = 0x4
	// Alternative 5 (chip-specific).
	PORT_PCR8_MUX_101 = 0x5
	// Alternative 6 (chip-specific).
	PORT_PCR8_MUX_110 = 0x6
	// Alternative 7 (chip-specific).
	PORT_PCR8_MUX_111 = 0x7
	// Position of LK field.
	PORT_PCR8_LK_Pos = 0xf
	// Bit mask of LK field.
	PORT_PCR8_LK_Msk = 0x8000
	// Bit LK.
	PORT_PCR8_LK = 0x8000
	// Pin Control Register fields [15:0] are not locked.
	PORT_PCR8_LK_0 = 0x0
	// Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
	PORT_PCR8_LK_1 = 0x1
	// Position of IRQC field.
	PORT_PCR8_IRQC_Pos = 0x10
	// Bit mask of IRQC field.
	PORT_PCR8_IRQC_Msk = 0xf0000
	// Interrupt/DMA request disabled.
	PORT_PCR8_IRQC_0000 = 0x0
	// DMA request on rising edge.
	PORT_PCR8_IRQC_0001 = 0x1
	// DMA request on falling edge.
	PORT_PCR8_IRQC_0010 = 0x2
	// DMA request on either edge.
	PORT_PCR8_IRQC_0011 = 0x3
	// Interrupt when logic 0.
	PORT_PCR8_IRQC_1000 = 0x8
	// Interrupt on rising-edge.
	PORT_PCR8_IRQC_1001 = 0x9
	// Interrupt on falling-edge.
	PORT_PCR8_IRQC_1010 = 0xa
	// Interrupt on either edge.
	PORT_PCR8_IRQC_1011 = 0xb
	// Interrupt when logic 1.
	PORT_PCR8_IRQC_1100 = 0xc
	// Position of ISF field.
	PORT_PCR8_ISF_Pos = 0x18
	// Bit mask of ISF field.
	PORT_PCR8_ISF_Msk = 0x1000000
	// Bit ISF.
	PORT_PCR8_ISF = 0x1000000
	// Configured interrupt is not detected.
	PORT_PCR8_ISF_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_PCR8_ISF_1 = 0x1

	// PCR9: Pin Control Register n
	// Position of PS field.
	PORT_PCR9_PS_Pos = 0x0
	// Bit mask of PS field.
	PORT_PCR9_PS_Msk = 0x1
	// Bit PS.
	PORT_PCR9_PS = 0x1
	// Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR9_PS_0 = 0x0
	// Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR9_PS_1 = 0x1
	// Position of PE field.
	PORT_PCR9_PE_Pos = 0x1
	// Bit mask of PE field.
	PORT_PCR9_PE_Msk = 0x2
	// Bit PE.
	PORT_PCR9_PE = 0x2
	// Internal pullup or pulldown resistor is not enabled on the corresponding pin.
	PORT_PCR9_PE_0 = 0x0
	// Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
	PORT_PCR9_PE_1 = 0x1
	// Position of SRE field.
	PORT_PCR9_SRE_Pos = 0x2
	// Bit mask of SRE field.
	PORT_PCR9_SRE_Msk = 0x4
	// Bit SRE.
	PORT_PCR9_SRE = 0x4
	// Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR9_SRE_0 = 0x0
	// Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR9_SRE_1 = 0x1
	// Position of PFE field.
	PORT_PCR9_PFE_Pos = 0x4
	// Bit mask of PFE field.
	PORT_PCR9_PFE_Msk = 0x10
	// Bit PFE.
	PORT_PCR9_PFE = 0x10
	// Passive input filter is disabled on the corresponding pin.
	PORT_PCR9_PFE_0 = 0x0
	// Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
	PORT_PCR9_PFE_1 = 0x1
	// Position of ODE field.
	PORT_PCR9_ODE_Pos = 0x5
	// Bit mask of ODE field.
	PORT_PCR9_ODE_Msk = 0x20
	// Bit ODE.
	PORT_PCR9_ODE = 0x20
	// Open drain output is disabled on the corresponding pin.
	PORT_PCR9_ODE_0 = 0x0
	// Open drain output is enabled on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR9_ODE_1 = 0x1
	// Position of DSE field.
	PORT_PCR9_DSE_Pos = 0x6
	// Bit mask of DSE field.
	PORT_PCR9_DSE_Msk = 0x40
	// Bit DSE.
	PORT_PCR9_DSE = 0x40
	// Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR9_DSE_0 = 0x0
	// High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR9_DSE_1 = 0x1
	// Position of MUX field.
	PORT_PCR9_MUX_Pos = 0x8
	// Bit mask of MUX field.
	PORT_PCR9_MUX_Msk = 0x700
	// Pin disabled (analog).
	PORT_PCR9_MUX_000 = 0x0
	// Alternative 1 (GPIO).
	PORT_PCR9_MUX_001 = 0x1
	// Alternative 2 (chip-specific).
	PORT_PCR9_MUX_010 = 0x2
	// Alternative 3 (chip-specific).
	PORT_PCR9_MUX_011 = 0x3
	// Alternative 4 (chip-specific).
	PORT_PCR9_MUX_100 = 0x4
	// Alternative 5 (chip-specific).
	PORT_PCR9_MUX_101 = 0x5
	// Alternative 6 (chip-specific).
	PORT_PCR9_MUX_110 = 0x6
	// Alternative 7 (chip-specific).
	PORT_PCR9_MUX_111 = 0x7
	// Position of LK field.
	PORT_PCR9_LK_Pos = 0xf
	// Bit mask of LK field.
	PORT_PCR9_LK_Msk = 0x8000
	// Bit LK.
	PORT_PCR9_LK = 0x8000
	// Pin Control Register fields [15:0] are not locked.
	PORT_PCR9_LK_0 = 0x0
	// Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
	PORT_PCR9_LK_1 = 0x1
	// Position of IRQC field.
	PORT_PCR9_IRQC_Pos = 0x10
	// Bit mask of IRQC field.
	PORT_PCR9_IRQC_Msk = 0xf0000
	// Interrupt/DMA request disabled.
	PORT_PCR9_IRQC_0000 = 0x0
	// DMA request on rising edge.
	PORT_PCR9_IRQC_0001 = 0x1
	// DMA request on falling edge.
	PORT_PCR9_IRQC_0010 = 0x2
	// DMA request on either edge.
	PORT_PCR9_IRQC_0011 = 0x3
	// Interrupt when logic 0.
	PORT_PCR9_IRQC_1000 = 0x8
	// Interrupt on rising-edge.
	PORT_PCR9_IRQC_1001 = 0x9
	// Interrupt on falling-edge.
	PORT_PCR9_IRQC_1010 = 0xa
	// Interrupt on either edge.
	PORT_PCR9_IRQC_1011 = 0xb
	// Interrupt when logic 1.
	PORT_PCR9_IRQC_1100 = 0xc
	// Position of ISF field.
	PORT_PCR9_ISF_Pos = 0x18
	// Bit mask of ISF field.
	PORT_PCR9_ISF_Msk = 0x1000000
	// Bit ISF.
	PORT_PCR9_ISF = 0x1000000
	// Configured interrupt is not detected.
	PORT_PCR9_ISF_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_PCR9_ISF_1 = 0x1

	// PCR10: Pin Control Register n
	// Position of PS field.
	PORT_PCR10_PS_Pos = 0x0
	// Bit mask of PS field.
	PORT_PCR10_PS_Msk = 0x1
	// Bit PS.
	PORT_PCR10_PS = 0x1
	// Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR10_PS_0 = 0x0
	// Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR10_PS_1 = 0x1
	// Position of PE field.
	PORT_PCR10_PE_Pos = 0x1
	// Bit mask of PE field.
	PORT_PCR10_PE_Msk = 0x2
	// Bit PE.
	PORT_PCR10_PE = 0x2
	// Internal pullup or pulldown resistor is not enabled on the corresponding pin.
	PORT_PCR10_PE_0 = 0x0
	// Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
	PORT_PCR10_PE_1 = 0x1
	// Position of SRE field.
	PORT_PCR10_SRE_Pos = 0x2
	// Bit mask of SRE field.
	PORT_PCR10_SRE_Msk = 0x4
	// Bit SRE.
	PORT_PCR10_SRE = 0x4
	// Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR10_SRE_0 = 0x0
	// Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR10_SRE_1 = 0x1
	// Position of PFE field.
	PORT_PCR10_PFE_Pos = 0x4
	// Bit mask of PFE field.
	PORT_PCR10_PFE_Msk = 0x10
	// Bit PFE.
	PORT_PCR10_PFE = 0x10
	// Passive input filter is disabled on the corresponding pin.
	PORT_PCR10_PFE_0 = 0x0
	// Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
	PORT_PCR10_PFE_1 = 0x1
	// Position of ODE field.
	PORT_PCR10_ODE_Pos = 0x5
	// Bit mask of ODE field.
	PORT_PCR10_ODE_Msk = 0x20
	// Bit ODE.
	PORT_PCR10_ODE = 0x20
	// Open drain output is disabled on the corresponding pin.
	PORT_PCR10_ODE_0 = 0x0
	// Open drain output is enabled on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR10_ODE_1 = 0x1
	// Position of DSE field.
	PORT_PCR10_DSE_Pos = 0x6
	// Bit mask of DSE field.
	PORT_PCR10_DSE_Msk = 0x40
	// Bit DSE.
	PORT_PCR10_DSE = 0x40
	// Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR10_DSE_0 = 0x0
	// High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR10_DSE_1 = 0x1
	// Position of MUX field.
	PORT_PCR10_MUX_Pos = 0x8
	// Bit mask of MUX field.
	PORT_PCR10_MUX_Msk = 0x700
	// Pin disabled (analog).
	PORT_PCR10_MUX_000 = 0x0
	// Alternative 1 (GPIO).
	PORT_PCR10_MUX_001 = 0x1
	// Alternative 2 (chip-specific).
	PORT_PCR10_MUX_010 = 0x2
	// Alternative 3 (chip-specific).
	PORT_PCR10_MUX_011 = 0x3
	// Alternative 4 (chip-specific).
	PORT_PCR10_MUX_100 = 0x4
	// Alternative 5 (chip-specific).
	PORT_PCR10_MUX_101 = 0x5
	// Alternative 6 (chip-specific).
	PORT_PCR10_MUX_110 = 0x6
	// Alternative 7 (chip-specific).
	PORT_PCR10_MUX_111 = 0x7
	// Position of LK field.
	PORT_PCR10_LK_Pos = 0xf
	// Bit mask of LK field.
	PORT_PCR10_LK_Msk = 0x8000
	// Bit LK.
	PORT_PCR10_LK = 0x8000
	// Pin Control Register fields [15:0] are not locked.
	PORT_PCR10_LK_0 = 0x0
	// Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
	PORT_PCR10_LK_1 = 0x1
	// Position of IRQC field.
	PORT_PCR10_IRQC_Pos = 0x10
	// Bit mask of IRQC field.
	PORT_PCR10_IRQC_Msk = 0xf0000
	// Interrupt/DMA request disabled.
	PORT_PCR10_IRQC_0000 = 0x0
	// DMA request on rising edge.
	PORT_PCR10_IRQC_0001 = 0x1
	// DMA request on falling edge.
	PORT_PCR10_IRQC_0010 = 0x2
	// DMA request on either edge.
	PORT_PCR10_IRQC_0011 = 0x3
	// Interrupt when logic 0.
	PORT_PCR10_IRQC_1000 = 0x8
	// Interrupt on rising-edge.
	PORT_PCR10_IRQC_1001 = 0x9
	// Interrupt on falling-edge.
	PORT_PCR10_IRQC_1010 = 0xa
	// Interrupt on either edge.
	PORT_PCR10_IRQC_1011 = 0xb
	// Interrupt when logic 1.
	PORT_PCR10_IRQC_1100 = 0xc
	// Position of ISF field.
	PORT_PCR10_ISF_Pos = 0x18
	// Bit mask of ISF field.
	PORT_PCR10_ISF_Msk = 0x1000000
	// Bit ISF.
	PORT_PCR10_ISF = 0x1000000
	// Configured interrupt is not detected.
	PORT_PCR10_ISF_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_PCR10_ISF_1 = 0x1

	// PCR11: Pin Control Register n
	// Position of PS field.
	PORT_PCR11_PS_Pos = 0x0
	// Bit mask of PS field.
	PORT_PCR11_PS_Msk = 0x1
	// Bit PS.
	PORT_PCR11_PS = 0x1
	// Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR11_PS_0 = 0x0
	// Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR11_PS_1 = 0x1
	// Position of PE field.
	PORT_PCR11_PE_Pos = 0x1
	// Bit mask of PE field.
	PORT_PCR11_PE_Msk = 0x2
	// Bit PE.
	PORT_PCR11_PE = 0x2
	// Internal pullup or pulldown resistor is not enabled on the corresponding pin.
	PORT_PCR11_PE_0 = 0x0
	// Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
	PORT_PCR11_PE_1 = 0x1
	// Position of SRE field.
	PORT_PCR11_SRE_Pos = 0x2
	// Bit mask of SRE field.
	PORT_PCR11_SRE_Msk = 0x4
	// Bit SRE.
	PORT_PCR11_SRE = 0x4
	// Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR11_SRE_0 = 0x0
	// Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR11_SRE_1 = 0x1
	// Position of PFE field.
	PORT_PCR11_PFE_Pos = 0x4
	// Bit mask of PFE field.
	PORT_PCR11_PFE_Msk = 0x10
	// Bit PFE.
	PORT_PCR11_PFE = 0x10
	// Passive input filter is disabled on the corresponding pin.
	PORT_PCR11_PFE_0 = 0x0
	// Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
	PORT_PCR11_PFE_1 = 0x1
	// Position of ODE field.
	PORT_PCR11_ODE_Pos = 0x5
	// Bit mask of ODE field.
	PORT_PCR11_ODE_Msk = 0x20
	// Bit ODE.
	PORT_PCR11_ODE = 0x20
	// Open drain output is disabled on the corresponding pin.
	PORT_PCR11_ODE_0 = 0x0
	// Open drain output is enabled on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR11_ODE_1 = 0x1
	// Position of DSE field.
	PORT_PCR11_DSE_Pos = 0x6
	// Bit mask of DSE field.
	PORT_PCR11_DSE_Msk = 0x40
	// Bit DSE.
	PORT_PCR11_DSE = 0x40
	// Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR11_DSE_0 = 0x0
	// High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR11_DSE_1 = 0x1
	// Position of MUX field.
	PORT_PCR11_MUX_Pos = 0x8
	// Bit mask of MUX field.
	PORT_PCR11_MUX_Msk = 0x700
	// Pin disabled (analog).
	PORT_PCR11_MUX_000 = 0x0
	// Alternative 1 (GPIO).
	PORT_PCR11_MUX_001 = 0x1
	// Alternative 2 (chip-specific).
	PORT_PCR11_MUX_010 = 0x2
	// Alternative 3 (chip-specific).
	PORT_PCR11_MUX_011 = 0x3
	// Alternative 4 (chip-specific).
	PORT_PCR11_MUX_100 = 0x4
	// Alternative 5 (chip-specific).
	PORT_PCR11_MUX_101 = 0x5
	// Alternative 6 (chip-specific).
	PORT_PCR11_MUX_110 = 0x6
	// Alternative 7 (chip-specific).
	PORT_PCR11_MUX_111 = 0x7
	// Position of LK field.
	PORT_PCR11_LK_Pos = 0xf
	// Bit mask of LK field.
	PORT_PCR11_LK_Msk = 0x8000
	// Bit LK.
	PORT_PCR11_LK = 0x8000
	// Pin Control Register fields [15:0] are not locked.
	PORT_PCR11_LK_0 = 0x0
	// Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
	PORT_PCR11_LK_1 = 0x1
	// Position of IRQC field.
	PORT_PCR11_IRQC_Pos = 0x10
	// Bit mask of IRQC field.
	PORT_PCR11_IRQC_Msk = 0xf0000
	// Interrupt/DMA request disabled.
	PORT_PCR11_IRQC_0000 = 0x0
	// DMA request on rising edge.
	PORT_PCR11_IRQC_0001 = 0x1
	// DMA request on falling edge.
	PORT_PCR11_IRQC_0010 = 0x2
	// DMA request on either edge.
	PORT_PCR11_IRQC_0011 = 0x3
	// Interrupt when logic 0.
	PORT_PCR11_IRQC_1000 = 0x8
	// Interrupt on rising-edge.
	PORT_PCR11_IRQC_1001 = 0x9
	// Interrupt on falling-edge.
	PORT_PCR11_IRQC_1010 = 0xa
	// Interrupt on either edge.
	PORT_PCR11_IRQC_1011 = 0xb
	// Interrupt when logic 1.
	PORT_PCR11_IRQC_1100 = 0xc
	// Position of ISF field.
	PORT_PCR11_ISF_Pos = 0x18
	// Bit mask of ISF field.
	PORT_PCR11_ISF_Msk = 0x1000000
	// Bit ISF.
	PORT_PCR11_ISF = 0x1000000
	// Configured interrupt is not detected.
	PORT_PCR11_ISF_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_PCR11_ISF_1 = 0x1

	// PCR12: Pin Control Register n
	// Position of PS field.
	PORT_PCR12_PS_Pos = 0x0
	// Bit mask of PS field.
	PORT_PCR12_PS_Msk = 0x1
	// Bit PS.
	PORT_PCR12_PS = 0x1
	// Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR12_PS_0 = 0x0
	// Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR12_PS_1 = 0x1
	// Position of PE field.
	PORT_PCR12_PE_Pos = 0x1
	// Bit mask of PE field.
	PORT_PCR12_PE_Msk = 0x2
	// Bit PE.
	PORT_PCR12_PE = 0x2
	// Internal pullup or pulldown resistor is not enabled on the corresponding pin.
	PORT_PCR12_PE_0 = 0x0
	// Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
	PORT_PCR12_PE_1 = 0x1
	// Position of SRE field.
	PORT_PCR12_SRE_Pos = 0x2
	// Bit mask of SRE field.
	PORT_PCR12_SRE_Msk = 0x4
	// Bit SRE.
	PORT_PCR12_SRE = 0x4
	// Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR12_SRE_0 = 0x0
	// Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR12_SRE_1 = 0x1
	// Position of PFE field.
	PORT_PCR12_PFE_Pos = 0x4
	// Bit mask of PFE field.
	PORT_PCR12_PFE_Msk = 0x10
	// Bit PFE.
	PORT_PCR12_PFE = 0x10
	// Passive input filter is disabled on the corresponding pin.
	PORT_PCR12_PFE_0 = 0x0
	// Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
	PORT_PCR12_PFE_1 = 0x1
	// Position of ODE field.
	PORT_PCR12_ODE_Pos = 0x5
	// Bit mask of ODE field.
	PORT_PCR12_ODE_Msk = 0x20
	// Bit ODE.
	PORT_PCR12_ODE = 0x20
	// Open drain output is disabled on the corresponding pin.
	PORT_PCR12_ODE_0 = 0x0
	// Open drain output is enabled on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR12_ODE_1 = 0x1
	// Position of DSE field.
	PORT_PCR12_DSE_Pos = 0x6
	// Bit mask of DSE field.
	PORT_PCR12_DSE_Msk = 0x40
	// Bit DSE.
	PORT_PCR12_DSE = 0x40
	// Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR12_DSE_0 = 0x0
	// High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR12_DSE_1 = 0x1
	// Position of MUX field.
	PORT_PCR12_MUX_Pos = 0x8
	// Bit mask of MUX field.
	PORT_PCR12_MUX_Msk = 0x700
	// Pin disabled (analog).
	PORT_PCR12_MUX_000 = 0x0
	// Alternative 1 (GPIO).
	PORT_PCR12_MUX_001 = 0x1
	// Alternative 2 (chip-specific).
	PORT_PCR12_MUX_010 = 0x2
	// Alternative 3 (chip-specific).
	PORT_PCR12_MUX_011 = 0x3
	// Alternative 4 (chip-specific).
	PORT_PCR12_MUX_100 = 0x4
	// Alternative 5 (chip-specific).
	PORT_PCR12_MUX_101 = 0x5
	// Alternative 6 (chip-specific).
	PORT_PCR12_MUX_110 = 0x6
	// Alternative 7 (chip-specific).
	PORT_PCR12_MUX_111 = 0x7
	// Position of LK field.
	PORT_PCR12_LK_Pos = 0xf
	// Bit mask of LK field.
	PORT_PCR12_LK_Msk = 0x8000
	// Bit LK.
	PORT_PCR12_LK = 0x8000
	// Pin Control Register fields [15:0] are not locked.
	PORT_PCR12_LK_0 = 0x0
	// Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
	PORT_PCR12_LK_1 = 0x1
	// Position of IRQC field.
	PORT_PCR12_IRQC_Pos = 0x10
	// Bit mask of IRQC field.
	PORT_PCR12_IRQC_Msk = 0xf0000
	// Interrupt/DMA request disabled.
	PORT_PCR12_IRQC_0000 = 0x0
	// DMA request on rising edge.
	PORT_PCR12_IRQC_0001 = 0x1
	// DMA request on falling edge.
	PORT_PCR12_IRQC_0010 = 0x2
	// DMA request on either edge.
	PORT_PCR12_IRQC_0011 = 0x3
	// Interrupt when logic 0.
	PORT_PCR12_IRQC_1000 = 0x8
	// Interrupt on rising-edge.
	PORT_PCR12_IRQC_1001 = 0x9
	// Interrupt on falling-edge.
	PORT_PCR12_IRQC_1010 = 0xa
	// Interrupt on either edge.
	PORT_PCR12_IRQC_1011 = 0xb
	// Interrupt when logic 1.
	PORT_PCR12_IRQC_1100 = 0xc
	// Position of ISF field.
	PORT_PCR12_ISF_Pos = 0x18
	// Bit mask of ISF field.
	PORT_PCR12_ISF_Msk = 0x1000000
	// Bit ISF.
	PORT_PCR12_ISF = 0x1000000
	// Configured interrupt is not detected.
	PORT_PCR12_ISF_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_PCR12_ISF_1 = 0x1

	// PCR13: Pin Control Register n
	// Position of PS field.
	PORT_PCR13_PS_Pos = 0x0
	// Bit mask of PS field.
	PORT_PCR13_PS_Msk = 0x1
	// Bit PS.
	PORT_PCR13_PS = 0x1
	// Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR13_PS_0 = 0x0
	// Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR13_PS_1 = 0x1
	// Position of PE field.
	PORT_PCR13_PE_Pos = 0x1
	// Bit mask of PE field.
	PORT_PCR13_PE_Msk = 0x2
	// Bit PE.
	PORT_PCR13_PE = 0x2
	// Internal pullup or pulldown resistor is not enabled on the corresponding pin.
	PORT_PCR13_PE_0 = 0x0
	// Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
	PORT_PCR13_PE_1 = 0x1
	// Position of SRE field.
	PORT_PCR13_SRE_Pos = 0x2
	// Bit mask of SRE field.
	PORT_PCR13_SRE_Msk = 0x4
	// Bit SRE.
	PORT_PCR13_SRE = 0x4
	// Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR13_SRE_0 = 0x0
	// Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR13_SRE_1 = 0x1
	// Position of PFE field.
	PORT_PCR13_PFE_Pos = 0x4
	// Bit mask of PFE field.
	PORT_PCR13_PFE_Msk = 0x10
	// Bit PFE.
	PORT_PCR13_PFE = 0x10
	// Passive input filter is disabled on the corresponding pin.
	PORT_PCR13_PFE_0 = 0x0
	// Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
	PORT_PCR13_PFE_1 = 0x1
	// Position of ODE field.
	PORT_PCR13_ODE_Pos = 0x5
	// Bit mask of ODE field.
	PORT_PCR13_ODE_Msk = 0x20
	// Bit ODE.
	PORT_PCR13_ODE = 0x20
	// Open drain output is disabled on the corresponding pin.
	PORT_PCR13_ODE_0 = 0x0
	// Open drain output is enabled on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR13_ODE_1 = 0x1
	// Position of DSE field.
	PORT_PCR13_DSE_Pos = 0x6
	// Bit mask of DSE field.
	PORT_PCR13_DSE_Msk = 0x40
	// Bit DSE.
	PORT_PCR13_DSE = 0x40
	// Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR13_DSE_0 = 0x0
	// High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR13_DSE_1 = 0x1
	// Position of MUX field.
	PORT_PCR13_MUX_Pos = 0x8
	// Bit mask of MUX field.
	PORT_PCR13_MUX_Msk = 0x700
	// Pin disabled (analog).
	PORT_PCR13_MUX_000 = 0x0
	// Alternative 1 (GPIO).
	PORT_PCR13_MUX_001 = 0x1
	// Alternative 2 (chip-specific).
	PORT_PCR13_MUX_010 = 0x2
	// Alternative 3 (chip-specific).
	PORT_PCR13_MUX_011 = 0x3
	// Alternative 4 (chip-specific).
	PORT_PCR13_MUX_100 = 0x4
	// Alternative 5 (chip-specific).
	PORT_PCR13_MUX_101 = 0x5
	// Alternative 6 (chip-specific).
	PORT_PCR13_MUX_110 = 0x6
	// Alternative 7 (chip-specific).
	PORT_PCR13_MUX_111 = 0x7
	// Position of LK field.
	PORT_PCR13_LK_Pos = 0xf
	// Bit mask of LK field.
	PORT_PCR13_LK_Msk = 0x8000
	// Bit LK.
	PORT_PCR13_LK = 0x8000
	// Pin Control Register fields [15:0] are not locked.
	PORT_PCR13_LK_0 = 0x0
	// Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
	PORT_PCR13_LK_1 = 0x1
	// Position of IRQC field.
	PORT_PCR13_IRQC_Pos = 0x10
	// Bit mask of IRQC field.
	PORT_PCR13_IRQC_Msk = 0xf0000
	// Interrupt/DMA request disabled.
	PORT_PCR13_IRQC_0000 = 0x0
	// DMA request on rising edge.
	PORT_PCR13_IRQC_0001 = 0x1
	// DMA request on falling edge.
	PORT_PCR13_IRQC_0010 = 0x2
	// DMA request on either edge.
	PORT_PCR13_IRQC_0011 = 0x3
	// Interrupt when logic 0.
	PORT_PCR13_IRQC_1000 = 0x8
	// Interrupt on rising-edge.
	PORT_PCR13_IRQC_1001 = 0x9
	// Interrupt on falling-edge.
	PORT_PCR13_IRQC_1010 = 0xa
	// Interrupt on either edge.
	PORT_PCR13_IRQC_1011 = 0xb
	// Interrupt when logic 1.
	PORT_PCR13_IRQC_1100 = 0xc
	// Position of ISF field.
	PORT_PCR13_ISF_Pos = 0x18
	// Bit mask of ISF field.
	PORT_PCR13_ISF_Msk = 0x1000000
	// Bit ISF.
	PORT_PCR13_ISF = 0x1000000
	// Configured interrupt is not detected.
	PORT_PCR13_ISF_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_PCR13_ISF_1 = 0x1

	// PCR14: Pin Control Register n
	// Position of PS field.
	PORT_PCR14_PS_Pos = 0x0
	// Bit mask of PS field.
	PORT_PCR14_PS_Msk = 0x1
	// Bit PS.
	PORT_PCR14_PS = 0x1
	// Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR14_PS_0 = 0x0
	// Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR14_PS_1 = 0x1
	// Position of PE field.
	PORT_PCR14_PE_Pos = 0x1
	// Bit mask of PE field.
	PORT_PCR14_PE_Msk = 0x2
	// Bit PE.
	PORT_PCR14_PE = 0x2
	// Internal pullup or pulldown resistor is not enabled on the corresponding pin.
	PORT_PCR14_PE_0 = 0x0
	// Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
	PORT_PCR14_PE_1 = 0x1
	// Position of SRE field.
	PORT_PCR14_SRE_Pos = 0x2
	// Bit mask of SRE field.
	PORT_PCR14_SRE_Msk = 0x4
	// Bit SRE.
	PORT_PCR14_SRE = 0x4
	// Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR14_SRE_0 = 0x0
	// Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR14_SRE_1 = 0x1
	// Position of PFE field.
	PORT_PCR14_PFE_Pos = 0x4
	// Bit mask of PFE field.
	PORT_PCR14_PFE_Msk = 0x10
	// Bit PFE.
	PORT_PCR14_PFE = 0x10
	// Passive input filter is disabled on the corresponding pin.
	PORT_PCR14_PFE_0 = 0x0
	// Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
	PORT_PCR14_PFE_1 = 0x1
	// Position of ODE field.
	PORT_PCR14_ODE_Pos = 0x5
	// Bit mask of ODE field.
	PORT_PCR14_ODE_Msk = 0x20
	// Bit ODE.
	PORT_PCR14_ODE = 0x20
	// Open drain output is disabled on the corresponding pin.
	PORT_PCR14_ODE_0 = 0x0
	// Open drain output is enabled on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR14_ODE_1 = 0x1
	// Position of DSE field.
	PORT_PCR14_DSE_Pos = 0x6
	// Bit mask of DSE field.
	PORT_PCR14_DSE_Msk = 0x40
	// Bit DSE.
	PORT_PCR14_DSE = 0x40
	// Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR14_DSE_0 = 0x0
	// High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR14_DSE_1 = 0x1
	// Position of MUX field.
	PORT_PCR14_MUX_Pos = 0x8
	// Bit mask of MUX field.
	PORT_PCR14_MUX_Msk = 0x700
	// Pin disabled (analog).
	PORT_PCR14_MUX_000 = 0x0
	// Alternative 1 (GPIO).
	PORT_PCR14_MUX_001 = 0x1
	// Alternative 2 (chip-specific).
	PORT_PCR14_MUX_010 = 0x2
	// Alternative 3 (chip-specific).
	PORT_PCR14_MUX_011 = 0x3
	// Alternative 4 (chip-specific).
	PORT_PCR14_MUX_100 = 0x4
	// Alternative 5 (chip-specific).
	PORT_PCR14_MUX_101 = 0x5
	// Alternative 6 (chip-specific).
	PORT_PCR14_MUX_110 = 0x6
	// Alternative 7 (chip-specific).
	PORT_PCR14_MUX_111 = 0x7
	// Position of LK field.
	PORT_PCR14_LK_Pos = 0xf
	// Bit mask of LK field.
	PORT_PCR14_LK_Msk = 0x8000
	// Bit LK.
	PORT_PCR14_LK = 0x8000
	// Pin Control Register fields [15:0] are not locked.
	PORT_PCR14_LK_0 = 0x0
	// Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
	PORT_PCR14_LK_1 = 0x1
	// Position of IRQC field.
	PORT_PCR14_IRQC_Pos = 0x10
	// Bit mask of IRQC field.
	PORT_PCR14_IRQC_Msk = 0xf0000
	// Interrupt/DMA request disabled.
	PORT_PCR14_IRQC_0000 = 0x0
	// DMA request on rising edge.
	PORT_PCR14_IRQC_0001 = 0x1
	// DMA request on falling edge.
	PORT_PCR14_IRQC_0010 = 0x2
	// DMA request on either edge.
	PORT_PCR14_IRQC_0011 = 0x3
	// Interrupt when logic 0.
	PORT_PCR14_IRQC_1000 = 0x8
	// Interrupt on rising-edge.
	PORT_PCR14_IRQC_1001 = 0x9
	// Interrupt on falling-edge.
	PORT_PCR14_IRQC_1010 = 0xa
	// Interrupt on either edge.
	PORT_PCR14_IRQC_1011 = 0xb
	// Interrupt when logic 1.
	PORT_PCR14_IRQC_1100 = 0xc
	// Position of ISF field.
	PORT_PCR14_ISF_Pos = 0x18
	// Bit mask of ISF field.
	PORT_PCR14_ISF_Msk = 0x1000000
	// Bit ISF.
	PORT_PCR14_ISF = 0x1000000
	// Configured interrupt is not detected.
	PORT_PCR14_ISF_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_PCR14_ISF_1 = 0x1

	// PCR15: Pin Control Register n
	// Position of PS field.
	PORT_PCR15_PS_Pos = 0x0
	// Bit mask of PS field.
	PORT_PCR15_PS_Msk = 0x1
	// Bit PS.
	PORT_PCR15_PS = 0x1
	// Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR15_PS_0 = 0x0
	// Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR15_PS_1 = 0x1
	// Position of PE field.
	PORT_PCR15_PE_Pos = 0x1
	// Bit mask of PE field.
	PORT_PCR15_PE_Msk = 0x2
	// Bit PE.
	PORT_PCR15_PE = 0x2
	// Internal pullup or pulldown resistor is not enabled on the corresponding pin.
	PORT_PCR15_PE_0 = 0x0
	// Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
	PORT_PCR15_PE_1 = 0x1
	// Position of SRE field.
	PORT_PCR15_SRE_Pos = 0x2
	// Bit mask of SRE field.
	PORT_PCR15_SRE_Msk = 0x4
	// Bit SRE.
	PORT_PCR15_SRE = 0x4
	// Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR15_SRE_0 = 0x0
	// Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR15_SRE_1 = 0x1
	// Position of PFE field.
	PORT_PCR15_PFE_Pos = 0x4
	// Bit mask of PFE field.
	PORT_PCR15_PFE_Msk = 0x10
	// Bit PFE.
	PORT_PCR15_PFE = 0x10
	// Passive input filter is disabled on the corresponding pin.
	PORT_PCR15_PFE_0 = 0x0
	// Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
	PORT_PCR15_PFE_1 = 0x1
	// Position of ODE field.
	PORT_PCR15_ODE_Pos = 0x5
	// Bit mask of ODE field.
	PORT_PCR15_ODE_Msk = 0x20
	// Bit ODE.
	PORT_PCR15_ODE = 0x20
	// Open drain output is disabled on the corresponding pin.
	PORT_PCR15_ODE_0 = 0x0
	// Open drain output is enabled on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR15_ODE_1 = 0x1
	// Position of DSE field.
	PORT_PCR15_DSE_Pos = 0x6
	// Bit mask of DSE field.
	PORT_PCR15_DSE_Msk = 0x40
	// Bit DSE.
	PORT_PCR15_DSE = 0x40
	// Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR15_DSE_0 = 0x0
	// High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR15_DSE_1 = 0x1
	// Position of MUX field.
	PORT_PCR15_MUX_Pos = 0x8
	// Bit mask of MUX field.
	PORT_PCR15_MUX_Msk = 0x700
	// Pin disabled (analog).
	PORT_PCR15_MUX_000 = 0x0
	// Alternative 1 (GPIO).
	PORT_PCR15_MUX_001 = 0x1
	// Alternative 2 (chip-specific).
	PORT_PCR15_MUX_010 = 0x2
	// Alternative 3 (chip-specific).
	PORT_PCR15_MUX_011 = 0x3
	// Alternative 4 (chip-specific).
	PORT_PCR15_MUX_100 = 0x4
	// Alternative 5 (chip-specific).
	PORT_PCR15_MUX_101 = 0x5
	// Alternative 6 (chip-specific).
	PORT_PCR15_MUX_110 = 0x6
	// Alternative 7 (chip-specific).
	PORT_PCR15_MUX_111 = 0x7
	// Position of LK field.
	PORT_PCR15_LK_Pos = 0xf
	// Bit mask of LK field.
	PORT_PCR15_LK_Msk = 0x8000
	// Bit LK.
	PORT_PCR15_LK = 0x8000
	// Pin Control Register fields [15:0] are not locked.
	PORT_PCR15_LK_0 = 0x0
	// Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
	PORT_PCR15_LK_1 = 0x1
	// Position of IRQC field.
	PORT_PCR15_IRQC_Pos = 0x10
	// Bit mask of IRQC field.
	PORT_PCR15_IRQC_Msk = 0xf0000
	// Interrupt/DMA request disabled.
	PORT_PCR15_IRQC_0000 = 0x0
	// DMA request on rising edge.
	PORT_PCR15_IRQC_0001 = 0x1
	// DMA request on falling edge.
	PORT_PCR15_IRQC_0010 = 0x2
	// DMA request on either edge.
	PORT_PCR15_IRQC_0011 = 0x3
	// Interrupt when logic 0.
	PORT_PCR15_IRQC_1000 = 0x8
	// Interrupt on rising-edge.
	PORT_PCR15_IRQC_1001 = 0x9
	// Interrupt on falling-edge.
	PORT_PCR15_IRQC_1010 = 0xa
	// Interrupt on either edge.
	PORT_PCR15_IRQC_1011 = 0xb
	// Interrupt when logic 1.
	PORT_PCR15_IRQC_1100 = 0xc
	// Position of ISF field.
	PORT_PCR15_ISF_Pos = 0x18
	// Bit mask of ISF field.
	PORT_PCR15_ISF_Msk = 0x1000000
	// Bit ISF.
	PORT_PCR15_ISF = 0x1000000
	// Configured interrupt is not detected.
	PORT_PCR15_ISF_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_PCR15_ISF_1 = 0x1

	// PCR16: Pin Control Register n
	// Position of PS field.
	PORT_PCR16_PS_Pos = 0x0
	// Bit mask of PS field.
	PORT_PCR16_PS_Msk = 0x1
	// Bit PS.
	PORT_PCR16_PS = 0x1
	// Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR16_PS_0 = 0x0
	// Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR16_PS_1 = 0x1
	// Position of PE field.
	PORT_PCR16_PE_Pos = 0x1
	// Bit mask of PE field.
	PORT_PCR16_PE_Msk = 0x2
	// Bit PE.
	PORT_PCR16_PE = 0x2
	// Internal pullup or pulldown resistor is not enabled on the corresponding pin.
	PORT_PCR16_PE_0 = 0x0
	// Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
	PORT_PCR16_PE_1 = 0x1
	// Position of SRE field.
	PORT_PCR16_SRE_Pos = 0x2
	// Bit mask of SRE field.
	PORT_PCR16_SRE_Msk = 0x4
	// Bit SRE.
	PORT_PCR16_SRE = 0x4
	// Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR16_SRE_0 = 0x0
	// Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR16_SRE_1 = 0x1
	// Position of PFE field.
	PORT_PCR16_PFE_Pos = 0x4
	// Bit mask of PFE field.
	PORT_PCR16_PFE_Msk = 0x10
	// Bit PFE.
	PORT_PCR16_PFE = 0x10
	// Passive input filter is disabled on the corresponding pin.
	PORT_PCR16_PFE_0 = 0x0
	// Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
	PORT_PCR16_PFE_1 = 0x1
	// Position of ODE field.
	PORT_PCR16_ODE_Pos = 0x5
	// Bit mask of ODE field.
	PORT_PCR16_ODE_Msk = 0x20
	// Bit ODE.
	PORT_PCR16_ODE = 0x20
	// Open drain output is disabled on the corresponding pin.
	PORT_PCR16_ODE_0 = 0x0
	// Open drain output is enabled on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR16_ODE_1 = 0x1
	// Position of DSE field.
	PORT_PCR16_DSE_Pos = 0x6
	// Bit mask of DSE field.
	PORT_PCR16_DSE_Msk = 0x40
	// Bit DSE.
	PORT_PCR16_DSE = 0x40
	// Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR16_DSE_0 = 0x0
	// High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR16_DSE_1 = 0x1
	// Position of MUX field.
	PORT_PCR16_MUX_Pos = 0x8
	// Bit mask of MUX field.
	PORT_PCR16_MUX_Msk = 0x700
	// Pin disabled (analog).
	PORT_PCR16_MUX_000 = 0x0
	// Alternative 1 (GPIO).
	PORT_PCR16_MUX_001 = 0x1
	// Alternative 2 (chip-specific).
	PORT_PCR16_MUX_010 = 0x2
	// Alternative 3 (chip-specific).
	PORT_PCR16_MUX_011 = 0x3
	// Alternative 4 (chip-specific).
	PORT_PCR16_MUX_100 = 0x4
	// Alternative 5 (chip-specific).
	PORT_PCR16_MUX_101 = 0x5
	// Alternative 6 (chip-specific).
	PORT_PCR16_MUX_110 = 0x6
	// Alternative 7 (chip-specific).
	PORT_PCR16_MUX_111 = 0x7
	// Position of LK field.
	PORT_PCR16_LK_Pos = 0xf
	// Bit mask of LK field.
	PORT_PCR16_LK_Msk = 0x8000
	// Bit LK.
	PORT_PCR16_LK = 0x8000
	// Pin Control Register fields [15:0] are not locked.
	PORT_PCR16_LK_0 = 0x0
	// Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
	PORT_PCR16_LK_1 = 0x1
	// Position of IRQC field.
	PORT_PCR16_IRQC_Pos = 0x10
	// Bit mask of IRQC field.
	PORT_PCR16_IRQC_Msk = 0xf0000
	// Interrupt/DMA request disabled.
	PORT_PCR16_IRQC_0000 = 0x0
	// DMA request on rising edge.
	PORT_PCR16_IRQC_0001 = 0x1
	// DMA request on falling edge.
	PORT_PCR16_IRQC_0010 = 0x2
	// DMA request on either edge.
	PORT_PCR16_IRQC_0011 = 0x3
	// Interrupt when logic 0.
	PORT_PCR16_IRQC_1000 = 0x8
	// Interrupt on rising-edge.
	PORT_PCR16_IRQC_1001 = 0x9
	// Interrupt on falling-edge.
	PORT_PCR16_IRQC_1010 = 0xa
	// Interrupt on either edge.
	PORT_PCR16_IRQC_1011 = 0xb
	// Interrupt when logic 1.
	PORT_PCR16_IRQC_1100 = 0xc
	// Position of ISF field.
	PORT_PCR16_ISF_Pos = 0x18
	// Bit mask of ISF field.
	PORT_PCR16_ISF_Msk = 0x1000000
	// Bit ISF.
	PORT_PCR16_ISF = 0x1000000
	// Configured interrupt is not detected.
	PORT_PCR16_ISF_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_PCR16_ISF_1 = 0x1

	// PCR17: Pin Control Register n
	// Position of PS field.
	PORT_PCR17_PS_Pos = 0x0
	// Bit mask of PS field.
	PORT_PCR17_PS_Msk = 0x1
	// Bit PS.
	PORT_PCR17_PS = 0x1
	// Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR17_PS_0 = 0x0
	// Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR17_PS_1 = 0x1
	// Position of PE field.
	PORT_PCR17_PE_Pos = 0x1
	// Bit mask of PE field.
	PORT_PCR17_PE_Msk = 0x2
	// Bit PE.
	PORT_PCR17_PE = 0x2
	// Internal pullup or pulldown resistor is not enabled on the corresponding pin.
	PORT_PCR17_PE_0 = 0x0
	// Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
	PORT_PCR17_PE_1 = 0x1
	// Position of SRE field.
	PORT_PCR17_SRE_Pos = 0x2
	// Bit mask of SRE field.
	PORT_PCR17_SRE_Msk = 0x4
	// Bit SRE.
	PORT_PCR17_SRE = 0x4
	// Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR17_SRE_0 = 0x0
	// Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR17_SRE_1 = 0x1
	// Position of PFE field.
	PORT_PCR17_PFE_Pos = 0x4
	// Bit mask of PFE field.
	PORT_PCR17_PFE_Msk = 0x10
	// Bit PFE.
	PORT_PCR17_PFE = 0x10
	// Passive input filter is disabled on the corresponding pin.
	PORT_PCR17_PFE_0 = 0x0
	// Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
	PORT_PCR17_PFE_1 = 0x1
	// Position of ODE field.
	PORT_PCR17_ODE_Pos = 0x5
	// Bit mask of ODE field.
	PORT_PCR17_ODE_Msk = 0x20
	// Bit ODE.
	PORT_PCR17_ODE = 0x20
	// Open drain output is disabled on the corresponding pin.
	PORT_PCR17_ODE_0 = 0x0
	// Open drain output is enabled on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR17_ODE_1 = 0x1
	// Position of DSE field.
	PORT_PCR17_DSE_Pos = 0x6
	// Bit mask of DSE field.
	PORT_PCR17_DSE_Msk = 0x40
	// Bit DSE.
	PORT_PCR17_DSE = 0x40
	// Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR17_DSE_0 = 0x0
	// High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR17_DSE_1 = 0x1
	// Position of MUX field.
	PORT_PCR17_MUX_Pos = 0x8
	// Bit mask of MUX field.
	PORT_PCR17_MUX_Msk = 0x700
	// Pin disabled (analog).
	PORT_PCR17_MUX_000 = 0x0
	// Alternative 1 (GPIO).
	PORT_PCR17_MUX_001 = 0x1
	// Alternative 2 (chip-specific).
	PORT_PCR17_MUX_010 = 0x2
	// Alternative 3 (chip-specific).
	PORT_PCR17_MUX_011 = 0x3
	// Alternative 4 (chip-specific).
	PORT_PCR17_MUX_100 = 0x4
	// Alternative 5 (chip-specific).
	PORT_PCR17_MUX_101 = 0x5
	// Alternative 6 (chip-specific).
	PORT_PCR17_MUX_110 = 0x6
	// Alternative 7 (chip-specific).
	PORT_PCR17_MUX_111 = 0x7
	// Position of LK field.
	PORT_PCR17_LK_Pos = 0xf
	// Bit mask of LK field.
	PORT_PCR17_LK_Msk = 0x8000
	// Bit LK.
	PORT_PCR17_LK = 0x8000
	// Pin Control Register fields [15:0] are not locked.
	PORT_PCR17_LK_0 = 0x0
	// Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
	PORT_PCR17_LK_1 = 0x1
	// Position of IRQC field.
	PORT_PCR17_IRQC_Pos = 0x10
	// Bit mask of IRQC field.
	PORT_PCR17_IRQC_Msk = 0xf0000
	// Interrupt/DMA request disabled.
	PORT_PCR17_IRQC_0000 = 0x0
	// DMA request on rising edge.
	PORT_PCR17_IRQC_0001 = 0x1
	// DMA request on falling edge.
	PORT_PCR17_IRQC_0010 = 0x2
	// DMA request on either edge.
	PORT_PCR17_IRQC_0011 = 0x3
	// Interrupt when logic 0.
	PORT_PCR17_IRQC_1000 = 0x8
	// Interrupt on rising-edge.
	PORT_PCR17_IRQC_1001 = 0x9
	// Interrupt on falling-edge.
	PORT_PCR17_IRQC_1010 = 0xa
	// Interrupt on either edge.
	PORT_PCR17_IRQC_1011 = 0xb
	// Interrupt when logic 1.
	PORT_PCR17_IRQC_1100 = 0xc
	// Position of ISF field.
	PORT_PCR17_ISF_Pos = 0x18
	// Bit mask of ISF field.
	PORT_PCR17_ISF_Msk = 0x1000000
	// Bit ISF.
	PORT_PCR17_ISF = 0x1000000
	// Configured interrupt is not detected.
	PORT_PCR17_ISF_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_PCR17_ISF_1 = 0x1

	// PCR18: Pin Control Register n
	// Position of PS field.
	PORT_PCR18_PS_Pos = 0x0
	// Bit mask of PS field.
	PORT_PCR18_PS_Msk = 0x1
	// Bit PS.
	PORT_PCR18_PS = 0x1
	// Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR18_PS_0 = 0x0
	// Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR18_PS_1 = 0x1
	// Position of PE field.
	PORT_PCR18_PE_Pos = 0x1
	// Bit mask of PE field.
	PORT_PCR18_PE_Msk = 0x2
	// Bit PE.
	PORT_PCR18_PE = 0x2
	// Internal pullup or pulldown resistor is not enabled on the corresponding pin.
	PORT_PCR18_PE_0 = 0x0
	// Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
	PORT_PCR18_PE_1 = 0x1
	// Position of SRE field.
	PORT_PCR18_SRE_Pos = 0x2
	// Bit mask of SRE field.
	PORT_PCR18_SRE_Msk = 0x4
	// Bit SRE.
	PORT_PCR18_SRE = 0x4
	// Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR18_SRE_0 = 0x0
	// Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR18_SRE_1 = 0x1
	// Position of PFE field.
	PORT_PCR18_PFE_Pos = 0x4
	// Bit mask of PFE field.
	PORT_PCR18_PFE_Msk = 0x10
	// Bit PFE.
	PORT_PCR18_PFE = 0x10
	// Passive input filter is disabled on the corresponding pin.
	PORT_PCR18_PFE_0 = 0x0
	// Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
	PORT_PCR18_PFE_1 = 0x1
	// Position of ODE field.
	PORT_PCR18_ODE_Pos = 0x5
	// Bit mask of ODE field.
	PORT_PCR18_ODE_Msk = 0x20
	// Bit ODE.
	PORT_PCR18_ODE = 0x20
	// Open drain output is disabled on the corresponding pin.
	PORT_PCR18_ODE_0 = 0x0
	// Open drain output is enabled on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR18_ODE_1 = 0x1
	// Position of DSE field.
	PORT_PCR18_DSE_Pos = 0x6
	// Bit mask of DSE field.
	PORT_PCR18_DSE_Msk = 0x40
	// Bit DSE.
	PORT_PCR18_DSE = 0x40
	// Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR18_DSE_0 = 0x0
	// High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR18_DSE_1 = 0x1
	// Position of MUX field.
	PORT_PCR18_MUX_Pos = 0x8
	// Bit mask of MUX field.
	PORT_PCR18_MUX_Msk = 0x700
	// Pin disabled (analog).
	PORT_PCR18_MUX_000 = 0x0
	// Alternative 1 (GPIO).
	PORT_PCR18_MUX_001 = 0x1
	// Alternative 2 (chip-specific).
	PORT_PCR18_MUX_010 = 0x2
	// Alternative 3 (chip-specific).
	PORT_PCR18_MUX_011 = 0x3
	// Alternative 4 (chip-specific).
	PORT_PCR18_MUX_100 = 0x4
	// Alternative 5 (chip-specific).
	PORT_PCR18_MUX_101 = 0x5
	// Alternative 6 (chip-specific).
	PORT_PCR18_MUX_110 = 0x6
	// Alternative 7 (chip-specific).
	PORT_PCR18_MUX_111 = 0x7
	// Position of LK field.
	PORT_PCR18_LK_Pos = 0xf
	// Bit mask of LK field.
	PORT_PCR18_LK_Msk = 0x8000
	// Bit LK.
	PORT_PCR18_LK = 0x8000
	// Pin Control Register fields [15:0] are not locked.
	PORT_PCR18_LK_0 = 0x0
	// Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
	PORT_PCR18_LK_1 = 0x1
	// Position of IRQC field.
	PORT_PCR18_IRQC_Pos = 0x10
	// Bit mask of IRQC field.
	PORT_PCR18_IRQC_Msk = 0xf0000
	// Interrupt/DMA request disabled.
	PORT_PCR18_IRQC_0000 = 0x0
	// DMA request on rising edge.
	PORT_PCR18_IRQC_0001 = 0x1
	// DMA request on falling edge.
	PORT_PCR18_IRQC_0010 = 0x2
	// DMA request on either edge.
	PORT_PCR18_IRQC_0011 = 0x3
	// Interrupt when logic 0.
	PORT_PCR18_IRQC_1000 = 0x8
	// Interrupt on rising-edge.
	PORT_PCR18_IRQC_1001 = 0x9
	// Interrupt on falling-edge.
	PORT_PCR18_IRQC_1010 = 0xa
	// Interrupt on either edge.
	PORT_PCR18_IRQC_1011 = 0xb
	// Interrupt when logic 1.
	PORT_PCR18_IRQC_1100 = 0xc
	// Position of ISF field.
	PORT_PCR18_ISF_Pos = 0x18
	// Bit mask of ISF field.
	PORT_PCR18_ISF_Msk = 0x1000000
	// Bit ISF.
	PORT_PCR18_ISF = 0x1000000
	// Configured interrupt is not detected.
	PORT_PCR18_ISF_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_PCR18_ISF_1 = 0x1

	// PCR19: Pin Control Register n
	// Position of PS field.
	PORT_PCR19_PS_Pos = 0x0
	// Bit mask of PS field.
	PORT_PCR19_PS_Msk = 0x1
	// Bit PS.
	PORT_PCR19_PS = 0x1
	// Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR19_PS_0 = 0x0
	// Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR19_PS_1 = 0x1
	// Position of PE field.
	PORT_PCR19_PE_Pos = 0x1
	// Bit mask of PE field.
	PORT_PCR19_PE_Msk = 0x2
	// Bit PE.
	PORT_PCR19_PE = 0x2
	// Internal pullup or pulldown resistor is not enabled on the corresponding pin.
	PORT_PCR19_PE_0 = 0x0
	// Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
	PORT_PCR19_PE_1 = 0x1
	// Position of SRE field.
	PORT_PCR19_SRE_Pos = 0x2
	// Bit mask of SRE field.
	PORT_PCR19_SRE_Msk = 0x4
	// Bit SRE.
	PORT_PCR19_SRE = 0x4
	// Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR19_SRE_0 = 0x0
	// Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR19_SRE_1 = 0x1
	// Position of PFE field.
	PORT_PCR19_PFE_Pos = 0x4
	// Bit mask of PFE field.
	PORT_PCR19_PFE_Msk = 0x10
	// Bit PFE.
	PORT_PCR19_PFE = 0x10
	// Passive input filter is disabled on the corresponding pin.
	PORT_PCR19_PFE_0 = 0x0
	// Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
	PORT_PCR19_PFE_1 = 0x1
	// Position of ODE field.
	PORT_PCR19_ODE_Pos = 0x5
	// Bit mask of ODE field.
	PORT_PCR19_ODE_Msk = 0x20
	// Bit ODE.
	PORT_PCR19_ODE = 0x20
	// Open drain output is disabled on the corresponding pin.
	PORT_PCR19_ODE_0 = 0x0
	// Open drain output is enabled on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR19_ODE_1 = 0x1
	// Position of DSE field.
	PORT_PCR19_DSE_Pos = 0x6
	// Bit mask of DSE field.
	PORT_PCR19_DSE_Msk = 0x40
	// Bit DSE.
	PORT_PCR19_DSE = 0x40
	// Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR19_DSE_0 = 0x0
	// High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR19_DSE_1 = 0x1
	// Position of MUX field.
	PORT_PCR19_MUX_Pos = 0x8
	// Bit mask of MUX field.
	PORT_PCR19_MUX_Msk = 0x700
	// Pin disabled (analog).
	PORT_PCR19_MUX_000 = 0x0
	// Alternative 1 (GPIO).
	PORT_PCR19_MUX_001 = 0x1
	// Alternative 2 (chip-specific).
	PORT_PCR19_MUX_010 = 0x2
	// Alternative 3 (chip-specific).
	PORT_PCR19_MUX_011 = 0x3
	// Alternative 4 (chip-specific).
	PORT_PCR19_MUX_100 = 0x4
	// Alternative 5 (chip-specific).
	PORT_PCR19_MUX_101 = 0x5
	// Alternative 6 (chip-specific).
	PORT_PCR19_MUX_110 = 0x6
	// Alternative 7 (chip-specific).
	PORT_PCR19_MUX_111 = 0x7
	// Position of LK field.
	PORT_PCR19_LK_Pos = 0xf
	// Bit mask of LK field.
	PORT_PCR19_LK_Msk = 0x8000
	// Bit LK.
	PORT_PCR19_LK = 0x8000
	// Pin Control Register fields [15:0] are not locked.
	PORT_PCR19_LK_0 = 0x0
	// Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
	PORT_PCR19_LK_1 = 0x1
	// Position of IRQC field.
	PORT_PCR19_IRQC_Pos = 0x10
	// Bit mask of IRQC field.
	PORT_PCR19_IRQC_Msk = 0xf0000
	// Interrupt/DMA request disabled.
	PORT_PCR19_IRQC_0000 = 0x0
	// DMA request on rising edge.
	PORT_PCR19_IRQC_0001 = 0x1
	// DMA request on falling edge.
	PORT_PCR19_IRQC_0010 = 0x2
	// DMA request on either edge.
	PORT_PCR19_IRQC_0011 = 0x3
	// Interrupt when logic 0.
	PORT_PCR19_IRQC_1000 = 0x8
	// Interrupt on rising-edge.
	PORT_PCR19_IRQC_1001 = 0x9
	// Interrupt on falling-edge.
	PORT_PCR19_IRQC_1010 = 0xa
	// Interrupt on either edge.
	PORT_PCR19_IRQC_1011 = 0xb
	// Interrupt when logic 1.
	PORT_PCR19_IRQC_1100 = 0xc
	// Position of ISF field.
	PORT_PCR19_ISF_Pos = 0x18
	// Bit mask of ISF field.
	PORT_PCR19_ISF_Msk = 0x1000000
	// Bit ISF.
	PORT_PCR19_ISF = 0x1000000
	// Configured interrupt is not detected.
	PORT_PCR19_ISF_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_PCR19_ISF_1 = 0x1

	// PCR20: Pin Control Register n
	// Position of PS field.
	PORT_PCR20_PS_Pos = 0x0
	// Bit mask of PS field.
	PORT_PCR20_PS_Msk = 0x1
	// Bit PS.
	PORT_PCR20_PS = 0x1
	// Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR20_PS_0 = 0x0
	// Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR20_PS_1 = 0x1
	// Position of PE field.
	PORT_PCR20_PE_Pos = 0x1
	// Bit mask of PE field.
	PORT_PCR20_PE_Msk = 0x2
	// Bit PE.
	PORT_PCR20_PE = 0x2
	// Internal pullup or pulldown resistor is not enabled on the corresponding pin.
	PORT_PCR20_PE_0 = 0x0
	// Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
	PORT_PCR20_PE_1 = 0x1
	// Position of SRE field.
	PORT_PCR20_SRE_Pos = 0x2
	// Bit mask of SRE field.
	PORT_PCR20_SRE_Msk = 0x4
	// Bit SRE.
	PORT_PCR20_SRE = 0x4
	// Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR20_SRE_0 = 0x0
	// Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR20_SRE_1 = 0x1
	// Position of PFE field.
	PORT_PCR20_PFE_Pos = 0x4
	// Bit mask of PFE field.
	PORT_PCR20_PFE_Msk = 0x10
	// Bit PFE.
	PORT_PCR20_PFE = 0x10
	// Passive input filter is disabled on the corresponding pin.
	PORT_PCR20_PFE_0 = 0x0
	// Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
	PORT_PCR20_PFE_1 = 0x1
	// Position of ODE field.
	PORT_PCR20_ODE_Pos = 0x5
	// Bit mask of ODE field.
	PORT_PCR20_ODE_Msk = 0x20
	// Bit ODE.
	PORT_PCR20_ODE = 0x20
	// Open drain output is disabled on the corresponding pin.
	PORT_PCR20_ODE_0 = 0x0
	// Open drain output is enabled on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR20_ODE_1 = 0x1
	// Position of DSE field.
	PORT_PCR20_DSE_Pos = 0x6
	// Bit mask of DSE field.
	PORT_PCR20_DSE_Msk = 0x40
	// Bit DSE.
	PORT_PCR20_DSE = 0x40
	// Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR20_DSE_0 = 0x0
	// High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR20_DSE_1 = 0x1
	// Position of MUX field.
	PORT_PCR20_MUX_Pos = 0x8
	// Bit mask of MUX field.
	PORT_PCR20_MUX_Msk = 0x700
	// Pin disabled (analog).
	PORT_PCR20_MUX_000 = 0x0
	// Alternative 1 (GPIO).
	PORT_PCR20_MUX_001 = 0x1
	// Alternative 2 (chip-specific).
	PORT_PCR20_MUX_010 = 0x2
	// Alternative 3 (chip-specific).
	PORT_PCR20_MUX_011 = 0x3
	// Alternative 4 (chip-specific).
	PORT_PCR20_MUX_100 = 0x4
	// Alternative 5 (chip-specific).
	PORT_PCR20_MUX_101 = 0x5
	// Alternative 6 (chip-specific).
	PORT_PCR20_MUX_110 = 0x6
	// Alternative 7 (chip-specific).
	PORT_PCR20_MUX_111 = 0x7
	// Position of LK field.
	PORT_PCR20_LK_Pos = 0xf
	// Bit mask of LK field.
	PORT_PCR20_LK_Msk = 0x8000
	// Bit LK.
	PORT_PCR20_LK = 0x8000
	// Pin Control Register fields [15:0] are not locked.
	PORT_PCR20_LK_0 = 0x0
	// Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
	PORT_PCR20_LK_1 = 0x1
	// Position of IRQC field.
	PORT_PCR20_IRQC_Pos = 0x10
	// Bit mask of IRQC field.
	PORT_PCR20_IRQC_Msk = 0xf0000
	// Interrupt/DMA request disabled.
	PORT_PCR20_IRQC_0000 = 0x0
	// DMA request on rising edge.
	PORT_PCR20_IRQC_0001 = 0x1
	// DMA request on falling edge.
	PORT_PCR20_IRQC_0010 = 0x2
	// DMA request on either edge.
	PORT_PCR20_IRQC_0011 = 0x3
	// Interrupt when logic 0.
	PORT_PCR20_IRQC_1000 = 0x8
	// Interrupt on rising-edge.
	PORT_PCR20_IRQC_1001 = 0x9
	// Interrupt on falling-edge.
	PORT_PCR20_IRQC_1010 = 0xa
	// Interrupt on either edge.
	PORT_PCR20_IRQC_1011 = 0xb
	// Interrupt when logic 1.
	PORT_PCR20_IRQC_1100 = 0xc
	// Position of ISF field.
	PORT_PCR20_ISF_Pos = 0x18
	// Bit mask of ISF field.
	PORT_PCR20_ISF_Msk = 0x1000000
	// Bit ISF.
	PORT_PCR20_ISF = 0x1000000
	// Configured interrupt is not detected.
	PORT_PCR20_ISF_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_PCR20_ISF_1 = 0x1

	// PCR21: Pin Control Register n
	// Position of PS field.
	PORT_PCR21_PS_Pos = 0x0
	// Bit mask of PS field.
	PORT_PCR21_PS_Msk = 0x1
	// Bit PS.
	PORT_PCR21_PS = 0x1
	// Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR21_PS_0 = 0x0
	// Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR21_PS_1 = 0x1
	// Position of PE field.
	PORT_PCR21_PE_Pos = 0x1
	// Bit mask of PE field.
	PORT_PCR21_PE_Msk = 0x2
	// Bit PE.
	PORT_PCR21_PE = 0x2
	// Internal pullup or pulldown resistor is not enabled on the corresponding pin.
	PORT_PCR21_PE_0 = 0x0
	// Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
	PORT_PCR21_PE_1 = 0x1
	// Position of SRE field.
	PORT_PCR21_SRE_Pos = 0x2
	// Bit mask of SRE field.
	PORT_PCR21_SRE_Msk = 0x4
	// Bit SRE.
	PORT_PCR21_SRE = 0x4
	// Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR21_SRE_0 = 0x0
	// Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR21_SRE_1 = 0x1
	// Position of PFE field.
	PORT_PCR21_PFE_Pos = 0x4
	// Bit mask of PFE field.
	PORT_PCR21_PFE_Msk = 0x10
	// Bit PFE.
	PORT_PCR21_PFE = 0x10
	// Passive input filter is disabled on the corresponding pin.
	PORT_PCR21_PFE_0 = 0x0
	// Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
	PORT_PCR21_PFE_1 = 0x1
	// Position of ODE field.
	PORT_PCR21_ODE_Pos = 0x5
	// Bit mask of ODE field.
	PORT_PCR21_ODE_Msk = 0x20
	// Bit ODE.
	PORT_PCR21_ODE = 0x20
	// Open drain output is disabled on the corresponding pin.
	PORT_PCR21_ODE_0 = 0x0
	// Open drain output is enabled on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR21_ODE_1 = 0x1
	// Position of DSE field.
	PORT_PCR21_DSE_Pos = 0x6
	// Bit mask of DSE field.
	PORT_PCR21_DSE_Msk = 0x40
	// Bit DSE.
	PORT_PCR21_DSE = 0x40
	// Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR21_DSE_0 = 0x0
	// High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR21_DSE_1 = 0x1
	// Position of MUX field.
	PORT_PCR21_MUX_Pos = 0x8
	// Bit mask of MUX field.
	PORT_PCR21_MUX_Msk = 0x700
	// Pin disabled (analog).
	PORT_PCR21_MUX_000 = 0x0
	// Alternative 1 (GPIO).
	PORT_PCR21_MUX_001 = 0x1
	// Alternative 2 (chip-specific).
	PORT_PCR21_MUX_010 = 0x2
	// Alternative 3 (chip-specific).
	PORT_PCR21_MUX_011 = 0x3
	// Alternative 4 (chip-specific).
	PORT_PCR21_MUX_100 = 0x4
	// Alternative 5 (chip-specific).
	PORT_PCR21_MUX_101 = 0x5
	// Alternative 6 (chip-specific).
	PORT_PCR21_MUX_110 = 0x6
	// Alternative 7 (chip-specific).
	PORT_PCR21_MUX_111 = 0x7
	// Position of LK field.
	PORT_PCR21_LK_Pos = 0xf
	// Bit mask of LK field.
	PORT_PCR21_LK_Msk = 0x8000
	// Bit LK.
	PORT_PCR21_LK = 0x8000
	// Pin Control Register fields [15:0] are not locked.
	PORT_PCR21_LK_0 = 0x0
	// Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
	PORT_PCR21_LK_1 = 0x1
	// Position of IRQC field.
	PORT_PCR21_IRQC_Pos = 0x10
	// Bit mask of IRQC field.
	PORT_PCR21_IRQC_Msk = 0xf0000
	// Interrupt/DMA request disabled.
	PORT_PCR21_IRQC_0000 = 0x0
	// DMA request on rising edge.
	PORT_PCR21_IRQC_0001 = 0x1
	// DMA request on falling edge.
	PORT_PCR21_IRQC_0010 = 0x2
	// DMA request on either edge.
	PORT_PCR21_IRQC_0011 = 0x3
	// Interrupt when logic 0.
	PORT_PCR21_IRQC_1000 = 0x8
	// Interrupt on rising-edge.
	PORT_PCR21_IRQC_1001 = 0x9
	// Interrupt on falling-edge.
	PORT_PCR21_IRQC_1010 = 0xa
	// Interrupt on either edge.
	PORT_PCR21_IRQC_1011 = 0xb
	// Interrupt when logic 1.
	PORT_PCR21_IRQC_1100 = 0xc
	// Position of ISF field.
	PORT_PCR21_ISF_Pos = 0x18
	// Bit mask of ISF field.
	PORT_PCR21_ISF_Msk = 0x1000000
	// Bit ISF.
	PORT_PCR21_ISF = 0x1000000
	// Configured interrupt is not detected.
	PORT_PCR21_ISF_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_PCR21_ISF_1 = 0x1

	// PCR22: Pin Control Register n
	// Position of PS field.
	PORT_PCR22_PS_Pos = 0x0
	// Bit mask of PS field.
	PORT_PCR22_PS_Msk = 0x1
	// Bit PS.
	PORT_PCR22_PS = 0x1
	// Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR22_PS_0 = 0x0
	// Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR22_PS_1 = 0x1
	// Position of PE field.
	PORT_PCR22_PE_Pos = 0x1
	// Bit mask of PE field.
	PORT_PCR22_PE_Msk = 0x2
	// Bit PE.
	PORT_PCR22_PE = 0x2
	// Internal pullup or pulldown resistor is not enabled on the corresponding pin.
	PORT_PCR22_PE_0 = 0x0
	// Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
	PORT_PCR22_PE_1 = 0x1
	// Position of SRE field.
	PORT_PCR22_SRE_Pos = 0x2
	// Bit mask of SRE field.
	PORT_PCR22_SRE_Msk = 0x4
	// Bit SRE.
	PORT_PCR22_SRE = 0x4
	// Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR22_SRE_0 = 0x0
	// Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR22_SRE_1 = 0x1
	// Position of PFE field.
	PORT_PCR22_PFE_Pos = 0x4
	// Bit mask of PFE field.
	PORT_PCR22_PFE_Msk = 0x10
	// Bit PFE.
	PORT_PCR22_PFE = 0x10
	// Passive input filter is disabled on the corresponding pin.
	PORT_PCR22_PFE_0 = 0x0
	// Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
	PORT_PCR22_PFE_1 = 0x1
	// Position of ODE field.
	PORT_PCR22_ODE_Pos = 0x5
	// Bit mask of ODE field.
	PORT_PCR22_ODE_Msk = 0x20
	// Bit ODE.
	PORT_PCR22_ODE = 0x20
	// Open drain output is disabled on the corresponding pin.
	PORT_PCR22_ODE_0 = 0x0
	// Open drain output is enabled on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR22_ODE_1 = 0x1
	// Position of DSE field.
	PORT_PCR22_DSE_Pos = 0x6
	// Bit mask of DSE field.
	PORT_PCR22_DSE_Msk = 0x40
	// Bit DSE.
	PORT_PCR22_DSE = 0x40
	// Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR22_DSE_0 = 0x0
	// High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR22_DSE_1 = 0x1
	// Position of MUX field.
	PORT_PCR22_MUX_Pos = 0x8
	// Bit mask of MUX field.
	PORT_PCR22_MUX_Msk = 0x700
	// Pin disabled (analog).
	PORT_PCR22_MUX_000 = 0x0
	// Alternative 1 (GPIO).
	PORT_PCR22_MUX_001 = 0x1
	// Alternative 2 (chip-specific).
	PORT_PCR22_MUX_010 = 0x2
	// Alternative 3 (chip-specific).
	PORT_PCR22_MUX_011 = 0x3
	// Alternative 4 (chip-specific).
	PORT_PCR22_MUX_100 = 0x4
	// Alternative 5 (chip-specific).
	PORT_PCR22_MUX_101 = 0x5
	// Alternative 6 (chip-specific).
	PORT_PCR22_MUX_110 = 0x6
	// Alternative 7 (chip-specific).
	PORT_PCR22_MUX_111 = 0x7
	// Position of LK field.
	PORT_PCR22_LK_Pos = 0xf
	// Bit mask of LK field.
	PORT_PCR22_LK_Msk = 0x8000
	// Bit LK.
	PORT_PCR22_LK = 0x8000
	// Pin Control Register fields [15:0] are not locked.
	PORT_PCR22_LK_0 = 0x0
	// Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
	PORT_PCR22_LK_1 = 0x1
	// Position of IRQC field.
	PORT_PCR22_IRQC_Pos = 0x10
	// Bit mask of IRQC field.
	PORT_PCR22_IRQC_Msk = 0xf0000
	// Interrupt/DMA request disabled.
	PORT_PCR22_IRQC_0000 = 0x0
	// DMA request on rising edge.
	PORT_PCR22_IRQC_0001 = 0x1
	// DMA request on falling edge.
	PORT_PCR22_IRQC_0010 = 0x2
	// DMA request on either edge.
	PORT_PCR22_IRQC_0011 = 0x3
	// Interrupt when logic 0.
	PORT_PCR22_IRQC_1000 = 0x8
	// Interrupt on rising-edge.
	PORT_PCR22_IRQC_1001 = 0x9
	// Interrupt on falling-edge.
	PORT_PCR22_IRQC_1010 = 0xa
	// Interrupt on either edge.
	PORT_PCR22_IRQC_1011 = 0xb
	// Interrupt when logic 1.
	PORT_PCR22_IRQC_1100 = 0xc
	// Position of ISF field.
	PORT_PCR22_ISF_Pos = 0x18
	// Bit mask of ISF field.
	PORT_PCR22_ISF_Msk = 0x1000000
	// Bit ISF.
	PORT_PCR22_ISF = 0x1000000
	// Configured interrupt is not detected.
	PORT_PCR22_ISF_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_PCR22_ISF_1 = 0x1

	// PCR23: Pin Control Register n
	// Position of PS field.
	PORT_PCR23_PS_Pos = 0x0
	// Bit mask of PS field.
	PORT_PCR23_PS_Msk = 0x1
	// Bit PS.
	PORT_PCR23_PS = 0x1
	// Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR23_PS_0 = 0x0
	// Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR23_PS_1 = 0x1
	// Position of PE field.
	PORT_PCR23_PE_Pos = 0x1
	// Bit mask of PE field.
	PORT_PCR23_PE_Msk = 0x2
	// Bit PE.
	PORT_PCR23_PE = 0x2
	// Internal pullup or pulldown resistor is not enabled on the corresponding pin.
	PORT_PCR23_PE_0 = 0x0
	// Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
	PORT_PCR23_PE_1 = 0x1
	// Position of SRE field.
	PORT_PCR23_SRE_Pos = 0x2
	// Bit mask of SRE field.
	PORT_PCR23_SRE_Msk = 0x4
	// Bit SRE.
	PORT_PCR23_SRE = 0x4
	// Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR23_SRE_0 = 0x0
	// Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR23_SRE_1 = 0x1
	// Position of PFE field.
	PORT_PCR23_PFE_Pos = 0x4
	// Bit mask of PFE field.
	PORT_PCR23_PFE_Msk = 0x10
	// Bit PFE.
	PORT_PCR23_PFE = 0x10
	// Passive input filter is disabled on the corresponding pin.
	PORT_PCR23_PFE_0 = 0x0
	// Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
	PORT_PCR23_PFE_1 = 0x1
	// Position of ODE field.
	PORT_PCR23_ODE_Pos = 0x5
	// Bit mask of ODE field.
	PORT_PCR23_ODE_Msk = 0x20
	// Bit ODE.
	PORT_PCR23_ODE = 0x20
	// Open drain output is disabled on the corresponding pin.
	PORT_PCR23_ODE_0 = 0x0
	// Open drain output is enabled on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR23_ODE_1 = 0x1
	// Position of DSE field.
	PORT_PCR23_DSE_Pos = 0x6
	// Bit mask of DSE field.
	PORT_PCR23_DSE_Msk = 0x40
	// Bit DSE.
	PORT_PCR23_DSE = 0x40
	// Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR23_DSE_0 = 0x0
	// High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR23_DSE_1 = 0x1
	// Position of MUX field.
	PORT_PCR23_MUX_Pos = 0x8
	// Bit mask of MUX field.
	PORT_PCR23_MUX_Msk = 0x700
	// Pin disabled (analog).
	PORT_PCR23_MUX_000 = 0x0
	// Alternative 1 (GPIO).
	PORT_PCR23_MUX_001 = 0x1
	// Alternative 2 (chip-specific).
	PORT_PCR23_MUX_010 = 0x2
	// Alternative 3 (chip-specific).
	PORT_PCR23_MUX_011 = 0x3
	// Alternative 4 (chip-specific).
	PORT_PCR23_MUX_100 = 0x4
	// Alternative 5 (chip-specific).
	PORT_PCR23_MUX_101 = 0x5
	// Alternative 6 (chip-specific).
	PORT_PCR23_MUX_110 = 0x6
	// Alternative 7 (chip-specific).
	PORT_PCR23_MUX_111 = 0x7
	// Position of LK field.
	PORT_PCR23_LK_Pos = 0xf
	// Bit mask of LK field.
	PORT_PCR23_LK_Msk = 0x8000
	// Bit LK.
	PORT_PCR23_LK = 0x8000
	// Pin Control Register fields [15:0] are not locked.
	PORT_PCR23_LK_0 = 0x0
	// Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
	PORT_PCR23_LK_1 = 0x1
	// Position of IRQC field.
	PORT_PCR23_IRQC_Pos = 0x10
	// Bit mask of IRQC field.
	PORT_PCR23_IRQC_Msk = 0xf0000
	// Interrupt/DMA request disabled.
	PORT_PCR23_IRQC_0000 = 0x0
	// DMA request on rising edge.
	PORT_PCR23_IRQC_0001 = 0x1
	// DMA request on falling edge.
	PORT_PCR23_IRQC_0010 = 0x2
	// DMA request on either edge.
	PORT_PCR23_IRQC_0011 = 0x3
	// Interrupt when logic 0.
	PORT_PCR23_IRQC_1000 = 0x8
	// Interrupt on rising-edge.
	PORT_PCR23_IRQC_1001 = 0x9
	// Interrupt on falling-edge.
	PORT_PCR23_IRQC_1010 = 0xa
	// Interrupt on either edge.
	PORT_PCR23_IRQC_1011 = 0xb
	// Interrupt when logic 1.
	PORT_PCR23_IRQC_1100 = 0xc
	// Position of ISF field.
	PORT_PCR23_ISF_Pos = 0x18
	// Bit mask of ISF field.
	PORT_PCR23_ISF_Msk = 0x1000000
	// Bit ISF.
	PORT_PCR23_ISF = 0x1000000
	// Configured interrupt is not detected.
	PORT_PCR23_ISF_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_PCR23_ISF_1 = 0x1

	// PCR24: Pin Control Register n
	// Position of PS field.
	PORT_PCR24_PS_Pos = 0x0
	// Bit mask of PS field.
	PORT_PCR24_PS_Msk = 0x1
	// Bit PS.
	PORT_PCR24_PS = 0x1
	// Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR24_PS_0 = 0x0
	// Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR24_PS_1 = 0x1
	// Position of PE field.
	PORT_PCR24_PE_Pos = 0x1
	// Bit mask of PE field.
	PORT_PCR24_PE_Msk = 0x2
	// Bit PE.
	PORT_PCR24_PE = 0x2
	// Internal pullup or pulldown resistor is not enabled on the corresponding pin.
	PORT_PCR24_PE_0 = 0x0
	// Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
	PORT_PCR24_PE_1 = 0x1
	// Position of SRE field.
	PORT_PCR24_SRE_Pos = 0x2
	// Bit mask of SRE field.
	PORT_PCR24_SRE_Msk = 0x4
	// Bit SRE.
	PORT_PCR24_SRE = 0x4
	// Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR24_SRE_0 = 0x0
	// Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR24_SRE_1 = 0x1
	// Position of PFE field.
	PORT_PCR24_PFE_Pos = 0x4
	// Bit mask of PFE field.
	PORT_PCR24_PFE_Msk = 0x10
	// Bit PFE.
	PORT_PCR24_PFE = 0x10
	// Passive input filter is disabled on the corresponding pin.
	PORT_PCR24_PFE_0 = 0x0
	// Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
	PORT_PCR24_PFE_1 = 0x1
	// Position of ODE field.
	PORT_PCR24_ODE_Pos = 0x5
	// Bit mask of ODE field.
	PORT_PCR24_ODE_Msk = 0x20
	// Bit ODE.
	PORT_PCR24_ODE = 0x20
	// Open drain output is disabled on the corresponding pin.
	PORT_PCR24_ODE_0 = 0x0
	// Open drain output is enabled on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR24_ODE_1 = 0x1
	// Position of DSE field.
	PORT_PCR24_DSE_Pos = 0x6
	// Bit mask of DSE field.
	PORT_PCR24_DSE_Msk = 0x40
	// Bit DSE.
	PORT_PCR24_DSE = 0x40
	// Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR24_DSE_0 = 0x0
	// High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR24_DSE_1 = 0x1
	// Position of MUX field.
	PORT_PCR24_MUX_Pos = 0x8
	// Bit mask of MUX field.
	PORT_PCR24_MUX_Msk = 0x700
	// Pin disabled (analog).
	PORT_PCR24_MUX_000 = 0x0
	// Alternative 1 (GPIO).
	PORT_PCR24_MUX_001 = 0x1
	// Alternative 2 (chip-specific).
	PORT_PCR24_MUX_010 = 0x2
	// Alternative 3 (chip-specific).
	PORT_PCR24_MUX_011 = 0x3
	// Alternative 4 (chip-specific).
	PORT_PCR24_MUX_100 = 0x4
	// Alternative 5 (chip-specific).
	PORT_PCR24_MUX_101 = 0x5
	// Alternative 6 (chip-specific).
	PORT_PCR24_MUX_110 = 0x6
	// Alternative 7 (chip-specific).
	PORT_PCR24_MUX_111 = 0x7
	// Position of LK field.
	PORT_PCR24_LK_Pos = 0xf
	// Bit mask of LK field.
	PORT_PCR24_LK_Msk = 0x8000
	// Bit LK.
	PORT_PCR24_LK = 0x8000
	// Pin Control Register fields [15:0] are not locked.
	PORT_PCR24_LK_0 = 0x0
	// Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
	PORT_PCR24_LK_1 = 0x1
	// Position of IRQC field.
	PORT_PCR24_IRQC_Pos = 0x10
	// Bit mask of IRQC field.
	PORT_PCR24_IRQC_Msk = 0xf0000
	// Interrupt/DMA request disabled.
	PORT_PCR24_IRQC_0000 = 0x0
	// DMA request on rising edge.
	PORT_PCR24_IRQC_0001 = 0x1
	// DMA request on falling edge.
	PORT_PCR24_IRQC_0010 = 0x2
	// DMA request on either edge.
	PORT_PCR24_IRQC_0011 = 0x3
	// Interrupt when logic 0.
	PORT_PCR24_IRQC_1000 = 0x8
	// Interrupt on rising-edge.
	PORT_PCR24_IRQC_1001 = 0x9
	// Interrupt on falling-edge.
	PORT_PCR24_IRQC_1010 = 0xa
	// Interrupt on either edge.
	PORT_PCR24_IRQC_1011 = 0xb
	// Interrupt when logic 1.
	PORT_PCR24_IRQC_1100 = 0xc
	// Position of ISF field.
	PORT_PCR24_ISF_Pos = 0x18
	// Bit mask of ISF field.
	PORT_PCR24_ISF_Msk = 0x1000000
	// Bit ISF.
	PORT_PCR24_ISF = 0x1000000
	// Configured interrupt is not detected.
	PORT_PCR24_ISF_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_PCR24_ISF_1 = 0x1

	// PCR25: Pin Control Register n
	// Position of PS field.
	PORT_PCR25_PS_Pos = 0x0
	// Bit mask of PS field.
	PORT_PCR25_PS_Msk = 0x1
	// Bit PS.
	PORT_PCR25_PS = 0x1
	// Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR25_PS_0 = 0x0
	// Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR25_PS_1 = 0x1
	// Position of PE field.
	PORT_PCR25_PE_Pos = 0x1
	// Bit mask of PE field.
	PORT_PCR25_PE_Msk = 0x2
	// Bit PE.
	PORT_PCR25_PE = 0x2
	// Internal pullup or pulldown resistor is not enabled on the corresponding pin.
	PORT_PCR25_PE_0 = 0x0
	// Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
	PORT_PCR25_PE_1 = 0x1
	// Position of SRE field.
	PORT_PCR25_SRE_Pos = 0x2
	// Bit mask of SRE field.
	PORT_PCR25_SRE_Msk = 0x4
	// Bit SRE.
	PORT_PCR25_SRE = 0x4
	// Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR25_SRE_0 = 0x0
	// Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR25_SRE_1 = 0x1
	// Position of PFE field.
	PORT_PCR25_PFE_Pos = 0x4
	// Bit mask of PFE field.
	PORT_PCR25_PFE_Msk = 0x10
	// Bit PFE.
	PORT_PCR25_PFE = 0x10
	// Passive input filter is disabled on the corresponding pin.
	PORT_PCR25_PFE_0 = 0x0
	// Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
	PORT_PCR25_PFE_1 = 0x1
	// Position of ODE field.
	PORT_PCR25_ODE_Pos = 0x5
	// Bit mask of ODE field.
	PORT_PCR25_ODE_Msk = 0x20
	// Bit ODE.
	PORT_PCR25_ODE = 0x20
	// Open drain output is disabled on the corresponding pin.
	PORT_PCR25_ODE_0 = 0x0
	// Open drain output is enabled on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR25_ODE_1 = 0x1
	// Position of DSE field.
	PORT_PCR25_DSE_Pos = 0x6
	// Bit mask of DSE field.
	PORT_PCR25_DSE_Msk = 0x40
	// Bit DSE.
	PORT_PCR25_DSE = 0x40
	// Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR25_DSE_0 = 0x0
	// High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR25_DSE_1 = 0x1
	// Position of MUX field.
	PORT_PCR25_MUX_Pos = 0x8
	// Bit mask of MUX field.
	PORT_PCR25_MUX_Msk = 0x700
	// Pin disabled (analog).
	PORT_PCR25_MUX_000 = 0x0
	// Alternative 1 (GPIO).
	PORT_PCR25_MUX_001 = 0x1
	// Alternative 2 (chip-specific).
	PORT_PCR25_MUX_010 = 0x2
	// Alternative 3 (chip-specific).
	PORT_PCR25_MUX_011 = 0x3
	// Alternative 4 (chip-specific).
	PORT_PCR25_MUX_100 = 0x4
	// Alternative 5 (chip-specific).
	PORT_PCR25_MUX_101 = 0x5
	// Alternative 6 (chip-specific).
	PORT_PCR25_MUX_110 = 0x6
	// Alternative 7 (chip-specific).
	PORT_PCR25_MUX_111 = 0x7
	// Position of LK field.
	PORT_PCR25_LK_Pos = 0xf
	// Bit mask of LK field.
	PORT_PCR25_LK_Msk = 0x8000
	// Bit LK.
	PORT_PCR25_LK = 0x8000
	// Pin Control Register fields [15:0] are not locked.
	PORT_PCR25_LK_0 = 0x0
	// Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
	PORT_PCR25_LK_1 = 0x1
	// Position of IRQC field.
	PORT_PCR25_IRQC_Pos = 0x10
	// Bit mask of IRQC field.
	PORT_PCR25_IRQC_Msk = 0xf0000
	// Interrupt/DMA request disabled.
	PORT_PCR25_IRQC_0000 = 0x0
	// DMA request on rising edge.
	PORT_PCR25_IRQC_0001 = 0x1
	// DMA request on falling edge.
	PORT_PCR25_IRQC_0010 = 0x2
	// DMA request on either edge.
	PORT_PCR25_IRQC_0011 = 0x3
	// Interrupt when logic 0.
	PORT_PCR25_IRQC_1000 = 0x8
	// Interrupt on rising-edge.
	PORT_PCR25_IRQC_1001 = 0x9
	// Interrupt on falling-edge.
	PORT_PCR25_IRQC_1010 = 0xa
	// Interrupt on either edge.
	PORT_PCR25_IRQC_1011 = 0xb
	// Interrupt when logic 1.
	PORT_PCR25_IRQC_1100 = 0xc
	// Position of ISF field.
	PORT_PCR25_ISF_Pos = 0x18
	// Bit mask of ISF field.
	PORT_PCR25_ISF_Msk = 0x1000000
	// Bit ISF.
	PORT_PCR25_ISF = 0x1000000
	// Configured interrupt is not detected.
	PORT_PCR25_ISF_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_PCR25_ISF_1 = 0x1

	// PCR26: Pin Control Register n
	// Position of PS field.
	PORT_PCR26_PS_Pos = 0x0
	// Bit mask of PS field.
	PORT_PCR26_PS_Msk = 0x1
	// Bit PS.
	PORT_PCR26_PS = 0x1
	// Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR26_PS_0 = 0x0
	// Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR26_PS_1 = 0x1
	// Position of PE field.
	PORT_PCR26_PE_Pos = 0x1
	// Bit mask of PE field.
	PORT_PCR26_PE_Msk = 0x2
	// Bit PE.
	PORT_PCR26_PE = 0x2
	// Internal pullup or pulldown resistor is not enabled on the corresponding pin.
	PORT_PCR26_PE_0 = 0x0
	// Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
	PORT_PCR26_PE_1 = 0x1
	// Position of SRE field.
	PORT_PCR26_SRE_Pos = 0x2
	// Bit mask of SRE field.
	PORT_PCR26_SRE_Msk = 0x4
	// Bit SRE.
	PORT_PCR26_SRE = 0x4
	// Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR26_SRE_0 = 0x0
	// Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR26_SRE_1 = 0x1
	// Position of PFE field.
	PORT_PCR26_PFE_Pos = 0x4
	// Bit mask of PFE field.
	PORT_PCR26_PFE_Msk = 0x10
	// Bit PFE.
	PORT_PCR26_PFE = 0x10
	// Passive input filter is disabled on the corresponding pin.
	PORT_PCR26_PFE_0 = 0x0
	// Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
	PORT_PCR26_PFE_1 = 0x1
	// Position of ODE field.
	PORT_PCR26_ODE_Pos = 0x5
	// Bit mask of ODE field.
	PORT_PCR26_ODE_Msk = 0x20
	// Bit ODE.
	PORT_PCR26_ODE = 0x20
	// Open drain output is disabled on the corresponding pin.
	PORT_PCR26_ODE_0 = 0x0
	// Open drain output is enabled on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR26_ODE_1 = 0x1
	// Position of DSE field.
	PORT_PCR26_DSE_Pos = 0x6
	// Bit mask of DSE field.
	PORT_PCR26_DSE_Msk = 0x40
	// Bit DSE.
	PORT_PCR26_DSE = 0x40
	// Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR26_DSE_0 = 0x0
	// High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR26_DSE_1 = 0x1
	// Position of MUX field.
	PORT_PCR26_MUX_Pos = 0x8
	// Bit mask of MUX field.
	PORT_PCR26_MUX_Msk = 0x700
	// Pin disabled (analog).
	PORT_PCR26_MUX_000 = 0x0
	// Alternative 1 (GPIO).
	PORT_PCR26_MUX_001 = 0x1
	// Alternative 2 (chip-specific).
	PORT_PCR26_MUX_010 = 0x2
	// Alternative 3 (chip-specific).
	PORT_PCR26_MUX_011 = 0x3
	// Alternative 4 (chip-specific).
	PORT_PCR26_MUX_100 = 0x4
	// Alternative 5 (chip-specific).
	PORT_PCR26_MUX_101 = 0x5
	// Alternative 6 (chip-specific).
	PORT_PCR26_MUX_110 = 0x6
	// Alternative 7 (chip-specific).
	PORT_PCR26_MUX_111 = 0x7
	// Position of LK field.
	PORT_PCR26_LK_Pos = 0xf
	// Bit mask of LK field.
	PORT_PCR26_LK_Msk = 0x8000
	// Bit LK.
	PORT_PCR26_LK = 0x8000
	// Pin Control Register fields [15:0] are not locked.
	PORT_PCR26_LK_0 = 0x0
	// Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
	PORT_PCR26_LK_1 = 0x1
	// Position of IRQC field.
	PORT_PCR26_IRQC_Pos = 0x10
	// Bit mask of IRQC field.
	PORT_PCR26_IRQC_Msk = 0xf0000
	// Interrupt/DMA request disabled.
	PORT_PCR26_IRQC_0000 = 0x0
	// DMA request on rising edge.
	PORT_PCR26_IRQC_0001 = 0x1
	// DMA request on falling edge.
	PORT_PCR26_IRQC_0010 = 0x2
	// DMA request on either edge.
	PORT_PCR26_IRQC_0011 = 0x3
	// Interrupt when logic 0.
	PORT_PCR26_IRQC_1000 = 0x8
	// Interrupt on rising-edge.
	PORT_PCR26_IRQC_1001 = 0x9
	// Interrupt on falling-edge.
	PORT_PCR26_IRQC_1010 = 0xa
	// Interrupt on either edge.
	PORT_PCR26_IRQC_1011 = 0xb
	// Interrupt when logic 1.
	PORT_PCR26_IRQC_1100 = 0xc
	// Position of ISF field.
	PORT_PCR26_ISF_Pos = 0x18
	// Bit mask of ISF field.
	PORT_PCR26_ISF_Msk = 0x1000000
	// Bit ISF.
	PORT_PCR26_ISF = 0x1000000
	// Configured interrupt is not detected.
	PORT_PCR26_ISF_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_PCR26_ISF_1 = 0x1

	// PCR27: Pin Control Register n
	// Position of PS field.
	PORT_PCR27_PS_Pos = 0x0
	// Bit mask of PS field.
	PORT_PCR27_PS_Msk = 0x1
	// Bit PS.
	PORT_PCR27_PS = 0x1
	// Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR27_PS_0 = 0x0
	// Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR27_PS_1 = 0x1
	// Position of PE field.
	PORT_PCR27_PE_Pos = 0x1
	// Bit mask of PE field.
	PORT_PCR27_PE_Msk = 0x2
	// Bit PE.
	PORT_PCR27_PE = 0x2
	// Internal pullup or pulldown resistor is not enabled on the corresponding pin.
	PORT_PCR27_PE_0 = 0x0
	// Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
	PORT_PCR27_PE_1 = 0x1
	// Position of SRE field.
	PORT_PCR27_SRE_Pos = 0x2
	// Bit mask of SRE field.
	PORT_PCR27_SRE_Msk = 0x4
	// Bit SRE.
	PORT_PCR27_SRE = 0x4
	// Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR27_SRE_0 = 0x0
	// Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR27_SRE_1 = 0x1
	// Position of PFE field.
	PORT_PCR27_PFE_Pos = 0x4
	// Bit mask of PFE field.
	PORT_PCR27_PFE_Msk = 0x10
	// Bit PFE.
	PORT_PCR27_PFE = 0x10
	// Passive input filter is disabled on the corresponding pin.
	PORT_PCR27_PFE_0 = 0x0
	// Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
	PORT_PCR27_PFE_1 = 0x1
	// Position of ODE field.
	PORT_PCR27_ODE_Pos = 0x5
	// Bit mask of ODE field.
	PORT_PCR27_ODE_Msk = 0x20
	// Bit ODE.
	PORT_PCR27_ODE = 0x20
	// Open drain output is disabled on the corresponding pin.
	PORT_PCR27_ODE_0 = 0x0
	// Open drain output is enabled on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR27_ODE_1 = 0x1
	// Position of DSE field.
	PORT_PCR27_DSE_Pos = 0x6
	// Bit mask of DSE field.
	PORT_PCR27_DSE_Msk = 0x40
	// Bit DSE.
	PORT_PCR27_DSE = 0x40
	// Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR27_DSE_0 = 0x0
	// High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR27_DSE_1 = 0x1
	// Position of MUX field.
	PORT_PCR27_MUX_Pos = 0x8
	// Bit mask of MUX field.
	PORT_PCR27_MUX_Msk = 0x700
	// Pin disabled (analog).
	PORT_PCR27_MUX_000 = 0x0
	// Alternative 1 (GPIO).
	PORT_PCR27_MUX_001 = 0x1
	// Alternative 2 (chip-specific).
	PORT_PCR27_MUX_010 = 0x2
	// Alternative 3 (chip-specific).
	PORT_PCR27_MUX_011 = 0x3
	// Alternative 4 (chip-specific).
	PORT_PCR27_MUX_100 = 0x4
	// Alternative 5 (chip-specific).
	PORT_PCR27_MUX_101 = 0x5
	// Alternative 6 (chip-specific).
	PORT_PCR27_MUX_110 = 0x6
	// Alternative 7 (chip-specific).
	PORT_PCR27_MUX_111 = 0x7
	// Position of LK field.
	PORT_PCR27_LK_Pos = 0xf
	// Bit mask of LK field.
	PORT_PCR27_LK_Msk = 0x8000
	// Bit LK.
	PORT_PCR27_LK = 0x8000
	// Pin Control Register fields [15:0] are not locked.
	PORT_PCR27_LK_0 = 0x0
	// Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
	PORT_PCR27_LK_1 = 0x1
	// Position of IRQC field.
	PORT_PCR27_IRQC_Pos = 0x10
	// Bit mask of IRQC field.
	PORT_PCR27_IRQC_Msk = 0xf0000
	// Interrupt/DMA request disabled.
	PORT_PCR27_IRQC_0000 = 0x0
	// DMA request on rising edge.
	PORT_PCR27_IRQC_0001 = 0x1
	// DMA request on falling edge.
	PORT_PCR27_IRQC_0010 = 0x2
	// DMA request on either edge.
	PORT_PCR27_IRQC_0011 = 0x3
	// Interrupt when logic 0.
	PORT_PCR27_IRQC_1000 = 0x8
	// Interrupt on rising-edge.
	PORT_PCR27_IRQC_1001 = 0x9
	// Interrupt on falling-edge.
	PORT_PCR27_IRQC_1010 = 0xa
	// Interrupt on either edge.
	PORT_PCR27_IRQC_1011 = 0xb
	// Interrupt when logic 1.
	PORT_PCR27_IRQC_1100 = 0xc
	// Position of ISF field.
	PORT_PCR27_ISF_Pos = 0x18
	// Bit mask of ISF field.
	PORT_PCR27_ISF_Msk = 0x1000000
	// Bit ISF.
	PORT_PCR27_ISF = 0x1000000
	// Configured interrupt is not detected.
	PORT_PCR27_ISF_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_PCR27_ISF_1 = 0x1

	// PCR28: Pin Control Register n
	// Position of PS field.
	PORT_PCR28_PS_Pos = 0x0
	// Bit mask of PS field.
	PORT_PCR28_PS_Msk = 0x1
	// Bit PS.
	PORT_PCR28_PS = 0x1
	// Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR28_PS_0 = 0x0
	// Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR28_PS_1 = 0x1
	// Position of PE field.
	PORT_PCR28_PE_Pos = 0x1
	// Bit mask of PE field.
	PORT_PCR28_PE_Msk = 0x2
	// Bit PE.
	PORT_PCR28_PE = 0x2
	// Internal pullup or pulldown resistor is not enabled on the corresponding pin.
	PORT_PCR28_PE_0 = 0x0
	// Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
	PORT_PCR28_PE_1 = 0x1
	// Position of SRE field.
	PORT_PCR28_SRE_Pos = 0x2
	// Bit mask of SRE field.
	PORT_PCR28_SRE_Msk = 0x4
	// Bit SRE.
	PORT_PCR28_SRE = 0x4
	// Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR28_SRE_0 = 0x0
	// Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR28_SRE_1 = 0x1
	// Position of PFE field.
	PORT_PCR28_PFE_Pos = 0x4
	// Bit mask of PFE field.
	PORT_PCR28_PFE_Msk = 0x10
	// Bit PFE.
	PORT_PCR28_PFE = 0x10
	// Passive input filter is disabled on the corresponding pin.
	PORT_PCR28_PFE_0 = 0x0
	// Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
	PORT_PCR28_PFE_1 = 0x1
	// Position of ODE field.
	PORT_PCR28_ODE_Pos = 0x5
	// Bit mask of ODE field.
	PORT_PCR28_ODE_Msk = 0x20
	// Bit ODE.
	PORT_PCR28_ODE = 0x20
	// Open drain output is disabled on the corresponding pin.
	PORT_PCR28_ODE_0 = 0x0
	// Open drain output is enabled on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR28_ODE_1 = 0x1
	// Position of DSE field.
	PORT_PCR28_DSE_Pos = 0x6
	// Bit mask of DSE field.
	PORT_PCR28_DSE_Msk = 0x40
	// Bit DSE.
	PORT_PCR28_DSE = 0x40
	// Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR28_DSE_0 = 0x0
	// High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR28_DSE_1 = 0x1
	// Position of MUX field.
	PORT_PCR28_MUX_Pos = 0x8
	// Bit mask of MUX field.
	PORT_PCR28_MUX_Msk = 0x700
	// Pin disabled (analog).
	PORT_PCR28_MUX_000 = 0x0
	// Alternative 1 (GPIO).
	PORT_PCR28_MUX_001 = 0x1
	// Alternative 2 (chip-specific).
	PORT_PCR28_MUX_010 = 0x2
	// Alternative 3 (chip-specific).
	PORT_PCR28_MUX_011 = 0x3
	// Alternative 4 (chip-specific).
	PORT_PCR28_MUX_100 = 0x4
	// Alternative 5 (chip-specific).
	PORT_PCR28_MUX_101 = 0x5
	// Alternative 6 (chip-specific).
	PORT_PCR28_MUX_110 = 0x6
	// Alternative 7 (chip-specific).
	PORT_PCR28_MUX_111 = 0x7
	// Position of LK field.
	PORT_PCR28_LK_Pos = 0xf
	// Bit mask of LK field.
	PORT_PCR28_LK_Msk = 0x8000
	// Bit LK.
	PORT_PCR28_LK = 0x8000
	// Pin Control Register fields [15:0] are not locked.
	PORT_PCR28_LK_0 = 0x0
	// Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
	PORT_PCR28_LK_1 = 0x1
	// Position of IRQC field.
	PORT_PCR28_IRQC_Pos = 0x10
	// Bit mask of IRQC field.
	PORT_PCR28_IRQC_Msk = 0xf0000
	// Interrupt/DMA request disabled.
	PORT_PCR28_IRQC_0000 = 0x0
	// DMA request on rising edge.
	PORT_PCR28_IRQC_0001 = 0x1
	// DMA request on falling edge.
	PORT_PCR28_IRQC_0010 = 0x2
	// DMA request on either edge.
	PORT_PCR28_IRQC_0011 = 0x3
	// Interrupt when logic 0.
	PORT_PCR28_IRQC_1000 = 0x8
	// Interrupt on rising-edge.
	PORT_PCR28_IRQC_1001 = 0x9
	// Interrupt on falling-edge.
	PORT_PCR28_IRQC_1010 = 0xa
	// Interrupt on either edge.
	PORT_PCR28_IRQC_1011 = 0xb
	// Interrupt when logic 1.
	PORT_PCR28_IRQC_1100 = 0xc
	// Position of ISF field.
	PORT_PCR28_ISF_Pos = 0x18
	// Bit mask of ISF field.
	PORT_PCR28_ISF_Msk = 0x1000000
	// Bit ISF.
	PORT_PCR28_ISF = 0x1000000
	// Configured interrupt is not detected.
	PORT_PCR28_ISF_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_PCR28_ISF_1 = 0x1

	// PCR29: Pin Control Register n
	// Position of PS field.
	PORT_PCR29_PS_Pos = 0x0
	// Bit mask of PS field.
	PORT_PCR29_PS_Msk = 0x1
	// Bit PS.
	PORT_PCR29_PS = 0x1
	// Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR29_PS_0 = 0x0
	// Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR29_PS_1 = 0x1
	// Position of PE field.
	PORT_PCR29_PE_Pos = 0x1
	// Bit mask of PE field.
	PORT_PCR29_PE_Msk = 0x2
	// Bit PE.
	PORT_PCR29_PE = 0x2
	// Internal pullup or pulldown resistor is not enabled on the corresponding pin.
	PORT_PCR29_PE_0 = 0x0
	// Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
	PORT_PCR29_PE_1 = 0x1
	// Position of SRE field.
	PORT_PCR29_SRE_Pos = 0x2
	// Bit mask of SRE field.
	PORT_PCR29_SRE_Msk = 0x4
	// Bit SRE.
	PORT_PCR29_SRE = 0x4
	// Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR29_SRE_0 = 0x0
	// Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR29_SRE_1 = 0x1
	// Position of PFE field.
	PORT_PCR29_PFE_Pos = 0x4
	// Bit mask of PFE field.
	PORT_PCR29_PFE_Msk = 0x10
	// Bit PFE.
	PORT_PCR29_PFE = 0x10
	// Passive input filter is disabled on the corresponding pin.
	PORT_PCR29_PFE_0 = 0x0
	// Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
	PORT_PCR29_PFE_1 = 0x1
	// Position of ODE field.
	PORT_PCR29_ODE_Pos = 0x5
	// Bit mask of ODE field.
	PORT_PCR29_ODE_Msk = 0x20
	// Bit ODE.
	PORT_PCR29_ODE = 0x20
	// Open drain output is disabled on the corresponding pin.
	PORT_PCR29_ODE_0 = 0x0
	// Open drain output is enabled on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR29_ODE_1 = 0x1
	// Position of DSE field.
	PORT_PCR29_DSE_Pos = 0x6
	// Bit mask of DSE field.
	PORT_PCR29_DSE_Msk = 0x40
	// Bit DSE.
	PORT_PCR29_DSE = 0x40
	// Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR29_DSE_0 = 0x0
	// High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR29_DSE_1 = 0x1
	// Position of MUX field.
	PORT_PCR29_MUX_Pos = 0x8
	// Bit mask of MUX field.
	PORT_PCR29_MUX_Msk = 0x700
	// Pin disabled (analog).
	PORT_PCR29_MUX_000 = 0x0
	// Alternative 1 (GPIO).
	PORT_PCR29_MUX_001 = 0x1
	// Alternative 2 (chip-specific).
	PORT_PCR29_MUX_010 = 0x2
	// Alternative 3 (chip-specific).
	PORT_PCR29_MUX_011 = 0x3
	// Alternative 4 (chip-specific).
	PORT_PCR29_MUX_100 = 0x4
	// Alternative 5 (chip-specific).
	PORT_PCR29_MUX_101 = 0x5
	// Alternative 6 (chip-specific).
	PORT_PCR29_MUX_110 = 0x6
	// Alternative 7 (chip-specific).
	PORT_PCR29_MUX_111 = 0x7
	// Position of LK field.
	PORT_PCR29_LK_Pos = 0xf
	// Bit mask of LK field.
	PORT_PCR29_LK_Msk = 0x8000
	// Bit LK.
	PORT_PCR29_LK = 0x8000
	// Pin Control Register fields [15:0] are not locked.
	PORT_PCR29_LK_0 = 0x0
	// Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
	PORT_PCR29_LK_1 = 0x1
	// Position of IRQC field.
	PORT_PCR29_IRQC_Pos = 0x10
	// Bit mask of IRQC field.
	PORT_PCR29_IRQC_Msk = 0xf0000
	// Interrupt/DMA request disabled.
	PORT_PCR29_IRQC_0000 = 0x0
	// DMA request on rising edge.
	PORT_PCR29_IRQC_0001 = 0x1
	// DMA request on falling edge.
	PORT_PCR29_IRQC_0010 = 0x2
	// DMA request on either edge.
	PORT_PCR29_IRQC_0011 = 0x3
	// Interrupt when logic 0.
	PORT_PCR29_IRQC_1000 = 0x8
	// Interrupt on rising-edge.
	PORT_PCR29_IRQC_1001 = 0x9
	// Interrupt on falling-edge.
	PORT_PCR29_IRQC_1010 = 0xa
	// Interrupt on either edge.
	PORT_PCR29_IRQC_1011 = 0xb
	// Interrupt when logic 1.
	PORT_PCR29_IRQC_1100 = 0xc
	// Position of ISF field.
	PORT_PCR29_ISF_Pos = 0x18
	// Bit mask of ISF field.
	PORT_PCR29_ISF_Msk = 0x1000000
	// Bit ISF.
	PORT_PCR29_ISF = 0x1000000
	// Configured interrupt is not detected.
	PORT_PCR29_ISF_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_PCR29_ISF_1 = 0x1

	// PCR30: Pin Control Register n
	// Position of PS field.
	PORT_PCR30_PS_Pos = 0x0
	// Bit mask of PS field.
	PORT_PCR30_PS_Msk = 0x1
	// Bit PS.
	PORT_PCR30_PS = 0x1
	// Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR30_PS_0 = 0x0
	// Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR30_PS_1 = 0x1
	// Position of PE field.
	PORT_PCR30_PE_Pos = 0x1
	// Bit mask of PE field.
	PORT_PCR30_PE_Msk = 0x2
	// Bit PE.
	PORT_PCR30_PE = 0x2
	// Internal pullup or pulldown resistor is not enabled on the corresponding pin.
	PORT_PCR30_PE_0 = 0x0
	// Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
	PORT_PCR30_PE_1 = 0x1
	// Position of SRE field.
	PORT_PCR30_SRE_Pos = 0x2
	// Bit mask of SRE field.
	PORT_PCR30_SRE_Msk = 0x4
	// Bit SRE.
	PORT_PCR30_SRE = 0x4
	// Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR30_SRE_0 = 0x0
	// Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR30_SRE_1 = 0x1
	// Position of PFE field.
	PORT_PCR30_PFE_Pos = 0x4
	// Bit mask of PFE field.
	PORT_PCR30_PFE_Msk = 0x10
	// Bit PFE.
	PORT_PCR30_PFE = 0x10
	// Passive input filter is disabled on the corresponding pin.
	PORT_PCR30_PFE_0 = 0x0
	// Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
	PORT_PCR30_PFE_1 = 0x1
	// Position of ODE field.
	PORT_PCR30_ODE_Pos = 0x5
	// Bit mask of ODE field.
	PORT_PCR30_ODE_Msk = 0x20
	// Bit ODE.
	PORT_PCR30_ODE = 0x20
	// Open drain output is disabled on the corresponding pin.
	PORT_PCR30_ODE_0 = 0x0
	// Open drain output is enabled on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR30_ODE_1 = 0x1
	// Position of DSE field.
	PORT_PCR30_DSE_Pos = 0x6
	// Bit mask of DSE field.
	PORT_PCR30_DSE_Msk = 0x40
	// Bit DSE.
	PORT_PCR30_DSE = 0x40
	// Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR30_DSE_0 = 0x0
	// High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR30_DSE_1 = 0x1
	// Position of MUX field.
	PORT_PCR30_MUX_Pos = 0x8
	// Bit mask of MUX field.
	PORT_PCR30_MUX_Msk = 0x700
	// Pin disabled (analog).
	PORT_PCR30_MUX_000 = 0x0
	// Alternative 1 (GPIO).
	PORT_PCR30_MUX_001 = 0x1
	// Alternative 2 (chip-specific).
	PORT_PCR30_MUX_010 = 0x2
	// Alternative 3 (chip-specific).
	PORT_PCR30_MUX_011 = 0x3
	// Alternative 4 (chip-specific).
	PORT_PCR30_MUX_100 = 0x4
	// Alternative 5 (chip-specific).
	PORT_PCR30_MUX_101 = 0x5
	// Alternative 6 (chip-specific).
	PORT_PCR30_MUX_110 = 0x6
	// Alternative 7 (chip-specific).
	PORT_PCR30_MUX_111 = 0x7
	// Position of LK field.
	PORT_PCR30_LK_Pos = 0xf
	// Bit mask of LK field.
	PORT_PCR30_LK_Msk = 0x8000
	// Bit LK.
	PORT_PCR30_LK = 0x8000
	// Pin Control Register fields [15:0] are not locked.
	PORT_PCR30_LK_0 = 0x0
	// Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
	PORT_PCR30_LK_1 = 0x1
	// Position of IRQC field.
	PORT_PCR30_IRQC_Pos = 0x10
	// Bit mask of IRQC field.
	PORT_PCR30_IRQC_Msk = 0xf0000
	// Interrupt/DMA request disabled.
	PORT_PCR30_IRQC_0000 = 0x0
	// DMA request on rising edge.
	PORT_PCR30_IRQC_0001 = 0x1
	// DMA request on falling edge.
	PORT_PCR30_IRQC_0010 = 0x2
	// DMA request on either edge.
	PORT_PCR30_IRQC_0011 = 0x3
	// Interrupt when logic 0.
	PORT_PCR30_IRQC_1000 = 0x8
	// Interrupt on rising-edge.
	PORT_PCR30_IRQC_1001 = 0x9
	// Interrupt on falling-edge.
	PORT_PCR30_IRQC_1010 = 0xa
	// Interrupt on either edge.
	PORT_PCR30_IRQC_1011 = 0xb
	// Interrupt when logic 1.
	PORT_PCR30_IRQC_1100 = 0xc
	// Position of ISF field.
	PORT_PCR30_ISF_Pos = 0x18
	// Bit mask of ISF field.
	PORT_PCR30_ISF_Msk = 0x1000000
	// Bit ISF.
	PORT_PCR30_ISF = 0x1000000
	// Configured interrupt is not detected.
	PORT_PCR30_ISF_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_PCR30_ISF_1 = 0x1

	// PCR31: Pin Control Register n
	// Position of PS field.
	PORT_PCR31_PS_Pos = 0x0
	// Bit mask of PS field.
	PORT_PCR31_PS_Msk = 0x1
	// Bit PS.
	PORT_PCR31_PS = 0x1
	// Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR31_PS_0 = 0x0
	// Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR31_PS_1 = 0x1
	// Position of PE field.
	PORT_PCR31_PE_Pos = 0x1
	// Bit mask of PE field.
	PORT_PCR31_PE_Msk = 0x2
	// Bit PE.
	PORT_PCR31_PE = 0x2
	// Internal pullup or pulldown resistor is not enabled on the corresponding pin.
	PORT_PCR31_PE_0 = 0x0
	// Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
	PORT_PCR31_PE_1 = 0x1
	// Position of SRE field.
	PORT_PCR31_SRE_Pos = 0x2
	// Bit mask of SRE field.
	PORT_PCR31_SRE_Msk = 0x4
	// Bit SRE.
	PORT_PCR31_SRE = 0x4
	// Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR31_SRE_0 = 0x0
	// Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR31_SRE_1 = 0x1
	// Position of PFE field.
	PORT_PCR31_PFE_Pos = 0x4
	// Bit mask of PFE field.
	PORT_PCR31_PFE_Msk = 0x10
	// Bit PFE.
	PORT_PCR31_PFE = 0x10
	// Passive input filter is disabled on the corresponding pin.
	PORT_PCR31_PFE_0 = 0x0
	// Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
	PORT_PCR31_PFE_1 = 0x1
	// Position of ODE field.
	PORT_PCR31_ODE_Pos = 0x5
	// Bit mask of ODE field.
	PORT_PCR31_ODE_Msk = 0x20
	// Bit ODE.
	PORT_PCR31_ODE = 0x20
	// Open drain output is disabled on the corresponding pin.
	PORT_PCR31_ODE_0 = 0x0
	// Open drain output is enabled on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR31_ODE_1 = 0x1
	// Position of DSE field.
	PORT_PCR31_DSE_Pos = 0x6
	// Bit mask of DSE field.
	PORT_PCR31_DSE_Msk = 0x40
	// Bit DSE.
	PORT_PCR31_DSE = 0x40
	// Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR31_DSE_0 = 0x0
	// High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR31_DSE_1 = 0x1
	// Position of MUX field.
	PORT_PCR31_MUX_Pos = 0x8
	// Bit mask of MUX field.
	PORT_PCR31_MUX_Msk = 0x700
	// Pin disabled (analog).
	PORT_PCR31_MUX_000 = 0x0
	// Alternative 1 (GPIO).
	PORT_PCR31_MUX_001 = 0x1
	// Alternative 2 (chip-specific).
	PORT_PCR31_MUX_010 = 0x2
	// Alternative 3 (chip-specific).
	PORT_PCR31_MUX_011 = 0x3
	// Alternative 4 (chip-specific).
	PORT_PCR31_MUX_100 = 0x4
	// Alternative 5 (chip-specific).
	PORT_PCR31_MUX_101 = 0x5
	// Alternative 6 (chip-specific).
	PORT_PCR31_MUX_110 = 0x6
	// Alternative 7 (chip-specific).
	PORT_PCR31_MUX_111 = 0x7
	// Position of LK field.
	PORT_PCR31_LK_Pos = 0xf
	// Bit mask of LK field.
	PORT_PCR31_LK_Msk = 0x8000
	// Bit LK.
	PORT_PCR31_LK = 0x8000
	// Pin Control Register fields [15:0] are not locked.
	PORT_PCR31_LK_0 = 0x0
	// Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
	PORT_PCR31_LK_1 = 0x1
	// Position of IRQC field.
	PORT_PCR31_IRQC_Pos = 0x10
	// Bit mask of IRQC field.
	PORT_PCR31_IRQC_Msk = 0xf0000
	// Interrupt/DMA request disabled.
	PORT_PCR31_IRQC_0000 = 0x0
	// DMA request on rising edge.
	PORT_PCR31_IRQC_0001 = 0x1
	// DMA request on falling edge.
	PORT_PCR31_IRQC_0010 = 0x2
	// DMA request on either edge.
	PORT_PCR31_IRQC_0011 = 0x3
	// Interrupt when logic 0.
	PORT_PCR31_IRQC_1000 = 0x8
	// Interrupt on rising-edge.
	PORT_PCR31_IRQC_1001 = 0x9
	// Interrupt on falling-edge.
	PORT_PCR31_IRQC_1010 = 0xa
	// Interrupt on either edge.
	PORT_PCR31_IRQC_1011 = 0xb
	// Interrupt when logic 1.
	PORT_PCR31_IRQC_1100 = 0xc
	// Position of ISF field.
	PORT_PCR31_ISF_Pos = 0x18
	// Bit mask of ISF field.
	PORT_PCR31_ISF_Msk = 0x1000000
	// Bit ISF.
	PORT_PCR31_ISF = 0x1000000
	// Configured interrupt is not detected.
	PORT_PCR31_ISF_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_PCR31_ISF_1 = 0x1

	// GPCLR: Global Pin Control Low Register
	// Position of GPWD field.
	PORT_GPCLR_GPWD_Pos = 0x0
	// Bit mask of GPWD field.
	PORT_GPCLR_GPWD_Msk = 0xffff
	// Position of GPWE0 field.
	PORT_GPCLR_GPWE0_Pos = 0x10
	// Bit mask of GPWE0 field.
	PORT_GPCLR_GPWE0_Msk = 0x10000
	// Bit GPWE0.
	PORT_GPCLR_GPWE0 = 0x10000
	// Corresponding Pin Control Register is not updated with the value in GPWD.
	PORT_GPCLR_GPWE0_0 = 0x0
	// Corresponding Pin Control Register is updated with the value in GPWD.
	PORT_GPCLR_GPWE0_1 = 0x1
	// Position of GPWE1 field.
	PORT_GPCLR_GPWE1_Pos = 0x11
	// Bit mask of GPWE1 field.
	PORT_GPCLR_GPWE1_Msk = 0x20000
	// Bit GPWE1.
	PORT_GPCLR_GPWE1 = 0x20000
	// Corresponding Pin Control Register is not updated with the value in GPWD.
	PORT_GPCLR_GPWE1_0 = 0x0
	// Corresponding Pin Control Register is updated with the value in GPWD.
	PORT_GPCLR_GPWE1_1 = 0x1
	// Position of GPWE2 field.
	PORT_GPCLR_GPWE2_Pos = 0x12
	// Bit mask of GPWE2 field.
	PORT_GPCLR_GPWE2_Msk = 0x40000
	// Bit GPWE2.
	PORT_GPCLR_GPWE2 = 0x40000
	// Corresponding Pin Control Register is not updated with the value in GPWD.
	PORT_GPCLR_GPWE2_0 = 0x0
	// Corresponding Pin Control Register is updated with the value in GPWD.
	PORT_GPCLR_GPWE2_1 = 0x1
	// Position of GPWE3 field.
	PORT_GPCLR_GPWE3_Pos = 0x13
	// Bit mask of GPWE3 field.
	PORT_GPCLR_GPWE3_Msk = 0x80000
	// Bit GPWE3.
	PORT_GPCLR_GPWE3 = 0x80000
	// Corresponding Pin Control Register is not updated with the value in GPWD.
	PORT_GPCLR_GPWE3_0 = 0x0
	// Corresponding Pin Control Register is updated with the value in GPWD.
	PORT_GPCLR_GPWE3_1 = 0x1
	// Position of GPWE4 field.
	PORT_GPCLR_GPWE4_Pos = 0x14
	// Bit mask of GPWE4 field.
	PORT_GPCLR_GPWE4_Msk = 0x100000
	// Bit GPWE4.
	PORT_GPCLR_GPWE4 = 0x100000
	// Corresponding Pin Control Register is not updated with the value in GPWD.
	PORT_GPCLR_GPWE4_0 = 0x0
	// Corresponding Pin Control Register is updated with the value in GPWD.
	PORT_GPCLR_GPWE4_1 = 0x1
	// Position of GPWE5 field.
	PORT_GPCLR_GPWE5_Pos = 0x15
	// Bit mask of GPWE5 field.
	PORT_GPCLR_GPWE5_Msk = 0x200000
	// Bit GPWE5.
	PORT_GPCLR_GPWE5 = 0x200000
	// Corresponding Pin Control Register is not updated with the value in GPWD.
	PORT_GPCLR_GPWE5_0 = 0x0
	// Corresponding Pin Control Register is updated with the value in GPWD.
	PORT_GPCLR_GPWE5_1 = 0x1
	// Position of GPWE6 field.
	PORT_GPCLR_GPWE6_Pos = 0x16
	// Bit mask of GPWE6 field.
	PORT_GPCLR_GPWE6_Msk = 0x400000
	// Bit GPWE6.
	PORT_GPCLR_GPWE6 = 0x400000
	// Corresponding Pin Control Register is not updated with the value in GPWD.
	PORT_GPCLR_GPWE6_0 = 0x0
	// Corresponding Pin Control Register is updated with the value in GPWD.
	PORT_GPCLR_GPWE6_1 = 0x1
	// Position of GPWE7 field.
	PORT_GPCLR_GPWE7_Pos = 0x17
	// Bit mask of GPWE7 field.
	PORT_GPCLR_GPWE7_Msk = 0x800000
	// Bit GPWE7.
	PORT_GPCLR_GPWE7 = 0x800000
	// Corresponding Pin Control Register is not updated with the value in GPWD.
	PORT_GPCLR_GPWE7_0 = 0x0
	// Corresponding Pin Control Register is updated with the value in GPWD.
	PORT_GPCLR_GPWE7_1 = 0x1
	// Position of GPWE8 field.
	PORT_GPCLR_GPWE8_Pos = 0x18
	// Bit mask of GPWE8 field.
	PORT_GPCLR_GPWE8_Msk = 0x1000000
	// Bit GPWE8.
	PORT_GPCLR_GPWE8 = 0x1000000
	// Corresponding Pin Control Register is not updated with the value in GPWD.
	PORT_GPCLR_GPWE8_0 = 0x0
	// Corresponding Pin Control Register is updated with the value in GPWD.
	PORT_GPCLR_GPWE8_1 = 0x1
	// Position of GPWE9 field.
	PORT_GPCLR_GPWE9_Pos = 0x19
	// Bit mask of GPWE9 field.
	PORT_GPCLR_GPWE9_Msk = 0x2000000
	// Bit GPWE9.
	PORT_GPCLR_GPWE9 = 0x2000000
	// Corresponding Pin Control Register is not updated with the value in GPWD.
	PORT_GPCLR_GPWE9_0 = 0x0
	// Corresponding Pin Control Register is updated with the value in GPWD.
	PORT_GPCLR_GPWE9_1 = 0x1
	// Position of GPWE10 field.
	PORT_GPCLR_GPWE10_Pos = 0x1a
	// Bit mask of GPWE10 field.
	PORT_GPCLR_GPWE10_Msk = 0x4000000
	// Bit GPWE10.
	PORT_GPCLR_GPWE10 = 0x4000000
	// Corresponding Pin Control Register is not updated with the value in GPWD.
	PORT_GPCLR_GPWE10_0 = 0x0
	// Corresponding Pin Control Register is updated with the value in GPWD.
	PORT_GPCLR_GPWE10_1 = 0x1
	// Position of GPWE11 field.
	PORT_GPCLR_GPWE11_Pos = 0x1b
	// Bit mask of GPWE11 field.
	PORT_GPCLR_GPWE11_Msk = 0x8000000
	// Bit GPWE11.
	PORT_GPCLR_GPWE11 = 0x8000000
	// Corresponding Pin Control Register is not updated with the value in GPWD.
	PORT_GPCLR_GPWE11_0 = 0x0
	// Corresponding Pin Control Register is updated with the value in GPWD.
	PORT_GPCLR_GPWE11_1 = 0x1
	// Position of GPWE12 field.
	PORT_GPCLR_GPWE12_Pos = 0x1c
	// Bit mask of GPWE12 field.
	PORT_GPCLR_GPWE12_Msk = 0x10000000
	// Bit GPWE12.
	PORT_GPCLR_GPWE12 = 0x10000000
	// Corresponding Pin Control Register is not updated with the value in GPWD.
	PORT_GPCLR_GPWE12_0 = 0x0
	// Corresponding Pin Control Register is updated with the value in GPWD.
	PORT_GPCLR_GPWE12_1 = 0x1
	// Position of GPWE13 field.
	PORT_GPCLR_GPWE13_Pos = 0x1d
	// Bit mask of GPWE13 field.
	PORT_GPCLR_GPWE13_Msk = 0x20000000
	// Bit GPWE13.
	PORT_GPCLR_GPWE13 = 0x20000000
	// Corresponding Pin Control Register is not updated with the value in GPWD.
	PORT_GPCLR_GPWE13_0 = 0x0
	// Corresponding Pin Control Register is updated with the value in GPWD.
	PORT_GPCLR_GPWE13_1 = 0x1
	// Position of GPWE14 field.
	PORT_GPCLR_GPWE14_Pos = 0x1e
	// Bit mask of GPWE14 field.
	PORT_GPCLR_GPWE14_Msk = 0x40000000
	// Bit GPWE14.
	PORT_GPCLR_GPWE14 = 0x40000000
	// Corresponding Pin Control Register is not updated with the value in GPWD.
	PORT_GPCLR_GPWE14_0 = 0x0
	// Corresponding Pin Control Register is updated with the value in GPWD.
	PORT_GPCLR_GPWE14_1 = 0x1
	// Position of GPWE15 field.
	PORT_GPCLR_GPWE15_Pos = 0x1f
	// Bit mask of GPWE15 field.
	PORT_GPCLR_GPWE15_Msk = 0x80000000
	// Bit GPWE15.
	PORT_GPCLR_GPWE15 = 0x80000000
	// Corresponding Pin Control Register is not updated with the value in GPWD.
	PORT_GPCLR_GPWE15_0 = 0x0
	// Corresponding Pin Control Register is updated with the value in GPWD.
	PORT_GPCLR_GPWE15_1 = 0x1

	// GPCHR: Global Pin Control High Register
	// Position of GPWD field.
	PORT_GPCHR_GPWD_Pos = 0x0
	// Bit mask of GPWD field.
	PORT_GPCHR_GPWD_Msk = 0xffff
	// Position of GPWE0 field.
	PORT_GPCHR_GPWE0_Pos = 0x10
	// Bit mask of GPWE0 field.
	PORT_GPCHR_GPWE0_Msk = 0x10000
	// Bit GPWE0.
	PORT_GPCHR_GPWE0 = 0x10000
	// Corresponding Pin Control Register is not updated with the value in GPWD.
	PORT_GPCHR_GPWE0_0 = 0x0
	// Corresponding Pin Control Register is updated with the value in GPWD.
	PORT_GPCHR_GPWE0_1 = 0x1
	// Position of GPWE1 field.
	PORT_GPCHR_GPWE1_Pos = 0x11
	// Bit mask of GPWE1 field.
	PORT_GPCHR_GPWE1_Msk = 0x20000
	// Bit GPWE1.
	PORT_GPCHR_GPWE1 = 0x20000
	// Corresponding Pin Control Register is not updated with the value in GPWD.
	PORT_GPCHR_GPWE1_0 = 0x0
	// Corresponding Pin Control Register is updated with the value in GPWD.
	PORT_GPCHR_GPWE1_1 = 0x1
	// Position of GPWE2 field.
	PORT_GPCHR_GPWE2_Pos = 0x12
	// Bit mask of GPWE2 field.
	PORT_GPCHR_GPWE2_Msk = 0x40000
	// Bit GPWE2.
	PORT_GPCHR_GPWE2 = 0x40000
	// Corresponding Pin Control Register is not updated with the value in GPWD.
	PORT_GPCHR_GPWE2_0 = 0x0
	// Corresponding Pin Control Register is updated with the value in GPWD.
	PORT_GPCHR_GPWE2_1 = 0x1
	// Position of GPWE3 field.
	PORT_GPCHR_GPWE3_Pos = 0x13
	// Bit mask of GPWE3 field.
	PORT_GPCHR_GPWE3_Msk = 0x80000
	// Bit GPWE3.
	PORT_GPCHR_GPWE3 = 0x80000
	// Corresponding Pin Control Register is not updated with the value in GPWD.
	PORT_GPCHR_GPWE3_0 = 0x0
	// Corresponding Pin Control Register is updated with the value in GPWD.
	PORT_GPCHR_GPWE3_1 = 0x1
	// Position of GPWE4 field.
	PORT_GPCHR_GPWE4_Pos = 0x14
	// Bit mask of GPWE4 field.
	PORT_GPCHR_GPWE4_Msk = 0x100000
	// Bit GPWE4.
	PORT_GPCHR_GPWE4 = 0x100000
	// Corresponding Pin Control Register is not updated with the value in GPWD.
	PORT_GPCHR_GPWE4_0 = 0x0
	// Corresponding Pin Control Register is updated with the value in GPWD.
	PORT_GPCHR_GPWE4_1 = 0x1
	// Position of GPWE5 field.
	PORT_GPCHR_GPWE5_Pos = 0x15
	// Bit mask of GPWE5 field.
	PORT_GPCHR_GPWE5_Msk = 0x200000
	// Bit GPWE5.
	PORT_GPCHR_GPWE5 = 0x200000
	// Corresponding Pin Control Register is not updated with the value in GPWD.
	PORT_GPCHR_GPWE5_0 = 0x0
	// Corresponding Pin Control Register is updated with the value in GPWD.
	PORT_GPCHR_GPWE5_1 = 0x1
	// Position of GPWE6 field.
	PORT_GPCHR_GPWE6_Pos = 0x16
	// Bit mask of GPWE6 field.
	PORT_GPCHR_GPWE6_Msk = 0x400000
	// Bit GPWE6.
	PORT_GPCHR_GPWE6 = 0x400000
	// Corresponding Pin Control Register is not updated with the value in GPWD.
	PORT_GPCHR_GPWE6_0 = 0x0
	// Corresponding Pin Control Register is updated with the value in GPWD.
	PORT_GPCHR_GPWE6_1 = 0x1
	// Position of GPWE7 field.
	PORT_GPCHR_GPWE7_Pos = 0x17
	// Bit mask of GPWE7 field.
	PORT_GPCHR_GPWE7_Msk = 0x800000
	// Bit GPWE7.
	PORT_GPCHR_GPWE7 = 0x800000
	// Corresponding Pin Control Register is not updated with the value in GPWD.
	PORT_GPCHR_GPWE7_0 = 0x0
	// Corresponding Pin Control Register is updated with the value in GPWD.
	PORT_GPCHR_GPWE7_1 = 0x1
	// Position of GPWE8 field.
	PORT_GPCHR_GPWE8_Pos = 0x18
	// Bit mask of GPWE8 field.
	PORT_GPCHR_GPWE8_Msk = 0x1000000
	// Bit GPWE8.
	PORT_GPCHR_GPWE8 = 0x1000000
	// Corresponding Pin Control Register is not updated with the value in GPWD.
	PORT_GPCHR_GPWE8_0 = 0x0
	// Corresponding Pin Control Register is updated with the value in GPWD.
	PORT_GPCHR_GPWE8_1 = 0x1
	// Position of GPWE9 field.
	PORT_GPCHR_GPWE9_Pos = 0x19
	// Bit mask of GPWE9 field.
	PORT_GPCHR_GPWE9_Msk = 0x2000000
	// Bit GPWE9.
	PORT_GPCHR_GPWE9 = 0x2000000
	// Corresponding Pin Control Register is not updated with the value in GPWD.
	PORT_GPCHR_GPWE9_0 = 0x0
	// Corresponding Pin Control Register is updated with the value in GPWD.
	PORT_GPCHR_GPWE9_1 = 0x1
	// Position of GPWE10 field.
	PORT_GPCHR_GPWE10_Pos = 0x1a
	// Bit mask of GPWE10 field.
	PORT_GPCHR_GPWE10_Msk = 0x4000000
	// Bit GPWE10.
	PORT_GPCHR_GPWE10 = 0x4000000
	// Corresponding Pin Control Register is not updated with the value in GPWD.
	PORT_GPCHR_GPWE10_0 = 0x0
	// Corresponding Pin Control Register is updated with the value in GPWD.
	PORT_GPCHR_GPWE10_1 = 0x1
	// Position of GPWE11 field.
	PORT_GPCHR_GPWE11_Pos = 0x1b
	// Bit mask of GPWE11 field.
	PORT_GPCHR_GPWE11_Msk = 0x8000000
	// Bit GPWE11.
	PORT_GPCHR_GPWE11 = 0x8000000
	// Corresponding Pin Control Register is not updated with the value in GPWD.
	PORT_GPCHR_GPWE11_0 = 0x0
	// Corresponding Pin Control Register is updated with the value in GPWD.
	PORT_GPCHR_GPWE11_1 = 0x1
	// Position of GPWE12 field.
	PORT_GPCHR_GPWE12_Pos = 0x1c
	// Bit mask of GPWE12 field.
	PORT_GPCHR_GPWE12_Msk = 0x10000000
	// Bit GPWE12.
	PORT_GPCHR_GPWE12 = 0x10000000
	// Corresponding Pin Control Register is not updated with the value in GPWD.
	PORT_GPCHR_GPWE12_0 = 0x0
	// Corresponding Pin Control Register is updated with the value in GPWD.
	PORT_GPCHR_GPWE12_1 = 0x1
	// Position of GPWE13 field.
	PORT_GPCHR_GPWE13_Pos = 0x1d
	// Bit mask of GPWE13 field.
	PORT_GPCHR_GPWE13_Msk = 0x20000000
	// Bit GPWE13.
	PORT_GPCHR_GPWE13 = 0x20000000
	// Corresponding Pin Control Register is not updated with the value in GPWD.
	PORT_GPCHR_GPWE13_0 = 0x0
	// Corresponding Pin Control Register is updated with the value in GPWD.
	PORT_GPCHR_GPWE13_1 = 0x1
	// Position of GPWE14 field.
	PORT_GPCHR_GPWE14_Pos = 0x1e
	// Bit mask of GPWE14 field.
	PORT_GPCHR_GPWE14_Msk = 0x40000000
	// Bit GPWE14.
	PORT_GPCHR_GPWE14 = 0x40000000
	// Corresponding Pin Control Register is not updated with the value in GPWD.
	PORT_GPCHR_GPWE14_0 = 0x0
	// Corresponding Pin Control Register is updated with the value in GPWD.
	PORT_GPCHR_GPWE14_1 = 0x1
	// Position of GPWE15 field.
	PORT_GPCHR_GPWE15_Pos = 0x1f
	// Bit mask of GPWE15 field.
	PORT_GPCHR_GPWE15_Msk = 0x80000000
	// Bit GPWE15.
	PORT_GPCHR_GPWE15 = 0x80000000
	// Corresponding Pin Control Register is not updated with the value in GPWD.
	PORT_GPCHR_GPWE15_0 = 0x0
	// Corresponding Pin Control Register is updated with the value in GPWD.
	PORT_GPCHR_GPWE15_1 = 0x1

	// ISFR: Interrupt Status Flag Register
	// Position of ISF0 field.
	PORT_ISFR_ISF0_Pos = 0x0
	// Bit mask of ISF0 field.
	PORT_ISFR_ISF0_Msk = 0x1
	// Bit ISF0.
	PORT_ISFR_ISF0 = 0x1
	// Configured interrupt is not detected.
	PORT_ISFR_ISF0_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_ISFR_ISF0_1 = 0x1
	// Position of ISF1 field.
	PORT_ISFR_ISF1_Pos = 0x1
	// Bit mask of ISF1 field.
	PORT_ISFR_ISF1_Msk = 0x2
	// Bit ISF1.
	PORT_ISFR_ISF1 = 0x2
	// Configured interrupt is not detected.
	PORT_ISFR_ISF1_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_ISFR_ISF1_1 = 0x1
	// Position of ISF2 field.
	PORT_ISFR_ISF2_Pos = 0x2
	// Bit mask of ISF2 field.
	PORT_ISFR_ISF2_Msk = 0x4
	// Bit ISF2.
	PORT_ISFR_ISF2 = 0x4
	// Configured interrupt is not detected.
	PORT_ISFR_ISF2_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_ISFR_ISF2_1 = 0x1
	// Position of ISF3 field.
	PORT_ISFR_ISF3_Pos = 0x3
	// Bit mask of ISF3 field.
	PORT_ISFR_ISF3_Msk = 0x8
	// Bit ISF3.
	PORT_ISFR_ISF3 = 0x8
	// Configured interrupt is not detected.
	PORT_ISFR_ISF3_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_ISFR_ISF3_1 = 0x1
	// Position of ISF4 field.
	PORT_ISFR_ISF4_Pos = 0x4
	// Bit mask of ISF4 field.
	PORT_ISFR_ISF4_Msk = 0x10
	// Bit ISF4.
	PORT_ISFR_ISF4 = 0x10
	// Configured interrupt is not detected.
	PORT_ISFR_ISF4_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_ISFR_ISF4_1 = 0x1
	// Position of ISF5 field.
	PORT_ISFR_ISF5_Pos = 0x5
	// Bit mask of ISF5 field.
	PORT_ISFR_ISF5_Msk = 0x20
	// Bit ISF5.
	PORT_ISFR_ISF5 = 0x20
	// Configured interrupt is not detected.
	PORT_ISFR_ISF5_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_ISFR_ISF5_1 = 0x1
	// Position of ISF6 field.
	PORT_ISFR_ISF6_Pos = 0x6
	// Bit mask of ISF6 field.
	PORT_ISFR_ISF6_Msk = 0x40
	// Bit ISF6.
	PORT_ISFR_ISF6 = 0x40
	// Configured interrupt is not detected.
	PORT_ISFR_ISF6_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_ISFR_ISF6_1 = 0x1
	// Position of ISF7 field.
	PORT_ISFR_ISF7_Pos = 0x7
	// Bit mask of ISF7 field.
	PORT_ISFR_ISF7_Msk = 0x80
	// Bit ISF7.
	PORT_ISFR_ISF7 = 0x80
	// Configured interrupt is not detected.
	PORT_ISFR_ISF7_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_ISFR_ISF7_1 = 0x1
	// Position of ISF8 field.
	PORT_ISFR_ISF8_Pos = 0x8
	// Bit mask of ISF8 field.
	PORT_ISFR_ISF8_Msk = 0x100
	// Bit ISF8.
	PORT_ISFR_ISF8 = 0x100
	// Configured interrupt is not detected.
	PORT_ISFR_ISF8_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_ISFR_ISF8_1 = 0x1
	// Position of ISF9 field.
	PORT_ISFR_ISF9_Pos = 0x9
	// Bit mask of ISF9 field.
	PORT_ISFR_ISF9_Msk = 0x200
	// Bit ISF9.
	PORT_ISFR_ISF9 = 0x200
	// Configured interrupt is not detected.
	PORT_ISFR_ISF9_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_ISFR_ISF9_1 = 0x1
	// Position of ISF10 field.
	PORT_ISFR_ISF10_Pos = 0xa
	// Bit mask of ISF10 field.
	PORT_ISFR_ISF10_Msk = 0x400
	// Bit ISF10.
	PORT_ISFR_ISF10 = 0x400
	// Configured interrupt is not detected.
	PORT_ISFR_ISF10_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_ISFR_ISF10_1 = 0x1
	// Position of ISF11 field.
	PORT_ISFR_ISF11_Pos = 0xb
	// Bit mask of ISF11 field.
	PORT_ISFR_ISF11_Msk = 0x800
	// Bit ISF11.
	PORT_ISFR_ISF11 = 0x800
	// Configured interrupt is not detected.
	PORT_ISFR_ISF11_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_ISFR_ISF11_1 = 0x1
	// Position of ISF12 field.
	PORT_ISFR_ISF12_Pos = 0xc
	// Bit mask of ISF12 field.
	PORT_ISFR_ISF12_Msk = 0x1000
	// Bit ISF12.
	PORT_ISFR_ISF12 = 0x1000
	// Configured interrupt is not detected.
	PORT_ISFR_ISF12_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_ISFR_ISF12_1 = 0x1
	// Position of ISF13 field.
	PORT_ISFR_ISF13_Pos = 0xd
	// Bit mask of ISF13 field.
	PORT_ISFR_ISF13_Msk = 0x2000
	// Bit ISF13.
	PORT_ISFR_ISF13 = 0x2000
	// Configured interrupt is not detected.
	PORT_ISFR_ISF13_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_ISFR_ISF13_1 = 0x1
	// Position of ISF14 field.
	PORT_ISFR_ISF14_Pos = 0xe
	// Bit mask of ISF14 field.
	PORT_ISFR_ISF14_Msk = 0x4000
	// Bit ISF14.
	PORT_ISFR_ISF14 = 0x4000
	// Configured interrupt is not detected.
	PORT_ISFR_ISF14_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_ISFR_ISF14_1 = 0x1
	// Position of ISF15 field.
	PORT_ISFR_ISF15_Pos = 0xf
	// Bit mask of ISF15 field.
	PORT_ISFR_ISF15_Msk = 0x8000
	// Bit ISF15.
	PORT_ISFR_ISF15 = 0x8000
	// Configured interrupt is not detected.
	PORT_ISFR_ISF15_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_ISFR_ISF15_1 = 0x1
	// Position of ISF16 field.
	PORT_ISFR_ISF16_Pos = 0x10
	// Bit mask of ISF16 field.
	PORT_ISFR_ISF16_Msk = 0x10000
	// Bit ISF16.
	PORT_ISFR_ISF16 = 0x10000
	// Configured interrupt is not detected.
	PORT_ISFR_ISF16_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_ISFR_ISF16_1 = 0x1
	// Position of ISF17 field.
	PORT_ISFR_ISF17_Pos = 0x11
	// Bit mask of ISF17 field.
	PORT_ISFR_ISF17_Msk = 0x20000
	// Bit ISF17.
	PORT_ISFR_ISF17 = 0x20000
	// Configured interrupt is not detected.
	PORT_ISFR_ISF17_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_ISFR_ISF17_1 = 0x1
	// Position of ISF18 field.
	PORT_ISFR_ISF18_Pos = 0x12
	// Bit mask of ISF18 field.
	PORT_ISFR_ISF18_Msk = 0x40000
	// Bit ISF18.
	PORT_ISFR_ISF18 = 0x40000
	// Configured interrupt is not detected.
	PORT_ISFR_ISF18_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_ISFR_ISF18_1 = 0x1
	// Position of ISF19 field.
	PORT_ISFR_ISF19_Pos = 0x13
	// Bit mask of ISF19 field.
	PORT_ISFR_ISF19_Msk = 0x80000
	// Bit ISF19.
	PORT_ISFR_ISF19 = 0x80000
	// Configured interrupt is not detected.
	PORT_ISFR_ISF19_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_ISFR_ISF19_1 = 0x1
	// Position of ISF20 field.
	PORT_ISFR_ISF20_Pos = 0x14
	// Bit mask of ISF20 field.
	PORT_ISFR_ISF20_Msk = 0x100000
	// Bit ISF20.
	PORT_ISFR_ISF20 = 0x100000
	// Configured interrupt is not detected.
	PORT_ISFR_ISF20_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_ISFR_ISF20_1 = 0x1
	// Position of ISF21 field.
	PORT_ISFR_ISF21_Pos = 0x15
	// Bit mask of ISF21 field.
	PORT_ISFR_ISF21_Msk = 0x200000
	// Bit ISF21.
	PORT_ISFR_ISF21 = 0x200000
	// Configured interrupt is not detected.
	PORT_ISFR_ISF21_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_ISFR_ISF21_1 = 0x1
	// Position of ISF22 field.
	PORT_ISFR_ISF22_Pos = 0x16
	// Bit mask of ISF22 field.
	PORT_ISFR_ISF22_Msk = 0x400000
	// Bit ISF22.
	PORT_ISFR_ISF22 = 0x400000
	// Configured interrupt is not detected.
	PORT_ISFR_ISF22_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_ISFR_ISF22_1 = 0x1
	// Position of ISF23 field.
	PORT_ISFR_ISF23_Pos = 0x17
	// Bit mask of ISF23 field.
	PORT_ISFR_ISF23_Msk = 0x800000
	// Bit ISF23.
	PORT_ISFR_ISF23 = 0x800000
	// Configured interrupt is not detected.
	PORT_ISFR_ISF23_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_ISFR_ISF23_1 = 0x1
	// Position of ISF24 field.
	PORT_ISFR_ISF24_Pos = 0x18
	// Bit mask of ISF24 field.
	PORT_ISFR_ISF24_Msk = 0x1000000
	// Bit ISF24.
	PORT_ISFR_ISF24 = 0x1000000
	// Configured interrupt is not detected.
	PORT_ISFR_ISF24_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_ISFR_ISF24_1 = 0x1
	// Position of ISF25 field.
	PORT_ISFR_ISF25_Pos = 0x19
	// Bit mask of ISF25 field.
	PORT_ISFR_ISF25_Msk = 0x2000000
	// Bit ISF25.
	PORT_ISFR_ISF25 = 0x2000000
	// Configured interrupt is not detected.
	PORT_ISFR_ISF25_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_ISFR_ISF25_1 = 0x1
	// Position of ISF26 field.
	PORT_ISFR_ISF26_Pos = 0x1a
	// Bit mask of ISF26 field.
	PORT_ISFR_ISF26_Msk = 0x4000000
	// Bit ISF26.
	PORT_ISFR_ISF26 = 0x4000000
	// Configured interrupt is not detected.
	PORT_ISFR_ISF26_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_ISFR_ISF26_1 = 0x1
	// Position of ISF27 field.
	PORT_ISFR_ISF27_Pos = 0x1b
	// Bit mask of ISF27 field.
	PORT_ISFR_ISF27_Msk = 0x8000000
	// Bit ISF27.
	PORT_ISFR_ISF27 = 0x8000000
	// Configured interrupt is not detected.
	PORT_ISFR_ISF27_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_ISFR_ISF27_1 = 0x1
	// Position of ISF28 field.
	PORT_ISFR_ISF28_Pos = 0x1c
	// Bit mask of ISF28 field.
	PORT_ISFR_ISF28_Msk = 0x10000000
	// Bit ISF28.
	PORT_ISFR_ISF28 = 0x10000000
	// Configured interrupt is not detected.
	PORT_ISFR_ISF28_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_ISFR_ISF28_1 = 0x1
	// Position of ISF29 field.
	PORT_ISFR_ISF29_Pos = 0x1d
	// Bit mask of ISF29 field.
	PORT_ISFR_ISF29_Msk = 0x20000000
	// Bit ISF29.
	PORT_ISFR_ISF29 = 0x20000000
	// Configured interrupt is not detected.
	PORT_ISFR_ISF29_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_ISFR_ISF29_1 = 0x1
	// Position of ISF30 field.
	PORT_ISFR_ISF30_Pos = 0x1e
	// Bit mask of ISF30 field.
	PORT_ISFR_ISF30_Msk = 0x40000000
	// Bit ISF30.
	PORT_ISFR_ISF30 = 0x40000000
	// Configured interrupt is not detected.
	PORT_ISFR_ISF30_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_ISFR_ISF30_1 = 0x1
	// Position of ISF31 field.
	PORT_ISFR_ISF31_Pos = 0x1f
	// Bit mask of ISF31 field.
	PORT_ISFR_ISF31_Msk = 0x80000000
	// Bit ISF31.
	PORT_ISFR_ISF31 = 0x80000000
	// Configured interrupt is not detected.
	PORT_ISFR_ISF31_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_ISFR_ISF31_1 = 0x1
)

// Constants for WDOG: Generation 2008 Watchdog Timer
const (
	// STCTRLH: Watchdog Status and Control Register High
	// Position of WDOGEN field.
	WDOG_STCTRLH_WDOGEN_Pos = 0x0
	// Bit mask of WDOGEN field.
	WDOG_STCTRLH_WDOGEN_Msk = 0x1
	// Bit WDOGEN.
	WDOG_STCTRLH_WDOGEN = 0x1
	// WDOG is disabled.
	WDOG_STCTRLH_WDOGEN_0 = 0x0
	// WDOG is enabled.
	WDOG_STCTRLH_WDOGEN_1 = 0x1
	// Position of CLKSRC field.
	WDOG_STCTRLH_CLKSRC_Pos = 0x1
	// Bit mask of CLKSRC field.
	WDOG_STCTRLH_CLKSRC_Msk = 0x2
	// Bit CLKSRC.
	WDOG_STCTRLH_CLKSRC = 0x2
	// WDOG clock sourced from LPO .
	WDOG_STCTRLH_CLKSRC_0 = 0x0
	// WDOG clock sourced from alternate clock source.
	WDOG_STCTRLH_CLKSRC_1 = 0x1
	// Position of IRQRSTEN field.
	WDOG_STCTRLH_IRQRSTEN_Pos = 0x2
	// Bit mask of IRQRSTEN field.
	WDOG_STCTRLH_IRQRSTEN_Msk = 0x4
	// Bit IRQRSTEN.
	WDOG_STCTRLH_IRQRSTEN = 0x4
	// WDOG time-out generates reset only.
	WDOG_STCTRLH_IRQRSTEN_0 = 0x0
	// WDOG time-out initially generates an interrupt. After WCT, it generates a reset.
	WDOG_STCTRLH_IRQRSTEN_1 = 0x1
	// Position of WINEN field.
	WDOG_STCTRLH_WINEN_Pos = 0x3
	// Bit mask of WINEN field.
	WDOG_STCTRLH_WINEN_Msk = 0x8
	// Bit WINEN.
	WDOG_STCTRLH_WINEN = 0x8
	// Windowing mode is disabled.
	WDOG_STCTRLH_WINEN_0 = 0x0
	// Windowing mode is enabled.
	WDOG_STCTRLH_WINEN_1 = 0x1
	// Position of ALLOWUPDATE field.
	WDOG_STCTRLH_ALLOWUPDATE_Pos = 0x4
	// Bit mask of ALLOWUPDATE field.
	WDOG_STCTRLH_ALLOWUPDATE_Msk = 0x10
	// Bit ALLOWUPDATE.
	WDOG_STCTRLH_ALLOWUPDATE = 0x10
	// No further updates allowed to WDOG write-once registers.
	WDOG_STCTRLH_ALLOWUPDATE_0 = 0x0
	// WDOG write-once registers can be unlocked for updating.
	WDOG_STCTRLH_ALLOWUPDATE_1 = 0x1
	// Position of DBGEN field.
	WDOG_STCTRLH_DBGEN_Pos = 0x5
	// Bit mask of DBGEN field.
	WDOG_STCTRLH_DBGEN_Msk = 0x20
	// Bit DBGEN.
	WDOG_STCTRLH_DBGEN = 0x20
	// WDOG is disabled in CPU Debug mode.
	WDOG_STCTRLH_DBGEN_0 = 0x0
	// WDOG is enabled in CPU Debug mode.
	WDOG_STCTRLH_DBGEN_1 = 0x1
	// Position of STOPEN field.
	WDOG_STCTRLH_STOPEN_Pos = 0x6
	// Bit mask of STOPEN field.
	WDOG_STCTRLH_STOPEN_Msk = 0x40
	// Bit STOPEN.
	WDOG_STCTRLH_STOPEN = 0x40
	// WDOG is disabled in CPU Stop mode.
	WDOG_STCTRLH_STOPEN_0 = 0x0
	// WDOG is enabled in CPU Stop mode.
	WDOG_STCTRLH_STOPEN_1 = 0x1
	// Position of WAITEN field.
	WDOG_STCTRLH_WAITEN_Pos = 0x7
	// Bit mask of WAITEN field.
	WDOG_STCTRLH_WAITEN_Msk = 0x80
	// Bit WAITEN.
	WDOG_STCTRLH_WAITEN = 0x80
	// WDOG is disabled in CPU Wait mode.
	WDOG_STCTRLH_WAITEN_0 = 0x0
	// WDOG is enabled in CPU Wait mode.
	WDOG_STCTRLH_WAITEN_1 = 0x1
	// Position of TESTWDOG field.
	WDOG_STCTRLH_TESTWDOG_Pos = 0xa
	// Bit mask of TESTWDOG field.
	WDOG_STCTRLH_TESTWDOG_Msk = 0x400
	// Bit TESTWDOG.
	WDOG_STCTRLH_TESTWDOG = 0x400
	// Position of TESTSEL field.
	WDOG_STCTRLH_TESTSEL_Pos = 0xb
	// Bit mask of TESTSEL field.
	WDOG_STCTRLH_TESTSEL_Msk = 0x800
	// Bit TESTSEL.
	WDOG_STCTRLH_TESTSEL = 0x800
	// Quick test. The timer runs in normal operation. You can load a small time-out value to do a quick test.
	WDOG_STCTRLH_TESTSEL_0 = 0x0
	// Byte test. Puts the timer in the byte test mode where individual bytes of the timer are enabled for operation and are compared for time-out against the corresponding byte of the programmed time-out value. Select the byte through BYTESEL[1:0] for testing.
	WDOG_STCTRLH_TESTSEL_1 = 0x1
	// Position of BYTESEL field.
	WDOG_STCTRLH_BYTESEL_Pos = 0xc
	// Bit mask of BYTESEL field.
	WDOG_STCTRLH_BYTESEL_Msk = 0x3000
	// Byte 0 selected
	WDOG_STCTRLH_BYTESEL_00 = 0x0
	// Byte 1 selected
	WDOG_STCTRLH_BYTESEL_01 = 0x1
	// Byte 2 selected
	WDOG_STCTRLH_BYTESEL_10 = 0x2
	// Byte 3 selected
	WDOG_STCTRLH_BYTESEL_11 = 0x3
	// Position of DISTESTWDOG field.
	WDOG_STCTRLH_DISTESTWDOG_Pos = 0xe
	// Bit mask of DISTESTWDOG field.
	WDOG_STCTRLH_DISTESTWDOG_Msk = 0x4000
	// Bit DISTESTWDOG.
	WDOG_STCTRLH_DISTESTWDOG = 0x4000
	// WDOG functional test mode is not disabled.
	WDOG_STCTRLH_DISTESTWDOG_0 = 0x0
	// WDOG functional test mode is disabled permanently until reset.
	WDOG_STCTRLH_DISTESTWDOG_1 = 0x1

	// STCTRLL: Watchdog Status and Control Register Low
	// Position of INTFLG field.
	WDOG_STCTRLL_INTFLG_Pos = 0xf
	// Bit mask of INTFLG field.
	WDOG_STCTRLL_INTFLG_Msk = 0x8000
	// Bit INTFLG.
	WDOG_STCTRLL_INTFLG = 0x8000

	// TOVALH: Watchdog Time-out Value Register High
	// Position of TOVALHIGH field.
	WDOG_TOVALH_TOVALHIGH_Pos = 0x0
	// Bit mask of TOVALHIGH field.
	WDOG_TOVALH_TOVALHIGH_Msk = 0xffff

	// TOVALL: Watchdog Time-out Value Register Low
	// Position of TOVALLOW field.
	WDOG_TOVALL_TOVALLOW_Pos = 0x0
	// Bit mask of TOVALLOW field.
	WDOG_TOVALL_TOVALLOW_Msk = 0xffff

	// WINH: Watchdog Window Register High
	// Position of WINHIGH field.
	WDOG_WINH_WINHIGH_Pos = 0x0
	// Bit mask of WINHIGH field.
	WDOG_WINH_WINHIGH_Msk = 0xffff

	// WINL: Watchdog Window Register Low
	// Position of WINLOW field.
	WDOG_WINL_WINLOW_Pos = 0x0
	// Bit mask of WINLOW field.
	WDOG_WINL_WINLOW_Msk = 0xffff

	// REFRESH: Watchdog Refresh register
	// Position of WDOGREFRESH field.
	WDOG_REFRESH_WDOGREFRESH_Pos = 0x0
	// Bit mask of WDOGREFRESH field.
	WDOG_REFRESH_WDOGREFRESH_Msk = 0xffff

	// UNLOCK: Watchdog Unlock register
	// Position of WDOGUNLOCK field.
	WDOG_UNLOCK_WDOGUNLOCK_Pos = 0x0
	// Bit mask of WDOGUNLOCK field.
	WDOG_UNLOCK_WDOGUNLOCK_Msk = 0xffff

	// TMROUTH: Watchdog Timer Output Register High
	// Position of TIMEROUTHIGH field.
	WDOG_TMROUTH_TIMEROUTHIGH_Pos = 0x0
	// Bit mask of TIMEROUTHIGH field.
	WDOG_TMROUTH_TIMEROUTHIGH_Msk = 0xffff

	// TMROUTL: Watchdog Timer Output Register Low
	// Position of TIMEROUTLOW field.
	WDOG_TMROUTL_TIMEROUTLOW_Pos = 0x0
	// Bit mask of TIMEROUTLOW field.
	WDOG_TMROUTL_TIMEROUTLOW_Msk = 0xffff

	// RSTCNT: Watchdog Reset Count register
	// Position of RSTCNT field.
	WDOG_RSTCNT_RSTCNT_Pos = 0x0
	// Bit mask of RSTCNT field.
	WDOG_RSTCNT_RSTCNT_Msk = 0xffff

	// PRESC: Watchdog Prescaler register
	// Position of PRESCVAL field.
	WDOG_PRESC_PRESCVAL_Pos = 0x8
	// Bit mask of PRESCVAL field.
	WDOG_PRESC_PRESCVAL_Msk = 0x700
)

// Constants for EWM: External Watchdog Monitor
const (
	// CTRL: Control Register
	// Position of EWMEN field.
	EWM_CTRL_EWMEN_Pos = 0x0
	// Bit mask of EWMEN field.
	EWM_CTRL_EWMEN_Msk = 0x1
	// Bit EWMEN.
	EWM_CTRL_EWMEN = 0x1
	// Position of ASSIN field.
	EWM_CTRL_ASSIN_Pos = 0x1
	// Bit mask of ASSIN field.
	EWM_CTRL_ASSIN_Msk = 0x2
	// Bit ASSIN.
	EWM_CTRL_ASSIN = 0x2
	// Position of INEN field.
	EWM_CTRL_INEN_Pos = 0x2
	// Bit mask of INEN field.
	EWM_CTRL_INEN_Msk = 0x4
	// Bit INEN.
	EWM_CTRL_INEN = 0x4
	// Position of INTEN field.
	EWM_CTRL_INTEN_Pos = 0x3
	// Bit mask of INTEN field.
	EWM_CTRL_INTEN_Msk = 0x8
	// Bit INTEN.
	EWM_CTRL_INTEN = 0x8

	// SERV: Service Register
	// Position of SERVICE field.
	EWM_SERV_SERVICE_Pos = 0x0
	// Bit mask of SERVICE field.
	EWM_SERV_SERVICE_Msk = 0xff

	// CMPL: Compare Low Register
	// Position of COMPAREL field.
	EWM_CMPL_COMPAREL_Pos = 0x0
	// Bit mask of COMPAREL field.
	EWM_CMPL_COMPAREL_Msk = 0xff

	// CMPH: Compare High Register
	// Position of COMPAREH field.
	EWM_CMPH_COMPAREH_Pos = 0x0
	// Bit mask of COMPAREH field.
	EWM_CMPH_COMPAREH_Msk = 0xff
)

// Constants for CMT: Carrier Modulator Transmitter
const (
	// CGH1: CMT Carrier Generator High Data Register 1
	// Position of PH field.
	CMT_CGH1_PH_Pos = 0x0
	// Bit mask of PH field.
	CMT_CGH1_PH_Msk = 0xff

	// CGL1: CMT Carrier Generator Low Data Register 1
	// Position of PL field.
	CMT_CGL1_PL_Pos = 0x0
	// Bit mask of PL field.
	CMT_CGL1_PL_Msk = 0xff

	// CGH2: CMT Carrier Generator High Data Register 2
	// Position of SH field.
	CMT_CGH2_SH_Pos = 0x0
	// Bit mask of SH field.
	CMT_CGH2_SH_Msk = 0xff

	// CGL2: CMT Carrier Generator Low Data Register 2
	// Position of SL field.
	CMT_CGL2_SL_Pos = 0x0
	// Bit mask of SL field.
	CMT_CGL2_SL_Msk = 0xff

	// OC: CMT Output Control Register
	// Position of IROPEN field.
	CMT_OC_IROPEN_Pos = 0x5
	// Bit mask of IROPEN field.
	CMT_OC_IROPEN_Msk = 0x20
	// Bit IROPEN.
	CMT_OC_IROPEN = 0x20
	// The IRO signal is disabled.
	CMT_OC_IROPEN_0 = 0x0
	// The IRO signal is enabled as output.
	CMT_OC_IROPEN_1 = 0x1
	// Position of CMTPOL field.
	CMT_OC_CMTPOL_Pos = 0x6
	// Bit mask of CMTPOL field.
	CMT_OC_CMTPOL_Msk = 0x40
	// Bit CMTPOL.
	CMT_OC_CMTPOL = 0x40
	// The IRO signal is active-low.
	CMT_OC_CMTPOL_0 = 0x0
	// The IRO signal is active-high.
	CMT_OC_CMTPOL_1 = 0x1
	// Position of IROL field.
	CMT_OC_IROL_Pos = 0x7
	// Bit mask of IROL field.
	CMT_OC_IROL_Msk = 0x80
	// Bit IROL.
	CMT_OC_IROL = 0x80

	// MSC: CMT Modulator Status and Control Register
	// Position of MCGEN field.
	CMT_MSC_MCGEN_Pos = 0x0
	// Bit mask of MCGEN field.
	CMT_MSC_MCGEN_Msk = 0x1
	// Bit MCGEN.
	CMT_MSC_MCGEN = 0x1
	// Modulator and carrier generator disabled
	CMT_MSC_MCGEN_0 = 0x0
	// Modulator and carrier generator enabled
	CMT_MSC_MCGEN_1 = 0x1
	// Position of EOCIE field.
	CMT_MSC_EOCIE_Pos = 0x1
	// Bit mask of EOCIE field.
	CMT_MSC_EOCIE_Msk = 0x2
	// Bit EOCIE.
	CMT_MSC_EOCIE = 0x2
	// CPU interrupt is disabled.
	CMT_MSC_EOCIE_0 = 0x0
	// CPU interrupt is enabled.
	CMT_MSC_EOCIE_1 = 0x1
	// Position of FSK field.
	CMT_MSC_FSK_Pos = 0x2
	// Bit mask of FSK field.
	CMT_MSC_FSK_Msk = 0x4
	// Bit FSK.
	CMT_MSC_FSK = 0x4
	// The CMT operates in Time or Baseband mode.
	CMT_MSC_FSK_0 = 0x0
	// The CMT operates in FSK mode.
	CMT_MSC_FSK_1 = 0x1
	// Position of BASE field.
	CMT_MSC_BASE_Pos = 0x3
	// Bit mask of BASE field.
	CMT_MSC_BASE_Msk = 0x8
	// Bit BASE.
	CMT_MSC_BASE = 0x8
	// Baseband mode is disabled.
	CMT_MSC_BASE_0 = 0x0
	// Baseband mode is enabled.
	CMT_MSC_BASE_1 = 0x1
	// Position of EXSPC field.
	CMT_MSC_EXSPC_Pos = 0x4
	// Bit mask of EXSPC field.
	CMT_MSC_EXSPC_Msk = 0x10
	// Bit EXSPC.
	CMT_MSC_EXSPC = 0x10
	// Extended space is disabled.
	CMT_MSC_EXSPC_0 = 0x0
	// Extended space is enabled.
	CMT_MSC_EXSPC_1 = 0x1
	// Position of CMTDIV field.
	CMT_MSC_CMTDIV_Pos = 0x5
	// Bit mask of CMTDIV field.
	CMT_MSC_CMTDIV_Msk = 0x60
	// IF * 1
	CMT_MSC_CMTDIV_00 = 0x0
	// IF * 2
	CMT_MSC_CMTDIV_01 = 0x1
	// IF * 4
	CMT_MSC_CMTDIV_10 = 0x2
	// IF * 8
	CMT_MSC_CMTDIV_11 = 0x3
	// Position of EOCF field.
	CMT_MSC_EOCF_Pos = 0x7
	// Bit mask of EOCF field.
	CMT_MSC_EOCF_Msk = 0x80
	// Bit EOCF.
	CMT_MSC_EOCF = 0x80
	// End of modulation cycle has not occurred since the flag last cleared.
	CMT_MSC_EOCF_0 = 0x0
	// End of modulator cycle has occurred.
	CMT_MSC_EOCF_1 = 0x1

	// CMD1: CMT Modulator Data Register Mark High
	// Position of MB field.
	CMT_CMD1_MB_Pos = 0x0
	// Bit mask of MB field.
	CMT_CMD1_MB_Msk = 0xff

	// CMD2: CMT Modulator Data Register Mark Low
	// Position of MB field.
	CMT_CMD2_MB_Pos = 0x0
	// Bit mask of MB field.
	CMT_CMD2_MB_Msk = 0xff

	// CMD3: CMT Modulator Data Register Space High
	// Position of SB field.
	CMT_CMD3_SB_Pos = 0x0
	// Bit mask of SB field.
	CMT_CMD3_SB_Msk = 0xff

	// CMD4: CMT Modulator Data Register Space Low
	// Position of SB field.
	CMT_CMD4_SB_Pos = 0x0
	// Bit mask of SB field.
	CMT_CMD4_SB_Msk = 0xff

	// PPS: CMT Primary Prescaler Register
	// Position of PPSDIV field.
	CMT_PPS_PPSDIV_Pos = 0x0
	// Bit mask of PPSDIV field.
	CMT_PPS_PPSDIV_Msk = 0xf
	// Bus clock * 1
	CMT_PPS_PPSDIV_0000 = 0x0
	// Bus clock * 2
	CMT_PPS_PPSDIV_0001 = 0x1
	// Bus clock * 3
	CMT_PPS_PPSDIV_0010 = 0x2
	// Bus clock * 4
	CMT_PPS_PPSDIV_0011 = 0x3
	// Bus clock * 5
	CMT_PPS_PPSDIV_0100 = 0x4
	// Bus clock * 6
	CMT_PPS_PPSDIV_0101 = 0x5
	// Bus clock * 7
	CMT_PPS_PPSDIV_0110 = 0x6
	// Bus clock * 8
	CMT_PPS_PPSDIV_0111 = 0x7
	// Bus clock * 9
	CMT_PPS_PPSDIV_1000 = 0x8
	// Bus clock * 10
	CMT_PPS_PPSDIV_1001 = 0x9
	// Bus clock * 11
	CMT_PPS_PPSDIV_1010 = 0xa
	// Bus clock * 12
	CMT_PPS_PPSDIV_1011 = 0xb
	// Bus clock * 13
	CMT_PPS_PPSDIV_1100 = 0xc
	// Bus clock * 14
	CMT_PPS_PPSDIV_1101 = 0xd
	// Bus clock * 15
	CMT_PPS_PPSDIV_1110 = 0xe
	// Bus clock * 16
	CMT_PPS_PPSDIV_1111 = 0xf

	// DMA: CMT Direct Memory Access Register
	// Position of DMA field.
	CMT_DMA_DMA_Pos = 0x0
	// Bit mask of DMA field.
	CMT_DMA_DMA_Msk = 0x1
	// Bit DMA.
	CMT_DMA_DMA = 0x1
	// DMA transfer request and done are disabled.
	CMT_DMA_DMA_0 = 0x0
	// DMA transfer request and done are enabled.
	CMT_DMA_DMA_1 = 0x1
)

// Constants for MCG: Multipurpose Clock Generator module
const (
	// C1: MCG Control 1 Register
	// Position of IREFSTEN field.
	MCG_C1_IREFSTEN_Pos = 0x0
	// Bit mask of IREFSTEN field.
	MCG_C1_IREFSTEN_Msk = 0x1
	// Bit IREFSTEN.
	MCG_C1_IREFSTEN = 0x1
	// Internal reference clock is disabled in Stop mode.
	MCG_C1_IREFSTEN_0 = 0x0
	// Internal reference clock is enabled in Stop mode if IRCLKEN is set or if MCG is in FEI, FBI, or BLPI modes before entering Stop mode.
	MCG_C1_IREFSTEN_1 = 0x1
	// Position of IRCLKEN field.
	MCG_C1_IRCLKEN_Pos = 0x1
	// Bit mask of IRCLKEN field.
	MCG_C1_IRCLKEN_Msk = 0x2
	// Bit IRCLKEN.
	MCG_C1_IRCLKEN = 0x2
	// MCGIRCLK inactive.
	MCG_C1_IRCLKEN_0 = 0x0
	// MCGIRCLK active.
	MCG_C1_IRCLKEN_1 = 0x1
	// Position of IREFS field.
	MCG_C1_IREFS_Pos = 0x2
	// Bit mask of IREFS field.
	MCG_C1_IREFS_Msk = 0x4
	// Bit IREFS.
	MCG_C1_IREFS = 0x4
	// External reference clock is selected.
	MCG_C1_IREFS_0 = 0x0
	// The slow internal reference clock is selected.
	MCG_C1_IREFS_1 = 0x1
	// Position of FRDIV field.
	MCG_C1_FRDIV_Pos = 0x3
	// Bit mask of FRDIV field.
	MCG_C1_FRDIV_Msk = 0x38
	// If RANGE = 0 or OSCSEL=1 , Divide Factor is 1; for all other RANGE values, Divide Factor is 32.
	MCG_C1_FRDIV_000 = 0x0
	// If RANGE = 0 or OSCSEL=1 , Divide Factor is 2; for all other RANGE values, Divide Factor is 64.
	MCG_C1_FRDIV_001 = 0x1
	// If RANGE = 0 or OSCSEL=1 , Divide Factor is 4; for all other RANGE values, Divide Factor is 128.
	MCG_C1_FRDIV_010 = 0x2
	// If RANGE = 0 or OSCSEL=1 , Divide Factor is 8; for all other RANGE values, Divide Factor is 256.
	MCG_C1_FRDIV_011 = 0x3
	// If RANGE = 0 or OSCSEL=1 , Divide Factor is 16; for all other RANGE values, Divide Factor is 512.
	MCG_C1_FRDIV_100 = 0x4
	// If RANGE = 0 or OSCSEL=1 , Divide Factor is 32; for all other RANGE values, Divide Factor is 1024.
	MCG_C1_FRDIV_101 = 0x5
	// If RANGE = 0 or OSCSEL=1 , Divide Factor is 64; for all other RANGE values, Divide Factor is 1280 .
	MCG_C1_FRDIV_110 = 0x6
	// If RANGE = 0 or OSCSEL=1 , Divide Factor is 128; for all other RANGE values, Divide Factor is 1536 .
	MCG_C1_FRDIV_111 = 0x7
	// Position of CLKS field.
	MCG_C1_CLKS_Pos = 0x6
	// Bit mask of CLKS field.
	MCG_C1_CLKS_Msk = 0xc0
	// Encoding 0 - Output of FLL or PLL is selected (depends on PLLS control bit).
	MCG_C1_CLKS_00 = 0x0
	// Encoding 1 - Internal reference clock is selected.
	MCG_C1_CLKS_01 = 0x1
	// Encoding 2 - External reference clock is selected.
	MCG_C1_CLKS_10 = 0x2
	// Encoding 3 - Reserved.
	MCG_C1_CLKS_11 = 0x3

	// C2: MCG Control 2 Register
	// Position of IRCS field.
	MCG_C2_IRCS_Pos = 0x0
	// Bit mask of IRCS field.
	MCG_C2_IRCS_Msk = 0x1
	// Bit IRCS.
	MCG_C2_IRCS = 0x1
	// Slow internal reference clock selected.
	MCG_C2_IRCS_0 = 0x0
	// Fast internal reference clock selected.
	MCG_C2_IRCS_1 = 0x1
	// Position of LP field.
	MCG_C2_LP_Pos = 0x1
	// Bit mask of LP field.
	MCG_C2_LP_Msk = 0x2
	// Bit LP.
	MCG_C2_LP = 0x2
	// FLL or PLL is not disabled in bypass modes.
	MCG_C2_LP_0 = 0x0
	// FLL or PLL is disabled in bypass modes (lower power)
	MCG_C2_LP_1 = 0x1
	// Position of EREFS field.
	MCG_C2_EREFS_Pos = 0x2
	// Bit mask of EREFS field.
	MCG_C2_EREFS_Msk = 0x4
	// Bit EREFS.
	MCG_C2_EREFS = 0x4
	// External reference clock requested.
	MCG_C2_EREFS_0 = 0x0
	// Oscillator requested.
	MCG_C2_EREFS_1 = 0x1
	// Position of HGO field.
	MCG_C2_HGO_Pos = 0x3
	// Bit mask of HGO field.
	MCG_C2_HGO_Msk = 0x8
	// Bit HGO.
	MCG_C2_HGO = 0x8
	// Configure crystal oscillator for low-power operation.
	MCG_C2_HGO_0 = 0x0
	// Configure crystal oscillator for high-gain operation.
	MCG_C2_HGO_1 = 0x1
	// Position of RANGE field.
	MCG_C2_RANGE_Pos = 0x4
	// Bit mask of RANGE field.
	MCG_C2_RANGE_Msk = 0x30
	// Encoding 0 - Low frequency range selected for the crystal oscillator .
	MCG_C2_RANGE_00 = 0x0
	// Encoding 1 - High frequency range selected for the crystal oscillator .
	MCG_C2_RANGE_01 = 0x1
	// Position of FCFTRIM field.
	MCG_C2_FCFTRIM_Pos = 0x6
	// Bit mask of FCFTRIM field.
	MCG_C2_FCFTRIM_Msk = 0x40
	// Bit FCFTRIM.
	MCG_C2_FCFTRIM = 0x40
	// Position of LOCRE0 field.
	MCG_C2_LOCRE0_Pos = 0x7
	// Bit mask of LOCRE0 field.
	MCG_C2_LOCRE0_Msk = 0x80
	// Bit LOCRE0.
	MCG_C2_LOCRE0 = 0x80
	// Interrupt request is generated on a loss of OSC0 external reference clock.
	MCG_C2_LOCRE0_0 = 0x0
	// Generate a reset request on a loss of OSC0 external reference clock.
	MCG_C2_LOCRE0_1 = 0x1

	// C3: MCG Control 3 Register
	// Position of SCTRIM field.
	MCG_C3_SCTRIM_Pos = 0x0
	// Bit mask of SCTRIM field.
	MCG_C3_SCTRIM_Msk = 0xff

	// C4: MCG Control 4 Register
	// Position of SCFTRIM field.
	MCG_C4_SCFTRIM_Pos = 0x0
	// Bit mask of SCFTRIM field.
	MCG_C4_SCFTRIM_Msk = 0x1
	// Bit SCFTRIM.
	MCG_C4_SCFTRIM = 0x1
	// Position of FCTRIM field.
	MCG_C4_FCTRIM_Pos = 0x1
	// Bit mask of FCTRIM field.
	MCG_C4_FCTRIM_Msk = 0x1e
	// Position of DRST_DRS field.
	MCG_C4_DRST_DRS_Pos = 0x5
	// Bit mask of DRST_DRS field.
	MCG_C4_DRST_DRS_Msk = 0x60
	// Encoding 0 - Low range (reset default).
	MCG_C4_DRST_DRS_00 = 0x0
	// Encoding 1 - Mid range.
	MCG_C4_DRST_DRS_01 = 0x1
	// Encoding 2 - Mid-high range.
	MCG_C4_DRST_DRS_10 = 0x2
	// Encoding 3 - High range.
	MCG_C4_DRST_DRS_11 = 0x3
	// Position of DMX32 field.
	MCG_C4_DMX32_Pos = 0x7
	// Bit mask of DMX32 field.
	MCG_C4_DMX32_Msk = 0x80
	// Bit DMX32.
	MCG_C4_DMX32 = 0x80
	// DCO has a default range of 25%.
	MCG_C4_DMX32_0 = 0x0
	// DCO is fine-tuned for maximum frequency with 32.768 kHz reference.
	MCG_C4_DMX32_1 = 0x1

	// C5: MCG Control 5 Register
	// Position of PRDIV0 field.
	MCG_C5_PRDIV0_Pos = 0x0
	// Bit mask of PRDIV0 field.
	MCG_C5_PRDIV0_Msk = 0x1f
	// Divide Factor is 1
	MCG_C5_PRDIV0_0 = 0x0
	// Divide Factor is 2
	MCG_C5_PRDIV0_1 = 0x1
	// Divide Factor is 3
	MCG_C5_PRDIV0_2 = 0x2
	// Divide Factor is 4
	MCG_C5_PRDIV0_3 = 0x3
	// Divide Factor is 5
	MCG_C5_PRDIV0_4 = 0x4
	// Divide Factor is 6
	MCG_C5_PRDIV0_5 = 0x5
	// Divide Factor is 7
	MCG_C5_PRDIV0_6 = 0x6
	// Divide Factor is 8
	MCG_C5_PRDIV0_7 = 0x7
	// Divide Factor is 9
	MCG_C5_PRDIV0_8 = 0x8
	// Divide Factor is 10
	MCG_C5_PRDIV0_9 = 0x9
	// Divide Factor is 11
	MCG_C5_PRDIV0_10 = 0xa
	// Divide Factor is 12
	MCG_C5_PRDIV0_11 = 0xb
	// Divide Factor is 13
	MCG_C5_PRDIV0_12 = 0xc
	// Divide Factor is 14
	MCG_C5_PRDIV0_13 = 0xd
	// Divide Factor is 15
	MCG_C5_PRDIV0_14 = 0xe
	// Divide Factor is 16
	MCG_C5_PRDIV0_15 = 0xf
	// Divide Factor is 17
	MCG_C5_PRDIV0_16 = 0x10
	// Divide Factor is 18
	MCG_C5_PRDIV0_17 = 0x11
	// Divide Factor is 19
	MCG_C5_PRDIV0_18 = 0x12
	// Divide Factor is 20
	MCG_C5_PRDIV0_19 = 0x13
	// Divide Factor is 21
	MCG_C5_PRDIV0_20 = 0x14
	// Divide Factor is 22
	MCG_C5_PRDIV0_21 = 0x15
	// Divide Factor is 23
	MCG_C5_PRDIV0_22 = 0x16
	// Divide Factor is 24
	MCG_C5_PRDIV0_23 = 0x17
	// Divide Factor is 25
	MCG_C5_PRDIV0_24 = 0x18
	// Divide Factor is 26
	MCG_C5_PRDIV0_25 = 0x19
	// Divide Factor is 27
	MCG_C5_PRDIV0_26 = 0x1a
	// Divide Factor is 28
	MCG_C5_PRDIV0_27 = 0x1b
	// Divide Factor is 29
	MCG_C5_PRDIV0_28 = 0x1c
	// Divide Factor is 30
	MCG_C5_PRDIV0_29 = 0x1d
	// Divide Factor is 31
	MCG_C5_PRDIV0_30 = 0x1e
	// Divide Factor is 32
	MCG_C5_PRDIV0_31 = 0x1f
	// Position of PLLSTEN0 field.
	MCG_C5_PLLSTEN0_Pos = 0x5
	// Bit mask of PLLSTEN0 field.
	MCG_C5_PLLSTEN0_Msk = 0x20
	// Bit PLLSTEN0.
	MCG_C5_PLLSTEN0 = 0x20
	// MCGPLLCLK is disabled in any of the Stop modes.
	MCG_C5_PLLSTEN0_0 = 0x0
	// MCGPLLCLK is enabled if system is in Normal Stop mode.
	MCG_C5_PLLSTEN0_1 = 0x1
	// Position of PLLCLKEN0 field.
	MCG_C5_PLLCLKEN0_Pos = 0x6
	// Bit mask of PLLCLKEN0 field.
	MCG_C5_PLLCLKEN0_Msk = 0x40
	// Bit PLLCLKEN0.
	MCG_C5_PLLCLKEN0 = 0x40
	// MCGPLLCLK is inactive.
	MCG_C5_PLLCLKEN0_0 = 0x0
	// MCGPLLCLK is active.
	MCG_C5_PLLCLKEN0_1 = 0x1

	// C6: MCG Control 6 Register
	// Position of VDIV0 field.
	MCG_C6_VDIV0_Pos = 0x0
	// Bit mask of VDIV0 field.
	MCG_C6_VDIV0_Msk = 0x1f
	// Multiply Factor is 24
	MCG_C6_VDIV0_0 = 0x0
	// Multiply Factor is 25
	MCG_C6_VDIV0_1 = 0x1
	// Multiply Factor is 26
	MCG_C6_VDIV0_2 = 0x2
	// Multiply Factor is 27
	MCG_C6_VDIV0_3 = 0x3
	// Multiply Factor is 28
	MCG_C6_VDIV0_4 = 0x4
	// Multiply Factor is 29
	MCG_C6_VDIV0_5 = 0x5
	// Multiply Factor is 30
	MCG_C6_VDIV0_6 = 0x6
	// Multiply Factor is 31
	MCG_C6_VDIV0_7 = 0x7
	// Multiply Factor is 32
	MCG_C6_VDIV0_8 = 0x8
	// Multiply Factor is 33
	MCG_C6_VDIV0_9 = 0x9
	// Multiply Factor is 34
	MCG_C6_VDIV0_10 = 0xa
	// Multiply Factor is 35
	MCG_C6_VDIV0_11 = 0xb
	// Multiply Factor is 36
	MCG_C6_VDIV0_12 = 0xc
	// Multiply Factor is 37
	MCG_C6_VDIV0_13 = 0xd
	// Multiply Factor is 38
	MCG_C6_VDIV0_14 = 0xe
	// Multiply Factor is 39
	MCG_C6_VDIV0_15 = 0xf
	// Multiply Factor is 40
	MCG_C6_VDIV0_16 = 0x10
	// Multiply Factor is 41
	MCG_C6_VDIV0_17 = 0x11
	// Multiply Factor is 42
	MCG_C6_VDIV0_18 = 0x12
	// Multiply Factor is 43
	MCG_C6_VDIV0_19 = 0x13
	// Multiply Factor is 44
	MCG_C6_VDIV0_20 = 0x14
	// Multiply Factor is 45
	MCG_C6_VDIV0_21 = 0x15
	// Multiply Factor is 46
	MCG_C6_VDIV0_22 = 0x16
	// Multiply Factor is 47
	MCG_C6_VDIV0_23 = 0x17
	// Multiply Factor is 48
	MCG_C6_VDIV0_24 = 0x18
	// Multiply Factor is 49
	MCG_C6_VDIV0_25 = 0x19
	// Multiply Factor is 50
	MCG_C6_VDIV0_26 = 0x1a
	// Multiply Factor is 51
	MCG_C6_VDIV0_27 = 0x1b
	// Multiply Factor is 52
	MCG_C6_VDIV0_28 = 0x1c
	// Multiply Factor is 53
	MCG_C6_VDIV0_29 = 0x1d
	// Multiply Factor is 54
	MCG_C6_VDIV0_30 = 0x1e
	// Multiply Factor is 55
	MCG_C6_VDIV0_31 = 0x1f
	// Position of CME0 field.
	MCG_C6_CME0_Pos = 0x5
	// Bit mask of CME0 field.
	MCG_C6_CME0_Msk = 0x20
	// Bit CME0.
	MCG_C6_CME0 = 0x20
	// External clock monitor is disabled for OSC0.
	MCG_C6_CME0_0 = 0x0
	// External clock monitor is enabled for OSC0.
	MCG_C6_CME0_1 = 0x1
	// Position of PLLS field.
	MCG_C6_PLLS_Pos = 0x6
	// Bit mask of PLLS field.
	MCG_C6_PLLS_Msk = 0x40
	// Bit PLLS.
	MCG_C6_PLLS = 0x40
	// FLL is selected.
	MCG_C6_PLLS_0 = 0x0
	// PLL is selected (PRDIV 0 need to be programmed to the correct divider to generate a PLL reference clock in the range of 2-4 MHz prior to setting the PLLS bit).
	MCG_C6_PLLS_1 = 0x1
	// Position of LOLIE0 field.
	MCG_C6_LOLIE0_Pos = 0x7
	// Bit mask of LOLIE0 field.
	MCG_C6_LOLIE0_Msk = 0x80
	// Bit LOLIE0.
	MCG_C6_LOLIE0 = 0x80
	// No interrupt request is generated on loss of lock.
	MCG_C6_LOLIE0_0 = 0x0
	// Generate an interrupt request on loss of lock.
	MCG_C6_LOLIE0_1 = 0x1

	// S: MCG Status Register
	// Position of IRCST field.
	MCG_S_IRCST_Pos = 0x0
	// Bit mask of IRCST field.
	MCG_S_IRCST_Msk = 0x1
	// Bit IRCST.
	MCG_S_IRCST = 0x1
	// Source of internal reference clock is the slow clock (32 kHz IRC).
	MCG_S_IRCST_0 = 0x0
	// Source of internal reference clock is the fast clock (4 MHz IRC).
	MCG_S_IRCST_1 = 0x1
	// Position of OSCINIT0 field.
	MCG_S_OSCINIT0_Pos = 0x1
	// Bit mask of OSCINIT0 field.
	MCG_S_OSCINIT0_Msk = 0x2
	// Bit OSCINIT0.
	MCG_S_OSCINIT0 = 0x2
	// Position of CLKST field.
	MCG_S_CLKST_Pos = 0x2
	// Bit mask of CLKST field.
	MCG_S_CLKST_Msk = 0xc
	// Encoding 0 - Output of the FLL is selected (reset default).
	MCG_S_CLKST_00 = 0x0
	// Encoding 1 - Internal reference clock is selected.
	MCG_S_CLKST_01 = 0x1
	// Encoding 2 - External reference clock is selected.
	MCG_S_CLKST_10 = 0x2
	// Encoding 3 - Output of the PLL is selected.
	MCG_S_CLKST_11 = 0x3
	// Position of IREFST field.
	MCG_S_IREFST_Pos = 0x4
	// Bit mask of IREFST field.
	MCG_S_IREFST_Msk = 0x10
	// Bit IREFST.
	MCG_S_IREFST = 0x10
	// Source of FLL reference clock is the external reference clock.
	MCG_S_IREFST_0 = 0x0
	// Source of FLL reference clock is the internal reference clock.
	MCG_S_IREFST_1 = 0x1
	// Position of PLLST field.
	MCG_S_PLLST_Pos = 0x5
	// Bit mask of PLLST field.
	MCG_S_PLLST_Msk = 0x20
	// Bit PLLST.
	MCG_S_PLLST = 0x20
	// Source of PLLS clock is FLL clock.
	MCG_S_PLLST_0 = 0x0
	// Source of PLLS clock is PLL output clock.
	MCG_S_PLLST_1 = 0x1
	// Position of LOCK0 field.
	MCG_S_LOCK0_Pos = 0x6
	// Bit mask of LOCK0 field.
	MCG_S_LOCK0_Msk = 0x40
	// Bit LOCK0.
	MCG_S_LOCK0 = 0x40
	// PLL is currently unlocked.
	MCG_S_LOCK0_0 = 0x0
	// PLL is currently locked.
	MCG_S_LOCK0_1 = 0x1
	// Position of LOLS0 field.
	MCG_S_LOLS0_Pos = 0x7
	// Bit mask of LOLS0 field.
	MCG_S_LOLS0_Msk = 0x80
	// Bit LOLS0.
	MCG_S_LOLS0 = 0x80
	// PLL has not lost lock since LOLS 0 was last cleared.
	MCG_S_LOLS0_0 = 0x0
	// PLL has lost lock since LOLS 0 was last cleared.
	MCG_S_LOLS0_1 = 0x1

	// SC: MCG Status and Control Register
	// Position of LOCS0 field.
	MCG_SC_LOCS0_Pos = 0x0
	// Bit mask of LOCS0 field.
	MCG_SC_LOCS0_Msk = 0x1
	// Bit LOCS0.
	MCG_SC_LOCS0 = 0x1
	// Loss of OSC0 has not occurred.
	MCG_SC_LOCS0_0 = 0x0
	// Loss of OSC0 has occurred.
	MCG_SC_LOCS0_1 = 0x1
	// Position of FCRDIV field.
	MCG_SC_FCRDIV_Pos = 0x1
	// Bit mask of FCRDIV field.
	MCG_SC_FCRDIV_Msk = 0xe
	// Divide Factor is 1
	MCG_SC_FCRDIV_000 = 0x0
	// Divide Factor is 2.
	MCG_SC_FCRDIV_001 = 0x1
	// Divide Factor is 4.
	MCG_SC_FCRDIV_010 = 0x2
	// Divide Factor is 8.
	MCG_SC_FCRDIV_011 = 0x3
	// Divide Factor is 16
	MCG_SC_FCRDIV_100 = 0x4
	// Divide Factor is 32
	MCG_SC_FCRDIV_101 = 0x5
	// Divide Factor is 64
	MCG_SC_FCRDIV_110 = 0x6
	// Divide Factor is 128.
	MCG_SC_FCRDIV_111 = 0x7
	// Position of FLTPRSRV field.
	MCG_SC_FLTPRSRV_Pos = 0x4
	// Bit mask of FLTPRSRV field.
	MCG_SC_FLTPRSRV_Msk = 0x10
	// Bit FLTPRSRV.
	MCG_SC_FLTPRSRV = 0x10
	// FLL filter and FLL frequency will reset on changes to currect clock mode.
	MCG_SC_FLTPRSRV_0 = 0x0
	// Fll filter and FLL frequency retain their previous values during new clock mode change.
	MCG_SC_FLTPRSRV_1 = 0x1
	// Position of ATMF field.
	MCG_SC_ATMF_Pos = 0x5
	// Bit mask of ATMF field.
	MCG_SC_ATMF_Msk = 0x20
	// Bit ATMF.
	MCG_SC_ATMF = 0x20
	// Automatic Trim Machine completed normally.
	MCG_SC_ATMF_0 = 0x0
	// Automatic Trim Machine failed.
	MCG_SC_ATMF_1 = 0x1
	// Position of ATMS field.
	MCG_SC_ATMS_Pos = 0x6
	// Bit mask of ATMS field.
	MCG_SC_ATMS_Msk = 0x40
	// Bit ATMS.
	MCG_SC_ATMS = 0x40
	// 32 kHz Internal Reference Clock selected.
	MCG_SC_ATMS_0 = 0x0
	// 4 MHz Internal Reference Clock selected.
	MCG_SC_ATMS_1 = 0x1
	// Position of ATME field.
	MCG_SC_ATME_Pos = 0x7
	// Bit mask of ATME field.
	MCG_SC_ATME_Msk = 0x80
	// Bit ATME.
	MCG_SC_ATME = 0x80
	// Auto Trim Machine disabled.
	MCG_SC_ATME_0 = 0x0
	// Auto Trim Machine enabled.
	MCG_SC_ATME_1 = 0x1

	// ATCVH: MCG Auto Trim Compare Value High Register
	// Position of ATCVH field.
	MCG_ATCVH_ATCVH_Pos = 0x0
	// Bit mask of ATCVH field.
	MCG_ATCVH_ATCVH_Msk = 0xff

	// ATCVL: MCG Auto Trim Compare Value Low Register
	// Position of ATCVL field.
	MCG_ATCVL_ATCVL_Pos = 0x0
	// Bit mask of ATCVL field.
	MCG_ATCVL_ATCVL_Msk = 0xff

	// C7: MCG Control 7 Register
	// Position of OSCSEL field.
	MCG_C7_OSCSEL_Pos = 0x0
	// Bit mask of OSCSEL field.
	MCG_C7_OSCSEL_Msk = 0x3
	// Selects Oscillator (OSCCLK0).
	MCG_C7_OSCSEL_00 = 0x0
	// Selects 32 kHz RTC Oscillator.
	MCG_C7_OSCSEL_01 = 0x1
	// Selects Oscillator (OSCCLK1).
	MCG_C7_OSCSEL_10 = 0x2

	// C8: MCG Control 8 Register
	// Position of LOCS1 field.
	MCG_C8_LOCS1_Pos = 0x0
	// Bit mask of LOCS1 field.
	MCG_C8_LOCS1_Msk = 0x1
	// Bit LOCS1.
	MCG_C8_LOCS1 = 0x1
	// Loss of RTC has not occur.
	MCG_C8_LOCS1_0 = 0x0
	// Loss of RTC has occur
	MCG_C8_LOCS1_1 = 0x1
	// Position of CME1 field.
	MCG_C8_CME1_Pos = 0x5
	// Bit mask of CME1 field.
	MCG_C8_CME1_Msk = 0x20
	// Bit CME1.
	MCG_C8_CME1 = 0x20
	// External clock monitor is disabled for RTC clock.
	MCG_C8_CME1_0 = 0x0
	// External clock monitor is enabled for RTC clock.
	MCG_C8_CME1_1 = 0x1
	// Position of LOLRE field.
	MCG_C8_LOLRE_Pos = 0x6
	// Bit mask of LOLRE field.
	MCG_C8_LOLRE_Msk = 0x40
	// Bit LOLRE.
	MCG_C8_LOLRE = 0x40
	// Interrupt request is generated on a PLL loss of lock indication. The PLL loss of lock interrupt enable bit must also be set to generate the interrupt request.
	MCG_C8_LOLRE_0 = 0x0
	// Generate a reset request on a PLL loss of lock indication.
	MCG_C8_LOLRE_1 = 0x1
	// Position of LOCRE1 field.
	MCG_C8_LOCRE1_Pos = 0x7
	// Bit mask of LOCRE1 field.
	MCG_C8_LOCRE1_Msk = 0x80
	// Bit LOCRE1.
	MCG_C8_LOCRE1 = 0x80
	// Interrupt request is generated on a loss of RTC external reference clock.
	MCG_C8_LOCRE1_0 = 0x0
	// Generate a reset request on a loss of RTC external reference clock
	MCG_C8_LOCRE1_1 = 0x1
)

// Constants for OSC: Oscillator
const (
	// CR: OSC Control Register
	// Position of SC16P field.
	OSC_CR_SC16P_Pos = 0x0
	// Bit mask of SC16P field.
	OSC_CR_SC16P_Msk = 0x1
	// Bit SC16P.
	OSC_CR_SC16P = 0x1
	// Disable the selection.
	OSC_CR_SC16P_0 = 0x0
	// Add 16 pF capacitor to the oscillator load.
	OSC_CR_SC16P_1 = 0x1
	// Position of SC8P field.
	OSC_CR_SC8P_Pos = 0x1
	// Bit mask of SC8P field.
	OSC_CR_SC8P_Msk = 0x2
	// Bit SC8P.
	OSC_CR_SC8P = 0x2
	// Disable the selection.
	OSC_CR_SC8P_0 = 0x0
	// Add 8 pF capacitor to the oscillator load.
	OSC_CR_SC8P_1 = 0x1
	// Position of SC4P field.
	OSC_CR_SC4P_Pos = 0x2
	// Bit mask of SC4P field.
	OSC_CR_SC4P_Msk = 0x4
	// Bit SC4P.
	OSC_CR_SC4P = 0x4
	// Disable the selection.
	OSC_CR_SC4P_0 = 0x0
	// Add 4 pF capacitor to the oscillator load.
	OSC_CR_SC4P_1 = 0x1
	// Position of SC2P field.
	OSC_CR_SC2P_Pos = 0x3
	// Bit mask of SC2P field.
	OSC_CR_SC2P_Msk = 0x8
	// Bit SC2P.
	OSC_CR_SC2P = 0x8
	// Disable the selection.
	OSC_CR_SC2P_0 = 0x0
	// Add 2 pF capacitor to the oscillator load.
	OSC_CR_SC2P_1 = 0x1
	// Position of EREFSTEN field.
	OSC_CR_EREFSTEN_Pos = 0x5
	// Bit mask of EREFSTEN field.
	OSC_CR_EREFSTEN_Msk = 0x20
	// Bit EREFSTEN.
	OSC_CR_EREFSTEN = 0x20
	// External reference clock is disabled in Stop mode.
	OSC_CR_EREFSTEN_0 = 0x0
	// External reference clock stays enabled in Stop mode if ERCLKEN is set before entering Stop mode.
	OSC_CR_EREFSTEN_1 = 0x1
	// Position of ERCLKEN field.
	OSC_CR_ERCLKEN_Pos = 0x7
	// Bit mask of ERCLKEN field.
	OSC_CR_ERCLKEN_Msk = 0x80
	// Bit ERCLKEN.
	OSC_CR_ERCLKEN = 0x80
	// External reference clock is inactive.
	OSC_CR_ERCLKEN_0 = 0x0
	// External reference clock is enabled.
	OSC_CR_ERCLKEN_1 = 0x1
)

// Constants for I2C0: Inter-Integrated Circuit
const (
	// A1: I2C Address Register 1
	// Position of AD field.
	I2C_A1_AD_Pos = 0x1
	// Bit mask of AD field.
	I2C_A1_AD_Msk = 0xfe

	// F: I2C Frequency Divider register
	// Position of ICR field.
	I2C_F_ICR_Pos = 0x0
	// Bit mask of ICR field.
	I2C_F_ICR_Msk = 0x3f
	// Position of MULT field.
	I2C_F_MULT_Pos = 0x6
	// Bit mask of MULT field.
	I2C_F_MULT_Msk = 0xc0
	// mul = 1
	I2C_F_MULT_00 = 0x0
	// mul = 2
	I2C_F_MULT_01 = 0x1
	// mul = 4
	I2C_F_MULT_10 = 0x2

	// C1: I2C Control Register 1
	// Position of DMAEN field.
	I2C_C1_DMAEN_Pos = 0x0
	// Bit mask of DMAEN field.
	I2C_C1_DMAEN_Msk = 0x1
	// Bit DMAEN.
	I2C_C1_DMAEN = 0x1
	// All DMA signalling disabled.
	I2C_C1_DMAEN_0 = 0x0
	// DMA transfer is enabled. While SMB[FACK] = 0, the following conditions trigger the DMA request: a data byte is received, and either address or data is transmitted. (ACK/NACK is automatic) the first byte received matches the A1 register or is a general call address. If any address matching occurs, S[IAAS] and S[TCF] are set. If the direction of transfer is known from master to slave, then it is not required to check S[SRW]. With this assumption, DMA can also be used in this case. In other cases, if the master reads data from the slave, then it is required to rewrite the C1 register operation. With this assumption, DMA cannot be used. When FACK = 1, an address or a data byte is transmitted.
	I2C_C1_DMAEN_1 = 0x1
	// Position of WUEN field.
	I2C_C1_WUEN_Pos = 0x1
	// Bit mask of WUEN field.
	I2C_C1_WUEN_Msk = 0x2
	// Bit WUEN.
	I2C_C1_WUEN = 0x2
	// Normal operation. No interrupt generated when address matching in low power mode.
	I2C_C1_WUEN_0 = 0x0
	// Enables the wakeup function in low power mode.
	I2C_C1_WUEN_1 = 0x1
	// Position of RSTA field.
	I2C_C1_RSTA_Pos = 0x2
	// Bit mask of RSTA field.
	I2C_C1_RSTA_Msk = 0x4
	// Bit RSTA.
	I2C_C1_RSTA = 0x4
	// Position of TXAK field.
	I2C_C1_TXAK_Pos = 0x3
	// Bit mask of TXAK field.
	I2C_C1_TXAK_Msk = 0x8
	// Bit TXAK.
	I2C_C1_TXAK = 0x8
	// An acknowledge signal is sent to the bus on the following receiving byte (if FACK is cleared) or the current receiving byte (if FACK is set).
	I2C_C1_TXAK_0 = 0x0
	// No acknowledge signal is sent to the bus on the following receiving data byte (if FACK is cleared) or the current receiving data byte (if FACK is set).
	I2C_C1_TXAK_1 = 0x1
	// Position of TX field.
	I2C_C1_TX_Pos = 0x4
	// Bit mask of TX field.
	I2C_C1_TX_Msk = 0x10
	// Bit TX.
	I2C_C1_TX = 0x10
	// Receive
	I2C_C1_TX_0 = 0x0
	// Transmit
	I2C_C1_TX_1 = 0x1
	// Position of MST field.
	I2C_C1_MST_Pos = 0x5
	// Bit mask of MST field.
	I2C_C1_MST_Msk = 0x20
	// Bit MST.
	I2C_C1_MST = 0x20
	// Slave mode
	I2C_C1_MST_0 = 0x0
	// Master mode
	I2C_C1_MST_1 = 0x1
	// Position of IICIE field.
	I2C_C1_IICIE_Pos = 0x6
	// Bit mask of IICIE field.
	I2C_C1_IICIE_Msk = 0x40
	// Bit IICIE.
	I2C_C1_IICIE = 0x40
	// Disabled
	I2C_C1_IICIE_0 = 0x0
	// Enabled
	I2C_C1_IICIE_1 = 0x1
	// Position of IICEN field.
	I2C_C1_IICEN_Pos = 0x7
	// Bit mask of IICEN field.
	I2C_C1_IICEN_Msk = 0x80
	// Bit IICEN.
	I2C_C1_IICEN = 0x80
	// Disabled
	I2C_C1_IICEN_0 = 0x0
	// Enabled
	I2C_C1_IICEN_1 = 0x1

	// S: I2C Status register
	// Position of RXAK field.
	I2C_S_RXAK_Pos = 0x0
	// Bit mask of RXAK field.
	I2C_S_RXAK_Msk = 0x1
	// Bit RXAK.
	I2C_S_RXAK = 0x1
	// Acknowledge signal was received after the completion of one byte of data transmission on the bus
	I2C_S_RXAK_0 = 0x0
	// No acknowledge signal detected
	I2C_S_RXAK_1 = 0x1
	// Position of IICIF field.
	I2C_S_IICIF_Pos = 0x1
	// Bit mask of IICIF field.
	I2C_S_IICIF_Msk = 0x2
	// Bit IICIF.
	I2C_S_IICIF = 0x2
	// No interrupt pending
	I2C_S_IICIF_0 = 0x0
	// Interrupt pending
	I2C_S_IICIF_1 = 0x1
	// Position of SRW field.
	I2C_S_SRW_Pos = 0x2
	// Bit mask of SRW field.
	I2C_S_SRW_Msk = 0x4
	// Bit SRW.
	I2C_S_SRW = 0x4
	// Slave receive, master writing to slave
	I2C_S_SRW_0 = 0x0
	// Slave transmit, master reading from slave
	I2C_S_SRW_1 = 0x1
	// Position of RAM field.
	I2C_S_RAM_Pos = 0x3
	// Bit mask of RAM field.
	I2C_S_RAM_Msk = 0x8
	// Bit RAM.
	I2C_S_RAM = 0x8
	// Not addressed
	I2C_S_RAM_0 = 0x0
	// Addressed as a slave
	I2C_S_RAM_1 = 0x1
	// Position of ARBL field.
	I2C_S_ARBL_Pos = 0x4
	// Bit mask of ARBL field.
	I2C_S_ARBL_Msk = 0x10
	// Bit ARBL.
	I2C_S_ARBL = 0x10
	// Standard bus operation.
	I2C_S_ARBL_0 = 0x0
	// Loss of arbitration.
	I2C_S_ARBL_1 = 0x1
	// Position of BUSY field.
	I2C_S_BUSY_Pos = 0x5
	// Bit mask of BUSY field.
	I2C_S_BUSY_Msk = 0x20
	// Bit BUSY.
	I2C_S_BUSY = 0x20
	// Bus is idle
	I2C_S_BUSY_0 = 0x0
	// Bus is busy
	I2C_S_BUSY_1 = 0x1
	// Position of IAAS field.
	I2C_S_IAAS_Pos = 0x6
	// Bit mask of IAAS field.
	I2C_S_IAAS_Msk = 0x40
	// Bit IAAS.
	I2C_S_IAAS = 0x40
	// Not addressed
	I2C_S_IAAS_0 = 0x0
	// Addressed as a slave
	I2C_S_IAAS_1 = 0x1
	// Position of TCF field.
	I2C_S_TCF_Pos = 0x7
	// Bit mask of TCF field.
	I2C_S_TCF_Msk = 0x80
	// Bit TCF.
	I2C_S_TCF = 0x80
	// Transfer in progress
	I2C_S_TCF_0 = 0x0
	// Transfer complete
	I2C_S_TCF_1 = 0x1

	// D: I2C Data I/O register
	// Position of DATA field.
	I2C_D_DATA_Pos = 0x0
	// Bit mask of DATA field.
	I2C_D_DATA_Msk = 0xff

	// C2: I2C Control Register 2
	// Position of AD field.
	I2C_C2_AD_Pos = 0x0
	// Bit mask of AD field.
	I2C_C2_AD_Msk = 0x7
	// Position of RMEN field.
	I2C_C2_RMEN_Pos = 0x3
	// Bit mask of RMEN field.
	I2C_C2_RMEN_Msk = 0x8
	// Bit RMEN.
	I2C_C2_RMEN = 0x8
	// Range mode disabled. No address matching occurs for an address within the range of values of the A1 and RA registers.
	I2C_C2_RMEN_0 = 0x0
	// Range mode enabled. Address matching occurs when a slave receives an address within the range of values of the A1 and RA registers.
	I2C_C2_RMEN_1 = 0x1
	// Position of SBRC field.
	I2C_C2_SBRC_Pos = 0x4
	// Bit mask of SBRC field.
	I2C_C2_SBRC_Msk = 0x10
	// Bit SBRC.
	I2C_C2_SBRC = 0x10
	// The slave baud rate follows the master baud rate and clock stretching may occur
	I2C_C2_SBRC_0 = 0x0
	// Slave baud rate is independent of the master baud rate
	I2C_C2_SBRC_1 = 0x1
	// Position of HDRS field.
	I2C_C2_HDRS_Pos = 0x5
	// Bit mask of HDRS field.
	I2C_C2_HDRS_Msk = 0x20
	// Bit HDRS.
	I2C_C2_HDRS = 0x20
	// Normal drive mode
	I2C_C2_HDRS_0 = 0x0
	// High drive mode
	I2C_C2_HDRS_1 = 0x1
	// Position of ADEXT field.
	I2C_C2_ADEXT_Pos = 0x6
	// Bit mask of ADEXT field.
	I2C_C2_ADEXT_Msk = 0x40
	// Bit ADEXT.
	I2C_C2_ADEXT = 0x40
	// 7-bit address scheme
	I2C_C2_ADEXT_0 = 0x0
	// 10-bit address scheme
	I2C_C2_ADEXT_1 = 0x1
	// Position of GCAEN field.
	I2C_C2_GCAEN_Pos = 0x7
	// Bit mask of GCAEN field.
	I2C_C2_GCAEN_Msk = 0x80
	// Bit GCAEN.
	I2C_C2_GCAEN = 0x80
	// Disabled
	I2C_C2_GCAEN_0 = 0x0
	// Enabled
	I2C_C2_GCAEN_1 = 0x1

	// FLT: I2C Programmable Input Glitch Filter register
	// Position of FLT field.
	I2C_FLT_FLT_Pos = 0x0
	// Bit mask of FLT field.
	I2C_FLT_FLT_Msk = 0xf
	// No filter/bypass
	I2C_FLT_FLT_0 = 0x0
	// Position of STARTF field.
	I2C_FLT_STARTF_Pos = 0x4
	// Bit mask of STARTF field.
	I2C_FLT_STARTF_Msk = 0x10
	// Bit STARTF.
	I2C_FLT_STARTF = 0x10
	// No start happens on I2C bus
	I2C_FLT_STARTF_0 = 0x0
	// Start detected on I2C bus
	I2C_FLT_STARTF_1 = 0x1
	// Position of SSIE field.
	I2C_FLT_SSIE_Pos = 0x5
	// Bit mask of SSIE field.
	I2C_FLT_SSIE_Msk = 0x20
	// Bit SSIE.
	I2C_FLT_SSIE = 0x20
	// Stop or start detection interrupt is disabled
	I2C_FLT_SSIE_0 = 0x0
	// Stop or start detection interrupt is enabled
	I2C_FLT_SSIE_1 = 0x1
	// Position of STOPF field.
	I2C_FLT_STOPF_Pos = 0x6
	// Bit mask of STOPF field.
	I2C_FLT_STOPF_Msk = 0x40
	// Bit STOPF.
	I2C_FLT_STOPF = 0x40
	// No stop happens on I2C bus
	I2C_FLT_STOPF_0 = 0x0
	// Stop detected on I2C bus
	I2C_FLT_STOPF_1 = 0x1
	// Position of SHEN field.
	I2C_FLT_SHEN_Pos = 0x7
	// Bit mask of SHEN field.
	I2C_FLT_SHEN_Msk = 0x80
	// Bit SHEN.
	I2C_FLT_SHEN = 0x80
	// Stop holdoff is disabled. The MCU's entry to stop mode is not gated.
	I2C_FLT_SHEN_0 = 0x0
	// Stop holdoff is enabled.
	I2C_FLT_SHEN_1 = 0x1

	// RA: I2C Range Address register
	// Position of RAD field.
	I2C_RA_RAD_Pos = 0x1
	// Bit mask of RAD field.
	I2C_RA_RAD_Msk = 0xfe

	// SMB: I2C SMBus Control and Status register
	// Position of SHTF2IE field.
	I2C_SMB_SHTF2IE_Pos = 0x0
	// Bit mask of SHTF2IE field.
	I2C_SMB_SHTF2IE_Msk = 0x1
	// Bit SHTF2IE.
	I2C_SMB_SHTF2IE = 0x1
	// SHTF2 interrupt is disabled
	I2C_SMB_SHTF2IE_0 = 0x0
	// SHTF2 interrupt is enabled
	I2C_SMB_SHTF2IE_1 = 0x1
	// Position of SHTF2 field.
	I2C_SMB_SHTF2_Pos = 0x1
	// Bit mask of SHTF2 field.
	I2C_SMB_SHTF2_Msk = 0x2
	// Bit SHTF2.
	I2C_SMB_SHTF2 = 0x2
	// No SCL high and SDA low timeout occurs
	I2C_SMB_SHTF2_0 = 0x0
	// SCL high and SDA low timeout occurs
	I2C_SMB_SHTF2_1 = 0x1
	// Position of SHTF1 field.
	I2C_SMB_SHTF1_Pos = 0x2
	// Bit mask of SHTF1 field.
	I2C_SMB_SHTF1_Msk = 0x4
	// Bit SHTF1.
	I2C_SMB_SHTF1 = 0x4
	// No SCL high and SDA high timeout occurs
	I2C_SMB_SHTF1_0 = 0x0
	// SCL high and SDA high timeout occurs
	I2C_SMB_SHTF1_1 = 0x1
	// Position of SLTF field.
	I2C_SMB_SLTF_Pos = 0x3
	// Bit mask of SLTF field.
	I2C_SMB_SLTF_Msk = 0x8
	// Bit SLTF.
	I2C_SMB_SLTF = 0x8
	// No low timeout occurs
	I2C_SMB_SLTF_0 = 0x0
	// Low timeout occurs
	I2C_SMB_SLTF_1 = 0x1
	// Position of TCKSEL field.
	I2C_SMB_TCKSEL_Pos = 0x4
	// Bit mask of TCKSEL field.
	I2C_SMB_TCKSEL_Msk = 0x10
	// Bit TCKSEL.
	I2C_SMB_TCKSEL = 0x10
	// Timeout counter counts at the frequency of the I2C module clock / 64
	I2C_SMB_TCKSEL_0 = 0x0
	// Timeout counter counts at the frequency of the I2C module clock
	I2C_SMB_TCKSEL_1 = 0x1
	// Position of SIICAEN field.
	I2C_SMB_SIICAEN_Pos = 0x5
	// Bit mask of SIICAEN field.
	I2C_SMB_SIICAEN_Msk = 0x20
	// Bit SIICAEN.
	I2C_SMB_SIICAEN = 0x20
	// I2C address register 2 matching is disabled
	I2C_SMB_SIICAEN_0 = 0x0
	// I2C address register 2 matching is enabled
	I2C_SMB_SIICAEN_1 = 0x1
	// Position of ALERTEN field.
	I2C_SMB_ALERTEN_Pos = 0x6
	// Bit mask of ALERTEN field.
	I2C_SMB_ALERTEN_Msk = 0x40
	// Bit ALERTEN.
	I2C_SMB_ALERTEN = 0x40
	// SMBus alert response address matching is disabled
	I2C_SMB_ALERTEN_0 = 0x0
	// SMBus alert response address matching is enabled
	I2C_SMB_ALERTEN_1 = 0x1
	// Position of FACK field.
	I2C_SMB_FACK_Pos = 0x7
	// Bit mask of FACK field.
	I2C_SMB_FACK_Msk = 0x80
	// Bit FACK.
	I2C_SMB_FACK = 0x80
	// An ACK or NACK is sent on the following receiving data byte
	I2C_SMB_FACK_0 = 0x0
	// Writing 0 to TXAK after receiving a data byte generates an ACK. Writing 1 to TXAK after receiving a data byte generates a NACK.
	I2C_SMB_FACK_1 = 0x1

	// A2: I2C Address Register 2
	// Position of SAD field.
	I2C_A2_SAD_Pos = 0x1
	// Bit mask of SAD field.
	I2C_A2_SAD_Msk = 0xfe

	// SLTH: I2C SCL Low Timeout Register High
	// Position of SSLT field.
	I2C_SLTH_SSLT_Pos = 0x0
	// Bit mask of SSLT field.
	I2C_SLTH_SSLT_Msk = 0xff

	// SLTL: I2C SCL Low Timeout Register Low
	// Position of SSLT field.
	I2C_SLTL_SSLT_Pos = 0x0
	// Bit mask of SSLT field.
	I2C_SLTL_SSLT_Msk = 0xff
)

// Constants for UART0: Serial Communication Interface
const (
	// BDH: UART Baud Rate Registers: High
	// Position of SBR field.
	UART_BDH_SBR_Pos = 0x0
	// Bit mask of SBR field.
	UART_BDH_SBR_Msk = 0x1f
	// Position of SBNS field.
	UART_BDH_SBNS_Pos = 0x5
	// Bit mask of SBNS field.
	UART_BDH_SBNS_Msk = 0x20
	// Bit SBNS.
	UART_BDH_SBNS = 0x20
	// Data frame consists of a single stop bit.
	UART_BDH_SBNS_0 = 0x0
	// Data frame consists of two stop bits.
	UART_BDH_SBNS_1 = 0x1
	// Position of RXEDGIE field.
	UART_BDH_RXEDGIE_Pos = 0x6
	// Bit mask of RXEDGIE field.
	UART_BDH_RXEDGIE_Msk = 0x40
	// Bit RXEDGIE.
	UART_BDH_RXEDGIE = 0x40
	// Hardware interrupts from RXEDGIF disabled using polling.
	UART_BDH_RXEDGIE_0 = 0x0
	// RXEDGIF interrupt request enabled.
	UART_BDH_RXEDGIE_1 = 0x1
	// Position of LBKDIE field.
	UART_BDH_LBKDIE_Pos = 0x7
	// Bit mask of LBKDIE field.
	UART_BDH_LBKDIE_Msk = 0x80
	// Bit LBKDIE.
	UART_BDH_LBKDIE = 0x80
	// LBKDIF interrupt and DMA transfer requests disabled.
	UART_BDH_LBKDIE_0 = 0x0
	// LBKDIF interrupt or DMA transfer requests enabled.
	UART_BDH_LBKDIE_1 = 0x1

	// BDL: UART Baud Rate Registers: Low
	// Position of SBR field.
	UART_BDL_SBR_Pos = 0x0
	// Bit mask of SBR field.
	UART_BDL_SBR_Msk = 0xff

	// C1: UART Control Register 1
	// Position of PT field.
	UART_C1_PT_Pos = 0x0
	// Bit mask of PT field.
	UART_C1_PT_Msk = 0x1
	// Bit PT.
	UART_C1_PT = 0x1
	// Even parity.
	UART_C1_PT_0 = 0x0
	// Odd parity.
	UART_C1_PT_1 = 0x1
	// Position of PE field.
	UART_C1_PE_Pos = 0x1
	// Bit mask of PE field.
	UART_C1_PE_Msk = 0x2
	// Bit PE.
	UART_C1_PE = 0x2
	// Parity function disabled.
	UART_C1_PE_0 = 0x0
	// Parity function enabled.
	UART_C1_PE_1 = 0x1
	// Position of ILT field.
	UART_C1_ILT_Pos = 0x2
	// Bit mask of ILT field.
	UART_C1_ILT_Msk = 0x4
	// Bit ILT.
	UART_C1_ILT = 0x4
	// Idle character bit count starts after start bit.
	UART_C1_ILT_0 = 0x0
	// Idle character bit count starts after stop bit.
	UART_C1_ILT_1 = 0x1
	// Position of WAKE field.
	UART_C1_WAKE_Pos = 0x3
	// Bit mask of WAKE field.
	UART_C1_WAKE_Msk = 0x8
	// Bit WAKE.
	UART_C1_WAKE = 0x8
	// Idle line wakeup.
	UART_C1_WAKE_0 = 0x0
	// Address mark wakeup.
	UART_C1_WAKE_1 = 0x1
	// Position of M field.
	UART_C1_M_Pos = 0x4
	// Bit mask of M field.
	UART_C1_M_Msk = 0x10
	// Bit M.
	UART_C1_M = 0x10
	// Normal-start + 8 data bits (MSB/LSB first as determined by MSBF) + stop.
	UART_C1_M_0 = 0x0
	// Use-start + 9 data bits (MSB/LSB first as determined by MSBF) + stop.
	UART_C1_M_1 = 0x1
	// Position of RSRC field.
	UART_C1_RSRC_Pos = 0x5
	// Bit mask of RSRC field.
	UART_C1_RSRC_Msk = 0x20
	// Bit RSRC.
	UART_C1_RSRC = 0x20
	// Selects internal loop back mode. The receiver input is internally connected to transmitter output.
	UART_C1_RSRC_0 = 0x0
	// Single wire UART mode where the receiver input is connected to the transmit pin input signal.
	UART_C1_RSRC_1 = 0x1
	// Position of UARTSWAI field.
	UART_C1_UARTSWAI_Pos = 0x6
	// Bit mask of UARTSWAI field.
	UART_C1_UARTSWAI_Msk = 0x40
	// Bit UARTSWAI.
	UART_C1_UARTSWAI = 0x40
	// UART clock continues to run in Wait mode.
	UART_C1_UARTSWAI_0 = 0x0
	// UART clock freezes while CPU is in Wait mode.
	UART_C1_UARTSWAI_1 = 0x1
	// Position of LOOPS field.
	UART_C1_LOOPS_Pos = 0x7
	// Bit mask of LOOPS field.
	UART_C1_LOOPS_Msk = 0x80
	// Bit LOOPS.
	UART_C1_LOOPS = 0x80
	// Normal operation.
	UART_C1_LOOPS_0 = 0x0
	// Loop mode where transmitter output is internally connected to receiver input. The receiver input is determined by RSRC.
	UART_C1_LOOPS_1 = 0x1

	// C2: UART Control Register 2
	// Position of SBK field.
	UART_C2_SBK_Pos = 0x0
	// Bit mask of SBK field.
	UART_C2_SBK_Msk = 0x1
	// Bit SBK.
	UART_C2_SBK = 0x1
	// Normal transmitter operation.
	UART_C2_SBK_0 = 0x0
	// Queue break characters to be sent.
	UART_C2_SBK_1 = 0x1
	// Position of RWU field.
	UART_C2_RWU_Pos = 0x1
	// Bit mask of RWU field.
	UART_C2_RWU_Msk = 0x2
	// Bit RWU.
	UART_C2_RWU = 0x2
	// Normal operation.
	UART_C2_RWU_0 = 0x0
	// RWU enables the wakeup function and inhibits further receiver interrupt requests. Normally, hardware wakes the receiver by automatically clearing RWU.
	UART_C2_RWU_1 = 0x1
	// Position of RE field.
	UART_C2_RE_Pos = 0x2
	// Bit mask of RE field.
	UART_C2_RE_Msk = 0x4
	// Bit RE.
	UART_C2_RE = 0x4
	// Receiver off.
	UART_C2_RE_0 = 0x0
	// Receiver on.
	UART_C2_RE_1 = 0x1
	// Position of TE field.
	UART_C2_TE_Pos = 0x3
	// Bit mask of TE field.
	UART_C2_TE_Msk = 0x8
	// Bit TE.
	UART_C2_TE = 0x8
	// Transmitter off.
	UART_C2_TE_0 = 0x0
	// Transmitter on.
	UART_C2_TE_1 = 0x1
	// Position of ILIE field.
	UART_C2_ILIE_Pos = 0x4
	// Bit mask of ILIE field.
	UART_C2_ILIE_Msk = 0x10
	// Bit ILIE.
	UART_C2_ILIE = 0x10
	// IDLE interrupt requests disabled. and DMA transfer
	UART_C2_ILIE_0 = 0x0
	// IDLE interrupt requests enabled. or DMA transfer
	UART_C2_ILIE_1 = 0x1
	// Position of RIE field.
	UART_C2_RIE_Pos = 0x5
	// Bit mask of RIE field.
	UART_C2_RIE_Msk = 0x20
	// Bit RIE.
	UART_C2_RIE = 0x20
	// RDRF interrupt and DMA transfer requests disabled.
	UART_C2_RIE_0 = 0x0
	// RDRF interrupt or DMA transfer requests enabled.
	UART_C2_RIE_1 = 0x1
	// Position of TCIE field.
	UART_C2_TCIE_Pos = 0x6
	// Bit mask of TCIE field.
	UART_C2_TCIE_Msk = 0x40
	// Bit TCIE.
	UART_C2_TCIE = 0x40
	// TC interrupt and DMA transfer requests disabled.
	UART_C2_TCIE_0 = 0x0
	// TC interrupt or DMA transfer requests enabled.
	UART_C2_TCIE_1 = 0x1
	// Position of TIE field.
	UART_C2_TIE_Pos = 0x7
	// Bit mask of TIE field.
	UART_C2_TIE_Msk = 0x80
	// Bit TIE.
	UART_C2_TIE = 0x80
	// TDRE interrupt and DMA transfer requests disabled.
	UART_C2_TIE_0 = 0x0
	// TDRE interrupt or DMA transfer requests enabled.
	UART_C2_TIE_1 = 0x1

	// S1: UART Status Register 1
	// Position of PF field.
	UART_S1_PF_Pos = 0x0
	// Bit mask of PF field.
	UART_S1_PF_Msk = 0x1
	// Bit PF.
	UART_S1_PF = 0x1
	// No parity error detected since the last time this flag was cleared. If the receive buffer has a depth greater than 1, then there may be data in the receive buffer what was received with a parity error.
	UART_S1_PF_0 = 0x0
	// At least one dataword was received with a parity error since the last time this flag was cleared.
	UART_S1_PF_1 = 0x1
	// Position of FE field.
	UART_S1_FE_Pos = 0x1
	// Bit mask of FE field.
	UART_S1_FE_Msk = 0x2
	// Bit FE.
	UART_S1_FE = 0x2
	// No framing error detected.
	UART_S1_FE_0 = 0x0
	// Framing error.
	UART_S1_FE_1 = 0x1
	// Position of NF field.
	UART_S1_NF_Pos = 0x2
	// Bit mask of NF field.
	UART_S1_NF_Msk = 0x4
	// Bit NF.
	UART_S1_NF = 0x4
	// No noise detected since the last time this flag was cleared. If the receive buffer has a depth greater than 1 then there may be data in the receiver buffer that was received with noise.
	UART_S1_NF_0 = 0x0
	// At least one dataword was received with noise detected since the last time the flag was cleared.
	UART_S1_NF_1 = 0x1
	// Position of OR field.
	UART_S1_OR_Pos = 0x3
	// Bit mask of OR field.
	UART_S1_OR_Msk = 0x8
	// Bit OR.
	UART_S1_OR = 0x8
	// No overrun has occurred since the last time the flag was cleared.
	UART_S1_OR_0 = 0x0
	// Overrun has occurred or the overrun flag has not been cleared since the last overrun occurred.
	UART_S1_OR_1 = 0x1
	// Position of IDLE field.
	UART_S1_IDLE_Pos = 0x4
	// Bit mask of IDLE field.
	UART_S1_IDLE_Msk = 0x10
	// Bit IDLE.
	UART_S1_IDLE = 0x10
	// Receiver input is either active now or has never become active since the IDLE flag was last cleared.
	UART_S1_IDLE_0 = 0x0
	// Receiver input has become idle or the flag has not been cleared since it last asserted.
	UART_S1_IDLE_1 = 0x1
	// Position of RDRF field.
	UART_S1_RDRF_Pos = 0x5
	// Bit mask of RDRF field.
	UART_S1_RDRF_Msk = 0x20
	// Bit RDRF.
	UART_S1_RDRF = 0x20
	// The number of datawords in the receive buffer is less than the number indicated by RXWATER.
	UART_S1_RDRF_0 = 0x0
	// The number of datawords in the receive buffer is equal to or greater than the number indicated by RXWATER at some point in time since this flag was last cleared.
	UART_S1_RDRF_1 = 0x1
	// Position of TC field.
	UART_S1_TC_Pos = 0x6
	// Bit mask of TC field.
	UART_S1_TC_Msk = 0x40
	// Bit TC.
	UART_S1_TC = 0x40
	// Transmitter active (sending data, a preamble, or a break).
	UART_S1_TC_0 = 0x0
	// Transmitter idle (transmission activity complete).
	UART_S1_TC_1 = 0x1
	// Position of TDRE field.
	UART_S1_TDRE_Pos = 0x7
	// Bit mask of TDRE field.
	UART_S1_TDRE_Msk = 0x80
	// Bit TDRE.
	UART_S1_TDRE = 0x80
	// The amount of data in the transmit buffer is greater than the value indicated by TWFIFO[TXWATER].
	UART_S1_TDRE_0 = 0x0
	// The amount of data in the transmit buffer is less than or equal to the value indicated by TWFIFO[TXWATER] at some point in time since the flag has been cleared.
	UART_S1_TDRE_1 = 0x1

	// S2: UART Status Register 2
	// Position of RAF field.
	UART_S2_RAF_Pos = 0x0
	// Bit mask of RAF field.
	UART_S2_RAF_Msk = 0x1
	// Bit RAF.
	UART_S2_RAF = 0x1
	// UART receiver idle/inactive waiting for a start bit.
	UART_S2_RAF_0 = 0x0
	// UART receiver active, RxD input not idle.
	UART_S2_RAF_1 = 0x1
	// Position of LBKDE field.
	UART_S2_LBKDE_Pos = 0x1
	// Bit mask of LBKDE field.
	UART_S2_LBKDE_Msk = 0x2
	// Bit LBKDE.
	UART_S2_LBKDE = 0x2
	// Break character detection is disabled.
	UART_S2_LBKDE_0 = 0x0
	// Break character is detected at length of 11 bit times if C1[M] = 0 or 12 bits time if C1[M] = 1.
	UART_S2_LBKDE_1 = 0x1
	// Position of BRK13 field.
	UART_S2_BRK13_Pos = 0x2
	// Bit mask of BRK13 field.
	UART_S2_BRK13_Msk = 0x4
	// Bit BRK13.
	UART_S2_BRK13 = 0x4
	// Break character is 10, 11, or 12 bits long.
	UART_S2_BRK13_0 = 0x0
	// Break character is 13 or 14 bits long.
	UART_S2_BRK13_1 = 0x1
	// Position of RWUID field.
	UART_S2_RWUID_Pos = 0x3
	// Bit mask of RWUID field.
	UART_S2_RWUID_Msk = 0x8
	// Bit RWUID.
	UART_S2_RWUID = 0x8
	// S1[IDLE] is not set upon detection of an idle character.
	UART_S2_RWUID_0 = 0x0
	// S1[IDLE] is set upon detection of an idle character.
	UART_S2_RWUID_1 = 0x1
	// Position of RXINV field.
	UART_S2_RXINV_Pos = 0x4
	// Bit mask of RXINV field.
	UART_S2_RXINV_Msk = 0x10
	// Bit RXINV.
	UART_S2_RXINV = 0x10
	// Receive data is not inverted.
	UART_S2_RXINV_0 = 0x0
	// Receive data is inverted.
	UART_S2_RXINV_1 = 0x1
	// Position of MSBF field.
	UART_S2_MSBF_Pos = 0x5
	// Bit mask of MSBF field.
	UART_S2_MSBF_Msk = 0x20
	// Bit MSBF.
	UART_S2_MSBF = 0x20
	// LSB (bit0) is the first bit that is transmitted following the start bit. Further, the first bit received after the start bit is identified as bit0.
	UART_S2_MSBF_0 = 0x0
	// MSB (bit8, bit7 or bit6) is the first bit that is transmitted following the start bit, depending on the setting of C1[M] and C1[PE]. Further, the first bit received after the start bit is identified as bit8, bit7, or bit6, depending on the setting of C1[M] and C1[PE].
	UART_S2_MSBF_1 = 0x1
	// Position of RXEDGIF field.
	UART_S2_RXEDGIF_Pos = 0x6
	// Bit mask of RXEDGIF field.
	UART_S2_RXEDGIF_Msk = 0x40
	// Bit RXEDGIF.
	UART_S2_RXEDGIF = 0x40
	// No active edge on the receive pin has occurred.
	UART_S2_RXEDGIF_0 = 0x0
	// An active edge on the receive pin has occurred.
	UART_S2_RXEDGIF_1 = 0x1
	// Position of LBKDIF field.
	UART_S2_LBKDIF_Pos = 0x7
	// Bit mask of LBKDIF field.
	UART_S2_LBKDIF_Msk = 0x80
	// Bit LBKDIF.
	UART_S2_LBKDIF = 0x80
	// No LIN break character detected.
	UART_S2_LBKDIF_0 = 0x0
	// LIN break character detected.
	UART_S2_LBKDIF_1 = 0x1

	// C3: UART Control Register 3
	// Position of PEIE field.
	UART_C3_PEIE_Pos = 0x0
	// Bit mask of PEIE field.
	UART_C3_PEIE_Msk = 0x1
	// Bit PEIE.
	UART_C3_PEIE = 0x1
	// PF interrupt requests are disabled.
	UART_C3_PEIE_0 = 0x0
	// PF interrupt requests are enabled.
	UART_C3_PEIE_1 = 0x1
	// Position of FEIE field.
	UART_C3_FEIE_Pos = 0x1
	// Bit mask of FEIE field.
	UART_C3_FEIE_Msk = 0x2
	// Bit FEIE.
	UART_C3_FEIE = 0x2
	// FE interrupt requests are disabled.
	UART_C3_FEIE_0 = 0x0
	// FE interrupt requests are enabled.
	UART_C3_FEIE_1 = 0x1
	// Position of NEIE field.
	UART_C3_NEIE_Pos = 0x2
	// Bit mask of NEIE field.
	UART_C3_NEIE_Msk = 0x4
	// Bit NEIE.
	UART_C3_NEIE = 0x4
	// NF interrupt requests are disabled.
	UART_C3_NEIE_0 = 0x0
	// NF interrupt requests are enabled.
	UART_C3_NEIE_1 = 0x1
	// Position of ORIE field.
	UART_C3_ORIE_Pos = 0x3
	// Bit mask of ORIE field.
	UART_C3_ORIE_Msk = 0x8
	// Bit ORIE.
	UART_C3_ORIE = 0x8
	// OR interrupts are disabled.
	UART_C3_ORIE_0 = 0x0
	// OR interrupt requests are enabled.
	UART_C3_ORIE_1 = 0x1
	// Position of TXINV field.
	UART_C3_TXINV_Pos = 0x4
	// Bit mask of TXINV field.
	UART_C3_TXINV_Msk = 0x10
	// Bit TXINV.
	UART_C3_TXINV = 0x10
	// Transmit data is not inverted.
	UART_C3_TXINV_0 = 0x0
	// Transmit data is inverted.
	UART_C3_TXINV_1 = 0x1
	// Position of TXDIR field.
	UART_C3_TXDIR_Pos = 0x5
	// Bit mask of TXDIR field.
	UART_C3_TXDIR_Msk = 0x20
	// Bit TXDIR.
	UART_C3_TXDIR = 0x20
	// TXD pin is an input in single wire mode.
	UART_C3_TXDIR_0 = 0x0
	// TXD pin is an output in single wire mode.
	UART_C3_TXDIR_1 = 0x1
	// Position of T8 field.
	UART_C3_T8_Pos = 0x6
	// Bit mask of T8 field.
	UART_C3_T8_Msk = 0x40
	// Bit T8.
	UART_C3_T8 = 0x40
	// Position of R8 field.
	UART_C3_R8_Pos = 0x7
	// Bit mask of R8 field.
	UART_C3_R8_Msk = 0x80
	// Bit R8.
	UART_C3_R8 = 0x80

	// D: UART Data Register
	// Position of RT field.
	UART_D_RT_Pos = 0x0
	// Bit mask of RT field.
	UART_D_RT_Msk = 0xff

	// MA1: UART Match Address Registers 1
	// Position of MA field.
	UART_MA1_MA_Pos = 0x0
	// Bit mask of MA field.
	UART_MA1_MA_Msk = 0xff

	// MA2: UART Match Address Registers 2
	// Position of MA field.
	UART_MA2_MA_Pos = 0x0
	// Bit mask of MA field.
	UART_MA2_MA_Msk = 0xff

	// C4: UART Control Register 4
	// Position of BRFA field.
	UART_C4_BRFA_Pos = 0x0
	// Bit mask of BRFA field.
	UART_C4_BRFA_Msk = 0x1f
	// Position of M10 field.
	UART_C4_M10_Pos = 0x5
	// Bit mask of M10 field.
	UART_C4_M10_Msk = 0x20
	// Bit M10.
	UART_C4_M10 = 0x20
	// The parity bit is the ninth bit in the serial transmission.
	UART_C4_M10_0 = 0x0
	// The parity bit is the tenth bit in the serial transmission.
	UART_C4_M10_1 = 0x1
	// Position of MAEN2 field.
	UART_C4_MAEN2_Pos = 0x6
	// Bit mask of MAEN2 field.
	UART_C4_MAEN2_Msk = 0x40
	// Bit MAEN2.
	UART_C4_MAEN2 = 0x40
	// All data received is transferred to the data buffer if MAEN1 is cleared.
	UART_C4_MAEN2_0 = 0x0
	// All data received with the most significant bit cleared, is discarded. All data received with the most significant bit set, is compared with contents of MA2 register. If no match occurs, the data is discarded. If a match occurs, data is transferred to the data buffer. This field must be cleared when C7816[ISO7816E] is set/enabled.
	UART_C4_MAEN2_1 = 0x1
	// Position of MAEN1 field.
	UART_C4_MAEN1_Pos = 0x7
	// Bit mask of MAEN1 field.
	UART_C4_MAEN1_Msk = 0x80
	// Bit MAEN1.
	UART_C4_MAEN1 = 0x80
	// All data received is transferred to the data buffer if MAEN2 is cleared.
	UART_C4_MAEN1_0 = 0x0
	// All data received with the most significant bit cleared, is discarded. All data received with the most significant bit set, is compared with contents of MA1 register. If no match occurs, the data is discarded. If match occurs, data is transferred to the data buffer. This field must be cleared when C7816[ISO7816E] is set/enabled.
	UART_C4_MAEN1_1 = 0x1

	// C5: UART Control Register 5
	// Position of LBKDDMAS field.
	UART_C5_LBKDDMAS_Pos = 0x3
	// Bit mask of LBKDDMAS field.
	UART_C5_LBKDDMAS_Msk = 0x8
	// Bit LBKDDMAS.
	UART_C5_LBKDDMAS = 0x8
	// If BDH[LBKDIE] and S2[LBKDIF] are set, the LBKDIF interrupt signal is asserted to request an interrupt service.
	UART_C5_LBKDDMAS_0 = 0x0
	// If BDH[LBKDIE] and S2[LBKDIF] are set, the LBKDIF DMA request signal is asserted to request a DMA transfer.
	UART_C5_LBKDDMAS_1 = 0x1
	// Position of ILDMAS field.
	UART_C5_ILDMAS_Pos = 0x4
	// Bit mask of ILDMAS field.
	UART_C5_ILDMAS_Msk = 0x10
	// Bit ILDMAS.
	UART_C5_ILDMAS = 0x10
	// If C2[ILIE] and S1[IDLE] are set, the IDLE interrupt request signal is asserted to request an interrupt service.
	UART_C5_ILDMAS_0 = 0x0
	// If C2[ILIE] and S1[IDLE] are set, the IDLE DMA request signal is asserted to request a DMA transfer.
	UART_C5_ILDMAS_1 = 0x1
	// Position of RDMAS field.
	UART_C5_RDMAS_Pos = 0x5
	// Bit mask of RDMAS field.
	UART_C5_RDMAS_Msk = 0x20
	// Bit RDMAS.
	UART_C5_RDMAS = 0x20
	// If C2[RIE] and S1[RDRF] are set, the RDFR interrupt request signal is asserted to request an interrupt service.
	UART_C5_RDMAS_0 = 0x0
	// If C2[RIE] and S1[RDRF] are set, the RDRF DMA request signal is asserted to request a DMA transfer.
	UART_C5_RDMAS_1 = 0x1
	// Position of TCDMAS field.
	UART_C5_TCDMAS_Pos = 0x6
	// Bit mask of TCDMAS field.
	UART_C5_TCDMAS_Msk = 0x40
	// Bit TCDMAS.
	UART_C5_TCDMAS = 0x40
	// If C2[TCIE] is set and the S1[TC] flag is set, the TC interrupt request signal is asserted to request an interrupt service.
	UART_C5_TCDMAS_0 = 0x0
	// If C2[TCIE] is set and the S1[TC] flag is set, the TC DMA request signal is asserted to request a DMA transfer.
	UART_C5_TCDMAS_1 = 0x1
	// Position of TDMAS field.
	UART_C5_TDMAS_Pos = 0x7
	// Bit mask of TDMAS field.
	UART_C5_TDMAS_Msk = 0x80
	// Bit TDMAS.
	UART_C5_TDMAS = 0x80
	// If C2[TIE] is set and the S1[TDRE] flag is set, the TDRE interrupt request signal is asserted to request interrupt service.
	UART_C5_TDMAS_0 = 0x0
	// If C2[TIE] is set and the S1[TDRE] flag is set, the TDRE DMA request signal is asserted to request a DMA transfer.
	UART_C5_TDMAS_1 = 0x1

	// ED: UART Extended Data Register
	// Position of PARITYE field.
	UART_ED_PARITYE_Pos = 0x6
	// Bit mask of PARITYE field.
	UART_ED_PARITYE_Msk = 0x40
	// Bit PARITYE.
	UART_ED_PARITYE = 0x40
	// The dataword was received without a parity error.
	UART_ED_PARITYE_0 = 0x0
	// The dataword was received with a parity error.
	UART_ED_PARITYE_1 = 0x1
	// Position of NOISY field.
	UART_ED_NOISY_Pos = 0x7
	// Bit mask of NOISY field.
	UART_ED_NOISY_Msk = 0x80
	// Bit NOISY.
	UART_ED_NOISY = 0x80
	// The dataword was received without noise.
	UART_ED_NOISY_0 = 0x0
	// The data was received with noise.
	UART_ED_NOISY_1 = 0x1

	// MODEM: UART Modem Register
	// Position of TXCTSE field.
	UART_MODEM_TXCTSE_Pos = 0x0
	// Bit mask of TXCTSE field.
	UART_MODEM_TXCTSE_Msk = 0x1
	// Bit TXCTSE.
	UART_MODEM_TXCTSE = 0x1
	// CTS has no effect on the transmitter.
	UART_MODEM_TXCTSE_0 = 0x0
	// Enables clear-to-send operation. The transmitter checks the state of CTS each time it is ready to send a character. If CTS is asserted, the character is sent. If CTS is deasserted, the signal TXD remains in the mark state and transmission is delayed until CTS is asserted. Changes in CTS as a character is being sent do not affect its transmission.
	UART_MODEM_TXCTSE_1 = 0x1
	// Position of TXRTSE field.
	UART_MODEM_TXRTSE_Pos = 0x1
	// Bit mask of TXRTSE field.
	UART_MODEM_TXRTSE_Msk = 0x2
	// Bit TXRTSE.
	UART_MODEM_TXRTSE = 0x2
	// The transmitter has no effect on RTS.
	UART_MODEM_TXRTSE_0 = 0x0
	// When a character is placed into an empty transmitter data buffer , RTS asserts one bit time before the start bit is transmitted. RTS deasserts one bit time after all characters in the transmitter data buffer and shift register are completely sent, including the last stop bit. (FIFO) (FIFO)
	UART_MODEM_TXRTSE_1 = 0x1
	// Position of TXRTSPOL field.
	UART_MODEM_TXRTSPOL_Pos = 0x2
	// Bit mask of TXRTSPOL field.
	UART_MODEM_TXRTSPOL_Msk = 0x4
	// Bit TXRTSPOL.
	UART_MODEM_TXRTSPOL = 0x4
	// Transmitter RTS is active low.
	UART_MODEM_TXRTSPOL_0 = 0x0
	// Transmitter RTS is active high.
	UART_MODEM_TXRTSPOL_1 = 0x1
	// Position of RXRTSE field.
	UART_MODEM_RXRTSE_Pos = 0x3
	// Bit mask of RXRTSE field.
	UART_MODEM_RXRTSE_Msk = 0x8
	// Bit RXRTSE.
	UART_MODEM_RXRTSE = 0x8
	// The receiver has no effect on RTS.
	UART_MODEM_RXRTSE_0 = 0x0
	// RTS is deasserted if the number of characters in the receiver data register (FIFO) is equal to or greater than RWFIFO[RXWATER]. RTS is asserted when the number of characters in the receiver data register (FIFO) is less than RWFIFO[RXWATER].
	UART_MODEM_RXRTSE_1 = 0x1

	// IR: UART Infrared Register
	// Position of TNP field.
	UART_IR_TNP_Pos = 0x0
	// Bit mask of TNP field.
	UART_IR_TNP_Msk = 0x3
	// 3/16.
	UART_IR_TNP_00 = 0x0
	// 1/16.
	UART_IR_TNP_01 = 0x1
	// 1/32.
	UART_IR_TNP_10 = 0x2
	// 1/4.
	UART_IR_TNP_11 = 0x3
	// Position of IREN field.
	UART_IR_IREN_Pos = 0x2
	// Bit mask of IREN field.
	UART_IR_IREN_Msk = 0x4
	// Bit IREN.
	UART_IR_IREN = 0x4
	// IR disabled.
	UART_IR_IREN_0 = 0x0
	// IR enabled.
	UART_IR_IREN_1 = 0x1

	// PFIFO: UART FIFO Parameters
	// Position of RXFIFOSIZE field.
	UART_PFIFO_RXFIFOSIZE_Pos = 0x0
	// Bit mask of RXFIFOSIZE field.
	UART_PFIFO_RXFIFOSIZE_Msk = 0x7
	// Receive FIFO/Buffer depth = 1 dataword.
	UART_PFIFO_RXFIFOSIZE_000 = 0x0
	// Receive FIFO/Buffer depth = 4 datawords.
	UART_PFIFO_RXFIFOSIZE_001 = 0x1
	// Receive FIFO/Buffer depth = 8 datawords.
	UART_PFIFO_RXFIFOSIZE_010 = 0x2
	// Receive FIFO/Buffer depth = 16 datawords.
	UART_PFIFO_RXFIFOSIZE_011 = 0x3
	// Receive FIFO/Buffer depth = 32 datawords.
	UART_PFIFO_RXFIFOSIZE_100 = 0x4
	// Receive FIFO/Buffer depth = 64 datawords.
	UART_PFIFO_RXFIFOSIZE_101 = 0x5
	// Receive FIFO/Buffer depth = 128 datawords.
	UART_PFIFO_RXFIFOSIZE_110 = 0x6
	// Position of RXFE field.
	UART_PFIFO_RXFE_Pos = 0x3
	// Bit mask of RXFE field.
	UART_PFIFO_RXFE_Msk = 0x8
	// Bit RXFE.
	UART_PFIFO_RXFE = 0x8
	// Receive FIFO is not enabled. Buffer is depth 1. (Legacy support)
	UART_PFIFO_RXFE_0 = 0x0
	// Receive FIFO is enabled. Buffer is depth indicted by RXFIFOSIZE.
	UART_PFIFO_RXFE_1 = 0x1
	// Position of TXFIFOSIZE field.
	UART_PFIFO_TXFIFOSIZE_Pos = 0x4
	// Bit mask of TXFIFOSIZE field.
	UART_PFIFO_TXFIFOSIZE_Msk = 0x70
	// Transmit FIFO/Buffer depth = 1 dataword.
	UART_PFIFO_TXFIFOSIZE_000 = 0x0
	// Transmit FIFO/Buffer depth = 4 datawords.
	UART_PFIFO_TXFIFOSIZE_001 = 0x1
	// Transmit FIFO/Buffer depth = 8 datawords.
	UART_PFIFO_TXFIFOSIZE_010 = 0x2
	// Transmit FIFO/Buffer depth = 16 datawords.
	UART_PFIFO_TXFIFOSIZE_011 = 0x3
	// Transmit FIFO/Buffer depth = 32 datawords.
	UART_PFIFO_TXFIFOSIZE_100 = 0x4
	// Transmit FIFO/Buffer depth = 64 datawords.
	UART_PFIFO_TXFIFOSIZE_101 = 0x5
	// Transmit FIFO/Buffer depth = 128 datawords.
	UART_PFIFO_TXFIFOSIZE_110 = 0x6
	// Position of TXFE field.
	UART_PFIFO_TXFE_Pos = 0x7
	// Bit mask of TXFE field.
	UART_PFIFO_TXFE_Msk = 0x80
	// Bit TXFE.
	UART_PFIFO_TXFE = 0x80
	// Transmit FIFO is not enabled. Buffer is depth 1. (Legacy support).
	UART_PFIFO_TXFE_0 = 0x0
	// Transmit FIFO is enabled. Buffer is depth indicated by TXFIFOSIZE.
	UART_PFIFO_TXFE_1 = 0x1

	// CFIFO: UART FIFO Control Register
	// Position of RXUFE field.
	UART_CFIFO_RXUFE_Pos = 0x0
	// Bit mask of RXUFE field.
	UART_CFIFO_RXUFE_Msk = 0x1
	// Bit RXUFE.
	UART_CFIFO_RXUFE = 0x1
	// RXUF flag does not generate an interrupt to the host.
	UART_CFIFO_RXUFE_0 = 0x0
	// RXUF flag generates an interrupt to the host.
	UART_CFIFO_RXUFE_1 = 0x1
	// Position of TXOFE field.
	UART_CFIFO_TXOFE_Pos = 0x1
	// Bit mask of TXOFE field.
	UART_CFIFO_TXOFE_Msk = 0x2
	// Bit TXOFE.
	UART_CFIFO_TXOFE = 0x2
	// TXOF flag does not generate an interrupt to the host.
	UART_CFIFO_TXOFE_0 = 0x0
	// TXOF flag generates an interrupt to the host.
	UART_CFIFO_TXOFE_1 = 0x1
	// Position of RXOFE field.
	UART_CFIFO_RXOFE_Pos = 0x2
	// Bit mask of RXOFE field.
	UART_CFIFO_RXOFE_Msk = 0x4
	// Bit RXOFE.
	UART_CFIFO_RXOFE = 0x4
	// RXOF flag does not generate an interrupt to the host.
	UART_CFIFO_RXOFE_0 = 0x0
	// RXOF flag generates an interrupt to the host.
	UART_CFIFO_RXOFE_1 = 0x1
	// Position of RXFLUSH field.
	UART_CFIFO_RXFLUSH_Pos = 0x6
	// Bit mask of RXFLUSH field.
	UART_CFIFO_RXFLUSH_Msk = 0x40
	// Bit RXFLUSH.
	UART_CFIFO_RXFLUSH = 0x40
	// No flush operation occurs.
	UART_CFIFO_RXFLUSH_0 = 0x0
	// All data in the receive FIFO/buffer is cleared out.
	UART_CFIFO_RXFLUSH_1 = 0x1
	// Position of TXFLUSH field.
	UART_CFIFO_TXFLUSH_Pos = 0x7
	// Bit mask of TXFLUSH field.
	UART_CFIFO_TXFLUSH_Msk = 0x80
	// Bit TXFLUSH.
	UART_CFIFO_TXFLUSH = 0x80
	// No flush operation occurs.
	UART_CFIFO_TXFLUSH_0 = 0x0
	// All data in the transmit FIFO/Buffer is cleared out.
	UART_CFIFO_TXFLUSH_1 = 0x1

	// SFIFO: UART FIFO Status Register
	// Position of RXUF field.
	UART_SFIFO_RXUF_Pos = 0x0
	// Bit mask of RXUF field.
	UART_SFIFO_RXUF_Msk = 0x1
	// Bit RXUF.
	UART_SFIFO_RXUF = 0x1
	// No receive buffer underflow has occurred since the last time the flag was cleared.
	UART_SFIFO_RXUF_0 = 0x0
	// At least one receive buffer underflow has occurred since the last time the flag was cleared.
	UART_SFIFO_RXUF_1 = 0x1
	// Position of TXOF field.
	UART_SFIFO_TXOF_Pos = 0x1
	// Bit mask of TXOF field.
	UART_SFIFO_TXOF_Msk = 0x2
	// Bit TXOF.
	UART_SFIFO_TXOF = 0x2
	// No transmit buffer overflow has occurred since the last time the flag was cleared.
	UART_SFIFO_TXOF_0 = 0x0
	// At least one transmit buffer overflow has occurred since the last time the flag was cleared.
	UART_SFIFO_TXOF_1 = 0x1
	// Position of RXOF field.
	UART_SFIFO_RXOF_Pos = 0x2
	// Bit mask of RXOF field.
	UART_SFIFO_RXOF_Msk = 0x4
	// Bit RXOF.
	UART_SFIFO_RXOF = 0x4
	// No receive buffer overflow has occurred since the last time the flag was cleared.
	UART_SFIFO_RXOF_0 = 0x0
	// At least one receive buffer overflow has occurred since the last time the flag was cleared.
	UART_SFIFO_RXOF_1 = 0x1
	// Position of RXEMPT field.
	UART_SFIFO_RXEMPT_Pos = 0x6
	// Bit mask of RXEMPT field.
	UART_SFIFO_RXEMPT_Msk = 0x40
	// Bit RXEMPT.
	UART_SFIFO_RXEMPT = 0x40
	// Receive buffer is not empty.
	UART_SFIFO_RXEMPT_0 = 0x0
	// Receive buffer is empty.
	UART_SFIFO_RXEMPT_1 = 0x1
	// Position of TXEMPT field.
	UART_SFIFO_TXEMPT_Pos = 0x7
	// Bit mask of TXEMPT field.
	UART_SFIFO_TXEMPT_Msk = 0x80
	// Bit TXEMPT.
	UART_SFIFO_TXEMPT = 0x80
	// Transmit buffer is not empty.
	UART_SFIFO_TXEMPT_0 = 0x0
	// Transmit buffer is empty.
	UART_SFIFO_TXEMPT_1 = 0x1

	// TWFIFO: UART FIFO Transmit Watermark
	// Position of TXWATER field.
	UART_TWFIFO_TXWATER_Pos = 0x0
	// Bit mask of TXWATER field.
	UART_TWFIFO_TXWATER_Msk = 0xff

	// TCFIFO: UART FIFO Transmit Count
	// Position of TXCOUNT field.
	UART_TCFIFO_TXCOUNT_Pos = 0x0
	// Bit mask of TXCOUNT field.
	UART_TCFIFO_TXCOUNT_Msk = 0xff

	// RWFIFO: UART FIFO Receive Watermark
	// Position of RXWATER field.
	UART_RWFIFO_RXWATER_Pos = 0x0
	// Bit mask of RXWATER field.
	UART_RWFIFO_RXWATER_Msk = 0xff

	// RCFIFO: UART FIFO Receive Count
	// Position of RXCOUNT field.
	UART_RCFIFO_RXCOUNT_Pos = 0x0
	// Bit mask of RXCOUNT field.
	UART_RCFIFO_RXCOUNT_Msk = 0xff

	// C7816: UART 7816 Control Register
	// Position of ISO_7816E field.
	UART_C7816_ISO_7816E_Pos = 0x0
	// Bit mask of ISO_7816E field.
	UART_C7816_ISO_7816E_Msk = 0x1
	// Bit ISO_7816E.
	UART_C7816_ISO_7816E = 0x1
	// ISO-7816 functionality is turned off/not enabled.
	UART_C7816_ISO_7816E_0 = 0x0
	// ISO-7816 functionality is turned on/enabled.
	UART_C7816_ISO_7816E_1 = 0x1
	// Position of TTYPE field.
	UART_C7816_TTYPE_Pos = 0x1
	// Bit mask of TTYPE field.
	UART_C7816_TTYPE_Msk = 0x2
	// Bit TTYPE.
	UART_C7816_TTYPE = 0x2
	// T = 0 per the ISO-7816 specification.
	UART_C7816_TTYPE_0 = 0x0
	// T = 1 per the ISO-7816 specification.
	UART_C7816_TTYPE_1 = 0x1
	// Position of INIT field.
	UART_C7816_INIT_Pos = 0x2
	// Bit mask of INIT field.
	UART_C7816_INIT_Msk = 0x4
	// Bit INIT.
	UART_C7816_INIT = 0x4
	// Normal operating mode. Receiver does not seek to identify initial character.
	UART_C7816_INIT_0 = 0x0
	// Receiver searches for initial character.
	UART_C7816_INIT_1 = 0x1
	// Position of ANACK field.
	UART_C7816_ANACK_Pos = 0x3
	// Bit mask of ANACK field.
	UART_C7816_ANACK_Msk = 0x8
	// Bit ANACK.
	UART_C7816_ANACK = 0x8
	// No NACK is automatically generated.
	UART_C7816_ANACK_0 = 0x0
	// A NACK is automatically generated if a parity error is detected or if an invalid initial character is detected.
	UART_C7816_ANACK_1 = 0x1
	// Position of ONACK field.
	UART_C7816_ONACK_Pos = 0x4
	// Bit mask of ONACK field.
	UART_C7816_ONACK_Msk = 0x10
	// Bit ONACK.
	UART_C7816_ONACK = 0x10
	// The received data does not generate a NACK when the receipt of the data results in an overflow event.
	UART_C7816_ONACK_0 = 0x0
	// If the receiver buffer overflows, a NACK is automatically sent on a received character.
	UART_C7816_ONACK_1 = 0x1

	// IE7816: UART 7816 Interrupt Enable Register
	// Position of RXTE field.
	UART_IE7816_RXTE_Pos = 0x0
	// Bit mask of RXTE field.
	UART_IE7816_RXTE_Msk = 0x1
	// Bit RXTE.
	UART_IE7816_RXTE = 0x1
	// The assertion of IS7816[RXT] does not result in the generation of an interrupt.
	UART_IE7816_RXTE_0 = 0x0
	// The assertion of IS7816[RXT] results in the generation of an interrupt.
	UART_IE7816_RXTE_1 = 0x1
	// Position of TXTE field.
	UART_IE7816_TXTE_Pos = 0x1
	// Bit mask of TXTE field.
	UART_IE7816_TXTE_Msk = 0x2
	// Bit TXTE.
	UART_IE7816_TXTE = 0x2
	// The assertion of IS7816[TXT] does not result in the generation of an interrupt.
	UART_IE7816_TXTE_0 = 0x0
	// The assertion of IS7816[TXT] results in the generation of an interrupt.
	UART_IE7816_TXTE_1 = 0x1
	// Position of GTVE field.
	UART_IE7816_GTVE_Pos = 0x2
	// Bit mask of GTVE field.
	UART_IE7816_GTVE_Msk = 0x4
	// Bit GTVE.
	UART_IE7816_GTVE = 0x4
	// The assertion of IS7816[GTV] does not result in the generation of an interrupt.
	UART_IE7816_GTVE_0 = 0x0
	// The assertion of IS7816[GTV] results in the generation of an interrupt.
	UART_IE7816_GTVE_1 = 0x1
	// Position of INITDE field.
	UART_IE7816_INITDE_Pos = 0x4
	// Bit mask of INITDE field.
	UART_IE7816_INITDE_Msk = 0x10
	// Bit INITDE.
	UART_IE7816_INITDE = 0x10
	// The assertion of IS7816[INITD] does not result in the generation of an interrupt.
	UART_IE7816_INITDE_0 = 0x0
	// The assertion of IS7816[INITD] results in the generation of an interrupt.
	UART_IE7816_INITDE_1 = 0x1
	// Position of BWTE field.
	UART_IE7816_BWTE_Pos = 0x5
	// Bit mask of BWTE field.
	UART_IE7816_BWTE_Msk = 0x20
	// Bit BWTE.
	UART_IE7816_BWTE = 0x20
	// The assertion of IS7816[BWT] does not result in the generation of an interrupt.
	UART_IE7816_BWTE_0 = 0x0
	// The assertion of IS7816[BWT] results in the generation of an interrupt.
	UART_IE7816_BWTE_1 = 0x1
	// Position of CWTE field.
	UART_IE7816_CWTE_Pos = 0x6
	// Bit mask of CWTE field.
	UART_IE7816_CWTE_Msk = 0x40
	// Bit CWTE.
	UART_IE7816_CWTE = 0x40
	// The assertion of IS7816[CWT] does not result in the generation of an interrupt.
	UART_IE7816_CWTE_0 = 0x0
	// The assertion of IS7816[CWT] results in the generation of an interrupt.
	UART_IE7816_CWTE_1 = 0x1
	// Position of WTE field.
	UART_IE7816_WTE_Pos = 0x7
	// Bit mask of WTE field.
	UART_IE7816_WTE_Msk = 0x80
	// Bit WTE.
	UART_IE7816_WTE = 0x80
	// The assertion of IS7816[WT] does not result in the generation of an interrupt.
	UART_IE7816_WTE_0 = 0x0
	// The assertion of IS7816[WT] results in the generation of an interrupt.
	UART_IE7816_WTE_1 = 0x1

	// IS7816: UART 7816 Interrupt Status Register
	// Position of RXT field.
	UART_IS7816_RXT_Pos = 0x0
	// Bit mask of RXT field.
	UART_IS7816_RXT_Msk = 0x1
	// Bit RXT.
	UART_IS7816_RXT = 0x1
	// The number of consecutive NACKS generated as a result of parity errors and buffer overruns is less than or equal to the value in ET7816[RXTHRESHOLD].
	UART_IS7816_RXT_0 = 0x0
	// The number of consecutive NACKS generated as a result of parity errors and buffer overruns is greater than the value in ET7816[RXTHRESHOLD].
	UART_IS7816_RXT_1 = 0x1
	// Position of TXT field.
	UART_IS7816_TXT_Pos = 0x1
	// Bit mask of TXT field.
	UART_IS7816_TXT_Msk = 0x2
	// Bit TXT.
	UART_IS7816_TXT = 0x2
	// The number of retries and corresponding NACKS does not exceed the value in ET7816[TXTHRESHOLD].
	UART_IS7816_TXT_0 = 0x0
	// The number of retries and corresponding NACKS exceeds the value in ET7816[TXTHRESHOLD].
	UART_IS7816_TXT_1 = 0x1
	// Position of GTV field.
	UART_IS7816_GTV_Pos = 0x2
	// Bit mask of GTV field.
	UART_IS7816_GTV_Msk = 0x4
	// Bit GTV.
	UART_IS7816_GTV = 0x4
	// A guard time (GT, CGT, or BGT) has not been violated.
	UART_IS7816_GTV_0 = 0x0
	// A guard time (GT, CGT, or BGT) has been violated.
	UART_IS7816_GTV_1 = 0x1
	// Position of INITD field.
	UART_IS7816_INITD_Pos = 0x4
	// Bit mask of INITD field.
	UART_IS7816_INITD_Msk = 0x10
	// Bit INITD.
	UART_IS7816_INITD = 0x10
	// A valid initial character has not been received.
	UART_IS7816_INITD_0 = 0x0
	// A valid initial character has been received.
	UART_IS7816_INITD_1 = 0x1
	// Position of BWT field.
	UART_IS7816_BWT_Pos = 0x5
	// Bit mask of BWT field.
	UART_IS7816_BWT_Msk = 0x20
	// Bit BWT.
	UART_IS7816_BWT = 0x20
	// Block wait time (BWT) has not been violated.
	UART_IS7816_BWT_0 = 0x0
	// Block wait time (BWT) has been violated.
	UART_IS7816_BWT_1 = 0x1
	// Position of CWT field.
	UART_IS7816_CWT_Pos = 0x6
	// Bit mask of CWT field.
	UART_IS7816_CWT_Msk = 0x40
	// Bit CWT.
	UART_IS7816_CWT = 0x40
	// Character wait time (CWT) has not been violated.
	UART_IS7816_CWT_0 = 0x0
	// Character wait time (CWT) has been violated.
	UART_IS7816_CWT_1 = 0x1
	// Position of WT field.
	UART_IS7816_WT_Pos = 0x7
	// Bit mask of WT field.
	UART_IS7816_WT_Msk = 0x80
	// Bit WT.
	UART_IS7816_WT = 0x80
	// Wait time (WT) has not been violated.
	UART_IS7816_WT_0 = 0x0
	// Wait time (WT) has been violated.
	UART_IS7816_WT_1 = 0x1

	// WP7816T0: UART 7816 Wait Parameter Register
	// Position of WI field.
	UART_WP7816T0_WI_Pos = 0x0
	// Bit mask of WI field.
	UART_WP7816T0_WI_Msk = 0xff

	// WP7816T1: UART 7816 Wait Parameter Register
	// Position of BWI field.
	UART_WP7816T1_BWI_Pos = 0x0
	// Bit mask of BWI field.
	UART_WP7816T1_BWI_Msk = 0xf
	// Position of CWI field.
	UART_WP7816T1_CWI_Pos = 0x4
	// Bit mask of CWI field.
	UART_WP7816T1_CWI_Msk = 0xf0

	// WN7816: UART 7816 Wait N Register
	// Position of GTN field.
	UART_WN7816_GTN_Pos = 0x0
	// Bit mask of GTN field.
	UART_WN7816_GTN_Msk = 0xff

	// WF7816: UART 7816 Wait FD Register
	// Position of GTFD field.
	UART_WF7816_GTFD_Pos = 0x0
	// Bit mask of GTFD field.
	UART_WF7816_GTFD_Msk = 0xff

	// ET7816: UART 7816 Error Threshold Register
	// Position of RXTHRESHOLD field.
	UART_ET7816_RXTHRESHOLD_Pos = 0x0
	// Bit mask of RXTHRESHOLD field.
	UART_ET7816_RXTHRESHOLD_Msk = 0xf
	// Position of TXTHRESHOLD field.
	UART_ET7816_TXTHRESHOLD_Pos = 0x4
	// Bit mask of TXTHRESHOLD field.
	UART_ET7816_TXTHRESHOLD_Msk = 0xf0
	// TXT asserts on the first NACK that is received.
	UART_ET7816_TXTHRESHOLD_0 = 0x0
	// TXT asserts on the second NACK that is received.
	UART_ET7816_TXTHRESHOLD_1 = 0x1

	// TL7816: UART 7816 Transmit Length Register
	// Position of TLEN field.
	UART_TL7816_TLEN_Pos = 0x0
	// Bit mask of TLEN field.
	UART_TL7816_TLEN_Msk = 0xff
)

// Constants for USB0: Universal Serial Bus, OTG Capable Controller
const (
	// PERID: Peripheral ID register
	// Position of ID field.
	USB0_PERID_ID_Pos = 0x0
	// Bit mask of ID field.
	USB0_PERID_ID_Msk = 0x3f

	// IDCOMP: Peripheral ID Complement register
	// Position of NID field.
	USB0_IDCOMP_NID_Pos = 0x0
	// Bit mask of NID field.
	USB0_IDCOMP_NID_Msk = 0x3f

	// REV: Peripheral Revision register
	// Position of REV field.
	USB0_REV_REV_Pos = 0x0
	// Bit mask of REV field.
	USB0_REV_REV_Msk = 0xff

	// ADDINFO: Peripheral Additional Info register
	// Position of IEHOST field.
	USB0_ADDINFO_IEHOST_Pos = 0x0
	// Bit mask of IEHOST field.
	USB0_ADDINFO_IEHOST_Msk = 0x1
	// Bit IEHOST.
	USB0_ADDINFO_IEHOST = 0x1
	// Position of IRQNUM field.
	USB0_ADDINFO_IRQNUM_Pos = 0x3
	// Bit mask of IRQNUM field.
	USB0_ADDINFO_IRQNUM_Msk = 0xf8

	// OTGISTAT: OTG Interrupt Status register
	// Position of AVBUSCHG field.
	USB0_OTGISTAT_AVBUSCHG_Pos = 0x0
	// Bit mask of AVBUSCHG field.
	USB0_OTGISTAT_AVBUSCHG_Msk = 0x1
	// Bit AVBUSCHG.
	USB0_OTGISTAT_AVBUSCHG = 0x1
	// Position of B_SESS_CHG field.
	USB0_OTGISTAT_B_SESS_CHG_Pos = 0x2
	// Bit mask of B_SESS_CHG field.
	USB0_OTGISTAT_B_SESS_CHG_Msk = 0x4
	// Bit B_SESS_CHG.
	USB0_OTGISTAT_B_SESS_CHG = 0x4
	// Position of SESSVLDCHG field.
	USB0_OTGISTAT_SESSVLDCHG_Pos = 0x3
	// Bit mask of SESSVLDCHG field.
	USB0_OTGISTAT_SESSVLDCHG_Msk = 0x8
	// Bit SESSVLDCHG.
	USB0_OTGISTAT_SESSVLDCHG = 0x8
	// Position of LINE_STATE_CHG field.
	USB0_OTGISTAT_LINE_STATE_CHG_Pos = 0x5
	// Bit mask of LINE_STATE_CHG field.
	USB0_OTGISTAT_LINE_STATE_CHG_Msk = 0x20
	// Bit LINE_STATE_CHG.
	USB0_OTGISTAT_LINE_STATE_CHG = 0x20
	// Position of ONEMSEC field.
	USB0_OTGISTAT_ONEMSEC_Pos = 0x6
	// Bit mask of ONEMSEC field.
	USB0_OTGISTAT_ONEMSEC_Msk = 0x40
	// Bit ONEMSEC.
	USB0_OTGISTAT_ONEMSEC = 0x40
	// Position of IDCHG field.
	USB0_OTGISTAT_IDCHG_Pos = 0x7
	// Bit mask of IDCHG field.
	USB0_OTGISTAT_IDCHG_Msk = 0x80
	// Bit IDCHG.
	USB0_OTGISTAT_IDCHG = 0x80

	// OTGICR: OTG Interrupt Control register
	// Position of AVBUSEN field.
	USB0_OTGICR_AVBUSEN_Pos = 0x0
	// Bit mask of AVBUSEN field.
	USB0_OTGICR_AVBUSEN_Msk = 0x1
	// Bit AVBUSEN.
	USB0_OTGICR_AVBUSEN = 0x1
	// Disables the AVBUSCHG interrupt.
	USB0_OTGICR_AVBUSEN_0 = 0x0
	// Enables the AVBUSCHG interrupt.
	USB0_OTGICR_AVBUSEN_1 = 0x1
	// Position of BSESSEN field.
	USB0_OTGICR_BSESSEN_Pos = 0x2
	// Bit mask of BSESSEN field.
	USB0_OTGICR_BSESSEN_Msk = 0x4
	// Bit BSESSEN.
	USB0_OTGICR_BSESSEN = 0x4
	// Disables the B_SESS_CHG interrupt.
	USB0_OTGICR_BSESSEN_0 = 0x0
	// Enables the B_SESS_CHG interrupt.
	USB0_OTGICR_BSESSEN_1 = 0x1
	// Position of SESSVLDEN field.
	USB0_OTGICR_SESSVLDEN_Pos = 0x3
	// Bit mask of SESSVLDEN field.
	USB0_OTGICR_SESSVLDEN_Msk = 0x8
	// Bit SESSVLDEN.
	USB0_OTGICR_SESSVLDEN = 0x8
	// Disables the SESSVLDCHG interrupt.
	USB0_OTGICR_SESSVLDEN_0 = 0x0
	// Enables the SESSVLDCHG interrupt.
	USB0_OTGICR_SESSVLDEN_1 = 0x1
	// Position of LINESTATEEN field.
	USB0_OTGICR_LINESTATEEN_Pos = 0x5
	// Bit mask of LINESTATEEN field.
	USB0_OTGICR_LINESTATEEN_Msk = 0x20
	// Bit LINESTATEEN.
	USB0_OTGICR_LINESTATEEN = 0x20
	// Disables the LINE_STAT_CHG interrupt.
	USB0_OTGICR_LINESTATEEN_0 = 0x0
	// Enables the LINE_STAT_CHG interrupt.
	USB0_OTGICR_LINESTATEEN_1 = 0x1
	// Position of ONEMSECEN field.
	USB0_OTGICR_ONEMSECEN_Pos = 0x6
	// Bit mask of ONEMSECEN field.
	USB0_OTGICR_ONEMSECEN_Msk = 0x40
	// Bit ONEMSECEN.
	USB0_OTGICR_ONEMSECEN = 0x40
	// Diables the 1ms timer interrupt.
	USB0_OTGICR_ONEMSECEN_0 = 0x0
	// Enables the 1ms timer interrupt.
	USB0_OTGICR_ONEMSECEN_1 = 0x1
	// Position of IDEN field.
	USB0_OTGICR_IDEN_Pos = 0x7
	// Bit mask of IDEN field.
	USB0_OTGICR_IDEN_Msk = 0x80
	// Bit IDEN.
	USB0_OTGICR_IDEN = 0x80
	// The ID interrupt is disabled
	USB0_OTGICR_IDEN_0 = 0x0
	// The ID interrupt is enabled
	USB0_OTGICR_IDEN_1 = 0x1

	// OTGSTAT: OTG Status register
	// Position of AVBUSVLD field.
	USB0_OTGSTAT_AVBUSVLD_Pos = 0x0
	// Bit mask of AVBUSVLD field.
	USB0_OTGSTAT_AVBUSVLD_Msk = 0x1
	// Bit AVBUSVLD.
	USB0_OTGSTAT_AVBUSVLD = 0x1
	// The VBUS voltage is below the A VBUS Valid threshold.
	USB0_OTGSTAT_AVBUSVLD_0 = 0x0
	// The VBUS voltage is above the A VBUS Valid threshold.
	USB0_OTGSTAT_AVBUSVLD_1 = 0x1
	// Position of BSESSEND field.
	USB0_OTGSTAT_BSESSEND_Pos = 0x2
	// Bit mask of BSESSEND field.
	USB0_OTGSTAT_BSESSEND_Msk = 0x4
	// Bit BSESSEND.
	USB0_OTGSTAT_BSESSEND = 0x4
	// The VBUS voltage is above the B session end threshold.
	USB0_OTGSTAT_BSESSEND_0 = 0x0
	// The VBUS voltage is below the B session end threshold.
	USB0_OTGSTAT_BSESSEND_1 = 0x1
	// Position of SESS_VLD field.
	USB0_OTGSTAT_SESS_VLD_Pos = 0x3
	// Bit mask of SESS_VLD field.
	USB0_OTGSTAT_SESS_VLD_Msk = 0x8
	// Bit SESS_VLD.
	USB0_OTGSTAT_SESS_VLD = 0x8
	// The VBUS voltage is below the B session valid threshold
	USB0_OTGSTAT_SESS_VLD_0 = 0x0
	// The VBUS voltage is above the B session valid threshold.
	USB0_OTGSTAT_SESS_VLD_1 = 0x1
	// Position of LINESTATESTABLE field.
	USB0_OTGSTAT_LINESTATESTABLE_Pos = 0x5
	// Bit mask of LINESTATESTABLE field.
	USB0_OTGSTAT_LINESTATESTABLE_Msk = 0x20
	// Bit LINESTATESTABLE.
	USB0_OTGSTAT_LINESTATESTABLE = 0x20
	// The LINE_STAT_CHG bit is not yet stable.
	USB0_OTGSTAT_LINESTATESTABLE_0 = 0x0
	// The LINE_STAT_CHG bit has been debounced and is stable.
	USB0_OTGSTAT_LINESTATESTABLE_1 = 0x1
	// Position of ONEMSECEN field.
	USB0_OTGSTAT_ONEMSECEN_Pos = 0x6
	// Bit mask of ONEMSECEN field.
	USB0_OTGSTAT_ONEMSECEN_Msk = 0x40
	// Bit ONEMSECEN.
	USB0_OTGSTAT_ONEMSECEN = 0x40
	// Position of ID field.
	USB0_OTGSTAT_ID_Pos = 0x7
	// Bit mask of ID field.
	USB0_OTGSTAT_ID_Msk = 0x80
	// Bit ID.
	USB0_OTGSTAT_ID = 0x80
	// Indicates a Type A cable is plugged into the USB connector.
	USB0_OTGSTAT_ID_0 = 0x0
	// Indicates no cable is attached or a Type B cable is plugged into the USB connector.
	USB0_OTGSTAT_ID_1 = 0x1

	// OTGCTL: OTG Control register
	// Position of OTGEN field.
	USB0_OTGCTL_OTGEN_Pos = 0x2
	// Bit mask of OTGEN field.
	USB0_OTGCTL_OTGEN_Msk = 0x4
	// Bit OTGEN.
	USB0_OTGCTL_OTGEN = 0x4
	// If USB_EN is 1 and HOST_MODE is 0 in the Control Register (CTL), then the D+ Data Line pull-up resistors are enabled. If HOST_MODE is 1 the D+ and D- Data Line pull-down resistors are engaged.
	USB0_OTGCTL_OTGEN_0 = 0x0
	// The pull-up and pull-down controls in this register are used.
	USB0_OTGCTL_OTGEN_1 = 0x1
	// Position of DMLOW field.
	USB0_OTGCTL_DMLOW_Pos = 0x4
	// Bit mask of DMLOW field.
	USB0_OTGCTL_DMLOW_Msk = 0x10
	// Bit DMLOW.
	USB0_OTGCTL_DMLOW = 0x10
	// D- pulldown resistor is not enabled.
	USB0_OTGCTL_DMLOW_0 = 0x0
	// D- pulldown resistor is enabled.
	USB0_OTGCTL_DMLOW_1 = 0x1
	// Position of DPLOW field.
	USB0_OTGCTL_DPLOW_Pos = 0x5
	// Bit mask of DPLOW field.
	USB0_OTGCTL_DPLOW_Msk = 0x20
	// Bit DPLOW.
	USB0_OTGCTL_DPLOW = 0x20
	// D+ pulldown resistor is not enabled.
	USB0_OTGCTL_DPLOW_0 = 0x0
	// D+ pulldown resistor is enabled.
	USB0_OTGCTL_DPLOW_1 = 0x1
	// Position of DPHIGH field.
	USB0_OTGCTL_DPHIGH_Pos = 0x7
	// Bit mask of DPHIGH field.
	USB0_OTGCTL_DPHIGH_Msk = 0x80
	// Bit DPHIGH.
	USB0_OTGCTL_DPHIGH = 0x80
	// D+ pullup resistor is not enabled
	USB0_OTGCTL_DPHIGH_0 = 0x0
	// D+ pullup resistor is enabled
	USB0_OTGCTL_DPHIGH_1 = 0x1

	// ISTAT: Interrupt Status register
	// Position of USBRST field.
	USB0_ISTAT_USBRST_Pos = 0x0
	// Bit mask of USBRST field.
	USB0_ISTAT_USBRST_Msk = 0x1
	// Bit USBRST.
	USB0_ISTAT_USBRST = 0x1
	// Position of ERROR field.
	USB0_ISTAT_ERROR_Pos = 0x1
	// Bit mask of ERROR field.
	USB0_ISTAT_ERROR_Msk = 0x2
	// Bit ERROR.
	USB0_ISTAT_ERROR = 0x2
	// Position of SOFTOK field.
	USB0_ISTAT_SOFTOK_Pos = 0x2
	// Bit mask of SOFTOK field.
	USB0_ISTAT_SOFTOK_Msk = 0x4
	// Bit SOFTOK.
	USB0_ISTAT_SOFTOK = 0x4
	// Position of TOKDNE field.
	USB0_ISTAT_TOKDNE_Pos = 0x3
	// Bit mask of TOKDNE field.
	USB0_ISTAT_TOKDNE_Msk = 0x8
	// Bit TOKDNE.
	USB0_ISTAT_TOKDNE = 0x8
	// Position of SLEEP field.
	USB0_ISTAT_SLEEP_Pos = 0x4
	// Bit mask of SLEEP field.
	USB0_ISTAT_SLEEP_Msk = 0x10
	// Bit SLEEP.
	USB0_ISTAT_SLEEP = 0x10
	// Position of RESUME field.
	USB0_ISTAT_RESUME_Pos = 0x5
	// Bit mask of RESUME field.
	USB0_ISTAT_RESUME_Msk = 0x20
	// Bit RESUME.
	USB0_ISTAT_RESUME = 0x20
	// Position of ATTACH field.
	USB0_ISTAT_ATTACH_Pos = 0x6
	// Bit mask of ATTACH field.
	USB0_ISTAT_ATTACH_Msk = 0x40
	// Bit ATTACH.
	USB0_ISTAT_ATTACH = 0x40
	// Position of STALL field.
	USB0_ISTAT_STALL_Pos = 0x7
	// Bit mask of STALL field.
	USB0_ISTAT_STALL_Msk = 0x80
	// Bit STALL.
	USB0_ISTAT_STALL = 0x80

	// INTEN: Interrupt Enable register
	// Position of USBRSTEN field.
	USB0_INTEN_USBRSTEN_Pos = 0x0
	// Bit mask of USBRSTEN field.
	USB0_INTEN_USBRSTEN_Msk = 0x1
	// Bit USBRSTEN.
	USB0_INTEN_USBRSTEN = 0x1
	// Disables the USBRST interrupt.
	USB0_INTEN_USBRSTEN_0 = 0x0
	// Enables the USBRST interrupt.
	USB0_INTEN_USBRSTEN_1 = 0x1
	// Position of ERROREN field.
	USB0_INTEN_ERROREN_Pos = 0x1
	// Bit mask of ERROREN field.
	USB0_INTEN_ERROREN_Msk = 0x2
	// Bit ERROREN.
	USB0_INTEN_ERROREN = 0x2
	// Disables the ERROR interrupt.
	USB0_INTEN_ERROREN_0 = 0x0
	// Enables the ERROR interrupt.
	USB0_INTEN_ERROREN_1 = 0x1
	// Position of SOFTOKEN field.
	USB0_INTEN_SOFTOKEN_Pos = 0x2
	// Bit mask of SOFTOKEN field.
	USB0_INTEN_SOFTOKEN_Msk = 0x4
	// Bit SOFTOKEN.
	USB0_INTEN_SOFTOKEN = 0x4
	// Disbles the SOFTOK interrupt.
	USB0_INTEN_SOFTOKEN_0 = 0x0
	// Enables the SOFTOK interrupt.
	USB0_INTEN_SOFTOKEN_1 = 0x1
	// Position of TOKDNEEN field.
	USB0_INTEN_TOKDNEEN_Pos = 0x3
	// Bit mask of TOKDNEEN field.
	USB0_INTEN_TOKDNEEN_Msk = 0x8
	// Bit TOKDNEEN.
	USB0_INTEN_TOKDNEEN = 0x8
	// Disables the TOKDNE interrupt.
	USB0_INTEN_TOKDNEEN_0 = 0x0
	// Enables the TOKDNE interrupt.
	USB0_INTEN_TOKDNEEN_1 = 0x1
	// Position of SLEEPEN field.
	USB0_INTEN_SLEEPEN_Pos = 0x4
	// Bit mask of SLEEPEN field.
	USB0_INTEN_SLEEPEN_Msk = 0x10
	// Bit SLEEPEN.
	USB0_INTEN_SLEEPEN = 0x10
	// Disables the SLEEP interrupt.
	USB0_INTEN_SLEEPEN_0 = 0x0
	// Enables the SLEEP interrupt.
	USB0_INTEN_SLEEPEN_1 = 0x1
	// Position of RESUMEEN field.
	USB0_INTEN_RESUMEEN_Pos = 0x5
	// Bit mask of RESUMEEN field.
	USB0_INTEN_RESUMEEN_Msk = 0x20
	// Bit RESUMEEN.
	USB0_INTEN_RESUMEEN = 0x20
	// Disables the RESUME interrupt.
	USB0_INTEN_RESUMEEN_0 = 0x0
	// Enables the RESUME interrupt.
	USB0_INTEN_RESUMEEN_1 = 0x1
	// Position of ATTACHEN field.
	USB0_INTEN_ATTACHEN_Pos = 0x6
	// Bit mask of ATTACHEN field.
	USB0_INTEN_ATTACHEN_Msk = 0x40
	// Bit ATTACHEN.
	USB0_INTEN_ATTACHEN = 0x40
	// Disables the ATTACH interrupt.
	USB0_INTEN_ATTACHEN_0 = 0x0
	// Enables the ATTACH interrupt.
	USB0_INTEN_ATTACHEN_1 = 0x1
	// Position of STALLEN field.
	USB0_INTEN_STALLEN_Pos = 0x7
	// Bit mask of STALLEN field.
	USB0_INTEN_STALLEN_Msk = 0x80
	// Bit STALLEN.
	USB0_INTEN_STALLEN = 0x80
	// Diasbles the STALL interrupt.
	USB0_INTEN_STALLEN_0 = 0x0
	// Enables the STALL interrupt.
	USB0_INTEN_STALLEN_1 = 0x1

	// ERRSTAT: Error Interrupt Status register
	// Position of PIDERR field.
	USB0_ERRSTAT_PIDERR_Pos = 0x0
	// Bit mask of PIDERR field.
	USB0_ERRSTAT_PIDERR_Msk = 0x1
	// Bit PIDERR.
	USB0_ERRSTAT_PIDERR = 0x1
	// Position of CRC5EOF field.
	USB0_ERRSTAT_CRC5EOF_Pos = 0x1
	// Bit mask of CRC5EOF field.
	USB0_ERRSTAT_CRC5EOF_Msk = 0x2
	// Bit CRC5EOF.
	USB0_ERRSTAT_CRC5EOF = 0x2
	// Position of CRC16 field.
	USB0_ERRSTAT_CRC16_Pos = 0x2
	// Bit mask of CRC16 field.
	USB0_ERRSTAT_CRC16_Msk = 0x4
	// Bit CRC16.
	USB0_ERRSTAT_CRC16 = 0x4
	// Position of DFN8 field.
	USB0_ERRSTAT_DFN8_Pos = 0x3
	// Bit mask of DFN8 field.
	USB0_ERRSTAT_DFN8_Msk = 0x8
	// Bit DFN8.
	USB0_ERRSTAT_DFN8 = 0x8
	// Position of BTOERR field.
	USB0_ERRSTAT_BTOERR_Pos = 0x4
	// Bit mask of BTOERR field.
	USB0_ERRSTAT_BTOERR_Msk = 0x10
	// Bit BTOERR.
	USB0_ERRSTAT_BTOERR = 0x10
	// Position of DMAERR field.
	USB0_ERRSTAT_DMAERR_Pos = 0x5
	// Bit mask of DMAERR field.
	USB0_ERRSTAT_DMAERR_Msk = 0x20
	// Bit DMAERR.
	USB0_ERRSTAT_DMAERR = 0x20
	// Position of BTSERR field.
	USB0_ERRSTAT_BTSERR_Pos = 0x7
	// Bit mask of BTSERR field.
	USB0_ERRSTAT_BTSERR_Msk = 0x80
	// Bit BTSERR.
	USB0_ERRSTAT_BTSERR = 0x80

	// ERREN: Error Interrupt Enable register
	// Position of PIDERREN field.
	USB0_ERREN_PIDERREN_Pos = 0x0
	// Bit mask of PIDERREN field.
	USB0_ERREN_PIDERREN_Msk = 0x1
	// Bit PIDERREN.
	USB0_ERREN_PIDERREN = 0x1
	// Disables the PIDERR interrupt.
	USB0_ERREN_PIDERREN_0 = 0x0
	// Enters the PIDERR interrupt.
	USB0_ERREN_PIDERREN_1 = 0x1
	// Position of CRC5EOFEN field.
	USB0_ERREN_CRC5EOFEN_Pos = 0x1
	// Bit mask of CRC5EOFEN field.
	USB0_ERREN_CRC5EOFEN_Msk = 0x2
	// Bit CRC5EOFEN.
	USB0_ERREN_CRC5EOFEN = 0x2
	// Disables the CRC5/EOF interrupt.
	USB0_ERREN_CRC5EOFEN_0 = 0x0
	// Enables the CRC5/EOF interrupt.
	USB0_ERREN_CRC5EOFEN_1 = 0x1
	// Position of CRC16EN field.
	USB0_ERREN_CRC16EN_Pos = 0x2
	// Bit mask of CRC16EN field.
	USB0_ERREN_CRC16EN_Msk = 0x4
	// Bit CRC16EN.
	USB0_ERREN_CRC16EN = 0x4
	// Disables the CRC16 interrupt.
	USB0_ERREN_CRC16EN_0 = 0x0
	// Enables the CRC16 interrupt.
	USB0_ERREN_CRC16EN_1 = 0x1
	// Position of DFN8EN field.
	USB0_ERREN_DFN8EN_Pos = 0x3
	// Bit mask of DFN8EN field.
	USB0_ERREN_DFN8EN_Msk = 0x8
	// Bit DFN8EN.
	USB0_ERREN_DFN8EN = 0x8
	// Disables the DFN8 interrupt.
	USB0_ERREN_DFN8EN_0 = 0x0
	// Enables the DFN8 interrupt.
	USB0_ERREN_DFN8EN_1 = 0x1
	// Position of BTOERREN field.
	USB0_ERREN_BTOERREN_Pos = 0x4
	// Bit mask of BTOERREN field.
	USB0_ERREN_BTOERREN_Msk = 0x10
	// Bit BTOERREN.
	USB0_ERREN_BTOERREN = 0x10
	// Disables the BTOERR interrupt.
	USB0_ERREN_BTOERREN_0 = 0x0
	// Enables the BTOERR interrupt.
	USB0_ERREN_BTOERREN_1 = 0x1
	// Position of DMAERREN field.
	USB0_ERREN_DMAERREN_Pos = 0x5
	// Bit mask of DMAERREN field.
	USB0_ERREN_DMAERREN_Msk = 0x20
	// Bit DMAERREN.
	USB0_ERREN_DMAERREN = 0x20
	// Disables the DMAERR interrupt.
	USB0_ERREN_DMAERREN_0 = 0x0
	// Enables the DMAERR interrupt.
	USB0_ERREN_DMAERREN_1 = 0x1
	// Position of BTSERREN field.
	USB0_ERREN_BTSERREN_Pos = 0x7
	// Bit mask of BTSERREN field.
	USB0_ERREN_BTSERREN_Msk = 0x80
	// Bit BTSERREN.
	USB0_ERREN_BTSERREN = 0x80
	// Disables the BTSERR interrupt.
	USB0_ERREN_BTSERREN_0 = 0x0
	// Enables the BTSERR interrupt.
	USB0_ERREN_BTSERREN_1 = 0x1

	// STAT: Status register
	// Position of ODD field.
	USB0_STAT_ODD_Pos = 0x2
	// Bit mask of ODD field.
	USB0_STAT_ODD_Msk = 0x4
	// Bit ODD.
	USB0_STAT_ODD = 0x4
	// Position of TX field.
	USB0_STAT_TX_Pos = 0x3
	// Bit mask of TX field.
	USB0_STAT_TX_Msk = 0x8
	// Bit TX.
	USB0_STAT_TX = 0x8
	// The most recent transaction was a receive operation.
	USB0_STAT_TX_0 = 0x0
	// The most recent transaction was a transmit operation.
	USB0_STAT_TX_1 = 0x1
	// Position of ENDP field.
	USB0_STAT_ENDP_Pos = 0x4
	// Bit mask of ENDP field.
	USB0_STAT_ENDP_Msk = 0xf0

	// CTL: Control register
	// Position of USBENSOFEN field.
	USB0_CTL_USBENSOFEN_Pos = 0x0
	// Bit mask of USBENSOFEN field.
	USB0_CTL_USBENSOFEN_Msk = 0x1
	// Bit USBENSOFEN.
	USB0_CTL_USBENSOFEN = 0x1
	// Disables the USB Module.
	USB0_CTL_USBENSOFEN_0 = 0x0
	// Enables the USB Module.
	USB0_CTL_USBENSOFEN_1 = 0x1
	// Position of ODDRST field.
	USB0_CTL_ODDRST_Pos = 0x1
	// Bit mask of ODDRST field.
	USB0_CTL_ODDRST_Msk = 0x2
	// Bit ODDRST.
	USB0_CTL_ODDRST = 0x2
	// Position of RESUME field.
	USB0_CTL_RESUME_Pos = 0x2
	// Bit mask of RESUME field.
	USB0_CTL_RESUME_Msk = 0x4
	// Bit RESUME.
	USB0_CTL_RESUME = 0x4
	// Position of HOSTMODEEN field.
	USB0_CTL_HOSTMODEEN_Pos = 0x3
	// Bit mask of HOSTMODEEN field.
	USB0_CTL_HOSTMODEEN_Msk = 0x8
	// Bit HOSTMODEEN.
	USB0_CTL_HOSTMODEEN = 0x8
	// Position of RESET field.
	USB0_CTL_RESET_Pos = 0x4
	// Bit mask of RESET field.
	USB0_CTL_RESET_Msk = 0x10
	// Bit RESET.
	USB0_CTL_RESET = 0x10
	// Position of TXSUSPENDTOKENBUSY field.
	USB0_CTL_TXSUSPENDTOKENBUSY_Pos = 0x5
	// Bit mask of TXSUSPENDTOKENBUSY field.
	USB0_CTL_TXSUSPENDTOKENBUSY_Msk = 0x20
	// Bit TXSUSPENDTOKENBUSY.
	USB0_CTL_TXSUSPENDTOKENBUSY = 0x20
	// Position of SE0 field.
	USB0_CTL_SE0_Pos = 0x6
	// Bit mask of SE0 field.
	USB0_CTL_SE0_Msk = 0x40
	// Bit SE0.
	USB0_CTL_SE0 = 0x40
	// Position of JSTATE field.
	USB0_CTL_JSTATE_Pos = 0x7
	// Bit mask of JSTATE field.
	USB0_CTL_JSTATE_Msk = 0x80
	// Bit JSTATE.
	USB0_CTL_JSTATE = 0x80

	// ADDR: Address register
	// Position of ADDR field.
	USB0_ADDR_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	USB0_ADDR_ADDR_Msk = 0x7f
	// Position of LSEN field.
	USB0_ADDR_LSEN_Pos = 0x7
	// Bit mask of LSEN field.
	USB0_ADDR_LSEN_Msk = 0x80
	// Bit LSEN.
	USB0_ADDR_LSEN = 0x80

	// BDTPAGE1: BDT Page register 1
	// Position of BDTBA field.
	USB0_BDTPAGE1_BDTBA_Pos = 0x1
	// Bit mask of BDTBA field.
	USB0_BDTPAGE1_BDTBA_Msk = 0xfe

	// FRMNUML: Frame Number register Low
	// Position of FRM field.
	USB0_FRMNUML_FRM_Pos = 0x0
	// Bit mask of FRM field.
	USB0_FRMNUML_FRM_Msk = 0xff

	// FRMNUMH: Frame Number register High
	// Position of FRM field.
	USB0_FRMNUMH_FRM_Pos = 0x0
	// Bit mask of FRM field.
	USB0_FRMNUMH_FRM_Msk = 0x7

	// TOKEN: Token register
	// Position of TOKENENDPT field.
	USB0_TOKEN_TOKENENDPT_Pos = 0x0
	// Bit mask of TOKENENDPT field.
	USB0_TOKEN_TOKENENDPT_Msk = 0xf
	// Position of TOKENPID field.
	USB0_TOKEN_TOKENPID_Pos = 0x4
	// Bit mask of TOKENPID field.
	USB0_TOKEN_TOKENPID_Msk = 0xf0
	// OUT Token. USB Module performs an OUT (TX) transaction.
	USB0_TOKEN_TOKENPID_0001 = 0x1
	// IN Token. USB Module performs an In (RX) transaction.
	USB0_TOKEN_TOKENPID_1001 = 0x9
	// SETUP Token. USB Module performs a SETUP (TX) transaction
	USB0_TOKEN_TOKENPID_1101 = 0xd

	// SOFTHLD: SOF Threshold register
	// Position of CNT field.
	USB0_SOFTHLD_CNT_Pos = 0x0
	// Bit mask of CNT field.
	USB0_SOFTHLD_CNT_Msk = 0xff

	// BDTPAGE2: BDT Page Register 2
	// Position of BDTBA field.
	USB0_BDTPAGE2_BDTBA_Pos = 0x0
	// Bit mask of BDTBA field.
	USB0_BDTPAGE2_BDTBA_Msk = 0xff

	// BDTPAGE3: BDT Page Register 3
	// Position of BDTBA field.
	USB0_BDTPAGE3_BDTBA_Pos = 0x0
	// Bit mask of BDTBA field.
	USB0_BDTPAGE3_BDTBA_Msk = 0xff

	// ENDPT0: Endpoint Control register
	// Position of EPHSHK field.
	USB0_ENDPT_EPHSHK_Pos = 0x0
	// Bit mask of EPHSHK field.
	USB0_ENDPT_EPHSHK_Msk = 0x1
	// Bit EPHSHK.
	USB0_ENDPT_EPHSHK = 0x1
	// Position of EPSTALL field.
	USB0_ENDPT_EPSTALL_Pos = 0x1
	// Bit mask of EPSTALL field.
	USB0_ENDPT_EPSTALL_Msk = 0x2
	// Bit EPSTALL.
	USB0_ENDPT_EPSTALL = 0x2
	// Position of EPTXEN field.
	USB0_ENDPT_EPTXEN_Pos = 0x2
	// Bit mask of EPTXEN field.
	USB0_ENDPT_EPTXEN_Msk = 0x4
	// Bit EPTXEN.
	USB0_ENDPT_EPTXEN = 0x4
	// Position of EPRXEN field.
	USB0_ENDPT_EPRXEN_Pos = 0x3
	// Bit mask of EPRXEN field.
	USB0_ENDPT_EPRXEN_Msk = 0x8
	// Bit EPRXEN.
	USB0_ENDPT_EPRXEN = 0x8
	// Position of EPCTLDIS field.
	USB0_ENDPT_EPCTLDIS_Pos = 0x4
	// Bit mask of EPCTLDIS field.
	USB0_ENDPT_EPCTLDIS_Msk = 0x10
	// Bit EPCTLDIS.
	USB0_ENDPT_EPCTLDIS = 0x10
	// Position of RETRYDIS field.
	USB0_ENDPT_RETRYDIS_Pos = 0x6
	// Bit mask of RETRYDIS field.
	USB0_ENDPT_RETRYDIS_Msk = 0x40
	// Bit RETRYDIS.
	USB0_ENDPT_RETRYDIS = 0x40
	// Position of HOSTWOHUB field.
	USB0_ENDPT_HOSTWOHUB_Pos = 0x7
	// Bit mask of HOSTWOHUB field.
	USB0_ENDPT_HOSTWOHUB_Msk = 0x80
	// Bit HOSTWOHUB.
	USB0_ENDPT_HOSTWOHUB = 0x80

	// USBCTRL: USB Control register
	// Position of PDE field.
	USB0_USBCTRL_PDE_Pos = 0x6
	// Bit mask of PDE field.
	USB0_USBCTRL_PDE_Msk = 0x40
	// Bit PDE.
	USB0_USBCTRL_PDE = 0x40
	// Weak pulldowns are disabled on D+ and D-.
	USB0_USBCTRL_PDE_0 = 0x0
	// Weak pulldowns are enabled on D+ and D-.
	USB0_USBCTRL_PDE_1 = 0x1
	// Position of SUSP field.
	USB0_USBCTRL_SUSP_Pos = 0x7
	// Bit mask of SUSP field.
	USB0_USBCTRL_SUSP_Msk = 0x80
	// Bit SUSP.
	USB0_USBCTRL_SUSP = 0x80
	// USB transceiver is not in suspend state.
	USB0_USBCTRL_SUSP_0 = 0x0
	// USB transceiver is in suspend state.
	USB0_USBCTRL_SUSP_1 = 0x1

	// OBSERVE: USB OTG Observe register
	// Position of DMPD field.
	USB0_OBSERVE_DMPD_Pos = 0x4
	// Bit mask of DMPD field.
	USB0_OBSERVE_DMPD_Msk = 0x10
	// Bit DMPD.
	USB0_OBSERVE_DMPD = 0x10
	// D- pulldown disabled.
	USB0_OBSERVE_DMPD_0 = 0x0
	// D- pulldown enabled.
	USB0_OBSERVE_DMPD_1 = 0x1
	// Position of DPPD field.
	USB0_OBSERVE_DPPD_Pos = 0x6
	// Bit mask of DPPD field.
	USB0_OBSERVE_DPPD_Msk = 0x40
	// Bit DPPD.
	USB0_OBSERVE_DPPD = 0x40
	// D+ pulldown disabled.
	USB0_OBSERVE_DPPD_0 = 0x0
	// D+ pulldown enabled.
	USB0_OBSERVE_DPPD_1 = 0x1
	// Position of DPPU field.
	USB0_OBSERVE_DPPU_Pos = 0x7
	// Bit mask of DPPU field.
	USB0_OBSERVE_DPPU_Msk = 0x80
	// Bit DPPU.
	USB0_OBSERVE_DPPU = 0x80
	// D+ pullup disabled.
	USB0_OBSERVE_DPPU_0 = 0x0
	// D+ pullup enabled.
	USB0_OBSERVE_DPPU_1 = 0x1

	// CONTROL: USB OTG Control register
	// Position of DPPULLUPNONOTG field.
	USB0_CONTROL_DPPULLUPNONOTG_Pos = 0x4
	// Bit mask of DPPULLUPNONOTG field.
	USB0_CONTROL_DPPULLUPNONOTG_Msk = 0x10
	// Bit DPPULLUPNONOTG.
	USB0_CONTROL_DPPULLUPNONOTG = 0x10
	// DP Pullup in non-OTG device mode is not enabled.
	USB0_CONTROL_DPPULLUPNONOTG_0 = 0x0
	// DP Pullup in non-OTG device mode is enabled.
	USB0_CONTROL_DPPULLUPNONOTG_1 = 0x1

	// USBTRC0: USB Transceiver Control register 0
	// Position of USB_RESUME_INT field.
	USB0_USBTRC0_USB_RESUME_INT_Pos = 0x0
	// Bit mask of USB_RESUME_INT field.
	USB0_USBTRC0_USB_RESUME_INT_Msk = 0x1
	// Bit USB_RESUME_INT.
	USB0_USBTRC0_USB_RESUME_INT = 0x1
	// No interrupt was generated.
	USB0_USBTRC0_USB_RESUME_INT_0 = 0x0
	// Interrupt was generated because of the USB asynchronous interrupt.
	USB0_USBTRC0_USB_RESUME_INT_1 = 0x1
	// Position of SYNC_DET field.
	USB0_USBTRC0_SYNC_DET_Pos = 0x1
	// Bit mask of SYNC_DET field.
	USB0_USBTRC0_SYNC_DET_Msk = 0x2
	// Bit SYNC_DET.
	USB0_USBTRC0_SYNC_DET = 0x2
	// Synchronous interrupt has not been detected.
	USB0_USBTRC0_SYNC_DET_0 = 0x0
	// Synchronous interrupt has been detected.
	USB0_USBTRC0_SYNC_DET_1 = 0x1
	// Position of USB_CLK_RECOVERY_INT field.
	USB0_USBTRC0_USB_CLK_RECOVERY_INT_Pos = 0x2
	// Bit mask of USB_CLK_RECOVERY_INT field.
	USB0_USBTRC0_USB_CLK_RECOVERY_INT_Msk = 0x4
	// Bit USB_CLK_RECOVERY_INT.
	USB0_USBTRC0_USB_CLK_RECOVERY_INT = 0x4
	// Position of USBRESMEN field.
	USB0_USBTRC0_USBRESMEN_Pos = 0x5
	// Bit mask of USBRESMEN field.
	USB0_USBTRC0_USBRESMEN_Msk = 0x20
	// Bit USBRESMEN.
	USB0_USBTRC0_USBRESMEN = 0x20
	// USB asynchronous wakeup from suspend mode disabled.
	USB0_USBTRC0_USBRESMEN_0 = 0x0
	// USB asynchronous wakeup from suspend mode enabled. The asynchronous resume interrupt differs from the synchronous resume interrupt in that it asynchronously detects K-state using the unfiltered state of the D+ and D- pins. This interrupt should only be enabled when the Transceiver is suspended.
	USB0_USBTRC0_USBRESMEN_1 = 0x1
	// Position of USBRESET field.
	USB0_USBTRC0_USBRESET_Pos = 0x7
	// Bit mask of USBRESET field.
	USB0_USBTRC0_USBRESET_Msk = 0x80
	// Bit USBRESET.
	USB0_USBTRC0_USBRESET = 0x80
	// Normal USB module operation.
	USB0_USBTRC0_USBRESET_0 = 0x0
	// Returns the USB module to its reset state.
	USB0_USBTRC0_USBRESET_1 = 0x1

	// USBFRMADJUST: Frame Adjust Register
	// Position of ADJ field.
	USB0_USBFRMADJUST_ADJ_Pos = 0x0
	// Bit mask of ADJ field.
	USB0_USBFRMADJUST_ADJ_Msk = 0xff

	// CLK_RECOVER_CTRL: USB Clock recovery control
	// Position of RESTART_IFRTRIM_EN field.
	USB0_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN_Pos = 0x5
	// Bit mask of RESTART_IFRTRIM_EN field.
	USB0_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN_Msk = 0x20
	// Bit RESTART_IFRTRIM_EN.
	USB0_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN = 0x20
	// Trim fine adjustment always works based on the previous updated trim fine value (default)
	USB0_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN_0 = 0x0
	// Trim fine restarts from the IFR trim value whenever bus_reset/bus_resume is detected or module enable is desasserted
	USB0_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN_1 = 0x1
	// Position of RESET_RESUME_ROUGH_EN field.
	USB0_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN_Pos = 0x6
	// Bit mask of RESET_RESUME_ROUGH_EN field.
	USB0_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN_Msk = 0x40
	// Bit RESET_RESUME_ROUGH_EN.
	USB0_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN = 0x40
	// Always works in tracking phase after the 1st time rough to track transition (default)
	USB0_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN_0 = 0x0
	// Go back to rough stage whenever bus reset or bus resume occurs
	USB0_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN_1 = 0x1
	// Position of CLOCK_RECOVER_EN field.
	USB0_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN_Pos = 0x7
	// Bit mask of CLOCK_RECOVER_EN field.
	USB0_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN_Msk = 0x80
	// Bit CLOCK_RECOVER_EN.
	USB0_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN = 0x80
	// Disable clock recovery block (default)
	USB0_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN_0 = 0x0
	// Enable clock recovery block
	USB0_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN_1 = 0x1

	// CLK_RECOVER_IRC_EN: IRC48M oscillator enable register
	// Position of REG_EN field.
	USB0_CLK_RECOVER_IRC_EN_REG_EN_Pos = 0x0
	// Bit mask of REG_EN field.
	USB0_CLK_RECOVER_IRC_EN_REG_EN_Msk = 0x1
	// Bit REG_EN.
	USB0_CLK_RECOVER_IRC_EN_REG_EN = 0x1
	// IRC48M local regulator is disabled
	USB0_CLK_RECOVER_IRC_EN_REG_EN_0 = 0x0
	// IRC48M local regulator is enabled (default)
	USB0_CLK_RECOVER_IRC_EN_REG_EN_1 = 0x1
	// Position of IRC_EN field.
	USB0_CLK_RECOVER_IRC_EN_IRC_EN_Pos = 0x1
	// Bit mask of IRC_EN field.
	USB0_CLK_RECOVER_IRC_EN_IRC_EN_Msk = 0x2
	// Bit IRC_EN.
	USB0_CLK_RECOVER_IRC_EN_IRC_EN = 0x2
	// Disable the IRC48M module (default)
	USB0_CLK_RECOVER_IRC_EN_IRC_EN_0 = 0x0
	// Enable the IRC48M module
	USB0_CLK_RECOVER_IRC_EN_IRC_EN_1 = 0x1

	// CLK_RECOVER_INT_STATUS: Clock recovery separated interrupt status
	// Position of OVF_ERROR field.
	USB0_CLK_RECOVER_INT_STATUS_OVF_ERROR_Pos = 0x4
	// Bit mask of OVF_ERROR field.
	USB0_CLK_RECOVER_INT_STATUS_OVF_ERROR_Msk = 0x10
	// Bit OVF_ERROR.
	USB0_CLK_RECOVER_INT_STATUS_OVF_ERROR = 0x10
	// No interrupt is reported
	USB0_CLK_RECOVER_INT_STATUS_OVF_ERROR_0 = 0x0
	// Unmasked interrupt has been generated
	USB0_CLK_RECOVER_INT_STATUS_OVF_ERROR_1 = 0x1
)

// Constants for CMP0: High-Speed Comparator (CMP), Voltage Reference (VREF) Digital-to-Analog Converter (DAC), and Analog Mux (ANMUX)
const (
	// CR0: CMP Control Register 0
	// Position of HYSTCTR field.
	CMP_CR0_HYSTCTR_Pos = 0x0
	// Bit mask of HYSTCTR field.
	CMP_CR0_HYSTCTR_Msk = 0x3
	// Level 0
	CMP_CR0_HYSTCTR_00 = 0x0
	// Level 1
	CMP_CR0_HYSTCTR_01 = 0x1
	// Level 2
	CMP_CR0_HYSTCTR_10 = 0x2
	// Level 3
	CMP_CR0_HYSTCTR_11 = 0x3
	// Position of FILTER_CNT field.
	CMP_CR0_FILTER_CNT_Pos = 0x4
	// Bit mask of FILTER_CNT field.
	CMP_CR0_FILTER_CNT_Msk = 0x70
	// Filter is disabled. If SE = 1, then COUT is a logic 0. This is not a legal state, and is not recommended. If SE = 0, COUT = COUTA.
	CMP_CR0_FILTER_CNT_000 = 0x0
	// One sample must agree. The comparator output is simply sampled.
	CMP_CR0_FILTER_CNT_001 = 0x1
	// 2 consecutive samples must agree.
	CMP_CR0_FILTER_CNT_010 = 0x2
	// 3 consecutive samples must agree.
	CMP_CR0_FILTER_CNT_011 = 0x3
	// 4 consecutive samples must agree.
	CMP_CR0_FILTER_CNT_100 = 0x4
	// 5 consecutive samples must agree.
	CMP_CR0_FILTER_CNT_101 = 0x5
	// 6 consecutive samples must agree.
	CMP_CR0_FILTER_CNT_110 = 0x6
	// 7 consecutive samples must agree.
	CMP_CR0_FILTER_CNT_111 = 0x7

	// CR1: CMP Control Register 1
	// Position of EN field.
	CMP_CR1_EN_Pos = 0x0
	// Bit mask of EN field.
	CMP_CR1_EN_Msk = 0x1
	// Bit EN.
	CMP_CR1_EN = 0x1
	// Analog Comparator is disabled.
	CMP_CR1_EN_0 = 0x0
	// Analog Comparator is enabled.
	CMP_CR1_EN_1 = 0x1
	// Position of OPE field.
	CMP_CR1_OPE_Pos = 0x1
	// Bit mask of OPE field.
	CMP_CR1_OPE_Msk = 0x2
	// Bit OPE.
	CMP_CR1_OPE = 0x2
	// CMPO is not available on the associated CMPO output pin. If the comparator does not own the pin, this field has no effect.
	CMP_CR1_OPE_0 = 0x0
	// CMPO is available on the associated CMPO output pin. The comparator output (CMPO) is driven out on the associated CMPO output pin if the comparator owns the pin. If the comparator does not own the field, this bit has no effect.
	CMP_CR1_OPE_1 = 0x1
	// Position of COS field.
	CMP_CR1_COS_Pos = 0x2
	// Bit mask of COS field.
	CMP_CR1_COS_Msk = 0x4
	// Bit COS.
	CMP_CR1_COS = 0x4
	// Set the filtered comparator output (CMPO) to equal COUT.
	CMP_CR1_COS_0 = 0x0
	// Set the unfiltered comparator output (CMPO) to equal COUTA.
	CMP_CR1_COS_1 = 0x1
	// Position of INV field.
	CMP_CR1_INV_Pos = 0x3
	// Bit mask of INV field.
	CMP_CR1_INV_Msk = 0x8
	// Bit INV.
	CMP_CR1_INV = 0x8
	// Does not invert the comparator output.
	CMP_CR1_INV_0 = 0x0
	// Inverts the comparator output.
	CMP_CR1_INV_1 = 0x1
	// Position of PMODE field.
	CMP_CR1_PMODE_Pos = 0x4
	// Bit mask of PMODE field.
	CMP_CR1_PMODE_Msk = 0x10
	// Bit PMODE.
	CMP_CR1_PMODE = 0x10
	// Low-Speed (LS) Comparison mode selected. In this mode, CMP has slower output propagation delay and lower current consumption.
	CMP_CR1_PMODE_0 = 0x0
	// High-Speed (HS) Comparison mode selected. In this mode, CMP has faster output propagation delay and higher current consumption.
	CMP_CR1_PMODE_1 = 0x1
	// Position of WE field.
	CMP_CR1_WE_Pos = 0x6
	// Bit mask of WE field.
	CMP_CR1_WE_Msk = 0x40
	// Bit WE.
	CMP_CR1_WE = 0x40
	// Windowing mode is not selected.
	CMP_CR1_WE_0 = 0x0
	// Windowing mode is selected.
	CMP_CR1_WE_1 = 0x1
	// Position of SE field.
	CMP_CR1_SE_Pos = 0x7
	// Bit mask of SE field.
	CMP_CR1_SE_Msk = 0x80
	// Bit SE.
	CMP_CR1_SE = 0x80
	// Sampling mode is not selected.
	CMP_CR1_SE_0 = 0x0
	// Sampling mode is selected.
	CMP_CR1_SE_1 = 0x1

	// FPR: CMP Filter Period Register
	// Position of FILT_PER field.
	CMP_FPR_FILT_PER_Pos = 0x0
	// Bit mask of FILT_PER field.
	CMP_FPR_FILT_PER_Msk = 0xff

	// SCR: CMP Status and Control Register
	// Position of COUT field.
	CMP_SCR_COUT_Pos = 0x0
	// Bit mask of COUT field.
	CMP_SCR_COUT_Msk = 0x1
	// Bit COUT.
	CMP_SCR_COUT = 0x1
	// Position of CFF field.
	CMP_SCR_CFF_Pos = 0x1
	// Bit mask of CFF field.
	CMP_SCR_CFF_Msk = 0x2
	// Bit CFF.
	CMP_SCR_CFF = 0x2
	// Falling-edge on COUT has not been detected.
	CMP_SCR_CFF_0 = 0x0
	// Falling-edge on COUT has occurred.
	CMP_SCR_CFF_1 = 0x1
	// Position of CFR field.
	CMP_SCR_CFR_Pos = 0x2
	// Bit mask of CFR field.
	CMP_SCR_CFR_Msk = 0x4
	// Bit CFR.
	CMP_SCR_CFR = 0x4
	// Rising-edge on COUT has not been detected.
	CMP_SCR_CFR_0 = 0x0
	// Rising-edge on COUT has occurred.
	CMP_SCR_CFR_1 = 0x1
	// Position of IEF field.
	CMP_SCR_IEF_Pos = 0x3
	// Bit mask of IEF field.
	CMP_SCR_IEF_Msk = 0x8
	// Bit IEF.
	CMP_SCR_IEF = 0x8
	// Interrupt is disabled.
	CMP_SCR_IEF_0 = 0x0
	// Interrupt is enabled.
	CMP_SCR_IEF_1 = 0x1
	// Position of IER field.
	CMP_SCR_IER_Pos = 0x4
	// Bit mask of IER field.
	CMP_SCR_IER_Msk = 0x10
	// Bit IER.
	CMP_SCR_IER = 0x10
	// Interrupt is disabled.
	CMP_SCR_IER_0 = 0x0
	// Interrupt is enabled.
	CMP_SCR_IER_1 = 0x1
	// Position of DMAEN field.
	CMP_SCR_DMAEN_Pos = 0x6
	// Bit mask of DMAEN field.
	CMP_SCR_DMAEN_Msk = 0x40
	// Bit DMAEN.
	CMP_SCR_DMAEN = 0x40
	// DMA is disabled.
	CMP_SCR_DMAEN_0 = 0x0
	// DMA is enabled.
	CMP_SCR_DMAEN_1 = 0x1

	// DACCR: DAC Control Register
	// Position of VOSEL field.
	CMP_DACCR_VOSEL_Pos = 0x0
	// Bit mask of VOSEL field.
	CMP_DACCR_VOSEL_Msk = 0x3f
	// Position of VRSEL field.
	CMP_DACCR_VRSEL_Pos = 0x6
	// Bit mask of VRSEL field.
	CMP_DACCR_VRSEL_Msk = 0x40
	// Bit VRSEL.
	CMP_DACCR_VRSEL = 0x40
	// V is selected as resistor ladder network supply reference V. in1 in
	CMP_DACCR_VRSEL_0 = 0x0
	// V is selected as resistor ladder network supply reference V. in2 in
	CMP_DACCR_VRSEL_1 = 0x1
	// Position of DACEN field.
	CMP_DACCR_DACEN_Pos = 0x7
	// Bit mask of DACEN field.
	CMP_DACCR_DACEN_Msk = 0x80
	// Bit DACEN.
	CMP_DACCR_DACEN = 0x80
	// DAC is disabled.
	CMP_DACCR_DACEN_0 = 0x0
	// DAC is enabled.
	CMP_DACCR_DACEN_1 = 0x1

	// MUXCR: MUX Control Register
	// Position of MSEL field.
	CMP_MUXCR_MSEL_Pos = 0x0
	// Bit mask of MSEL field.
	CMP_MUXCR_MSEL_Msk = 0x7
	// IN0
	CMP_MUXCR_MSEL_000 = 0x0
	// IN1
	CMP_MUXCR_MSEL_001 = 0x1
	// IN2
	CMP_MUXCR_MSEL_010 = 0x2
	// IN3
	CMP_MUXCR_MSEL_011 = 0x3
	// IN4
	CMP_MUXCR_MSEL_100 = 0x4
	// IN5
	CMP_MUXCR_MSEL_101 = 0x5
	// IN6
	CMP_MUXCR_MSEL_110 = 0x6
	// IN7
	CMP_MUXCR_MSEL_111 = 0x7
	// Position of PSEL field.
	CMP_MUXCR_PSEL_Pos = 0x3
	// Bit mask of PSEL field.
	CMP_MUXCR_PSEL_Msk = 0x38
	// IN0
	CMP_MUXCR_PSEL_000 = 0x0
	// IN1
	CMP_MUXCR_PSEL_001 = 0x1
	// IN2
	CMP_MUXCR_PSEL_010 = 0x2
	// IN3
	CMP_MUXCR_PSEL_011 = 0x3
	// IN4
	CMP_MUXCR_PSEL_100 = 0x4
	// IN5
	CMP_MUXCR_PSEL_101 = 0x5
	// IN6
	CMP_MUXCR_PSEL_110 = 0x6
	// IN7
	CMP_MUXCR_PSEL_111 = 0x7
	// Position of PSTM field.
	CMP_MUXCR_PSTM_Pos = 0x7
	// Bit mask of PSTM field.
	CMP_MUXCR_PSTM_Msk = 0x80
	// Bit PSTM.
	CMP_MUXCR_PSTM = 0x80
	// Pass Through Mode is disabled.
	CMP_MUXCR_PSTM_0 = 0x0
	// Pass Through Mode is enabled.
	CMP_MUXCR_PSTM_1 = 0x1
)

// Constants for VREF: Voltage Reference
const (
	// TRM: VREF Trim Register
	// Position of TRIM field.
	VREF_TRM_TRIM_Pos = 0x0
	// Bit mask of TRIM field.
	VREF_TRM_TRIM_Msk = 0x3f
	// Min
	VREF_TRM_TRIM_000000 = 0x0
	// Max
	VREF_TRM_TRIM_111111 = 0x3f
	// Position of CHOPEN field.
	VREF_TRM_CHOPEN_Pos = 0x6
	// Bit mask of CHOPEN field.
	VREF_TRM_CHOPEN_Msk = 0x40
	// Bit CHOPEN.
	VREF_TRM_CHOPEN = 0x40
	// Chop oscillator is disabled.
	VREF_TRM_CHOPEN_0 = 0x0
	// Chop oscillator is enabled.
	VREF_TRM_CHOPEN_1 = 0x1

	// SC: VREF Status and Control Register
	// Position of MODE_LV field.
	VREF_SC_MODE_LV_Pos = 0x0
	// Bit mask of MODE_LV field.
	VREF_SC_MODE_LV_Msk = 0x3
	// Bandgap on only, for stabilization and startup
	VREF_SC_MODE_LV_00 = 0x0
	// High power buffer mode enabled
	VREF_SC_MODE_LV_01 = 0x1
	// Low-power buffer mode enabled
	VREF_SC_MODE_LV_10 = 0x2
	// Position of VREFST field.
	VREF_SC_VREFST_Pos = 0x2
	// Bit mask of VREFST field.
	VREF_SC_VREFST_Msk = 0x4
	// Bit VREFST.
	VREF_SC_VREFST = 0x4
	// The module is disabled or not stable.
	VREF_SC_VREFST_0 = 0x0
	// The module is stable.
	VREF_SC_VREFST_1 = 0x1
	// Position of ICOMPEN field.
	VREF_SC_ICOMPEN_Pos = 0x5
	// Bit mask of ICOMPEN field.
	VREF_SC_ICOMPEN_Msk = 0x20
	// Bit ICOMPEN.
	VREF_SC_ICOMPEN = 0x20
	// Disabled
	VREF_SC_ICOMPEN_0 = 0x0
	// Enabled
	VREF_SC_ICOMPEN_1 = 0x1
	// Position of REGEN field.
	VREF_SC_REGEN_Pos = 0x6
	// Bit mask of REGEN field.
	VREF_SC_REGEN_Msk = 0x40
	// Bit REGEN.
	VREF_SC_REGEN = 0x40
	// Internal 1.75 V regulator is disabled.
	VREF_SC_REGEN_0 = 0x0
	// Internal 1.75 V regulator is enabled.
	VREF_SC_REGEN_1 = 0x1
	// Position of VREFEN field.
	VREF_SC_VREFEN_Pos = 0x7
	// Bit mask of VREFEN field.
	VREF_SC_VREFEN_Msk = 0x80
	// Bit VREFEN.
	VREF_SC_VREFEN = 0x80
	// The module is disabled.
	VREF_SC_VREFEN_0 = 0x0
	// The module is enabled.
	VREF_SC_VREFEN_1 = 0x1
)

// Constants for LLWU: Low leakage wakeup unit
const (
	// PE1: LLWU Pin Enable 1 register
	// Position of WUPE0 field.
	LLWU_PE1_WUPE0_Pos = 0x0
	// Bit mask of WUPE0 field.
	LLWU_PE1_WUPE0_Msk = 0x3
	// External input pin disabled as wakeup input
	LLWU_PE1_WUPE0_00 = 0x0
	// External input pin enabled with rising edge detection
	LLWU_PE1_WUPE0_01 = 0x1
	// External input pin enabled with falling edge detection
	LLWU_PE1_WUPE0_10 = 0x2
	// External input pin enabled with any change detection
	LLWU_PE1_WUPE0_11 = 0x3
	// Position of WUPE1 field.
	LLWU_PE1_WUPE1_Pos = 0x2
	// Bit mask of WUPE1 field.
	LLWU_PE1_WUPE1_Msk = 0xc
	// External input pin disabled as wakeup input
	LLWU_PE1_WUPE1_00 = 0x0
	// External input pin enabled with rising edge detection
	LLWU_PE1_WUPE1_01 = 0x1
	// External input pin enabled with falling edge detection
	LLWU_PE1_WUPE1_10 = 0x2
	// External input pin enabled with any change detection
	LLWU_PE1_WUPE1_11 = 0x3
	// Position of WUPE2 field.
	LLWU_PE1_WUPE2_Pos = 0x4
	// Bit mask of WUPE2 field.
	LLWU_PE1_WUPE2_Msk = 0x30
	// External input pin disabled as wakeup input
	LLWU_PE1_WUPE2_00 = 0x0
	// External input pin enabled with rising edge detection
	LLWU_PE1_WUPE2_01 = 0x1
	// External input pin enabled with falling edge detection
	LLWU_PE1_WUPE2_10 = 0x2
	// External input pin enabled with any change detection
	LLWU_PE1_WUPE2_11 = 0x3
	// Position of WUPE3 field.
	LLWU_PE1_WUPE3_Pos = 0x6
	// Bit mask of WUPE3 field.
	LLWU_PE1_WUPE3_Msk = 0xc0
	// External input pin disabled as wakeup input
	LLWU_PE1_WUPE3_00 = 0x0
	// External input pin enabled with rising edge detection
	LLWU_PE1_WUPE3_01 = 0x1
	// External input pin enabled with falling edge detection
	LLWU_PE1_WUPE3_10 = 0x2
	// External input pin enabled with any change detection
	LLWU_PE1_WUPE3_11 = 0x3

	// PE2: LLWU Pin Enable 2 register
	// Position of WUPE4 field.
	LLWU_PE2_WUPE4_Pos = 0x0
	// Bit mask of WUPE4 field.
	LLWU_PE2_WUPE4_Msk = 0x3
	// External input pin disabled as wakeup input
	LLWU_PE2_WUPE4_00 = 0x0
	// External input pin enabled with rising edge detection
	LLWU_PE2_WUPE4_01 = 0x1
	// External input pin enabled with falling edge detection
	LLWU_PE2_WUPE4_10 = 0x2
	// External input pin enabled with any change detection
	LLWU_PE2_WUPE4_11 = 0x3
	// Position of WUPE5 field.
	LLWU_PE2_WUPE5_Pos = 0x2
	// Bit mask of WUPE5 field.
	LLWU_PE2_WUPE5_Msk = 0xc
	// External input pin disabled as wakeup input
	LLWU_PE2_WUPE5_00 = 0x0
	// External input pin enabled with rising edge detection
	LLWU_PE2_WUPE5_01 = 0x1
	// External input pin enabled with falling edge detection
	LLWU_PE2_WUPE5_10 = 0x2
	// External input pin enabled with any change detection
	LLWU_PE2_WUPE5_11 = 0x3
	// Position of WUPE6 field.
	LLWU_PE2_WUPE6_Pos = 0x4
	// Bit mask of WUPE6 field.
	LLWU_PE2_WUPE6_Msk = 0x30
	// External input pin disabled as wakeup input
	LLWU_PE2_WUPE6_00 = 0x0
	// External input pin enabled with rising edge detection
	LLWU_PE2_WUPE6_01 = 0x1
	// External input pin enabled with falling edge detection
	LLWU_PE2_WUPE6_10 = 0x2
	// External input pin enabled with any change detection
	LLWU_PE2_WUPE6_11 = 0x3
	// Position of WUPE7 field.
	LLWU_PE2_WUPE7_Pos = 0x6
	// Bit mask of WUPE7 field.
	LLWU_PE2_WUPE7_Msk = 0xc0
	// External input pin disabled as wakeup input
	LLWU_PE2_WUPE7_00 = 0x0
	// External input pin enabled with rising edge detection
	LLWU_PE2_WUPE7_01 = 0x1
	// External input pin enabled with falling edge detection
	LLWU_PE2_WUPE7_10 = 0x2
	// External input pin enabled with any change detection
	LLWU_PE2_WUPE7_11 = 0x3

	// PE3: LLWU Pin Enable 3 register
	// Position of WUPE8 field.
	LLWU_PE3_WUPE8_Pos = 0x0
	// Bit mask of WUPE8 field.
	LLWU_PE3_WUPE8_Msk = 0x3
	// External input pin disabled as wakeup input
	LLWU_PE3_WUPE8_00 = 0x0
	// External input pin enabled with rising edge detection
	LLWU_PE3_WUPE8_01 = 0x1
	// External input pin enabled with falling edge detection
	LLWU_PE3_WUPE8_10 = 0x2
	// External input pin enabled with any change detection
	LLWU_PE3_WUPE8_11 = 0x3
	// Position of WUPE9 field.
	LLWU_PE3_WUPE9_Pos = 0x2
	// Bit mask of WUPE9 field.
	LLWU_PE3_WUPE9_Msk = 0xc
	// External input pin disabled as wakeup input
	LLWU_PE3_WUPE9_00 = 0x0
	// External input pin enabled with rising edge detection
	LLWU_PE3_WUPE9_01 = 0x1
	// External input pin enabled with falling edge detection
	LLWU_PE3_WUPE9_10 = 0x2
	// External input pin enabled with any change detection
	LLWU_PE3_WUPE9_11 = 0x3
	// Position of WUPE10 field.
	LLWU_PE3_WUPE10_Pos = 0x4
	// Bit mask of WUPE10 field.
	LLWU_PE3_WUPE10_Msk = 0x30
	// External input pin disabled as wakeup input
	LLWU_PE3_WUPE10_00 = 0x0
	// External input pin enabled with rising edge detection
	LLWU_PE3_WUPE10_01 = 0x1
	// External input pin enabled with falling edge detection
	LLWU_PE3_WUPE10_10 = 0x2
	// External input pin enabled with any change detection
	LLWU_PE3_WUPE10_11 = 0x3
	// Position of WUPE11 field.
	LLWU_PE3_WUPE11_Pos = 0x6
	// Bit mask of WUPE11 field.
	LLWU_PE3_WUPE11_Msk = 0xc0
	// External input pin disabled as wakeup input
	LLWU_PE3_WUPE11_00 = 0x0
	// External input pin enabled with rising edge detection
	LLWU_PE3_WUPE11_01 = 0x1
	// External input pin enabled with falling edge detection
	LLWU_PE3_WUPE11_10 = 0x2
	// External input pin enabled with any change detection
	LLWU_PE3_WUPE11_11 = 0x3

	// PE4: LLWU Pin Enable 4 register
	// Position of WUPE12 field.
	LLWU_PE4_WUPE12_Pos = 0x0
	// Bit mask of WUPE12 field.
	LLWU_PE4_WUPE12_Msk = 0x3
	// External input pin disabled as wakeup input
	LLWU_PE4_WUPE12_00 = 0x0
	// External input pin enabled with rising edge detection
	LLWU_PE4_WUPE12_01 = 0x1
	// External input pin enabled with falling edge detection
	LLWU_PE4_WUPE12_10 = 0x2
	// External input pin enabled with any change detection
	LLWU_PE4_WUPE12_11 = 0x3
	// Position of WUPE13 field.
	LLWU_PE4_WUPE13_Pos = 0x2
	// Bit mask of WUPE13 field.
	LLWU_PE4_WUPE13_Msk = 0xc
	// External input pin disabled as wakeup input
	LLWU_PE4_WUPE13_00 = 0x0
	// External input pin enabled with rising edge detection
	LLWU_PE4_WUPE13_01 = 0x1
	// External input pin enabled with falling edge detection
	LLWU_PE4_WUPE13_10 = 0x2
	// External input pin enabled with any change detection
	LLWU_PE4_WUPE13_11 = 0x3
	// Position of WUPE14 field.
	LLWU_PE4_WUPE14_Pos = 0x4
	// Bit mask of WUPE14 field.
	LLWU_PE4_WUPE14_Msk = 0x30
	// External input pin disabled as wakeup input
	LLWU_PE4_WUPE14_00 = 0x0
	// External input pin enabled with rising edge detection
	LLWU_PE4_WUPE14_01 = 0x1
	// External input pin enabled with falling edge detection
	LLWU_PE4_WUPE14_10 = 0x2
	// External input pin enabled with any change detection
	LLWU_PE4_WUPE14_11 = 0x3
	// Position of WUPE15 field.
	LLWU_PE4_WUPE15_Pos = 0x6
	// Bit mask of WUPE15 field.
	LLWU_PE4_WUPE15_Msk = 0xc0
	// External input pin disabled as wakeup input
	LLWU_PE4_WUPE15_00 = 0x0
	// External input pin enabled with rising edge detection
	LLWU_PE4_WUPE15_01 = 0x1
	// External input pin enabled with falling edge detection
	LLWU_PE4_WUPE15_10 = 0x2
	// External input pin enabled with any change detection
	LLWU_PE4_WUPE15_11 = 0x3

	// ME: LLWU Module Enable register
	// Position of WUME0 field.
	LLWU_ME_WUME0_Pos = 0x0
	// Bit mask of WUME0 field.
	LLWU_ME_WUME0_Msk = 0x1
	// Bit WUME0.
	LLWU_ME_WUME0 = 0x1
	// Internal module flag not used as wakeup source
	LLWU_ME_WUME0_0 = 0x0
	// Internal module flag used as wakeup source
	LLWU_ME_WUME0_1 = 0x1
	// Position of WUME1 field.
	LLWU_ME_WUME1_Pos = 0x1
	// Bit mask of WUME1 field.
	LLWU_ME_WUME1_Msk = 0x2
	// Bit WUME1.
	LLWU_ME_WUME1 = 0x2
	// Internal module flag not used as wakeup source
	LLWU_ME_WUME1_0 = 0x0
	// Internal module flag used as wakeup source
	LLWU_ME_WUME1_1 = 0x1
	// Position of WUME2 field.
	LLWU_ME_WUME2_Pos = 0x2
	// Bit mask of WUME2 field.
	LLWU_ME_WUME2_Msk = 0x4
	// Bit WUME2.
	LLWU_ME_WUME2 = 0x4
	// Internal module flag not used as wakeup source
	LLWU_ME_WUME2_0 = 0x0
	// Internal module flag used as wakeup source
	LLWU_ME_WUME2_1 = 0x1
	// Position of WUME3 field.
	LLWU_ME_WUME3_Pos = 0x3
	// Bit mask of WUME3 field.
	LLWU_ME_WUME3_Msk = 0x8
	// Bit WUME3.
	LLWU_ME_WUME3 = 0x8
	// Internal module flag not used as wakeup source
	LLWU_ME_WUME3_0 = 0x0
	// Internal module flag used as wakeup source
	LLWU_ME_WUME3_1 = 0x1
	// Position of WUME4 field.
	LLWU_ME_WUME4_Pos = 0x4
	// Bit mask of WUME4 field.
	LLWU_ME_WUME4_Msk = 0x10
	// Bit WUME4.
	LLWU_ME_WUME4 = 0x10
	// Internal module flag not used as wakeup source
	LLWU_ME_WUME4_0 = 0x0
	// Internal module flag used as wakeup source
	LLWU_ME_WUME4_1 = 0x1
	// Position of WUME5 field.
	LLWU_ME_WUME5_Pos = 0x5
	// Bit mask of WUME5 field.
	LLWU_ME_WUME5_Msk = 0x20
	// Bit WUME5.
	LLWU_ME_WUME5 = 0x20
	// Internal module flag not used as wakeup source
	LLWU_ME_WUME5_0 = 0x0
	// Internal module flag used as wakeup source
	LLWU_ME_WUME5_1 = 0x1
	// Position of WUME6 field.
	LLWU_ME_WUME6_Pos = 0x6
	// Bit mask of WUME6 field.
	LLWU_ME_WUME6_Msk = 0x40
	// Bit WUME6.
	LLWU_ME_WUME6 = 0x40
	// Internal module flag not used as wakeup source
	LLWU_ME_WUME6_0 = 0x0
	// Internal module flag used as wakeup source
	LLWU_ME_WUME6_1 = 0x1
	// Position of WUME7 field.
	LLWU_ME_WUME7_Pos = 0x7
	// Bit mask of WUME7 field.
	LLWU_ME_WUME7_Msk = 0x80
	// Bit WUME7.
	LLWU_ME_WUME7 = 0x80
	// Internal module flag not used as wakeup source
	LLWU_ME_WUME7_0 = 0x0
	// Internal module flag used as wakeup source
	LLWU_ME_WUME7_1 = 0x1

	// F1: LLWU Flag 1 register
	// Position of WUF0 field.
	LLWU_F1_WUF0_Pos = 0x0
	// Bit mask of WUF0 field.
	LLWU_F1_WUF0_Msk = 0x1
	// Bit WUF0.
	LLWU_F1_WUF0 = 0x1
	// LLWU_P0 input was not a wakeup source
	LLWU_F1_WUF0_0 = 0x0
	// LLWU_P0 input was a wakeup source
	LLWU_F1_WUF0_1 = 0x1
	// Position of WUF1 field.
	LLWU_F1_WUF1_Pos = 0x1
	// Bit mask of WUF1 field.
	LLWU_F1_WUF1_Msk = 0x2
	// Bit WUF1.
	LLWU_F1_WUF1 = 0x2
	// LLWU_P1 input was not a wakeup source
	LLWU_F1_WUF1_0 = 0x0
	// LLWU_P1 input was a wakeup source
	LLWU_F1_WUF1_1 = 0x1
	// Position of WUF2 field.
	LLWU_F1_WUF2_Pos = 0x2
	// Bit mask of WUF2 field.
	LLWU_F1_WUF2_Msk = 0x4
	// Bit WUF2.
	LLWU_F1_WUF2 = 0x4
	// LLWU_P2 input was not a wakeup source
	LLWU_F1_WUF2_0 = 0x0
	// LLWU_P2 input was a wakeup source
	LLWU_F1_WUF2_1 = 0x1
	// Position of WUF3 field.
	LLWU_F1_WUF3_Pos = 0x3
	// Bit mask of WUF3 field.
	LLWU_F1_WUF3_Msk = 0x8
	// Bit WUF3.
	LLWU_F1_WUF3 = 0x8
	// LLWU_P3 input was not a wake-up source
	LLWU_F1_WUF3_0 = 0x0
	// LLWU_P3 input was a wake-up source
	LLWU_F1_WUF3_1 = 0x1
	// Position of WUF4 field.
	LLWU_F1_WUF4_Pos = 0x4
	// Bit mask of WUF4 field.
	LLWU_F1_WUF4_Msk = 0x10
	// Bit WUF4.
	LLWU_F1_WUF4 = 0x10
	// LLWU_P4 input was not a wakeup source
	LLWU_F1_WUF4_0 = 0x0
	// LLWU_P4 input was a wakeup source
	LLWU_F1_WUF4_1 = 0x1
	// Position of WUF5 field.
	LLWU_F1_WUF5_Pos = 0x5
	// Bit mask of WUF5 field.
	LLWU_F1_WUF5_Msk = 0x20
	// Bit WUF5.
	LLWU_F1_WUF5 = 0x20
	// LLWU_P5 input was not a wakeup source
	LLWU_F1_WUF5_0 = 0x0
	// LLWU_P5 input was a wakeup source
	LLWU_F1_WUF5_1 = 0x1
	// Position of WUF6 field.
	LLWU_F1_WUF6_Pos = 0x6
	// Bit mask of WUF6 field.
	LLWU_F1_WUF6_Msk = 0x40
	// Bit WUF6.
	LLWU_F1_WUF6 = 0x40
	// LLWU_P6 input was not a wakeup source
	LLWU_F1_WUF6_0 = 0x0
	// LLWU_P6 input was a wakeup source
	LLWU_F1_WUF6_1 = 0x1
	// Position of WUF7 field.
	LLWU_F1_WUF7_Pos = 0x7
	// Bit mask of WUF7 field.
	LLWU_F1_WUF7_Msk = 0x80
	// Bit WUF7.
	LLWU_F1_WUF7 = 0x80
	// LLWU_P7 input was not a wakeup source
	LLWU_F1_WUF7_0 = 0x0
	// LLWU_P7 input was a wakeup source
	LLWU_F1_WUF7_1 = 0x1

	// F2: LLWU Flag 2 register
	// Position of WUF8 field.
	LLWU_F2_WUF8_Pos = 0x0
	// Bit mask of WUF8 field.
	LLWU_F2_WUF8_Msk = 0x1
	// Bit WUF8.
	LLWU_F2_WUF8 = 0x1
	// LLWU_P8 input was not a wakeup source
	LLWU_F2_WUF8_0 = 0x0
	// LLWU_P8 input was a wakeup source
	LLWU_F2_WUF8_1 = 0x1
	// Position of WUF9 field.
	LLWU_F2_WUF9_Pos = 0x1
	// Bit mask of WUF9 field.
	LLWU_F2_WUF9_Msk = 0x2
	// Bit WUF9.
	LLWU_F2_WUF9 = 0x2
	// LLWU_P9 input was not a wakeup source
	LLWU_F2_WUF9_0 = 0x0
	// LLWU_P9 input was a wakeup source
	LLWU_F2_WUF9_1 = 0x1
	// Position of WUF10 field.
	LLWU_F2_WUF10_Pos = 0x2
	// Bit mask of WUF10 field.
	LLWU_F2_WUF10_Msk = 0x4
	// Bit WUF10.
	LLWU_F2_WUF10 = 0x4
	// LLWU_P10 input was not a wakeup source
	LLWU_F2_WUF10_0 = 0x0
	// LLWU_P10 input was a wakeup source
	LLWU_F2_WUF10_1 = 0x1
	// Position of WUF11 field.
	LLWU_F2_WUF11_Pos = 0x3
	// Bit mask of WUF11 field.
	LLWU_F2_WUF11_Msk = 0x8
	// Bit WUF11.
	LLWU_F2_WUF11 = 0x8
	// LLWU_P11 input was not a wakeup source
	LLWU_F2_WUF11_0 = 0x0
	// LLWU_P11 input was a wakeup source
	LLWU_F2_WUF11_1 = 0x1
	// Position of WUF12 field.
	LLWU_F2_WUF12_Pos = 0x4
	// Bit mask of WUF12 field.
	LLWU_F2_WUF12_Msk = 0x10
	// Bit WUF12.
	LLWU_F2_WUF12 = 0x10
	// LLWU_P12 input was not a wakeup source
	LLWU_F2_WUF12_0 = 0x0
	// LLWU_P12 input was a wakeup source
	LLWU_F2_WUF12_1 = 0x1
	// Position of WUF13 field.
	LLWU_F2_WUF13_Pos = 0x5
	// Bit mask of WUF13 field.
	LLWU_F2_WUF13_Msk = 0x20
	// Bit WUF13.
	LLWU_F2_WUF13 = 0x20
	// LLWU_P13 input was not a wakeup source
	LLWU_F2_WUF13_0 = 0x0
	// LLWU_P13 input was a wakeup source
	LLWU_F2_WUF13_1 = 0x1
	// Position of WUF14 field.
	LLWU_F2_WUF14_Pos = 0x6
	// Bit mask of WUF14 field.
	LLWU_F2_WUF14_Msk = 0x40
	// Bit WUF14.
	LLWU_F2_WUF14 = 0x40
	// LLWU_P14 input was not a wakeup source
	LLWU_F2_WUF14_0 = 0x0
	// LLWU_P14 input was a wakeup source
	LLWU_F2_WUF14_1 = 0x1
	// Position of WUF15 field.
	LLWU_F2_WUF15_Pos = 0x7
	// Bit mask of WUF15 field.
	LLWU_F2_WUF15_Msk = 0x80
	// Bit WUF15.
	LLWU_F2_WUF15 = 0x80
	// LLWU_P15 input was not a wakeup source
	LLWU_F2_WUF15_0 = 0x0
	// LLWU_P15 input was a wakeup source
	LLWU_F2_WUF15_1 = 0x1

	// F3: LLWU Flag 3 register
	// Position of MWUF0 field.
	LLWU_F3_MWUF0_Pos = 0x0
	// Bit mask of MWUF0 field.
	LLWU_F3_MWUF0_Msk = 0x1
	// Bit MWUF0.
	LLWU_F3_MWUF0 = 0x1
	// Module 0 input was not a wakeup source
	LLWU_F3_MWUF0_0 = 0x0
	// Module 0 input was a wakeup source
	LLWU_F3_MWUF0_1 = 0x1
	// Position of MWUF1 field.
	LLWU_F3_MWUF1_Pos = 0x1
	// Bit mask of MWUF1 field.
	LLWU_F3_MWUF1_Msk = 0x2
	// Bit MWUF1.
	LLWU_F3_MWUF1 = 0x2
	// Module 1 input was not a wakeup source
	LLWU_F3_MWUF1_0 = 0x0
	// Module 1 input was a wakeup source
	LLWU_F3_MWUF1_1 = 0x1
	// Position of MWUF2 field.
	LLWU_F3_MWUF2_Pos = 0x2
	// Bit mask of MWUF2 field.
	LLWU_F3_MWUF2_Msk = 0x4
	// Bit MWUF2.
	LLWU_F3_MWUF2 = 0x4
	// Module 2 input was not a wakeup source
	LLWU_F3_MWUF2_0 = 0x0
	// Module 2 input was a wakeup source
	LLWU_F3_MWUF2_1 = 0x1
	// Position of MWUF3 field.
	LLWU_F3_MWUF3_Pos = 0x3
	// Bit mask of MWUF3 field.
	LLWU_F3_MWUF3_Msk = 0x8
	// Bit MWUF3.
	LLWU_F3_MWUF3 = 0x8
	// Module 3 input was not a wakeup source
	LLWU_F3_MWUF3_0 = 0x0
	// Module 3 input was a wakeup source
	LLWU_F3_MWUF3_1 = 0x1
	// Position of MWUF4 field.
	LLWU_F3_MWUF4_Pos = 0x4
	// Bit mask of MWUF4 field.
	LLWU_F3_MWUF4_Msk = 0x10
	// Bit MWUF4.
	LLWU_F3_MWUF4 = 0x10
	// Module 4 input was not a wakeup source
	LLWU_F3_MWUF4_0 = 0x0
	// Module 4 input was a wakeup source
	LLWU_F3_MWUF4_1 = 0x1
	// Position of MWUF5 field.
	LLWU_F3_MWUF5_Pos = 0x5
	// Bit mask of MWUF5 field.
	LLWU_F3_MWUF5_Msk = 0x20
	// Bit MWUF5.
	LLWU_F3_MWUF5 = 0x20
	// Module 5 input was not a wakeup source
	LLWU_F3_MWUF5_0 = 0x0
	// Module 5 input was a wakeup source
	LLWU_F3_MWUF5_1 = 0x1
	// Position of MWUF6 field.
	LLWU_F3_MWUF6_Pos = 0x6
	// Bit mask of MWUF6 field.
	LLWU_F3_MWUF6_Msk = 0x40
	// Bit MWUF6.
	LLWU_F3_MWUF6 = 0x40
	// Module 6 input was not a wakeup source
	LLWU_F3_MWUF6_0 = 0x0
	// Module 6 input was a wakeup source
	LLWU_F3_MWUF6_1 = 0x1
	// Position of MWUF7 field.
	LLWU_F3_MWUF7_Pos = 0x7
	// Bit mask of MWUF7 field.
	LLWU_F3_MWUF7_Msk = 0x80
	// Bit MWUF7.
	LLWU_F3_MWUF7 = 0x80
	// Module 7 input was not a wakeup source
	LLWU_F3_MWUF7_0 = 0x0
	// Module 7 input was a wakeup source
	LLWU_F3_MWUF7_1 = 0x1

	// FILT1: LLWU Pin Filter 1 register
	// Position of FILTSEL field.
	LLWU_FILT1_FILTSEL_Pos = 0x0
	// Bit mask of FILTSEL field.
	LLWU_FILT1_FILTSEL_Msk = 0xf
	// Select LLWU_P0 for filter
	LLWU_FILT1_FILTSEL_0000 = 0x0
	// Select LLWU_P15 for filter
	LLWU_FILT1_FILTSEL_1111 = 0xf
	// Position of FILTE field.
	LLWU_FILT1_FILTE_Pos = 0x5
	// Bit mask of FILTE field.
	LLWU_FILT1_FILTE_Msk = 0x60
	// Filter disabled
	LLWU_FILT1_FILTE_00 = 0x0
	// Filter posedge detect enabled
	LLWU_FILT1_FILTE_01 = 0x1
	// Filter negedge detect enabled
	LLWU_FILT1_FILTE_10 = 0x2
	// Filter any edge detect enabled
	LLWU_FILT1_FILTE_11 = 0x3
	// Position of FILTF field.
	LLWU_FILT1_FILTF_Pos = 0x7
	// Bit mask of FILTF field.
	LLWU_FILT1_FILTF_Msk = 0x80
	// Bit FILTF.
	LLWU_FILT1_FILTF = 0x80
	// Pin Filter 1 was not a wakeup source
	LLWU_FILT1_FILTF_0 = 0x0
	// Pin Filter 1 was a wakeup source
	LLWU_FILT1_FILTF_1 = 0x1

	// FILT2: LLWU Pin Filter 2 register
	// Position of FILTSEL field.
	LLWU_FILT2_FILTSEL_Pos = 0x0
	// Bit mask of FILTSEL field.
	LLWU_FILT2_FILTSEL_Msk = 0xf
	// Select LLWU_P0 for filter
	LLWU_FILT2_FILTSEL_0000 = 0x0
	// Select LLWU_P15 for filter
	LLWU_FILT2_FILTSEL_1111 = 0xf
	// Position of FILTE field.
	LLWU_FILT2_FILTE_Pos = 0x5
	// Bit mask of FILTE field.
	LLWU_FILT2_FILTE_Msk = 0x60
	// Filter disabled
	LLWU_FILT2_FILTE_00 = 0x0
	// Filter posedge detect enabled
	LLWU_FILT2_FILTE_01 = 0x1
	// Filter negedge detect enabled
	LLWU_FILT2_FILTE_10 = 0x2
	// Filter any edge detect enabled
	LLWU_FILT2_FILTE_11 = 0x3
	// Position of FILTF field.
	LLWU_FILT2_FILTF_Pos = 0x7
	// Bit mask of FILTF field.
	LLWU_FILT2_FILTF_Msk = 0x80
	// Bit FILTF.
	LLWU_FILT2_FILTF = 0x80
	// Pin Filter 2 was not a wakeup source
	LLWU_FILT2_FILTF_0 = 0x0
	// Pin Filter 2 was a wakeup source
	LLWU_FILT2_FILTF_1 = 0x1

	// RST: LLWU Reset Enable register
	// Position of RSTFILT field.
	LLWU_RST_RSTFILT_Pos = 0x0
	// Bit mask of RSTFILT field.
	LLWU_RST_RSTFILT_Msk = 0x1
	// Bit RSTFILT.
	LLWU_RST_RSTFILT = 0x1
	// Filter not enabled
	LLWU_RST_RSTFILT_0 = 0x0
	// Filter enabled
	LLWU_RST_RSTFILT_1 = 0x1
	// Position of LLRSTE field.
	LLWU_RST_LLRSTE_Pos = 0x1
	// Bit mask of LLRSTE field.
	LLWU_RST_LLRSTE_Msk = 0x2
	// Bit LLRSTE.
	LLWU_RST_LLRSTE = 0x2
	// RESET pin not enabled as a leakage mode exit source
	LLWU_RST_LLRSTE_0 = 0x0
	// RESET pin enabled as a low leakage mode exit source
	LLWU_RST_LLRSTE_1 = 0x1
)

// Constants for PMC: Power Management Controller
const (
	// LVDSC1: Low Voltage Detect Status And Control 1 register
	// Position of LVDV field.
	PMC_LVDSC1_LVDV_Pos = 0x0
	// Bit mask of LVDV field.
	PMC_LVDSC1_LVDV_Msk = 0x3
	// Low trip point selected (V LVD = V LVDL )
	PMC_LVDSC1_LVDV_00 = 0x0
	// High trip point selected (V LVD = V LVDH )
	PMC_LVDSC1_LVDV_01 = 0x1
	// Position of LVDRE field.
	PMC_LVDSC1_LVDRE_Pos = 0x4
	// Bit mask of LVDRE field.
	PMC_LVDSC1_LVDRE_Msk = 0x10
	// Bit LVDRE.
	PMC_LVDSC1_LVDRE = 0x10
	// LVDF does not generate hardware resets
	PMC_LVDSC1_LVDRE_0 = 0x0
	// Force an MCU reset when LVDF = 1
	PMC_LVDSC1_LVDRE_1 = 0x1
	// Position of LVDIE field.
	PMC_LVDSC1_LVDIE_Pos = 0x5
	// Bit mask of LVDIE field.
	PMC_LVDSC1_LVDIE_Msk = 0x20
	// Bit LVDIE.
	PMC_LVDSC1_LVDIE = 0x20
	// Hardware interrupt disabled (use polling)
	PMC_LVDSC1_LVDIE_0 = 0x0
	// Request a hardware interrupt when LVDF = 1
	PMC_LVDSC1_LVDIE_1 = 0x1
	// Position of LVDACK field.
	PMC_LVDSC1_LVDACK_Pos = 0x6
	// Bit mask of LVDACK field.
	PMC_LVDSC1_LVDACK_Msk = 0x40
	// Bit LVDACK.
	PMC_LVDSC1_LVDACK = 0x40
	// Position of LVDF field.
	PMC_LVDSC1_LVDF_Pos = 0x7
	// Bit mask of LVDF field.
	PMC_LVDSC1_LVDF_Msk = 0x80
	// Bit LVDF.
	PMC_LVDSC1_LVDF = 0x80
	// Low-voltage event not detected
	PMC_LVDSC1_LVDF_0 = 0x0
	// Low-voltage event detected
	PMC_LVDSC1_LVDF_1 = 0x1

	// LVDSC2: Low Voltage Detect Status And Control 2 register
	// Position of LVWV field.
	PMC_LVDSC2_LVWV_Pos = 0x0
	// Bit mask of LVWV field.
	PMC_LVDSC2_LVWV_Msk = 0x3
	// Low trip point selected (VLVW = VLVW1)
	PMC_LVDSC2_LVWV_00 = 0x0
	// Mid 1 trip point selected (VLVW = VLVW2)
	PMC_LVDSC2_LVWV_01 = 0x1
	// Mid 2 trip point selected (VLVW = VLVW3)
	PMC_LVDSC2_LVWV_10 = 0x2
	// High trip point selected (VLVW = VLVW4)
	PMC_LVDSC2_LVWV_11 = 0x3
	// Position of LVWIE field.
	PMC_LVDSC2_LVWIE_Pos = 0x5
	// Bit mask of LVWIE field.
	PMC_LVDSC2_LVWIE_Msk = 0x20
	// Bit LVWIE.
	PMC_LVDSC2_LVWIE = 0x20
	// Hardware interrupt disabled (use polling)
	PMC_LVDSC2_LVWIE_0 = 0x0
	// Request a hardware interrupt when LVWF = 1
	PMC_LVDSC2_LVWIE_1 = 0x1
	// Position of LVWACK field.
	PMC_LVDSC2_LVWACK_Pos = 0x6
	// Bit mask of LVWACK field.
	PMC_LVDSC2_LVWACK_Msk = 0x40
	// Bit LVWACK.
	PMC_LVDSC2_LVWACK = 0x40
	// Position of LVWF field.
	PMC_LVDSC2_LVWF_Pos = 0x7
	// Bit mask of LVWF field.
	PMC_LVDSC2_LVWF_Msk = 0x80
	// Bit LVWF.
	PMC_LVDSC2_LVWF = 0x80
	// Low-voltage warning event not detected
	PMC_LVDSC2_LVWF_0 = 0x0
	// Low-voltage warning event detected
	PMC_LVDSC2_LVWF_1 = 0x1

	// REGSC: Regulator Status And Control register
	// Position of BGBE field.
	PMC_REGSC_BGBE_Pos = 0x0
	// Bit mask of BGBE field.
	PMC_REGSC_BGBE_Msk = 0x1
	// Bit BGBE.
	PMC_REGSC_BGBE = 0x1
	// Bandgap buffer not enabled
	PMC_REGSC_BGBE_0 = 0x0
	// Bandgap buffer enabled
	PMC_REGSC_BGBE_1 = 0x1
	// Position of REGONS field.
	PMC_REGSC_REGONS_Pos = 0x2
	// Bit mask of REGONS field.
	PMC_REGSC_REGONS_Msk = 0x4
	// Bit REGONS.
	PMC_REGSC_REGONS = 0x4
	// Regulator is in stop regulation or in transition to/from it
	PMC_REGSC_REGONS_0 = 0x0
	// Regulator is in run regulation
	PMC_REGSC_REGONS_1 = 0x1
	// Position of ACKISO field.
	PMC_REGSC_ACKISO_Pos = 0x3
	// Bit mask of ACKISO field.
	PMC_REGSC_ACKISO_Msk = 0x8
	// Bit ACKISO.
	PMC_REGSC_ACKISO = 0x8
	// Peripherals and I/O pads are in normal run state.
	PMC_REGSC_ACKISO_0 = 0x0
	// Certain peripherals and I/O pads are in an isolated and latched state.
	PMC_REGSC_ACKISO_1 = 0x1
	// Position of BGEN field.
	PMC_REGSC_BGEN_Pos = 0x4
	// Bit mask of BGEN field.
	PMC_REGSC_BGEN_Msk = 0x10
	// Bit BGEN.
	PMC_REGSC_BGEN = 0x10
	// Bandgap voltage reference is disabled in VLPx , LLS , and VLLSx modes.
	PMC_REGSC_BGEN_0 = 0x0
	// Bandgap voltage reference is enabled in VLPx , LLS , and VLLSx modes.
	PMC_REGSC_BGEN_1 = 0x1
)

// Constants for SMC: System Mode Controller
const (
	// PMPROT: Power Mode Protection register
	// Position of AVLLS field.
	SMC_PMPROT_AVLLS_Pos = 0x1
	// Bit mask of AVLLS field.
	SMC_PMPROT_AVLLS_Msk = 0x2
	// Bit AVLLS.
	SMC_PMPROT_AVLLS = 0x2
	// Any VLLSx mode is not allowed
	SMC_PMPROT_AVLLS_0 = 0x0
	// Any VLLSx mode is allowed
	SMC_PMPROT_AVLLS_1 = 0x1
	// Position of ALLS field.
	SMC_PMPROT_ALLS_Pos = 0x3
	// Bit mask of ALLS field.
	SMC_PMPROT_ALLS_Msk = 0x8
	// Bit ALLS.
	SMC_PMPROT_ALLS = 0x8
	// LLS is not allowed
	SMC_PMPROT_ALLS_0 = 0x0
	// LLS is allowed
	SMC_PMPROT_ALLS_1 = 0x1
	// Position of AVLP field.
	SMC_PMPROT_AVLP_Pos = 0x5
	// Bit mask of AVLP field.
	SMC_PMPROT_AVLP_Msk = 0x20
	// Bit AVLP.
	SMC_PMPROT_AVLP = 0x20
	// VLPR, VLPW, and VLPS are not allowed.
	SMC_PMPROT_AVLP_0 = 0x0
	// VLPR, VLPW, and VLPS are allowed.
	SMC_PMPROT_AVLP_1 = 0x1

	// PMCTRL: Power Mode Control register
	// Position of STOPM field.
	SMC_PMCTRL_STOPM_Pos = 0x0
	// Bit mask of STOPM field.
	SMC_PMCTRL_STOPM_Msk = 0x7
	// Normal Stop (STOP)
	SMC_PMCTRL_STOPM_000 = 0x0
	// Very-Low-Power Stop (VLPS)
	SMC_PMCTRL_STOPM_010 = 0x2
	// Low-Leakage Stop (LLS)
	SMC_PMCTRL_STOPM_011 = 0x3
	// Very-Low-Leakage Stop (VLLSx)
	SMC_PMCTRL_STOPM_100 = 0x4
	// Reseved
	SMC_PMCTRL_STOPM_110 = 0x6
	// Position of STOPA field.
	SMC_PMCTRL_STOPA_Pos = 0x3
	// Bit mask of STOPA field.
	SMC_PMCTRL_STOPA_Msk = 0x8
	// Bit STOPA.
	SMC_PMCTRL_STOPA = 0x8
	// The previous stop mode entry was successsful.
	SMC_PMCTRL_STOPA_0 = 0x0
	// The previous stop mode entry was aborted.
	SMC_PMCTRL_STOPA_1 = 0x1
	// Position of RUNM field.
	SMC_PMCTRL_RUNM_Pos = 0x5
	// Bit mask of RUNM field.
	SMC_PMCTRL_RUNM_Msk = 0x60
	// Normal Run mode (RUN)
	SMC_PMCTRL_RUNM_00 = 0x0
	// Very-Low-Power Run mode (VLPR)
	SMC_PMCTRL_RUNM_10 = 0x2
	// Position of LPWUI field.
	SMC_PMCTRL_LPWUI_Pos = 0x7
	// Bit mask of LPWUI field.
	SMC_PMCTRL_LPWUI_Msk = 0x80
	// Bit LPWUI.
	SMC_PMCTRL_LPWUI = 0x80
	// The system remains in a VLP mode on an interrupt
	SMC_PMCTRL_LPWUI_0 = 0x0
	// The system exits to Normal RUN mode on an interrupt
	SMC_PMCTRL_LPWUI_1 = 0x1

	// VLLSCTRL: VLLS Control register
	// Position of VLLSM field.
	SMC_VLLSCTRL_VLLSM_Pos = 0x0
	// Bit mask of VLLSM field.
	SMC_VLLSCTRL_VLLSM_Msk = 0x7
	// VLLS0
	SMC_VLLSCTRL_VLLSM_000 = 0x0
	// VLLS1
	SMC_VLLSCTRL_VLLSM_001 = 0x1
	// VLLS2
	SMC_VLLSCTRL_VLLSM_010 = 0x2
	// VLLS3
	SMC_VLLSCTRL_VLLSM_011 = 0x3
	// Position of PORPO field.
	SMC_VLLSCTRL_PORPO_Pos = 0x5
	// Bit mask of PORPO field.
	SMC_VLLSCTRL_PORPO_Msk = 0x20
	// Bit PORPO.
	SMC_VLLSCTRL_PORPO = 0x20
	// POR detect circuit is enabled in VLLS0.
	SMC_VLLSCTRL_PORPO_0 = 0x0
	// POR detect circuit is disabled in VLLS0.
	SMC_VLLSCTRL_PORPO_1 = 0x1

	// PMSTAT: Power Mode Status register
	// Position of PMSTAT field.
	SMC_PMSTAT_PMSTAT_Pos = 0x0
	// Bit mask of PMSTAT field.
	SMC_PMSTAT_PMSTAT_Msk = 0x7f
)

// Constants for RCM: Reset Control Module
const (
	// SRS0: System Reset Status Register 0
	// Position of WAKEUP field.
	RCM_SRS0_WAKEUP_Pos = 0x0
	// Bit mask of WAKEUP field.
	RCM_SRS0_WAKEUP_Msk = 0x1
	// Bit WAKEUP.
	RCM_SRS0_WAKEUP = 0x1
	// Reset not caused by LLWU module wakeup source
	RCM_SRS0_WAKEUP_0 = 0x0
	// Reset caused by LLWU module wakeup source
	RCM_SRS0_WAKEUP_1 = 0x1
	// Position of LVD field.
	RCM_SRS0_LVD_Pos = 0x1
	// Bit mask of LVD field.
	RCM_SRS0_LVD_Msk = 0x2
	// Bit LVD.
	RCM_SRS0_LVD = 0x2
	// Reset not caused by LVD trip or POR
	RCM_SRS0_LVD_0 = 0x0
	// Reset caused by LVD trip or POR
	RCM_SRS0_LVD_1 = 0x1
	// Position of LOC field.
	RCM_SRS0_LOC_Pos = 0x2
	// Bit mask of LOC field.
	RCM_SRS0_LOC_Msk = 0x4
	// Bit LOC.
	RCM_SRS0_LOC = 0x4
	// Reset not caused by a loss of external clock.
	RCM_SRS0_LOC_0 = 0x0
	// Reset caused by a loss of external clock.
	RCM_SRS0_LOC_1 = 0x1
	// Position of LOL field.
	RCM_SRS0_LOL_Pos = 0x3
	// Bit mask of LOL field.
	RCM_SRS0_LOL_Msk = 0x8
	// Bit LOL.
	RCM_SRS0_LOL = 0x8
	// Reset not caused by a loss of lock in the PLL
	RCM_SRS0_LOL_0 = 0x0
	// Reset caused by a loss of lock in the PLL
	RCM_SRS0_LOL_1 = 0x1
	// Position of WDOG field.
	RCM_SRS0_WDOG_Pos = 0x5
	// Bit mask of WDOG field.
	RCM_SRS0_WDOG_Msk = 0x20
	// Bit WDOG.
	RCM_SRS0_WDOG = 0x20
	// Reset not caused by watchdog timeout
	RCM_SRS0_WDOG_0 = 0x0
	// Reset caused by watchdog timeout
	RCM_SRS0_WDOG_1 = 0x1
	// Position of PIN field.
	RCM_SRS0_PIN_Pos = 0x6
	// Bit mask of PIN field.
	RCM_SRS0_PIN_Msk = 0x40
	// Bit PIN.
	RCM_SRS0_PIN = 0x40
	// Reset not caused by external reset pin
	RCM_SRS0_PIN_0 = 0x0
	// Reset caused by external reset pin
	RCM_SRS0_PIN_1 = 0x1
	// Position of POR field.
	RCM_SRS0_POR_Pos = 0x7
	// Bit mask of POR field.
	RCM_SRS0_POR_Msk = 0x80
	// Bit POR.
	RCM_SRS0_POR = 0x80
	// Reset not caused by POR
	RCM_SRS0_POR_0 = 0x0
	// Reset caused by POR
	RCM_SRS0_POR_1 = 0x1

	// SRS1: System Reset Status Register 1
	// Position of JTAG field.
	RCM_SRS1_JTAG_Pos = 0x0
	// Bit mask of JTAG field.
	RCM_SRS1_JTAG_Msk = 0x1
	// Bit JTAG.
	RCM_SRS1_JTAG = 0x1
	// Reset not caused by JTAG
	RCM_SRS1_JTAG_0 = 0x0
	// Reset caused by JTAG
	RCM_SRS1_JTAG_1 = 0x1
	// Position of LOCKUP field.
	RCM_SRS1_LOCKUP_Pos = 0x1
	// Bit mask of LOCKUP field.
	RCM_SRS1_LOCKUP_Msk = 0x2
	// Bit LOCKUP.
	RCM_SRS1_LOCKUP = 0x2
	// Reset not caused by core LOCKUP event
	RCM_SRS1_LOCKUP_0 = 0x0
	// Reset caused by core LOCKUP event
	RCM_SRS1_LOCKUP_1 = 0x1
	// Position of SW field.
	RCM_SRS1_SW_Pos = 0x2
	// Bit mask of SW field.
	RCM_SRS1_SW_Msk = 0x4
	// Bit SW.
	RCM_SRS1_SW = 0x4
	// Reset not caused by software setting of SYSRESETREQ bit
	RCM_SRS1_SW_0 = 0x0
	// Reset caused by software setting of SYSRESETREQ bit
	RCM_SRS1_SW_1 = 0x1
	// Position of MDM_AP field.
	RCM_SRS1_MDM_AP_Pos = 0x3
	// Bit mask of MDM_AP field.
	RCM_SRS1_MDM_AP_Msk = 0x8
	// Bit MDM_AP.
	RCM_SRS1_MDM_AP = 0x8
	// Reset not caused by host debugger system setting of the System Reset Request bit
	RCM_SRS1_MDM_AP_0 = 0x0
	// Reset caused by host debugger system setting of the System Reset Request bit
	RCM_SRS1_MDM_AP_1 = 0x1
	// Position of EZPT field.
	RCM_SRS1_EZPT_Pos = 0x4
	// Bit mask of EZPT field.
	RCM_SRS1_EZPT_Msk = 0x10
	// Bit EZPT.
	RCM_SRS1_EZPT = 0x10
	// Reset not caused by EzPort receiving the RESET command while the device is in EzPort mode
	RCM_SRS1_EZPT_0 = 0x0
	// Reset caused by EzPort receiving the RESET command while the device is in EzPort mode
	RCM_SRS1_EZPT_1 = 0x1
	// Position of SACKERR field.
	RCM_SRS1_SACKERR_Pos = 0x5
	// Bit mask of SACKERR field.
	RCM_SRS1_SACKERR_Msk = 0x20
	// Bit SACKERR.
	RCM_SRS1_SACKERR = 0x20
	// Reset not caused by peripheral failure to acknowledge attempt to enter stop mode
	RCM_SRS1_SACKERR_0 = 0x0
	// Reset caused by peripheral failure to acknowledge attempt to enter stop mode
	RCM_SRS1_SACKERR_1 = 0x1

	// RPFC: Reset Pin Filter Control register
	// Position of RSTFLTSRW field.
	RCM_RPFC_RSTFLTSRW_Pos = 0x0
	// Bit mask of RSTFLTSRW field.
	RCM_RPFC_RSTFLTSRW_Msk = 0x3
	// All filtering disabled
	RCM_RPFC_RSTFLTSRW_00 = 0x0
	// Bus clock filter enabled for normal operation
	RCM_RPFC_RSTFLTSRW_01 = 0x1
	// LPO clock filter enabled for normal operation
	RCM_RPFC_RSTFLTSRW_10 = 0x2
	// Position of RSTFLTSS field.
	RCM_RPFC_RSTFLTSS_Pos = 0x2
	// Bit mask of RSTFLTSS field.
	RCM_RPFC_RSTFLTSS_Msk = 0x4
	// Bit RSTFLTSS.
	RCM_RPFC_RSTFLTSS = 0x4
	// All filtering disabled
	RCM_RPFC_RSTFLTSS_0 = 0x0
	// LPO clock filter enabled
	RCM_RPFC_RSTFLTSS_1 = 0x1

	// RPFW: Reset Pin Filter Width register
	// Position of RSTFLTSEL field.
	RCM_RPFW_RSTFLTSEL_Pos = 0x0
	// Bit mask of RSTFLTSEL field.
	RCM_RPFW_RSTFLTSEL_Msk = 0x1f
	// Bus clock filter count is 1
	RCM_RPFW_RSTFLTSEL_00000 = 0x0
	// Bus clock filter count is 2
	RCM_RPFW_RSTFLTSEL_00001 = 0x1
	// Bus clock filter count is 3
	RCM_RPFW_RSTFLTSEL_00010 = 0x2
	// Bus clock filter count is 4
	RCM_RPFW_RSTFLTSEL_00011 = 0x3
	// Bus clock filter count is 5
	RCM_RPFW_RSTFLTSEL_00100 = 0x4
	// Bus clock filter count is 6
	RCM_RPFW_RSTFLTSEL_00101 = 0x5
	// Bus clock filter count is 7
	RCM_RPFW_RSTFLTSEL_00110 = 0x6
	// Bus clock filter count is 8
	RCM_RPFW_RSTFLTSEL_00111 = 0x7
	// Bus clock filter count is 9
	RCM_RPFW_RSTFLTSEL_01000 = 0x8
	// Bus clock filter count is 10
	RCM_RPFW_RSTFLTSEL_01001 = 0x9
	// Bus clock filter count is 11
	RCM_RPFW_RSTFLTSEL_01010 = 0xa
	// Bus clock filter count is 12
	RCM_RPFW_RSTFLTSEL_01011 = 0xb
	// Bus clock filter count is 13
	RCM_RPFW_RSTFLTSEL_01100 = 0xc
	// Bus clock filter count is 14
	RCM_RPFW_RSTFLTSEL_01101 = 0xd
	// Bus clock filter count is 15
	RCM_RPFW_RSTFLTSEL_01110 = 0xe
	// Bus clock filter count is 16
	RCM_RPFW_RSTFLTSEL_01111 = 0xf
	// Bus clock filter count is 17
	RCM_RPFW_RSTFLTSEL_10000 = 0x10
	// Bus clock filter count is 18
	RCM_RPFW_RSTFLTSEL_10001 = 0x11
	// Bus clock filter count is 19
	RCM_RPFW_RSTFLTSEL_10010 = 0x12
	// Bus clock filter count is 20
	RCM_RPFW_RSTFLTSEL_10011 = 0x13
	// Bus clock filter count is 21
	RCM_RPFW_RSTFLTSEL_10100 = 0x14
	// Bus clock filter count is 22
	RCM_RPFW_RSTFLTSEL_10101 = 0x15
	// Bus clock filter count is 23
	RCM_RPFW_RSTFLTSEL_10110 = 0x16
	// Bus clock filter count is 24
	RCM_RPFW_RSTFLTSEL_10111 = 0x17
	// Bus clock filter count is 25
	RCM_RPFW_RSTFLTSEL_11000 = 0x18
	// Bus clock filter count is 26
	RCM_RPFW_RSTFLTSEL_11001 = 0x19
	// Bus clock filter count is 27
	RCM_RPFW_RSTFLTSEL_11010 = 0x1a
	// Bus clock filter count is 28
	RCM_RPFW_RSTFLTSEL_11011 = 0x1b
	// Bus clock filter count is 29
	RCM_RPFW_RSTFLTSEL_11100 = 0x1c
	// Bus clock filter count is 30
	RCM_RPFW_RSTFLTSEL_11101 = 0x1d
	// Bus clock filter count is 31
	RCM_RPFW_RSTFLTSEL_11110 = 0x1e
	// Bus clock filter count is 32
	RCM_RPFW_RSTFLTSEL_11111 = 0x1f

	// MR: Mode Register
	// Position of EZP_MS field.
	RCM_MR_EZP_MS_Pos = 0x1
	// Bit mask of EZP_MS field.
	RCM_MR_EZP_MS_Msk = 0x2
	// Bit EZP_MS.
	RCM_MR_EZP_MS = 0x2
	// Pin deasserted (logic 1)
	RCM_MR_EZP_MS_0 = 0x0
	// Pin asserted (logic 0)
	RCM_MR_EZP_MS_1 = 0x1
)

// Constants for SDHC: Secured Digital Host Controller
const (
	// DSADDR: DMA System Address register
	// Position of DSADDR field.
	SDHC_DSADDR_DSADDR_Pos = 0x2
	// Bit mask of DSADDR field.
	SDHC_DSADDR_DSADDR_Msk = 0xfffffffc

	// BLKATTR: Block Attributes register
	// Position of BLKSIZE field.
	SDHC_BLKATTR_BLKSIZE_Pos = 0x0
	// Bit mask of BLKSIZE field.
	SDHC_BLKATTR_BLKSIZE_Msk = 0x1fff
	// No data transfer.
	SDHC_BLKATTR_BLKSIZE_0 = 0x0
	// 1 Byte
	SDHC_BLKATTR_BLKSIZE_1 = 0x1
	// 2 Bytes
	SDHC_BLKATTR_BLKSIZE_10 = 0x2
	// 3 Bytes
	SDHC_BLKATTR_BLKSIZE_11 = 0x3
	// 4 Bytes
	SDHC_BLKATTR_BLKSIZE_100 = 0x4
	// 511 Bytes
	SDHC_BLKATTR_BLKSIZE_111111111 = 0x1ff
	// 512 Bytes
	SDHC_BLKATTR_BLKSIZE_1000000000 = 0x200
	// 2048 Bytes
	SDHC_BLKATTR_BLKSIZE_100000000000 = 0x800
	// 4096 Bytes
	SDHC_BLKATTR_BLKSIZE_1000000000000 = 0x1000
	// Position of BLKCNT field.
	SDHC_BLKATTR_BLKCNT_Pos = 0x10
	// Bit mask of BLKCNT field.
	SDHC_BLKATTR_BLKCNT_Msk = 0xffff0000
	// Stop count.
	SDHC_BLKATTR_BLKCNT_0 = 0x0
	// 1 block
	SDHC_BLKATTR_BLKCNT_1 = 0x1
	// 2 blocks
	SDHC_BLKATTR_BLKCNT_10 = 0x2
	// 65535 blocks
	SDHC_BLKATTR_BLKCNT_1111111111111111 = 0xffff

	// CMDARG: Command Argument register
	// Position of CMDARG field.
	SDHC_CMDARG_CMDARG_Pos = 0x0
	// Bit mask of CMDARG field.
	SDHC_CMDARG_CMDARG_Msk = 0xffffffff

	// XFERTYP: Transfer Type register
	// Position of DMAEN field.
	SDHC_XFERTYP_DMAEN_Pos = 0x0
	// Bit mask of DMAEN field.
	SDHC_XFERTYP_DMAEN_Msk = 0x1
	// Bit DMAEN.
	SDHC_XFERTYP_DMAEN = 0x1
	// Disable
	SDHC_XFERTYP_DMAEN_0 = 0x0
	// Enable
	SDHC_XFERTYP_DMAEN_1 = 0x1
	// Position of BCEN field.
	SDHC_XFERTYP_BCEN_Pos = 0x1
	// Bit mask of BCEN field.
	SDHC_XFERTYP_BCEN_Msk = 0x2
	// Bit BCEN.
	SDHC_XFERTYP_BCEN = 0x2
	// Disable
	SDHC_XFERTYP_BCEN_0 = 0x0
	// Enable
	SDHC_XFERTYP_BCEN_1 = 0x1
	// Position of AC12EN field.
	SDHC_XFERTYP_AC12EN_Pos = 0x2
	// Bit mask of AC12EN field.
	SDHC_XFERTYP_AC12EN_Msk = 0x4
	// Bit AC12EN.
	SDHC_XFERTYP_AC12EN = 0x4
	// Disable
	SDHC_XFERTYP_AC12EN_0 = 0x0
	// Enable
	SDHC_XFERTYP_AC12EN_1 = 0x1
	// Position of DTDSEL field.
	SDHC_XFERTYP_DTDSEL_Pos = 0x4
	// Bit mask of DTDSEL field.
	SDHC_XFERTYP_DTDSEL_Msk = 0x10
	// Bit DTDSEL.
	SDHC_XFERTYP_DTDSEL = 0x10
	// Write host to card.
	SDHC_XFERTYP_DTDSEL_0 = 0x0
	// Read card to host.
	SDHC_XFERTYP_DTDSEL_1 = 0x1
	// Position of MSBSEL field.
	SDHC_XFERTYP_MSBSEL_Pos = 0x5
	// Bit mask of MSBSEL field.
	SDHC_XFERTYP_MSBSEL_Msk = 0x20
	// Bit MSBSEL.
	SDHC_XFERTYP_MSBSEL = 0x20
	// Single block.
	SDHC_XFERTYP_MSBSEL_0 = 0x0
	// Multiple blocks.
	SDHC_XFERTYP_MSBSEL_1 = 0x1
	// Position of RSPTYP field.
	SDHC_XFERTYP_RSPTYP_Pos = 0x10
	// Bit mask of RSPTYP field.
	SDHC_XFERTYP_RSPTYP_Msk = 0x30000
	// No response.
	SDHC_XFERTYP_RSPTYP_00 = 0x0
	// Response length 136.
	SDHC_XFERTYP_RSPTYP_01 = 0x1
	// Response length 48.
	SDHC_XFERTYP_RSPTYP_10 = 0x2
	// Response length 48, check busy after response.
	SDHC_XFERTYP_RSPTYP_11 = 0x3
	// Position of CCCEN field.
	SDHC_XFERTYP_CCCEN_Pos = 0x13
	// Bit mask of CCCEN field.
	SDHC_XFERTYP_CCCEN_Msk = 0x80000
	// Bit CCCEN.
	SDHC_XFERTYP_CCCEN = 0x80000
	// Disable
	SDHC_XFERTYP_CCCEN_0 = 0x0
	// Enable
	SDHC_XFERTYP_CCCEN_1 = 0x1
	// Position of CICEN field.
	SDHC_XFERTYP_CICEN_Pos = 0x14
	// Bit mask of CICEN field.
	SDHC_XFERTYP_CICEN_Msk = 0x100000
	// Bit CICEN.
	SDHC_XFERTYP_CICEN = 0x100000
	// Disable
	SDHC_XFERTYP_CICEN_0 = 0x0
	// Enable
	SDHC_XFERTYP_CICEN_1 = 0x1
	// Position of DPSEL field.
	SDHC_XFERTYP_DPSEL_Pos = 0x15
	// Bit mask of DPSEL field.
	SDHC_XFERTYP_DPSEL_Msk = 0x200000
	// Bit DPSEL.
	SDHC_XFERTYP_DPSEL = 0x200000
	// No data present.
	SDHC_XFERTYP_DPSEL_0 = 0x0
	// Data present.
	SDHC_XFERTYP_DPSEL_1 = 0x1
	// Position of CMDTYP field.
	SDHC_XFERTYP_CMDTYP_Pos = 0x16
	// Bit mask of CMDTYP field.
	SDHC_XFERTYP_CMDTYP_Msk = 0xc00000
	// Normal other commands.
	SDHC_XFERTYP_CMDTYP_00 = 0x0
	// Suspend CMD52 for writing bus suspend in CCCR.
	SDHC_XFERTYP_CMDTYP_01 = 0x1
	// Resume CMD52 for writing function select in CCCR.
	SDHC_XFERTYP_CMDTYP_10 = 0x2
	// Abort CMD12, CMD52 for writing I/O abort in CCCR.
	SDHC_XFERTYP_CMDTYP_11 = 0x3
	// Position of CMDINX field.
	SDHC_XFERTYP_CMDINX_Pos = 0x18
	// Bit mask of CMDINX field.
	SDHC_XFERTYP_CMDINX_Msk = 0x3f000000

	// CMDRSP0: Command Response 0
	// Position of CMDRSP0 field.
	SDHC_CMDRSP0_CMDRSP0_Pos = 0x0
	// Bit mask of CMDRSP0 field.
	SDHC_CMDRSP0_CMDRSP0_Msk = 0xffffffff

	// CMDRSP1: Command Response 1
	// Position of CMDRSP1 field.
	SDHC_CMDRSP1_CMDRSP1_Pos = 0x0
	// Bit mask of CMDRSP1 field.
	SDHC_CMDRSP1_CMDRSP1_Msk = 0xffffffff

	// CMDRSP2: Command Response 2
	// Position of CMDRSP2 field.
	SDHC_CMDRSP2_CMDRSP2_Pos = 0x0
	// Bit mask of CMDRSP2 field.
	SDHC_CMDRSP2_CMDRSP2_Msk = 0xffffffff

	// CMDRSP3: Command Response 3
	// Position of CMDRSP3 field.
	SDHC_CMDRSP3_CMDRSP3_Pos = 0x0
	// Bit mask of CMDRSP3 field.
	SDHC_CMDRSP3_CMDRSP3_Msk = 0xffffffff

	// DATPORT: Buffer Data Port register
	// Position of DATCONT field.
	SDHC_DATPORT_DATCONT_Pos = 0x0
	// Bit mask of DATCONT field.
	SDHC_DATPORT_DATCONT_Msk = 0xffffffff

	// PRSSTAT: Present State register
	// Position of CIHB field.
	SDHC_PRSSTAT_CIHB_Pos = 0x0
	// Bit mask of CIHB field.
	SDHC_PRSSTAT_CIHB_Msk = 0x1
	// Bit CIHB.
	SDHC_PRSSTAT_CIHB = 0x1
	// Can issue command using only CMD line.
	SDHC_PRSSTAT_CIHB_0 = 0x0
	// Cannot issue command.
	SDHC_PRSSTAT_CIHB_1 = 0x1
	// Position of CDIHB field.
	SDHC_PRSSTAT_CDIHB_Pos = 0x1
	// Bit mask of CDIHB field.
	SDHC_PRSSTAT_CDIHB_Msk = 0x2
	// Bit CDIHB.
	SDHC_PRSSTAT_CDIHB = 0x2
	// Can issue command which uses the DAT line.
	SDHC_PRSSTAT_CDIHB_0 = 0x0
	// Cannot issue command which uses the DAT line.
	SDHC_PRSSTAT_CDIHB_1 = 0x1
	// Position of DLA field.
	SDHC_PRSSTAT_DLA_Pos = 0x2
	// Bit mask of DLA field.
	SDHC_PRSSTAT_DLA_Msk = 0x4
	// Bit DLA.
	SDHC_PRSSTAT_DLA = 0x4
	// DAT line inactive.
	SDHC_PRSSTAT_DLA_0 = 0x0
	// DAT line active.
	SDHC_PRSSTAT_DLA_1 = 0x1
	// Position of SDSTB field.
	SDHC_PRSSTAT_SDSTB_Pos = 0x3
	// Bit mask of SDSTB field.
	SDHC_PRSSTAT_SDSTB_Msk = 0x8
	// Bit SDSTB.
	SDHC_PRSSTAT_SDSTB = 0x8
	// Clock is changing frequency and not stable.
	SDHC_PRSSTAT_SDSTB_0 = 0x0
	// Clock is stable.
	SDHC_PRSSTAT_SDSTB_1 = 0x1
	// Position of IPGOFF field.
	SDHC_PRSSTAT_IPGOFF_Pos = 0x4
	// Bit mask of IPGOFF field.
	SDHC_PRSSTAT_IPGOFF_Msk = 0x10
	// Bit IPGOFF.
	SDHC_PRSSTAT_IPGOFF = 0x10
	// Bus clock is active.
	SDHC_PRSSTAT_IPGOFF_0 = 0x0
	// Bus clock is gated off.
	SDHC_PRSSTAT_IPGOFF_1 = 0x1
	// Position of HCKOFF field.
	SDHC_PRSSTAT_HCKOFF_Pos = 0x5
	// Bit mask of HCKOFF field.
	SDHC_PRSSTAT_HCKOFF_Msk = 0x20
	// Bit HCKOFF.
	SDHC_PRSSTAT_HCKOFF = 0x20
	// System clock is active.
	SDHC_PRSSTAT_HCKOFF_0 = 0x0
	// System clock is gated off.
	SDHC_PRSSTAT_HCKOFF_1 = 0x1
	// Position of PEROFF field.
	SDHC_PRSSTAT_PEROFF_Pos = 0x6
	// Bit mask of PEROFF field.
	SDHC_PRSSTAT_PEROFF_Msk = 0x40
	// Bit PEROFF.
	SDHC_PRSSTAT_PEROFF = 0x40
	// SDHC clock is active.
	SDHC_PRSSTAT_PEROFF_0 = 0x0
	// SDHC clock is gated off.
	SDHC_PRSSTAT_PEROFF_1 = 0x1
	// Position of SDOFF field.
	SDHC_PRSSTAT_SDOFF_Pos = 0x7
	// Bit mask of SDOFF field.
	SDHC_PRSSTAT_SDOFF_Msk = 0x80
	// Bit SDOFF.
	SDHC_PRSSTAT_SDOFF = 0x80
	// SD clock is active.
	SDHC_PRSSTAT_SDOFF_0 = 0x0
	// SD clock is gated off.
	SDHC_PRSSTAT_SDOFF_1 = 0x1
	// Position of WTA field.
	SDHC_PRSSTAT_WTA_Pos = 0x8
	// Bit mask of WTA field.
	SDHC_PRSSTAT_WTA_Msk = 0x100
	// Bit WTA.
	SDHC_PRSSTAT_WTA = 0x100
	// No valid data.
	SDHC_PRSSTAT_WTA_0 = 0x0
	// Transferring data.
	SDHC_PRSSTAT_WTA_1 = 0x1
	// Position of RTA field.
	SDHC_PRSSTAT_RTA_Pos = 0x9
	// Bit mask of RTA field.
	SDHC_PRSSTAT_RTA_Msk = 0x200
	// Bit RTA.
	SDHC_PRSSTAT_RTA = 0x200
	// No valid data.
	SDHC_PRSSTAT_RTA_0 = 0x0
	// Transferring data.
	SDHC_PRSSTAT_RTA_1 = 0x1
	// Position of BWEN field.
	SDHC_PRSSTAT_BWEN_Pos = 0xa
	// Bit mask of BWEN field.
	SDHC_PRSSTAT_BWEN_Msk = 0x400
	// Bit BWEN.
	SDHC_PRSSTAT_BWEN = 0x400
	// Write disable, the buffer can hold valid data less than the write watermark level.
	SDHC_PRSSTAT_BWEN_0 = 0x0
	// Write enable, the buffer can hold valid data greater than the write watermark level.
	SDHC_PRSSTAT_BWEN_1 = 0x1
	// Position of BREN field.
	SDHC_PRSSTAT_BREN_Pos = 0xb
	// Bit mask of BREN field.
	SDHC_PRSSTAT_BREN_Msk = 0x800
	// Bit BREN.
	SDHC_PRSSTAT_BREN = 0x800
	// Read disable, valid data less than the watermark level exist in the buffer.
	SDHC_PRSSTAT_BREN_0 = 0x0
	// Read enable, valid data greater than the watermark level exist in the buffer.
	SDHC_PRSSTAT_BREN_1 = 0x1
	// Position of CINS field.
	SDHC_PRSSTAT_CINS_Pos = 0x10
	// Bit mask of CINS field.
	SDHC_PRSSTAT_CINS_Msk = 0x10000
	// Bit CINS.
	SDHC_PRSSTAT_CINS = 0x10000
	// Power on reset or no card.
	SDHC_PRSSTAT_CINS_0 = 0x0
	// Card inserted.
	SDHC_PRSSTAT_CINS_1 = 0x1
	// Position of CLSL field.
	SDHC_PRSSTAT_CLSL_Pos = 0x17
	// Bit mask of CLSL field.
	SDHC_PRSSTAT_CLSL_Msk = 0x800000
	// Bit CLSL.
	SDHC_PRSSTAT_CLSL = 0x800000
	// Position of DLSL field.
	SDHC_PRSSTAT_DLSL_Pos = 0x18
	// Bit mask of DLSL field.
	SDHC_PRSSTAT_DLSL_Msk = 0xff000000

	// PROCTL: Protocol Control register
	// Position of LCTL field.
	SDHC_PROCTL_LCTL_Pos = 0x0
	// Bit mask of LCTL field.
	SDHC_PROCTL_LCTL_Msk = 0x1
	// Bit LCTL.
	SDHC_PROCTL_LCTL = 0x1
	// LED off.
	SDHC_PROCTL_LCTL_0 = 0x0
	// LED on.
	SDHC_PROCTL_LCTL_1 = 0x1
	// Position of DTW field.
	SDHC_PROCTL_DTW_Pos = 0x1
	// Bit mask of DTW field.
	SDHC_PROCTL_DTW_Msk = 0x6
	// 1-bit mode
	SDHC_PROCTL_DTW_00 = 0x0
	// 4-bit mode
	SDHC_PROCTL_DTW_01 = 0x1
	// 8-bit mode
	SDHC_PROCTL_DTW_10 = 0x2
	// Position of D3CD field.
	SDHC_PROCTL_D3CD_Pos = 0x3
	// Bit mask of D3CD field.
	SDHC_PROCTL_D3CD_Msk = 0x8
	// Bit D3CD.
	SDHC_PROCTL_D3CD = 0x8
	// DAT3 does not monitor card Insertion.
	SDHC_PROCTL_D3CD_0 = 0x0
	// DAT3 as card detection pin.
	SDHC_PROCTL_D3CD_1 = 0x1
	// Position of EMODE field.
	SDHC_PROCTL_EMODE_Pos = 0x4
	// Bit mask of EMODE field.
	SDHC_PROCTL_EMODE_Msk = 0x30
	// Big endian mode
	SDHC_PROCTL_EMODE_00 = 0x0
	// Half word big endian mode
	SDHC_PROCTL_EMODE_01 = 0x1
	// Little endian mode
	SDHC_PROCTL_EMODE_10 = 0x2
	// Position of CDTL field.
	SDHC_PROCTL_CDTL_Pos = 0x6
	// Bit mask of CDTL field.
	SDHC_PROCTL_CDTL_Msk = 0x40
	// Bit CDTL.
	SDHC_PROCTL_CDTL = 0x40
	// Card detect test level is 0, no card inserted.
	SDHC_PROCTL_CDTL_0 = 0x0
	// Card detect test level is 1, card inserted.
	SDHC_PROCTL_CDTL_1 = 0x1
	// Position of CDSS field.
	SDHC_PROCTL_CDSS_Pos = 0x7
	// Bit mask of CDSS field.
	SDHC_PROCTL_CDSS_Msk = 0x80
	// Bit CDSS.
	SDHC_PROCTL_CDSS = 0x80
	// Card detection level is selected for normal purpose.
	SDHC_PROCTL_CDSS_0 = 0x0
	// Card detection test level is selected for test purpose.
	SDHC_PROCTL_CDSS_1 = 0x1
	// Position of DMAS field.
	SDHC_PROCTL_DMAS_Pos = 0x8
	// Bit mask of DMAS field.
	SDHC_PROCTL_DMAS_Msk = 0x300
	// No DMA or simple DMA is selected.
	SDHC_PROCTL_DMAS_00 = 0x0
	// ADMA1 is selected.
	SDHC_PROCTL_DMAS_01 = 0x1
	// ADMA2 is selected.
	SDHC_PROCTL_DMAS_10 = 0x2
	// Position of SABGREQ field.
	SDHC_PROCTL_SABGREQ_Pos = 0x10
	// Bit mask of SABGREQ field.
	SDHC_PROCTL_SABGREQ_Msk = 0x10000
	// Bit SABGREQ.
	SDHC_PROCTL_SABGREQ = 0x10000
	// Transfer
	SDHC_PROCTL_SABGREQ_0 = 0x0
	// Stop
	SDHC_PROCTL_SABGREQ_1 = 0x1
	// Position of CREQ field.
	SDHC_PROCTL_CREQ_Pos = 0x11
	// Bit mask of CREQ field.
	SDHC_PROCTL_CREQ_Msk = 0x20000
	// Bit CREQ.
	SDHC_PROCTL_CREQ = 0x20000
	// No effect.
	SDHC_PROCTL_CREQ_0 = 0x0
	// Restart
	SDHC_PROCTL_CREQ_1 = 0x1
	// Position of RWCTL field.
	SDHC_PROCTL_RWCTL_Pos = 0x12
	// Bit mask of RWCTL field.
	SDHC_PROCTL_RWCTL_Msk = 0x40000
	// Bit RWCTL.
	SDHC_PROCTL_RWCTL = 0x40000
	// Disable read wait control, and stop SD clock at block gap when SABGREQ is set.
	SDHC_PROCTL_RWCTL_0 = 0x0
	// Enable read wait control, and assert read wait without stopping SD clock at block gap when SABGREQ bit is set.
	SDHC_PROCTL_RWCTL_1 = 0x1
	// Position of IABG field.
	SDHC_PROCTL_IABG_Pos = 0x13
	// Bit mask of IABG field.
	SDHC_PROCTL_IABG_Msk = 0x80000
	// Bit IABG.
	SDHC_PROCTL_IABG = 0x80000
	// Disabled
	SDHC_PROCTL_IABG_0 = 0x0
	// Enabled
	SDHC_PROCTL_IABG_1 = 0x1
	// Position of WECINT field.
	SDHC_PROCTL_WECINT_Pos = 0x18
	// Bit mask of WECINT field.
	SDHC_PROCTL_WECINT_Msk = 0x1000000
	// Bit WECINT.
	SDHC_PROCTL_WECINT = 0x1000000
	// Disabled
	SDHC_PROCTL_WECINT_0 = 0x0
	// Enabled
	SDHC_PROCTL_WECINT_1 = 0x1
	// Position of WECINS field.
	SDHC_PROCTL_WECINS_Pos = 0x19
	// Bit mask of WECINS field.
	SDHC_PROCTL_WECINS_Msk = 0x2000000
	// Bit WECINS.
	SDHC_PROCTL_WECINS = 0x2000000
	// Disabled
	SDHC_PROCTL_WECINS_0 = 0x0
	// Enabled
	SDHC_PROCTL_WECINS_1 = 0x1
	// Position of WECRM field.
	SDHC_PROCTL_WECRM_Pos = 0x1a
	// Bit mask of WECRM field.
	SDHC_PROCTL_WECRM_Msk = 0x4000000
	// Bit WECRM.
	SDHC_PROCTL_WECRM = 0x4000000
	// Disabled
	SDHC_PROCTL_WECRM_0 = 0x0
	// Enabled
	SDHC_PROCTL_WECRM_1 = 0x1

	// SYSCTL: System Control register
	// Position of IPGEN field.
	SDHC_SYSCTL_IPGEN_Pos = 0x0
	// Bit mask of IPGEN field.
	SDHC_SYSCTL_IPGEN_Msk = 0x1
	// Bit IPGEN.
	SDHC_SYSCTL_IPGEN = 0x1
	// Bus clock will be internally gated off.
	SDHC_SYSCTL_IPGEN_0 = 0x0
	// Bus clock will not be automatically gated off.
	SDHC_SYSCTL_IPGEN_1 = 0x1
	// Position of HCKEN field.
	SDHC_SYSCTL_HCKEN_Pos = 0x1
	// Bit mask of HCKEN field.
	SDHC_SYSCTL_HCKEN_Msk = 0x2
	// Bit HCKEN.
	SDHC_SYSCTL_HCKEN = 0x2
	// System clock will be internally gated off.
	SDHC_SYSCTL_HCKEN_0 = 0x0
	// System clock will not be automatically gated off.
	SDHC_SYSCTL_HCKEN_1 = 0x1
	// Position of PEREN field.
	SDHC_SYSCTL_PEREN_Pos = 0x2
	// Bit mask of PEREN field.
	SDHC_SYSCTL_PEREN_Msk = 0x4
	// Bit PEREN.
	SDHC_SYSCTL_PEREN = 0x4
	// SDHC clock will be internally gated off.
	SDHC_SYSCTL_PEREN_0 = 0x0
	// SDHC clock will not be automatically gated off.
	SDHC_SYSCTL_PEREN_1 = 0x1
	// Position of SDCLKEN field.
	SDHC_SYSCTL_SDCLKEN_Pos = 0x3
	// Bit mask of SDCLKEN field.
	SDHC_SYSCTL_SDCLKEN_Msk = 0x8
	// Bit SDCLKEN.
	SDHC_SYSCTL_SDCLKEN = 0x8
	// Position of DVS field.
	SDHC_SYSCTL_DVS_Pos = 0x4
	// Bit mask of DVS field.
	SDHC_SYSCTL_DVS_Msk = 0xf0
	// Divisor by 1.
	SDHC_SYSCTL_DVS_0 = 0x0
	// Divisor by 2.
	SDHC_SYSCTL_DVS_1 = 0x1
	// Divisor by 15.
	SDHC_SYSCTL_DVS_1110 = 0xe
	// Divisor by 16.
	SDHC_SYSCTL_DVS_1111 = 0xf
	// Position of SDCLKFS field.
	SDHC_SYSCTL_SDCLKFS_Pos = 0x8
	// Bit mask of SDCLKFS field.
	SDHC_SYSCTL_SDCLKFS_Msk = 0xff00
	// Base clock divided by 2.
	SDHC_SYSCTL_SDCLKFS_1 = 0x1
	// Base clock divided by 4.
	SDHC_SYSCTL_SDCLKFS_10 = 0x2
	// Base clock divided by 8.
	SDHC_SYSCTL_SDCLKFS_100 = 0x4
	// Base clock divided by 16.
	SDHC_SYSCTL_SDCLKFS_1000 = 0x8
	// Base clock divided by 32.
	SDHC_SYSCTL_SDCLKFS_10000 = 0x10
	// Base clock divided by 64.
	SDHC_SYSCTL_SDCLKFS_100000 = 0x20
	// Base clock divided by 128.
	SDHC_SYSCTL_SDCLKFS_1000000 = 0x40
	// Base clock divided by 256.
	SDHC_SYSCTL_SDCLKFS_10000000 = 0x80
	// Position of DTOCV field.
	SDHC_SYSCTL_DTOCV_Pos = 0x10
	// Bit mask of DTOCV field.
	SDHC_SYSCTL_DTOCV_Msk = 0xf0000
	// SDCLK x 2 13
	SDHC_SYSCTL_DTOCV_0000 = 0x0
	// SDCLK x 2 14
	SDHC_SYSCTL_DTOCV_0001 = 0x1
	// SDCLK x 2 27
	SDHC_SYSCTL_DTOCV_1110 = 0xe
	// Position of RSTA field.
	SDHC_SYSCTL_RSTA_Pos = 0x18
	// Bit mask of RSTA field.
	SDHC_SYSCTL_RSTA_Msk = 0x1000000
	// Bit RSTA.
	SDHC_SYSCTL_RSTA = 0x1000000
	// No reset.
	SDHC_SYSCTL_RSTA_0 = 0x0
	// Reset.
	SDHC_SYSCTL_RSTA_1 = 0x1
	// Position of RSTC field.
	SDHC_SYSCTL_RSTC_Pos = 0x19
	// Bit mask of RSTC field.
	SDHC_SYSCTL_RSTC_Msk = 0x2000000
	// Bit RSTC.
	SDHC_SYSCTL_RSTC = 0x2000000
	// No reset.
	SDHC_SYSCTL_RSTC_0 = 0x0
	// Reset.
	SDHC_SYSCTL_RSTC_1 = 0x1
	// Position of RSTD field.
	SDHC_SYSCTL_RSTD_Pos = 0x1a
	// Bit mask of RSTD field.
	SDHC_SYSCTL_RSTD_Msk = 0x4000000
	// Bit RSTD.
	SDHC_SYSCTL_RSTD = 0x4000000
	// No reset.
	SDHC_SYSCTL_RSTD_0 = 0x0
	// Reset.
	SDHC_SYSCTL_RSTD_1 = 0x1
	// Position of INITA field.
	SDHC_SYSCTL_INITA_Pos = 0x1b
	// Bit mask of INITA field.
	SDHC_SYSCTL_INITA_Msk = 0x8000000
	// Bit INITA.
	SDHC_SYSCTL_INITA = 0x8000000

	// IRQSTAT: Interrupt Status register
	// Position of CC field.
	SDHC_IRQSTAT_CC_Pos = 0x0
	// Bit mask of CC field.
	SDHC_IRQSTAT_CC_Msk = 0x1
	// Bit CC.
	SDHC_IRQSTAT_CC = 0x1
	// Command not complete.
	SDHC_IRQSTAT_CC_0 = 0x0
	// Command complete.
	SDHC_IRQSTAT_CC_1 = 0x1
	// Position of TC field.
	SDHC_IRQSTAT_TC_Pos = 0x1
	// Bit mask of TC field.
	SDHC_IRQSTAT_TC_Msk = 0x2
	// Bit TC.
	SDHC_IRQSTAT_TC = 0x2
	// Transfer not complete.
	SDHC_IRQSTAT_TC_0 = 0x0
	// Transfer complete.
	SDHC_IRQSTAT_TC_1 = 0x1
	// Position of BGE field.
	SDHC_IRQSTAT_BGE_Pos = 0x2
	// Bit mask of BGE field.
	SDHC_IRQSTAT_BGE_Msk = 0x4
	// Bit BGE.
	SDHC_IRQSTAT_BGE = 0x4
	// No block gap event.
	SDHC_IRQSTAT_BGE_0 = 0x0
	// Transaction stopped at block gap.
	SDHC_IRQSTAT_BGE_1 = 0x1
	// Position of DINT field.
	SDHC_IRQSTAT_DINT_Pos = 0x3
	// Bit mask of DINT field.
	SDHC_IRQSTAT_DINT_Msk = 0x8
	// Bit DINT.
	SDHC_IRQSTAT_DINT = 0x8
	// No DMA Interrupt.
	SDHC_IRQSTAT_DINT_0 = 0x0
	// DMA Interrupt is generated.
	SDHC_IRQSTAT_DINT_1 = 0x1
	// Position of BWR field.
	SDHC_IRQSTAT_BWR_Pos = 0x4
	// Bit mask of BWR field.
	SDHC_IRQSTAT_BWR_Msk = 0x10
	// Bit BWR.
	SDHC_IRQSTAT_BWR = 0x10
	// Not ready to write buffer.
	SDHC_IRQSTAT_BWR_0 = 0x0
	// Ready to write buffer.
	SDHC_IRQSTAT_BWR_1 = 0x1
	// Position of BRR field.
	SDHC_IRQSTAT_BRR_Pos = 0x5
	// Bit mask of BRR field.
	SDHC_IRQSTAT_BRR_Msk = 0x20
	// Bit BRR.
	SDHC_IRQSTAT_BRR = 0x20
	// Not ready to read buffer.
	SDHC_IRQSTAT_BRR_0 = 0x0
	// Ready to read buffer.
	SDHC_IRQSTAT_BRR_1 = 0x1
	// Position of CINS field.
	SDHC_IRQSTAT_CINS_Pos = 0x6
	// Bit mask of CINS field.
	SDHC_IRQSTAT_CINS_Msk = 0x40
	// Bit CINS.
	SDHC_IRQSTAT_CINS = 0x40
	// Card state unstable or removed.
	SDHC_IRQSTAT_CINS_0 = 0x0
	// Card inserted.
	SDHC_IRQSTAT_CINS_1 = 0x1
	// Position of CRM field.
	SDHC_IRQSTAT_CRM_Pos = 0x7
	// Bit mask of CRM field.
	SDHC_IRQSTAT_CRM_Msk = 0x80
	// Bit CRM.
	SDHC_IRQSTAT_CRM = 0x80
	// Card state unstable or inserted.
	SDHC_IRQSTAT_CRM_0 = 0x0
	// Card removed.
	SDHC_IRQSTAT_CRM_1 = 0x1
	// Position of CINT field.
	SDHC_IRQSTAT_CINT_Pos = 0x8
	// Bit mask of CINT field.
	SDHC_IRQSTAT_CINT_Msk = 0x100
	// Bit CINT.
	SDHC_IRQSTAT_CINT = 0x100
	// No Card Interrupt.
	SDHC_IRQSTAT_CINT_0 = 0x0
	// Generate Card Interrupt.
	SDHC_IRQSTAT_CINT_1 = 0x1
	// Position of CTOE field.
	SDHC_IRQSTAT_CTOE_Pos = 0x10
	// Bit mask of CTOE field.
	SDHC_IRQSTAT_CTOE_Msk = 0x10000
	// Bit CTOE.
	SDHC_IRQSTAT_CTOE = 0x10000
	// No error.
	SDHC_IRQSTAT_CTOE_0 = 0x0
	// Time out.
	SDHC_IRQSTAT_CTOE_1 = 0x1
	// Position of CCE field.
	SDHC_IRQSTAT_CCE_Pos = 0x11
	// Bit mask of CCE field.
	SDHC_IRQSTAT_CCE_Msk = 0x20000
	// Bit CCE.
	SDHC_IRQSTAT_CCE = 0x20000
	// No error.
	SDHC_IRQSTAT_CCE_0 = 0x0
	// CRC Error generated.
	SDHC_IRQSTAT_CCE_1 = 0x1
	// Position of CEBE field.
	SDHC_IRQSTAT_CEBE_Pos = 0x12
	// Bit mask of CEBE field.
	SDHC_IRQSTAT_CEBE_Msk = 0x40000
	// Bit CEBE.
	SDHC_IRQSTAT_CEBE = 0x40000
	// No error.
	SDHC_IRQSTAT_CEBE_0 = 0x0
	// End Bit Error generated.
	SDHC_IRQSTAT_CEBE_1 = 0x1
	// Position of CIE field.
	SDHC_IRQSTAT_CIE_Pos = 0x13
	// Bit mask of CIE field.
	SDHC_IRQSTAT_CIE_Msk = 0x80000
	// Bit CIE.
	SDHC_IRQSTAT_CIE = 0x80000
	// No error.
	SDHC_IRQSTAT_CIE_0 = 0x0
	// Error.
	SDHC_IRQSTAT_CIE_1 = 0x1
	// Position of DTOE field.
	SDHC_IRQSTAT_DTOE_Pos = 0x14
	// Bit mask of DTOE field.
	SDHC_IRQSTAT_DTOE_Msk = 0x100000
	// Bit DTOE.
	SDHC_IRQSTAT_DTOE = 0x100000
	// No error.
	SDHC_IRQSTAT_DTOE_0 = 0x0
	// Time out.
	SDHC_IRQSTAT_DTOE_1 = 0x1
	// Position of DCE field.
	SDHC_IRQSTAT_DCE_Pos = 0x15
	// Bit mask of DCE field.
	SDHC_IRQSTAT_DCE_Msk = 0x200000
	// Bit DCE.
	SDHC_IRQSTAT_DCE = 0x200000
	// No error.
	SDHC_IRQSTAT_DCE_0 = 0x0
	// Error.
	SDHC_IRQSTAT_DCE_1 = 0x1
	// Position of DEBE field.
	SDHC_IRQSTAT_DEBE_Pos = 0x16
	// Bit mask of DEBE field.
	SDHC_IRQSTAT_DEBE_Msk = 0x400000
	// Bit DEBE.
	SDHC_IRQSTAT_DEBE = 0x400000
	// No error.
	SDHC_IRQSTAT_DEBE_0 = 0x0
	// Error.
	SDHC_IRQSTAT_DEBE_1 = 0x1
	// Position of AC12E field.
	SDHC_IRQSTAT_AC12E_Pos = 0x18
	// Bit mask of AC12E field.
	SDHC_IRQSTAT_AC12E_Msk = 0x1000000
	// Bit AC12E.
	SDHC_IRQSTAT_AC12E = 0x1000000
	// No error.
	SDHC_IRQSTAT_AC12E_0 = 0x0
	// Error.
	SDHC_IRQSTAT_AC12E_1 = 0x1
	// Position of DMAE field.
	SDHC_IRQSTAT_DMAE_Pos = 0x1c
	// Bit mask of DMAE field.
	SDHC_IRQSTAT_DMAE_Msk = 0x10000000
	// Bit DMAE.
	SDHC_IRQSTAT_DMAE = 0x10000000
	// No error.
	SDHC_IRQSTAT_DMAE_0 = 0x0
	// Error.
	SDHC_IRQSTAT_DMAE_1 = 0x1

	// IRQSTATEN: Interrupt Status Enable register
	// Position of CCSEN field.
	SDHC_IRQSTATEN_CCSEN_Pos = 0x0
	// Bit mask of CCSEN field.
	SDHC_IRQSTATEN_CCSEN_Msk = 0x1
	// Bit CCSEN.
	SDHC_IRQSTATEN_CCSEN = 0x1
	// Masked
	SDHC_IRQSTATEN_CCSEN_0 = 0x0
	// Enabled
	SDHC_IRQSTATEN_CCSEN_1 = 0x1
	// Position of TCSEN field.
	SDHC_IRQSTATEN_TCSEN_Pos = 0x1
	// Bit mask of TCSEN field.
	SDHC_IRQSTATEN_TCSEN_Msk = 0x2
	// Bit TCSEN.
	SDHC_IRQSTATEN_TCSEN = 0x2
	// Masked
	SDHC_IRQSTATEN_TCSEN_0 = 0x0
	// Enabled
	SDHC_IRQSTATEN_TCSEN_1 = 0x1
	// Position of BGESEN field.
	SDHC_IRQSTATEN_BGESEN_Pos = 0x2
	// Bit mask of BGESEN field.
	SDHC_IRQSTATEN_BGESEN_Msk = 0x4
	// Bit BGESEN.
	SDHC_IRQSTATEN_BGESEN = 0x4
	// Masked
	SDHC_IRQSTATEN_BGESEN_0 = 0x0
	// Enabled
	SDHC_IRQSTATEN_BGESEN_1 = 0x1
	// Position of DINTSEN field.
	SDHC_IRQSTATEN_DINTSEN_Pos = 0x3
	// Bit mask of DINTSEN field.
	SDHC_IRQSTATEN_DINTSEN_Msk = 0x8
	// Bit DINTSEN.
	SDHC_IRQSTATEN_DINTSEN = 0x8
	// Masked
	SDHC_IRQSTATEN_DINTSEN_0 = 0x0
	// Enabled
	SDHC_IRQSTATEN_DINTSEN_1 = 0x1
	// Position of BWRSEN field.
	SDHC_IRQSTATEN_BWRSEN_Pos = 0x4
	// Bit mask of BWRSEN field.
	SDHC_IRQSTATEN_BWRSEN_Msk = 0x10
	// Bit BWRSEN.
	SDHC_IRQSTATEN_BWRSEN = 0x10
	// Masked
	SDHC_IRQSTATEN_BWRSEN_0 = 0x0
	// Enabled
	SDHC_IRQSTATEN_BWRSEN_1 = 0x1
	// Position of BRRSEN field.
	SDHC_IRQSTATEN_BRRSEN_Pos = 0x5
	// Bit mask of BRRSEN field.
	SDHC_IRQSTATEN_BRRSEN_Msk = 0x20
	// Bit BRRSEN.
	SDHC_IRQSTATEN_BRRSEN = 0x20
	// Masked
	SDHC_IRQSTATEN_BRRSEN_0 = 0x0
	// Enabled
	SDHC_IRQSTATEN_BRRSEN_1 = 0x1
	// Position of CINSEN field.
	SDHC_IRQSTATEN_CINSEN_Pos = 0x6
	// Bit mask of CINSEN field.
	SDHC_IRQSTATEN_CINSEN_Msk = 0x40
	// Bit CINSEN.
	SDHC_IRQSTATEN_CINSEN = 0x40
	// Masked
	SDHC_IRQSTATEN_CINSEN_0 = 0x0
	// Enabled
	SDHC_IRQSTATEN_CINSEN_1 = 0x1
	// Position of CRMSEN field.
	SDHC_IRQSTATEN_CRMSEN_Pos = 0x7
	// Bit mask of CRMSEN field.
	SDHC_IRQSTATEN_CRMSEN_Msk = 0x80
	// Bit CRMSEN.
	SDHC_IRQSTATEN_CRMSEN = 0x80
	// Masked
	SDHC_IRQSTATEN_CRMSEN_0 = 0x0
	// Enabled
	SDHC_IRQSTATEN_CRMSEN_1 = 0x1
	// Position of CINTSEN field.
	SDHC_IRQSTATEN_CINTSEN_Pos = 0x8
	// Bit mask of CINTSEN field.
	SDHC_IRQSTATEN_CINTSEN_Msk = 0x100
	// Bit CINTSEN.
	SDHC_IRQSTATEN_CINTSEN = 0x100
	// Masked
	SDHC_IRQSTATEN_CINTSEN_0 = 0x0
	// Enabled
	SDHC_IRQSTATEN_CINTSEN_1 = 0x1
	// Position of CTOESEN field.
	SDHC_IRQSTATEN_CTOESEN_Pos = 0x10
	// Bit mask of CTOESEN field.
	SDHC_IRQSTATEN_CTOESEN_Msk = 0x10000
	// Bit CTOESEN.
	SDHC_IRQSTATEN_CTOESEN = 0x10000
	// Masked
	SDHC_IRQSTATEN_CTOESEN_0 = 0x0
	// Enabled
	SDHC_IRQSTATEN_CTOESEN_1 = 0x1
	// Position of CCESEN field.
	SDHC_IRQSTATEN_CCESEN_Pos = 0x11
	// Bit mask of CCESEN field.
	SDHC_IRQSTATEN_CCESEN_Msk = 0x20000
	// Bit CCESEN.
	SDHC_IRQSTATEN_CCESEN = 0x20000
	// Masked
	SDHC_IRQSTATEN_CCESEN_0 = 0x0
	// Enabled
	SDHC_IRQSTATEN_CCESEN_1 = 0x1
	// Position of CEBESEN field.
	SDHC_IRQSTATEN_CEBESEN_Pos = 0x12
	// Bit mask of CEBESEN field.
	SDHC_IRQSTATEN_CEBESEN_Msk = 0x40000
	// Bit CEBESEN.
	SDHC_IRQSTATEN_CEBESEN = 0x40000
	// Masked
	SDHC_IRQSTATEN_CEBESEN_0 = 0x0
	// Enabled
	SDHC_IRQSTATEN_CEBESEN_1 = 0x1
	// Position of CIESEN field.
	SDHC_IRQSTATEN_CIESEN_Pos = 0x13
	// Bit mask of CIESEN field.
	SDHC_IRQSTATEN_CIESEN_Msk = 0x80000
	// Bit CIESEN.
	SDHC_IRQSTATEN_CIESEN = 0x80000
	// Masked
	SDHC_IRQSTATEN_CIESEN_0 = 0x0
	// Enabled
	SDHC_IRQSTATEN_CIESEN_1 = 0x1
	// Position of DTOESEN field.
	SDHC_IRQSTATEN_DTOESEN_Pos = 0x14
	// Bit mask of DTOESEN field.
	SDHC_IRQSTATEN_DTOESEN_Msk = 0x100000
	// Bit DTOESEN.
	SDHC_IRQSTATEN_DTOESEN = 0x100000
	// Masked
	SDHC_IRQSTATEN_DTOESEN_0 = 0x0
	// Enabled
	SDHC_IRQSTATEN_DTOESEN_1 = 0x1
	// Position of DCESEN field.
	SDHC_IRQSTATEN_DCESEN_Pos = 0x15
	// Bit mask of DCESEN field.
	SDHC_IRQSTATEN_DCESEN_Msk = 0x200000
	// Bit DCESEN.
	SDHC_IRQSTATEN_DCESEN = 0x200000
	// Masked
	SDHC_IRQSTATEN_DCESEN_0 = 0x0
	// Enabled
	SDHC_IRQSTATEN_DCESEN_1 = 0x1
	// Position of DEBESEN field.
	SDHC_IRQSTATEN_DEBESEN_Pos = 0x16
	// Bit mask of DEBESEN field.
	SDHC_IRQSTATEN_DEBESEN_Msk = 0x400000
	// Bit DEBESEN.
	SDHC_IRQSTATEN_DEBESEN = 0x400000
	// Masked
	SDHC_IRQSTATEN_DEBESEN_0 = 0x0
	// Enabled
	SDHC_IRQSTATEN_DEBESEN_1 = 0x1
	// Position of AC12ESEN field.
	SDHC_IRQSTATEN_AC12ESEN_Pos = 0x18
	// Bit mask of AC12ESEN field.
	SDHC_IRQSTATEN_AC12ESEN_Msk = 0x1000000
	// Bit AC12ESEN.
	SDHC_IRQSTATEN_AC12ESEN = 0x1000000
	// Masked
	SDHC_IRQSTATEN_AC12ESEN_0 = 0x0
	// Enabled
	SDHC_IRQSTATEN_AC12ESEN_1 = 0x1
	// Position of DMAESEN field.
	SDHC_IRQSTATEN_DMAESEN_Pos = 0x1c
	// Bit mask of DMAESEN field.
	SDHC_IRQSTATEN_DMAESEN_Msk = 0x10000000
	// Bit DMAESEN.
	SDHC_IRQSTATEN_DMAESEN = 0x10000000
	// Masked
	SDHC_IRQSTATEN_DMAESEN_0 = 0x0
	// Enabled
	SDHC_IRQSTATEN_DMAESEN_1 = 0x1

	// IRQSIGEN: Interrupt Signal Enable register
	// Position of CCIEN field.
	SDHC_IRQSIGEN_CCIEN_Pos = 0x0
	// Bit mask of CCIEN field.
	SDHC_IRQSIGEN_CCIEN_Msk = 0x1
	// Bit CCIEN.
	SDHC_IRQSIGEN_CCIEN = 0x1
	// Masked
	SDHC_IRQSIGEN_CCIEN_0 = 0x0
	// Enabled
	SDHC_IRQSIGEN_CCIEN_1 = 0x1
	// Position of TCIEN field.
	SDHC_IRQSIGEN_TCIEN_Pos = 0x1
	// Bit mask of TCIEN field.
	SDHC_IRQSIGEN_TCIEN_Msk = 0x2
	// Bit TCIEN.
	SDHC_IRQSIGEN_TCIEN = 0x2
	// Masked
	SDHC_IRQSIGEN_TCIEN_0 = 0x0
	// Enabled
	SDHC_IRQSIGEN_TCIEN_1 = 0x1
	// Position of BGEIEN field.
	SDHC_IRQSIGEN_BGEIEN_Pos = 0x2
	// Bit mask of BGEIEN field.
	SDHC_IRQSIGEN_BGEIEN_Msk = 0x4
	// Bit BGEIEN.
	SDHC_IRQSIGEN_BGEIEN = 0x4
	// Masked
	SDHC_IRQSIGEN_BGEIEN_0 = 0x0
	// Enabled
	SDHC_IRQSIGEN_BGEIEN_1 = 0x1
	// Position of DINTIEN field.
	SDHC_IRQSIGEN_DINTIEN_Pos = 0x3
	// Bit mask of DINTIEN field.
	SDHC_IRQSIGEN_DINTIEN_Msk = 0x8
	// Bit DINTIEN.
	SDHC_IRQSIGEN_DINTIEN = 0x8
	// Masked
	SDHC_IRQSIGEN_DINTIEN_0 = 0x0
	// Enabled
	SDHC_IRQSIGEN_DINTIEN_1 = 0x1
	// Position of BWRIEN field.
	SDHC_IRQSIGEN_BWRIEN_Pos = 0x4
	// Bit mask of BWRIEN field.
	SDHC_IRQSIGEN_BWRIEN_Msk = 0x10
	// Bit BWRIEN.
	SDHC_IRQSIGEN_BWRIEN = 0x10
	// Masked
	SDHC_IRQSIGEN_BWRIEN_0 = 0x0
	// Enabled
	SDHC_IRQSIGEN_BWRIEN_1 = 0x1
	// Position of BRRIEN field.
	SDHC_IRQSIGEN_BRRIEN_Pos = 0x5
	// Bit mask of BRRIEN field.
	SDHC_IRQSIGEN_BRRIEN_Msk = 0x20
	// Bit BRRIEN.
	SDHC_IRQSIGEN_BRRIEN = 0x20
	// Masked
	SDHC_IRQSIGEN_BRRIEN_0 = 0x0
	// Enabled
	SDHC_IRQSIGEN_BRRIEN_1 = 0x1
	// Position of CINSIEN field.
	SDHC_IRQSIGEN_CINSIEN_Pos = 0x6
	// Bit mask of CINSIEN field.
	SDHC_IRQSIGEN_CINSIEN_Msk = 0x40
	// Bit CINSIEN.
	SDHC_IRQSIGEN_CINSIEN = 0x40
	// Masked
	SDHC_IRQSIGEN_CINSIEN_0 = 0x0
	// Enabled
	SDHC_IRQSIGEN_CINSIEN_1 = 0x1
	// Position of CRMIEN field.
	SDHC_IRQSIGEN_CRMIEN_Pos = 0x7
	// Bit mask of CRMIEN field.
	SDHC_IRQSIGEN_CRMIEN_Msk = 0x80
	// Bit CRMIEN.
	SDHC_IRQSIGEN_CRMIEN = 0x80
	// Masked
	SDHC_IRQSIGEN_CRMIEN_0 = 0x0
	// Enabled
	SDHC_IRQSIGEN_CRMIEN_1 = 0x1
	// Position of CINTIEN field.
	SDHC_IRQSIGEN_CINTIEN_Pos = 0x8
	// Bit mask of CINTIEN field.
	SDHC_IRQSIGEN_CINTIEN_Msk = 0x100
	// Bit CINTIEN.
	SDHC_IRQSIGEN_CINTIEN = 0x100
	// Masked
	SDHC_IRQSIGEN_CINTIEN_0 = 0x0
	// Enabled
	SDHC_IRQSIGEN_CINTIEN_1 = 0x1
	// Position of CTOEIEN field.
	SDHC_IRQSIGEN_CTOEIEN_Pos = 0x10
	// Bit mask of CTOEIEN field.
	SDHC_IRQSIGEN_CTOEIEN_Msk = 0x10000
	// Bit CTOEIEN.
	SDHC_IRQSIGEN_CTOEIEN = 0x10000
	// Masked
	SDHC_IRQSIGEN_CTOEIEN_0 = 0x0
	// Enabled
	SDHC_IRQSIGEN_CTOEIEN_1 = 0x1
	// Position of CCEIEN field.
	SDHC_IRQSIGEN_CCEIEN_Pos = 0x11
	// Bit mask of CCEIEN field.
	SDHC_IRQSIGEN_CCEIEN_Msk = 0x20000
	// Bit CCEIEN.
	SDHC_IRQSIGEN_CCEIEN = 0x20000
	// Masked
	SDHC_IRQSIGEN_CCEIEN_0 = 0x0
	// Enabled
	SDHC_IRQSIGEN_CCEIEN_1 = 0x1
	// Position of CEBEIEN field.
	SDHC_IRQSIGEN_CEBEIEN_Pos = 0x12
	// Bit mask of CEBEIEN field.
	SDHC_IRQSIGEN_CEBEIEN_Msk = 0x40000
	// Bit CEBEIEN.
	SDHC_IRQSIGEN_CEBEIEN = 0x40000
	// Masked
	SDHC_IRQSIGEN_CEBEIEN_0 = 0x0
	// Enabled
	SDHC_IRQSIGEN_CEBEIEN_1 = 0x1
	// Position of CIEIEN field.
	SDHC_IRQSIGEN_CIEIEN_Pos = 0x13
	// Bit mask of CIEIEN field.
	SDHC_IRQSIGEN_CIEIEN_Msk = 0x80000
	// Bit CIEIEN.
	SDHC_IRQSIGEN_CIEIEN = 0x80000
	// Masked
	SDHC_IRQSIGEN_CIEIEN_0 = 0x0
	// Enabled
	SDHC_IRQSIGEN_CIEIEN_1 = 0x1
	// Position of DTOEIEN field.
	SDHC_IRQSIGEN_DTOEIEN_Pos = 0x14
	// Bit mask of DTOEIEN field.
	SDHC_IRQSIGEN_DTOEIEN_Msk = 0x100000
	// Bit DTOEIEN.
	SDHC_IRQSIGEN_DTOEIEN = 0x100000
	// Masked
	SDHC_IRQSIGEN_DTOEIEN_0 = 0x0
	// Enabled
	SDHC_IRQSIGEN_DTOEIEN_1 = 0x1
	// Position of DCEIEN field.
	SDHC_IRQSIGEN_DCEIEN_Pos = 0x15
	// Bit mask of DCEIEN field.
	SDHC_IRQSIGEN_DCEIEN_Msk = 0x200000
	// Bit DCEIEN.
	SDHC_IRQSIGEN_DCEIEN = 0x200000
	// Masked
	SDHC_IRQSIGEN_DCEIEN_0 = 0x0
	// Enabled
	SDHC_IRQSIGEN_DCEIEN_1 = 0x1
	// Position of DEBEIEN field.
	SDHC_IRQSIGEN_DEBEIEN_Pos = 0x16
	// Bit mask of DEBEIEN field.
	SDHC_IRQSIGEN_DEBEIEN_Msk = 0x400000
	// Bit DEBEIEN.
	SDHC_IRQSIGEN_DEBEIEN = 0x400000
	// Masked
	SDHC_IRQSIGEN_DEBEIEN_0 = 0x0
	// Enabled
	SDHC_IRQSIGEN_DEBEIEN_1 = 0x1
	// Position of AC12EIEN field.
	SDHC_IRQSIGEN_AC12EIEN_Pos = 0x18
	// Bit mask of AC12EIEN field.
	SDHC_IRQSIGEN_AC12EIEN_Msk = 0x1000000
	// Bit AC12EIEN.
	SDHC_IRQSIGEN_AC12EIEN = 0x1000000
	// Masked
	SDHC_IRQSIGEN_AC12EIEN_0 = 0x0
	// Enabled
	SDHC_IRQSIGEN_AC12EIEN_1 = 0x1
	// Position of DMAEIEN field.
	SDHC_IRQSIGEN_DMAEIEN_Pos = 0x1c
	// Bit mask of DMAEIEN field.
	SDHC_IRQSIGEN_DMAEIEN_Msk = 0x10000000
	// Bit DMAEIEN.
	SDHC_IRQSIGEN_DMAEIEN = 0x10000000
	// Masked
	SDHC_IRQSIGEN_DMAEIEN_0 = 0x0
	// Enabled
	SDHC_IRQSIGEN_DMAEIEN_1 = 0x1

	// AC12ERR: Auto CMD12 Error Status Register
	// Position of AC12NE field.
	SDHC_AC12ERR_AC12NE_Pos = 0x0
	// Bit mask of AC12NE field.
	SDHC_AC12ERR_AC12NE_Msk = 0x1
	// Bit AC12NE.
	SDHC_AC12ERR_AC12NE = 0x1
	// Executed.
	SDHC_AC12ERR_AC12NE_0 = 0x0
	// Not executed.
	SDHC_AC12ERR_AC12NE_1 = 0x1
	// Position of AC12TOE field.
	SDHC_AC12ERR_AC12TOE_Pos = 0x1
	// Bit mask of AC12TOE field.
	SDHC_AC12ERR_AC12TOE_Msk = 0x2
	// Bit AC12TOE.
	SDHC_AC12ERR_AC12TOE = 0x2
	// No error.
	SDHC_AC12ERR_AC12TOE_0 = 0x0
	// Time out.
	SDHC_AC12ERR_AC12TOE_1 = 0x1
	// Position of AC12EBE field.
	SDHC_AC12ERR_AC12EBE_Pos = 0x2
	// Bit mask of AC12EBE field.
	SDHC_AC12ERR_AC12EBE_Msk = 0x4
	// Bit AC12EBE.
	SDHC_AC12ERR_AC12EBE = 0x4
	// No error.
	SDHC_AC12ERR_AC12EBE_0 = 0x0
	// End bit error generated.
	SDHC_AC12ERR_AC12EBE_1 = 0x1
	// Position of AC12CE field.
	SDHC_AC12ERR_AC12CE_Pos = 0x3
	// Bit mask of AC12CE field.
	SDHC_AC12ERR_AC12CE_Msk = 0x8
	// Bit AC12CE.
	SDHC_AC12ERR_AC12CE = 0x8
	// No CRC error.
	SDHC_AC12ERR_AC12CE_0 = 0x0
	// CRC error met in Auto CMD12 response.
	SDHC_AC12ERR_AC12CE_1 = 0x1
	// Position of AC12IE field.
	SDHC_AC12ERR_AC12IE_Pos = 0x4
	// Bit mask of AC12IE field.
	SDHC_AC12ERR_AC12IE_Msk = 0x10
	// Bit AC12IE.
	SDHC_AC12ERR_AC12IE = 0x10
	// No error.
	SDHC_AC12ERR_AC12IE_0 = 0x0
	// Error, the CMD index in response is not CMD12.
	SDHC_AC12ERR_AC12IE_1 = 0x1
	// Position of CNIBAC12E field.
	SDHC_AC12ERR_CNIBAC12E_Pos = 0x7
	// Bit mask of CNIBAC12E field.
	SDHC_AC12ERR_CNIBAC12E_Msk = 0x80
	// Bit CNIBAC12E.
	SDHC_AC12ERR_CNIBAC12E = 0x80
	// No error.
	SDHC_AC12ERR_CNIBAC12E_0 = 0x0
	// Not issued.
	SDHC_AC12ERR_CNIBAC12E_1 = 0x1

	// HTCAPBLT: Host Controller Capabilities
	// Position of MBL field.
	SDHC_HTCAPBLT_MBL_Pos = 0x10
	// Bit mask of MBL field.
	SDHC_HTCAPBLT_MBL_Msk = 0x70000
	// 512 bytes
	SDHC_HTCAPBLT_MBL_000 = 0x0
	// 1024 bytes
	SDHC_HTCAPBLT_MBL_001 = 0x1
	// 2048 bytes
	SDHC_HTCAPBLT_MBL_010 = 0x2
	// 4096 bytes
	SDHC_HTCAPBLT_MBL_011 = 0x3
	// Position of ADMAS field.
	SDHC_HTCAPBLT_ADMAS_Pos = 0x14
	// Bit mask of ADMAS field.
	SDHC_HTCAPBLT_ADMAS_Msk = 0x100000
	// Bit ADMAS.
	SDHC_HTCAPBLT_ADMAS = 0x100000
	// Advanced DMA not supported.
	SDHC_HTCAPBLT_ADMAS_0 = 0x0
	// Advanced DMA supported.
	SDHC_HTCAPBLT_ADMAS_1 = 0x1
	// Position of HSS field.
	SDHC_HTCAPBLT_HSS_Pos = 0x15
	// Bit mask of HSS field.
	SDHC_HTCAPBLT_HSS_Msk = 0x200000
	// Bit HSS.
	SDHC_HTCAPBLT_HSS = 0x200000
	// High speed not supported.
	SDHC_HTCAPBLT_HSS_0 = 0x0
	// High speed supported.
	SDHC_HTCAPBLT_HSS_1 = 0x1
	// Position of DMAS field.
	SDHC_HTCAPBLT_DMAS_Pos = 0x16
	// Bit mask of DMAS field.
	SDHC_HTCAPBLT_DMAS_Msk = 0x400000
	// Bit DMAS.
	SDHC_HTCAPBLT_DMAS = 0x400000
	// DMA not supported.
	SDHC_HTCAPBLT_DMAS_0 = 0x0
	// DMA supported.
	SDHC_HTCAPBLT_DMAS_1 = 0x1
	// Position of SRS field.
	SDHC_HTCAPBLT_SRS_Pos = 0x17
	// Bit mask of SRS field.
	SDHC_HTCAPBLT_SRS_Msk = 0x800000
	// Bit SRS.
	SDHC_HTCAPBLT_SRS = 0x800000
	// Not supported.
	SDHC_HTCAPBLT_SRS_0 = 0x0
	// Supported.
	SDHC_HTCAPBLT_SRS_1 = 0x1
	// Position of VS33 field.
	SDHC_HTCAPBLT_VS33_Pos = 0x18
	// Bit mask of VS33 field.
	SDHC_HTCAPBLT_VS33_Msk = 0x1000000
	// Bit VS33.
	SDHC_HTCAPBLT_VS33 = 0x1000000
	// 3.3 V not supported.
	SDHC_HTCAPBLT_VS33_0 = 0x0
	// 3.3 V supported.
	SDHC_HTCAPBLT_VS33_1 = 0x1

	// WML: Watermark Level Register
	// Position of RDWML field.
	SDHC_WML_RDWML_Pos = 0x0
	// Bit mask of RDWML field.
	SDHC_WML_RDWML_Msk = 0xff
	// Position of WRWML field.
	SDHC_WML_WRWML_Pos = 0x10
	// Bit mask of WRWML field.
	SDHC_WML_WRWML_Msk = 0xff0000

	// FEVT: Force Event register
	// Position of AC12NE field.
	SDHC_FEVT_AC12NE_Pos = 0x0
	// Bit mask of AC12NE field.
	SDHC_FEVT_AC12NE_Msk = 0x1
	// Bit AC12NE.
	SDHC_FEVT_AC12NE = 0x1
	// Position of AC12TOE field.
	SDHC_FEVT_AC12TOE_Pos = 0x1
	// Bit mask of AC12TOE field.
	SDHC_FEVT_AC12TOE_Msk = 0x2
	// Bit AC12TOE.
	SDHC_FEVT_AC12TOE = 0x2
	// Position of AC12CE field.
	SDHC_FEVT_AC12CE_Pos = 0x2
	// Bit mask of AC12CE field.
	SDHC_FEVT_AC12CE_Msk = 0x4
	// Bit AC12CE.
	SDHC_FEVT_AC12CE = 0x4
	// Position of AC12EBE field.
	SDHC_FEVT_AC12EBE_Pos = 0x3
	// Bit mask of AC12EBE field.
	SDHC_FEVT_AC12EBE_Msk = 0x8
	// Bit AC12EBE.
	SDHC_FEVT_AC12EBE = 0x8
	// Position of AC12IE field.
	SDHC_FEVT_AC12IE_Pos = 0x4
	// Bit mask of AC12IE field.
	SDHC_FEVT_AC12IE_Msk = 0x10
	// Bit AC12IE.
	SDHC_FEVT_AC12IE = 0x10
	// Position of CNIBAC12E field.
	SDHC_FEVT_CNIBAC12E_Pos = 0x7
	// Bit mask of CNIBAC12E field.
	SDHC_FEVT_CNIBAC12E_Msk = 0x80
	// Bit CNIBAC12E.
	SDHC_FEVT_CNIBAC12E = 0x80
	// Position of CTOE field.
	SDHC_FEVT_CTOE_Pos = 0x10
	// Bit mask of CTOE field.
	SDHC_FEVT_CTOE_Msk = 0x10000
	// Bit CTOE.
	SDHC_FEVT_CTOE = 0x10000
	// Position of CCE field.
	SDHC_FEVT_CCE_Pos = 0x11
	// Bit mask of CCE field.
	SDHC_FEVT_CCE_Msk = 0x20000
	// Bit CCE.
	SDHC_FEVT_CCE = 0x20000
	// Position of CEBE field.
	SDHC_FEVT_CEBE_Pos = 0x12
	// Bit mask of CEBE field.
	SDHC_FEVT_CEBE_Msk = 0x40000
	// Bit CEBE.
	SDHC_FEVT_CEBE = 0x40000
	// Position of CIE field.
	SDHC_FEVT_CIE_Pos = 0x13
	// Bit mask of CIE field.
	SDHC_FEVT_CIE_Msk = 0x80000
	// Bit CIE.
	SDHC_FEVT_CIE = 0x80000
	// Position of DTOE field.
	SDHC_FEVT_DTOE_Pos = 0x14
	// Bit mask of DTOE field.
	SDHC_FEVT_DTOE_Msk = 0x100000
	// Bit DTOE.
	SDHC_FEVT_DTOE = 0x100000
	// Position of DCE field.
	SDHC_FEVT_DCE_Pos = 0x15
	// Bit mask of DCE field.
	SDHC_FEVT_DCE_Msk = 0x200000
	// Bit DCE.
	SDHC_FEVT_DCE = 0x200000
	// Position of DEBE field.
	SDHC_FEVT_DEBE_Pos = 0x16
	// Bit mask of DEBE field.
	SDHC_FEVT_DEBE_Msk = 0x400000
	// Bit DEBE.
	SDHC_FEVT_DEBE = 0x400000
	// Position of AC12E field.
	SDHC_FEVT_AC12E_Pos = 0x18
	// Bit mask of AC12E field.
	SDHC_FEVT_AC12E_Msk = 0x1000000
	// Bit AC12E.
	SDHC_FEVT_AC12E = 0x1000000
	// Position of DMAE field.
	SDHC_FEVT_DMAE_Pos = 0x1c
	// Bit mask of DMAE field.
	SDHC_FEVT_DMAE_Msk = 0x10000000
	// Bit DMAE.
	SDHC_FEVT_DMAE = 0x10000000
	// Position of CINT field.
	SDHC_FEVT_CINT_Pos = 0x1f
	// Bit mask of CINT field.
	SDHC_FEVT_CINT_Msk = 0x80000000
	// Bit CINT.
	SDHC_FEVT_CINT = 0x80000000

	// ADMAES: ADMA Error Status register
	// Position of ADMAES field.
	SDHC_ADMAES_ADMAES_Pos = 0x0
	// Bit mask of ADMAES field.
	SDHC_ADMAES_ADMAES_Msk = 0x3
	// Position of ADMALME field.
	SDHC_ADMAES_ADMALME_Pos = 0x2
	// Bit mask of ADMALME field.
	SDHC_ADMAES_ADMALME_Msk = 0x4
	// Bit ADMALME.
	SDHC_ADMAES_ADMALME = 0x4
	// No error.
	SDHC_ADMAES_ADMALME_0 = 0x0
	// Error.
	SDHC_ADMAES_ADMALME_1 = 0x1
	// Position of ADMADCE field.
	SDHC_ADMAES_ADMADCE_Pos = 0x3
	// Bit mask of ADMADCE field.
	SDHC_ADMAES_ADMADCE_Msk = 0x8
	// Bit ADMADCE.
	SDHC_ADMAES_ADMADCE = 0x8
	// No error.
	SDHC_ADMAES_ADMADCE_0 = 0x0
	// Error.
	SDHC_ADMAES_ADMADCE_1 = 0x1

	// ADSADDR: ADMA System Addressregister
	// Position of ADSADDR field.
	SDHC_ADSADDR_ADSADDR_Pos = 0x2
	// Bit mask of ADSADDR field.
	SDHC_ADSADDR_ADSADDR_Msk = 0xfffffffc

	// VENDOR: Vendor Specific register
	// Position of EXTDMAEN field.
	SDHC_VENDOR_EXTDMAEN_Pos = 0x0
	// Bit mask of EXTDMAEN field.
	SDHC_VENDOR_EXTDMAEN_Msk = 0x1
	// Bit EXTDMAEN.
	SDHC_VENDOR_EXTDMAEN = 0x1
	// In any scenario, SDHC does not send out the external DMA request.
	SDHC_VENDOR_EXTDMAEN_0 = 0x0
	// When internal DMA is not active, the external DMA request will be sent out.
	SDHC_VENDOR_EXTDMAEN_1 = 0x1
	// Position of EXBLKNU field.
	SDHC_VENDOR_EXBLKNU_Pos = 0x1
	// Bit mask of EXBLKNU field.
	SDHC_VENDOR_EXBLKNU_Msk = 0x2
	// Bit EXBLKNU.
	SDHC_VENDOR_EXBLKNU = 0x2
	// None exact block read.
	SDHC_VENDOR_EXBLKNU_0 = 0x0
	// Exact block read for SDIO CMD53.
	SDHC_VENDOR_EXBLKNU_1 = 0x1
	// Position of INTSTVAL field.
	SDHC_VENDOR_INTSTVAL_Pos = 0x10
	// Bit mask of INTSTVAL field.
	SDHC_VENDOR_INTSTVAL_Msk = 0xff0000

	// MMCBOOT: MMC Boot register
	// Position of DTOCVACK field.
	SDHC_MMCBOOT_DTOCVACK_Pos = 0x0
	// Bit mask of DTOCVACK field.
	SDHC_MMCBOOT_DTOCVACK_Msk = 0xf
	// SDCLK x 2^8
	SDHC_MMCBOOT_DTOCVACK_0000 = 0x0
	// SDCLK x 2^9
	SDHC_MMCBOOT_DTOCVACK_0001 = 0x1
	// SDCLK x 2^10
	SDHC_MMCBOOT_DTOCVACK_0010 = 0x2
	// SDCLK x 2^11
	SDHC_MMCBOOT_DTOCVACK_0011 = 0x3
	// SDCLK x 2^12
	SDHC_MMCBOOT_DTOCVACK_0100 = 0x4
	// SDCLK x 2^13
	SDHC_MMCBOOT_DTOCVACK_0101 = 0x5
	// SDCLK x 2^14
	SDHC_MMCBOOT_DTOCVACK_0110 = 0x6
	// SDCLK x 2^15
	SDHC_MMCBOOT_DTOCVACK_0111 = 0x7
	// SDCLK x 2^22
	SDHC_MMCBOOT_DTOCVACK_1110 = 0xe
	// Position of BOOTACK field.
	SDHC_MMCBOOT_BOOTACK_Pos = 0x4
	// Bit mask of BOOTACK field.
	SDHC_MMCBOOT_BOOTACK_Msk = 0x10
	// Bit BOOTACK.
	SDHC_MMCBOOT_BOOTACK = 0x10
	// No ack.
	SDHC_MMCBOOT_BOOTACK_0 = 0x0
	// Ack.
	SDHC_MMCBOOT_BOOTACK_1 = 0x1
	// Position of BOOTMODE field.
	SDHC_MMCBOOT_BOOTMODE_Pos = 0x5
	// Bit mask of BOOTMODE field.
	SDHC_MMCBOOT_BOOTMODE_Msk = 0x20
	// Bit BOOTMODE.
	SDHC_MMCBOOT_BOOTMODE = 0x20
	// Normal boot.
	SDHC_MMCBOOT_BOOTMODE_0 = 0x0
	// Alternative boot.
	SDHC_MMCBOOT_BOOTMODE_1 = 0x1
	// Position of BOOTEN field.
	SDHC_MMCBOOT_BOOTEN_Pos = 0x6
	// Bit mask of BOOTEN field.
	SDHC_MMCBOOT_BOOTEN_Msk = 0x40
	// Bit BOOTEN.
	SDHC_MMCBOOT_BOOTEN = 0x40
	// Fast boot disable.
	SDHC_MMCBOOT_BOOTEN_0 = 0x0
	// Fast boot enable.
	SDHC_MMCBOOT_BOOTEN_1 = 0x1
	// Position of AUTOSABGEN field.
	SDHC_MMCBOOT_AUTOSABGEN_Pos = 0x7
	// Bit mask of AUTOSABGEN field.
	SDHC_MMCBOOT_AUTOSABGEN_Msk = 0x80
	// Bit AUTOSABGEN.
	SDHC_MMCBOOT_AUTOSABGEN = 0x80
	// Position of BOOTBLKCNT field.
	SDHC_MMCBOOT_BOOTBLKCNT_Pos = 0x10
	// Bit mask of BOOTBLKCNT field.
	SDHC_MMCBOOT_BOOTBLKCNT_Msk = 0xffff0000

	// HOSTVER: Host Controller Version
	// Position of SVN field.
	SDHC_HOSTVER_SVN_Pos = 0x0
	// Bit mask of SVN field.
	SDHC_HOSTVER_SVN_Msk = 0xff
	// SD host specification version 2.0, supports test event register and ADMA.
	SDHC_HOSTVER_SVN_1 = 0x1
	// Position of VVN field.
	SDHC_HOSTVER_VVN_Pos = 0x8
	// Bit mask of VVN field.
	SDHC_HOSTVER_VVN_Msk = 0xff00
	// Freescale SDHC version 1.0
	SDHC_HOSTVER_VVN_0 = 0x0
	// Freescale SDHC version 2.0
	SDHC_HOSTVER_VVN_10000 = 0x10
	// Freescale SDHC version 2.1
	SDHC_HOSTVER_VVN_10001 = 0x11
	// Freescale SDHC version 2.2
	SDHC_HOSTVER_VVN_10010 = 0x12
)

// Constants for ENET: Ethernet MAC-NET Core
const (
	// EIR: Interrupt Event Register
	// Position of TS_TIMER field.
	ENET_EIR_TS_TIMER_Pos = 0xf
	// Bit mask of TS_TIMER field.
	ENET_EIR_TS_TIMER_Msk = 0x8000
	// Bit TS_TIMER.
	ENET_EIR_TS_TIMER = 0x8000
	// Position of TS_AVAIL field.
	ENET_EIR_TS_AVAIL_Pos = 0x10
	// Bit mask of TS_AVAIL field.
	ENET_EIR_TS_AVAIL_Msk = 0x10000
	// Bit TS_AVAIL.
	ENET_EIR_TS_AVAIL = 0x10000
	// Position of WAKEUP field.
	ENET_EIR_WAKEUP_Pos = 0x11
	// Bit mask of WAKEUP field.
	ENET_EIR_WAKEUP_Msk = 0x20000
	// Bit WAKEUP.
	ENET_EIR_WAKEUP = 0x20000
	// Position of PLR field.
	ENET_EIR_PLR_Pos = 0x12
	// Bit mask of PLR field.
	ENET_EIR_PLR_Msk = 0x40000
	// Bit PLR.
	ENET_EIR_PLR = 0x40000
	// Position of UN field.
	ENET_EIR_UN_Pos = 0x13
	// Bit mask of UN field.
	ENET_EIR_UN_Msk = 0x80000
	// Bit UN.
	ENET_EIR_UN = 0x80000
	// Position of RL field.
	ENET_EIR_RL_Pos = 0x14
	// Bit mask of RL field.
	ENET_EIR_RL_Msk = 0x100000
	// Bit RL.
	ENET_EIR_RL = 0x100000
	// Position of LC field.
	ENET_EIR_LC_Pos = 0x15
	// Bit mask of LC field.
	ENET_EIR_LC_Msk = 0x200000
	// Bit LC.
	ENET_EIR_LC = 0x200000
	// Position of EBERR field.
	ENET_EIR_EBERR_Pos = 0x16
	// Bit mask of EBERR field.
	ENET_EIR_EBERR_Msk = 0x400000
	// Bit EBERR.
	ENET_EIR_EBERR = 0x400000
	// Position of MII field.
	ENET_EIR_MII_Pos = 0x17
	// Bit mask of MII field.
	ENET_EIR_MII_Msk = 0x800000
	// Bit MII.
	ENET_EIR_MII = 0x800000
	// Position of RXB field.
	ENET_EIR_RXB_Pos = 0x18
	// Bit mask of RXB field.
	ENET_EIR_RXB_Msk = 0x1000000
	// Bit RXB.
	ENET_EIR_RXB = 0x1000000
	// Position of RXF field.
	ENET_EIR_RXF_Pos = 0x19
	// Bit mask of RXF field.
	ENET_EIR_RXF_Msk = 0x2000000
	// Bit RXF.
	ENET_EIR_RXF = 0x2000000
	// Position of TXB field.
	ENET_EIR_TXB_Pos = 0x1a
	// Bit mask of TXB field.
	ENET_EIR_TXB_Msk = 0x4000000
	// Bit TXB.
	ENET_EIR_TXB = 0x4000000
	// Position of TXF field.
	ENET_EIR_TXF_Pos = 0x1b
	// Bit mask of TXF field.
	ENET_EIR_TXF_Msk = 0x8000000
	// Bit TXF.
	ENET_EIR_TXF = 0x8000000
	// Position of GRA field.
	ENET_EIR_GRA_Pos = 0x1c
	// Bit mask of GRA field.
	ENET_EIR_GRA_Msk = 0x10000000
	// Bit GRA.
	ENET_EIR_GRA = 0x10000000
	// Position of BABT field.
	ENET_EIR_BABT_Pos = 0x1d
	// Bit mask of BABT field.
	ENET_EIR_BABT_Msk = 0x20000000
	// Bit BABT.
	ENET_EIR_BABT = 0x20000000
	// Position of BABR field.
	ENET_EIR_BABR_Pos = 0x1e
	// Bit mask of BABR field.
	ENET_EIR_BABR_Msk = 0x40000000
	// Bit BABR.
	ENET_EIR_BABR = 0x40000000

	// EIMR: Interrupt Mask Register
	// Position of TS_TIMER field.
	ENET_EIMR_TS_TIMER_Pos = 0xf
	// Bit mask of TS_TIMER field.
	ENET_EIMR_TS_TIMER_Msk = 0x8000
	// Bit TS_TIMER.
	ENET_EIMR_TS_TIMER = 0x8000
	// Position of TS_AVAIL field.
	ENET_EIMR_TS_AVAIL_Pos = 0x10
	// Bit mask of TS_AVAIL field.
	ENET_EIMR_TS_AVAIL_Msk = 0x10000
	// Bit TS_AVAIL.
	ENET_EIMR_TS_AVAIL = 0x10000
	// Position of WAKEUP field.
	ENET_EIMR_WAKEUP_Pos = 0x11
	// Bit mask of WAKEUP field.
	ENET_EIMR_WAKEUP_Msk = 0x20000
	// Bit WAKEUP.
	ENET_EIMR_WAKEUP = 0x20000
	// Position of PLR field.
	ENET_EIMR_PLR_Pos = 0x12
	// Bit mask of PLR field.
	ENET_EIMR_PLR_Msk = 0x40000
	// Bit PLR.
	ENET_EIMR_PLR = 0x40000
	// Position of UN field.
	ENET_EIMR_UN_Pos = 0x13
	// Bit mask of UN field.
	ENET_EIMR_UN_Msk = 0x80000
	// Bit UN.
	ENET_EIMR_UN = 0x80000
	// Position of RL field.
	ENET_EIMR_RL_Pos = 0x14
	// Bit mask of RL field.
	ENET_EIMR_RL_Msk = 0x100000
	// Bit RL.
	ENET_EIMR_RL = 0x100000
	// Position of LC field.
	ENET_EIMR_LC_Pos = 0x15
	// Bit mask of LC field.
	ENET_EIMR_LC_Msk = 0x200000
	// Bit LC.
	ENET_EIMR_LC = 0x200000
	// Position of EBERR field.
	ENET_EIMR_EBERR_Pos = 0x16
	// Bit mask of EBERR field.
	ENET_EIMR_EBERR_Msk = 0x400000
	// Bit EBERR.
	ENET_EIMR_EBERR = 0x400000
	// Position of MII field.
	ENET_EIMR_MII_Pos = 0x17
	// Bit mask of MII field.
	ENET_EIMR_MII_Msk = 0x800000
	// Bit MII.
	ENET_EIMR_MII = 0x800000
	// Position of RXB field.
	ENET_EIMR_RXB_Pos = 0x18
	// Bit mask of RXB field.
	ENET_EIMR_RXB_Msk = 0x1000000
	// Bit RXB.
	ENET_EIMR_RXB = 0x1000000
	// Position of RXF field.
	ENET_EIMR_RXF_Pos = 0x19
	// Bit mask of RXF field.
	ENET_EIMR_RXF_Msk = 0x2000000
	// Bit RXF.
	ENET_EIMR_RXF = 0x2000000
	// Position of TXB field.
	ENET_EIMR_TXB_Pos = 0x1a
	// Bit mask of TXB field.
	ENET_EIMR_TXB_Msk = 0x4000000
	// Bit TXB.
	ENET_EIMR_TXB = 0x4000000
	// The corresponding interrupt source is masked.
	ENET_EIMR_TXB_0 = 0x0
	// The corresponding interrupt source is not masked.
	ENET_EIMR_TXB_1 = 0x1
	// Position of TXF field.
	ENET_EIMR_TXF_Pos = 0x1b
	// Bit mask of TXF field.
	ENET_EIMR_TXF_Msk = 0x8000000
	// Bit TXF.
	ENET_EIMR_TXF = 0x8000000
	// The corresponding interrupt source is masked.
	ENET_EIMR_TXF_0 = 0x0
	// The corresponding interrupt source is not masked.
	ENET_EIMR_TXF_1 = 0x1
	// Position of GRA field.
	ENET_EIMR_GRA_Pos = 0x1c
	// Bit mask of GRA field.
	ENET_EIMR_GRA_Msk = 0x10000000
	// Bit GRA.
	ENET_EIMR_GRA = 0x10000000
	// The corresponding interrupt source is masked.
	ENET_EIMR_GRA_0 = 0x0
	// The corresponding interrupt source is not masked.
	ENET_EIMR_GRA_1 = 0x1
	// Position of BABT field.
	ENET_EIMR_BABT_Pos = 0x1d
	// Bit mask of BABT field.
	ENET_EIMR_BABT_Msk = 0x20000000
	// Bit BABT.
	ENET_EIMR_BABT = 0x20000000
	// The corresponding interrupt source is masked.
	ENET_EIMR_BABT_0 = 0x0
	// The corresponding interrupt source is not masked.
	ENET_EIMR_BABT_1 = 0x1
	// Position of BABR field.
	ENET_EIMR_BABR_Pos = 0x1e
	// Bit mask of BABR field.
	ENET_EIMR_BABR_Msk = 0x40000000
	// Bit BABR.
	ENET_EIMR_BABR = 0x40000000
	// The corresponding interrupt source is masked.
	ENET_EIMR_BABR_0 = 0x0
	// The corresponding interrupt source is not masked.
	ENET_EIMR_BABR_1 = 0x1

	// RDAR: Receive Descriptor Active Register
	// Position of RDAR field.
	ENET_RDAR_RDAR_Pos = 0x18
	// Bit mask of RDAR field.
	ENET_RDAR_RDAR_Msk = 0x1000000
	// Bit RDAR.
	ENET_RDAR_RDAR = 0x1000000

	// TDAR: Transmit Descriptor Active Register
	// Position of TDAR field.
	ENET_TDAR_TDAR_Pos = 0x18
	// Bit mask of TDAR field.
	ENET_TDAR_TDAR_Msk = 0x1000000
	// Bit TDAR.
	ENET_TDAR_TDAR = 0x1000000

	// ECR: Ethernet Control Register
	// Position of RESET field.
	ENET_ECR_RESET_Pos = 0x0
	// Bit mask of RESET field.
	ENET_ECR_RESET_Msk = 0x1
	// Bit RESET.
	ENET_ECR_RESET = 0x1
	// Position of ETHEREN field.
	ENET_ECR_ETHEREN_Pos = 0x1
	// Bit mask of ETHEREN field.
	ENET_ECR_ETHEREN_Msk = 0x2
	// Bit ETHEREN.
	ENET_ECR_ETHEREN = 0x2
	// Reception immediately stops and transmission stops after a bad CRC is appended to any currently transmitted frame.
	ENET_ECR_ETHEREN_0 = 0x0
	// MAC is enabled, and reception and transmission are possible.
	ENET_ECR_ETHEREN_1 = 0x1
	// Position of MAGICEN field.
	ENET_ECR_MAGICEN_Pos = 0x2
	// Bit mask of MAGICEN field.
	ENET_ECR_MAGICEN_Msk = 0x4
	// Bit MAGICEN.
	ENET_ECR_MAGICEN = 0x4
	// Magic detection logic disabled.
	ENET_ECR_MAGICEN_0 = 0x0
	// The MAC core detects magic packets and asserts EIR[WAKEUP] when a frame is detected.
	ENET_ECR_MAGICEN_1 = 0x1
	// Position of SLEEP field.
	ENET_ECR_SLEEP_Pos = 0x3
	// Bit mask of SLEEP field.
	ENET_ECR_SLEEP_Msk = 0x8
	// Bit SLEEP.
	ENET_ECR_SLEEP = 0x8
	// Normal operating mode.
	ENET_ECR_SLEEP_0 = 0x0
	// Sleep mode.
	ENET_ECR_SLEEP_1 = 0x1
	// Position of EN1588 field.
	ENET_ECR_EN1588_Pos = 0x4
	// Bit mask of EN1588 field.
	ENET_ECR_EN1588_Msk = 0x10
	// Bit EN1588.
	ENET_ECR_EN1588 = 0x10
	// Legacy FEC buffer descriptors and functions enabled.
	ENET_ECR_EN1588_0 = 0x0
	// Enhanced frame time-stamping functions enabled.
	ENET_ECR_EN1588_1 = 0x1
	// Position of DBGEN field.
	ENET_ECR_DBGEN_Pos = 0x6
	// Bit mask of DBGEN field.
	ENET_ECR_DBGEN_Msk = 0x40
	// Bit DBGEN.
	ENET_ECR_DBGEN = 0x40
	// MAC continues operation in debug mode.
	ENET_ECR_DBGEN_0 = 0x0
	// MAC enters hardware freeze mode when the processor is in debug mode.
	ENET_ECR_DBGEN_1 = 0x1
	// Position of STOPEN field.
	ENET_ECR_STOPEN_Pos = 0x7
	// Bit mask of STOPEN field.
	ENET_ECR_STOPEN_Msk = 0x80
	// Bit STOPEN.
	ENET_ECR_STOPEN = 0x80
	// Position of DBSWP field.
	ENET_ECR_DBSWP_Pos = 0x8
	// Bit mask of DBSWP field.
	ENET_ECR_DBSWP_Msk = 0x100
	// Bit DBSWP.
	ENET_ECR_DBSWP = 0x100
	// The buffer descriptor bytes are not swapped to support big-endian devices.
	ENET_ECR_DBSWP_0 = 0x0
	// The buffer descriptor bytes are swapped to support little-endian devices.
	ENET_ECR_DBSWP_1 = 0x1

	// MMFR: MII Management Frame Register
	// Position of DATA field.
	ENET_MMFR_DATA_Pos = 0x0
	// Bit mask of DATA field.
	ENET_MMFR_DATA_Msk = 0xffff
	// Position of TA field.
	ENET_MMFR_TA_Pos = 0x10
	// Bit mask of TA field.
	ENET_MMFR_TA_Msk = 0x30000
	// Position of RA field.
	ENET_MMFR_RA_Pos = 0x12
	// Bit mask of RA field.
	ENET_MMFR_RA_Msk = 0x7c0000
	// Position of PA field.
	ENET_MMFR_PA_Pos = 0x17
	// Bit mask of PA field.
	ENET_MMFR_PA_Msk = 0xf800000
	// Position of OP field.
	ENET_MMFR_OP_Pos = 0x1c
	// Bit mask of OP field.
	ENET_MMFR_OP_Msk = 0x30000000
	// Write frame operation, but not MII compliant.
	ENET_MMFR_OP_00 = 0x0
	// Write frame operation for a valid MII management frame.
	ENET_MMFR_OP_01 = 0x1
	// Read frame operation for a valid MII management frame.
	ENET_MMFR_OP_10 = 0x2
	// Read frame operation, but not MII compliant.
	ENET_MMFR_OP_11 = 0x3
	// Position of ST field.
	ENET_MMFR_ST_Pos = 0x1e
	// Bit mask of ST field.
	ENET_MMFR_ST_Msk = 0xc0000000

	// MSCR: MII Speed Control Register
	// Position of MII_SPEED field.
	ENET_MSCR_MII_SPEED_Pos = 0x1
	// Bit mask of MII_SPEED field.
	ENET_MSCR_MII_SPEED_Msk = 0x7e
	// Position of DIS_PRE field.
	ENET_MSCR_DIS_PRE_Pos = 0x7
	// Bit mask of DIS_PRE field.
	ENET_MSCR_DIS_PRE_Msk = 0x80
	// Bit DIS_PRE.
	ENET_MSCR_DIS_PRE = 0x80
	// Preamble enabled.
	ENET_MSCR_DIS_PRE_0 = 0x0
	// Preamble (32 ones) is not prepended to the MII management frame.
	ENET_MSCR_DIS_PRE_1 = 0x1
	// Position of HOLDTIME field.
	ENET_MSCR_HOLDTIME_Pos = 0x8
	// Bit mask of HOLDTIME field.
	ENET_MSCR_HOLDTIME_Msk = 0x700
	// 1 internal module clock cycle
	ENET_MSCR_HOLDTIME_000 = 0x0
	// 2 internal module clock cycles
	ENET_MSCR_HOLDTIME_001 = 0x1
	// 3 internal module clock cycles
	ENET_MSCR_HOLDTIME_010 = 0x2
	// 8 internal module clock cycles
	ENET_MSCR_HOLDTIME_111 = 0x7

	// MIBC: MIB Control Register
	// Position of MIB_CLEAR field.
	ENET_MIBC_MIB_CLEAR_Pos = 0x1d
	// Bit mask of MIB_CLEAR field.
	ENET_MIBC_MIB_CLEAR_Msk = 0x20000000
	// Bit MIB_CLEAR.
	ENET_MIBC_MIB_CLEAR = 0x20000000
	// Position of MIB_IDLE field.
	ENET_MIBC_MIB_IDLE_Pos = 0x1e
	// Bit mask of MIB_IDLE field.
	ENET_MIBC_MIB_IDLE_Msk = 0x40000000
	// Bit MIB_IDLE.
	ENET_MIBC_MIB_IDLE = 0x40000000
	// Position of MIB_DIS field.
	ENET_MIBC_MIB_DIS_Pos = 0x1f
	// Bit mask of MIB_DIS field.
	ENET_MIBC_MIB_DIS_Msk = 0x80000000
	// Bit MIB_DIS.
	ENET_MIBC_MIB_DIS = 0x80000000

	// RCR: Receive Control Register
	// Position of LOOP field.
	ENET_RCR_LOOP_Pos = 0x0
	// Bit mask of LOOP field.
	ENET_RCR_LOOP_Msk = 0x1
	// Bit LOOP.
	ENET_RCR_LOOP = 0x1
	// Loopback disabled.
	ENET_RCR_LOOP_0 = 0x0
	// Transmitted frames are looped back internal to the device and transmit MII output signals are not asserted. DRT must be cleared.
	ENET_RCR_LOOP_1 = 0x1
	// Position of DRT field.
	ENET_RCR_DRT_Pos = 0x1
	// Bit mask of DRT field.
	ENET_RCR_DRT_Msk = 0x2
	// Bit DRT.
	ENET_RCR_DRT = 0x2
	// Receive path operates independently of transmit. Used for full-duplex or to monitor transmit activity in half-duplex mode.
	ENET_RCR_DRT_0 = 0x0
	// Disable reception of frames while transmitting. Normally used for half-duplex mode.
	ENET_RCR_DRT_1 = 0x1
	// Position of MII_MODE field.
	ENET_RCR_MII_MODE_Pos = 0x2
	// Bit mask of MII_MODE field.
	ENET_RCR_MII_MODE_Msk = 0x4
	// Bit MII_MODE.
	ENET_RCR_MII_MODE = 0x4
	// MII or RMII mode, as indicated by the RMII_MODE field.
	ENET_RCR_MII_MODE_1 = 0x1
	// Position of PROM field.
	ENET_RCR_PROM_Pos = 0x3
	// Bit mask of PROM field.
	ENET_RCR_PROM_Msk = 0x8
	// Bit PROM.
	ENET_RCR_PROM = 0x8
	// Disabled.
	ENET_RCR_PROM_0 = 0x0
	// Enabled.
	ENET_RCR_PROM_1 = 0x1
	// Position of BC_REJ field.
	ENET_RCR_BC_REJ_Pos = 0x4
	// Bit mask of BC_REJ field.
	ENET_RCR_BC_REJ_Msk = 0x10
	// Bit BC_REJ.
	ENET_RCR_BC_REJ = 0x10
	// Position of FCE field.
	ENET_RCR_FCE_Pos = 0x5
	// Bit mask of FCE field.
	ENET_RCR_FCE_Msk = 0x20
	// Bit FCE.
	ENET_RCR_FCE = 0x20
	// Position of RMII_MODE field.
	ENET_RCR_RMII_MODE_Pos = 0x8
	// Bit mask of RMII_MODE field.
	ENET_RCR_RMII_MODE_Msk = 0x100
	// Bit RMII_MODE.
	ENET_RCR_RMII_MODE = 0x100
	// MAC configured for MII mode.
	ENET_RCR_RMII_MODE_0 = 0x0
	// MAC configured for RMII operation.
	ENET_RCR_RMII_MODE_1 = 0x1
	// Position of RMII_10T field.
	ENET_RCR_RMII_10T_Pos = 0x9
	// Bit mask of RMII_10T field.
	ENET_RCR_RMII_10T_Msk = 0x200
	// Bit RMII_10T.
	ENET_RCR_RMII_10T = 0x200
	// 100 Mbps operation.
	ENET_RCR_RMII_10T_0 = 0x0
	// 10 Mbps operation.
	ENET_RCR_RMII_10T_1 = 0x1
	// Position of PADEN field.
	ENET_RCR_PADEN_Pos = 0xc
	// Bit mask of PADEN field.
	ENET_RCR_PADEN_Msk = 0x1000
	// Bit PADEN.
	ENET_RCR_PADEN = 0x1000
	// No padding is removed on receive by the MAC.
	ENET_RCR_PADEN_0 = 0x0
	// Padding is removed from received frames.
	ENET_RCR_PADEN_1 = 0x1
	// Position of PAUFWD field.
	ENET_RCR_PAUFWD_Pos = 0xd
	// Bit mask of PAUFWD field.
	ENET_RCR_PAUFWD_Msk = 0x2000
	// Bit PAUFWD.
	ENET_RCR_PAUFWD = 0x2000
	// Pause frames are terminated and discarded in the MAC.
	ENET_RCR_PAUFWD_0 = 0x0
	// Pause frames are forwarded to the user application.
	ENET_RCR_PAUFWD_1 = 0x1
	// Position of CRCFWD field.
	ENET_RCR_CRCFWD_Pos = 0xe
	// Bit mask of CRCFWD field.
	ENET_RCR_CRCFWD_Msk = 0x4000
	// Bit CRCFWD.
	ENET_RCR_CRCFWD = 0x4000
	// The CRC field of received frames is transmitted to the user application.
	ENET_RCR_CRCFWD_0 = 0x0
	// The CRC field is stripped from the frame.
	ENET_RCR_CRCFWD_1 = 0x1
	// Position of CFEN field.
	ENET_RCR_CFEN_Pos = 0xf
	// Bit mask of CFEN field.
	ENET_RCR_CFEN_Msk = 0x8000
	// Bit CFEN.
	ENET_RCR_CFEN = 0x8000
	// MAC control frames with any opcode other than 0x0001 (pause frame) are accepted and forwarded to the client interface.
	ENET_RCR_CFEN_0 = 0x0
	// MAC control frames with any opcode other than 0x0001 (pause frame) are silently discarded.
	ENET_RCR_CFEN_1 = 0x1
	// Position of MAX_FL field.
	ENET_RCR_MAX_FL_Pos = 0x10
	// Bit mask of MAX_FL field.
	ENET_RCR_MAX_FL_Msk = 0x3fff0000
	// Position of NLC field.
	ENET_RCR_NLC_Pos = 0x1e
	// Bit mask of NLC field.
	ENET_RCR_NLC_Msk = 0x40000000
	// Bit NLC.
	ENET_RCR_NLC = 0x40000000
	// The payload length check is disabled.
	ENET_RCR_NLC_0 = 0x0
	// The core checks the frame's payload length with the frame length/type field. Errors are indicated in the EIR[PLC] field.
	ENET_RCR_NLC_1 = 0x1
	// Position of GRS field.
	ENET_RCR_GRS_Pos = 0x1f
	// Bit mask of GRS field.
	ENET_RCR_GRS_Msk = 0x80000000
	// Bit GRS.
	ENET_RCR_GRS = 0x80000000

	// TCR: Transmit Control Register
	// Position of GTS field.
	ENET_TCR_GTS_Pos = 0x0
	// Bit mask of GTS field.
	ENET_TCR_GTS_Msk = 0x1
	// Bit GTS.
	ENET_TCR_GTS = 0x1
	// Position of FDEN field.
	ENET_TCR_FDEN_Pos = 0x2
	// Bit mask of FDEN field.
	ENET_TCR_FDEN_Msk = 0x4
	// Bit FDEN.
	ENET_TCR_FDEN = 0x4
	// Position of TFC_PAUSE field.
	ENET_TCR_TFC_PAUSE_Pos = 0x3
	// Bit mask of TFC_PAUSE field.
	ENET_TCR_TFC_PAUSE_Msk = 0x8
	// Bit TFC_PAUSE.
	ENET_TCR_TFC_PAUSE = 0x8
	// No PAUSE frame transmitted.
	ENET_TCR_TFC_PAUSE_0 = 0x0
	// The MAC stops transmission of data frames after the current transmission is complete.
	ENET_TCR_TFC_PAUSE_1 = 0x1
	// Position of RFC_PAUSE field.
	ENET_TCR_RFC_PAUSE_Pos = 0x4
	// Bit mask of RFC_PAUSE field.
	ENET_TCR_RFC_PAUSE_Msk = 0x10
	// Bit RFC_PAUSE.
	ENET_TCR_RFC_PAUSE = 0x10
	// Position of ADDSEL field.
	ENET_TCR_ADDSEL_Pos = 0x5
	// Bit mask of ADDSEL field.
	ENET_TCR_ADDSEL_Msk = 0xe0
	// Node MAC address programmed on PADDR1/2 registers.
	ENET_TCR_ADDSEL_000 = 0x0
	// Position of ADDINS field.
	ENET_TCR_ADDINS_Pos = 0x8
	// Bit mask of ADDINS field.
	ENET_TCR_ADDINS_Msk = 0x100
	// Bit ADDINS.
	ENET_TCR_ADDINS = 0x100
	// The source MAC address is not modified by the MAC.
	ENET_TCR_ADDINS_0 = 0x0
	// The MAC overwrites the source MAC address with the programmed MAC address according to ADDSEL.
	ENET_TCR_ADDINS_1 = 0x1
	// Position of CRCFWD field.
	ENET_TCR_CRCFWD_Pos = 0x9
	// Bit mask of CRCFWD field.
	ENET_TCR_CRCFWD_Msk = 0x200
	// Bit CRCFWD.
	ENET_TCR_CRCFWD = 0x200
	// TxBD[TC] controls whether the frame has a CRC from the application.
	ENET_TCR_CRCFWD_0 = 0x0
	// The transmitter does not append any CRC to transmitted frames, as it is expecting a frame with CRC from the application.
	ENET_TCR_CRCFWD_1 = 0x1

	// PALR: Physical Address Lower Register
	// Position of PADDR1 field.
	ENET_PALR_PADDR1_Pos = 0x0
	// Bit mask of PADDR1 field.
	ENET_PALR_PADDR1_Msk = 0xffffffff

	// PAUR: Physical Address Upper Register
	// Position of TYPE field.
	ENET_PAUR_TYPE_Pos = 0x0
	// Bit mask of TYPE field.
	ENET_PAUR_TYPE_Msk = 0xffff
	// Position of PADDR2 field.
	ENET_PAUR_PADDR2_Pos = 0x10
	// Bit mask of PADDR2 field.
	ENET_PAUR_PADDR2_Msk = 0xffff0000

	// OPD: Opcode/Pause Duration Register
	// Position of PAUSE_DUR field.
	ENET_OPD_PAUSE_DUR_Pos = 0x0
	// Bit mask of PAUSE_DUR field.
	ENET_OPD_PAUSE_DUR_Msk = 0xffff
	// Position of OPCODE field.
	ENET_OPD_OPCODE_Pos = 0x10
	// Bit mask of OPCODE field.
	ENET_OPD_OPCODE_Msk = 0xffff0000

	// IAUR: Descriptor Individual Upper Address Register
	// Position of IADDR1 field.
	ENET_IAUR_IADDR1_Pos = 0x0
	// Bit mask of IADDR1 field.
	ENET_IAUR_IADDR1_Msk = 0xffffffff

	// IALR: Descriptor Individual Lower Address Register
	// Position of IADDR2 field.
	ENET_IALR_IADDR2_Pos = 0x0
	// Bit mask of IADDR2 field.
	ENET_IALR_IADDR2_Msk = 0xffffffff

	// GAUR: Descriptor Group Upper Address Register
	// Position of GADDR1 field.
	ENET_GAUR_GADDR1_Pos = 0x0
	// Bit mask of GADDR1 field.
	ENET_GAUR_GADDR1_Msk = 0xffffffff

	// GALR: Descriptor Group Lower Address Register
	// Position of GADDR2 field.
	ENET_GALR_GADDR2_Pos = 0x0
	// Bit mask of GADDR2 field.
	ENET_GALR_GADDR2_Msk = 0xffffffff

	// TFWR: Transmit FIFO Watermark Register
	// Position of TFWR field.
	ENET_TFWR_TFWR_Pos = 0x0
	// Bit mask of TFWR field.
	ENET_TFWR_TFWR_Msk = 0x3f
	// 64 bytes written.
	ENET_TFWR_TFWR_000000 = 0x0
	// 64 bytes written.
	ENET_TFWR_TFWR_000001 = 0x1
	// 128 bytes written.
	ENET_TFWR_TFWR_000010 = 0x2
	// 192 bytes written.
	ENET_TFWR_TFWR_000011 = 0x3
	// 3968 bytes written.
	ENET_TFWR_TFWR_111110 = 0x3e
	// 4032 bytes written.
	ENET_TFWR_TFWR_111111 = 0x3f
	// Position of STRFWD field.
	ENET_TFWR_STRFWD_Pos = 0x8
	// Bit mask of STRFWD field.
	ENET_TFWR_STRFWD_Msk = 0x100
	// Bit STRFWD.
	ENET_TFWR_STRFWD = 0x100
	// Reset. The transmission start threshold is programmed in TFWR[TFWR].
	ENET_TFWR_STRFWD_0 = 0x0
	// Enabled.
	ENET_TFWR_STRFWD_1 = 0x1

	// RDSR: Receive Descriptor Ring Start Register
	// Position of R_DES_START field.
	ENET_RDSR_R_DES_START_Pos = 0x3
	// Bit mask of R_DES_START field.
	ENET_RDSR_R_DES_START_Msk = 0xfffffff8

	// TDSR: Transmit Buffer Descriptor Ring Start Register
	// Position of X_DES_START field.
	ENET_TDSR_X_DES_START_Pos = 0x3
	// Bit mask of X_DES_START field.
	ENET_TDSR_X_DES_START_Msk = 0xfffffff8

	// MRBR: Maximum Receive Buffer Size Register
	// Position of R_BUF_SIZE field.
	ENET_MRBR_R_BUF_SIZE_Pos = 0x4
	// Bit mask of R_BUF_SIZE field.
	ENET_MRBR_R_BUF_SIZE_Msk = 0x3ff0

	// RSFL: Receive FIFO Section Full Threshold
	// Position of RX_SECTION_FULL field.
	ENET_RSFL_RX_SECTION_FULL_Pos = 0x0
	// Bit mask of RX_SECTION_FULL field.
	ENET_RSFL_RX_SECTION_FULL_Msk = 0xff

	// RSEM: Receive FIFO Section Empty Threshold
	// Position of RX_SECTION_EMPTY field.
	ENET_RSEM_RX_SECTION_EMPTY_Pos = 0x0
	// Bit mask of RX_SECTION_EMPTY field.
	ENET_RSEM_RX_SECTION_EMPTY_Msk = 0xff
	// Position of STAT_SECTION_EMPTY field.
	ENET_RSEM_STAT_SECTION_EMPTY_Pos = 0x10
	// Bit mask of STAT_SECTION_EMPTY field.
	ENET_RSEM_STAT_SECTION_EMPTY_Msk = 0x1f0000

	// RAEM: Receive FIFO Almost Empty Threshold
	// Position of RX_ALMOST_EMPTY field.
	ENET_RAEM_RX_ALMOST_EMPTY_Pos = 0x0
	// Bit mask of RX_ALMOST_EMPTY field.
	ENET_RAEM_RX_ALMOST_EMPTY_Msk = 0xff

	// RAFL: Receive FIFO Almost Full Threshold
	// Position of RX_ALMOST_FULL field.
	ENET_RAFL_RX_ALMOST_FULL_Pos = 0x0
	// Bit mask of RX_ALMOST_FULL field.
	ENET_RAFL_RX_ALMOST_FULL_Msk = 0xff

	// TSEM: Transmit FIFO Section Empty Threshold
	// Position of TX_SECTION_EMPTY field.
	ENET_TSEM_TX_SECTION_EMPTY_Pos = 0x0
	// Bit mask of TX_SECTION_EMPTY field.
	ENET_TSEM_TX_SECTION_EMPTY_Msk = 0xff

	// TAEM: Transmit FIFO Almost Empty Threshold
	// Position of TX_ALMOST_EMPTY field.
	ENET_TAEM_TX_ALMOST_EMPTY_Pos = 0x0
	// Bit mask of TX_ALMOST_EMPTY field.
	ENET_TAEM_TX_ALMOST_EMPTY_Msk = 0xff

	// TAFL: Transmit FIFO Almost Full Threshold
	// Position of TX_ALMOST_FULL field.
	ENET_TAFL_TX_ALMOST_FULL_Pos = 0x0
	// Bit mask of TX_ALMOST_FULL field.
	ENET_TAFL_TX_ALMOST_FULL_Msk = 0xff

	// TIPG: Transmit Inter-Packet Gap
	// Position of IPG field.
	ENET_TIPG_IPG_Pos = 0x0
	// Bit mask of IPG field.
	ENET_TIPG_IPG_Msk = 0x1f

	// FTRL: Frame Truncation Length
	// Position of TRUNC_FL field.
	ENET_FTRL_TRUNC_FL_Pos = 0x0
	// Bit mask of TRUNC_FL field.
	ENET_FTRL_TRUNC_FL_Msk = 0x3fff

	// TACC: Transmit Accelerator Function Configuration
	// Position of SHIFT16 field.
	ENET_TACC_SHIFT16_Pos = 0x0
	// Bit mask of SHIFT16 field.
	ENET_TACC_SHIFT16_Msk = 0x1
	// Bit SHIFT16.
	ENET_TACC_SHIFT16 = 0x1
	// Disabled.
	ENET_TACC_SHIFT16_0 = 0x0
	// Indicates to the transmit data FIFO that the written frames contain two additional octets before the frame data. This means the actual frame begins at bit 16 of the first word written into the FIFO. This function allows putting the frame payload on a 32-bit boundary in memory, as the 14-byte Ethernet header is extended to a 16-byte header.
	ENET_TACC_SHIFT16_1 = 0x1
	// Position of IPCHK field.
	ENET_TACC_IPCHK_Pos = 0x3
	// Bit mask of IPCHK field.
	ENET_TACC_IPCHK_Msk = 0x8
	// Bit IPCHK.
	ENET_TACC_IPCHK = 0x8
	// Checksum is not inserted.
	ENET_TACC_IPCHK_0 = 0x0
	// If an IP frame is transmitted, the checksum is inserted automatically. The IP header checksum field must be cleared. If a non-IP frame is transmitted the frame is not modified.
	ENET_TACC_IPCHK_1 = 0x1
	// Position of PROCHK field.
	ENET_TACC_PROCHK_Pos = 0x4
	// Bit mask of PROCHK field.
	ENET_TACC_PROCHK_Msk = 0x10
	// Bit PROCHK.
	ENET_TACC_PROCHK = 0x10
	// Checksum not inserted.
	ENET_TACC_PROCHK_0 = 0x0
	// If an IP frame with a known protocol is transmitted, the checksum is inserted automatically into the frame. The checksum field must be cleared. The other frames are not modified.
	ENET_TACC_PROCHK_1 = 0x1

	// RACC: Receive Accelerator Function Configuration
	// Position of PADREM field.
	ENET_RACC_PADREM_Pos = 0x0
	// Bit mask of PADREM field.
	ENET_RACC_PADREM_Msk = 0x1
	// Bit PADREM.
	ENET_RACC_PADREM = 0x1
	// Padding not removed.
	ENET_RACC_PADREM_0 = 0x0
	// Any bytes following the IP payload section of the frame are removed from the frame.
	ENET_RACC_PADREM_1 = 0x1
	// Position of IPDIS field.
	ENET_RACC_IPDIS_Pos = 0x1
	// Bit mask of IPDIS field.
	ENET_RACC_IPDIS_Msk = 0x2
	// Bit IPDIS.
	ENET_RACC_IPDIS = 0x2
	// Frames with wrong IPv4 header checksum are not discarded.
	ENET_RACC_IPDIS_0 = 0x0
	// If an IPv4 frame is received with a mismatching header checksum, the frame is discarded. IPv6 has no header checksum and is not affected by this setting. Discarding is only available when the RX FIFO operates in store and forward mode (RSFL cleared).
	ENET_RACC_IPDIS_1 = 0x1
	// Position of PRODIS field.
	ENET_RACC_PRODIS_Pos = 0x2
	// Bit mask of PRODIS field.
	ENET_RACC_PRODIS_Msk = 0x4
	// Bit PRODIS.
	ENET_RACC_PRODIS = 0x4
	// Frames with wrong checksum are not discarded.
	ENET_RACC_PRODIS_0 = 0x0
	// If a TCP/IP, UDP/IP, or ICMP/IP frame is received that has a wrong TCP, UDP, or ICMP checksum, the frame is discarded. Discarding is only available when the RX FIFO operates in store and forward mode (RSFL cleared).
	ENET_RACC_PRODIS_1 = 0x1
	// Position of LINEDIS field.
	ENET_RACC_LINEDIS_Pos = 0x6
	// Bit mask of LINEDIS field.
	ENET_RACC_LINEDIS_Msk = 0x40
	// Bit LINEDIS.
	ENET_RACC_LINEDIS = 0x40
	// Frames with errors are not discarded.
	ENET_RACC_LINEDIS_0 = 0x0
	// Any frame received with a CRC, length, or PHY error is automatically discarded and not forwarded to the user application interface.
	ENET_RACC_LINEDIS_1 = 0x1
	// Position of SHIFT16 field.
	ENET_RACC_SHIFT16_Pos = 0x7
	// Bit mask of SHIFT16 field.
	ENET_RACC_SHIFT16_Msk = 0x80
	// Bit SHIFT16.
	ENET_RACC_SHIFT16 = 0x80
	// Disabled.
	ENET_RACC_SHIFT16_0 = 0x0
	// Instructs the MAC to write two additional bytes in front of each frame received into the RX FIFO.
	ENET_RACC_SHIFT16_1 = 0x1

	// RMON_T_PACKETS: Tx Packet Count Statistic Register
	// Position of TXPKTS field.
	ENET_RMON_T_PACKETS_TXPKTS_Pos = 0x0
	// Bit mask of TXPKTS field.
	ENET_RMON_T_PACKETS_TXPKTS_Msk = 0xffff

	// RMON_T_BC_PKT: Tx Broadcast Packets Statistic Register
	// Position of TXPKTS field.
	ENET_RMON_T_BC_PKT_TXPKTS_Pos = 0x0
	// Bit mask of TXPKTS field.
	ENET_RMON_T_BC_PKT_TXPKTS_Msk = 0xffff

	// RMON_T_MC_PKT: Tx Multicast Packets Statistic Register
	// Position of TXPKTS field.
	ENET_RMON_T_MC_PKT_TXPKTS_Pos = 0x0
	// Bit mask of TXPKTS field.
	ENET_RMON_T_MC_PKT_TXPKTS_Msk = 0xffff

	// RMON_T_CRC_ALIGN: Tx Packets with CRC/Align Error Statistic Register
	// Position of TXPKTS field.
	ENET_RMON_T_CRC_ALIGN_TXPKTS_Pos = 0x0
	// Bit mask of TXPKTS field.
	ENET_RMON_T_CRC_ALIGN_TXPKTS_Msk = 0xffff

	// RMON_T_UNDERSIZE: Tx Packets Less Than Bytes and Good CRC Statistic Register
	// Position of TXPKTS field.
	ENET_RMON_T_UNDERSIZE_TXPKTS_Pos = 0x0
	// Bit mask of TXPKTS field.
	ENET_RMON_T_UNDERSIZE_TXPKTS_Msk = 0xffff

	// RMON_T_OVERSIZE: Tx Packets GT MAX_FL bytes and Good CRC Statistic Register
	// Position of TXPKTS field.
	ENET_RMON_T_OVERSIZE_TXPKTS_Pos = 0x0
	// Bit mask of TXPKTS field.
	ENET_RMON_T_OVERSIZE_TXPKTS_Msk = 0xffff

	// RMON_T_FRAG: Tx Packets Less Than 64 Bytes and Bad CRC Statistic Register
	// Position of TXPKTS field.
	ENET_RMON_T_FRAG_TXPKTS_Pos = 0x0
	// Bit mask of TXPKTS field.
	ENET_RMON_T_FRAG_TXPKTS_Msk = 0xffff

	// RMON_T_JAB: Tx Packets Greater Than MAX_FL bytes and Bad CRC Statistic Register
	// Position of TXPKTS field.
	ENET_RMON_T_JAB_TXPKTS_Pos = 0x0
	// Bit mask of TXPKTS field.
	ENET_RMON_T_JAB_TXPKTS_Msk = 0xffff

	// RMON_T_COL: Tx Collision Count Statistic Register
	// Position of TXPKTS field.
	ENET_RMON_T_COL_TXPKTS_Pos = 0x0
	// Bit mask of TXPKTS field.
	ENET_RMON_T_COL_TXPKTS_Msk = 0xffff

	// RMON_T_P64: Tx 64-Byte Packets Statistic Register
	// Position of TXPKTS field.
	ENET_RMON_T_P64_TXPKTS_Pos = 0x0
	// Bit mask of TXPKTS field.
	ENET_RMON_T_P64_TXPKTS_Msk = 0xffff

	// RMON_T_P65TO127: Tx 65- to 127-byte Packets Statistic Register
	// Position of TXPKTS field.
	ENET_RMON_T_P65TO127_TXPKTS_Pos = 0x0
	// Bit mask of TXPKTS field.
	ENET_RMON_T_P65TO127_TXPKTS_Msk = 0xffff

	// RMON_T_P128TO255: Tx 128- to 255-byte Packets Statistic Register
	// Position of TXPKTS field.
	ENET_RMON_T_P128TO255_TXPKTS_Pos = 0x0
	// Bit mask of TXPKTS field.
	ENET_RMON_T_P128TO255_TXPKTS_Msk = 0xffff

	// RMON_T_P256TO511: Tx 256- to 511-byte Packets Statistic Register
	// Position of TXPKTS field.
	ENET_RMON_T_P256TO511_TXPKTS_Pos = 0x0
	// Bit mask of TXPKTS field.
	ENET_RMON_T_P256TO511_TXPKTS_Msk = 0xffff

	// RMON_T_P512TO1023: Tx 512- to 1023-byte Packets Statistic Register
	// Position of TXPKTS field.
	ENET_RMON_T_P512TO1023_TXPKTS_Pos = 0x0
	// Bit mask of TXPKTS field.
	ENET_RMON_T_P512TO1023_TXPKTS_Msk = 0xffff

	// RMON_T_P1024TO2047: Tx 1024- to 2047-byte Packets Statistic Register
	// Position of TXPKTS field.
	ENET_RMON_T_P1024TO2047_TXPKTS_Pos = 0x0
	// Bit mask of TXPKTS field.
	ENET_RMON_T_P1024TO2047_TXPKTS_Msk = 0xffff

	// RMON_T_P_GTE2048: Tx Packets Greater Than 2048 Bytes Statistic Register
	// Position of TXPKTS field.
	ENET_RMON_T_P_GTE2048_TXPKTS_Pos = 0x0
	// Bit mask of TXPKTS field.
	ENET_RMON_T_P_GTE2048_TXPKTS_Msk = 0xffff

	// RMON_T_OCTETS: Tx Octets Statistic Register
	// Position of TXOCTS field.
	ENET_RMON_T_OCTETS_TXOCTS_Pos = 0x0
	// Bit mask of TXOCTS field.
	ENET_RMON_T_OCTETS_TXOCTS_Msk = 0xffffffff

	// IEEE_T_FRAME_OK: Frames Transmitted OK Statistic Register
	// Position of COUNT field.
	ENET_IEEE_T_FRAME_OK_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_IEEE_T_FRAME_OK_COUNT_Msk = 0xffff

	// IEEE_T_1COL: Frames Transmitted with Single Collision Statistic Register
	// Position of COUNT field.
	ENET_IEEE_T_1COL_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_IEEE_T_1COL_COUNT_Msk = 0xffff

	// IEEE_T_MCOL: Frames Transmitted with Multiple Collisions Statistic Register
	// Position of COUNT field.
	ENET_IEEE_T_MCOL_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_IEEE_T_MCOL_COUNT_Msk = 0xffff

	// IEEE_T_DEF: Frames Transmitted after Deferral Delay Statistic Register
	// Position of COUNT field.
	ENET_IEEE_T_DEF_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_IEEE_T_DEF_COUNT_Msk = 0xffff

	// IEEE_T_LCOL: Frames Transmitted with Late Collision Statistic Register
	// Position of COUNT field.
	ENET_IEEE_T_LCOL_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_IEEE_T_LCOL_COUNT_Msk = 0xffff

	// IEEE_T_EXCOL: Frames Transmitted with Excessive Collisions Statistic Register
	// Position of COUNT field.
	ENET_IEEE_T_EXCOL_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_IEEE_T_EXCOL_COUNT_Msk = 0xffff

	// IEEE_T_MACERR: Frames Transmitted with Tx FIFO Underrun Statistic Register
	// Position of COUNT field.
	ENET_IEEE_T_MACERR_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_IEEE_T_MACERR_COUNT_Msk = 0xffff

	// IEEE_T_CSERR: Frames Transmitted with Carrier Sense Error Statistic Register
	// Position of COUNT field.
	ENET_IEEE_T_CSERR_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_IEEE_T_CSERR_COUNT_Msk = 0xffff

	// IEEE_T_FDXFC: Flow Control Pause Frames Transmitted Statistic Register
	// Position of COUNT field.
	ENET_IEEE_T_FDXFC_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_IEEE_T_FDXFC_COUNT_Msk = 0xffff

	// IEEE_T_OCTETS_OK: Octet Count for Frames Transmitted w/o Error Statistic Register
	// Position of COUNT field.
	ENET_IEEE_T_OCTETS_OK_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_IEEE_T_OCTETS_OK_COUNT_Msk = 0xffffffff

	// RMON_R_PACKETS: Rx Packet Count Statistic Register
	// Position of COUNT field.
	ENET_RMON_R_PACKETS_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_RMON_R_PACKETS_COUNT_Msk = 0xffff

	// RMON_R_BC_PKT: Rx Broadcast Packets Statistic Register
	// Position of COUNT field.
	ENET_RMON_R_BC_PKT_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_RMON_R_BC_PKT_COUNT_Msk = 0xffff

	// RMON_R_MC_PKT: Rx Multicast Packets Statistic Register
	// Position of COUNT field.
	ENET_RMON_R_MC_PKT_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_RMON_R_MC_PKT_COUNT_Msk = 0xffff

	// RMON_R_CRC_ALIGN: Rx Packets with CRC/Align Error Statistic Register
	// Position of COUNT field.
	ENET_RMON_R_CRC_ALIGN_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_RMON_R_CRC_ALIGN_COUNT_Msk = 0xffff

	// RMON_R_UNDERSIZE: Rx Packets with Less Than 64 Bytes and Good CRC Statistic Register
	// Position of COUNT field.
	ENET_RMON_R_UNDERSIZE_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_RMON_R_UNDERSIZE_COUNT_Msk = 0xffff

	// RMON_R_OVERSIZE: Rx Packets Greater Than MAX_FL and Good CRC Statistic Register
	// Position of COUNT field.
	ENET_RMON_R_OVERSIZE_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_RMON_R_OVERSIZE_COUNT_Msk = 0xffff

	// RMON_R_FRAG: Rx Packets Less Than 64 Bytes and Bad CRC Statistic Register
	// Position of COUNT field.
	ENET_RMON_R_FRAG_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_RMON_R_FRAG_COUNT_Msk = 0xffff

	// RMON_R_JAB: Rx Packets Greater Than MAX_FL Bytes and Bad CRC Statistic Register
	// Position of COUNT field.
	ENET_RMON_R_JAB_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_RMON_R_JAB_COUNT_Msk = 0xffff

	// RMON_R_P64: Rx 64-Byte Packets Statistic Register
	// Position of COUNT field.
	ENET_RMON_R_P64_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_RMON_R_P64_COUNT_Msk = 0xffff

	// RMON_R_P65TO127: Rx 65- to 127-Byte Packets Statistic Register
	// Position of COUNT field.
	ENET_RMON_R_P65TO127_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_RMON_R_P65TO127_COUNT_Msk = 0xffff

	// RMON_R_P128TO255: Rx 128- to 255-Byte Packets Statistic Register
	// Position of COUNT field.
	ENET_RMON_R_P128TO255_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_RMON_R_P128TO255_COUNT_Msk = 0xffff

	// RMON_R_P256TO511: Rx 256- to 511-Byte Packets Statistic Register
	// Position of COUNT field.
	ENET_RMON_R_P256TO511_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_RMON_R_P256TO511_COUNT_Msk = 0xffff

	// RMON_R_P512TO1023: Rx 512- to 1023-Byte Packets Statistic Register
	// Position of COUNT field.
	ENET_RMON_R_P512TO1023_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_RMON_R_P512TO1023_COUNT_Msk = 0xffff

	// RMON_R_P1024TO2047: Rx 1024- to 2047-Byte Packets Statistic Register
	// Position of COUNT field.
	ENET_RMON_R_P1024TO2047_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_RMON_R_P1024TO2047_COUNT_Msk = 0xffff

	// RMON_R_P_GTE2048: Rx Packets Greater than 2048 Bytes Statistic Register
	// Position of COUNT field.
	ENET_RMON_R_P_GTE2048_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_RMON_R_P_GTE2048_COUNT_Msk = 0xffff

	// RMON_R_OCTETS: Rx Octets Statistic Register
	// Position of COUNT field.
	ENET_RMON_R_OCTETS_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_RMON_R_OCTETS_COUNT_Msk = 0xffffffff

	// IEEE_R_DROP: Frames not Counted Correctly Statistic Register
	// Position of COUNT field.
	ENET_IEEE_R_DROP_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_IEEE_R_DROP_COUNT_Msk = 0xffff

	// IEEE_R_FRAME_OK: Frames Received OK Statistic Register
	// Position of COUNT field.
	ENET_IEEE_R_FRAME_OK_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_IEEE_R_FRAME_OK_COUNT_Msk = 0xffff

	// IEEE_R_CRC: Frames Received with CRC Error Statistic Register
	// Position of COUNT field.
	ENET_IEEE_R_CRC_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_IEEE_R_CRC_COUNT_Msk = 0xffff

	// IEEE_R_ALIGN: Frames Received with Alignment Error Statistic Register
	// Position of COUNT field.
	ENET_IEEE_R_ALIGN_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_IEEE_R_ALIGN_COUNT_Msk = 0xffff

	// IEEE_R_MACERR: Receive FIFO Overflow Count Statistic Register
	// Position of COUNT field.
	ENET_IEEE_R_MACERR_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_IEEE_R_MACERR_COUNT_Msk = 0xffff

	// IEEE_R_FDXFC: Flow Control Pause Frames Received Statistic Register
	// Position of COUNT field.
	ENET_IEEE_R_FDXFC_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_IEEE_R_FDXFC_COUNT_Msk = 0xffff

	// IEEE_R_OCTETS_OK: Octet Count for Frames Received without Error Statistic Register
	// Position of COUNT field.
	ENET_IEEE_R_OCTETS_OK_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_IEEE_R_OCTETS_OK_COUNT_Msk = 0xffffffff

	// ATCR: Adjustable Timer Control Register
	// Position of EN field.
	ENET_ATCR_EN_Pos = 0x0
	// Bit mask of EN field.
	ENET_ATCR_EN_Msk = 0x1
	// Bit EN.
	ENET_ATCR_EN = 0x1
	// The timer stops at the current value.
	ENET_ATCR_EN_0 = 0x0
	// The timer starts incrementing.
	ENET_ATCR_EN_1 = 0x1
	// Position of OFFEN field.
	ENET_ATCR_OFFEN_Pos = 0x2
	// Bit mask of OFFEN field.
	ENET_ATCR_OFFEN_Msk = 0x4
	// Bit OFFEN.
	ENET_ATCR_OFFEN = 0x4
	// Disable.
	ENET_ATCR_OFFEN_0 = 0x0
	// The timer can be reset to zero when the given offset time is reached (offset event). The field is cleared when the offset event is reached, so no further event occurs until the field is set again. The timer offset value must be set before setting this field.
	ENET_ATCR_OFFEN_1 = 0x1
	// Position of OFFRST field.
	ENET_ATCR_OFFRST_Pos = 0x3
	// Bit mask of OFFRST field.
	ENET_ATCR_OFFRST_Msk = 0x8
	// Bit OFFRST.
	ENET_ATCR_OFFRST = 0x8
	// The timer is not affected and no action occurs, besides clearing OFFEN, when the offset is reached.
	ENET_ATCR_OFFRST_0 = 0x0
	// If OFFEN is set, the timer resets to zero when the offset setting is reached. The offset event does not cause a timer interrupt.
	ENET_ATCR_OFFRST_1 = 0x1
	// Position of PEREN field.
	ENET_ATCR_PEREN_Pos = 0x4
	// Bit mask of PEREN field.
	ENET_ATCR_PEREN_Msk = 0x10
	// Bit PEREN.
	ENET_ATCR_PEREN = 0x10
	// Disable.
	ENET_ATCR_PEREN_0 = 0x0
	// A period event interrupt can be generated (EIR[TS_TIMER]) and the event signal output is asserted when the timer wraps around according to the periodic setting ATPER. The timer period value must be set before setting this bit. Not all devices contain the event signal output. See the chip configuration details.
	ENET_ATCR_PEREN_1 = 0x1
	// Position of PINPER field.
	ENET_ATCR_PINPER_Pos = 0x7
	// Bit mask of PINPER field.
	ENET_ATCR_PINPER_Msk = 0x80
	// Bit PINPER.
	ENET_ATCR_PINPER = 0x80
	// Disable.
	ENET_ATCR_PINPER_0 = 0x0
	// Enable.
	ENET_ATCR_PINPER_1 = 0x1
	// Position of RESTART field.
	ENET_ATCR_RESTART_Pos = 0x9
	// Bit mask of RESTART field.
	ENET_ATCR_RESTART_Msk = 0x200
	// Bit RESTART.
	ENET_ATCR_RESTART = 0x200
	// Position of CAPTURE field.
	ENET_ATCR_CAPTURE_Pos = 0xb
	// Bit mask of CAPTURE field.
	ENET_ATCR_CAPTURE_Msk = 0x800
	// Bit CAPTURE.
	ENET_ATCR_CAPTURE = 0x800
	// No effect.
	ENET_ATCR_CAPTURE_0 = 0x0
	// The current time is captured and can be read from the ATVR register.
	ENET_ATCR_CAPTURE_1 = 0x1
	// Position of SLAVE field.
	ENET_ATCR_SLAVE_Pos = 0xd
	// Bit mask of SLAVE field.
	ENET_ATCR_SLAVE_Msk = 0x2000
	// Bit SLAVE.
	ENET_ATCR_SLAVE = 0x2000
	// The timer is active and all configuration fields in this register are relevant.
	ENET_ATCR_SLAVE_0 = 0x0
	// The internal timer is disabled and the externally provided timer value is used. All other fields, except CAPTURE, in this register have no effect. CAPTURE can still be used to capture the current timer value.
	ENET_ATCR_SLAVE_1 = 0x1

	// ATVR: Timer Value Register
	// Position of ATIME field.
	ENET_ATVR_ATIME_Pos = 0x0
	// Bit mask of ATIME field.
	ENET_ATVR_ATIME_Msk = 0xffffffff

	// ATOFF: Timer Offset Register
	// Position of OFFSET field.
	ENET_ATOFF_OFFSET_Pos = 0x0
	// Bit mask of OFFSET field.
	ENET_ATOFF_OFFSET_Msk = 0xffffffff

	// ATPER: Timer Period Register
	// Position of PERIOD field.
	ENET_ATPER_PERIOD_Pos = 0x0
	// Bit mask of PERIOD field.
	ENET_ATPER_PERIOD_Msk = 0xffffffff

	// ATCOR: Timer Correction Register
	// Position of COR field.
	ENET_ATCOR_COR_Pos = 0x0
	// Bit mask of COR field.
	ENET_ATCOR_COR_Msk = 0x7fffffff

	// ATINC: Time-Stamping Clock Period Register
	// Position of INC field.
	ENET_ATINC_INC_Pos = 0x0
	// Bit mask of INC field.
	ENET_ATINC_INC_Msk = 0x7f
	// Position of INC_CORR field.
	ENET_ATINC_INC_CORR_Pos = 0x8
	// Bit mask of INC_CORR field.
	ENET_ATINC_INC_CORR_Msk = 0x7f00

	// ATSTMP: Timestamp of Last Transmitted Frame
	// Position of TIMESTAMP field.
	ENET_ATSTMP_TIMESTAMP_Pos = 0x0
	// Bit mask of TIMESTAMP field.
	ENET_ATSTMP_TIMESTAMP_Msk = 0xffffffff

	// TGSR: Timer Global Status Register
	// Position of TF0 field.
	ENET_TGSR_TF0_Pos = 0x0
	// Bit mask of TF0 field.
	ENET_TGSR_TF0_Msk = 0x1
	// Bit TF0.
	ENET_TGSR_TF0 = 0x1
	// Timer Flag for Channel 0 is clear
	ENET_TGSR_TF0_0 = 0x0
	// Timer Flag for Channel 0 is set
	ENET_TGSR_TF0_1 = 0x1
	// Position of TF1 field.
	ENET_TGSR_TF1_Pos = 0x1
	// Bit mask of TF1 field.
	ENET_TGSR_TF1_Msk = 0x2
	// Bit TF1.
	ENET_TGSR_TF1 = 0x2
	// Timer Flag for Channel 1 is clear
	ENET_TGSR_TF1_0 = 0x0
	// Timer Flag for Channel 1 is set
	ENET_TGSR_TF1_1 = 0x1
	// Position of TF2 field.
	ENET_TGSR_TF2_Pos = 0x2
	// Bit mask of TF2 field.
	ENET_TGSR_TF2_Msk = 0x4
	// Bit TF2.
	ENET_TGSR_TF2 = 0x4
	// Timer Flag for Channel 2 is clear
	ENET_TGSR_TF2_0 = 0x0
	// Timer Flag for Channel 2 is set
	ENET_TGSR_TF2_1 = 0x1
	// Position of TF3 field.
	ENET_TGSR_TF3_Pos = 0x3
	// Bit mask of TF3 field.
	ENET_TGSR_TF3_Msk = 0x8
	// Bit TF3.
	ENET_TGSR_TF3 = 0x8
	// Timer Flag for Channel 3 is clear
	ENET_TGSR_TF3_0 = 0x0
	// Timer Flag for Channel 3 is set
	ENET_TGSR_TF3_1 = 0x1

	// TCSR0: Timer Control Status Register
	// Position of TDRE field.
	ENET_TCSR_TDRE_Pos = 0x0
	// Bit mask of TDRE field.
	ENET_TCSR_TDRE_Msk = 0x1
	// Bit TDRE.
	ENET_TCSR_TDRE = 0x1
	// DMA request is disabled
	ENET_TCSR_TDRE_0 = 0x0
	// DMA request is enabled
	ENET_TCSR_TDRE_1 = 0x1
	// Position of TMODE field.
	ENET_TCSR_TMODE_Pos = 0x2
	// Bit mask of TMODE field.
	ENET_TCSR_TMODE_Msk = 0x3c
	// Timer Channel is disabled.
	ENET_TCSR_TMODE_0000 = 0x0
	// Timer Channel is configured for Input Capture on rising edge
	ENET_TCSR_TMODE_0001 = 0x1
	// Timer Channel is configured for Input Capture on falling edge
	ENET_TCSR_TMODE_0010 = 0x2
	// Timer Channel is configured for Input Capture on both edges
	ENET_TCSR_TMODE_0011 = 0x3
	// Timer Channel is configured for Output Compare - software only
	ENET_TCSR_TMODE_0100 = 0x4
	// Timer Channel is configured for Output Compare - toggle output on compare
	ENET_TCSR_TMODE_0101 = 0x5
	// Timer Channel is configured for Output Compare - clear output on compare
	ENET_TCSR_TMODE_0110 = 0x6
	// Timer Channel is configured for Output Compare - set output on compare
	ENET_TCSR_TMODE_0111 = 0x7
	// Timer Channel is configured for Output Compare - clear output on compare, set output on overflow
	ENET_TCSR_TMODE_1010 = 0xa
	// Timer Channel is configured for Output Compare - pulse output low on compare for one 1588 clock cycle
	ENET_TCSR_TMODE_1110 = 0xe
	// Timer Channel is configured for Output Compare - pulse output high on compare for one 1588 clock cycle
	ENET_TCSR_TMODE_1111 = 0xf
	// Position of TIE field.
	ENET_TCSR_TIE_Pos = 0x6
	// Bit mask of TIE field.
	ENET_TCSR_TIE_Msk = 0x40
	// Bit TIE.
	ENET_TCSR_TIE = 0x40
	// Interrupt is disabled
	ENET_TCSR_TIE_0 = 0x0
	// Interrupt is enabled
	ENET_TCSR_TIE_1 = 0x1
	// Position of TF field.
	ENET_TCSR_TF_Pos = 0x7
	// Bit mask of TF field.
	ENET_TCSR_TF_Msk = 0x80
	// Bit TF.
	ENET_TCSR_TF = 0x80
	// Input Capture or Output Compare has not occurred
	ENET_TCSR_TF_0 = 0x0
	// Input Capture or Output Compare has occurred
	ENET_TCSR_TF_1 = 0x1

	// TCCR0: Timer Compare Capture Register
	// Position of TCC field.
	ENET_TCCR_TCC_Pos = 0x0
	// Bit mask of TCC field.
	ENET_TCCR_TCC_Msk = 0xffffffff
)

// Constants for DAC0: 12-Bit Digital-to-Analog Converter
const (
	// DAT0L: DAC Data Low Register
	// Position of DATA0 field.
	DAC_DATL_DATA0_Pos = 0x0
	// Bit mask of DATA0 field.
	DAC_DATL_DATA0_Msk = 0xff

	// DAT0H: DAC Data High Register
	// Position of DATA1 field.
	DAC_DATH_DATA1_Pos = 0x0
	// Bit mask of DATA1 field.
	DAC_DATH_DATA1_Msk = 0xf

	// SR: DAC Status Register
	// Position of DACBFRPBF field.
	DAC_SR_DACBFRPBF_Pos = 0x0
	// Bit mask of DACBFRPBF field.
	DAC_SR_DACBFRPBF_Msk = 0x1
	// Bit DACBFRPBF.
	DAC_SR_DACBFRPBF = 0x1
	// The DAC buffer read pointer is not equal to C2[DACBFUP].
	DAC_SR_DACBFRPBF_0 = 0x0
	// The DAC buffer read pointer is equal to C2[DACBFUP].
	DAC_SR_DACBFRPBF_1 = 0x1
	// Position of DACBFRPTF field.
	DAC_SR_DACBFRPTF_Pos = 0x1
	// Bit mask of DACBFRPTF field.
	DAC_SR_DACBFRPTF_Msk = 0x2
	// Bit DACBFRPTF.
	DAC_SR_DACBFRPTF = 0x2
	// The DAC buffer read pointer is not zero.
	DAC_SR_DACBFRPTF_0 = 0x0
	// The DAC buffer read pointer is zero.
	DAC_SR_DACBFRPTF_1 = 0x1
	// Position of DACBFWMF field.
	DAC_SR_DACBFWMF_Pos = 0x2
	// Bit mask of DACBFWMF field.
	DAC_SR_DACBFWMF_Msk = 0x4
	// Bit DACBFWMF.
	DAC_SR_DACBFWMF = 0x4
	// The DAC buffer read pointer has not reached the watermark level.
	DAC_SR_DACBFWMF_0 = 0x0
	// The DAC buffer read pointer has reached the watermark level.
	DAC_SR_DACBFWMF_1 = 0x1

	// C0: DAC Control Register
	// Position of DACBBIEN field.
	DAC_C0_DACBBIEN_Pos = 0x0
	// Bit mask of DACBBIEN field.
	DAC_C0_DACBBIEN_Msk = 0x1
	// Bit DACBBIEN.
	DAC_C0_DACBBIEN = 0x1
	// The DAC buffer read pointer bottom flag interrupt is disabled.
	DAC_C0_DACBBIEN_0 = 0x0
	// The DAC buffer read pointer bottom flag interrupt is enabled.
	DAC_C0_DACBBIEN_1 = 0x1
	// Position of DACBTIEN field.
	DAC_C0_DACBTIEN_Pos = 0x1
	// Bit mask of DACBTIEN field.
	DAC_C0_DACBTIEN_Msk = 0x2
	// Bit DACBTIEN.
	DAC_C0_DACBTIEN = 0x2
	// The DAC buffer read pointer top flag interrupt is disabled.
	DAC_C0_DACBTIEN_0 = 0x0
	// The DAC buffer read pointer top flag interrupt is enabled.
	DAC_C0_DACBTIEN_1 = 0x1
	// Position of DACBWIEN field.
	DAC_C0_DACBWIEN_Pos = 0x2
	// Bit mask of DACBWIEN field.
	DAC_C0_DACBWIEN_Msk = 0x4
	// Bit DACBWIEN.
	DAC_C0_DACBWIEN = 0x4
	// The DAC buffer watermark interrupt is disabled.
	DAC_C0_DACBWIEN_0 = 0x0
	// The DAC buffer watermark interrupt is enabled.
	DAC_C0_DACBWIEN_1 = 0x1
	// Position of LPEN field.
	DAC_C0_LPEN_Pos = 0x3
	// Bit mask of LPEN field.
	DAC_C0_LPEN_Msk = 0x8
	// Bit LPEN.
	DAC_C0_LPEN = 0x8
	// High-Power mode
	DAC_C0_LPEN_0 = 0x0
	// Low-Power mode
	DAC_C0_LPEN_1 = 0x1
	// Position of DACSWTRG field.
	DAC_C0_DACSWTRG_Pos = 0x4
	// Bit mask of DACSWTRG field.
	DAC_C0_DACSWTRG_Msk = 0x10
	// Bit DACSWTRG.
	DAC_C0_DACSWTRG = 0x10
	// The DAC soft trigger is not valid.
	DAC_C0_DACSWTRG_0 = 0x0
	// The DAC soft trigger is valid.
	DAC_C0_DACSWTRG_1 = 0x1
	// Position of DACTRGSEL field.
	DAC_C0_DACTRGSEL_Pos = 0x5
	// Bit mask of DACTRGSEL field.
	DAC_C0_DACTRGSEL_Msk = 0x20
	// Bit DACTRGSEL.
	DAC_C0_DACTRGSEL = 0x20
	// The DAC hardware trigger is selected.
	DAC_C0_DACTRGSEL_0 = 0x0
	// The DAC software trigger is selected.
	DAC_C0_DACTRGSEL_1 = 0x1
	// Position of DACRFS field.
	DAC_C0_DACRFS_Pos = 0x6
	// Bit mask of DACRFS field.
	DAC_C0_DACRFS_Msk = 0x40
	// Bit DACRFS.
	DAC_C0_DACRFS = 0x40
	// The DAC selects DACREF_1 as the reference voltage.
	DAC_C0_DACRFS_0 = 0x0
	// The DAC selects DACREF_2 as the reference voltage.
	DAC_C0_DACRFS_1 = 0x1
	// Position of DACEN field.
	DAC_C0_DACEN_Pos = 0x7
	// Bit mask of DACEN field.
	DAC_C0_DACEN_Msk = 0x80
	// Bit DACEN.
	DAC_C0_DACEN = 0x80
	// The DAC system is disabled.
	DAC_C0_DACEN_0 = 0x0
	// The DAC system is enabled.
	DAC_C0_DACEN_1 = 0x1

	// C1: DAC Control Register 1
	// Position of DACBFEN field.
	DAC_C1_DACBFEN_Pos = 0x0
	// Bit mask of DACBFEN field.
	DAC_C1_DACBFEN_Msk = 0x1
	// Bit DACBFEN.
	DAC_C1_DACBFEN = 0x1
	// Buffer read pointer is disabled. The converted data is always the first word of the buffer.
	DAC_C1_DACBFEN_0 = 0x0
	// Buffer read pointer is enabled. The converted data is the word that the read pointer points to. It means converted data can be from any word of the buffer.
	DAC_C1_DACBFEN_1 = 0x1
	// Position of DACBFMD field.
	DAC_C1_DACBFMD_Pos = 0x1
	// Bit mask of DACBFMD field.
	DAC_C1_DACBFMD_Msk = 0x6
	// Normal mode
	DAC_C1_DACBFMD_00 = 0x0
	// Swing mode
	DAC_C1_DACBFMD_01 = 0x1
	// One-Time Scan mode
	DAC_C1_DACBFMD_10 = 0x2
	// Position of DACBFWM field.
	DAC_C1_DACBFWM_Pos = 0x3
	// Bit mask of DACBFWM field.
	DAC_C1_DACBFWM_Msk = 0x18
	// 1 word
	DAC_C1_DACBFWM_00 = 0x0
	// 2 words
	DAC_C1_DACBFWM_01 = 0x1
	// 3 words
	DAC_C1_DACBFWM_10 = 0x2
	// 4 words
	DAC_C1_DACBFWM_11 = 0x3
	// Position of DMAEN field.
	DAC_C1_DMAEN_Pos = 0x7
	// Bit mask of DMAEN field.
	DAC_C1_DMAEN_Msk = 0x80
	// Bit DMAEN.
	DAC_C1_DMAEN = 0x80
	// DMA is disabled.
	DAC_C1_DMAEN_0 = 0x0
	// DMA is enabled. When DMA is enabled, the DMA request will be generated by original interrupts. The interrupts will not be presented on this module at the same time.
	DAC_C1_DMAEN_1 = 0x1

	// C2: DAC Control Register 2
	// Position of DACBFUP field.
	DAC_C2_DACBFUP_Pos = 0x0
	// Bit mask of DACBFUP field.
	DAC_C2_DACBFUP_Msk = 0xf
	// Position of DACBFRP field.
	DAC_C2_DACBFRP_Pos = 0x4
	// Bit mask of DACBFRP field.
	DAC_C2_DACBFRP_Msk = 0xf0
)

// Constants for GPIOA: General Purpose Input/Output
const (
	// PDOR: Port Data Output Register
	// Position of PDO0 field.
	GPIO_PDOR_PDO0_Pos = 0x0
	// Bit mask of PDO0 field.
	GPIO_PDOR_PDO0_Msk = 0x1
	// Bit PDO0.
	GPIO_PDOR_PDO0 = 0x1
	// Logic level 0 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO0_0 = 0x0
	// Logic level 1 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO0_1 = 0x1
	// Position of PDO1 field.
	GPIO_PDOR_PDO1_Pos = 0x1
	// Bit mask of PDO1 field.
	GPIO_PDOR_PDO1_Msk = 0x2
	// Bit PDO1.
	GPIO_PDOR_PDO1 = 0x2
	// Logic level 0 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO1_0 = 0x0
	// Logic level 1 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO1_1 = 0x1
	// Position of PDO2 field.
	GPIO_PDOR_PDO2_Pos = 0x2
	// Bit mask of PDO2 field.
	GPIO_PDOR_PDO2_Msk = 0x4
	// Bit PDO2.
	GPIO_PDOR_PDO2 = 0x4
	// Logic level 0 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO2_0 = 0x0
	// Logic level 1 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO2_1 = 0x1
	// Position of PDO3 field.
	GPIO_PDOR_PDO3_Pos = 0x3
	// Bit mask of PDO3 field.
	GPIO_PDOR_PDO3_Msk = 0x8
	// Bit PDO3.
	GPIO_PDOR_PDO3 = 0x8
	// Logic level 0 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO3_0 = 0x0
	// Logic level 1 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO3_1 = 0x1
	// Position of PDO4 field.
	GPIO_PDOR_PDO4_Pos = 0x4
	// Bit mask of PDO4 field.
	GPIO_PDOR_PDO4_Msk = 0x10
	// Bit PDO4.
	GPIO_PDOR_PDO4 = 0x10
	// Logic level 0 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO4_0 = 0x0
	// Logic level 1 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO4_1 = 0x1
	// Position of PDO5 field.
	GPIO_PDOR_PDO5_Pos = 0x5
	// Bit mask of PDO5 field.
	GPIO_PDOR_PDO5_Msk = 0x20
	// Bit PDO5.
	GPIO_PDOR_PDO5 = 0x20
	// Logic level 0 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO5_0 = 0x0
	// Logic level 1 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO5_1 = 0x1
	// Position of PDO6 field.
	GPIO_PDOR_PDO6_Pos = 0x6
	// Bit mask of PDO6 field.
	GPIO_PDOR_PDO6_Msk = 0x40
	// Bit PDO6.
	GPIO_PDOR_PDO6 = 0x40
	// Logic level 0 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO6_0 = 0x0
	// Logic level 1 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO6_1 = 0x1
	// Position of PDO7 field.
	GPIO_PDOR_PDO7_Pos = 0x7
	// Bit mask of PDO7 field.
	GPIO_PDOR_PDO7_Msk = 0x80
	// Bit PDO7.
	GPIO_PDOR_PDO7 = 0x80
	// Logic level 0 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO7_0 = 0x0
	// Logic level 1 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO7_1 = 0x1
	// Position of PDO8 field.
	GPIO_PDOR_PDO8_Pos = 0x8
	// Bit mask of PDO8 field.
	GPIO_PDOR_PDO8_Msk = 0x100
	// Bit PDO8.
	GPIO_PDOR_PDO8 = 0x100
	// Logic level 0 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO8_0 = 0x0
	// Logic level 1 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO8_1 = 0x1
	// Position of PDO9 field.
	GPIO_PDOR_PDO9_Pos = 0x9
	// Bit mask of PDO9 field.
	GPIO_PDOR_PDO9_Msk = 0x200
	// Bit PDO9.
	GPIO_PDOR_PDO9 = 0x200
	// Logic level 0 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO9_0 = 0x0
	// Logic level 1 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO9_1 = 0x1
	// Position of PDO10 field.
	GPIO_PDOR_PDO10_Pos = 0xa
	// Bit mask of PDO10 field.
	GPIO_PDOR_PDO10_Msk = 0x400
	// Bit PDO10.
	GPIO_PDOR_PDO10 = 0x400
	// Logic level 0 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO10_0 = 0x0
	// Logic level 1 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO10_1 = 0x1
	// Position of PDO11 field.
	GPIO_PDOR_PDO11_Pos = 0xb
	// Bit mask of PDO11 field.
	GPIO_PDOR_PDO11_Msk = 0x800
	// Bit PDO11.
	GPIO_PDOR_PDO11 = 0x800
	// Logic level 0 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO11_0 = 0x0
	// Logic level 1 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO11_1 = 0x1
	// Position of PDO12 field.
	GPIO_PDOR_PDO12_Pos = 0xc
	// Bit mask of PDO12 field.
	GPIO_PDOR_PDO12_Msk = 0x1000
	// Bit PDO12.
	GPIO_PDOR_PDO12 = 0x1000
	// Logic level 0 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO12_0 = 0x0
	// Logic level 1 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO12_1 = 0x1
	// Position of PDO13 field.
	GPIO_PDOR_PDO13_Pos = 0xd
	// Bit mask of PDO13 field.
	GPIO_PDOR_PDO13_Msk = 0x2000
	// Bit PDO13.
	GPIO_PDOR_PDO13 = 0x2000
	// Logic level 0 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO13_0 = 0x0
	// Logic level 1 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO13_1 = 0x1
	// Position of PDO14 field.
	GPIO_PDOR_PDO14_Pos = 0xe
	// Bit mask of PDO14 field.
	GPIO_PDOR_PDO14_Msk = 0x4000
	// Bit PDO14.
	GPIO_PDOR_PDO14 = 0x4000
	// Logic level 0 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO14_0 = 0x0
	// Logic level 1 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO14_1 = 0x1
	// Position of PDO15 field.
	GPIO_PDOR_PDO15_Pos = 0xf
	// Bit mask of PDO15 field.
	GPIO_PDOR_PDO15_Msk = 0x8000
	// Bit PDO15.
	GPIO_PDOR_PDO15 = 0x8000
	// Logic level 0 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO15_0 = 0x0
	// Logic level 1 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO15_1 = 0x1
	// Position of PDO16 field.
	GPIO_PDOR_PDO16_Pos = 0x10
	// Bit mask of PDO16 field.
	GPIO_PDOR_PDO16_Msk = 0x10000
	// Bit PDO16.
	GPIO_PDOR_PDO16 = 0x10000
	// Logic level 0 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO16_0 = 0x0
	// Logic level 1 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO16_1 = 0x1
	// Position of PDO17 field.
	GPIO_PDOR_PDO17_Pos = 0x11
	// Bit mask of PDO17 field.
	GPIO_PDOR_PDO17_Msk = 0x20000
	// Bit PDO17.
	GPIO_PDOR_PDO17 = 0x20000
	// Logic level 0 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO17_0 = 0x0
	// Logic level 1 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO17_1 = 0x1
	// Position of PDO18 field.
	GPIO_PDOR_PDO18_Pos = 0x12
	// Bit mask of PDO18 field.
	GPIO_PDOR_PDO18_Msk = 0x40000
	// Bit PDO18.
	GPIO_PDOR_PDO18 = 0x40000
	// Logic level 0 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO18_0 = 0x0
	// Logic level 1 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO18_1 = 0x1
	// Position of PDO19 field.
	GPIO_PDOR_PDO19_Pos = 0x13
	// Bit mask of PDO19 field.
	GPIO_PDOR_PDO19_Msk = 0x80000
	// Bit PDO19.
	GPIO_PDOR_PDO19 = 0x80000
	// Logic level 0 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO19_0 = 0x0
	// Logic level 1 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO19_1 = 0x1
	// Position of PDO20 field.
	GPIO_PDOR_PDO20_Pos = 0x14
	// Bit mask of PDO20 field.
	GPIO_PDOR_PDO20_Msk = 0x100000
	// Bit PDO20.
	GPIO_PDOR_PDO20 = 0x100000
	// Logic level 0 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO20_0 = 0x0
	// Logic level 1 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO20_1 = 0x1
	// Position of PDO21 field.
	GPIO_PDOR_PDO21_Pos = 0x15
	// Bit mask of PDO21 field.
	GPIO_PDOR_PDO21_Msk = 0x200000
	// Bit PDO21.
	GPIO_PDOR_PDO21 = 0x200000
	// Logic level 0 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO21_0 = 0x0
	// Logic level 1 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO21_1 = 0x1
	// Position of PDO22 field.
	GPIO_PDOR_PDO22_Pos = 0x16
	// Bit mask of PDO22 field.
	GPIO_PDOR_PDO22_Msk = 0x400000
	// Bit PDO22.
	GPIO_PDOR_PDO22 = 0x400000
	// Logic level 0 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO22_0 = 0x0
	// Logic level 1 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO22_1 = 0x1
	// Position of PDO23 field.
	GPIO_PDOR_PDO23_Pos = 0x17
	// Bit mask of PDO23 field.
	GPIO_PDOR_PDO23_Msk = 0x800000
	// Bit PDO23.
	GPIO_PDOR_PDO23 = 0x800000
	// Logic level 0 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO23_0 = 0x0
	// Logic level 1 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO23_1 = 0x1
	// Position of PDO24 field.
	GPIO_PDOR_PDO24_Pos = 0x18
	// Bit mask of PDO24 field.
	GPIO_PDOR_PDO24_Msk = 0x1000000
	// Bit PDO24.
	GPIO_PDOR_PDO24 = 0x1000000
	// Logic level 0 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO24_0 = 0x0
	// Logic level 1 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO24_1 = 0x1
	// Position of PDO25 field.
	GPIO_PDOR_PDO25_Pos = 0x19
	// Bit mask of PDO25 field.
	GPIO_PDOR_PDO25_Msk = 0x2000000
	// Bit PDO25.
	GPIO_PDOR_PDO25 = 0x2000000
	// Logic level 0 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO25_0 = 0x0
	// Logic level 1 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO25_1 = 0x1
	// Position of PDO26 field.
	GPIO_PDOR_PDO26_Pos = 0x1a
	// Bit mask of PDO26 field.
	GPIO_PDOR_PDO26_Msk = 0x4000000
	// Bit PDO26.
	GPIO_PDOR_PDO26 = 0x4000000
	// Logic level 0 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO26_0 = 0x0
	// Logic level 1 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO26_1 = 0x1
	// Position of PDO27 field.
	GPIO_PDOR_PDO27_Pos = 0x1b
	// Bit mask of PDO27 field.
	GPIO_PDOR_PDO27_Msk = 0x8000000
	// Bit PDO27.
	GPIO_PDOR_PDO27 = 0x8000000
	// Logic level 0 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO27_0 = 0x0
	// Logic level 1 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO27_1 = 0x1
	// Position of PDO28 field.
	GPIO_PDOR_PDO28_Pos = 0x1c
	// Bit mask of PDO28 field.
	GPIO_PDOR_PDO28_Msk = 0x10000000
	// Bit PDO28.
	GPIO_PDOR_PDO28 = 0x10000000
	// Logic level 0 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO28_0 = 0x0
	// Logic level 1 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO28_1 = 0x1
	// Position of PDO29 field.
	GPIO_PDOR_PDO29_Pos = 0x1d
	// Bit mask of PDO29 field.
	GPIO_PDOR_PDO29_Msk = 0x20000000
	// Bit PDO29.
	GPIO_PDOR_PDO29 = 0x20000000
	// Logic level 0 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO29_0 = 0x0
	// Logic level 1 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO29_1 = 0x1
	// Position of PDO30 field.
	GPIO_PDOR_PDO30_Pos = 0x1e
	// Bit mask of PDO30 field.
	GPIO_PDOR_PDO30_Msk = 0x40000000
	// Bit PDO30.
	GPIO_PDOR_PDO30 = 0x40000000
	// Logic level 0 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO30_0 = 0x0
	// Logic level 1 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO30_1 = 0x1
	// Position of PDO31 field.
	GPIO_PDOR_PDO31_Pos = 0x1f
	// Bit mask of PDO31 field.
	GPIO_PDOR_PDO31_Msk = 0x80000000
	// Bit PDO31.
	GPIO_PDOR_PDO31 = 0x80000000
	// Logic level 0 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO31_0 = 0x0
	// Logic level 1 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO31_1 = 0x1

	// PSOR: Port Set Output Register
	// Position of PTSO0 field.
	GPIO_PSOR_PTSO0_Pos = 0x0
	// Bit mask of PTSO0 field.
	GPIO_PSOR_PTSO0_Msk = 0x1
	// Bit PTSO0.
	GPIO_PSOR_PTSO0 = 0x1
	// Corresponding bit in PDORn does not change.
	GPIO_PSOR_PTSO0_0 = 0x0
	// Corresponding bit in PDORn is set to logic 1.
	GPIO_PSOR_PTSO0_1 = 0x1
	// Position of PTSO1 field.
	GPIO_PSOR_PTSO1_Pos = 0x1
	// Bit mask of PTSO1 field.
	GPIO_PSOR_PTSO1_Msk = 0x2
	// Bit PTSO1.
	GPIO_PSOR_PTSO1 = 0x2
	// Corresponding bit in PDORn does not change.
	GPIO_PSOR_PTSO1_0 = 0x0
	// Corresponding bit in PDORn is set to logic 1.
	GPIO_PSOR_PTSO1_1 = 0x1
	// Position of PTSO2 field.
	GPIO_PSOR_PTSO2_Pos = 0x2
	// Bit mask of PTSO2 field.
	GPIO_PSOR_PTSO2_Msk = 0x4
	// Bit PTSO2.
	GPIO_PSOR_PTSO2 = 0x4
	// Corresponding bit in PDORn does not change.
	GPIO_PSOR_PTSO2_0 = 0x0
	// Corresponding bit in PDORn is set to logic 1.
	GPIO_PSOR_PTSO2_1 = 0x1
	// Position of PTSO3 field.
	GPIO_PSOR_PTSO3_Pos = 0x3
	// Bit mask of PTSO3 field.
	GPIO_PSOR_PTSO3_Msk = 0x8
	// Bit PTSO3.
	GPIO_PSOR_PTSO3 = 0x8
	// Corresponding bit in PDORn does not change.
	GPIO_PSOR_PTSO3_0 = 0x0
	// Corresponding bit in PDORn is set to logic 1.
	GPIO_PSOR_PTSO3_1 = 0x1
	// Position of PTSO4 field.
	GPIO_PSOR_PTSO4_Pos = 0x4
	// Bit mask of PTSO4 field.
	GPIO_PSOR_PTSO4_Msk = 0x10
	// Bit PTSO4.
	GPIO_PSOR_PTSO4 = 0x10
	// Corresponding bit in PDORn does not change.
	GPIO_PSOR_PTSO4_0 = 0x0
	// Corresponding bit in PDORn is set to logic 1.
	GPIO_PSOR_PTSO4_1 = 0x1
	// Position of PTSO5 field.
	GPIO_PSOR_PTSO5_Pos = 0x5
	// Bit mask of PTSO5 field.
	GPIO_PSOR_PTSO5_Msk = 0x20
	// Bit PTSO5.
	GPIO_PSOR_PTSO5 = 0x20
	// Corresponding bit in PDORn does not change.
	GPIO_PSOR_PTSO5_0 = 0x0
	// Corresponding bit in PDORn is set to logic 1.
	GPIO_PSOR_PTSO5_1 = 0x1
	// Position of PTSO6 field.
	GPIO_PSOR_PTSO6_Pos = 0x6
	// Bit mask of PTSO6 field.
	GPIO_PSOR_PTSO6_Msk = 0x40
	// Bit PTSO6.
	GPIO_PSOR_PTSO6 = 0x40
	// Corresponding bit in PDORn does not change.
	GPIO_PSOR_PTSO6_0 = 0x0
	// Corresponding bit in PDORn is set to logic 1.
	GPIO_PSOR_PTSO6_1 = 0x1
	// Position of PTSO7 field.
	GPIO_PSOR_PTSO7_Pos = 0x7
	// Bit mask of PTSO7 field.
	GPIO_PSOR_PTSO7_Msk = 0x80
	// Bit PTSO7.
	GPIO_PSOR_PTSO7 = 0x80
	// Corresponding bit in PDORn does not change.
	GPIO_PSOR_PTSO7_0 = 0x0
	// Corresponding bit in PDORn is set to logic 1.
	GPIO_PSOR_PTSO7_1 = 0x1
	// Position of PTSO8 field.
	GPIO_PSOR_PTSO8_Pos = 0x8
	// Bit mask of PTSO8 field.
	GPIO_PSOR_PTSO8_Msk = 0x100
	// Bit PTSO8.
	GPIO_PSOR_PTSO8 = 0x100
	// Corresponding bit in PDORn does not change.
	GPIO_PSOR_PTSO8_0 = 0x0
	// Corresponding bit in PDORn is set to logic 1.
	GPIO_PSOR_PTSO8_1 = 0x1
	// Position of PTSO9 field.
	GPIO_PSOR_PTSO9_Pos = 0x9
	// Bit mask of PTSO9 field.
	GPIO_PSOR_PTSO9_Msk = 0x200
	// Bit PTSO9.
	GPIO_PSOR_PTSO9 = 0x200
	// Corresponding bit in PDORn does not change.
	GPIO_PSOR_PTSO9_0 = 0x0
	// Corresponding bit in PDORn is set to logic 1.
	GPIO_PSOR_PTSO9_1 = 0x1
	// Position of PTSO10 field.
	GPIO_PSOR_PTSO10_Pos = 0xa
	// Bit mask of PTSO10 field.
	GPIO_PSOR_PTSO10_Msk = 0x400
	// Bit PTSO10.
	GPIO_PSOR_PTSO10 = 0x400
	// Corresponding bit in PDORn does not change.
	GPIO_PSOR_PTSO10_0 = 0x0
	// Corresponding bit in PDORn is set to logic 1.
	GPIO_PSOR_PTSO10_1 = 0x1
	// Position of PTSO11 field.
	GPIO_PSOR_PTSO11_Pos = 0xb
	// Bit mask of PTSO11 field.
	GPIO_PSOR_PTSO11_Msk = 0x800
	// Bit PTSO11.
	GPIO_PSOR_PTSO11 = 0x800
	// Corresponding bit in PDORn does not change.
	GPIO_PSOR_PTSO11_0 = 0x0
	// Corresponding bit in PDORn is set to logic 1.
	GPIO_PSOR_PTSO11_1 = 0x1
	// Position of PTSO12 field.
	GPIO_PSOR_PTSO12_Pos = 0xc
	// Bit mask of PTSO12 field.
	GPIO_PSOR_PTSO12_Msk = 0x1000
	// Bit PTSO12.
	GPIO_PSOR_PTSO12 = 0x1000
	// Corresponding bit in PDORn does not change.
	GPIO_PSOR_PTSO12_0 = 0x0
	// Corresponding bit in PDORn is set to logic 1.
	GPIO_PSOR_PTSO12_1 = 0x1
	// Position of PTSO13 field.
	GPIO_PSOR_PTSO13_Pos = 0xd
	// Bit mask of PTSO13 field.
	GPIO_PSOR_PTSO13_Msk = 0x2000
	// Bit PTSO13.
	GPIO_PSOR_PTSO13 = 0x2000
	// Corresponding bit in PDORn does not change.
	GPIO_PSOR_PTSO13_0 = 0x0
	// Corresponding bit in PDORn is set to logic 1.
	GPIO_PSOR_PTSO13_1 = 0x1
	// Position of PTSO14 field.
	GPIO_PSOR_PTSO14_Pos = 0xe
	// Bit mask of PTSO14 field.
	GPIO_PSOR_PTSO14_Msk = 0x4000
	// Bit PTSO14.
	GPIO_PSOR_PTSO14 = 0x4000
	// Corresponding bit in PDORn does not change.
	GPIO_PSOR_PTSO14_0 = 0x0
	// Corresponding bit in PDORn is set to logic 1.
	GPIO_PSOR_PTSO14_1 = 0x1
	// Position of PTSO15 field.
	GPIO_PSOR_PTSO15_Pos = 0xf
	// Bit mask of PTSO15 field.
	GPIO_PSOR_PTSO15_Msk = 0x8000
	// Bit PTSO15.
	GPIO_PSOR_PTSO15 = 0x8000
	// Corresponding bit in PDORn does not change.
	GPIO_PSOR_PTSO15_0 = 0x0
	// Corresponding bit in PDORn is set to logic 1.
	GPIO_PSOR_PTSO15_1 = 0x1
	// Position of PTSO16 field.
	GPIO_PSOR_PTSO16_Pos = 0x10
	// Bit mask of PTSO16 field.
	GPIO_PSOR_PTSO16_Msk = 0x10000
	// Bit PTSO16.
	GPIO_PSOR_PTSO16 = 0x10000
	// Corresponding bit in PDORn does not change.
	GPIO_PSOR_PTSO16_0 = 0x0
	// Corresponding bit in PDORn is set to logic 1.
	GPIO_PSOR_PTSO16_1 = 0x1
	// Position of PTSO17 field.
	GPIO_PSOR_PTSO17_Pos = 0x11
	// Bit mask of PTSO17 field.
	GPIO_PSOR_PTSO17_Msk = 0x20000
	// Bit PTSO17.
	GPIO_PSOR_PTSO17 = 0x20000
	// Corresponding bit in PDORn does not change.
	GPIO_PSOR_PTSO17_0 = 0x0
	// Corresponding bit in PDORn is set to logic 1.
	GPIO_PSOR_PTSO17_1 = 0x1
	// Position of PTSO18 field.
	GPIO_PSOR_PTSO18_Pos = 0x12
	// Bit mask of PTSO18 field.
	GPIO_PSOR_PTSO18_Msk = 0x40000
	// Bit PTSO18.
	GPIO_PSOR_PTSO18 = 0x40000
	// Corresponding bit in PDORn does not change.
	GPIO_PSOR_PTSO18_0 = 0x0
	// Corresponding bit in PDORn is set to logic 1.
	GPIO_PSOR_PTSO18_1 = 0x1
	// Position of PTSO19 field.
	GPIO_PSOR_PTSO19_Pos = 0x13
	// Bit mask of PTSO19 field.
	GPIO_PSOR_PTSO19_Msk = 0x80000
	// Bit PTSO19.
	GPIO_PSOR_PTSO19 = 0x80000
	// Corresponding bit in PDORn does not change.
	GPIO_PSOR_PTSO19_0 = 0x0
	// Corresponding bit in PDORn is set to logic 1.
	GPIO_PSOR_PTSO19_1 = 0x1
	// Position of PTSO20 field.
	GPIO_PSOR_PTSO20_Pos = 0x14
	// Bit mask of PTSO20 field.
	GPIO_PSOR_PTSO20_Msk = 0x100000
	// Bit PTSO20.
	GPIO_PSOR_PTSO20 = 0x100000
	// Corresponding bit in PDORn does not change.
	GPIO_PSOR_PTSO20_0 = 0x0
	// Corresponding bit in PDORn is set to logic 1.
	GPIO_PSOR_PTSO20_1 = 0x1
	// Position of PTSO21 field.
	GPIO_PSOR_PTSO21_Pos = 0x15
	// Bit mask of PTSO21 field.
	GPIO_PSOR_PTSO21_Msk = 0x200000
	// Bit PTSO21.
	GPIO_PSOR_PTSO21 = 0x200000
	// Corresponding bit in PDORn does not change.
	GPIO_PSOR_PTSO21_0 = 0x0
	// Corresponding bit in PDORn is set to logic 1.
	GPIO_PSOR_PTSO21_1 = 0x1
	// Position of PTSO22 field.
	GPIO_PSOR_PTSO22_Pos = 0x16
	// Bit mask of PTSO22 field.
	GPIO_PSOR_PTSO22_Msk = 0x400000
	// Bit PTSO22.
	GPIO_PSOR_PTSO22 = 0x400000
	// Corresponding bit in PDORn does not change.
	GPIO_PSOR_PTSO22_0 = 0x0
	// Corresponding bit in PDORn is set to logic 1.
	GPIO_PSOR_PTSO22_1 = 0x1
	// Position of PTSO23 field.
	GPIO_PSOR_PTSO23_Pos = 0x17
	// Bit mask of PTSO23 field.
	GPIO_PSOR_PTSO23_Msk = 0x800000
	// Bit PTSO23.
	GPIO_PSOR_PTSO23 = 0x800000
	// Corresponding bit in PDORn does not change.
	GPIO_PSOR_PTSO23_0 = 0x0
	// Corresponding bit in PDORn is set to logic 1.
	GPIO_PSOR_PTSO23_1 = 0x1
	// Position of PTSO24 field.
	GPIO_PSOR_PTSO24_Pos = 0x18
	// Bit mask of PTSO24 field.
	GPIO_PSOR_PTSO24_Msk = 0x1000000
	// Bit PTSO24.
	GPIO_PSOR_PTSO24 = 0x1000000
	// Corresponding bit in PDORn does not change.
	GPIO_PSOR_PTSO24_0 = 0x0
	// Corresponding bit in PDORn is set to logic 1.
	GPIO_PSOR_PTSO24_1 = 0x1
	// Position of PTSO25 field.
	GPIO_PSOR_PTSO25_Pos = 0x19
	// Bit mask of PTSO25 field.
	GPIO_PSOR_PTSO25_Msk = 0x2000000
	// Bit PTSO25.
	GPIO_PSOR_PTSO25 = 0x2000000
	// Corresponding bit in PDORn does not change.
	GPIO_PSOR_PTSO25_0 = 0x0
	// Corresponding bit in PDORn is set to logic 1.
	GPIO_PSOR_PTSO25_1 = 0x1
	// Position of PTSO26 field.
	GPIO_PSOR_PTSO26_Pos = 0x1a
	// Bit mask of PTSO26 field.
	GPIO_PSOR_PTSO26_Msk = 0x4000000
	// Bit PTSO26.
	GPIO_PSOR_PTSO26 = 0x4000000
	// Corresponding bit in PDORn does not change.
	GPIO_PSOR_PTSO26_0 = 0x0
	// Corresponding bit in PDORn is set to logic 1.
	GPIO_PSOR_PTSO26_1 = 0x1
	// Position of PTSO27 field.
	GPIO_PSOR_PTSO27_Pos = 0x1b
	// Bit mask of PTSO27 field.
	GPIO_PSOR_PTSO27_Msk = 0x8000000
	// Bit PTSO27.
	GPIO_PSOR_PTSO27 = 0x8000000
	// Corresponding bit in PDORn does not change.
	GPIO_PSOR_PTSO27_0 = 0x0
	// Corresponding bit in PDORn is set to logic 1.
	GPIO_PSOR_PTSO27_1 = 0x1
	// Position of PTSO28 field.
	GPIO_PSOR_PTSO28_Pos = 0x1c
	// Bit mask of PTSO28 field.
	GPIO_PSOR_PTSO28_Msk = 0x10000000
	// Bit PTSO28.
	GPIO_PSOR_PTSO28 = 0x10000000
	// Corresponding bit in PDORn does not change.
	GPIO_PSOR_PTSO28_0 = 0x0
	// Corresponding bit in PDORn is set to logic 1.
	GPIO_PSOR_PTSO28_1 = 0x1
	// Position of PTSO29 field.
	GPIO_PSOR_PTSO29_Pos = 0x1d
	// Bit mask of PTSO29 field.
	GPIO_PSOR_PTSO29_Msk = 0x20000000
	// Bit PTSO29.
	GPIO_PSOR_PTSO29 = 0x20000000
	// Corresponding bit in PDORn does not change.
	GPIO_PSOR_PTSO29_0 = 0x0
	// Corresponding bit in PDORn is set to logic 1.
	GPIO_PSOR_PTSO29_1 = 0x1
	// Position of PTSO30 field.
	GPIO_PSOR_PTSO30_Pos = 0x1e
	// Bit mask of PTSO30 field.
	GPIO_PSOR_PTSO30_Msk = 0x40000000
	// Bit PTSO30.
	GPIO_PSOR_PTSO30 = 0x40000000
	// Corresponding bit in PDORn does not change.
	GPIO_PSOR_PTSO30_0 = 0x0
	// Corresponding bit in PDORn is set to logic 1.
	GPIO_PSOR_PTSO30_1 = 0x1
	// Position of PTSO31 field.
	GPIO_PSOR_PTSO31_Pos = 0x1f
	// Bit mask of PTSO31 field.
	GPIO_PSOR_PTSO31_Msk = 0x80000000
	// Bit PTSO31.
	GPIO_PSOR_PTSO31 = 0x80000000
	// Corresponding bit in PDORn does not change.
	GPIO_PSOR_PTSO31_0 = 0x0
	// Corresponding bit in PDORn is set to logic 1.
	GPIO_PSOR_PTSO31_1 = 0x1

	// PCOR: Port Clear Output Register
	// Position of PTCO0 field.
	GPIO_PCOR_PTCO0_Pos = 0x0
	// Bit mask of PTCO0 field.
	GPIO_PCOR_PTCO0_Msk = 0x1
	// Bit PTCO0.
	GPIO_PCOR_PTCO0 = 0x1
	// Corresponding bit in PDORn does not change.
	GPIO_PCOR_PTCO0_0 = 0x0
	// Corresponding bit in PDORn is cleared to logic 0.
	GPIO_PCOR_PTCO0_1 = 0x1
	// Position of PTCO1 field.
	GPIO_PCOR_PTCO1_Pos = 0x1
	// Bit mask of PTCO1 field.
	GPIO_PCOR_PTCO1_Msk = 0x2
	// Bit PTCO1.
	GPIO_PCOR_PTCO1 = 0x2
	// Corresponding bit in PDORn does not change.
	GPIO_PCOR_PTCO1_0 = 0x0
	// Corresponding bit in PDORn is cleared to logic 0.
	GPIO_PCOR_PTCO1_1 = 0x1
	// Position of PTCO2 field.
	GPIO_PCOR_PTCO2_Pos = 0x2
	// Bit mask of PTCO2 field.
	GPIO_PCOR_PTCO2_Msk = 0x4
	// Bit PTCO2.
	GPIO_PCOR_PTCO2 = 0x4
	// Corresponding bit in PDORn does not change.
	GPIO_PCOR_PTCO2_0 = 0x0
	// Corresponding bit in PDORn is cleared to logic 0.
	GPIO_PCOR_PTCO2_1 = 0x1
	// Position of PTCO3 field.
	GPIO_PCOR_PTCO3_Pos = 0x3
	// Bit mask of PTCO3 field.
	GPIO_PCOR_PTCO3_Msk = 0x8
	// Bit PTCO3.
	GPIO_PCOR_PTCO3 = 0x8
	// Corresponding bit in PDORn does not change.
	GPIO_PCOR_PTCO3_0 = 0x0
	// Corresponding bit in PDORn is cleared to logic 0.
	GPIO_PCOR_PTCO3_1 = 0x1
	// Position of PTCO4 field.
	GPIO_PCOR_PTCO4_Pos = 0x4
	// Bit mask of PTCO4 field.
	GPIO_PCOR_PTCO4_Msk = 0x10
	// Bit PTCO4.
	GPIO_PCOR_PTCO4 = 0x10
	// Corresponding bit in PDORn does not change.
	GPIO_PCOR_PTCO4_0 = 0x0
	// Corresponding bit in PDORn is cleared to logic 0.
	GPIO_PCOR_PTCO4_1 = 0x1
	// Position of PTCO5 field.
	GPIO_PCOR_PTCO5_Pos = 0x5
	// Bit mask of PTCO5 field.
	GPIO_PCOR_PTCO5_Msk = 0x20
	// Bit PTCO5.
	GPIO_PCOR_PTCO5 = 0x20
	// Corresponding bit in PDORn does not change.
	GPIO_PCOR_PTCO5_0 = 0x0
	// Corresponding bit in PDORn is cleared to logic 0.
	GPIO_PCOR_PTCO5_1 = 0x1
	// Position of PTCO6 field.
	GPIO_PCOR_PTCO6_Pos = 0x6
	// Bit mask of PTCO6 field.
	GPIO_PCOR_PTCO6_Msk = 0x40
	// Bit PTCO6.
	GPIO_PCOR_PTCO6 = 0x40
	// Corresponding bit in PDORn does not change.
	GPIO_PCOR_PTCO6_0 = 0x0
	// Corresponding bit in PDORn is cleared to logic 0.
	GPIO_PCOR_PTCO6_1 = 0x1
	// Position of PTCO7 field.
	GPIO_PCOR_PTCO7_Pos = 0x7
	// Bit mask of PTCO7 field.
	GPIO_PCOR_PTCO7_Msk = 0x80
	// Bit PTCO7.
	GPIO_PCOR_PTCO7 = 0x80
	// Corresponding bit in PDORn does not change.
	GPIO_PCOR_PTCO7_0 = 0x0
	// Corresponding bit in PDORn is cleared to logic 0.
	GPIO_PCOR_PTCO7_1 = 0x1
	// Position of PTCO8 field.
	GPIO_PCOR_PTCO8_Pos = 0x8
	// Bit mask of PTCO8 field.
	GPIO_PCOR_PTCO8_Msk = 0x100
	// Bit PTCO8.
	GPIO_PCOR_PTCO8 = 0x100
	// Corresponding bit in PDORn does not change.
	GPIO_PCOR_PTCO8_0 = 0x0
	// Corresponding bit in PDORn is cleared to logic 0.
	GPIO_PCOR_PTCO8_1 = 0x1
	// Position of PTCO9 field.
	GPIO_PCOR_PTCO9_Pos = 0x9
	// Bit mask of PTCO9 field.
	GPIO_PCOR_PTCO9_Msk = 0x200
	// Bit PTCO9.
	GPIO_PCOR_PTCO9 = 0x200
	// Corresponding bit in PDORn does not change.
	GPIO_PCOR_PTCO9_0 = 0x0
	// Corresponding bit in PDORn is cleared to logic 0.
	GPIO_PCOR_PTCO9_1 = 0x1
	// Position of PTCO10 field.
	GPIO_PCOR_PTCO10_Pos = 0xa
	// Bit mask of PTCO10 field.
	GPIO_PCOR_PTCO10_Msk = 0x400
	// Bit PTCO10.
	GPIO_PCOR_PTCO10 = 0x400
	// Corresponding bit in PDORn does not change.
	GPIO_PCOR_PTCO10_0 = 0x0
	// Corresponding bit in PDORn is cleared to logic 0.
	GPIO_PCOR_PTCO10_1 = 0x1
	// Position of PTCO11 field.
	GPIO_PCOR_PTCO11_Pos = 0xb
	// Bit mask of PTCO11 field.
	GPIO_PCOR_PTCO11_Msk = 0x800
	// Bit PTCO11.
	GPIO_PCOR_PTCO11 = 0x800
	// Corresponding bit in PDORn does not change.
	GPIO_PCOR_PTCO11_0 = 0x0
	// Corresponding bit in PDORn is cleared to logic 0.
	GPIO_PCOR_PTCO11_1 = 0x1
	// Position of PTCO12 field.
	GPIO_PCOR_PTCO12_Pos = 0xc
	// Bit mask of PTCO12 field.
	GPIO_PCOR_PTCO12_Msk = 0x1000
	// Bit PTCO12.
	GPIO_PCOR_PTCO12 = 0x1000
	// Corresponding bit in PDORn does not change.
	GPIO_PCOR_PTCO12_0 = 0x0
	// Corresponding bit in PDORn is cleared to logic 0.
	GPIO_PCOR_PTCO12_1 = 0x1
	// Position of PTCO13 field.
	GPIO_PCOR_PTCO13_Pos = 0xd
	// Bit mask of PTCO13 field.
	GPIO_PCOR_PTCO13_Msk = 0x2000
	// Bit PTCO13.
	GPIO_PCOR_PTCO13 = 0x2000
	// Corresponding bit in PDORn does not change.
	GPIO_PCOR_PTCO13_0 = 0x0
	// Corresponding bit in PDORn is cleared to logic 0.
	GPIO_PCOR_PTCO13_1 = 0x1
	// Position of PTCO14 field.
	GPIO_PCOR_PTCO14_Pos = 0xe
	// Bit mask of PTCO14 field.
	GPIO_PCOR_PTCO14_Msk = 0x4000
	// Bit PTCO14.
	GPIO_PCOR_PTCO14 = 0x4000
	// Corresponding bit in PDORn does not change.
	GPIO_PCOR_PTCO14_0 = 0x0
	// Corresponding bit in PDORn is cleared to logic 0.
	GPIO_PCOR_PTCO14_1 = 0x1
	// Position of PTCO15 field.
	GPIO_PCOR_PTCO15_Pos = 0xf
	// Bit mask of PTCO15 field.
	GPIO_PCOR_PTCO15_Msk = 0x8000
	// Bit PTCO15.
	GPIO_PCOR_PTCO15 = 0x8000
	// Corresponding bit in PDORn does not change.
	GPIO_PCOR_PTCO15_0 = 0x0
	// Corresponding bit in PDORn is cleared to logic 0.
	GPIO_PCOR_PTCO15_1 = 0x1
	// Position of PTCO16 field.
	GPIO_PCOR_PTCO16_Pos = 0x10
	// Bit mask of PTCO16 field.
	GPIO_PCOR_PTCO16_Msk = 0x10000
	// Bit PTCO16.
	GPIO_PCOR_PTCO16 = 0x10000
	// Corresponding bit in PDORn does not change.
	GPIO_PCOR_PTCO16_0 = 0x0
	// Corresponding bit in PDORn is cleared to logic 0.
	GPIO_PCOR_PTCO16_1 = 0x1
	// Position of PTCO17 field.
	GPIO_PCOR_PTCO17_Pos = 0x11
	// Bit mask of PTCO17 field.
	GPIO_PCOR_PTCO17_Msk = 0x20000
	// Bit PTCO17.
	GPIO_PCOR_PTCO17 = 0x20000
	// Corresponding bit in PDORn does not change.
	GPIO_PCOR_PTCO17_0 = 0x0
	// Corresponding bit in PDORn is cleared to logic 0.
	GPIO_PCOR_PTCO17_1 = 0x1
	// Position of PTCO18 field.
	GPIO_PCOR_PTCO18_Pos = 0x12
	// Bit mask of PTCO18 field.
	GPIO_PCOR_PTCO18_Msk = 0x40000
	// Bit PTCO18.
	GPIO_PCOR_PTCO18 = 0x40000
	// Corresponding bit in PDORn does not change.
	GPIO_PCOR_PTCO18_0 = 0x0
	// Corresponding bit in PDORn is cleared to logic 0.
	GPIO_PCOR_PTCO18_1 = 0x1
	// Position of PTCO19 field.
	GPIO_PCOR_PTCO19_Pos = 0x13
	// Bit mask of PTCO19 field.
	GPIO_PCOR_PTCO19_Msk = 0x80000
	// Bit PTCO19.
	GPIO_PCOR_PTCO19 = 0x80000
	// Corresponding bit in PDORn does not change.
	GPIO_PCOR_PTCO19_0 = 0x0
	// Corresponding bit in PDORn is cleared to logic 0.
	GPIO_PCOR_PTCO19_1 = 0x1
	// Position of PTCO20 field.
	GPIO_PCOR_PTCO20_Pos = 0x14
	// Bit mask of PTCO20 field.
	GPIO_PCOR_PTCO20_Msk = 0x100000
	// Bit PTCO20.
	GPIO_PCOR_PTCO20 = 0x100000
	// Corresponding bit in PDORn does not change.
	GPIO_PCOR_PTCO20_0 = 0x0
	// Corresponding bit in PDORn is cleared to logic 0.
	GPIO_PCOR_PTCO20_1 = 0x1
	// Position of PTCO21 field.
	GPIO_PCOR_PTCO21_Pos = 0x15
	// Bit mask of PTCO21 field.
	GPIO_PCOR_PTCO21_Msk = 0x200000
	// Bit PTCO21.
	GPIO_PCOR_PTCO21 = 0x200000
	// Corresponding bit in PDORn does not change.
	GPIO_PCOR_PTCO21_0 = 0x0
	// Corresponding bit in PDORn is cleared to logic 0.
	GPIO_PCOR_PTCO21_1 = 0x1
	// Position of PTCO22 field.
	GPIO_PCOR_PTCO22_Pos = 0x16
	// Bit mask of PTCO22 field.
	GPIO_PCOR_PTCO22_Msk = 0x400000
	// Bit PTCO22.
	GPIO_PCOR_PTCO22 = 0x400000
	// Corresponding bit in PDORn does not change.
	GPIO_PCOR_PTCO22_0 = 0x0
	// Corresponding bit in PDORn is cleared to logic 0.
	GPIO_PCOR_PTCO22_1 = 0x1
	// Position of PTCO23 field.
	GPIO_PCOR_PTCO23_Pos = 0x17
	// Bit mask of PTCO23 field.
	GPIO_PCOR_PTCO23_Msk = 0x800000
	// Bit PTCO23.
	GPIO_PCOR_PTCO23 = 0x800000
	// Corresponding bit in PDORn does not change.
	GPIO_PCOR_PTCO23_0 = 0x0
	// Corresponding bit in PDORn is cleared to logic 0.
	GPIO_PCOR_PTCO23_1 = 0x1
	// Position of PTCO24 field.
	GPIO_PCOR_PTCO24_Pos = 0x18
	// Bit mask of PTCO24 field.
	GPIO_PCOR_PTCO24_Msk = 0x1000000
	// Bit PTCO24.
	GPIO_PCOR_PTCO24 = 0x1000000
	// Corresponding bit in PDORn does not change.
	GPIO_PCOR_PTCO24_0 = 0x0
	// Corresponding bit in PDORn is cleared to logic 0.
	GPIO_PCOR_PTCO24_1 = 0x1
	// Position of PTCO25 field.
	GPIO_PCOR_PTCO25_Pos = 0x19
	// Bit mask of PTCO25 field.
	GPIO_PCOR_PTCO25_Msk = 0x2000000
	// Bit PTCO25.
	GPIO_PCOR_PTCO25 = 0x2000000
	// Corresponding bit in PDORn does not change.
	GPIO_PCOR_PTCO25_0 = 0x0
	// Corresponding bit in PDORn is cleared to logic 0.
	GPIO_PCOR_PTCO25_1 = 0x1
	// Position of PTCO26 field.
	GPIO_PCOR_PTCO26_Pos = 0x1a
	// Bit mask of PTCO26 field.
	GPIO_PCOR_PTCO26_Msk = 0x4000000
	// Bit PTCO26.
	GPIO_PCOR_PTCO26 = 0x4000000
	// Corresponding bit in PDORn does not change.
	GPIO_PCOR_PTCO26_0 = 0x0
	// Corresponding bit in PDORn is cleared to logic 0.
	GPIO_PCOR_PTCO26_1 = 0x1
	// Position of PTCO27 field.
	GPIO_PCOR_PTCO27_Pos = 0x1b
	// Bit mask of PTCO27 field.
	GPIO_PCOR_PTCO27_Msk = 0x8000000
	// Bit PTCO27.
	GPIO_PCOR_PTCO27 = 0x8000000
	// Corresponding bit in PDORn does not change.
	GPIO_PCOR_PTCO27_0 = 0x0
	// Corresponding bit in PDORn is cleared to logic 0.
	GPIO_PCOR_PTCO27_1 = 0x1
	// Position of PTCO28 field.
	GPIO_PCOR_PTCO28_Pos = 0x1c
	// Bit mask of PTCO28 field.
	GPIO_PCOR_PTCO28_Msk = 0x10000000
	// Bit PTCO28.
	GPIO_PCOR_PTCO28 = 0x10000000
	// Corresponding bit in PDORn does not change.
	GPIO_PCOR_PTCO28_0 = 0x0
	// Corresponding bit in PDORn is cleared to logic 0.
	GPIO_PCOR_PTCO28_1 = 0x1
	// Position of PTCO29 field.
	GPIO_PCOR_PTCO29_Pos = 0x1d
	// Bit mask of PTCO29 field.
	GPIO_PCOR_PTCO29_Msk = 0x20000000
	// Bit PTCO29.
	GPIO_PCOR_PTCO29 = 0x20000000
	// Corresponding bit in PDORn does not change.
	GPIO_PCOR_PTCO29_0 = 0x0
	// Corresponding bit in PDORn is cleared to logic 0.
	GPIO_PCOR_PTCO29_1 = 0x1
	// Position of PTCO30 field.
	GPIO_PCOR_PTCO30_Pos = 0x1e
	// Bit mask of PTCO30 field.
	GPIO_PCOR_PTCO30_Msk = 0x40000000
	// Bit PTCO30.
	GPIO_PCOR_PTCO30 = 0x40000000
	// Corresponding bit in PDORn does not change.
	GPIO_PCOR_PTCO30_0 = 0x0
	// Corresponding bit in PDORn is cleared to logic 0.
	GPIO_PCOR_PTCO30_1 = 0x1
	// Position of PTCO31 field.
	GPIO_PCOR_PTCO31_Pos = 0x1f
	// Bit mask of PTCO31 field.
	GPIO_PCOR_PTCO31_Msk = 0x80000000
	// Bit PTCO31.
	GPIO_PCOR_PTCO31 = 0x80000000
	// Corresponding bit in PDORn does not change.
	GPIO_PCOR_PTCO31_0 = 0x0
	// Corresponding bit in PDORn is cleared to logic 0.
	GPIO_PCOR_PTCO31_1 = 0x1

	// PTOR: Port Toggle Output Register
	// Position of PTTO0 field.
	GPIO_PTOR_PTTO0_Pos = 0x0
	// Bit mask of PTTO0 field.
	GPIO_PTOR_PTTO0_Msk = 0x1
	// Bit PTTO0.
	GPIO_PTOR_PTTO0 = 0x1
	// Corresponding bit in PDORn does not change.
	GPIO_PTOR_PTTO0_0 = 0x0
	// Corresponding bit in PDORn is set to the inverse of its existing logic state.
	GPIO_PTOR_PTTO0_1 = 0x1
	// Position of PTTO1 field.
	GPIO_PTOR_PTTO1_Pos = 0x1
	// Bit mask of PTTO1 field.
	GPIO_PTOR_PTTO1_Msk = 0x2
	// Bit PTTO1.
	GPIO_PTOR_PTTO1 = 0x2
	// Corresponding bit in PDORn does not change.
	GPIO_PTOR_PTTO1_0 = 0x0
	// Corresponding bit in PDORn is set to the inverse of its existing logic state.
	GPIO_PTOR_PTTO1_1 = 0x1
	// Position of PTTO2 field.
	GPIO_PTOR_PTTO2_Pos = 0x2
	// Bit mask of PTTO2 field.
	GPIO_PTOR_PTTO2_Msk = 0x4
	// Bit PTTO2.
	GPIO_PTOR_PTTO2 = 0x4
	// Corresponding bit in PDORn does not change.
	GPIO_PTOR_PTTO2_0 = 0x0
	// Corresponding bit in PDORn is set to the inverse of its existing logic state.
	GPIO_PTOR_PTTO2_1 = 0x1
	// Position of PTTO3 field.
	GPIO_PTOR_PTTO3_Pos = 0x3
	// Bit mask of PTTO3 field.
	GPIO_PTOR_PTTO3_Msk = 0x8
	// Bit PTTO3.
	GPIO_PTOR_PTTO3 = 0x8
	// Corresponding bit in PDORn does not change.
	GPIO_PTOR_PTTO3_0 = 0x0
	// Corresponding bit in PDORn is set to the inverse of its existing logic state.
	GPIO_PTOR_PTTO3_1 = 0x1
	// Position of PTTO4 field.
	GPIO_PTOR_PTTO4_Pos = 0x4
	// Bit mask of PTTO4 field.
	GPIO_PTOR_PTTO4_Msk = 0x10
	// Bit PTTO4.
	GPIO_PTOR_PTTO4 = 0x10
	// Corresponding bit in PDORn does not change.
	GPIO_PTOR_PTTO4_0 = 0x0
	// Corresponding bit in PDORn is set to the inverse of its existing logic state.
	GPIO_PTOR_PTTO4_1 = 0x1
	// Position of PTTO5 field.
	GPIO_PTOR_PTTO5_Pos = 0x5
	// Bit mask of PTTO5 field.
	GPIO_PTOR_PTTO5_Msk = 0x20
	// Bit PTTO5.
	GPIO_PTOR_PTTO5 = 0x20
	// Corresponding bit in PDORn does not change.
	GPIO_PTOR_PTTO5_0 = 0x0
	// Corresponding bit in PDORn is set to the inverse of its existing logic state.
	GPIO_PTOR_PTTO5_1 = 0x1
	// Position of PTTO6 field.
	GPIO_PTOR_PTTO6_Pos = 0x6
	// Bit mask of PTTO6 field.
	GPIO_PTOR_PTTO6_Msk = 0x40
	// Bit PTTO6.
	GPIO_PTOR_PTTO6 = 0x40
	// Corresponding bit in PDORn does not change.
	GPIO_PTOR_PTTO6_0 = 0x0
	// Corresponding bit in PDORn is set to the inverse of its existing logic state.
	GPIO_PTOR_PTTO6_1 = 0x1
	// Position of PTTO7 field.
	GPIO_PTOR_PTTO7_Pos = 0x7
	// Bit mask of PTTO7 field.
	GPIO_PTOR_PTTO7_Msk = 0x80
	// Bit PTTO7.
	GPIO_PTOR_PTTO7 = 0x80
	// Corresponding bit in PDORn does not change.
	GPIO_PTOR_PTTO7_0 = 0x0
	// Corresponding bit in PDORn is set to the inverse of its existing logic state.
	GPIO_PTOR_PTTO7_1 = 0x1
	// Position of PTTO8 field.
	GPIO_PTOR_PTTO8_Pos = 0x8
	// Bit mask of PTTO8 field.
	GPIO_PTOR_PTTO8_Msk = 0x100
	// Bit PTTO8.
	GPIO_PTOR_PTTO8 = 0x100
	// Corresponding bit in PDORn does not change.
	GPIO_PTOR_PTTO8_0 = 0x0
	// Corresponding bit in PDORn is set to the inverse of its existing logic state.
	GPIO_PTOR_PTTO8_1 = 0x1
	// Position of PTTO9 field.
	GPIO_PTOR_PTTO9_Pos = 0x9
	// Bit mask of PTTO9 field.
	GPIO_PTOR_PTTO9_Msk = 0x200
	// Bit PTTO9.
	GPIO_PTOR_PTTO9 = 0x200
	// Corresponding bit in PDORn does not change.
	GPIO_PTOR_PTTO9_0 = 0x0
	// Corresponding bit in PDORn is set to the inverse of its existing logic state.
	GPIO_PTOR_PTTO9_1 = 0x1
	// Position of PTTO10 field.
	GPIO_PTOR_PTTO10_Pos = 0xa
	// Bit mask of PTTO10 field.
	GPIO_PTOR_PTTO10_Msk = 0x400
	// Bit PTTO10.
	GPIO_PTOR_PTTO10 = 0x400
	// Corresponding bit in PDORn does not change.
	GPIO_PTOR_PTTO10_0 = 0x0
	// Corresponding bit in PDORn is set to the inverse of its existing logic state.
	GPIO_PTOR_PTTO10_1 = 0x1
	// Position of PTTO11 field.
	GPIO_PTOR_PTTO11_Pos = 0xb
	// Bit mask of PTTO11 field.
	GPIO_PTOR_PTTO11_Msk = 0x800
	// Bit PTTO11.
	GPIO_PTOR_PTTO11 = 0x800
	// Corresponding bit in PDORn does not change.
	GPIO_PTOR_PTTO11_0 = 0x0
	// Corresponding bit in PDORn is set to the inverse of its existing logic state.
	GPIO_PTOR_PTTO11_1 = 0x1
	// Position of PTTO12 field.
	GPIO_PTOR_PTTO12_Pos = 0xc
	// Bit mask of PTTO12 field.
	GPIO_PTOR_PTTO12_Msk = 0x1000
	// Bit PTTO12.
	GPIO_PTOR_PTTO12 = 0x1000
	// Corresponding bit in PDORn does not change.
	GPIO_PTOR_PTTO12_0 = 0x0
	// Corresponding bit in PDORn is set to the inverse of its existing logic state.
	GPIO_PTOR_PTTO12_1 = 0x1
	// Position of PTTO13 field.
	GPIO_PTOR_PTTO13_Pos = 0xd
	// Bit mask of PTTO13 field.
	GPIO_PTOR_PTTO13_Msk = 0x2000
	// Bit PTTO13.
	GPIO_PTOR_PTTO13 = 0x2000
	// Corresponding bit in PDORn does not change.
	GPIO_PTOR_PTTO13_0 = 0x0
	// Corresponding bit in PDORn is set to the inverse of its existing logic state.
	GPIO_PTOR_PTTO13_1 = 0x1
	// Position of PTTO14 field.
	GPIO_PTOR_PTTO14_Pos = 0xe
	// Bit mask of PTTO14 field.
	GPIO_PTOR_PTTO14_Msk = 0x4000
	// Bit PTTO14.
	GPIO_PTOR_PTTO14 = 0x4000
	// Corresponding bit in PDORn does not change.
	GPIO_PTOR_PTTO14_0 = 0x0
	// Corresponding bit in PDORn is set to the inverse of its existing logic state.
	GPIO_PTOR_PTTO14_1 = 0x1
	// Position of PTTO15 field.
	GPIO_PTOR_PTTO15_Pos = 0xf
	// Bit mask of PTTO15 field.
	GPIO_PTOR_PTTO15_Msk = 0x8000
	// Bit PTTO15.
	GPIO_PTOR_PTTO15 = 0x8000
	// Corresponding bit in PDORn does not change.
	GPIO_PTOR_PTTO15_0 = 0x0
	// Corresponding bit in PDORn is set to the inverse of its existing logic state.
	GPIO_PTOR_PTTO15_1 = 0x1
	// Position of PTTO16 field.
	GPIO_PTOR_PTTO16_Pos = 0x10
	// Bit mask of PTTO16 field.
	GPIO_PTOR_PTTO16_Msk = 0x10000
	// Bit PTTO16.
	GPIO_PTOR_PTTO16 = 0x10000
	// Corresponding bit in PDORn does not change.
	GPIO_PTOR_PTTO16_0 = 0x0
	// Corresponding bit in PDORn is set to the inverse of its existing logic state.
	GPIO_PTOR_PTTO16_1 = 0x1
	// Position of PTTO17 field.
	GPIO_PTOR_PTTO17_Pos = 0x11
	// Bit mask of PTTO17 field.
	GPIO_PTOR_PTTO17_Msk = 0x20000
	// Bit PTTO17.
	GPIO_PTOR_PTTO17 = 0x20000
	// Corresponding bit in PDORn does not change.
	GPIO_PTOR_PTTO17_0 = 0x0
	// Corresponding bit in PDORn is set to the inverse of its existing logic state.
	GPIO_PTOR_PTTO17_1 = 0x1
	// Position of PTTO18 field.
	GPIO_PTOR_PTTO18_Pos = 0x12
	// Bit mask of PTTO18 field.
	GPIO_PTOR_PTTO18_Msk = 0x40000
	// Bit PTTO18.
	GPIO_PTOR_PTTO18 = 0x40000
	// Corresponding bit in PDORn does not change.
	GPIO_PTOR_PTTO18_0 = 0x0
	// Corresponding bit in PDORn is set to the inverse of its existing logic state.
	GPIO_PTOR_PTTO18_1 = 0x1
	// Position of PTTO19 field.
	GPIO_PTOR_PTTO19_Pos = 0x13
	// Bit mask of PTTO19 field.
	GPIO_PTOR_PTTO19_Msk = 0x80000
	// Bit PTTO19.
	GPIO_PTOR_PTTO19 = 0x80000
	// Corresponding bit in PDORn does not change.
	GPIO_PTOR_PTTO19_0 = 0x0
	// Corresponding bit in PDORn is set to the inverse of its existing logic state.
	GPIO_PTOR_PTTO19_1 = 0x1
	// Position of PTTO20 field.
	GPIO_PTOR_PTTO20_Pos = 0x14
	// Bit mask of PTTO20 field.
	GPIO_PTOR_PTTO20_Msk = 0x100000
	// Bit PTTO20.
	GPIO_PTOR_PTTO20 = 0x100000
	// Corresponding bit in PDORn does not change.
	GPIO_PTOR_PTTO20_0 = 0x0
	// Corresponding bit in PDORn is set to the inverse of its existing logic state.
	GPIO_PTOR_PTTO20_1 = 0x1
	// Position of PTTO21 field.
	GPIO_PTOR_PTTO21_Pos = 0x15
	// Bit mask of PTTO21 field.
	GPIO_PTOR_PTTO21_Msk = 0x200000
	// Bit PTTO21.
	GPIO_PTOR_PTTO21 = 0x200000
	// Corresponding bit in PDORn does not change.
	GPIO_PTOR_PTTO21_0 = 0x0
	// Corresponding bit in PDORn is set to the inverse of its existing logic state.
	GPIO_PTOR_PTTO21_1 = 0x1
	// Position of PTTO22 field.
	GPIO_PTOR_PTTO22_Pos = 0x16
	// Bit mask of PTTO22 field.
	GPIO_PTOR_PTTO22_Msk = 0x400000
	// Bit PTTO22.
	GPIO_PTOR_PTTO22 = 0x400000
	// Corresponding bit in PDORn does not change.
	GPIO_PTOR_PTTO22_0 = 0x0
	// Corresponding bit in PDORn is set to the inverse of its existing logic state.
	GPIO_PTOR_PTTO22_1 = 0x1
	// Position of PTTO23 field.
	GPIO_PTOR_PTTO23_Pos = 0x17
	// Bit mask of PTTO23 field.
	GPIO_PTOR_PTTO23_Msk = 0x800000
	// Bit PTTO23.
	GPIO_PTOR_PTTO23 = 0x800000
	// Corresponding bit in PDORn does not change.
	GPIO_PTOR_PTTO23_0 = 0x0
	// Corresponding bit in PDORn is set to the inverse of its existing logic state.
	GPIO_PTOR_PTTO23_1 = 0x1
	// Position of PTTO24 field.
	GPIO_PTOR_PTTO24_Pos = 0x18
	// Bit mask of PTTO24 field.
	GPIO_PTOR_PTTO24_Msk = 0x1000000
	// Bit PTTO24.
	GPIO_PTOR_PTTO24 = 0x1000000
	// Corresponding bit in PDORn does not change.
	GPIO_PTOR_PTTO24_0 = 0x0
	// Corresponding bit in PDORn is set to the inverse of its existing logic state.
	GPIO_PTOR_PTTO24_1 = 0x1
	// Position of PTTO25 field.
	GPIO_PTOR_PTTO25_Pos = 0x19
	// Bit mask of PTTO25 field.
	GPIO_PTOR_PTTO25_Msk = 0x2000000
	// Bit PTTO25.
	GPIO_PTOR_PTTO25 = 0x2000000
	// Corresponding bit in PDORn does not change.
	GPIO_PTOR_PTTO25_0 = 0x0
	// Corresponding bit in PDORn is set to the inverse of its existing logic state.
	GPIO_PTOR_PTTO25_1 = 0x1
	// Position of PTTO26 field.
	GPIO_PTOR_PTTO26_Pos = 0x1a
	// Bit mask of PTTO26 field.
	GPIO_PTOR_PTTO26_Msk = 0x4000000
	// Bit PTTO26.
	GPIO_PTOR_PTTO26 = 0x4000000
	// Corresponding bit in PDORn does not change.
	GPIO_PTOR_PTTO26_0 = 0x0
	// Corresponding bit in PDORn is set to the inverse of its existing logic state.
	GPIO_PTOR_PTTO26_1 = 0x1
	// Position of PTTO27 field.
	GPIO_PTOR_PTTO27_Pos = 0x1b
	// Bit mask of PTTO27 field.
	GPIO_PTOR_PTTO27_Msk = 0x8000000
	// Bit PTTO27.
	GPIO_PTOR_PTTO27 = 0x8000000
	// Corresponding bit in PDORn does not change.
	GPIO_PTOR_PTTO27_0 = 0x0
	// Corresponding bit in PDORn is set to the inverse of its existing logic state.
	GPIO_PTOR_PTTO27_1 = 0x1
	// Position of PTTO28 field.
	GPIO_PTOR_PTTO28_Pos = 0x1c
	// Bit mask of PTTO28 field.
	GPIO_PTOR_PTTO28_Msk = 0x10000000
	// Bit PTTO28.
	GPIO_PTOR_PTTO28 = 0x10000000
	// Corresponding bit in PDORn does not change.
	GPIO_PTOR_PTTO28_0 = 0x0
	// Corresponding bit in PDORn is set to the inverse of its existing logic state.
	GPIO_PTOR_PTTO28_1 = 0x1
	// Position of PTTO29 field.
	GPIO_PTOR_PTTO29_Pos = 0x1d
	// Bit mask of PTTO29 field.
	GPIO_PTOR_PTTO29_Msk = 0x20000000
	// Bit PTTO29.
	GPIO_PTOR_PTTO29 = 0x20000000
	// Corresponding bit in PDORn does not change.
	GPIO_PTOR_PTTO29_0 = 0x0
	// Corresponding bit in PDORn is set to the inverse of its existing logic state.
	GPIO_PTOR_PTTO29_1 = 0x1
	// Position of PTTO30 field.
	GPIO_PTOR_PTTO30_Pos = 0x1e
	// Bit mask of PTTO30 field.
	GPIO_PTOR_PTTO30_Msk = 0x40000000
	// Bit PTTO30.
	GPIO_PTOR_PTTO30 = 0x40000000
	// Corresponding bit in PDORn does not change.
	GPIO_PTOR_PTTO30_0 = 0x0
	// Corresponding bit in PDORn is set to the inverse of its existing logic state.
	GPIO_PTOR_PTTO30_1 = 0x1
	// Position of PTTO31 field.
	GPIO_PTOR_PTTO31_Pos = 0x1f
	// Bit mask of PTTO31 field.
	GPIO_PTOR_PTTO31_Msk = 0x80000000
	// Bit PTTO31.
	GPIO_PTOR_PTTO31 = 0x80000000
	// Corresponding bit in PDORn does not change.
	GPIO_PTOR_PTTO31_0 = 0x0
	// Corresponding bit in PDORn is set to the inverse of its existing logic state.
	GPIO_PTOR_PTTO31_1 = 0x1

	// PDIR: Port Data Input Register
	// Position of PDI0 field.
	GPIO_PDIR_PDI0_Pos = 0x0
	// Bit mask of PDI0 field.
	GPIO_PDIR_PDI0_Msk = 0x1
	// Bit PDI0.
	GPIO_PDIR_PDI0 = 0x1
	// Pin logic level is logic 0, or is not configured for use by digital function.
	GPIO_PDIR_PDI0_0 = 0x0
	// Pin logic level is logic 1.
	GPIO_PDIR_PDI0_1 = 0x1
	// Position of PDI1 field.
	GPIO_PDIR_PDI1_Pos = 0x1
	// Bit mask of PDI1 field.
	GPIO_PDIR_PDI1_Msk = 0x2
	// Bit PDI1.
	GPIO_PDIR_PDI1 = 0x2
	// Pin logic level is logic 0, or is not configured for use by digital function.
	GPIO_PDIR_PDI1_0 = 0x0
	// Pin logic level is logic 1.
	GPIO_PDIR_PDI1_1 = 0x1
	// Position of PDI2 field.
	GPIO_PDIR_PDI2_Pos = 0x2
	// Bit mask of PDI2 field.
	GPIO_PDIR_PDI2_Msk = 0x4
	// Bit PDI2.
	GPIO_PDIR_PDI2 = 0x4
	// Pin logic level is logic 0, or is not configured for use by digital function.
	GPIO_PDIR_PDI2_0 = 0x0
	// Pin logic level is logic 1.
	GPIO_PDIR_PDI2_1 = 0x1
	// Position of PDI3 field.
	GPIO_PDIR_PDI3_Pos = 0x3
	// Bit mask of PDI3 field.
	GPIO_PDIR_PDI3_Msk = 0x8
	// Bit PDI3.
	GPIO_PDIR_PDI3 = 0x8
	// Pin logic level is logic 0, or is not configured for use by digital function.
	GPIO_PDIR_PDI3_0 = 0x0
	// Pin logic level is logic 1.
	GPIO_PDIR_PDI3_1 = 0x1
	// Position of PDI4 field.
	GPIO_PDIR_PDI4_Pos = 0x4
	// Bit mask of PDI4 field.
	GPIO_PDIR_PDI4_Msk = 0x10
	// Bit PDI4.
	GPIO_PDIR_PDI4 = 0x10
	// Pin logic level is logic 0, or is not configured for use by digital function.
	GPIO_PDIR_PDI4_0 = 0x0
	// Pin logic level is logic 1.
	GPIO_PDIR_PDI4_1 = 0x1
	// Position of PDI5 field.
	GPIO_PDIR_PDI5_Pos = 0x5
	// Bit mask of PDI5 field.
	GPIO_PDIR_PDI5_Msk = 0x20
	// Bit PDI5.
	GPIO_PDIR_PDI5 = 0x20
	// Pin logic level is logic 0, or is not configured for use by digital function.
	GPIO_PDIR_PDI5_0 = 0x0
	// Pin logic level is logic 1.
	GPIO_PDIR_PDI5_1 = 0x1
	// Position of PDI6 field.
	GPIO_PDIR_PDI6_Pos = 0x6
	// Bit mask of PDI6 field.
	GPIO_PDIR_PDI6_Msk = 0x40
	// Bit PDI6.
	GPIO_PDIR_PDI6 = 0x40
	// Pin logic level is logic 0, or is not configured for use by digital function.
	GPIO_PDIR_PDI6_0 = 0x0
	// Pin logic level is logic 1.
	GPIO_PDIR_PDI6_1 = 0x1
	// Position of PDI7 field.
	GPIO_PDIR_PDI7_Pos = 0x7
	// Bit mask of PDI7 field.
	GPIO_PDIR_PDI7_Msk = 0x80
	// Bit PDI7.
	GPIO_PDIR_PDI7 = 0x80
	// Pin logic level is logic 0, or is not configured for use by digital function.
	GPIO_PDIR_PDI7_0 = 0x0
	// Pin logic level is logic 1.
	GPIO_PDIR_PDI7_1 = 0x1
	// Position of PDI8 field.
	GPIO_PDIR_PDI8_Pos = 0x8
	// Bit mask of PDI8 field.
	GPIO_PDIR_PDI8_Msk = 0x100
	// Bit PDI8.
	GPIO_PDIR_PDI8 = 0x100
	// Pin logic level is logic 0, or is not configured for use by digital function.
	GPIO_PDIR_PDI8_0 = 0x0
	// Pin logic level is logic 1.
	GPIO_PDIR_PDI8_1 = 0x1
	// Position of PDI9 field.
	GPIO_PDIR_PDI9_Pos = 0x9
	// Bit mask of PDI9 field.
	GPIO_PDIR_PDI9_Msk = 0x200
	// Bit PDI9.
	GPIO_PDIR_PDI9 = 0x200
	// Pin logic level is logic 0, or is not configured for use by digital function.
	GPIO_PDIR_PDI9_0 = 0x0
	// Pin logic level is logic 1.
	GPIO_PDIR_PDI9_1 = 0x1
	// Position of PDI10 field.
	GPIO_PDIR_PDI10_Pos = 0xa
	// Bit mask of PDI10 field.
	GPIO_PDIR_PDI10_Msk = 0x400
	// Bit PDI10.
	GPIO_PDIR_PDI10 = 0x400
	// Pin logic level is logic 0, or is not configured for use by digital function.
	GPIO_PDIR_PDI10_0 = 0x0
	// Pin logic level is logic 1.
	GPIO_PDIR_PDI10_1 = 0x1
	// Position of PDI11 field.
	GPIO_PDIR_PDI11_Pos = 0xb
	// Bit mask of PDI11 field.
	GPIO_PDIR_PDI11_Msk = 0x800
	// Bit PDI11.
	GPIO_PDIR_PDI11 = 0x800
	// Pin logic level is logic 0, or is not configured for use by digital function.
	GPIO_PDIR_PDI11_0 = 0x0
	// Pin logic level is logic 1.
	GPIO_PDIR_PDI11_1 = 0x1
	// Position of PDI12 field.
	GPIO_PDIR_PDI12_Pos = 0xc
	// Bit mask of PDI12 field.
	GPIO_PDIR_PDI12_Msk = 0x1000
	// Bit PDI12.
	GPIO_PDIR_PDI12 = 0x1000
	// Pin logic level is logic 0, or is not configured for use by digital function.
	GPIO_PDIR_PDI12_0 = 0x0
	// Pin logic level is logic 1.
	GPIO_PDIR_PDI12_1 = 0x1
	// Position of PDI13 field.
	GPIO_PDIR_PDI13_Pos = 0xd
	// Bit mask of PDI13 field.
	GPIO_PDIR_PDI13_Msk = 0x2000
	// Bit PDI13.
	GPIO_PDIR_PDI13 = 0x2000
	// Pin logic level is logic 0, or is not configured for use by digital function.
	GPIO_PDIR_PDI13_0 = 0x0
	// Pin logic level is logic 1.
	GPIO_PDIR_PDI13_1 = 0x1
	// Position of PDI14 field.
	GPIO_PDIR_PDI14_Pos = 0xe
	// Bit mask of PDI14 field.
	GPIO_PDIR_PDI14_Msk = 0x4000
	// Bit PDI14.
	GPIO_PDIR_PDI14 = 0x4000
	// Pin logic level is logic 0, or is not configured for use by digital function.
	GPIO_PDIR_PDI14_0 = 0x0
	// Pin logic level is logic 1.
	GPIO_PDIR_PDI14_1 = 0x1
	// Position of PDI15 field.
	GPIO_PDIR_PDI15_Pos = 0xf
	// Bit mask of PDI15 field.
	GPIO_PDIR_PDI15_Msk = 0x8000
	// Bit PDI15.
	GPIO_PDIR_PDI15 = 0x8000
	// Pin logic level is logic 0, or is not configured for use by digital function.
	GPIO_PDIR_PDI15_0 = 0x0
	// Pin logic level is logic 1.
	GPIO_PDIR_PDI15_1 = 0x1
	// Position of PDI16 field.
	GPIO_PDIR_PDI16_Pos = 0x10
	// Bit mask of PDI16 field.
	GPIO_PDIR_PDI16_Msk = 0x10000
	// Bit PDI16.
	GPIO_PDIR_PDI16 = 0x10000
	// Pin logic level is logic 0, or is not configured for use by digital function.
	GPIO_PDIR_PDI16_0 = 0x0
	// Pin logic level is logic 1.
	GPIO_PDIR_PDI16_1 = 0x1
	// Position of PDI17 field.
	GPIO_PDIR_PDI17_Pos = 0x11
	// Bit mask of PDI17 field.
	GPIO_PDIR_PDI17_Msk = 0x20000
	// Bit PDI17.
	GPIO_PDIR_PDI17 = 0x20000
	// Pin logic level is logic 0, or is not configured for use by digital function.
	GPIO_PDIR_PDI17_0 = 0x0
	// Pin logic level is logic 1.
	GPIO_PDIR_PDI17_1 = 0x1
	// Position of PDI18 field.
	GPIO_PDIR_PDI18_Pos = 0x12
	// Bit mask of PDI18 field.
	GPIO_PDIR_PDI18_Msk = 0x40000
	// Bit PDI18.
	GPIO_PDIR_PDI18 = 0x40000
	// Pin logic level is logic 0, or is not configured for use by digital function.
	GPIO_PDIR_PDI18_0 = 0x0
	// Pin logic level is logic 1.
	GPIO_PDIR_PDI18_1 = 0x1
	// Position of PDI19 field.
	GPIO_PDIR_PDI19_Pos = 0x13
	// Bit mask of PDI19 field.
	GPIO_PDIR_PDI19_Msk = 0x80000
	// Bit PDI19.
	GPIO_PDIR_PDI19 = 0x80000
	// Pin logic level is logic 0, or is not configured for use by digital function.
	GPIO_PDIR_PDI19_0 = 0x0
	// Pin logic level is logic 1.
	GPIO_PDIR_PDI19_1 = 0x1
	// Position of PDI20 field.
	GPIO_PDIR_PDI20_Pos = 0x14
	// Bit mask of PDI20 field.
	GPIO_PDIR_PDI20_Msk = 0x100000
	// Bit PDI20.
	GPIO_PDIR_PDI20 = 0x100000
	// Pin logic level is logic 0, or is not configured for use by digital function.
	GPIO_PDIR_PDI20_0 = 0x0
	// Pin logic level is logic 1.
	GPIO_PDIR_PDI20_1 = 0x1
	// Position of PDI21 field.
	GPIO_PDIR_PDI21_Pos = 0x15
	// Bit mask of PDI21 field.
	GPIO_PDIR_PDI21_Msk = 0x200000
	// Bit PDI21.
	GPIO_PDIR_PDI21 = 0x200000
	// Pin logic level is logic 0, or is not configured for use by digital function.
	GPIO_PDIR_PDI21_0 = 0x0
	// Pin logic level is logic 1.
	GPIO_PDIR_PDI21_1 = 0x1
	// Position of PDI22 field.
	GPIO_PDIR_PDI22_Pos = 0x16
	// Bit mask of PDI22 field.
	GPIO_PDIR_PDI22_Msk = 0x400000
	// Bit PDI22.
	GPIO_PDIR_PDI22 = 0x400000
	// Pin logic level is logic 0, or is not configured for use by digital function.
	GPIO_PDIR_PDI22_0 = 0x0
	// Pin logic level is logic 1.
	GPIO_PDIR_PDI22_1 = 0x1
	// Position of PDI23 field.
	GPIO_PDIR_PDI23_Pos = 0x17
	// Bit mask of PDI23 field.
	GPIO_PDIR_PDI23_Msk = 0x800000
	// Bit PDI23.
	GPIO_PDIR_PDI23 = 0x800000
	// Pin logic level is logic 0, or is not configured for use by digital function.
	GPIO_PDIR_PDI23_0 = 0x0
	// Pin logic level is logic 1.
	GPIO_PDIR_PDI23_1 = 0x1
	// Position of PDI24 field.
	GPIO_PDIR_PDI24_Pos = 0x18
	// Bit mask of PDI24 field.
	GPIO_PDIR_PDI24_Msk = 0x1000000
	// Bit PDI24.
	GPIO_PDIR_PDI24 = 0x1000000
	// Pin logic level is logic 0, or is not configured for use by digital function.
	GPIO_PDIR_PDI24_0 = 0x0
	// Pin logic level is logic 1.
	GPIO_PDIR_PDI24_1 = 0x1
	// Position of PDI25 field.
	GPIO_PDIR_PDI25_Pos = 0x19
	// Bit mask of PDI25 field.
	GPIO_PDIR_PDI25_Msk = 0x2000000
	// Bit PDI25.
	GPIO_PDIR_PDI25 = 0x2000000
	// Pin logic level is logic 0, or is not configured for use by digital function.
	GPIO_PDIR_PDI25_0 = 0x0
	// Pin logic level is logic 1.
	GPIO_PDIR_PDI25_1 = 0x1
	// Position of PDI26 field.
	GPIO_PDIR_PDI26_Pos = 0x1a
	// Bit mask of PDI26 field.
	GPIO_PDIR_PDI26_Msk = 0x4000000
	// Bit PDI26.
	GPIO_PDIR_PDI26 = 0x4000000
	// Pin logic level is logic 0, or is not configured for use by digital function.
	GPIO_PDIR_PDI26_0 = 0x0
	// Pin logic level is logic 1.
	GPIO_PDIR_PDI26_1 = 0x1
	// Position of PDI27 field.
	GPIO_PDIR_PDI27_Pos = 0x1b
	// Bit mask of PDI27 field.
	GPIO_PDIR_PDI27_Msk = 0x8000000
	// Bit PDI27.
	GPIO_PDIR_PDI27 = 0x8000000
	// Pin logic level is logic 0, or is not configured for use by digital function.
	GPIO_PDIR_PDI27_0 = 0x0
	// Pin logic level is logic 1.
	GPIO_PDIR_PDI27_1 = 0x1
	// Position of PDI28 field.
	GPIO_PDIR_PDI28_Pos = 0x1c
	// Bit mask of PDI28 field.
	GPIO_PDIR_PDI28_Msk = 0x10000000
	// Bit PDI28.
	GPIO_PDIR_PDI28 = 0x10000000
	// Pin logic level is logic 0, or is not configured for use by digital function.
	GPIO_PDIR_PDI28_0 = 0x0
	// Pin logic level is logic 1.
	GPIO_PDIR_PDI28_1 = 0x1
	// Position of PDI29 field.
	GPIO_PDIR_PDI29_Pos = 0x1d
	// Bit mask of PDI29 field.
	GPIO_PDIR_PDI29_Msk = 0x20000000
	// Bit PDI29.
	GPIO_PDIR_PDI29 = 0x20000000
	// Pin logic level is logic 0, or is not configured for use by digital function.
	GPIO_PDIR_PDI29_0 = 0x0
	// Pin logic level is logic 1.
	GPIO_PDIR_PDI29_1 = 0x1
	// Position of PDI30 field.
	GPIO_PDIR_PDI30_Pos = 0x1e
	// Bit mask of PDI30 field.
	GPIO_PDIR_PDI30_Msk = 0x40000000
	// Bit PDI30.
	GPIO_PDIR_PDI30 = 0x40000000
	// Pin logic level is logic 0, or is not configured for use by digital function.
	GPIO_PDIR_PDI30_0 = 0x0
	// Pin logic level is logic 1.
	GPIO_PDIR_PDI30_1 = 0x1
	// Position of PDI31 field.
	GPIO_PDIR_PDI31_Pos = 0x1f
	// Bit mask of PDI31 field.
	GPIO_PDIR_PDI31_Msk = 0x80000000
	// Bit PDI31.
	GPIO_PDIR_PDI31 = 0x80000000
	// Pin logic level is logic 0, or is not configured for use by digital function.
	GPIO_PDIR_PDI31_0 = 0x0
	// Pin logic level is logic 1.
	GPIO_PDIR_PDI31_1 = 0x1

	// PDDR: Port Data Direction Register
	// Position of PDD0 field.
	GPIO_PDDR_PDD0_Pos = 0x0
	// Bit mask of PDD0 field.
	GPIO_PDDR_PDD0_Msk = 0x1
	// Bit PDD0.
	GPIO_PDDR_PDD0 = 0x1
	// Pin is configured as general-purpose input, for the GPIO function.
	GPIO_PDDR_PDD0_0 = 0x0
	// Pin is configured as general-purpose output, for the GPIO function.
	GPIO_PDDR_PDD0_1 = 0x1
	// Position of PDD1 field.
	GPIO_PDDR_PDD1_Pos = 0x1
	// Bit mask of PDD1 field.
	GPIO_PDDR_PDD1_Msk = 0x2
	// Bit PDD1.
	GPIO_PDDR_PDD1 = 0x2
	// Pin is configured as general-purpose input, for the GPIO function.
	GPIO_PDDR_PDD1_0 = 0x0
	// Pin is configured as general-purpose output, for the GPIO function.
	GPIO_PDDR_PDD1_1 = 0x1
	// Position of PDD2 field.
	GPIO_PDDR_PDD2_Pos = 0x2
	// Bit mask of PDD2 field.
	GPIO_PDDR_PDD2_Msk = 0x4
	// Bit PDD2.
	GPIO_PDDR_PDD2 = 0x4
	// Pin is configured as general-purpose input, for the GPIO function.
	GPIO_PDDR_PDD2_0 = 0x0
	// Pin is configured as general-purpose output, for the GPIO function.
	GPIO_PDDR_PDD2_1 = 0x1
	// Position of PDD3 field.
	GPIO_PDDR_PDD3_Pos = 0x3
	// Bit mask of PDD3 field.
	GPIO_PDDR_PDD3_Msk = 0x8
	// Bit PDD3.
	GPIO_PDDR_PDD3 = 0x8
	// Pin is configured as general-purpose input, for the GPIO function.
	GPIO_PDDR_PDD3_0 = 0x0
	// Pin is configured as general-purpose output, for the GPIO function.
	GPIO_PDDR_PDD3_1 = 0x1
	// Position of PDD4 field.
	GPIO_PDDR_PDD4_Pos = 0x4
	// Bit mask of PDD4 field.
	GPIO_PDDR_PDD4_Msk = 0x10
	// Bit PDD4.
	GPIO_PDDR_PDD4 = 0x10
	// Pin is configured as general-purpose input, for the GPIO function.
	GPIO_PDDR_PDD4_0 = 0x0
	// Pin is configured as general-purpose output, for the GPIO function.
	GPIO_PDDR_PDD4_1 = 0x1
	// Position of PDD5 field.
	GPIO_PDDR_PDD5_Pos = 0x5
	// Bit mask of PDD5 field.
	GPIO_PDDR_PDD5_Msk = 0x20
	// Bit PDD5.
	GPIO_PDDR_PDD5 = 0x20
	// Pin is configured as general-purpose input, for the GPIO function.
	GPIO_PDDR_PDD5_0 = 0x0
	// Pin is configured as general-purpose output, for the GPIO function.
	GPIO_PDDR_PDD5_1 = 0x1
	// Position of PDD6 field.
	GPIO_PDDR_PDD6_Pos = 0x6
	// Bit mask of PDD6 field.
	GPIO_PDDR_PDD6_Msk = 0x40
	// Bit PDD6.
	GPIO_PDDR_PDD6 = 0x40
	// Pin is configured as general-purpose input, for the GPIO function.
	GPIO_PDDR_PDD6_0 = 0x0
	// Pin is configured as general-purpose output, for the GPIO function.
	GPIO_PDDR_PDD6_1 = 0x1
	// Position of PDD7 field.
	GPIO_PDDR_PDD7_Pos = 0x7
	// Bit mask of PDD7 field.
	GPIO_PDDR_PDD7_Msk = 0x80
	// Bit PDD7.
	GPIO_PDDR_PDD7 = 0x80
	// Pin is configured as general-purpose input, for the GPIO function.
	GPIO_PDDR_PDD7_0 = 0x0
	// Pin is configured as general-purpose output, for the GPIO function.
	GPIO_PDDR_PDD7_1 = 0x1
	// Position of PDD8 field.
	GPIO_PDDR_PDD8_Pos = 0x8
	// Bit mask of PDD8 field.
	GPIO_PDDR_PDD8_Msk = 0x100
	// Bit PDD8.
	GPIO_PDDR_PDD8 = 0x100
	// Pin is configured as general-purpose input, for the GPIO function.
	GPIO_PDDR_PDD8_0 = 0x0
	// Pin is configured as general-purpose output, for the GPIO function.
	GPIO_PDDR_PDD8_1 = 0x1
	// Position of PDD9 field.
	GPIO_PDDR_PDD9_Pos = 0x9
	// Bit mask of PDD9 field.
	GPIO_PDDR_PDD9_Msk = 0x200
	// Bit PDD9.
	GPIO_PDDR_PDD9 = 0x200
	// Pin is configured as general-purpose input, for the GPIO function.
	GPIO_PDDR_PDD9_0 = 0x0
	// Pin is configured as general-purpose output, for the GPIO function.
	GPIO_PDDR_PDD9_1 = 0x1
	// Position of PDD10 field.
	GPIO_PDDR_PDD10_Pos = 0xa
	// Bit mask of PDD10 field.
	GPIO_PDDR_PDD10_Msk = 0x400
	// Bit PDD10.
	GPIO_PDDR_PDD10 = 0x400
	// Pin is configured as general-purpose input, for the GPIO function.
	GPIO_PDDR_PDD10_0 = 0x0
	// Pin is configured as general-purpose output, for the GPIO function.
	GPIO_PDDR_PDD10_1 = 0x1
	// Position of PDD11 field.
	GPIO_PDDR_PDD11_Pos = 0xb
	// Bit mask of PDD11 field.
	GPIO_PDDR_PDD11_Msk = 0x800
	// Bit PDD11.
	GPIO_PDDR_PDD11 = 0x800
	// Pin is configured as general-purpose input, for the GPIO function.
	GPIO_PDDR_PDD11_0 = 0x0
	// Pin is configured as general-purpose output, for the GPIO function.
	GPIO_PDDR_PDD11_1 = 0x1
	// Position of PDD12 field.
	GPIO_PDDR_PDD12_Pos = 0xc
	// Bit mask of PDD12 field.
	GPIO_PDDR_PDD12_Msk = 0x1000
	// Bit PDD12.
	GPIO_PDDR_PDD12 = 0x1000
	// Pin is configured as general-purpose input, for the GPIO function.
	GPIO_PDDR_PDD12_0 = 0x0
	// Pin is configured as general-purpose output, for the GPIO function.
	GPIO_PDDR_PDD12_1 = 0x1
	// Position of PDD13 field.
	GPIO_PDDR_PDD13_Pos = 0xd
	// Bit mask of PDD13 field.
	GPIO_PDDR_PDD13_Msk = 0x2000
	// Bit PDD13.
	GPIO_PDDR_PDD13 = 0x2000
	// Pin is configured as general-purpose input, for the GPIO function.
	GPIO_PDDR_PDD13_0 = 0x0
	// Pin is configured as general-purpose output, for the GPIO function.
	GPIO_PDDR_PDD13_1 = 0x1
	// Position of PDD14 field.
	GPIO_PDDR_PDD14_Pos = 0xe
	// Bit mask of PDD14 field.
	GPIO_PDDR_PDD14_Msk = 0x4000
	// Bit PDD14.
	GPIO_PDDR_PDD14 = 0x4000
	// Pin is configured as general-purpose input, for the GPIO function.
	GPIO_PDDR_PDD14_0 = 0x0
	// Pin is configured as general-purpose output, for the GPIO function.
	GPIO_PDDR_PDD14_1 = 0x1
	// Position of PDD15 field.
	GPIO_PDDR_PDD15_Pos = 0xf
	// Bit mask of PDD15 field.
	GPIO_PDDR_PDD15_Msk = 0x8000
	// Bit PDD15.
	GPIO_PDDR_PDD15 = 0x8000
	// Pin is configured as general-purpose input, for the GPIO function.
	GPIO_PDDR_PDD15_0 = 0x0
	// Pin is configured as general-purpose output, for the GPIO function.
	GPIO_PDDR_PDD15_1 = 0x1
	// Position of PDD16 field.
	GPIO_PDDR_PDD16_Pos = 0x10
	// Bit mask of PDD16 field.
	GPIO_PDDR_PDD16_Msk = 0x10000
	// Bit PDD16.
	GPIO_PDDR_PDD16 = 0x10000
	// Pin is configured as general-purpose input, for the GPIO function.
	GPIO_PDDR_PDD16_0 = 0x0
	// Pin is configured as general-purpose output, for the GPIO function.
	GPIO_PDDR_PDD16_1 = 0x1
	// Position of PDD17 field.
	GPIO_PDDR_PDD17_Pos = 0x11
	// Bit mask of PDD17 field.
	GPIO_PDDR_PDD17_Msk = 0x20000
	// Bit PDD17.
	GPIO_PDDR_PDD17 = 0x20000
	// Pin is configured as general-purpose input, for the GPIO function.
	GPIO_PDDR_PDD17_0 = 0x0
	// Pin is configured as general-purpose output, for the GPIO function.
	GPIO_PDDR_PDD17_1 = 0x1
	// Position of PDD18 field.
	GPIO_PDDR_PDD18_Pos = 0x12
	// Bit mask of PDD18 field.
	GPIO_PDDR_PDD18_Msk = 0x40000
	// Bit PDD18.
	GPIO_PDDR_PDD18 = 0x40000
	// Pin is configured as general-purpose input, for the GPIO function.
	GPIO_PDDR_PDD18_0 = 0x0
	// Pin is configured as general-purpose output, for the GPIO function.
	GPIO_PDDR_PDD18_1 = 0x1
	// Position of PDD19 field.
	GPIO_PDDR_PDD19_Pos = 0x13
	// Bit mask of PDD19 field.
	GPIO_PDDR_PDD19_Msk = 0x80000
	// Bit PDD19.
	GPIO_PDDR_PDD19 = 0x80000
	// Pin is configured as general-purpose input, for the GPIO function.
	GPIO_PDDR_PDD19_0 = 0x0
	// Pin is configured as general-purpose output, for the GPIO function.
	GPIO_PDDR_PDD19_1 = 0x1
	// Position of PDD20 field.
	GPIO_PDDR_PDD20_Pos = 0x14
	// Bit mask of PDD20 field.
	GPIO_PDDR_PDD20_Msk = 0x100000
	// Bit PDD20.
	GPIO_PDDR_PDD20 = 0x100000
	// Pin is configured as general-purpose input, for the GPIO function.
	GPIO_PDDR_PDD20_0 = 0x0
	// Pin is configured as general-purpose output, for the GPIO function.
	GPIO_PDDR_PDD20_1 = 0x1
	// Position of PDD21 field.
	GPIO_PDDR_PDD21_Pos = 0x15
	// Bit mask of PDD21 field.
	GPIO_PDDR_PDD21_Msk = 0x200000
	// Bit PDD21.
	GPIO_PDDR_PDD21 = 0x200000
	// Pin is configured as general-purpose input, for the GPIO function.
	GPIO_PDDR_PDD21_0 = 0x0
	// Pin is configured as general-purpose output, for the GPIO function.
	GPIO_PDDR_PDD21_1 = 0x1
	// Position of PDD22 field.
	GPIO_PDDR_PDD22_Pos = 0x16
	// Bit mask of PDD22 field.
	GPIO_PDDR_PDD22_Msk = 0x400000
	// Bit PDD22.
	GPIO_PDDR_PDD22 = 0x400000
	// Pin is configured as general-purpose input, for the GPIO function.
	GPIO_PDDR_PDD22_0 = 0x0
	// Pin is configured as general-purpose output, for the GPIO function.
	GPIO_PDDR_PDD22_1 = 0x1
	// Position of PDD23 field.
	GPIO_PDDR_PDD23_Pos = 0x17
	// Bit mask of PDD23 field.
	GPIO_PDDR_PDD23_Msk = 0x800000
	// Bit PDD23.
	GPIO_PDDR_PDD23 = 0x800000
	// Pin is configured as general-purpose input, for the GPIO function.
	GPIO_PDDR_PDD23_0 = 0x0
	// Pin is configured as general-purpose output, for the GPIO function.
	GPIO_PDDR_PDD23_1 = 0x1
	// Position of PDD24 field.
	GPIO_PDDR_PDD24_Pos = 0x18
	// Bit mask of PDD24 field.
	GPIO_PDDR_PDD24_Msk = 0x1000000
	// Bit PDD24.
	GPIO_PDDR_PDD24 = 0x1000000
	// Pin is configured as general-purpose input, for the GPIO function.
	GPIO_PDDR_PDD24_0 = 0x0
	// Pin is configured as general-purpose output, for the GPIO function.
	GPIO_PDDR_PDD24_1 = 0x1
	// Position of PDD25 field.
	GPIO_PDDR_PDD25_Pos = 0x19
	// Bit mask of PDD25 field.
	GPIO_PDDR_PDD25_Msk = 0x2000000
	// Bit PDD25.
	GPIO_PDDR_PDD25 = 0x2000000
	// Pin is configured as general-purpose input, for the GPIO function.
	GPIO_PDDR_PDD25_0 = 0x0
	// Pin is configured as general-purpose output, for the GPIO function.
	GPIO_PDDR_PDD25_1 = 0x1
	// Position of PDD26 field.
	GPIO_PDDR_PDD26_Pos = 0x1a
	// Bit mask of PDD26 field.
	GPIO_PDDR_PDD26_Msk = 0x4000000
	// Bit PDD26.
	GPIO_PDDR_PDD26 = 0x4000000
	// Pin is configured as general-purpose input, for the GPIO function.
	GPIO_PDDR_PDD26_0 = 0x0
	// Pin is configured as general-purpose output, for the GPIO function.
	GPIO_PDDR_PDD26_1 = 0x1
	// Position of PDD27 field.
	GPIO_PDDR_PDD27_Pos = 0x1b
	// Bit mask of PDD27 field.
	GPIO_PDDR_PDD27_Msk = 0x8000000
	// Bit PDD27.
	GPIO_PDDR_PDD27 = 0x8000000
	// Pin is configured as general-purpose input, for the GPIO function.
	GPIO_PDDR_PDD27_0 = 0x0
	// Pin is configured as general-purpose output, for the GPIO function.
	GPIO_PDDR_PDD27_1 = 0x1
	// Position of PDD28 field.
	GPIO_PDDR_PDD28_Pos = 0x1c
	// Bit mask of PDD28 field.
	GPIO_PDDR_PDD28_Msk = 0x10000000
	// Bit PDD28.
	GPIO_PDDR_PDD28 = 0x10000000
	// Pin is configured as general-purpose input, for the GPIO function.
	GPIO_PDDR_PDD28_0 = 0x0
	// Pin is configured as general-purpose output, for the GPIO function.
	GPIO_PDDR_PDD28_1 = 0x1
	// Position of PDD29 field.
	GPIO_PDDR_PDD29_Pos = 0x1d
	// Bit mask of PDD29 field.
	GPIO_PDDR_PDD29_Msk = 0x20000000
	// Bit PDD29.
	GPIO_PDDR_PDD29 = 0x20000000
	// Pin is configured as general-purpose input, for the GPIO function.
	GPIO_PDDR_PDD29_0 = 0x0
	// Pin is configured as general-purpose output, for the GPIO function.
	GPIO_PDDR_PDD29_1 = 0x1
	// Position of PDD30 field.
	GPIO_PDDR_PDD30_Pos = 0x1e
	// Bit mask of PDD30 field.
	GPIO_PDDR_PDD30_Msk = 0x40000000
	// Bit PDD30.
	GPIO_PDDR_PDD30 = 0x40000000
	// Pin is configured as general-purpose input, for the GPIO function.
	GPIO_PDDR_PDD30_0 = 0x0
	// Pin is configured as general-purpose output, for the GPIO function.
	GPIO_PDDR_PDD30_1 = 0x1
	// Position of PDD31 field.
	GPIO_PDDR_PDD31_Pos = 0x1f
	// Bit mask of PDD31 field.
	GPIO_PDDR_PDD31_Msk = 0x80000000
	// Bit PDD31.
	GPIO_PDDR_PDD31 = 0x80000000
	// Pin is configured as general-purpose input, for the GPIO function.
	GPIO_PDDR_PDD31_0 = 0x0
	// Pin is configured as general-purpose output, for the GPIO function.
	GPIO_PDDR_PDD31_1 = 0x1
)

// Constants for SystemControl: System Control Block
const (
	// ACTLR: Auxiliary Control Register,
	// Position of DISMCYCINT field.
	SystemControl_ACTLR_DISMCYCINT_Pos = 0x0
	// Bit mask of DISMCYCINT field.
	SystemControl_ACTLR_DISMCYCINT_Msk = 0x1
	// Bit DISMCYCINT.
	SystemControl_ACTLR_DISMCYCINT = 0x1
	// Position of DISDEFWBUF field.
	SystemControl_ACTLR_DISDEFWBUF_Pos = 0x1
	// Bit mask of DISDEFWBUF field.
	SystemControl_ACTLR_DISDEFWBUF_Msk = 0x2
	// Bit DISDEFWBUF.
	SystemControl_ACTLR_DISDEFWBUF = 0x2
	// Position of DISFOLD field.
	SystemControl_ACTLR_DISFOLD_Pos = 0x2
	// Bit mask of DISFOLD field.
	SystemControl_ACTLR_DISFOLD_Msk = 0x4
	// Bit DISFOLD.
	SystemControl_ACTLR_DISFOLD = 0x4

	// CPUID: CPUID Base Register
	// Position of REVISION field.
	SystemControl_CPUID_REVISION_Pos = 0x0
	// Bit mask of REVISION field.
	SystemControl_CPUID_REVISION_Msk = 0xf
	// Position of PARTNO field.
	SystemControl_CPUID_PARTNO_Pos = 0x4
	// Bit mask of PARTNO field.
	SystemControl_CPUID_PARTNO_Msk = 0xfff0
	// Position of VARIANT field.
	SystemControl_CPUID_VARIANT_Pos = 0x14
	// Bit mask of VARIANT field.
	SystemControl_CPUID_VARIANT_Msk = 0xf00000
	// Position of IMPLEMENTER field.
	SystemControl_CPUID_IMPLEMENTER_Pos = 0x18
	// Bit mask of IMPLEMENTER field.
	SystemControl_CPUID_IMPLEMENTER_Msk = 0xff000000

	// ICSR: Interrupt Control and State Register
	// Position of VECTACTIVE field.
	SystemControl_ICSR_VECTACTIVE_Pos = 0x0
	// Bit mask of VECTACTIVE field.
	SystemControl_ICSR_VECTACTIVE_Msk = 0x1ff
	// Position of RETTOBASE field.
	SystemControl_ICSR_RETTOBASE_Pos = 0xb
	// Bit mask of RETTOBASE field.
	SystemControl_ICSR_RETTOBASE_Msk = 0x800
	// Bit RETTOBASE.
	SystemControl_ICSR_RETTOBASE = 0x800
	// there are preempted active exceptions to execute
	SystemControl_ICSR_RETTOBASE_0 = 0x0
	// there are no active exceptions, or the currently-executing exception is the only active exception
	SystemControl_ICSR_RETTOBASE_1 = 0x1
	// Position of VECTPENDING field.
	SystemControl_ICSR_VECTPENDING_Pos = 0xc
	// Bit mask of VECTPENDING field.
	SystemControl_ICSR_VECTPENDING_Msk = 0x3f000
	// Position of ISRPENDING field.
	SystemControl_ICSR_ISRPENDING_Pos = 0x16
	// Bit mask of ISRPENDING field.
	SystemControl_ICSR_ISRPENDING_Msk = 0x400000
	// Bit ISRPENDING.
	SystemControl_ICSR_ISRPENDING = 0x400000
	// Position of ISRPREEMPT field.
	SystemControl_ICSR_ISRPREEMPT_Pos = 0x17
	// Bit mask of ISRPREEMPT field.
	SystemControl_ICSR_ISRPREEMPT_Msk = 0x800000
	// Bit ISRPREEMPT.
	SystemControl_ICSR_ISRPREEMPT = 0x800000
	// Will not service
	SystemControl_ICSR_ISRPREEMPT_0 = 0x0
	// Will service a pending exception
	SystemControl_ICSR_ISRPREEMPT_1 = 0x1
	// Position of PENDSTCLR field.
	SystemControl_ICSR_PENDSTCLR_Pos = 0x19
	// Bit mask of PENDSTCLR field.
	SystemControl_ICSR_PENDSTCLR_Msk = 0x2000000
	// Bit PENDSTCLR.
	SystemControl_ICSR_PENDSTCLR = 0x2000000
	// no effect
	SystemControl_ICSR_PENDSTCLR_0 = 0x0
	// removes the pending state from the SysTick exception
	SystemControl_ICSR_PENDSTCLR_1 = 0x1
	// Position of PENDSTSET field.
	SystemControl_ICSR_PENDSTSET_Pos = 0x1a
	// Bit mask of PENDSTSET field.
	SystemControl_ICSR_PENDSTSET_Msk = 0x4000000
	// Bit PENDSTSET.
	SystemControl_ICSR_PENDSTSET = 0x4000000
	// write: no effect; read: SysTick exception is not pending
	SystemControl_ICSR_PENDSTSET_0 = 0x0
	// write: changes SysTick exception state to pending; read: SysTick exception is pending
	SystemControl_ICSR_PENDSTSET_1 = 0x1
	// Position of PENDSVCLR field.
	SystemControl_ICSR_PENDSVCLR_Pos = 0x1b
	// Bit mask of PENDSVCLR field.
	SystemControl_ICSR_PENDSVCLR_Msk = 0x8000000
	// Bit PENDSVCLR.
	SystemControl_ICSR_PENDSVCLR = 0x8000000
	// no effect
	SystemControl_ICSR_PENDSVCLR_0 = 0x0
	// removes the pending state from the PendSV exception
	SystemControl_ICSR_PENDSVCLR_1 = 0x1
	// Position of PENDSVSET field.
	SystemControl_ICSR_PENDSVSET_Pos = 0x1c
	// Bit mask of PENDSVSET field.
	SystemControl_ICSR_PENDSVSET_Msk = 0x10000000
	// Bit PENDSVSET.
	SystemControl_ICSR_PENDSVSET = 0x10000000
	// write: no effect; read: PendSV exception is not pending
	SystemControl_ICSR_PENDSVSET_0 = 0x0
	// write: changes PendSV exception state to pending; read: PendSV exception is pending
	SystemControl_ICSR_PENDSVSET_1 = 0x1
	// Position of NMIPENDSET field.
	SystemControl_ICSR_NMIPENDSET_Pos = 0x1f
	// Bit mask of NMIPENDSET field.
	SystemControl_ICSR_NMIPENDSET_Msk = 0x80000000
	// Bit NMIPENDSET.
	SystemControl_ICSR_NMIPENDSET = 0x80000000
	// write: no effect; read: NMI exception is not pending
	SystemControl_ICSR_NMIPENDSET_0 = 0x0
	// write: changes NMI exception state to pending; read: NMI exception is pending
	SystemControl_ICSR_NMIPENDSET_1 = 0x1

	// VTOR: Vector Table Offset Register
	// Position of TBLOFF field.
	SystemControl_VTOR_TBLOFF_Pos = 0x7
	// Bit mask of TBLOFF field.
	SystemControl_VTOR_TBLOFF_Msk = 0xffffff80

	// AIRCR: Application Interrupt and Reset Control Register
	// Position of VECTRESET field.
	SystemControl_AIRCR_VECTRESET_Pos = 0x0
	// Bit mask of VECTRESET field.
	SystemControl_AIRCR_VECTRESET_Msk = 0x1
	// Bit VECTRESET.
	SystemControl_AIRCR_VECTRESET = 0x1
	// Position of VECTCLRACTIVE field.
	SystemControl_AIRCR_VECTCLRACTIVE_Pos = 0x1
	// Bit mask of VECTCLRACTIVE field.
	SystemControl_AIRCR_VECTCLRACTIVE_Msk = 0x2
	// Bit VECTCLRACTIVE.
	SystemControl_AIRCR_VECTCLRACTIVE = 0x2
	// Position of SYSRESETREQ field.
	SystemControl_AIRCR_SYSRESETREQ_Pos = 0x2
	// Bit mask of SYSRESETREQ field.
	SystemControl_AIRCR_SYSRESETREQ_Msk = 0x4
	// Bit SYSRESETREQ.
	SystemControl_AIRCR_SYSRESETREQ = 0x4
	// no system reset request
	SystemControl_AIRCR_SYSRESETREQ_0 = 0x0
	// asserts a signal to the outer system that requests a reset
	SystemControl_AIRCR_SYSRESETREQ_1 = 0x1
	// Position of PRIGROUP field.
	SystemControl_AIRCR_PRIGROUP_Pos = 0x8
	// Bit mask of PRIGROUP field.
	SystemControl_AIRCR_PRIGROUP_Msk = 0x700
	// Position of ENDIANNESS field.
	SystemControl_AIRCR_ENDIANNESS_Pos = 0xf
	// Bit mask of ENDIANNESS field.
	SystemControl_AIRCR_ENDIANNESS_Msk = 0x8000
	// Bit ENDIANNESS.
	SystemControl_AIRCR_ENDIANNESS = 0x8000
	// Little-endian
	SystemControl_AIRCR_ENDIANNESS_0 = 0x0
	// Big-endian
	SystemControl_AIRCR_ENDIANNESS_1 = 0x1
	// Position of VECTKEY field.
	SystemControl_AIRCR_VECTKEY_Pos = 0x10
	// Bit mask of VECTKEY field.
	SystemControl_AIRCR_VECTKEY_Msk = 0xffff0000

	// SCR: System Control Register
	// Position of SLEEPONEXIT field.
	SystemControl_SCR_SLEEPONEXIT_Pos = 0x1
	// Bit mask of SLEEPONEXIT field.
	SystemControl_SCR_SLEEPONEXIT_Msk = 0x2
	// Bit SLEEPONEXIT.
	SystemControl_SCR_SLEEPONEXIT = 0x2
	// o not sleep when returning to Thread mode
	SystemControl_SCR_SLEEPONEXIT_0 = 0x0
	// enter sleep, or deep sleep, on return from an ISR
	SystemControl_SCR_SLEEPONEXIT_1 = 0x1
	// Position of SLEEPDEEP field.
	SystemControl_SCR_SLEEPDEEP_Pos = 0x2
	// Bit mask of SLEEPDEEP field.
	SystemControl_SCR_SLEEPDEEP_Msk = 0x4
	// Bit SLEEPDEEP.
	SystemControl_SCR_SLEEPDEEP = 0x4
	// sleep
	SystemControl_SCR_SLEEPDEEP_0 = 0x0
	// deep sleep
	SystemControl_SCR_SLEEPDEEP_1 = 0x1
	// Position of SEVONPEND field.
	SystemControl_SCR_SEVONPEND_Pos = 0x4
	// Bit mask of SEVONPEND field.
	SystemControl_SCR_SEVONPEND_Msk = 0x10
	// Bit SEVONPEND.
	SystemControl_SCR_SEVONPEND = 0x10
	// only enabled interrupts or events can wakeup the processor, disabled interrupts are excluded
	SystemControl_SCR_SEVONPEND_0 = 0x0
	// enabled events and all interrupts, including disabled interrupts, can wakeup the processor
	SystemControl_SCR_SEVONPEND_1 = 0x1

	// CCR: Configuration and Control Register
	// Position of NONBASETHRDENA field.
	SystemControl_CCR_NONBASETHRDENA_Pos = 0x0
	// Bit mask of NONBASETHRDENA field.
	SystemControl_CCR_NONBASETHRDENA_Msk = 0x1
	// Bit NONBASETHRDENA.
	SystemControl_CCR_NONBASETHRDENA = 0x1
	// processor can enter Thread mode only when no exception is active
	SystemControl_CCR_NONBASETHRDENA_0 = 0x0
	// processor can enter Thread mode from any level under the control of an EXC_RETURN value
	SystemControl_CCR_NONBASETHRDENA_1 = 0x1
	// Position of USERSETMPEND field.
	SystemControl_CCR_USERSETMPEND_Pos = 0x1
	// Bit mask of USERSETMPEND field.
	SystemControl_CCR_USERSETMPEND_Msk = 0x2
	// Bit USERSETMPEND.
	SystemControl_CCR_USERSETMPEND = 0x2
	// disable
	SystemControl_CCR_USERSETMPEND_0 = 0x0
	// enable
	SystemControl_CCR_USERSETMPEND_1 = 0x1
	// Position of UNALIGN_TRP field.
	SystemControl_CCR_UNALIGN_TRP_Pos = 0x3
	// Bit mask of UNALIGN_TRP field.
	SystemControl_CCR_UNALIGN_TRP_Msk = 0x8
	// Bit UNALIGN_TRP.
	SystemControl_CCR_UNALIGN_TRP = 0x8
	// do not trap unaligned halfword and word accesses
	SystemControl_CCR_UNALIGN_TRP_0 = 0x0
	// trap unaligned halfword and word accesses
	SystemControl_CCR_UNALIGN_TRP_1 = 0x1
	// Position of DIV_0_TRP field.
	SystemControl_CCR_DIV_0_TRP_Pos = 0x4
	// Bit mask of DIV_0_TRP field.
	SystemControl_CCR_DIV_0_TRP_Msk = 0x10
	// Bit DIV_0_TRP.
	SystemControl_CCR_DIV_0_TRP = 0x10
	// do not trap divide by 0
	SystemControl_CCR_DIV_0_TRP_0 = 0x0
	// trap divide by 0
	SystemControl_CCR_DIV_0_TRP_1 = 0x1
	// Position of BFHFNMIGN field.
	SystemControl_CCR_BFHFNMIGN_Pos = 0x8
	// Bit mask of BFHFNMIGN field.
	SystemControl_CCR_BFHFNMIGN_Msk = 0x100
	// Bit BFHFNMIGN.
	SystemControl_CCR_BFHFNMIGN = 0x100
	// data bus faults caused by load and store instructions cause a lock-up
	SystemControl_CCR_BFHFNMIGN_0 = 0x0
	// handlers running at priority -1 and -2 ignore data bus faults caused by load and store instructions
	SystemControl_CCR_BFHFNMIGN_1 = 0x1
	// Position of STKALIGN field.
	SystemControl_CCR_STKALIGN_Pos = 0x9
	// Bit mask of STKALIGN field.
	SystemControl_CCR_STKALIGN_Msk = 0x200
	// Bit STKALIGN.
	SystemControl_CCR_STKALIGN = 0x200
	// 4-byte aligned
	SystemControl_CCR_STKALIGN_0 = 0x0
	// 8-byte aligned
	SystemControl_CCR_STKALIGN_1 = 0x1

	// SHPR1: System Handler Priority Register 1
	// Position of PRI_4 field.
	SystemControl_SHPR1_PRI_4_Pos = 0x0
	// Bit mask of PRI_4 field.
	SystemControl_SHPR1_PRI_4_Msk = 0xff
	// Position of PRI_5 field.
	SystemControl_SHPR1_PRI_5_Pos = 0x8
	// Bit mask of PRI_5 field.
	SystemControl_SHPR1_PRI_5_Msk = 0xff00
	// Position of PRI_6 field.
	SystemControl_SHPR1_PRI_6_Pos = 0x10
	// Bit mask of PRI_6 field.
	SystemControl_SHPR1_PRI_6_Msk = 0xff0000

	// SHPR2: System Handler Priority Register 2
	// Position of PRI_11 field.
	SystemControl_SHPR2_PRI_11_Pos = 0x18
	// Bit mask of PRI_11 field.
	SystemControl_SHPR2_PRI_11_Msk = 0xff000000

	// SHPR3: System Handler Priority Register 3
	// Position of PRI_14 field.
	SystemControl_SHPR3_PRI_14_Pos = 0x10
	// Bit mask of PRI_14 field.
	SystemControl_SHPR3_PRI_14_Msk = 0xff0000
	// Position of PRI_15 field.
	SystemControl_SHPR3_PRI_15_Pos = 0x18
	// Bit mask of PRI_15 field.
	SystemControl_SHPR3_PRI_15_Msk = 0xff000000

	// SHCSR: System Handler Control and State Register
	// Position of MEMFAULTACT field.
	SystemControl_SHCSR_MEMFAULTACT_Pos = 0x0
	// Bit mask of MEMFAULTACT field.
	SystemControl_SHCSR_MEMFAULTACT_Msk = 0x1
	// Bit MEMFAULTACT.
	SystemControl_SHCSR_MEMFAULTACT = 0x1
	// exception is not active
	SystemControl_SHCSR_MEMFAULTACT_0 = 0x0
	// exception is active
	SystemControl_SHCSR_MEMFAULTACT_1 = 0x1
	// Position of BUSFAULTACT field.
	SystemControl_SHCSR_BUSFAULTACT_Pos = 0x1
	// Bit mask of BUSFAULTACT field.
	SystemControl_SHCSR_BUSFAULTACT_Msk = 0x2
	// Bit BUSFAULTACT.
	SystemControl_SHCSR_BUSFAULTACT = 0x2
	// exception is not active
	SystemControl_SHCSR_BUSFAULTACT_0 = 0x0
	// exception is active
	SystemControl_SHCSR_BUSFAULTACT_1 = 0x1
	// Position of USGFAULTACT field.
	SystemControl_SHCSR_USGFAULTACT_Pos = 0x3
	// Bit mask of USGFAULTACT field.
	SystemControl_SHCSR_USGFAULTACT_Msk = 0x8
	// Bit USGFAULTACT.
	SystemControl_SHCSR_USGFAULTACT = 0x8
	// exception is not active
	SystemControl_SHCSR_USGFAULTACT_0 = 0x0
	// exception is active
	SystemControl_SHCSR_USGFAULTACT_1 = 0x1
	// Position of SVCALLACT field.
	SystemControl_SHCSR_SVCALLACT_Pos = 0x7
	// Bit mask of SVCALLACT field.
	SystemControl_SHCSR_SVCALLACT_Msk = 0x80
	// Bit SVCALLACT.
	SystemControl_SHCSR_SVCALLACT = 0x80
	// exception is not active
	SystemControl_SHCSR_SVCALLACT_0 = 0x0
	// exception is active
	SystemControl_SHCSR_SVCALLACT_1 = 0x1
	// Position of MONITORACT field.
	SystemControl_SHCSR_MONITORACT_Pos = 0x8
	// Bit mask of MONITORACT field.
	SystemControl_SHCSR_MONITORACT_Msk = 0x100
	// Bit MONITORACT.
	SystemControl_SHCSR_MONITORACT = 0x100
	// exception is not active
	SystemControl_SHCSR_MONITORACT_0 = 0x0
	// exception is active
	SystemControl_SHCSR_MONITORACT_1 = 0x1
	// Position of PENDSVACT field.
	SystemControl_SHCSR_PENDSVACT_Pos = 0xa
	// Bit mask of PENDSVACT field.
	SystemControl_SHCSR_PENDSVACT_Msk = 0x400
	// Bit PENDSVACT.
	SystemControl_SHCSR_PENDSVACT = 0x400
	// exception is not active
	SystemControl_SHCSR_PENDSVACT_0 = 0x0
	// exception is active
	SystemControl_SHCSR_PENDSVACT_1 = 0x1
	// Position of SYSTICKACT field.
	SystemControl_SHCSR_SYSTICKACT_Pos = 0xb
	// Bit mask of SYSTICKACT field.
	SystemControl_SHCSR_SYSTICKACT_Msk = 0x800
	// Bit SYSTICKACT.
	SystemControl_SHCSR_SYSTICKACT = 0x800
	// exception is not active
	SystemControl_SHCSR_SYSTICKACT_0 = 0x0
	// exception is active
	SystemControl_SHCSR_SYSTICKACT_1 = 0x1
	// Position of USGFAULTPENDED field.
	SystemControl_SHCSR_USGFAULTPENDED_Pos = 0xc
	// Bit mask of USGFAULTPENDED field.
	SystemControl_SHCSR_USGFAULTPENDED_Msk = 0x1000
	// Bit USGFAULTPENDED.
	SystemControl_SHCSR_USGFAULTPENDED = 0x1000
	// exception is not pending
	SystemControl_SHCSR_USGFAULTPENDED_0 = 0x0
	// exception is pending
	SystemControl_SHCSR_USGFAULTPENDED_1 = 0x1
	// Position of MEMFAULTPENDED field.
	SystemControl_SHCSR_MEMFAULTPENDED_Pos = 0xd
	// Bit mask of MEMFAULTPENDED field.
	SystemControl_SHCSR_MEMFAULTPENDED_Msk = 0x2000
	// Bit MEMFAULTPENDED.
	SystemControl_SHCSR_MEMFAULTPENDED = 0x2000
	// exception is not pending
	SystemControl_SHCSR_MEMFAULTPENDED_0 = 0x0
	// exception is pending
	SystemControl_SHCSR_MEMFAULTPENDED_1 = 0x1
	// Position of BUSFAULTPENDED field.
	SystemControl_SHCSR_BUSFAULTPENDED_Pos = 0xe
	// Bit mask of BUSFAULTPENDED field.
	SystemControl_SHCSR_BUSFAULTPENDED_Msk = 0x4000
	// Bit BUSFAULTPENDED.
	SystemControl_SHCSR_BUSFAULTPENDED = 0x4000
	// exception is not pending
	SystemControl_SHCSR_BUSFAULTPENDED_0 = 0x0
	// exception is pending
	SystemControl_SHCSR_BUSFAULTPENDED_1 = 0x1
	// Position of SVCALLPENDED field.
	SystemControl_SHCSR_SVCALLPENDED_Pos = 0xf
	// Bit mask of SVCALLPENDED field.
	SystemControl_SHCSR_SVCALLPENDED_Msk = 0x8000
	// Bit SVCALLPENDED.
	SystemControl_SHCSR_SVCALLPENDED = 0x8000
	// exception is not pending
	SystemControl_SHCSR_SVCALLPENDED_0 = 0x0
	// exception is pending
	SystemControl_SHCSR_SVCALLPENDED_1 = 0x1
	// Position of MEMFAULTENA field.
	SystemControl_SHCSR_MEMFAULTENA_Pos = 0x10
	// Bit mask of MEMFAULTENA field.
	SystemControl_SHCSR_MEMFAULTENA_Msk = 0x10000
	// Bit MEMFAULTENA.
	SystemControl_SHCSR_MEMFAULTENA = 0x10000
	// disable the exception
	SystemControl_SHCSR_MEMFAULTENA_0 = 0x0
	// enable the exception
	SystemControl_SHCSR_MEMFAULTENA_1 = 0x1
	// Position of BUSFAULTENA field.
	SystemControl_SHCSR_BUSFAULTENA_Pos = 0x11
	// Bit mask of BUSFAULTENA field.
	SystemControl_SHCSR_BUSFAULTENA_Msk = 0x20000
	// Bit BUSFAULTENA.
	SystemControl_SHCSR_BUSFAULTENA = 0x20000
	// disable the exception
	SystemControl_SHCSR_BUSFAULTENA_0 = 0x0
	// enable the exception
	SystemControl_SHCSR_BUSFAULTENA_1 = 0x1
	// Position of USGFAULTENA field.
	SystemControl_SHCSR_USGFAULTENA_Pos = 0x12
	// Bit mask of USGFAULTENA field.
	SystemControl_SHCSR_USGFAULTENA_Msk = 0x40000
	// Bit USGFAULTENA.
	SystemControl_SHCSR_USGFAULTENA = 0x40000
	// disable the exception
	SystemControl_SHCSR_USGFAULTENA_0 = 0x0
	// enable the exception
	SystemControl_SHCSR_USGFAULTENA_1 = 0x1

	// CFSR: Configurable Fault Status Registers
	// Position of IACCVIOL field.
	SystemControl_CFSR_IACCVIOL_Pos = 0x0
	// Bit mask of IACCVIOL field.
	SystemControl_CFSR_IACCVIOL_Msk = 0x1
	// Bit IACCVIOL.
	SystemControl_CFSR_IACCVIOL = 0x1
	// no instruction access violation fault
	SystemControl_CFSR_IACCVIOL_0 = 0x0
	// the processor attempted an instruction fetch from a location that does not permit execution
	SystemControl_CFSR_IACCVIOL_1 = 0x1
	// Position of DACCVIOL field.
	SystemControl_CFSR_DACCVIOL_Pos = 0x1
	// Bit mask of DACCVIOL field.
	SystemControl_CFSR_DACCVIOL_Msk = 0x2
	// Bit DACCVIOL.
	SystemControl_CFSR_DACCVIOL = 0x2
	// no data access violation fault
	SystemControl_CFSR_DACCVIOL_0 = 0x0
	// the processor attempted a load or store at a location that does not permit the operation
	SystemControl_CFSR_DACCVIOL_1 = 0x1
	// Position of MUNSTKERR field.
	SystemControl_CFSR_MUNSTKERR_Pos = 0x3
	// Bit mask of MUNSTKERR field.
	SystemControl_CFSR_MUNSTKERR_Msk = 0x8
	// Bit MUNSTKERR.
	SystemControl_CFSR_MUNSTKERR = 0x8
	// no unstacking fault
	SystemControl_CFSR_MUNSTKERR_0 = 0x0
	// unstack for an exception return has caused one or more access violations
	SystemControl_CFSR_MUNSTKERR_1 = 0x1
	// Position of MSTKERR field.
	SystemControl_CFSR_MSTKERR_Pos = 0x4
	// Bit mask of MSTKERR field.
	SystemControl_CFSR_MSTKERR_Msk = 0x10
	// Bit MSTKERR.
	SystemControl_CFSR_MSTKERR = 0x10
	// no stacking fault
	SystemControl_CFSR_MSTKERR_0 = 0x0
	// stacking for an exception entry has caused one or more access violations
	SystemControl_CFSR_MSTKERR_1 = 0x1
	// Position of MLSPERR field.
	SystemControl_CFSR_MLSPERR_Pos = 0x5
	// Bit mask of MLSPERR field.
	SystemControl_CFSR_MLSPERR_Msk = 0x20
	// Bit MLSPERR.
	SystemControl_CFSR_MLSPERR = 0x20
	// No MemManage fault occurred during floating-point lazy state preservation
	SystemControl_CFSR_MLSPERR_0 = 0x0
	// A MemManage fault occurred during floating-point lazy state preservation
	SystemControl_CFSR_MLSPERR_1 = 0x1
	// Position of MMARVALID field.
	SystemControl_CFSR_MMARVALID_Pos = 0x7
	// Bit mask of MMARVALID field.
	SystemControl_CFSR_MMARVALID_Msk = 0x80
	// Bit MMARVALID.
	SystemControl_CFSR_MMARVALID = 0x80
	// value in MMAR is not a valid fault address
	SystemControl_CFSR_MMARVALID_0 = 0x0
	// MMAR holds a valid fault address
	SystemControl_CFSR_MMARVALID_1 = 0x1
	// Position of IBUSERR field.
	SystemControl_CFSR_IBUSERR_Pos = 0x8
	// Bit mask of IBUSERR field.
	SystemControl_CFSR_IBUSERR_Msk = 0x100
	// Bit IBUSERR.
	SystemControl_CFSR_IBUSERR = 0x100
	// no instruction bus error
	SystemControl_CFSR_IBUSERR_0 = 0x0
	// instruction bus error
	SystemControl_CFSR_IBUSERR_1 = 0x1
	// Position of PRECISERR field.
	SystemControl_CFSR_PRECISERR_Pos = 0x9
	// Bit mask of PRECISERR field.
	SystemControl_CFSR_PRECISERR_Msk = 0x200
	// Bit PRECISERR.
	SystemControl_CFSR_PRECISERR = 0x200
	// no precise data bus error
	SystemControl_CFSR_PRECISERR_0 = 0x0
	// a data bus error has occurred, and the PC value stacked for the exception return points to the instruction that caused the fault
	SystemControl_CFSR_PRECISERR_1 = 0x1
	// Position of IMPRECISERR field.
	SystemControl_CFSR_IMPRECISERR_Pos = 0xa
	// Bit mask of IMPRECISERR field.
	SystemControl_CFSR_IMPRECISERR_Msk = 0x400
	// Bit IMPRECISERR.
	SystemControl_CFSR_IMPRECISERR = 0x400
	// no imprecise data bus error
	SystemControl_CFSR_IMPRECISERR_0 = 0x0
	// a data bus error has occurred, but the return address in the stack frame is not related to the instruction that caused the error
	SystemControl_CFSR_IMPRECISERR_1 = 0x1
	// Position of UNSTKERR field.
	SystemControl_CFSR_UNSTKERR_Pos = 0xb
	// Bit mask of UNSTKERR field.
	SystemControl_CFSR_UNSTKERR_Msk = 0x800
	// Bit UNSTKERR.
	SystemControl_CFSR_UNSTKERR = 0x800
	// no unstacking fault
	SystemControl_CFSR_UNSTKERR_0 = 0x0
	// unstack for an exception return has caused one or more BusFaults
	SystemControl_CFSR_UNSTKERR_1 = 0x1
	// Position of STKERR field.
	SystemControl_CFSR_STKERR_Pos = 0xc
	// Bit mask of STKERR field.
	SystemControl_CFSR_STKERR_Msk = 0x1000
	// Bit STKERR.
	SystemControl_CFSR_STKERR = 0x1000
	// no stacking fault
	SystemControl_CFSR_STKERR_0 = 0x0
	// stacking for an exception entry has caused one or more BusFaults
	SystemControl_CFSR_STKERR_1 = 0x1
	// Position of LSPERR field.
	SystemControl_CFSR_LSPERR_Pos = 0xd
	// Bit mask of LSPERR field.
	SystemControl_CFSR_LSPERR_Msk = 0x2000
	// Bit LSPERR.
	SystemControl_CFSR_LSPERR = 0x2000
	// No bus fault occurred during floating-point lazy state preservation
	SystemControl_CFSR_LSPERR_0 = 0x0
	// A bus fault occurred during floating-point lazy state preservation
	SystemControl_CFSR_LSPERR_1 = 0x1
	// Position of BFARVALID field.
	SystemControl_CFSR_BFARVALID_Pos = 0xf
	// Bit mask of BFARVALID field.
	SystemControl_CFSR_BFARVALID_Msk = 0x8000
	// Bit BFARVALID.
	SystemControl_CFSR_BFARVALID = 0x8000
	// value in BFAR is not a valid fault address
	SystemControl_CFSR_BFARVALID_0 = 0x0
	// BFAR holds a valid fault address
	SystemControl_CFSR_BFARVALID_1 = 0x1
	// Position of UNDEFINSTR field.
	SystemControl_CFSR_UNDEFINSTR_Pos = 0x10
	// Bit mask of UNDEFINSTR field.
	SystemControl_CFSR_UNDEFINSTR_Msk = 0x10000
	// Bit UNDEFINSTR.
	SystemControl_CFSR_UNDEFINSTR = 0x10000
	// no undefined instruction UsageFault
	SystemControl_CFSR_UNDEFINSTR_0 = 0x0
	// the processor has attempted to execute an undefined instruction
	SystemControl_CFSR_UNDEFINSTR_1 = 0x1
	// Position of INVSTATE field.
	SystemControl_CFSR_INVSTATE_Pos = 0x11
	// Bit mask of INVSTATE field.
	SystemControl_CFSR_INVSTATE_Msk = 0x20000
	// Bit INVSTATE.
	SystemControl_CFSR_INVSTATE = 0x20000
	// no invalid state UsageFault
	SystemControl_CFSR_INVSTATE_0 = 0x0
	// the processor has attempted to execute an instruction that makes illegal use of the EPSR
	SystemControl_CFSR_INVSTATE_1 = 0x1
	// Position of INVPC field.
	SystemControl_CFSR_INVPC_Pos = 0x12
	// Bit mask of INVPC field.
	SystemControl_CFSR_INVPC_Msk = 0x40000
	// Bit INVPC.
	SystemControl_CFSR_INVPC = 0x40000
	// no invalid PC load UsageFault
	SystemControl_CFSR_INVPC_0 = 0x0
	// the processor has attempted an illegal load of EXC_RETURN to the PC
	SystemControl_CFSR_INVPC_1 = 0x1
	// Position of NOCP field.
	SystemControl_CFSR_NOCP_Pos = 0x13
	// Bit mask of NOCP field.
	SystemControl_CFSR_NOCP_Msk = 0x80000
	// Bit NOCP.
	SystemControl_CFSR_NOCP = 0x80000
	// no UsageFault caused by attempting to access a coprocessor
	SystemControl_CFSR_NOCP_0 = 0x0
	// the processor has attempted to access a coprocessor
	SystemControl_CFSR_NOCP_1 = 0x1
	// Position of UNALIGNED field.
	SystemControl_CFSR_UNALIGNED_Pos = 0x18
	// Bit mask of UNALIGNED field.
	SystemControl_CFSR_UNALIGNED_Msk = 0x1000000
	// Bit UNALIGNED.
	SystemControl_CFSR_UNALIGNED = 0x1000000
	// no unaligned access fault, or unaligned access trapping not enabled
	SystemControl_CFSR_UNALIGNED_0 = 0x0
	// the processor has made an unaligned memory access
	SystemControl_CFSR_UNALIGNED_1 = 0x1
	// Position of DIVBYZERO field.
	SystemControl_CFSR_DIVBYZERO_Pos = 0x19
	// Bit mask of DIVBYZERO field.
	SystemControl_CFSR_DIVBYZERO_Msk = 0x2000000
	// Bit DIVBYZERO.
	SystemControl_CFSR_DIVBYZERO = 0x2000000
	// no divide by zero fault, or divide by zero trapping not enabled
	SystemControl_CFSR_DIVBYZERO_0 = 0x0
	// the processor has executed an SDIV or UDIV instruction with a divisor of 0
	SystemControl_CFSR_DIVBYZERO_1 = 0x1

	// HFSR: HardFault Status register
	// Position of VECTTBL field.
	SystemControl_HFSR_VECTTBL_Pos = 0x1
	// Bit mask of VECTTBL field.
	SystemControl_HFSR_VECTTBL_Msk = 0x2
	// Bit VECTTBL.
	SystemControl_HFSR_VECTTBL = 0x2
	// no BusFault on vector table read
	SystemControl_HFSR_VECTTBL_0 = 0x0
	// BusFault on vector table read
	SystemControl_HFSR_VECTTBL_1 = 0x1
	// Position of FORCED field.
	SystemControl_HFSR_FORCED_Pos = 0x1e
	// Bit mask of FORCED field.
	SystemControl_HFSR_FORCED_Msk = 0x40000000
	// Bit FORCED.
	SystemControl_HFSR_FORCED = 0x40000000
	// no forced HardFault
	SystemControl_HFSR_FORCED_0 = 0x0
	// forced HardFault
	SystemControl_HFSR_FORCED_1 = 0x1
	// Position of DEBUGEVT field.
	SystemControl_HFSR_DEBUGEVT_Pos = 0x1f
	// Bit mask of DEBUGEVT field.
	SystemControl_HFSR_DEBUGEVT_Msk = 0x80000000
	// Bit DEBUGEVT.
	SystemControl_HFSR_DEBUGEVT = 0x80000000

	// DFSR: Debug Fault Status Register
	// Position of HALTED field.
	SystemControl_DFSR_HALTED_Pos = 0x0
	// Bit mask of HALTED field.
	SystemControl_DFSR_HALTED_Msk = 0x1
	// Bit HALTED.
	SystemControl_DFSR_HALTED = 0x1
	// No active halt request debug event
	SystemControl_DFSR_HALTED_0 = 0x0
	// Halt request debug event active
	SystemControl_DFSR_HALTED_1 = 0x1
	// Position of BKPT field.
	SystemControl_DFSR_BKPT_Pos = 0x1
	// Bit mask of BKPT field.
	SystemControl_DFSR_BKPT_Msk = 0x2
	// Bit BKPT.
	SystemControl_DFSR_BKPT = 0x2
	// No current breakpoint debug event
	SystemControl_DFSR_BKPT_0 = 0x0
	// At least one current breakpoint debug event
	SystemControl_DFSR_BKPT_1 = 0x1
	// Position of DWTTRAP field.
	SystemControl_DFSR_DWTTRAP_Pos = 0x2
	// Bit mask of DWTTRAP field.
	SystemControl_DFSR_DWTTRAP_Msk = 0x4
	// Bit DWTTRAP.
	SystemControl_DFSR_DWTTRAP = 0x4
	// No current debug events generated by the DWT
	SystemControl_DFSR_DWTTRAP_0 = 0x0
	// At least one current debug event generated by the DWT
	SystemControl_DFSR_DWTTRAP_1 = 0x1
	// Position of VCATCH field.
	SystemControl_DFSR_VCATCH_Pos = 0x3
	// Bit mask of VCATCH field.
	SystemControl_DFSR_VCATCH_Msk = 0x8
	// Bit VCATCH.
	SystemControl_DFSR_VCATCH = 0x8
	// No Vector catch triggered
	SystemControl_DFSR_VCATCH_0 = 0x0
	// Vector catch triggered
	SystemControl_DFSR_VCATCH_1 = 0x1
	// Position of EXTERNAL field.
	SystemControl_DFSR_EXTERNAL_Pos = 0x4
	// Bit mask of EXTERNAL field.
	SystemControl_DFSR_EXTERNAL_Msk = 0x10
	// Bit EXTERNAL.
	SystemControl_DFSR_EXTERNAL = 0x10
	// No EDBGRQ debug event
	SystemControl_DFSR_EXTERNAL_0 = 0x0
	// EDBGRQ debug event
	SystemControl_DFSR_EXTERNAL_1 = 0x1

	// MMFAR: MemManage Address Register
	// Position of ADDRESS field.
	SystemControl_MMFAR_ADDRESS_Pos = 0x0
	// Bit mask of ADDRESS field.
	SystemControl_MMFAR_ADDRESS_Msk = 0xffffffff

	// BFAR: BusFault Address Register
	// Position of ADDRESS field.
	SystemControl_BFAR_ADDRESS_Pos = 0x0
	// Bit mask of ADDRESS field.
	SystemControl_BFAR_ADDRESS_Msk = 0xffffffff

	// AFSR: Auxiliary Fault Status Register
	// Position of AUXFAULT field.
	SystemControl_AFSR_AUXFAULT_Pos = 0x0
	// Bit mask of AUXFAULT field.
	SystemControl_AFSR_AUXFAULT_Msk = 0xffffffff

	// CPACR: Coprocessor Access Control Register
	// Position of CP10 field.
	SystemControl_CPACR_CP10_Pos = 0x14
	// Bit mask of CP10 field.
	SystemControl_CPACR_CP10_Msk = 0x300000
	// Access denied. Any attempted access generates a NOCP UsageFault
	SystemControl_CPACR_CP10_00 = 0x0
	// Privileged access only. An unprivileged access generates a NOCP fault.
	SystemControl_CPACR_CP10_01 = 0x1
	// Reserved. The result of any access is UNPREDICTABLE.
	SystemControl_CPACR_CP10_10 = 0x2
	// Full access.
	SystemControl_CPACR_CP10_11 = 0x3
	// Position of CP11 field.
	SystemControl_CPACR_CP11_Pos = 0x16
	// Bit mask of CP11 field.
	SystemControl_CPACR_CP11_Msk = 0xc00000
	// Access denied. Any attempted access generates a NOCP UsageFault
	SystemControl_CPACR_CP11_00 = 0x0
	// Privileged access only. An unprivileged access generates a NOCP fault.
	SystemControl_CPACR_CP11_01 = 0x1
	// Reserved. The result of any access is UNPREDICTABLE.
	SystemControl_CPACR_CP11_10 = 0x2
	// Full access.
	SystemControl_CPACR_CP11_11 = 0x3

	// FPCCR: Floating-point Context Control Register
	// Position of LSPACT field.
	SystemControl_FPCCR_LSPACT_Pos = 0x0
	// Bit mask of LSPACT field.
	SystemControl_FPCCR_LSPACT_Msk = 0x1
	// Bit LSPACT.
	SystemControl_FPCCR_LSPACT = 0x1
	// Lazy state preservation is not active.
	SystemControl_FPCCR_LSPACT_0 = 0x0
	// Lazy state preservation is active. floating-point stack frame has been allocated but saving state to it has been deferred.
	SystemControl_FPCCR_LSPACT_1 = 0x1
	// Position of USER field.
	SystemControl_FPCCR_USER_Pos = 0x1
	// Bit mask of USER field.
	SystemControl_FPCCR_USER_Msk = 0x2
	// Bit USER.
	SystemControl_FPCCR_USER = 0x2
	// Privilege level was not user when the floating-point stack frame was allocated.
	SystemControl_FPCCR_USER_0 = 0x0
	// Privilege level was user when the floating-point stack frame was allocated.
	SystemControl_FPCCR_USER_1 = 0x1
	// Position of THREAD field.
	SystemControl_FPCCR_THREAD_Pos = 0x3
	// Bit mask of THREAD field.
	SystemControl_FPCCR_THREAD_Msk = 0x8
	// Bit THREAD.
	SystemControl_FPCCR_THREAD = 0x8
	// Mode was not Thread Mode when the floating-point stack frame was allocated.
	SystemControl_FPCCR_THREAD_0 = 0x0
	// Mode was Thread Mode when the floating-point stack frame was allocated.
	SystemControl_FPCCR_THREAD_1 = 0x1
	// Position of HFRDY field.
	SystemControl_FPCCR_HFRDY_Pos = 0x4
	// Bit mask of HFRDY field.
	SystemControl_FPCCR_HFRDY_Msk = 0x10
	// Bit HFRDY.
	SystemControl_FPCCR_HFRDY = 0x10
	// Priority did not permit setting the HardFault handler to the pending state when the floating-point stack frame was allocated.
	SystemControl_FPCCR_HFRDY_0 = 0x0
	// Priority permitted setting the HardFault handler to the pending state when the floating-point stack frame was allocated.
	SystemControl_FPCCR_HFRDY_1 = 0x1
	// Position of MMRDY field.
	SystemControl_FPCCR_MMRDY_Pos = 0x5
	// Bit mask of MMRDY field.
	SystemControl_FPCCR_MMRDY_Msk = 0x20
	// Bit MMRDY.
	SystemControl_FPCCR_MMRDY = 0x20
	// MemManage is disabled or priority did not permit setting the MemManage handler to the pending state when the floating-point stack frame was allocated.
	SystemControl_FPCCR_MMRDY_0 = 0x0
	// MemManage is enabled and priority permitted setting the MemManage handler to the pending state when the floating-point stack frame was allocated.
	SystemControl_FPCCR_MMRDY_1 = 0x1
	// Position of BFRDY field.
	SystemControl_FPCCR_BFRDY_Pos = 0x6
	// Bit mask of BFRDY field.
	SystemControl_FPCCR_BFRDY_Msk = 0x40
	// Bit BFRDY.
	SystemControl_FPCCR_BFRDY = 0x40
	// BusFault is disabled or priority did not permit setting the BusFault handler to the pending state when the floating-point stack frame was allocated.
	SystemControl_FPCCR_BFRDY_0 = 0x0
	// BusFault is disabled or priority did not permit setting the BusFault handler to the pending state when the floating-point stack frame was allocated.
	SystemControl_FPCCR_BFRDY_1 = 0x1
	// Position of MONRDY field.
	SystemControl_FPCCR_MONRDY_Pos = 0x8
	// Bit mask of MONRDY field.
	SystemControl_FPCCR_MONRDY_Msk = 0x100
	// Bit MONRDY.
	SystemControl_FPCCR_MONRDY = 0x100
	// DebugMonitor is disabled or priority did not permit setting MON_PEND when the floating-point stack frame was allocated.
	SystemControl_FPCCR_MONRDY_0 = 0x0
	// DebugMonitor is enabled and priority permits setting MON_PEND when the floating-point stack frame was allocated.
	SystemControl_FPCCR_MONRDY_1 = 0x1
	// Position of LSPEN field.
	SystemControl_FPCCR_LSPEN_Pos = 0x1e
	// Bit mask of LSPEN field.
	SystemControl_FPCCR_LSPEN_Msk = 0x40000000
	// Bit LSPEN.
	SystemControl_FPCCR_LSPEN = 0x40000000
	// Disable automatic lazy state preservation for floating-point context.
	SystemControl_FPCCR_LSPEN_0 = 0x0
	// Enable automatic lazy state preservation for floating-point context.
	SystemControl_FPCCR_LSPEN_1 = 0x1
	// Position of ASPEN field.
	SystemControl_FPCCR_ASPEN_Pos = 0x1f
	// Bit mask of ASPEN field.
	SystemControl_FPCCR_ASPEN_Msk = 0x80000000
	// Bit ASPEN.
	SystemControl_FPCCR_ASPEN = 0x80000000
	// Disable CONTROL2 setting on execution of a floating-point instruction.
	SystemControl_FPCCR_ASPEN_0 = 0x0
	// Enable CONTROL2 setting on execution of a floating-point instruction.
	SystemControl_FPCCR_ASPEN_1 = 0x1

	// FPCAR: Floating-point Context Address Register
	// Position of ADDRESS field.
	SystemControl_FPCAR_ADDRESS_Pos = 0x3
	// Bit mask of ADDRESS field.
	SystemControl_FPCAR_ADDRESS_Msk = 0xfffffff8

	// FPDSCR: Floating-point Default Status Control Register
	// Position of RMode field.
	SystemControl_FPDSCR_RMode_Pos = 0x16
	// Bit mask of RMode field.
	SystemControl_FPDSCR_RMode_Msk = 0xc00000
	// Round to Nearest (RN) mode
	SystemControl_FPDSCR_RMode_00 = 0x0
	// Round towards Plus Infinity (RP) mode.
	SystemControl_FPDSCR_RMode_01 = 0x1
	// Round towards Minus Infinity (RM) mode.
	SystemControl_FPDSCR_RMode_10 = 0x2
	// Round towards Zero (RZ) mode.
	SystemControl_FPDSCR_RMode_11 = 0x3
	// Position of FZ field.
	SystemControl_FPDSCR_FZ_Pos = 0x18
	// Bit mask of FZ field.
	SystemControl_FPDSCR_FZ_Msk = 0x1000000
	// Bit FZ.
	SystemControl_FPDSCR_FZ = 0x1000000
	// Flush-to-zero mode disabled. Behavior of the floating-point system is fully compliant with the IEEE 754 standard.
	SystemControl_FPDSCR_FZ_0 = 0x0
	// Flush-to-zero mode enabled.
	SystemControl_FPDSCR_FZ_1 = 0x1
	// Position of DN field.
	SystemControl_FPDSCR_DN_Pos = 0x19
	// Bit mask of DN field.
	SystemControl_FPDSCR_DN_Msk = 0x2000000
	// Bit DN.
	SystemControl_FPDSCR_DN = 0x2000000
	// NaN operands propagate through to the output of a floating-point operation.
	SystemControl_FPDSCR_DN_0 = 0x0
	// Any operation involving one or more NaNs returns the Default NaN.
	SystemControl_FPDSCR_DN_1 = 0x1
	// Position of AHP field.
	SystemControl_FPDSCR_AHP_Pos = 0x1a
	// Bit mask of AHP field.
	SystemControl_FPDSCR_AHP_Msk = 0x4000000
	// Bit AHP.
	SystemControl_FPDSCR_AHP = 0x4000000
	// IEEE half-precision format selected.
	SystemControl_FPDSCR_AHP_0 = 0x0
	// Alternative half-precision format selected.
	SystemControl_FPDSCR_AHP_1 = 0x1
)

// Constants for SysTick: System timer
const (
	// CSR: SysTick Control and Status Register
	// Position of ENABLE field.
	SysTick_CSR_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	SysTick_CSR_ENABLE_Msk = 0x1
	// Bit ENABLE.
	SysTick_CSR_ENABLE = 0x1
	// counter disabled
	SysTick_CSR_ENABLE_0 = 0x0
	// counter enabled
	SysTick_CSR_ENABLE_1 = 0x1
	// Position of TICKINT field.
	SysTick_CSR_TICKINT_Pos = 0x1
	// Bit mask of TICKINT field.
	SysTick_CSR_TICKINT_Msk = 0x2
	// Bit TICKINT.
	SysTick_CSR_TICKINT = 0x2
	// counting down to 0 does not assert the SysTick exception request
	SysTick_CSR_TICKINT_0 = 0x0
	// counting down to 0 asserts the SysTick exception request
	SysTick_CSR_TICKINT_1 = 0x1
	// Position of CLKSOURCE field.
	SysTick_CSR_CLKSOURCE_Pos = 0x2
	// Bit mask of CLKSOURCE field.
	SysTick_CSR_CLKSOURCE_Msk = 0x4
	// Bit CLKSOURCE.
	SysTick_CSR_CLKSOURCE = 0x4
	// external clock
	SysTick_CSR_CLKSOURCE_0 = 0x0
	// processor clock
	SysTick_CSR_CLKSOURCE_1 = 0x1
	// Position of COUNTFLAG field.
	SysTick_CSR_COUNTFLAG_Pos = 0x10
	// Bit mask of COUNTFLAG field.
	SysTick_CSR_COUNTFLAG_Msk = 0x10000
	// Bit COUNTFLAG.
	SysTick_CSR_COUNTFLAG = 0x10000

	// RVR: SysTick Reload Value Register
	// Position of RELOAD field.
	SysTick_RVR_RELOAD_Pos = 0x0
	// Bit mask of RELOAD field.
	SysTick_RVR_RELOAD_Msk = 0xffffff

	// CVR: SysTick Current Value Register
	// Position of CURRENT field.
	SysTick_CVR_CURRENT_Pos = 0x0
	// Bit mask of CURRENT field.
	SysTick_CVR_CURRENT_Msk = 0xffffff

	// CALIB: SysTick Calibration Value Register
	// Position of TENMS field.
	SysTick_CALIB_TENMS_Pos = 0x0
	// Bit mask of TENMS field.
	SysTick_CALIB_TENMS_Msk = 0xffffff
	// Position of SKEW field.
	SysTick_CALIB_SKEW_Pos = 0x1e
	// Bit mask of SKEW field.
	SysTick_CALIB_SKEW_Msk = 0x40000000
	// Bit SKEW.
	SysTick_CALIB_SKEW = 0x40000000
	// 10ms calibration value is exact
	SysTick_CALIB_SKEW_0 = 0x0
	// 10ms calibration value is inexact, because of the clock frequency
	SysTick_CALIB_SKEW_1 = 0x1
	// Position of NOREF field.
	SysTick_CALIB_NOREF_Pos = 0x1f
	// Bit mask of NOREF field.
	SysTick_CALIB_NOREF_Msk = 0x80000000
	// Bit NOREF.
	SysTick_CALIB_NOREF = 0x80000000
	// The reference clock is provided
	SysTick_CALIB_NOREF_0 = 0x0
	// The reference clock is not provided
	SysTick_CALIB_NOREF_1 = 0x1
)

// Constants for NVIC: Nested Vectored Interrupt Controller
const (
	// NVICISER0: Interrupt Set Enable Register n
	// Position of SETENA field.
	NVIC_NVICISER0_SETENA_Pos = 0x0
	// Bit mask of SETENA field.
	NVIC_NVICISER0_SETENA_Msk = 0xffffffff

	// NVICISER1: Interrupt Set Enable Register n
	// Position of SETENA field.
	NVIC_NVICISER1_SETENA_Pos = 0x0
	// Bit mask of SETENA field.
	NVIC_NVICISER1_SETENA_Msk = 0xffffffff

	// NVICISER2: Interrupt Set Enable Register n
	// Position of SETENA field.
	NVIC_NVICISER2_SETENA_Pos = 0x0
	// Bit mask of SETENA field.
	NVIC_NVICISER2_SETENA_Msk = 0xffffffff

	// NVICISER3: Interrupt Set Enable Register n
	// Position of SETENA field.
	NVIC_NVICISER3_SETENA_Pos = 0x0
	// Bit mask of SETENA field.
	NVIC_NVICISER3_SETENA_Msk = 0xffffffff

	// NVICICER0: Interrupt Clear Enable Register n
	// Position of CLRENA field.
	NVIC_NVICICER0_CLRENA_Pos = 0x0
	// Bit mask of CLRENA field.
	NVIC_NVICICER0_CLRENA_Msk = 0xffffffff

	// NVICICER1: Interrupt Clear Enable Register n
	// Position of CLRENA field.
	NVIC_NVICICER1_CLRENA_Pos = 0x0
	// Bit mask of CLRENA field.
	NVIC_NVICICER1_CLRENA_Msk = 0xffffffff

	// NVICICER2: Interrupt Clear Enable Register n
	// Position of CLRENA field.
	NVIC_NVICICER2_CLRENA_Pos = 0x0
	// Bit mask of CLRENA field.
	NVIC_NVICICER2_CLRENA_Msk = 0xffffffff

	// NVICICER3: Interrupt Clear Enable Register n
	// Position of CLRENA field.
	NVIC_NVICICER3_CLRENA_Pos = 0x0
	// Bit mask of CLRENA field.
	NVIC_NVICICER3_CLRENA_Msk = 0xffffffff

	// NVICISPR0: Interrupt Set Pending Register n
	// Position of SETPEND field.
	NVIC_NVICISPR0_SETPEND_Pos = 0x0
	// Bit mask of SETPEND field.
	NVIC_NVICISPR0_SETPEND_Msk = 0xffffffff

	// NVICISPR1: Interrupt Set Pending Register n
	// Position of SETPEND field.
	NVIC_NVICISPR1_SETPEND_Pos = 0x0
	// Bit mask of SETPEND field.
	NVIC_NVICISPR1_SETPEND_Msk = 0xffffffff

	// NVICISPR2: Interrupt Set Pending Register n
	// Position of SETPEND field.
	NVIC_NVICISPR2_SETPEND_Pos = 0x0
	// Bit mask of SETPEND field.
	NVIC_NVICISPR2_SETPEND_Msk = 0xffffffff

	// NVICISPR3: Interrupt Set Pending Register n
	// Position of SETPEND field.
	NVIC_NVICISPR3_SETPEND_Pos = 0x0
	// Bit mask of SETPEND field.
	NVIC_NVICISPR3_SETPEND_Msk = 0xffffffff

	// NVICICPR0: Interrupt Clear Pending Register n
	// Position of CLRPEND field.
	NVIC_NVICICPR0_CLRPEND_Pos = 0x0
	// Bit mask of CLRPEND field.
	NVIC_NVICICPR0_CLRPEND_Msk = 0xffffffff

	// NVICICPR1: Interrupt Clear Pending Register n
	// Position of CLRPEND field.
	NVIC_NVICICPR1_CLRPEND_Pos = 0x0
	// Bit mask of CLRPEND field.
	NVIC_NVICICPR1_CLRPEND_Msk = 0xffffffff

	// NVICICPR2: Interrupt Clear Pending Register n
	// Position of CLRPEND field.
	NVIC_NVICICPR2_CLRPEND_Pos = 0x0
	// Bit mask of CLRPEND field.
	NVIC_NVICICPR2_CLRPEND_Msk = 0xffffffff

	// NVICICPR3: Interrupt Clear Pending Register n
	// Position of CLRPEND field.
	NVIC_NVICICPR3_CLRPEND_Pos = 0x0
	// Bit mask of CLRPEND field.
	NVIC_NVICICPR3_CLRPEND_Msk = 0xffffffff

	// NVICIABR0: Interrupt Active bit Register n
	// Position of ACTIVE field.
	NVIC_NVICIABR0_ACTIVE_Pos = 0x0
	// Bit mask of ACTIVE field.
	NVIC_NVICIABR0_ACTIVE_Msk = 0xffffffff

	// NVICIABR1: Interrupt Active bit Register n
	// Position of ACTIVE field.
	NVIC_NVICIABR1_ACTIVE_Pos = 0x0
	// Bit mask of ACTIVE field.
	NVIC_NVICIABR1_ACTIVE_Msk = 0xffffffff

	// NVICIABR2: Interrupt Active bit Register n
	// Position of ACTIVE field.
	NVIC_NVICIABR2_ACTIVE_Pos = 0x0
	// Bit mask of ACTIVE field.
	NVIC_NVICIABR2_ACTIVE_Msk = 0xffffffff

	// NVICIABR3: Interrupt Active bit Register n
	// Position of ACTIVE field.
	NVIC_NVICIABR3_ACTIVE_Pos = 0x0
	// Bit mask of ACTIVE field.
	NVIC_NVICIABR3_ACTIVE_Msk = 0xffffffff

	// NVICIP0: Interrupt Priority Register n
	// Position of PRI0 field.
	NVIC_NVICIP0_PRI0_Pos = 0x0
	// Bit mask of PRI0 field.
	NVIC_NVICIP0_PRI0_Msk = 0xff

	// NVICIP1: Interrupt Priority Register n
	// Position of PRI1 field.
	NVIC_NVICIP1_PRI1_Pos = 0x0
	// Bit mask of PRI1 field.
	NVIC_NVICIP1_PRI1_Msk = 0xff

	// NVICIP2: Interrupt Priority Register n
	// Position of PRI2 field.
	NVIC_NVICIP2_PRI2_Pos = 0x0
	// Bit mask of PRI2 field.
	NVIC_NVICIP2_PRI2_Msk = 0xff

	// NVICIP3: Interrupt Priority Register n
	// Position of PRI3 field.
	NVIC_NVICIP3_PRI3_Pos = 0x0
	// Bit mask of PRI3 field.
	NVIC_NVICIP3_PRI3_Msk = 0xff

	// NVICIP4: Interrupt Priority Register n
	// Position of PRI4 field.
	NVIC_NVICIP4_PRI4_Pos = 0x0
	// Bit mask of PRI4 field.
	NVIC_NVICIP4_PRI4_Msk = 0xff

	// NVICIP5: Interrupt Priority Register n
	// Position of PRI5 field.
	NVIC_NVICIP5_PRI5_Pos = 0x0
	// Bit mask of PRI5 field.
	NVIC_NVICIP5_PRI5_Msk = 0xff

	// NVICIP6: Interrupt Priority Register n
	// Position of PRI6 field.
	NVIC_NVICIP6_PRI6_Pos = 0x0
	// Bit mask of PRI6 field.
	NVIC_NVICIP6_PRI6_Msk = 0xff

	// NVICIP7: Interrupt Priority Register n
	// Position of PRI7 field.
	NVIC_NVICIP7_PRI7_Pos = 0x0
	// Bit mask of PRI7 field.
	NVIC_NVICIP7_PRI7_Msk = 0xff

	// NVICIP8: Interrupt Priority Register n
	// Position of PRI8 field.
	NVIC_NVICIP8_PRI8_Pos = 0x0
	// Bit mask of PRI8 field.
	NVIC_NVICIP8_PRI8_Msk = 0xff

	// NVICIP9: Interrupt Priority Register n
	// Position of PRI9 field.
	NVIC_NVICIP9_PRI9_Pos = 0x0
	// Bit mask of PRI9 field.
	NVIC_NVICIP9_PRI9_Msk = 0xff

	// NVICIP10: Interrupt Priority Register n
	// Position of PRI10 field.
	NVIC_NVICIP10_PRI10_Pos = 0x0
	// Bit mask of PRI10 field.
	NVIC_NVICIP10_PRI10_Msk = 0xff

	// NVICIP11: Interrupt Priority Register n
	// Position of PRI11 field.
	NVIC_NVICIP11_PRI11_Pos = 0x0
	// Bit mask of PRI11 field.
	NVIC_NVICIP11_PRI11_Msk = 0xff

	// NVICIP12: Interrupt Priority Register n
	// Position of PRI12 field.
	NVIC_NVICIP12_PRI12_Pos = 0x0
	// Bit mask of PRI12 field.
	NVIC_NVICIP12_PRI12_Msk = 0xff

	// NVICIP13: Interrupt Priority Register n
	// Position of PRI13 field.
	NVIC_NVICIP13_PRI13_Pos = 0x0
	// Bit mask of PRI13 field.
	NVIC_NVICIP13_PRI13_Msk = 0xff

	// NVICIP14: Interrupt Priority Register n
	// Position of PRI14 field.
	NVIC_NVICIP14_PRI14_Pos = 0x0
	// Bit mask of PRI14 field.
	NVIC_NVICIP14_PRI14_Msk = 0xff

	// NVICIP15: Interrupt Priority Register n
	// Position of PRI15 field.
	NVIC_NVICIP15_PRI15_Pos = 0x0
	// Bit mask of PRI15 field.
	NVIC_NVICIP15_PRI15_Msk = 0xff

	// NVICIP16: Interrupt Priority Register n
	// Position of PRI16 field.
	NVIC_NVICIP16_PRI16_Pos = 0x0
	// Bit mask of PRI16 field.
	NVIC_NVICIP16_PRI16_Msk = 0xff

	// NVICIP17: Interrupt Priority Register n
	// Position of PRI17 field.
	NVIC_NVICIP17_PRI17_Pos = 0x0
	// Bit mask of PRI17 field.
	NVIC_NVICIP17_PRI17_Msk = 0xff

	// NVICIP18: Interrupt Priority Register n
	// Position of PRI18 field.
	NVIC_NVICIP18_PRI18_Pos = 0x0
	// Bit mask of PRI18 field.
	NVIC_NVICIP18_PRI18_Msk = 0xff

	// NVICIP19: Interrupt Priority Register n
	// Position of PRI19 field.
	NVIC_NVICIP19_PRI19_Pos = 0x0
	// Bit mask of PRI19 field.
	NVIC_NVICIP19_PRI19_Msk = 0xff

	// NVICIP20: Interrupt Priority Register n
	// Position of PRI20 field.
	NVIC_NVICIP20_PRI20_Pos = 0x0
	// Bit mask of PRI20 field.
	NVIC_NVICIP20_PRI20_Msk = 0xff

	// NVICIP21: Interrupt Priority Register n
	// Position of PRI21 field.
	NVIC_NVICIP21_PRI21_Pos = 0x0
	// Bit mask of PRI21 field.
	NVIC_NVICIP21_PRI21_Msk = 0xff

	// NVICIP22: Interrupt Priority Register n
	// Position of PRI22 field.
	NVIC_NVICIP22_PRI22_Pos = 0x0
	// Bit mask of PRI22 field.
	NVIC_NVICIP22_PRI22_Msk = 0xff

	// NVICIP23: Interrupt Priority Register n
	// Position of PRI23 field.
	NVIC_NVICIP23_PRI23_Pos = 0x0
	// Bit mask of PRI23 field.
	NVIC_NVICIP23_PRI23_Msk = 0xff

	// NVICIP24: Interrupt Priority Register n
	// Position of PRI24 field.
	NVIC_NVICIP24_PRI24_Pos = 0x0
	// Bit mask of PRI24 field.
	NVIC_NVICIP24_PRI24_Msk = 0xff

	// NVICIP25: Interrupt Priority Register n
	// Position of PRI25 field.
	NVIC_NVICIP25_PRI25_Pos = 0x0
	// Bit mask of PRI25 field.
	NVIC_NVICIP25_PRI25_Msk = 0xff

	// NVICIP26: Interrupt Priority Register n
	// Position of PRI26 field.
	NVIC_NVICIP26_PRI26_Pos = 0x0
	// Bit mask of PRI26 field.
	NVIC_NVICIP26_PRI26_Msk = 0xff

	// NVICIP27: Interrupt Priority Register n
	// Position of PRI27 field.
	NVIC_NVICIP27_PRI27_Pos = 0x0
	// Bit mask of PRI27 field.
	NVIC_NVICIP27_PRI27_Msk = 0xff

	// NVICIP28: Interrupt Priority Register n
	// Position of PRI28 field.
	NVIC_NVICIP28_PRI28_Pos = 0x0
	// Bit mask of PRI28 field.
	NVIC_NVICIP28_PRI28_Msk = 0xff

	// NVICIP29: Interrupt Priority Register n
	// Position of PRI29 field.
	NVIC_NVICIP29_PRI29_Pos = 0x0
	// Bit mask of PRI29 field.
	NVIC_NVICIP29_PRI29_Msk = 0xff

	// NVICIP30: Interrupt Priority Register n
	// Position of PRI30 field.
	NVIC_NVICIP30_PRI30_Pos = 0x0
	// Bit mask of PRI30 field.
	NVIC_NVICIP30_PRI30_Msk = 0xff

	// NVICIP31: Interrupt Priority Register n
	// Position of PRI31 field.
	NVIC_NVICIP31_PRI31_Pos = 0x0
	// Bit mask of PRI31 field.
	NVIC_NVICIP31_PRI31_Msk = 0xff

	// NVICIP32: Interrupt Priority Register n
	// Position of PRI32 field.
	NVIC_NVICIP32_PRI32_Pos = 0x0
	// Bit mask of PRI32 field.
	NVIC_NVICIP32_PRI32_Msk = 0xff

	// NVICIP33: Interrupt Priority Register n
	// Position of PRI33 field.
	NVIC_NVICIP33_PRI33_Pos = 0x0
	// Bit mask of PRI33 field.
	NVIC_NVICIP33_PRI33_Msk = 0xff

	// NVICIP34: Interrupt Priority Register n
	// Position of PRI34 field.
	NVIC_NVICIP34_PRI34_Pos = 0x0
	// Bit mask of PRI34 field.
	NVIC_NVICIP34_PRI34_Msk = 0xff

	// NVICIP35: Interrupt Priority Register n
	// Position of PRI35 field.
	NVIC_NVICIP35_PRI35_Pos = 0x0
	// Bit mask of PRI35 field.
	NVIC_NVICIP35_PRI35_Msk = 0xff

	// NVICIP36: Interrupt Priority Register n
	// Position of PRI36 field.
	NVIC_NVICIP36_PRI36_Pos = 0x0
	// Bit mask of PRI36 field.
	NVIC_NVICIP36_PRI36_Msk = 0xff

	// NVICIP37: Interrupt Priority Register n
	// Position of PRI37 field.
	NVIC_NVICIP37_PRI37_Pos = 0x0
	// Bit mask of PRI37 field.
	NVIC_NVICIP37_PRI37_Msk = 0xff

	// NVICIP38: Interrupt Priority Register n
	// Position of PRI38 field.
	NVIC_NVICIP38_PRI38_Pos = 0x0
	// Bit mask of PRI38 field.
	NVIC_NVICIP38_PRI38_Msk = 0xff

	// NVICIP39: Interrupt Priority Register n
	// Position of PRI39 field.
	NVIC_NVICIP39_PRI39_Pos = 0x0
	// Bit mask of PRI39 field.
	NVIC_NVICIP39_PRI39_Msk = 0xff

	// NVICIP40: Interrupt Priority Register n
	// Position of PRI40 field.
	NVIC_NVICIP40_PRI40_Pos = 0x0
	// Bit mask of PRI40 field.
	NVIC_NVICIP40_PRI40_Msk = 0xff

	// NVICIP41: Interrupt Priority Register n
	// Position of PRI41 field.
	NVIC_NVICIP41_PRI41_Pos = 0x0
	// Bit mask of PRI41 field.
	NVIC_NVICIP41_PRI41_Msk = 0xff

	// NVICIP42: Interrupt Priority Register n
	// Position of PRI42 field.
	NVIC_NVICIP42_PRI42_Pos = 0x0
	// Bit mask of PRI42 field.
	NVIC_NVICIP42_PRI42_Msk = 0xff

	// NVICIP43: Interrupt Priority Register n
	// Position of PRI43 field.
	NVIC_NVICIP43_PRI43_Pos = 0x0
	// Bit mask of PRI43 field.
	NVIC_NVICIP43_PRI43_Msk = 0xff

	// NVICIP44: Interrupt Priority Register n
	// Position of PRI44 field.
	NVIC_NVICIP44_PRI44_Pos = 0x0
	// Bit mask of PRI44 field.
	NVIC_NVICIP44_PRI44_Msk = 0xff

	// NVICIP45: Interrupt Priority Register n
	// Position of PRI45 field.
	NVIC_NVICIP45_PRI45_Pos = 0x0
	// Bit mask of PRI45 field.
	NVIC_NVICIP45_PRI45_Msk = 0xff

	// NVICIP46: Interrupt Priority Register n
	// Position of PRI46 field.
	NVIC_NVICIP46_PRI46_Pos = 0x0
	// Bit mask of PRI46 field.
	NVIC_NVICIP46_PRI46_Msk = 0xff

	// NVICIP47: Interrupt Priority Register n
	// Position of PRI47 field.
	NVIC_NVICIP47_PRI47_Pos = 0x0
	// Bit mask of PRI47 field.
	NVIC_NVICIP47_PRI47_Msk = 0xff

	// NVICIP48: Interrupt Priority Register n
	// Position of PRI48 field.
	NVIC_NVICIP48_PRI48_Pos = 0x0
	// Bit mask of PRI48 field.
	NVIC_NVICIP48_PRI48_Msk = 0xff

	// NVICIP49: Interrupt Priority Register n
	// Position of PRI49 field.
	NVIC_NVICIP49_PRI49_Pos = 0x0
	// Bit mask of PRI49 field.
	NVIC_NVICIP49_PRI49_Msk = 0xff

	// NVICIP50: Interrupt Priority Register n
	// Position of PRI50 field.
	NVIC_NVICIP50_PRI50_Pos = 0x0
	// Bit mask of PRI50 field.
	NVIC_NVICIP50_PRI50_Msk = 0xff

	// NVICIP51: Interrupt Priority Register n
	// Position of PRI51 field.
	NVIC_NVICIP51_PRI51_Pos = 0x0
	// Bit mask of PRI51 field.
	NVIC_NVICIP51_PRI51_Msk = 0xff

	// NVICIP52: Interrupt Priority Register n
	// Position of PRI52 field.
	NVIC_NVICIP52_PRI52_Pos = 0x0
	// Bit mask of PRI52 field.
	NVIC_NVICIP52_PRI52_Msk = 0xff

	// NVICIP53: Interrupt Priority Register n
	// Position of PRI53 field.
	NVIC_NVICIP53_PRI53_Pos = 0x0
	// Bit mask of PRI53 field.
	NVIC_NVICIP53_PRI53_Msk = 0xff

	// NVICIP54: Interrupt Priority Register n
	// Position of PRI54 field.
	NVIC_NVICIP54_PRI54_Pos = 0x0
	// Bit mask of PRI54 field.
	NVIC_NVICIP54_PRI54_Msk = 0xff

	// NVICIP55: Interrupt Priority Register n
	// Position of PRI55 field.
	NVIC_NVICIP55_PRI55_Pos = 0x0
	// Bit mask of PRI55 field.
	NVIC_NVICIP55_PRI55_Msk = 0xff

	// NVICIP56: Interrupt Priority Register n
	// Position of PRI56 field.
	NVIC_NVICIP56_PRI56_Pos = 0x0
	// Bit mask of PRI56 field.
	NVIC_NVICIP56_PRI56_Msk = 0xff

	// NVICIP57: Interrupt Priority Register n
	// Position of PRI57 field.
	NVIC_NVICIP57_PRI57_Pos = 0x0
	// Bit mask of PRI57 field.
	NVIC_NVICIP57_PRI57_Msk = 0xff

	// NVICIP58: Interrupt Priority Register n
	// Position of PRI58 field.
	NVIC_NVICIP58_PRI58_Pos = 0x0
	// Bit mask of PRI58 field.
	NVIC_NVICIP58_PRI58_Msk = 0xff

	// NVICIP59: Interrupt Priority Register n
	// Position of PRI59 field.
	NVIC_NVICIP59_PRI59_Pos = 0x0
	// Bit mask of PRI59 field.
	NVIC_NVICIP59_PRI59_Msk = 0xff

	// NVICIP60: Interrupt Priority Register n
	// Position of PRI60 field.
	NVIC_NVICIP60_PRI60_Pos = 0x0
	// Bit mask of PRI60 field.
	NVIC_NVICIP60_PRI60_Msk = 0xff

	// NVICIP61: Interrupt Priority Register n
	// Position of PRI61 field.
	NVIC_NVICIP61_PRI61_Pos = 0x0
	// Bit mask of PRI61 field.
	NVIC_NVICIP61_PRI61_Msk = 0xff

	// NVICIP62: Interrupt Priority Register n
	// Position of PRI62 field.
	NVIC_NVICIP62_PRI62_Pos = 0x0
	// Bit mask of PRI62 field.
	NVIC_NVICIP62_PRI62_Msk = 0xff

	// NVICIP63: Interrupt Priority Register n
	// Position of PRI63 field.
	NVIC_NVICIP63_PRI63_Pos = 0x0
	// Bit mask of PRI63 field.
	NVIC_NVICIP63_PRI63_Msk = 0xff

	// NVICIP64: Interrupt Priority Register n
	// Position of PRI64 field.
	NVIC_NVICIP64_PRI64_Pos = 0x0
	// Bit mask of PRI64 field.
	NVIC_NVICIP64_PRI64_Msk = 0xff

	// NVICIP65: Interrupt Priority Register n
	// Position of PRI65 field.
	NVIC_NVICIP65_PRI65_Pos = 0x0
	// Bit mask of PRI65 field.
	NVIC_NVICIP65_PRI65_Msk = 0xff

	// NVICIP66: Interrupt Priority Register n
	// Position of PRI66 field.
	NVIC_NVICIP66_PRI66_Pos = 0x0
	// Bit mask of PRI66 field.
	NVIC_NVICIP66_PRI66_Msk = 0xff

	// NVICIP67: Interrupt Priority Register n
	// Position of PRI67 field.
	NVIC_NVICIP67_PRI67_Pos = 0x0
	// Bit mask of PRI67 field.
	NVIC_NVICIP67_PRI67_Msk = 0xff

	// NVICIP68: Interrupt Priority Register n
	// Position of PRI68 field.
	NVIC_NVICIP68_PRI68_Pos = 0x0
	// Bit mask of PRI68 field.
	NVIC_NVICIP68_PRI68_Msk = 0xff

	// NVICIP69: Interrupt Priority Register n
	// Position of PRI69 field.
	NVIC_NVICIP69_PRI69_Pos = 0x0
	// Bit mask of PRI69 field.
	NVIC_NVICIP69_PRI69_Msk = 0xff

	// NVICIP70: Interrupt Priority Register n
	// Position of PRI70 field.
	NVIC_NVICIP70_PRI70_Pos = 0x0
	// Bit mask of PRI70 field.
	NVIC_NVICIP70_PRI70_Msk = 0xff

	// NVICIP71: Interrupt Priority Register n
	// Position of PRI71 field.
	NVIC_NVICIP71_PRI71_Pos = 0x0
	// Bit mask of PRI71 field.
	NVIC_NVICIP71_PRI71_Msk = 0xff

	// NVICIP72: Interrupt Priority Register n
	// Position of PRI72 field.
	NVIC_NVICIP72_PRI72_Pos = 0x0
	// Bit mask of PRI72 field.
	NVIC_NVICIP72_PRI72_Msk = 0xff

	// NVICIP73: Interrupt Priority Register n
	// Position of PRI73 field.
	NVIC_NVICIP73_PRI73_Pos = 0x0
	// Bit mask of PRI73 field.
	NVIC_NVICIP73_PRI73_Msk = 0xff

	// NVICIP74: Interrupt Priority Register n
	// Position of PRI74 field.
	NVIC_NVICIP74_PRI74_Pos = 0x0
	// Bit mask of PRI74 field.
	NVIC_NVICIP74_PRI74_Msk = 0xff

	// NVICIP75: Interrupt Priority Register n
	// Position of PRI75 field.
	NVIC_NVICIP75_PRI75_Pos = 0x0
	// Bit mask of PRI75 field.
	NVIC_NVICIP75_PRI75_Msk = 0xff

	// NVICIP76: Interrupt Priority Register n
	// Position of PRI76 field.
	NVIC_NVICIP76_PRI76_Pos = 0x0
	// Bit mask of PRI76 field.
	NVIC_NVICIP76_PRI76_Msk = 0xff

	// NVICIP77: Interrupt Priority Register n
	// Position of PRI77 field.
	NVIC_NVICIP77_PRI77_Pos = 0x0
	// Bit mask of PRI77 field.
	NVIC_NVICIP77_PRI77_Msk = 0xff

	// NVICIP78: Interrupt Priority Register n
	// Position of PRI78 field.
	NVIC_NVICIP78_PRI78_Pos = 0x0
	// Bit mask of PRI78 field.
	NVIC_NVICIP78_PRI78_Msk = 0xff

	// NVICIP79: Interrupt Priority Register n
	// Position of PRI79 field.
	NVIC_NVICIP79_PRI79_Pos = 0x0
	// Bit mask of PRI79 field.
	NVIC_NVICIP79_PRI79_Msk = 0xff

	// NVICIP80: Interrupt Priority Register n
	// Position of PRI80 field.
	NVIC_NVICIP80_PRI80_Pos = 0x0
	// Bit mask of PRI80 field.
	NVIC_NVICIP80_PRI80_Msk = 0xff

	// NVICIP81: Interrupt Priority Register n
	// Position of PRI81 field.
	NVIC_NVICIP81_PRI81_Pos = 0x0
	// Bit mask of PRI81 field.
	NVIC_NVICIP81_PRI81_Msk = 0xff

	// NVICIP82: Interrupt Priority Register n
	// Position of PRI82 field.
	NVIC_NVICIP82_PRI82_Pos = 0x0
	// Bit mask of PRI82 field.
	NVIC_NVICIP82_PRI82_Msk = 0xff

	// NVICIP83: Interrupt Priority Register n
	// Position of PRI83 field.
	NVIC_NVICIP83_PRI83_Pos = 0x0
	// Bit mask of PRI83 field.
	NVIC_NVICIP83_PRI83_Msk = 0xff

	// NVICIP84: Interrupt Priority Register n
	// Position of PRI84 field.
	NVIC_NVICIP84_PRI84_Pos = 0x0
	// Bit mask of PRI84 field.
	NVIC_NVICIP84_PRI84_Msk = 0xff

	// NVICIP85: Interrupt Priority Register n
	// Position of PRI85 field.
	NVIC_NVICIP85_PRI85_Pos = 0x0
	// Bit mask of PRI85 field.
	NVIC_NVICIP85_PRI85_Msk = 0xff

	// NVICIP86: Interrupt Priority Register n
	// Position of PRI86 field.
	NVIC_NVICIP86_PRI86_Pos = 0x0
	// Bit mask of PRI86 field.
	NVIC_NVICIP86_PRI86_Msk = 0xff

	// NVICIP87: Interrupt Priority Register n
	// Position of PRI87 field.
	NVIC_NVICIP87_PRI87_Pos = 0x0
	// Bit mask of PRI87 field.
	NVIC_NVICIP87_PRI87_Msk = 0xff

	// NVICIP88: Interrupt Priority Register n
	// Position of PRI88 field.
	NVIC_NVICIP88_PRI88_Pos = 0x0
	// Bit mask of PRI88 field.
	NVIC_NVICIP88_PRI88_Msk = 0xff

	// NVICIP89: Interrupt Priority Register n
	// Position of PRI89 field.
	NVIC_NVICIP89_PRI89_Pos = 0x0
	// Bit mask of PRI89 field.
	NVIC_NVICIP89_PRI89_Msk = 0xff

	// NVICIP90: Interrupt Priority Register n
	// Position of PRI90 field.
	NVIC_NVICIP90_PRI90_Pos = 0x0
	// Bit mask of PRI90 field.
	NVIC_NVICIP90_PRI90_Msk = 0xff

	// NVICIP91: Interrupt Priority Register n
	// Position of PRI91 field.
	NVIC_NVICIP91_PRI91_Pos = 0x0
	// Bit mask of PRI91 field.
	NVIC_NVICIP91_PRI91_Msk = 0xff

	// NVICIP92: Interrupt Priority Register n
	// Position of PRI92 field.
	NVIC_NVICIP92_PRI92_Pos = 0x0
	// Bit mask of PRI92 field.
	NVIC_NVICIP92_PRI92_Msk = 0xff

	// NVICIP93: Interrupt Priority Register n
	// Position of PRI93 field.
	NVIC_NVICIP93_PRI93_Pos = 0x0
	// Bit mask of PRI93 field.
	NVIC_NVICIP93_PRI93_Msk = 0xff

	// NVICIP94: Interrupt Priority Register n
	// Position of PRI94 field.
	NVIC_NVICIP94_PRI94_Pos = 0x0
	// Bit mask of PRI94 field.
	NVIC_NVICIP94_PRI94_Msk = 0xff

	// NVICIP95: Interrupt Priority Register n
	// Position of PRI95 field.
	NVIC_NVICIP95_PRI95_Pos = 0x0
	// Bit mask of PRI95 field.
	NVIC_NVICIP95_PRI95_Msk = 0xff

	// NVICIP96: Interrupt Priority Register n
	// Position of PRI96 field.
	NVIC_NVICIP96_PRI96_Pos = 0x0
	// Bit mask of PRI96 field.
	NVIC_NVICIP96_PRI96_Msk = 0xff

	// NVICIP97: Interrupt Priority Register n
	// Position of PRI97 field.
	NVIC_NVICIP97_PRI97_Pos = 0x0
	// Bit mask of PRI97 field.
	NVIC_NVICIP97_PRI97_Msk = 0xff

	// NVICIP98: Interrupt Priority Register n
	// Position of PRI98 field.
	NVIC_NVICIP98_PRI98_Pos = 0x0
	// Bit mask of PRI98 field.
	NVIC_NVICIP98_PRI98_Msk = 0xff

	// NVICIP99: Interrupt Priority Register n
	// Position of PRI99 field.
	NVIC_NVICIP99_PRI99_Pos = 0x0
	// Bit mask of PRI99 field.
	NVIC_NVICIP99_PRI99_Msk = 0xff

	// NVICIP100: Interrupt Priority Register n
	// Position of PRI100 field.
	NVIC_NVICIP100_PRI100_Pos = 0x0
	// Bit mask of PRI100 field.
	NVIC_NVICIP100_PRI100_Msk = 0xff

	// NVICIP101: Interrupt Priority Register n
	// Position of PRI101 field.
	NVIC_NVICIP101_PRI101_Pos = 0x0
	// Bit mask of PRI101 field.
	NVIC_NVICIP101_PRI101_Msk = 0xff

	// NVICIP102: Interrupt Priority Register n
	// Position of PRI102 field.
	NVIC_NVICIP102_PRI102_Pos = 0x0
	// Bit mask of PRI102 field.
	NVIC_NVICIP102_PRI102_Msk = 0xff

	// NVICIP103: Interrupt Priority Register n
	// Position of PRI103 field.
	NVIC_NVICIP103_PRI103_Pos = 0x0
	// Bit mask of PRI103 field.
	NVIC_NVICIP103_PRI103_Msk = 0xff

	// NVICIP104: Interrupt Priority Register n
	// Position of PRI104 field.
	NVIC_NVICIP104_PRI104_Pos = 0x0
	// Bit mask of PRI104 field.
	NVIC_NVICIP104_PRI104_Msk = 0xff

	// NVICIP105: Interrupt Priority Register n
	// Position of PRI105 field.
	NVIC_NVICIP105_PRI105_Pos = 0x0
	// Bit mask of PRI105 field.
	NVIC_NVICIP105_PRI105_Msk = 0xff

	// NVICSTIR: Software Trigger Interrupt Register
	// Position of INTID field.
	NVIC_NVICSTIR_INTID_Pos = 0x0
	// Bit mask of INTID field.
	NVIC_NVICSTIR_INTID_Msk = 0x1ff
)

// Constants for MCM: Core Platform Miscellaneous Control Module
const (
	// PLASC: Crossbar Switch (AXBS) Slave Configuration
	// Position of ASC field.
	MCM_PLASC_ASC_Pos = 0x0
	// Bit mask of ASC field.
	MCM_PLASC_ASC_Msk = 0xff
	// A bus slave connection to AXBS input port n is absent
	MCM_PLASC_ASC_0 = 0x0
	// A bus slave connection to AXBS input port n is present
	MCM_PLASC_ASC_1 = 0x1

	// PLAMC: Crossbar Switch (AXBS) Master Configuration
	// Position of AMC field.
	MCM_PLAMC_AMC_Pos = 0x0
	// Bit mask of AMC field.
	MCM_PLAMC_AMC_Msk = 0xff
	// A bus master connection to AXBS input port n is absent
	MCM_PLAMC_AMC_0 = 0x0
	// A bus master connection to AXBS input port n is present
	MCM_PLAMC_AMC_1 = 0x1

	// CR: Control Register
	// Position of SRAMUAP field.
	MCM_CR_SRAMUAP_Pos = 0x18
	// Bit mask of SRAMUAP field.
	MCM_CR_SRAMUAP_Msk = 0x3000000
	// Round robin
	MCM_CR_SRAMUAP_00 = 0x0
	// Special round robin (favors SRAM backoor accesses over the processor)
	MCM_CR_SRAMUAP_01 = 0x1
	// Fixed priority. Processor has highest, backdoor has lowest
	MCM_CR_SRAMUAP_10 = 0x2
	// Fixed priority. Backdoor has highest, processor has lowest
	MCM_CR_SRAMUAP_11 = 0x3
	// Position of SRAMUWP field.
	MCM_CR_SRAMUWP_Pos = 0x1a
	// Bit mask of SRAMUWP field.
	MCM_CR_SRAMUWP_Msk = 0x4000000
	// Bit SRAMUWP.
	MCM_CR_SRAMUWP = 0x4000000
	// Position of SRAMLAP field.
	MCM_CR_SRAMLAP_Pos = 0x1c
	// Bit mask of SRAMLAP field.
	MCM_CR_SRAMLAP_Msk = 0x30000000
	// Round robin
	MCM_CR_SRAMLAP_00 = 0x0
	// Special round robin (favors SRAM backoor accesses over the processor)
	MCM_CR_SRAMLAP_01 = 0x1
	// Fixed priority. Processor has highest, backdoor has lowest
	MCM_CR_SRAMLAP_10 = 0x2
	// Fixed priority. Backdoor has highest, processor has lowest
	MCM_CR_SRAMLAP_11 = 0x3
	// Position of SRAMLWP field.
	MCM_CR_SRAMLWP_Pos = 0x1e
	// Bit mask of SRAMLWP field.
	MCM_CR_SRAMLWP_Msk = 0x40000000
	// Bit SRAMLWP.
	MCM_CR_SRAMLWP = 0x40000000

	// ISCR: Interrupt Status Register
	// Position of IRQ field.
	MCM_ISCR_IRQ_Pos = 0x1
	// Bit mask of IRQ field.
	MCM_ISCR_IRQ_Msk = 0x2
	// Bit IRQ.
	MCM_ISCR_IRQ = 0x2
	// No pending interrupt
	MCM_ISCR_IRQ_0 = 0x0
	// Due to the ETB counter expiring, a normal interrupt is pending
	MCM_ISCR_IRQ_1 = 0x1
	// Position of NMI field.
	MCM_ISCR_NMI_Pos = 0x2
	// Bit mask of NMI field.
	MCM_ISCR_NMI_Msk = 0x4
	// Bit NMI.
	MCM_ISCR_NMI = 0x4
	// No pending NMI
	MCM_ISCR_NMI_0 = 0x0
	// Due to the ETB counter expiring, an NMI is pending
	MCM_ISCR_NMI_1 = 0x1
	// Position of DHREQ field.
	MCM_ISCR_DHREQ_Pos = 0x3
	// Bit mask of DHREQ field.
	MCM_ISCR_DHREQ_Msk = 0x8
	// Bit DHREQ.
	MCM_ISCR_DHREQ = 0x8
	// No debug halt request
	MCM_ISCR_DHREQ_0 = 0x0
	// Debug halt request initiated
	MCM_ISCR_DHREQ_1 = 0x1
	// Position of FIOC field.
	MCM_ISCR_FIOC_Pos = 0x8
	// Bit mask of FIOC field.
	MCM_ISCR_FIOC_Msk = 0x100
	// Bit FIOC.
	MCM_ISCR_FIOC = 0x100
	// No interrupt
	MCM_ISCR_FIOC_0 = 0x0
	// Interrupt occurred
	MCM_ISCR_FIOC_1 = 0x1
	// Position of FDZC field.
	MCM_ISCR_FDZC_Pos = 0x9
	// Bit mask of FDZC field.
	MCM_ISCR_FDZC_Msk = 0x200
	// Bit FDZC.
	MCM_ISCR_FDZC = 0x200
	// No interrupt
	MCM_ISCR_FDZC_0 = 0x0
	// Interrupt occurred
	MCM_ISCR_FDZC_1 = 0x1
	// Position of FOFC field.
	MCM_ISCR_FOFC_Pos = 0xa
	// Bit mask of FOFC field.
	MCM_ISCR_FOFC_Msk = 0x400
	// Bit FOFC.
	MCM_ISCR_FOFC = 0x400
	// No interrupt
	MCM_ISCR_FOFC_0 = 0x0
	// Interrupt occurred
	MCM_ISCR_FOFC_1 = 0x1
	// Position of FUFC field.
	MCM_ISCR_FUFC_Pos = 0xb
	// Bit mask of FUFC field.
	MCM_ISCR_FUFC_Msk = 0x800
	// Bit FUFC.
	MCM_ISCR_FUFC = 0x800
	// No interrupt
	MCM_ISCR_FUFC_0 = 0x0
	// Interrupt occurred
	MCM_ISCR_FUFC_1 = 0x1
	// Position of FIXC field.
	MCM_ISCR_FIXC_Pos = 0xc
	// Bit mask of FIXC field.
	MCM_ISCR_FIXC_Msk = 0x1000
	// Bit FIXC.
	MCM_ISCR_FIXC = 0x1000
	// No interrupt
	MCM_ISCR_FIXC_0 = 0x0
	// Interrupt occurred
	MCM_ISCR_FIXC_1 = 0x1
	// Position of FIDC field.
	MCM_ISCR_FIDC_Pos = 0xf
	// Bit mask of FIDC field.
	MCM_ISCR_FIDC_Msk = 0x8000
	// Bit FIDC.
	MCM_ISCR_FIDC = 0x8000
	// No interrupt
	MCM_ISCR_FIDC_0 = 0x0
	// Interrupt occurred
	MCM_ISCR_FIDC_1 = 0x1
	// Position of FIOCE field.
	MCM_ISCR_FIOCE_Pos = 0x18
	// Bit mask of FIOCE field.
	MCM_ISCR_FIOCE_Msk = 0x1000000
	// Bit FIOCE.
	MCM_ISCR_FIOCE = 0x1000000
	// Disable interrupt
	MCM_ISCR_FIOCE_0 = 0x0
	// Enable interrupt
	MCM_ISCR_FIOCE_1 = 0x1
	// Position of FDZCE field.
	MCM_ISCR_FDZCE_Pos = 0x19
	// Bit mask of FDZCE field.
	MCM_ISCR_FDZCE_Msk = 0x2000000
	// Bit FDZCE.
	MCM_ISCR_FDZCE = 0x2000000
	// Disable interrupt
	MCM_ISCR_FDZCE_0 = 0x0
	// Enable interrupt
	MCM_ISCR_FDZCE_1 = 0x1
	// Position of FOFCE field.
	MCM_ISCR_FOFCE_Pos = 0x1a
	// Bit mask of FOFCE field.
	MCM_ISCR_FOFCE_Msk = 0x4000000
	// Bit FOFCE.
	MCM_ISCR_FOFCE = 0x4000000
	// Disable interrupt
	MCM_ISCR_FOFCE_0 = 0x0
	// Enable interrupt
	MCM_ISCR_FOFCE_1 = 0x1
	// Position of FUFCE field.
	MCM_ISCR_FUFCE_Pos = 0x1b
	// Bit mask of FUFCE field.
	MCM_ISCR_FUFCE_Msk = 0x8000000
	// Bit FUFCE.
	MCM_ISCR_FUFCE = 0x8000000
	// Disable interrupt
	MCM_ISCR_FUFCE_0 = 0x0
	// Enable interrupt
	MCM_ISCR_FUFCE_1 = 0x1
	// Position of FIXCE field.
	MCM_ISCR_FIXCE_Pos = 0x1c
	// Bit mask of FIXCE field.
	MCM_ISCR_FIXCE_Msk = 0x10000000
	// Bit FIXCE.
	MCM_ISCR_FIXCE = 0x10000000
	// Disable interrupt
	MCM_ISCR_FIXCE_0 = 0x0
	// Enable interrupt
	MCM_ISCR_FIXCE_1 = 0x1
	// Position of FIDCE field.
	MCM_ISCR_FIDCE_Pos = 0x1f
	// Bit mask of FIDCE field.
	MCM_ISCR_FIDCE_Msk = 0x80000000
	// Bit FIDCE.
	MCM_ISCR_FIDCE = 0x80000000
	// Disable interrupt
	MCM_ISCR_FIDCE_0 = 0x0
	// Enable interrupt
	MCM_ISCR_FIDCE_1 = 0x1

	// ETBCC: ETB Counter Control register
	// Position of CNTEN field.
	MCM_ETBCC_CNTEN_Pos = 0x0
	// Bit mask of CNTEN field.
	MCM_ETBCC_CNTEN_Msk = 0x1
	// Bit CNTEN.
	MCM_ETBCC_CNTEN = 0x1
	// ETB counter disabled
	MCM_ETBCC_CNTEN_0 = 0x0
	// ETB counter enabled
	MCM_ETBCC_CNTEN_1 = 0x1
	// Position of RSPT field.
	MCM_ETBCC_RSPT_Pos = 0x1
	// Bit mask of RSPT field.
	MCM_ETBCC_RSPT_Msk = 0x6
	// No response when the ETB count expires
	MCM_ETBCC_RSPT_00 = 0x0
	// Generate a normal interrupt when the ETB count expires
	MCM_ETBCC_RSPT_01 = 0x1
	// Generate an NMI when the ETB count expires
	MCM_ETBCC_RSPT_10 = 0x2
	// Generate a debug halt when the ETB count expires
	MCM_ETBCC_RSPT_11 = 0x3
	// Position of RLRQ field.
	MCM_ETBCC_RLRQ_Pos = 0x3
	// Bit mask of RLRQ field.
	MCM_ETBCC_RLRQ_Msk = 0x8
	// Bit RLRQ.
	MCM_ETBCC_RLRQ = 0x8
	// No effect
	MCM_ETBCC_RLRQ_0 = 0x0
	// Clears pending debug halt, NMI, or IRQ interrupt requests
	MCM_ETBCC_RLRQ_1 = 0x1
	// Position of ETDIS field.
	MCM_ETBCC_ETDIS_Pos = 0x4
	// Bit mask of ETDIS field.
	MCM_ETBCC_ETDIS_Msk = 0x10
	// Bit ETDIS.
	MCM_ETBCC_ETDIS = 0x10
	// ETM-to-TPIU trace path enabled
	MCM_ETBCC_ETDIS_0 = 0x0
	// ETM-to-TPIU trace path disabled
	MCM_ETBCC_ETDIS_1 = 0x1
	// Position of ITDIS field.
	MCM_ETBCC_ITDIS_Pos = 0x5
	// Bit mask of ITDIS field.
	MCM_ETBCC_ITDIS_Msk = 0x20
	// Bit ITDIS.
	MCM_ETBCC_ITDIS = 0x20
	// ITM-to-TPIU trace path enabled
	MCM_ETBCC_ITDIS_0 = 0x0
	// ITM-to-TPIU trace path disabled
	MCM_ETBCC_ITDIS_1 = 0x1

	// ETBRL: ETB Reload register
	// Position of RELOAD field.
	MCM_ETBRL_RELOAD_Pos = 0x0
	// Bit mask of RELOAD field.
	MCM_ETBRL_RELOAD_Msk = 0x7ff

	// ETBCNT: ETB Counter Value register
	// Position of COUNTER field.
	MCM_ETBCNT_COUNTER_Pos = 0x0
	// Bit mask of COUNTER field.
	MCM_ETBCNT_COUNTER_Msk = 0x7ff

	// PID: Process ID register
	// Position of PID field.
	MCM_PID_PID_Pos = 0x0
	// Bit mask of PID field.
	MCM_PID_PID_Msk = 0xff
)

// Constants for CAU: Memory Mapped Cryptographic Acceleration Unit (MMCAU)
const (
	// CAU_DIRECT0: Direct access register 0
	// Position of CAU_DIRECT0 field.
	CAU_CAU_DIRECT0_CAU_DIRECT0_Pos = 0x0
	// Bit mask of CAU_DIRECT0 field.
	CAU_CAU_DIRECT0_CAU_DIRECT0_Msk = 0xffffffff

	// CAU_DIRECT1: Direct access register 1
	// Position of CAU_DIRECT1 field.
	CAU_CAU_DIRECT1_CAU_DIRECT1_Pos = 0x0
	// Bit mask of CAU_DIRECT1 field.
	CAU_CAU_DIRECT1_CAU_DIRECT1_Msk = 0xffffffff

	// CAU_DIRECT2: Direct access register 2
	// Position of CAU_DIRECT2 field.
	CAU_CAU_DIRECT2_CAU_DIRECT2_Pos = 0x0
	// Bit mask of CAU_DIRECT2 field.
	CAU_CAU_DIRECT2_CAU_DIRECT2_Msk = 0xffffffff

	// CAU_DIRECT3: Direct access register 3
	// Position of CAU_DIRECT3 field.
	CAU_CAU_DIRECT3_CAU_DIRECT3_Pos = 0x0
	// Bit mask of CAU_DIRECT3 field.
	CAU_CAU_DIRECT3_CAU_DIRECT3_Msk = 0xffffffff

	// CAU_DIRECT4: Direct access register 4
	// Position of CAU_DIRECT4 field.
	CAU_CAU_DIRECT4_CAU_DIRECT4_Pos = 0x0
	// Bit mask of CAU_DIRECT4 field.
	CAU_CAU_DIRECT4_CAU_DIRECT4_Msk = 0xffffffff

	// CAU_DIRECT5: Direct access register 5
	// Position of CAU_DIRECT5 field.
	CAU_CAU_DIRECT5_CAU_DIRECT5_Pos = 0x0
	// Bit mask of CAU_DIRECT5 field.
	CAU_CAU_DIRECT5_CAU_DIRECT5_Msk = 0xffffffff

	// CAU_DIRECT6: Direct access register 6
	// Position of CAU_DIRECT6 field.
	CAU_CAU_DIRECT6_CAU_DIRECT6_Pos = 0x0
	// Bit mask of CAU_DIRECT6 field.
	CAU_CAU_DIRECT6_CAU_DIRECT6_Msk = 0xffffffff

	// CAU_DIRECT7: Direct access register 7
	// Position of CAU_DIRECT7 field.
	CAU_CAU_DIRECT7_CAU_DIRECT7_Pos = 0x0
	// Bit mask of CAU_DIRECT7 field.
	CAU_CAU_DIRECT7_CAU_DIRECT7_Msk = 0xffffffff

	// CAU_DIRECT8: Direct access register 8
	// Position of CAU_DIRECT8 field.
	CAU_CAU_DIRECT8_CAU_DIRECT8_Pos = 0x0
	// Bit mask of CAU_DIRECT8 field.
	CAU_CAU_DIRECT8_CAU_DIRECT8_Msk = 0xffffffff

	// CAU_DIRECT9: Direct access register 9
	// Position of CAU_DIRECT9 field.
	CAU_CAU_DIRECT9_CAU_DIRECT9_Pos = 0x0
	// Bit mask of CAU_DIRECT9 field.
	CAU_CAU_DIRECT9_CAU_DIRECT9_Msk = 0xffffffff

	// CAU_DIRECT10: Direct access register 10
	// Position of CAU_DIRECT10 field.
	CAU_CAU_DIRECT10_CAU_DIRECT10_Pos = 0x0
	// Bit mask of CAU_DIRECT10 field.
	CAU_CAU_DIRECT10_CAU_DIRECT10_Msk = 0xffffffff

	// CAU_DIRECT11: Direct access register 11
	// Position of CAU_DIRECT11 field.
	CAU_CAU_DIRECT11_CAU_DIRECT11_Pos = 0x0
	// Bit mask of CAU_DIRECT11 field.
	CAU_CAU_DIRECT11_CAU_DIRECT11_Msk = 0xffffffff

	// CAU_DIRECT12: Direct access register 12
	// Position of CAU_DIRECT12 field.
	CAU_CAU_DIRECT12_CAU_DIRECT12_Pos = 0x0
	// Bit mask of CAU_DIRECT12 field.
	CAU_CAU_DIRECT12_CAU_DIRECT12_Msk = 0xffffffff

	// CAU_DIRECT13: Direct access register 13
	// Position of CAU_DIRECT13 field.
	CAU_CAU_DIRECT13_CAU_DIRECT13_Pos = 0x0
	// Bit mask of CAU_DIRECT13 field.
	CAU_CAU_DIRECT13_CAU_DIRECT13_Msk = 0xffffffff

	// CAU_DIRECT14: Direct access register 14
	// Position of CAU_DIRECT14 field.
	CAU_CAU_DIRECT14_CAU_DIRECT14_Pos = 0x0
	// Bit mask of CAU_DIRECT14 field.
	CAU_CAU_DIRECT14_CAU_DIRECT14_Msk = 0xffffffff

	// CAU_DIRECT15: Direct access register 15
	// Position of CAU_DIRECT15 field.
	CAU_CAU_DIRECT15_CAU_DIRECT15_Pos = 0x0
	// Bit mask of CAU_DIRECT15 field.
	CAU_CAU_DIRECT15_CAU_DIRECT15_Msk = 0xffffffff

	// CAU_LDR_CASR: Status register - Load Register command
	// Position of IC field.
	CAU_CAU_LDR_CASR_IC_Pos = 0x0
	// Bit mask of IC field.
	CAU_CAU_LDR_CASR_IC_Msk = 0x1
	// Bit IC.
	CAU_CAU_LDR_CASR_IC = 0x1
	// No illegal commands issued
	CAU_CAU_LDR_CASR_IC_0 = 0x0
	// Illegal command issued
	CAU_CAU_LDR_CASR_IC_1 = 0x1
	// Position of DPE field.
	CAU_CAU_LDR_CASR_DPE_Pos = 0x1
	// Bit mask of DPE field.
	CAU_CAU_LDR_CASR_DPE_Msk = 0x2
	// Bit DPE.
	CAU_CAU_LDR_CASR_DPE = 0x2
	// No error detected
	CAU_CAU_LDR_CASR_DPE_0 = 0x0
	// DES key parity error detected
	CAU_CAU_LDR_CASR_DPE_1 = 0x1
	// Position of VER field.
	CAU_CAU_LDR_CASR_VER_Pos = 0x1c
	// Bit mask of VER field.
	CAU_CAU_LDR_CASR_VER_Msk = 0xf0000000
	// Initial CAU version
	CAU_CAU_LDR_CASR_VER_0001 = 0x1
	// Second version, added support for SHA-256 algorithm.(This is the value on this device)
	CAU_CAU_LDR_CASR_VER_0010 = 0x2

	// CAU_LDR_CAA: Accumulator register - Load Register command
	// Position of ACC field.
	CAU_CAU_LDR_CAA_ACC_Pos = 0x0
	// Bit mask of ACC field.
	CAU_CAU_LDR_CAA_ACC_Msk = 0xffffffff

	// CAU_LDR_CA0: General Purpose Register 0 - Load Register command
	// Position of CA0 field.
	CAU_CAU_LDR_CA0_CA0_Pos = 0x0
	// Bit mask of CA0 field.
	CAU_CAU_LDR_CA0_CA0_Msk = 0xffffffff

	// CAU_LDR_CA1: General Purpose Register 1 - Load Register command
	// Position of CA1 field.
	CAU_CAU_LDR_CA1_CA1_Pos = 0x0
	// Bit mask of CA1 field.
	CAU_CAU_LDR_CA1_CA1_Msk = 0xffffffff

	// CAU_LDR_CA2: General Purpose Register 2 - Load Register command
	// Position of CA2 field.
	CAU_CAU_LDR_CA2_CA2_Pos = 0x0
	// Bit mask of CA2 field.
	CAU_CAU_LDR_CA2_CA2_Msk = 0xffffffff

	// CAU_LDR_CA3: General Purpose Register 3 - Load Register command
	// Position of CA3 field.
	CAU_CAU_LDR_CA3_CA3_Pos = 0x0
	// Bit mask of CA3 field.
	CAU_CAU_LDR_CA3_CA3_Msk = 0xffffffff

	// CAU_LDR_CA4: General Purpose Register 4 - Load Register command
	// Position of CA4 field.
	CAU_CAU_LDR_CA4_CA4_Pos = 0x0
	// Bit mask of CA4 field.
	CAU_CAU_LDR_CA4_CA4_Msk = 0xffffffff

	// CAU_LDR_CA5: General Purpose Register 5 - Load Register command
	// Position of CA5 field.
	CAU_CAU_LDR_CA5_CA5_Pos = 0x0
	// Bit mask of CA5 field.
	CAU_CAU_LDR_CA5_CA5_Msk = 0xffffffff

	// CAU_LDR_CA6: General Purpose Register 6 - Load Register command
	// Position of CA6 field.
	CAU_CAU_LDR_CA6_CA6_Pos = 0x0
	// Bit mask of CA6 field.
	CAU_CAU_LDR_CA6_CA6_Msk = 0xffffffff

	// CAU_LDR_CA7: General Purpose Register 7 - Load Register command
	// Position of CA7 field.
	CAU_CAU_LDR_CA7_CA7_Pos = 0x0
	// Bit mask of CA7 field.
	CAU_CAU_LDR_CA7_CA7_Msk = 0xffffffff

	// CAU_LDR_CA8: General Purpose Register 8 - Load Register command
	// Position of CA8 field.
	CAU_CAU_LDR_CA8_CA8_Pos = 0x0
	// Bit mask of CA8 field.
	CAU_CAU_LDR_CA8_CA8_Msk = 0xffffffff

	// CAU_STR_CASR: Status register - Store Register command
	// Position of IC field.
	CAU_CAU_STR_CASR_IC_Pos = 0x0
	// Bit mask of IC field.
	CAU_CAU_STR_CASR_IC_Msk = 0x1
	// Bit IC.
	CAU_CAU_STR_CASR_IC = 0x1
	// No illegal commands issued
	CAU_CAU_STR_CASR_IC_0 = 0x0
	// Illegal command issued
	CAU_CAU_STR_CASR_IC_1 = 0x1
	// Position of DPE field.
	CAU_CAU_STR_CASR_DPE_Pos = 0x1
	// Bit mask of DPE field.
	CAU_CAU_STR_CASR_DPE_Msk = 0x2
	// Bit DPE.
	CAU_CAU_STR_CASR_DPE = 0x2
	// No error detected
	CAU_CAU_STR_CASR_DPE_0 = 0x0
	// DES key parity error detected
	CAU_CAU_STR_CASR_DPE_1 = 0x1
	// Position of VER field.
	CAU_CAU_STR_CASR_VER_Pos = 0x1c
	// Bit mask of VER field.
	CAU_CAU_STR_CASR_VER_Msk = 0xf0000000
	// Initial CAU version
	CAU_CAU_STR_CASR_VER_0001 = 0x1
	// Second version, added support for SHA-256 algorithm.(This is the value on this device)
	CAU_CAU_STR_CASR_VER_0010 = 0x2

	// CAU_STR_CAA: Accumulator register - Store Register command
	// Position of ACC field.
	CAU_CAU_STR_CAA_ACC_Pos = 0x0
	// Bit mask of ACC field.
	CAU_CAU_STR_CAA_ACC_Msk = 0xffffffff

	// CAU_STR_CA0: General Purpose Register 0 - Store Register command
	// Position of CA0 field.
	CAU_CAU_STR_CA0_CA0_Pos = 0x0
	// Bit mask of CA0 field.
	CAU_CAU_STR_CA0_CA0_Msk = 0xffffffff

	// CAU_STR_CA1: General Purpose Register 1 - Store Register command
	// Position of CA1 field.
	CAU_CAU_STR_CA1_CA1_Pos = 0x0
	// Bit mask of CA1 field.
	CAU_CAU_STR_CA1_CA1_Msk = 0xffffffff

	// CAU_STR_CA2: General Purpose Register 2 - Store Register command
	// Position of CA2 field.
	CAU_CAU_STR_CA2_CA2_Pos = 0x0
	// Bit mask of CA2 field.
	CAU_CAU_STR_CA2_CA2_Msk = 0xffffffff

	// CAU_STR_CA3: General Purpose Register 3 - Store Register command
	// Position of CA3 field.
	CAU_CAU_STR_CA3_CA3_Pos = 0x0
	// Bit mask of CA3 field.
	CAU_CAU_STR_CA3_CA3_Msk = 0xffffffff

	// CAU_STR_CA4: General Purpose Register 4 - Store Register command
	// Position of CA4 field.
	CAU_CAU_STR_CA4_CA4_Pos = 0x0
	// Bit mask of CA4 field.
	CAU_CAU_STR_CA4_CA4_Msk = 0xffffffff

	// CAU_STR_CA5: General Purpose Register 5 - Store Register command
	// Position of CA5 field.
	CAU_CAU_STR_CA5_CA5_Pos = 0x0
	// Bit mask of CA5 field.
	CAU_CAU_STR_CA5_CA5_Msk = 0xffffffff

	// CAU_STR_CA6: General Purpose Register 6 - Store Register command
	// Position of CA6 field.
	CAU_CAU_STR_CA6_CA6_Pos = 0x0
	// Bit mask of CA6 field.
	CAU_CAU_STR_CA6_CA6_Msk = 0xffffffff

	// CAU_STR_CA7: General Purpose Register 7 - Store Register command
	// Position of CA7 field.
	CAU_CAU_STR_CA7_CA7_Pos = 0x0
	// Bit mask of CA7 field.
	CAU_CAU_STR_CA7_CA7_Msk = 0xffffffff

	// CAU_STR_CA8: General Purpose Register 8 - Store Register command
	// Position of CA8 field.
	CAU_CAU_STR_CA8_CA8_Pos = 0x0
	// Bit mask of CA8 field.
	CAU_CAU_STR_CA8_CA8_Msk = 0xffffffff

	// CAU_ADR_CASR: Status register - Add Register command
	// Position of IC field.
	CAU_CAU_ADR_CASR_IC_Pos = 0x0
	// Bit mask of IC field.
	CAU_CAU_ADR_CASR_IC_Msk = 0x1
	// Bit IC.
	CAU_CAU_ADR_CASR_IC = 0x1
	// No illegal commands issued
	CAU_CAU_ADR_CASR_IC_0 = 0x0
	// Illegal command issued
	CAU_CAU_ADR_CASR_IC_1 = 0x1
	// Position of DPE field.
	CAU_CAU_ADR_CASR_DPE_Pos = 0x1
	// Bit mask of DPE field.
	CAU_CAU_ADR_CASR_DPE_Msk = 0x2
	// Bit DPE.
	CAU_CAU_ADR_CASR_DPE = 0x2
	// No error detected
	CAU_CAU_ADR_CASR_DPE_0 = 0x0
	// DES key parity error detected
	CAU_CAU_ADR_CASR_DPE_1 = 0x1
	// Position of VER field.
	CAU_CAU_ADR_CASR_VER_Pos = 0x1c
	// Bit mask of VER field.
	CAU_CAU_ADR_CASR_VER_Msk = 0xf0000000
	// Initial CAU version
	CAU_CAU_ADR_CASR_VER_0001 = 0x1
	// Second version, added support for SHA-256 algorithm.(This is the value on this device)
	CAU_CAU_ADR_CASR_VER_0010 = 0x2

	// CAU_ADR_CAA: Accumulator register - Add to register command
	// Position of ACC field.
	CAU_CAU_ADR_CAA_ACC_Pos = 0x0
	// Bit mask of ACC field.
	CAU_CAU_ADR_CAA_ACC_Msk = 0xffffffff

	// CAU_ADR_CA0: General Purpose Register 0 - Add to register command
	// Position of CA0 field.
	CAU_CAU_ADR_CA0_CA0_Pos = 0x0
	// Bit mask of CA0 field.
	CAU_CAU_ADR_CA0_CA0_Msk = 0xffffffff

	// CAU_ADR_CA1: General Purpose Register 1 - Add to register command
	// Position of CA1 field.
	CAU_CAU_ADR_CA1_CA1_Pos = 0x0
	// Bit mask of CA1 field.
	CAU_CAU_ADR_CA1_CA1_Msk = 0xffffffff

	// CAU_ADR_CA2: General Purpose Register 2 - Add to register command
	// Position of CA2 field.
	CAU_CAU_ADR_CA2_CA2_Pos = 0x0
	// Bit mask of CA2 field.
	CAU_CAU_ADR_CA2_CA2_Msk = 0xffffffff

	// CAU_ADR_CA3: General Purpose Register 3 - Add to register command
	// Position of CA3 field.
	CAU_CAU_ADR_CA3_CA3_Pos = 0x0
	// Bit mask of CA3 field.
	CAU_CAU_ADR_CA3_CA3_Msk = 0xffffffff

	// CAU_ADR_CA4: General Purpose Register 4 - Add to register command
	// Position of CA4 field.
	CAU_CAU_ADR_CA4_CA4_Pos = 0x0
	// Bit mask of CA4 field.
	CAU_CAU_ADR_CA4_CA4_Msk = 0xffffffff

	// CAU_ADR_CA5: General Purpose Register 5 - Add to register command
	// Position of CA5 field.
	CAU_CAU_ADR_CA5_CA5_Pos = 0x0
	// Bit mask of CA5 field.
	CAU_CAU_ADR_CA5_CA5_Msk = 0xffffffff

	// CAU_ADR_CA6: General Purpose Register 6 - Add to register command
	// Position of CA6 field.
	CAU_CAU_ADR_CA6_CA6_Pos = 0x0
	// Bit mask of CA6 field.
	CAU_CAU_ADR_CA6_CA6_Msk = 0xffffffff

	// CAU_ADR_CA7: General Purpose Register 7 - Add to register command
	// Position of CA7 field.
	CAU_CAU_ADR_CA7_CA7_Pos = 0x0
	// Bit mask of CA7 field.
	CAU_CAU_ADR_CA7_CA7_Msk = 0xffffffff

	// CAU_ADR_CA8: General Purpose Register 8 - Add to register command
	// Position of CA8 field.
	CAU_CAU_ADR_CA8_CA8_Pos = 0x0
	// Bit mask of CA8 field.
	CAU_CAU_ADR_CA8_CA8_Msk = 0xffffffff

	// CAU_RADR_CASR: Status register - Reverse and Add to Register command
	// Position of IC field.
	CAU_CAU_RADR_CASR_IC_Pos = 0x0
	// Bit mask of IC field.
	CAU_CAU_RADR_CASR_IC_Msk = 0x1
	// Bit IC.
	CAU_CAU_RADR_CASR_IC = 0x1
	// No illegal commands issued
	CAU_CAU_RADR_CASR_IC_0 = 0x0
	// Illegal command issued
	CAU_CAU_RADR_CASR_IC_1 = 0x1
	// Position of DPE field.
	CAU_CAU_RADR_CASR_DPE_Pos = 0x1
	// Bit mask of DPE field.
	CAU_CAU_RADR_CASR_DPE_Msk = 0x2
	// Bit DPE.
	CAU_CAU_RADR_CASR_DPE = 0x2
	// No error detected
	CAU_CAU_RADR_CASR_DPE_0 = 0x0
	// DES key parity error detected
	CAU_CAU_RADR_CASR_DPE_1 = 0x1
	// Position of VER field.
	CAU_CAU_RADR_CASR_VER_Pos = 0x1c
	// Bit mask of VER field.
	CAU_CAU_RADR_CASR_VER_Msk = 0xf0000000
	// Initial CAU version
	CAU_CAU_RADR_CASR_VER_0001 = 0x1
	// Second version, added support for SHA-256 algorithm.(This is the value on this device)
	CAU_CAU_RADR_CASR_VER_0010 = 0x2

	// CAU_RADR_CAA: Accumulator register - Reverse and Add to Register command
	// Position of ACC field.
	CAU_CAU_RADR_CAA_ACC_Pos = 0x0
	// Bit mask of ACC field.
	CAU_CAU_RADR_CAA_ACC_Msk = 0xffffffff

	// CAU_RADR_CA0: General Purpose Register 0 - Reverse and Add to Register command
	// Position of CA0 field.
	CAU_CAU_RADR_CA0_CA0_Pos = 0x0
	// Bit mask of CA0 field.
	CAU_CAU_RADR_CA0_CA0_Msk = 0xffffffff

	// CAU_RADR_CA1: General Purpose Register 1 - Reverse and Add to Register command
	// Position of CA1 field.
	CAU_CAU_RADR_CA1_CA1_Pos = 0x0
	// Bit mask of CA1 field.
	CAU_CAU_RADR_CA1_CA1_Msk = 0xffffffff

	// CAU_RADR_CA2: General Purpose Register 2 - Reverse and Add to Register command
	// Position of CA2 field.
	CAU_CAU_RADR_CA2_CA2_Pos = 0x0
	// Bit mask of CA2 field.
	CAU_CAU_RADR_CA2_CA2_Msk = 0xffffffff

	// CAU_RADR_CA3: General Purpose Register 3 - Reverse and Add to Register command
	// Position of CA3 field.
	CAU_CAU_RADR_CA3_CA3_Pos = 0x0
	// Bit mask of CA3 field.
	CAU_CAU_RADR_CA3_CA3_Msk = 0xffffffff

	// CAU_RADR_CA4: General Purpose Register 4 - Reverse and Add to Register command
	// Position of CA4 field.
	CAU_CAU_RADR_CA4_CA4_Pos = 0x0
	// Bit mask of CA4 field.
	CAU_CAU_RADR_CA4_CA4_Msk = 0xffffffff

	// CAU_RADR_CA5: General Purpose Register 5 - Reverse and Add to Register command
	// Position of CA5 field.
	CAU_CAU_RADR_CA5_CA5_Pos = 0x0
	// Bit mask of CA5 field.
	CAU_CAU_RADR_CA5_CA5_Msk = 0xffffffff

	// CAU_RADR_CA6: General Purpose Register 6 - Reverse and Add to Register command
	// Position of CA6 field.
	CAU_CAU_RADR_CA6_CA6_Pos = 0x0
	// Bit mask of CA6 field.
	CAU_CAU_RADR_CA6_CA6_Msk = 0xffffffff

	// CAU_RADR_CA7: General Purpose Register 7 - Reverse and Add to Register command
	// Position of CA7 field.
	CAU_CAU_RADR_CA7_CA7_Pos = 0x0
	// Bit mask of CA7 field.
	CAU_CAU_RADR_CA7_CA7_Msk = 0xffffffff

	// CAU_RADR_CA8: General Purpose Register 8 - Reverse and Add to Register command
	// Position of CA8 field.
	CAU_CAU_RADR_CA8_CA8_Pos = 0x0
	// Bit mask of CA8 field.
	CAU_CAU_RADR_CA8_CA8_Msk = 0xffffffff

	// CAU_XOR_CASR: Status register - Exclusive Or command
	// Position of IC field.
	CAU_CAU_XOR_CASR_IC_Pos = 0x0
	// Bit mask of IC field.
	CAU_CAU_XOR_CASR_IC_Msk = 0x1
	// Bit IC.
	CAU_CAU_XOR_CASR_IC = 0x1
	// No illegal commands issued
	CAU_CAU_XOR_CASR_IC_0 = 0x0
	// Illegal command issued
	CAU_CAU_XOR_CASR_IC_1 = 0x1
	// Position of DPE field.
	CAU_CAU_XOR_CASR_DPE_Pos = 0x1
	// Bit mask of DPE field.
	CAU_CAU_XOR_CASR_DPE_Msk = 0x2
	// Bit DPE.
	CAU_CAU_XOR_CASR_DPE = 0x2
	// No error detected
	CAU_CAU_XOR_CASR_DPE_0 = 0x0
	// DES key parity error detected
	CAU_CAU_XOR_CASR_DPE_1 = 0x1
	// Position of VER field.
	CAU_CAU_XOR_CASR_VER_Pos = 0x1c
	// Bit mask of VER field.
	CAU_CAU_XOR_CASR_VER_Msk = 0xf0000000
	// Initial CAU version
	CAU_CAU_XOR_CASR_VER_0001 = 0x1
	// Second version, added support for SHA-256 algorithm.(This is the value on this device)
	CAU_CAU_XOR_CASR_VER_0010 = 0x2

	// CAU_XOR_CAA: Accumulator register - Exclusive Or command
	// Position of ACC field.
	CAU_CAU_XOR_CAA_ACC_Pos = 0x0
	// Bit mask of ACC field.
	CAU_CAU_XOR_CAA_ACC_Msk = 0xffffffff

	// CAU_XOR_CA0: General Purpose Register 0 - Exclusive Or command
	// Position of CA0 field.
	CAU_CAU_XOR_CA0_CA0_Pos = 0x0
	// Bit mask of CA0 field.
	CAU_CAU_XOR_CA0_CA0_Msk = 0xffffffff

	// CAU_XOR_CA1: General Purpose Register 1 - Exclusive Or command
	// Position of CA1 field.
	CAU_CAU_XOR_CA1_CA1_Pos = 0x0
	// Bit mask of CA1 field.
	CAU_CAU_XOR_CA1_CA1_Msk = 0xffffffff

	// CAU_XOR_CA2: General Purpose Register 2 - Exclusive Or command
	// Position of CA2 field.
	CAU_CAU_XOR_CA2_CA2_Pos = 0x0
	// Bit mask of CA2 field.
	CAU_CAU_XOR_CA2_CA2_Msk = 0xffffffff

	// CAU_XOR_CA3: General Purpose Register 3 - Exclusive Or command
	// Position of CA3 field.
	CAU_CAU_XOR_CA3_CA3_Pos = 0x0
	// Bit mask of CA3 field.
	CAU_CAU_XOR_CA3_CA3_Msk = 0xffffffff

	// CAU_XOR_CA4: General Purpose Register 4 - Exclusive Or command
	// Position of CA4 field.
	CAU_CAU_XOR_CA4_CA4_Pos = 0x0
	// Bit mask of CA4 field.
	CAU_CAU_XOR_CA4_CA4_Msk = 0xffffffff

	// CAU_XOR_CA5: General Purpose Register 5 - Exclusive Or command
	// Position of CA5 field.
	CAU_CAU_XOR_CA5_CA5_Pos = 0x0
	// Bit mask of CA5 field.
	CAU_CAU_XOR_CA5_CA5_Msk = 0xffffffff

	// CAU_XOR_CA6: General Purpose Register 6 - Exclusive Or command
	// Position of CA6 field.
	CAU_CAU_XOR_CA6_CA6_Pos = 0x0
	// Bit mask of CA6 field.
	CAU_CAU_XOR_CA6_CA6_Msk = 0xffffffff

	// CAU_XOR_CA7: General Purpose Register 7 - Exclusive Or command
	// Position of CA7 field.
	CAU_CAU_XOR_CA7_CA7_Pos = 0x0
	// Bit mask of CA7 field.
	CAU_CAU_XOR_CA7_CA7_Msk = 0xffffffff

	// CAU_XOR_CA8: General Purpose Register 8 - Exclusive Or command
	// Position of CA8 field.
	CAU_CAU_XOR_CA8_CA8_Pos = 0x0
	// Bit mask of CA8 field.
	CAU_CAU_XOR_CA8_CA8_Msk = 0xffffffff

	// CAU_ROTL_CASR: Status register - Rotate Left command
	// Position of IC field.
	CAU_CAU_ROTL_CASR_IC_Pos = 0x0
	// Bit mask of IC field.
	CAU_CAU_ROTL_CASR_IC_Msk = 0x1
	// Bit IC.
	CAU_CAU_ROTL_CASR_IC = 0x1
	// No illegal commands issued
	CAU_CAU_ROTL_CASR_IC_0 = 0x0
	// Illegal command issued
	CAU_CAU_ROTL_CASR_IC_1 = 0x1
	// Position of DPE field.
	CAU_CAU_ROTL_CASR_DPE_Pos = 0x1
	// Bit mask of DPE field.
	CAU_CAU_ROTL_CASR_DPE_Msk = 0x2
	// Bit DPE.
	CAU_CAU_ROTL_CASR_DPE = 0x2
	// No error detected
	CAU_CAU_ROTL_CASR_DPE_0 = 0x0
	// DES key parity error detected
	CAU_CAU_ROTL_CASR_DPE_1 = 0x1
	// Position of VER field.
	CAU_CAU_ROTL_CASR_VER_Pos = 0x1c
	// Bit mask of VER field.
	CAU_CAU_ROTL_CASR_VER_Msk = 0xf0000000
	// Initial CAU version
	CAU_CAU_ROTL_CASR_VER_0001 = 0x1
	// Second version, added support for SHA-256 algorithm.(This is the value on this device)
	CAU_CAU_ROTL_CASR_VER_0010 = 0x2

	// CAU_ROTL_CAA: Accumulator register - Rotate Left command
	// Position of ACC field.
	CAU_CAU_ROTL_CAA_ACC_Pos = 0x0
	// Bit mask of ACC field.
	CAU_CAU_ROTL_CAA_ACC_Msk = 0xffffffff

	// CAU_ROTL_CA0: General Purpose Register 0 - Rotate Left command
	// Position of CA0 field.
	CAU_CAU_ROTL_CA0_CA0_Pos = 0x0
	// Bit mask of CA0 field.
	CAU_CAU_ROTL_CA0_CA0_Msk = 0xffffffff

	// CAU_ROTL_CA1: General Purpose Register 1 - Rotate Left command
	// Position of CA1 field.
	CAU_CAU_ROTL_CA1_CA1_Pos = 0x0
	// Bit mask of CA1 field.
	CAU_CAU_ROTL_CA1_CA1_Msk = 0xffffffff

	// CAU_ROTL_CA2: General Purpose Register 2 - Rotate Left command
	// Position of CA2 field.
	CAU_CAU_ROTL_CA2_CA2_Pos = 0x0
	// Bit mask of CA2 field.
	CAU_CAU_ROTL_CA2_CA2_Msk = 0xffffffff

	// CAU_ROTL_CA3: General Purpose Register 3 - Rotate Left command
	// Position of CA3 field.
	CAU_CAU_ROTL_CA3_CA3_Pos = 0x0
	// Bit mask of CA3 field.
	CAU_CAU_ROTL_CA3_CA3_Msk = 0xffffffff

	// CAU_ROTL_CA4: General Purpose Register 4 - Rotate Left command
	// Position of CA4 field.
	CAU_CAU_ROTL_CA4_CA4_Pos = 0x0
	// Bit mask of CA4 field.
	CAU_CAU_ROTL_CA4_CA4_Msk = 0xffffffff

	// CAU_ROTL_CA5: General Purpose Register 5 - Rotate Left command
	// Position of CA5 field.
	CAU_CAU_ROTL_CA5_CA5_Pos = 0x0
	// Bit mask of CA5 field.
	CAU_CAU_ROTL_CA5_CA5_Msk = 0xffffffff

	// CAU_ROTL_CA6: General Purpose Register 6 - Rotate Left command
	// Position of CA6 field.
	CAU_CAU_ROTL_CA6_CA6_Pos = 0x0
	// Bit mask of CA6 field.
	CAU_CAU_ROTL_CA6_CA6_Msk = 0xffffffff

	// CAU_ROTL_CA7: General Purpose Register 7 - Rotate Left command
	// Position of CA7 field.
	CAU_CAU_ROTL_CA7_CA7_Pos = 0x0
	// Bit mask of CA7 field.
	CAU_CAU_ROTL_CA7_CA7_Msk = 0xffffffff

	// CAU_ROTL_CA8: General Purpose Register 8 - Rotate Left command
	// Position of CA8 field.
	CAU_CAU_ROTL_CA8_CA8_Pos = 0x0
	// Bit mask of CA8 field.
	CAU_CAU_ROTL_CA8_CA8_Msk = 0xffffffff

	// CAU_AESC_CASR: Status register - AES Column Operation command
	// Position of IC field.
	CAU_CAU_AESC_CASR_IC_Pos = 0x0
	// Bit mask of IC field.
	CAU_CAU_AESC_CASR_IC_Msk = 0x1
	// Bit IC.
	CAU_CAU_AESC_CASR_IC = 0x1
	// No illegal commands issued
	CAU_CAU_AESC_CASR_IC_0 = 0x0
	// Illegal command issued
	CAU_CAU_AESC_CASR_IC_1 = 0x1
	// Position of DPE field.
	CAU_CAU_AESC_CASR_DPE_Pos = 0x1
	// Bit mask of DPE field.
	CAU_CAU_AESC_CASR_DPE_Msk = 0x2
	// Bit DPE.
	CAU_CAU_AESC_CASR_DPE = 0x2
	// No error detected
	CAU_CAU_AESC_CASR_DPE_0 = 0x0
	// DES key parity error detected
	CAU_CAU_AESC_CASR_DPE_1 = 0x1
	// Position of VER field.
	CAU_CAU_AESC_CASR_VER_Pos = 0x1c
	// Bit mask of VER field.
	CAU_CAU_AESC_CASR_VER_Msk = 0xf0000000
	// Initial CAU version
	CAU_CAU_AESC_CASR_VER_0001 = 0x1
	// Second version, added support for SHA-256 algorithm.(This is the value on this device)
	CAU_CAU_AESC_CASR_VER_0010 = 0x2

	// CAU_AESC_CAA: Accumulator register - AES Column Operation command
	// Position of ACC field.
	CAU_CAU_AESC_CAA_ACC_Pos = 0x0
	// Bit mask of ACC field.
	CAU_CAU_AESC_CAA_ACC_Msk = 0xffffffff

	// CAU_AESC_CA0: General Purpose Register 0 - AES Column Operation command
	// Position of CA0 field.
	CAU_CAU_AESC_CA0_CA0_Pos = 0x0
	// Bit mask of CA0 field.
	CAU_CAU_AESC_CA0_CA0_Msk = 0xffffffff

	// CAU_AESC_CA1: General Purpose Register 1 - AES Column Operation command
	// Position of CA1 field.
	CAU_CAU_AESC_CA1_CA1_Pos = 0x0
	// Bit mask of CA1 field.
	CAU_CAU_AESC_CA1_CA1_Msk = 0xffffffff

	// CAU_AESC_CA2: General Purpose Register 2 - AES Column Operation command
	// Position of CA2 field.
	CAU_CAU_AESC_CA2_CA2_Pos = 0x0
	// Bit mask of CA2 field.
	CAU_CAU_AESC_CA2_CA2_Msk = 0xffffffff

	// CAU_AESC_CA3: General Purpose Register 3 - AES Column Operation command
	// Position of CA3 field.
	CAU_CAU_AESC_CA3_CA3_Pos = 0x0
	// Bit mask of CA3 field.
	CAU_CAU_AESC_CA3_CA3_Msk = 0xffffffff

	// CAU_AESC_CA4: General Purpose Register 4 - AES Column Operation command
	// Position of CA4 field.
	CAU_CAU_AESC_CA4_CA4_Pos = 0x0
	// Bit mask of CA4 field.
	CAU_CAU_AESC_CA4_CA4_Msk = 0xffffffff

	// CAU_AESC_CA5: General Purpose Register 5 - AES Column Operation command
	// Position of CA5 field.
	CAU_CAU_AESC_CA5_CA5_Pos = 0x0
	// Bit mask of CA5 field.
	CAU_CAU_AESC_CA5_CA5_Msk = 0xffffffff

	// CAU_AESC_CA6: General Purpose Register 6 - AES Column Operation command
	// Position of CA6 field.
	CAU_CAU_AESC_CA6_CA6_Pos = 0x0
	// Bit mask of CA6 field.
	CAU_CAU_AESC_CA6_CA6_Msk = 0xffffffff

	// CAU_AESC_CA7: General Purpose Register 7 - AES Column Operation command
	// Position of CA7 field.
	CAU_CAU_AESC_CA7_CA7_Pos = 0x0
	// Bit mask of CA7 field.
	CAU_CAU_AESC_CA7_CA7_Msk = 0xffffffff

	// CAU_AESC_CA8: General Purpose Register 8 - AES Column Operation command
	// Position of CA8 field.
	CAU_CAU_AESC_CA8_CA8_Pos = 0x0
	// Bit mask of CA8 field.
	CAU_CAU_AESC_CA8_CA8_Msk = 0xffffffff

	// CAU_AESIC_CASR: Status register - AES Inverse Column Operation command
	// Position of IC field.
	CAU_CAU_AESIC_CASR_IC_Pos = 0x0
	// Bit mask of IC field.
	CAU_CAU_AESIC_CASR_IC_Msk = 0x1
	// Bit IC.
	CAU_CAU_AESIC_CASR_IC = 0x1
	// No illegal commands issued
	CAU_CAU_AESIC_CASR_IC_0 = 0x0
	// Illegal command issued
	CAU_CAU_AESIC_CASR_IC_1 = 0x1
	// Position of DPE field.
	CAU_CAU_AESIC_CASR_DPE_Pos = 0x1
	// Bit mask of DPE field.
	CAU_CAU_AESIC_CASR_DPE_Msk = 0x2
	// Bit DPE.
	CAU_CAU_AESIC_CASR_DPE = 0x2
	// No error detected
	CAU_CAU_AESIC_CASR_DPE_0 = 0x0
	// DES key parity error detected
	CAU_CAU_AESIC_CASR_DPE_1 = 0x1
	// Position of VER field.
	CAU_CAU_AESIC_CASR_VER_Pos = 0x1c
	// Bit mask of VER field.
	CAU_CAU_AESIC_CASR_VER_Msk = 0xf0000000
	// Initial CAU version
	CAU_CAU_AESIC_CASR_VER_0001 = 0x1
	// Second version, added support for SHA-256 algorithm.(This is the value on this device)
	CAU_CAU_AESIC_CASR_VER_0010 = 0x2

	// CAU_AESIC_CAA: Accumulator register - AES Inverse Column Operation command
	// Position of ACC field.
	CAU_CAU_AESIC_CAA_ACC_Pos = 0x0
	// Bit mask of ACC field.
	CAU_CAU_AESIC_CAA_ACC_Msk = 0xffffffff

	// CAU_AESIC_CA0: General Purpose Register 0 - AES Inverse Column Operation command
	// Position of CA0 field.
	CAU_CAU_AESIC_CA0_CA0_Pos = 0x0
	// Bit mask of CA0 field.
	CAU_CAU_AESIC_CA0_CA0_Msk = 0xffffffff

	// CAU_AESIC_CA1: General Purpose Register 1 - AES Inverse Column Operation command
	// Position of CA1 field.
	CAU_CAU_AESIC_CA1_CA1_Pos = 0x0
	// Bit mask of CA1 field.
	CAU_CAU_AESIC_CA1_CA1_Msk = 0xffffffff

	// CAU_AESIC_CA2: General Purpose Register 2 - AES Inverse Column Operation command
	// Position of CA2 field.
	CAU_CAU_AESIC_CA2_CA2_Pos = 0x0
	// Bit mask of CA2 field.
	CAU_CAU_AESIC_CA2_CA2_Msk = 0xffffffff

	// CAU_AESIC_CA3: General Purpose Register 3 - AES Inverse Column Operation command
	// Position of CA3 field.
	CAU_CAU_AESIC_CA3_CA3_Pos = 0x0
	// Bit mask of CA3 field.
	CAU_CAU_AESIC_CA3_CA3_Msk = 0xffffffff

	// CAU_AESIC_CA4: General Purpose Register 4 - AES Inverse Column Operation command
	// Position of CA4 field.
	CAU_CAU_AESIC_CA4_CA4_Pos = 0x0
	// Bit mask of CA4 field.
	CAU_CAU_AESIC_CA4_CA4_Msk = 0xffffffff

	// CAU_AESIC_CA5: General Purpose Register 5 - AES Inverse Column Operation command
	// Position of CA5 field.
	CAU_CAU_AESIC_CA5_CA5_Pos = 0x0
	// Bit mask of CA5 field.
	CAU_CAU_AESIC_CA5_CA5_Msk = 0xffffffff

	// CAU_AESIC_CA6: General Purpose Register 6 - AES Inverse Column Operation command
	// Position of CA6 field.
	CAU_CAU_AESIC_CA6_CA6_Pos = 0x0
	// Bit mask of CA6 field.
	CAU_CAU_AESIC_CA6_CA6_Msk = 0xffffffff

	// CAU_AESIC_CA7: General Purpose Register 7 - AES Inverse Column Operation command
	// Position of CA7 field.
	CAU_CAU_AESIC_CA7_CA7_Pos = 0x0
	// Bit mask of CA7 field.
	CAU_CAU_AESIC_CA7_CA7_Msk = 0xffffffff

	// CAU_AESIC_CA8: General Purpose Register 8 - AES Inverse Column Operation command
	// Position of CA8 field.
	CAU_CAU_AESIC_CA8_CA8_Pos = 0x0
	// Bit mask of CA8 field.
	CAU_CAU_AESIC_CA8_CA8_Msk = 0xffffffff
)
