// Automatically generated file. DO NOT EDIT.
// Generated by gen-device-svd.go from QN908XC.svd, see https://github.com/posborne/cmsis-svd/tree/master/data/NXP

//go:build nxp && qn908xc

/*
// QN9080C, QN9083C
*/

package nxp

import (
	"github.com/goplus/emb/runtime/volatile"
	"unsafe"
)

// Some information about this device.
const (
	Device       = "QN908XC"
	CPU          = "CM4"
	FPUPresent   = true
	NVICPrioBits = 3
)

// Interrupt numbers.
const (
	// Highest interrupt number on this device.
	IRQ_max = 0
)

// Pseudo function call that is replaced by the compiler with the actual
// functions registered through interrupt.New.
//
// NOTE(zzy): runtime/interrupt.callHandlers is not yet implemented in LLGO
// Original linkname: //go:linkname callHandlers runtime/interrupt.callHandlers
func callHandlers(num int) {
	// TODO: implement interrupt handler dispatch mechanism
}

// Peripherals.
var (
	// syscon
	SYSCON = (*SYSCON_Type)(unsafe.Pointer(uintptr(0x40000000)))

	// wdog
	WDT = (*WDT_Type)(unsafe.Pointer(uintptr(0x40001000)))

	// timer
	CTIMER0 = (*CTIMER_Type)(unsafe.Pointer(uintptr(0x40002000)))

	// QN908X Pin interrupt and pattern match (PINT)
	PINT = (*PINT_Type)(unsafe.Pointer(uintptr(0x40006000)))

	// dmamux
	INPUTMUX = (*INPUTMUX_Type)(unsafe.Pointer(uintptr(0x40006200)))

	// adc
	ADC = (*ADC_Type)(unsafe.Pointer(uintptr(0x40007000)))

	// dac
	DAC = (*DAC_Type)(unsafe.Pointer(uintptr(0x40007400)))

	// tsc
	CS = (*CS_Type)(unsafe.Pointer(uintptr(0x40007800)))

	// rng
	RNG = (*RNG_Type)(unsafe.Pointer(uintptr(0x40007c00)))

	// qdec
	QDEC0 = (*QDEC_Type)(unsafe.Pointer(uintptr(0x40009000)))

	// rtc
	RTC = (*RTC_Type)(unsafe.Pointer(uintptr(0x4000b000)))

	// agc
	AGC = (*AGC_Type)(unsafe.Pointer(uintptr(0x4000c000)))

	// prop
	PROP = (*PROP_Type)(unsafe.Pointer(uintptr(0x4000d000)))

	// bledp
	BLEDP = (*BLEDP_Type)(unsafe.Pointer(uintptr(0x4000e000)))

	// calib
	CALIB = (*CALIB_Type)(unsafe.Pointer(uintptr(0x4000f000)))

	// spifi
	SPIFI0 = (*SPIFI_Type)(unsafe.Pointer(uintptr(0x40080000)))

	// flash
	FLASH = (*FLASH_Type)(unsafe.Pointer(uintptr(0x40081000)))

	// LPC5411x DMA controller
	DMA0 = (*DMA_Type)(unsafe.Pointer(uintptr(0x40082000)))

	// flexcomm
	FLEXCOMM0 = (*FLEXCOMM_Type)(unsafe.Pointer(uintptr(0x40083000)))

	// usart
	USART0 = (*USART_Type)(unsafe.Pointer(uintptr(0x40083000)))

	// usb
	USB0 = (*USB_Type)(unsafe.Pointer(uintptr(0x40084000)))

	// LPC5411x SCTimer/PWM (SCT)
	SCT0 = (*SCT_Type)(unsafe.Pointer(uintptr(0x40085000)))

	// i2c
	I2C0 = (*I2C_Type)(unsafe.Pointer(uintptr(0x40086000)))

	// spi
	SPI0 = (*SPI_Type)(unsafe.Pointer(uintptr(0x40087000)))

	// fsp
	FSP = (*FSP_Type)(unsafe.Pointer(uintptr(0x40088000)))

	// gpio
	GPIOA = (*GPIO_Type)(unsafe.Pointer(uintptr(0x4008c000)))

	// crc
	CRC_ENGINE = (*CRC_Type)(unsafe.Pointer(uintptr(0x4008e000)))

	// timer
	CTIMER1 = (*CTIMER_Type)(unsafe.Pointer(uintptr(0x40003000)))

	// timer
	CTIMER2 = (*CTIMER_Type)(unsafe.Pointer(uintptr(0x40004000)))

	// timer
	CTIMER3 = (*CTIMER_Type)(unsafe.Pointer(uintptr(0x40005000)))

	// qdec
	QDEC1 = (*QDEC_Type)(unsafe.Pointer(uintptr(0x40009800)))

	// flexcomm
	FLEXCOMM1 = (*FLEXCOMM_Type)(unsafe.Pointer(uintptr(0x40086000)))

	// flexcomm
	FLEXCOMM2 = (*FLEXCOMM_Type)(unsafe.Pointer(uintptr(0x40087000)))

	// flexcomm
	FLEXCOMM3 = (*FLEXCOMM_Type)(unsafe.Pointer(uintptr(0x4008f000)))

	// usart
	USART1 = (*USART_Type)(unsafe.Pointer(uintptr(0x40086000)))

	// i2c
	I2C1 = (*I2C_Type)(unsafe.Pointer(uintptr(0x40087000)))

	// spi
	SPI1 = (*SPI_Type)(unsafe.Pointer(uintptr(0x4008f000)))

	// gpio
	GPIOB = (*GPIO_Type)(unsafe.Pointer(uintptr(0x4008d000)))
)

// syscon
type SYSCON_Type struct {
	RST_SW_SET      volatile.Register32 // 0x0
	RST_SW_CLR      volatile.Register32 // 0x4
	CLK_DIS         volatile.Register32 // 0x8
	CLK_EN          volatile.Register32 // 0xC
	CLK_CTRL        volatile.Register32 // 0x10
	SYS_MODE_CTRL   volatile.Register32 // 0x14
	_               [104]byte
	SYS_STAT        volatile.Register32 // 0x80
	_               [124]byte
	SYS_TICK        volatile.Register32 // 0x100
	SRAM_CTRL       volatile.Register32 // 0x104
	CHIP_ID         volatile.Register32 // 0x108
	_               [4]byte
	ANA_CTRL0       volatile.Register32 // 0x110
	_               [108]byte
	XTAL_CTRL       volatile.Register32 // 0x180
	BUCK            volatile.Register32 // 0x184
	_               [120]byte
	FC_FRG          volatile.Register32 // 0x200
	_               [1532]byte
	PIO_PULL_CFG0   volatile.Register32 // 0x800
	PIO_PULL_CFG1   volatile.Register32 // 0x804
	PIO_PULL_CFG2   volatile.Register32 // 0x808
	IO_CAP          volatile.Register32 // 0x80C
	PIO_DRV_CFG0    volatile.Register32 // 0x810
	PIO_DRV_CFG1    volatile.Register32 // 0x814
	PIO_DRV_CFG2    volatile.Register32 // 0x818
	PIO_CFG_MISC    volatile.Register32 // 0x81C
	PIO_WAKEUP_LVL0 volatile.Register32 // 0x820
	PIO_WAKEUP_LVL1 volatile.Register32 // 0x824
	PIO_IE_CFG0     volatile.Register32 // 0x828
	PIO_IE_CFG1     volatile.Register32 // 0x82C
	PIO_FUNC_CFG0   volatile.Register32 // 0x830
	PIO_FUNC_CFG1   volatile.Register32 // 0x834
	PIO_FUNC_CFG2   volatile.Register32 // 0x838
	PIO_FUNC_CFG3   volatile.Register32 // 0x83C
	PIO_WAKEUP_EN0  volatile.Register32 // 0x840
	PIO_WAKEUP_EN1  volatile.Register32 // 0x844
	PIO_CAP_OE0     volatile.Register32 // 0x848
	PIO_CAP_OE1     volatile.Register32 // 0x84C
	PIO_CAP_OUT0    volatile.Register32 // 0x850
	PIO_CAP_OUT1    volatile.Register32 // 0x854
	RST_CAUSE_SRC   volatile.Register32 // 0x858
	PMU_CTRL0       volatile.Register32 // 0x85C
	PMU_CTRL1       volatile.Register32 // 0x860
	ANA_EN          volatile.Register32 // 0x864
	XTAL32K_CTRL    volatile.Register32 // 0x868
	USB_CFG         volatile.Register32 // 0x86C
	_               [16]byte
	PMU_CTRL2       volatile.Register32 // 0x880
	ANA_CTRL1       volatile.Register32 // 0x884
	_               [8]byte
	MISC            volatile.Register32 // 0x890
}

// SYSCON.RST_SW_SET: block software reset set register
func (o *SYSCON_Type) SetRST_SW_SET_SET_FC0_RST(value uint32) {
	volatile.StoreUint32(&o.RST_SW_SET.Reg, volatile.LoadUint32(&o.RST_SW_SET.Reg)&^(0x1)|value)
}
func (o *SYSCON_Type) GetRST_SW_SET_SET_FC0_RST() uint32 {
	return volatile.LoadUint32(&o.RST_SW_SET.Reg) & 0x1
}
func (o *SYSCON_Type) SetRST_SW_SET_SET_FC1_RST(value uint32) {
	volatile.StoreUint32(&o.RST_SW_SET.Reg, volatile.LoadUint32(&o.RST_SW_SET.Reg)&^(0x2)|value<<1)
}
func (o *SYSCON_Type) GetRST_SW_SET_SET_FC1_RST() uint32 {
	return (volatile.LoadUint32(&o.RST_SW_SET.Reg) & 0x2) >> 1
}
func (o *SYSCON_Type) SetRST_SW_SET_SET_FC2_RST(value uint32) {
	volatile.StoreUint32(&o.RST_SW_SET.Reg, volatile.LoadUint32(&o.RST_SW_SET.Reg)&^(0x4)|value<<2)
}
func (o *SYSCON_Type) GetRST_SW_SET_SET_FC2_RST() uint32 {
	return (volatile.LoadUint32(&o.RST_SW_SET.Reg) & 0x4) >> 2
}
func (o *SYSCON_Type) SetRST_SW_SET_SET_FC3_RST(value uint32) {
	volatile.StoreUint32(&o.RST_SW_SET.Reg, volatile.LoadUint32(&o.RST_SW_SET.Reg)&^(0x8)|value<<3)
}
func (o *SYSCON_Type) GetRST_SW_SET_SET_FC3_RST() uint32 {
	return (volatile.LoadUint32(&o.RST_SW_SET.Reg) & 0x8) >> 3
}
func (o *SYSCON_Type) SetRST_SW_SET_SET_TIM0_RST(value uint32) {
	volatile.StoreUint32(&o.RST_SW_SET.Reg, volatile.LoadUint32(&o.RST_SW_SET.Reg)&^(0x10)|value<<4)
}
func (o *SYSCON_Type) GetRST_SW_SET_SET_TIM0_RST() uint32 {
	return (volatile.LoadUint32(&o.RST_SW_SET.Reg) & 0x10) >> 4
}
func (o *SYSCON_Type) SetRST_SW_SET_SET_TIM1_RST(value uint32) {
	volatile.StoreUint32(&o.RST_SW_SET.Reg, volatile.LoadUint32(&o.RST_SW_SET.Reg)&^(0x20)|value<<5)
}
func (o *SYSCON_Type) GetRST_SW_SET_SET_TIM1_RST() uint32 {
	return (volatile.LoadUint32(&o.RST_SW_SET.Reg) & 0x20) >> 5
}
func (o *SYSCON_Type) SetRST_SW_SET_SET_TIM2_RST(value uint32) {
	volatile.StoreUint32(&o.RST_SW_SET.Reg, volatile.LoadUint32(&o.RST_SW_SET.Reg)&^(0x40)|value<<6)
}
func (o *SYSCON_Type) GetRST_SW_SET_SET_TIM2_RST() uint32 {
	return (volatile.LoadUint32(&o.RST_SW_SET.Reg) & 0x40) >> 6
}
func (o *SYSCON_Type) SetRST_SW_SET_SET_TIM3_RST(value uint32) {
	volatile.StoreUint32(&o.RST_SW_SET.Reg, volatile.LoadUint32(&o.RST_SW_SET.Reg)&^(0x80)|value<<7)
}
func (o *SYSCON_Type) GetRST_SW_SET_SET_TIM3_RST() uint32 {
	return (volatile.LoadUint32(&o.RST_SW_SET.Reg) & 0x80) >> 7
}
func (o *SYSCON_Type) SetRST_SW_SET_SET_SCT_RST(value uint32) {
	volatile.StoreUint32(&o.RST_SW_SET.Reg, volatile.LoadUint32(&o.RST_SW_SET.Reg)&^(0x100)|value<<8)
}
func (o *SYSCON_Type) GetRST_SW_SET_SET_SCT_RST() uint32 {
	return (volatile.LoadUint32(&o.RST_SW_SET.Reg) & 0x100) >> 8
}
func (o *SYSCON_Type) SetRST_SW_SET_SET_WDT_RST(value uint32) {
	volatile.StoreUint32(&o.RST_SW_SET.Reg, volatile.LoadUint32(&o.RST_SW_SET.Reg)&^(0x200)|value<<9)
}
func (o *SYSCON_Type) GetRST_SW_SET_SET_WDT_RST() uint32 {
	return (volatile.LoadUint32(&o.RST_SW_SET.Reg) & 0x200) >> 9
}
func (o *SYSCON_Type) SetRST_SW_SET_SET_USB_RST(value uint32) {
	volatile.StoreUint32(&o.RST_SW_SET.Reg, volatile.LoadUint32(&o.RST_SW_SET.Reg)&^(0x400)|value<<10)
}
func (o *SYSCON_Type) GetRST_SW_SET_SET_USB_RST() uint32 {
	return (volatile.LoadUint32(&o.RST_SW_SET.Reg) & 0x400) >> 10
}
func (o *SYSCON_Type) SetRST_SW_SET_SET_GPIO_RST(value uint32) {
	volatile.StoreUint32(&o.RST_SW_SET.Reg, volatile.LoadUint32(&o.RST_SW_SET.Reg)&^(0x800)|value<<11)
}
func (o *SYSCON_Type) GetRST_SW_SET_SET_GPIO_RST() uint32 {
	return (volatile.LoadUint32(&o.RST_SW_SET.Reg) & 0x800) >> 11
}
func (o *SYSCON_Type) SetRST_SW_SET_SET_RTC_RST(value uint32) {
	volatile.StoreUint32(&o.RST_SW_SET.Reg, volatile.LoadUint32(&o.RST_SW_SET.Reg)&^(0x1000)|value<<12)
}
func (o *SYSCON_Type) GetRST_SW_SET_SET_RTC_RST() uint32 {
	return (volatile.LoadUint32(&o.RST_SW_SET.Reg) & 0x1000) >> 12
}
func (o *SYSCON_Type) SetRST_SW_SET_SET_ADC_RST(value uint32) {
	volatile.StoreUint32(&o.RST_SW_SET.Reg, volatile.LoadUint32(&o.RST_SW_SET.Reg)&^(0x2000)|value<<13)
}
func (o *SYSCON_Type) GetRST_SW_SET_SET_ADC_RST() uint32 {
	return (volatile.LoadUint32(&o.RST_SW_SET.Reg) & 0x2000) >> 13
}
func (o *SYSCON_Type) SetRST_SW_SET_SET_DAC_RST(value uint32) {
	volatile.StoreUint32(&o.RST_SW_SET.Reg, volatile.LoadUint32(&o.RST_SW_SET.Reg)&^(0x4000)|value<<14)
}
func (o *SYSCON_Type) GetRST_SW_SET_SET_DAC_RST() uint32 {
	return (volatile.LoadUint32(&o.RST_SW_SET.Reg) & 0x4000) >> 14
}
func (o *SYSCON_Type) SetRST_SW_SET_SET_CS_RST(value uint32) {
	volatile.StoreUint32(&o.RST_SW_SET.Reg, volatile.LoadUint32(&o.RST_SW_SET.Reg)&^(0x8000)|value<<15)
}
func (o *SYSCON_Type) GetRST_SW_SET_SET_CS_RST() uint32 {
	return (volatile.LoadUint32(&o.RST_SW_SET.Reg) & 0x8000) >> 15
}
func (o *SYSCON_Type) SetRST_SW_SET_SET_FSP_RST(value uint32) {
	volatile.StoreUint32(&o.RST_SW_SET.Reg, volatile.LoadUint32(&o.RST_SW_SET.Reg)&^(0x10000)|value<<16)
}
func (o *SYSCON_Type) GetRST_SW_SET_SET_FSP_RST() uint32 {
	return (volatile.LoadUint32(&o.RST_SW_SET.Reg) & 0x10000) >> 16
}
func (o *SYSCON_Type) SetRST_SW_SET_SET_DMA_RST(value uint32) {
	volatile.StoreUint32(&o.RST_SW_SET.Reg, volatile.LoadUint32(&o.RST_SW_SET.Reg)&^(0x20000)|value<<17)
}
func (o *SYSCON_Type) GetRST_SW_SET_SET_DMA_RST() uint32 {
	return (volatile.LoadUint32(&o.RST_SW_SET.Reg) & 0x20000) >> 17
}
func (o *SYSCON_Type) SetRST_SW_SET_SET_QDEC0_RST(value uint32) {
	volatile.StoreUint32(&o.RST_SW_SET.Reg, volatile.LoadUint32(&o.RST_SW_SET.Reg)&^(0x80000)|value<<19)
}
func (o *SYSCON_Type) GetRST_SW_SET_SET_QDEC0_RST() uint32 {
	return (volatile.LoadUint32(&o.RST_SW_SET.Reg) & 0x80000) >> 19
}
func (o *SYSCON_Type) SetRST_SW_SET_SET_QDEC1_RST(value uint32) {
	volatile.StoreUint32(&o.RST_SW_SET.Reg, volatile.LoadUint32(&o.RST_SW_SET.Reg)&^(0x100000)|value<<20)
}
func (o *SYSCON_Type) GetRST_SW_SET_SET_QDEC1_RST() uint32 {
	return (volatile.LoadUint32(&o.RST_SW_SET.Reg) & 0x100000) >> 20
}
func (o *SYSCON_Type) SetRST_SW_SET_SET_SPIFI_RST(value uint32) {
	volatile.StoreUint32(&o.RST_SW_SET.Reg, volatile.LoadUint32(&o.RST_SW_SET.Reg)&^(0x400000)|value<<22)
}
func (o *SYSCON_Type) GetRST_SW_SET_SET_SPIFI_RST() uint32 {
	return (volatile.LoadUint32(&o.RST_SW_SET.Reg) & 0x400000) >> 22
}
func (o *SYSCON_Type) SetRST_SW_SET_SET_CPU_RST(value uint32) {
	volatile.StoreUint32(&o.RST_SW_SET.Reg, volatile.LoadUint32(&o.RST_SW_SET.Reg)&^(0x4000000)|value<<26)
}
func (o *SYSCON_Type) GetRST_SW_SET_SET_CPU_RST() uint32 {
	return (volatile.LoadUint32(&o.RST_SW_SET.Reg) & 0x4000000) >> 26
}
func (o *SYSCON_Type) SetRST_SW_SET_SET_BLE_RST(value uint32) {
	volatile.StoreUint32(&o.RST_SW_SET.Reg, volatile.LoadUint32(&o.RST_SW_SET.Reg)&^(0x8000000)|value<<27)
}
func (o *SYSCON_Type) GetRST_SW_SET_SET_BLE_RST() uint32 {
	return (volatile.LoadUint32(&o.RST_SW_SET.Reg) & 0x8000000) >> 27
}
func (o *SYSCON_Type) SetRST_SW_SET_SET_FLASH_RST(value uint32) {
	volatile.StoreUint32(&o.RST_SW_SET.Reg, volatile.LoadUint32(&o.RST_SW_SET.Reg)&^(0x10000000)|value<<28)
}
func (o *SYSCON_Type) GetRST_SW_SET_SET_FLASH_RST() uint32 {
	return (volatile.LoadUint32(&o.RST_SW_SET.Reg) & 0x10000000) >> 28
}
func (o *SYSCON_Type) SetRST_SW_SET_SET_DP_RST(value uint32) {
	volatile.StoreUint32(&o.RST_SW_SET.Reg, volatile.LoadUint32(&o.RST_SW_SET.Reg)&^(0x20000000)|value<<29)
}
func (o *SYSCON_Type) GetRST_SW_SET_SET_DP_RST() uint32 {
	return (volatile.LoadUint32(&o.RST_SW_SET.Reg) & 0x20000000) >> 29
}
func (o *SYSCON_Type) SetRST_SW_SET_SET_REG_RST(value uint32) {
	volatile.StoreUint32(&o.RST_SW_SET.Reg, volatile.LoadUint32(&o.RST_SW_SET.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSCON_Type) GetRST_SW_SET_SET_REG_RST() uint32 {
	return (volatile.LoadUint32(&o.RST_SW_SET.Reg) & 0x40000000) >> 30
}
func (o *SYSCON_Type) SetRST_SW_SET_SET_REBOOT(value uint32) {
	volatile.StoreUint32(&o.RST_SW_SET.Reg, volatile.LoadUint32(&o.RST_SW_SET.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSCON_Type) GetRST_SW_SET_SET_REBOOT() uint32 {
	return (volatile.LoadUint32(&o.RST_SW_SET.Reg) & 0x80000000) >> 31
}

// SYSCON.RST_SW_CLR: block software reset clear register
func (o *SYSCON_Type) SetRST_SW_CLR_CLR_FC0_RST(value uint32) {
	volatile.StoreUint32(&o.RST_SW_CLR.Reg, volatile.LoadUint32(&o.RST_SW_CLR.Reg)&^(0x1)|value)
}
func (o *SYSCON_Type) GetRST_SW_CLR_CLR_FC0_RST() uint32 {
	return volatile.LoadUint32(&o.RST_SW_CLR.Reg) & 0x1
}
func (o *SYSCON_Type) SetRST_SW_CLR_CLR_FC1_RST(value uint32) {
	volatile.StoreUint32(&o.RST_SW_CLR.Reg, volatile.LoadUint32(&o.RST_SW_CLR.Reg)&^(0x2)|value<<1)
}
func (o *SYSCON_Type) GetRST_SW_CLR_CLR_FC1_RST() uint32 {
	return (volatile.LoadUint32(&o.RST_SW_CLR.Reg) & 0x2) >> 1
}
func (o *SYSCON_Type) SetRST_SW_CLR_CLR_FC2_RST(value uint32) {
	volatile.StoreUint32(&o.RST_SW_CLR.Reg, volatile.LoadUint32(&o.RST_SW_CLR.Reg)&^(0x4)|value<<2)
}
func (o *SYSCON_Type) GetRST_SW_CLR_CLR_FC2_RST() uint32 {
	return (volatile.LoadUint32(&o.RST_SW_CLR.Reg) & 0x4) >> 2
}
func (o *SYSCON_Type) SetRST_SW_CLR_CLR_FC3_RST(value uint32) {
	volatile.StoreUint32(&o.RST_SW_CLR.Reg, volatile.LoadUint32(&o.RST_SW_CLR.Reg)&^(0x8)|value<<3)
}
func (o *SYSCON_Type) GetRST_SW_CLR_CLR_FC3_RST() uint32 {
	return (volatile.LoadUint32(&o.RST_SW_CLR.Reg) & 0x8) >> 3
}
func (o *SYSCON_Type) SetRST_SW_CLR_CLR_TIM0_RST(value uint32) {
	volatile.StoreUint32(&o.RST_SW_CLR.Reg, volatile.LoadUint32(&o.RST_SW_CLR.Reg)&^(0x10)|value<<4)
}
func (o *SYSCON_Type) GetRST_SW_CLR_CLR_TIM0_RST() uint32 {
	return (volatile.LoadUint32(&o.RST_SW_CLR.Reg) & 0x10) >> 4
}
func (o *SYSCON_Type) SetRST_SW_CLR_CLR_TIM1_RST(value uint32) {
	volatile.StoreUint32(&o.RST_SW_CLR.Reg, volatile.LoadUint32(&o.RST_SW_CLR.Reg)&^(0x20)|value<<5)
}
func (o *SYSCON_Type) GetRST_SW_CLR_CLR_TIM1_RST() uint32 {
	return (volatile.LoadUint32(&o.RST_SW_CLR.Reg) & 0x20) >> 5
}
func (o *SYSCON_Type) SetRST_SW_CLR_CLR_TIM2_RST(value uint32) {
	volatile.StoreUint32(&o.RST_SW_CLR.Reg, volatile.LoadUint32(&o.RST_SW_CLR.Reg)&^(0x40)|value<<6)
}
func (o *SYSCON_Type) GetRST_SW_CLR_CLR_TIM2_RST() uint32 {
	return (volatile.LoadUint32(&o.RST_SW_CLR.Reg) & 0x40) >> 6
}
func (o *SYSCON_Type) SetRST_SW_CLR_CLR_TIM3_RST(value uint32) {
	volatile.StoreUint32(&o.RST_SW_CLR.Reg, volatile.LoadUint32(&o.RST_SW_CLR.Reg)&^(0x80)|value<<7)
}
func (o *SYSCON_Type) GetRST_SW_CLR_CLR_TIM3_RST() uint32 {
	return (volatile.LoadUint32(&o.RST_SW_CLR.Reg) & 0x80) >> 7
}
func (o *SYSCON_Type) SetRST_SW_CLR_CLR_SCT_RST(value uint32) {
	volatile.StoreUint32(&o.RST_SW_CLR.Reg, volatile.LoadUint32(&o.RST_SW_CLR.Reg)&^(0x100)|value<<8)
}
func (o *SYSCON_Type) GetRST_SW_CLR_CLR_SCT_RST() uint32 {
	return (volatile.LoadUint32(&o.RST_SW_CLR.Reg) & 0x100) >> 8
}
func (o *SYSCON_Type) SetRST_SW_CLR_CLR_WDT_RST(value uint32) {
	volatile.StoreUint32(&o.RST_SW_CLR.Reg, volatile.LoadUint32(&o.RST_SW_CLR.Reg)&^(0x200)|value<<9)
}
func (o *SYSCON_Type) GetRST_SW_CLR_CLR_WDT_RST() uint32 {
	return (volatile.LoadUint32(&o.RST_SW_CLR.Reg) & 0x200) >> 9
}
func (o *SYSCON_Type) SetRST_SW_CLR_CLR_USB_RST(value uint32) {
	volatile.StoreUint32(&o.RST_SW_CLR.Reg, volatile.LoadUint32(&o.RST_SW_CLR.Reg)&^(0x400)|value<<10)
}
func (o *SYSCON_Type) GetRST_SW_CLR_CLR_USB_RST() uint32 {
	return (volatile.LoadUint32(&o.RST_SW_CLR.Reg) & 0x400) >> 10
}
func (o *SYSCON_Type) SetRST_SW_CLR_CLR_GPIO_RST(value uint32) {
	volatile.StoreUint32(&o.RST_SW_CLR.Reg, volatile.LoadUint32(&o.RST_SW_CLR.Reg)&^(0x800)|value<<11)
}
func (o *SYSCON_Type) GetRST_SW_CLR_CLR_GPIO_RST() uint32 {
	return (volatile.LoadUint32(&o.RST_SW_CLR.Reg) & 0x800) >> 11
}
func (o *SYSCON_Type) SetRST_SW_CLR_CLR_RTC_RST(value uint32) {
	volatile.StoreUint32(&o.RST_SW_CLR.Reg, volatile.LoadUint32(&o.RST_SW_CLR.Reg)&^(0x1000)|value<<12)
}
func (o *SYSCON_Type) GetRST_SW_CLR_CLR_RTC_RST() uint32 {
	return (volatile.LoadUint32(&o.RST_SW_CLR.Reg) & 0x1000) >> 12
}
func (o *SYSCON_Type) SetRST_SW_CLR_CLR_ADC_RST(value uint32) {
	volatile.StoreUint32(&o.RST_SW_CLR.Reg, volatile.LoadUint32(&o.RST_SW_CLR.Reg)&^(0x2000)|value<<13)
}
func (o *SYSCON_Type) GetRST_SW_CLR_CLR_ADC_RST() uint32 {
	return (volatile.LoadUint32(&o.RST_SW_CLR.Reg) & 0x2000) >> 13
}
func (o *SYSCON_Type) SetRST_SW_CLR_CLR_DAC_RST(value uint32) {
	volatile.StoreUint32(&o.RST_SW_CLR.Reg, volatile.LoadUint32(&o.RST_SW_CLR.Reg)&^(0x4000)|value<<14)
}
func (o *SYSCON_Type) GetRST_SW_CLR_CLR_DAC_RST() uint32 {
	return (volatile.LoadUint32(&o.RST_SW_CLR.Reg) & 0x4000) >> 14
}
func (o *SYSCON_Type) SetRST_SW_CLR_CLR_CS_RST(value uint32) {
	volatile.StoreUint32(&o.RST_SW_CLR.Reg, volatile.LoadUint32(&o.RST_SW_CLR.Reg)&^(0x8000)|value<<15)
}
func (o *SYSCON_Type) GetRST_SW_CLR_CLR_CS_RST() uint32 {
	return (volatile.LoadUint32(&o.RST_SW_CLR.Reg) & 0x8000) >> 15
}
func (o *SYSCON_Type) SetRST_SW_CLR_CLR_FSP_RST(value uint32) {
	volatile.StoreUint32(&o.RST_SW_CLR.Reg, volatile.LoadUint32(&o.RST_SW_CLR.Reg)&^(0x10000)|value<<16)
}
func (o *SYSCON_Type) GetRST_SW_CLR_CLR_FSP_RST() uint32 {
	return (volatile.LoadUint32(&o.RST_SW_CLR.Reg) & 0x10000) >> 16
}
func (o *SYSCON_Type) SetRST_SW_CLR_CLR_DMA_RST(value uint32) {
	volatile.StoreUint32(&o.RST_SW_CLR.Reg, volatile.LoadUint32(&o.RST_SW_CLR.Reg)&^(0x20000)|value<<17)
}
func (o *SYSCON_Type) GetRST_SW_CLR_CLR_DMA_RST() uint32 {
	return (volatile.LoadUint32(&o.RST_SW_CLR.Reg) & 0x20000) >> 17
}
func (o *SYSCON_Type) SetRST_SW_CLR_CLR_QDEC0_RST(value uint32) {
	volatile.StoreUint32(&o.RST_SW_CLR.Reg, volatile.LoadUint32(&o.RST_SW_CLR.Reg)&^(0x80000)|value<<19)
}
func (o *SYSCON_Type) GetRST_SW_CLR_CLR_QDEC0_RST() uint32 {
	return (volatile.LoadUint32(&o.RST_SW_CLR.Reg) & 0x80000) >> 19
}
func (o *SYSCON_Type) SetRST_SW_CLR_CLR_QDEC1_RST(value uint32) {
	volatile.StoreUint32(&o.RST_SW_CLR.Reg, volatile.LoadUint32(&o.RST_SW_CLR.Reg)&^(0x100000)|value<<20)
}
func (o *SYSCON_Type) GetRST_SW_CLR_CLR_QDEC1_RST() uint32 {
	return (volatile.LoadUint32(&o.RST_SW_CLR.Reg) & 0x100000) >> 20
}
func (o *SYSCON_Type) SetRST_SW_CLR_CLR_SPIFI_RST(value uint32) {
	volatile.StoreUint32(&o.RST_SW_CLR.Reg, volatile.LoadUint32(&o.RST_SW_CLR.Reg)&^(0x400000)|value<<22)
}
func (o *SYSCON_Type) GetRST_SW_CLR_CLR_SPIFI_RST() uint32 {
	return (volatile.LoadUint32(&o.RST_SW_CLR.Reg) & 0x400000) >> 22
}
func (o *SYSCON_Type) SetRST_SW_CLR_CLR_CPU_RST(value uint32) {
	volatile.StoreUint32(&o.RST_SW_CLR.Reg, volatile.LoadUint32(&o.RST_SW_CLR.Reg)&^(0x4000000)|value<<26)
}
func (o *SYSCON_Type) GetRST_SW_CLR_CLR_CPU_RST() uint32 {
	return (volatile.LoadUint32(&o.RST_SW_CLR.Reg) & 0x4000000) >> 26
}
func (o *SYSCON_Type) SetRST_SW_CLR_CLR_BLE_RST(value uint32) {
	volatile.StoreUint32(&o.RST_SW_CLR.Reg, volatile.LoadUint32(&o.RST_SW_CLR.Reg)&^(0x8000000)|value<<27)
}
func (o *SYSCON_Type) GetRST_SW_CLR_CLR_BLE_RST() uint32 {
	return (volatile.LoadUint32(&o.RST_SW_CLR.Reg) & 0x8000000) >> 27
}
func (o *SYSCON_Type) SetRST_SW_CLR_CLR_FLASH_RST(value uint32) {
	volatile.StoreUint32(&o.RST_SW_CLR.Reg, volatile.LoadUint32(&o.RST_SW_CLR.Reg)&^(0x10000000)|value<<28)
}
func (o *SYSCON_Type) GetRST_SW_CLR_CLR_FLASH_RST() uint32 {
	return (volatile.LoadUint32(&o.RST_SW_CLR.Reg) & 0x10000000) >> 28
}
func (o *SYSCON_Type) SetRST_SW_CLR_CLR_DP_RST(value uint32) {
	volatile.StoreUint32(&o.RST_SW_CLR.Reg, volatile.LoadUint32(&o.RST_SW_CLR.Reg)&^(0x20000000)|value<<29)
}
func (o *SYSCON_Type) GetRST_SW_CLR_CLR_DP_RST() uint32 {
	return (volatile.LoadUint32(&o.RST_SW_CLR.Reg) & 0x20000000) >> 29
}
func (o *SYSCON_Type) SetRST_SW_CLR_CLR_REG_RST(value uint32) {
	volatile.StoreUint32(&o.RST_SW_CLR.Reg, volatile.LoadUint32(&o.RST_SW_CLR.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSCON_Type) GetRST_SW_CLR_CLR_REG_RST() uint32 {
	return (volatile.LoadUint32(&o.RST_SW_CLR.Reg) & 0x40000000) >> 30
}

// SYSCON.CLK_DIS: clock disable register
func (o *SYSCON_Type) SetCLK_DIS_CLK_FC0_DIS(value uint32) {
	volatile.StoreUint32(&o.CLK_DIS.Reg, volatile.LoadUint32(&o.CLK_DIS.Reg)&^(0x1)|value)
}
func (o *SYSCON_Type) GetCLK_DIS_CLK_FC0_DIS() uint32 {
	return volatile.LoadUint32(&o.CLK_DIS.Reg) & 0x1
}
func (o *SYSCON_Type) SetCLK_DIS_CLK_FC1_DIS(value uint32) {
	volatile.StoreUint32(&o.CLK_DIS.Reg, volatile.LoadUint32(&o.CLK_DIS.Reg)&^(0x2)|value<<1)
}
func (o *SYSCON_Type) GetCLK_DIS_CLK_FC1_DIS() uint32 {
	return (volatile.LoadUint32(&o.CLK_DIS.Reg) & 0x2) >> 1
}
func (o *SYSCON_Type) SetCLK_DIS_CLK_FC2_DIS(value uint32) {
	volatile.StoreUint32(&o.CLK_DIS.Reg, volatile.LoadUint32(&o.CLK_DIS.Reg)&^(0x4)|value<<2)
}
func (o *SYSCON_Type) GetCLK_DIS_CLK_FC2_DIS() uint32 {
	return (volatile.LoadUint32(&o.CLK_DIS.Reg) & 0x4) >> 2
}
func (o *SYSCON_Type) SetCLK_DIS_CLK_FC3_DIS(value uint32) {
	volatile.StoreUint32(&o.CLK_DIS.Reg, volatile.LoadUint32(&o.CLK_DIS.Reg)&^(0x8)|value<<3)
}
func (o *SYSCON_Type) GetCLK_DIS_CLK_FC3_DIS() uint32 {
	return (volatile.LoadUint32(&o.CLK_DIS.Reg) & 0x8) >> 3
}
func (o *SYSCON_Type) SetCLK_DIS_CLK_TIM0_DIS(value uint32) {
	volatile.StoreUint32(&o.CLK_DIS.Reg, volatile.LoadUint32(&o.CLK_DIS.Reg)&^(0x10)|value<<4)
}
func (o *SYSCON_Type) GetCLK_DIS_CLK_TIM0_DIS() uint32 {
	return (volatile.LoadUint32(&o.CLK_DIS.Reg) & 0x10) >> 4
}
func (o *SYSCON_Type) SetCLK_DIS_CLK_TIM1_DIS(value uint32) {
	volatile.StoreUint32(&o.CLK_DIS.Reg, volatile.LoadUint32(&o.CLK_DIS.Reg)&^(0x20)|value<<5)
}
func (o *SYSCON_Type) GetCLK_DIS_CLK_TIM1_DIS() uint32 {
	return (volatile.LoadUint32(&o.CLK_DIS.Reg) & 0x20) >> 5
}
func (o *SYSCON_Type) SetCLK_DIS_CLK_TIM2_DIS(value uint32) {
	volatile.StoreUint32(&o.CLK_DIS.Reg, volatile.LoadUint32(&o.CLK_DIS.Reg)&^(0x40)|value<<6)
}
func (o *SYSCON_Type) GetCLK_DIS_CLK_TIM2_DIS() uint32 {
	return (volatile.LoadUint32(&o.CLK_DIS.Reg) & 0x40) >> 6
}
func (o *SYSCON_Type) SetCLK_DIS_CLK_TIM3_DIS(value uint32) {
	volatile.StoreUint32(&o.CLK_DIS.Reg, volatile.LoadUint32(&o.CLK_DIS.Reg)&^(0x80)|value<<7)
}
func (o *SYSCON_Type) GetCLK_DIS_CLK_TIM3_DIS() uint32 {
	return (volatile.LoadUint32(&o.CLK_DIS.Reg) & 0x80) >> 7
}
func (o *SYSCON_Type) SetCLK_DIS_CLK_SCT_DIS(value uint32) {
	volatile.StoreUint32(&o.CLK_DIS.Reg, volatile.LoadUint32(&o.CLK_DIS.Reg)&^(0x100)|value<<8)
}
func (o *SYSCON_Type) GetCLK_DIS_CLK_SCT_DIS() uint32 {
	return (volatile.LoadUint32(&o.CLK_DIS.Reg) & 0x100) >> 8
}
func (o *SYSCON_Type) SetCLK_DIS_CLK_WDT_DIS(value uint32) {
	volatile.StoreUint32(&o.CLK_DIS.Reg, volatile.LoadUint32(&o.CLK_DIS.Reg)&^(0x200)|value<<9)
}
func (o *SYSCON_Type) GetCLK_DIS_CLK_WDT_DIS() uint32 {
	return (volatile.LoadUint32(&o.CLK_DIS.Reg) & 0x200) >> 9
}
func (o *SYSCON_Type) SetCLK_DIS_CLK_USB_DIS(value uint32) {
	volatile.StoreUint32(&o.CLK_DIS.Reg, volatile.LoadUint32(&o.CLK_DIS.Reg)&^(0x400)|value<<10)
}
func (o *SYSCON_Type) GetCLK_DIS_CLK_USB_DIS() uint32 {
	return (volatile.LoadUint32(&o.CLK_DIS.Reg) & 0x400) >> 10
}
func (o *SYSCON_Type) SetCLK_DIS_CLK_GPIO_DIS(value uint32) {
	volatile.StoreUint32(&o.CLK_DIS.Reg, volatile.LoadUint32(&o.CLK_DIS.Reg)&^(0x800)|value<<11)
}
func (o *SYSCON_Type) GetCLK_DIS_CLK_GPIO_DIS() uint32 {
	return (volatile.LoadUint32(&o.CLK_DIS.Reg) & 0x800) >> 11
}
func (o *SYSCON_Type) SetCLK_DIS_CLK_BIV_DIS(value uint32) {
	volatile.StoreUint32(&o.CLK_DIS.Reg, volatile.LoadUint32(&o.CLK_DIS.Reg)&^(0x1000)|value<<12)
}
func (o *SYSCON_Type) GetCLK_DIS_CLK_BIV_DIS() uint32 {
	return (volatile.LoadUint32(&o.CLK_DIS.Reg) & 0x1000) >> 12
}
func (o *SYSCON_Type) SetCLK_DIS_CLK_ADC_DIS(value uint32) {
	volatile.StoreUint32(&o.CLK_DIS.Reg, volatile.LoadUint32(&o.CLK_DIS.Reg)&^(0x2000)|value<<13)
}
func (o *SYSCON_Type) GetCLK_DIS_CLK_ADC_DIS() uint32 {
	return (volatile.LoadUint32(&o.CLK_DIS.Reg) & 0x2000) >> 13
}
func (o *SYSCON_Type) SetCLK_DIS_CLK_DAC_DIS(value uint32) {
	volatile.StoreUint32(&o.CLK_DIS.Reg, volatile.LoadUint32(&o.CLK_DIS.Reg)&^(0x4000)|value<<14)
}
func (o *SYSCON_Type) GetCLK_DIS_CLK_DAC_DIS() uint32 {
	return (volatile.LoadUint32(&o.CLK_DIS.Reg) & 0x4000) >> 14
}
func (o *SYSCON_Type) SetCLK_DIS_CLK_CS_DIS(value uint32) {
	volatile.StoreUint32(&o.CLK_DIS.Reg, volatile.LoadUint32(&o.CLK_DIS.Reg)&^(0x8000)|value<<15)
}
func (o *SYSCON_Type) GetCLK_DIS_CLK_CS_DIS() uint32 {
	return (volatile.LoadUint32(&o.CLK_DIS.Reg) & 0x8000) >> 15
}
func (o *SYSCON_Type) SetCLK_DIS_CLK_FSP_DIS(value uint32) {
	volatile.StoreUint32(&o.CLK_DIS.Reg, volatile.LoadUint32(&o.CLK_DIS.Reg)&^(0x10000)|value<<16)
}
func (o *SYSCON_Type) GetCLK_DIS_CLK_FSP_DIS() uint32 {
	return (volatile.LoadUint32(&o.CLK_DIS.Reg) & 0x10000) >> 16
}
func (o *SYSCON_Type) SetCLK_DIS_CLK_DMA_DIS(value uint32) {
	volatile.StoreUint32(&o.CLK_DIS.Reg, volatile.LoadUint32(&o.CLK_DIS.Reg)&^(0x20000)|value<<17)
}
func (o *SYSCON_Type) GetCLK_DIS_CLK_DMA_DIS() uint32 {
	return (volatile.LoadUint32(&o.CLK_DIS.Reg) & 0x20000) >> 17
}
func (o *SYSCON_Type) SetCLK_DIS_CLK_QDEC0_DIS(value uint32) {
	volatile.StoreUint32(&o.CLK_DIS.Reg, volatile.LoadUint32(&o.CLK_DIS.Reg)&^(0x80000)|value<<19)
}
func (o *SYSCON_Type) GetCLK_DIS_CLK_QDEC0_DIS() uint32 {
	return (volatile.LoadUint32(&o.CLK_DIS.Reg) & 0x80000) >> 19
}
func (o *SYSCON_Type) SetCLK_DIS_CLK_QDEC1_DIS(value uint32) {
	volatile.StoreUint32(&o.CLK_DIS.Reg, volatile.LoadUint32(&o.CLK_DIS.Reg)&^(0x100000)|value<<20)
}
func (o *SYSCON_Type) GetCLK_DIS_CLK_QDEC1_DIS() uint32 {
	return (volatile.LoadUint32(&o.CLK_DIS.Reg) & 0x100000) >> 20
}
func (o *SYSCON_Type) SetCLK_DIS_CLK_DP_DIS(value uint32) {
	volatile.StoreUint32(&o.CLK_DIS.Reg, volatile.LoadUint32(&o.CLK_DIS.Reg)&^(0x200000)|value<<21)
}
func (o *SYSCON_Type) GetCLK_DIS_CLK_DP_DIS() uint32 {
	return (volatile.LoadUint32(&o.CLK_DIS.Reg) & 0x200000) >> 21
}
func (o *SYSCON_Type) SetCLK_DIS_CLK_SPIFI_DIS(value uint32) {
	volatile.StoreUint32(&o.CLK_DIS.Reg, volatile.LoadUint32(&o.CLK_DIS.Reg)&^(0x400000)|value<<22)
}
func (o *SYSCON_Type) GetCLK_DIS_CLK_SPIFI_DIS() uint32 {
	return (volatile.LoadUint32(&o.CLK_DIS.Reg) & 0x400000) >> 22
}
func (o *SYSCON_Type) SetCLK_DIS_CLK_CAL_DIS(value uint32) {
	volatile.StoreUint32(&o.CLK_DIS.Reg, volatile.LoadUint32(&o.CLK_DIS.Reg)&^(0x2000000)|value<<25)
}
func (o *SYSCON_Type) GetCLK_DIS_CLK_CAL_DIS() uint32 {
	return (volatile.LoadUint32(&o.CLK_DIS.Reg) & 0x2000000) >> 25
}
func (o *SYSCON_Type) SetCLK_DIS_CLK_BLE_DIS(value uint32) {
	volatile.StoreUint32(&o.CLK_DIS.Reg, volatile.LoadUint32(&o.CLK_DIS.Reg)&^(0x8000000)|value<<27)
}
func (o *SYSCON_Type) GetCLK_DIS_CLK_BLE_DIS() uint32 {
	return (volatile.LoadUint32(&o.CLK_DIS.Reg) & 0x8000000) >> 27
}
func (o *SYSCON_Type) SetCLK_DIS_PCLK_DIS(value uint32) {
	volatile.StoreUint32(&o.CLK_DIS.Reg, volatile.LoadUint32(&o.CLK_DIS.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSCON_Type) GetCLK_DIS_PCLK_DIS() uint32 {
	return (volatile.LoadUint32(&o.CLK_DIS.Reg) & 0x40000000) >> 30
}
func (o *SYSCON_Type) SetCLK_DIS_FCLK_DIS(value uint32) {
	volatile.StoreUint32(&o.CLK_DIS.Reg, volatile.LoadUint32(&o.CLK_DIS.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSCON_Type) GetCLK_DIS_FCLK_DIS() uint32 {
	return (volatile.LoadUint32(&o.CLK_DIS.Reg) & 0x80000000) >> 31
}

// SYSCON.CLK_EN: clock enable register
func (o *SYSCON_Type) SetCLK_EN_CLK_FC0_EN(value uint32) {
	volatile.StoreUint32(&o.CLK_EN.Reg, volatile.LoadUint32(&o.CLK_EN.Reg)&^(0x1)|value)
}
func (o *SYSCON_Type) GetCLK_EN_CLK_FC0_EN() uint32 {
	return volatile.LoadUint32(&o.CLK_EN.Reg) & 0x1
}
func (o *SYSCON_Type) SetCLK_EN_CLK_FC1_EN(value uint32) {
	volatile.StoreUint32(&o.CLK_EN.Reg, volatile.LoadUint32(&o.CLK_EN.Reg)&^(0x2)|value<<1)
}
func (o *SYSCON_Type) GetCLK_EN_CLK_FC1_EN() uint32 {
	return (volatile.LoadUint32(&o.CLK_EN.Reg) & 0x2) >> 1
}
func (o *SYSCON_Type) SetCLK_EN_CLK_FC2_EN(value uint32) {
	volatile.StoreUint32(&o.CLK_EN.Reg, volatile.LoadUint32(&o.CLK_EN.Reg)&^(0x4)|value<<2)
}
func (o *SYSCON_Type) GetCLK_EN_CLK_FC2_EN() uint32 {
	return (volatile.LoadUint32(&o.CLK_EN.Reg) & 0x4) >> 2
}
func (o *SYSCON_Type) SetCLK_EN_CLK_FC3_EN(value uint32) {
	volatile.StoreUint32(&o.CLK_EN.Reg, volatile.LoadUint32(&o.CLK_EN.Reg)&^(0x8)|value<<3)
}
func (o *SYSCON_Type) GetCLK_EN_CLK_FC3_EN() uint32 {
	return (volatile.LoadUint32(&o.CLK_EN.Reg) & 0x8) >> 3
}
func (o *SYSCON_Type) SetCLK_EN_CLK_TIM0_EN(value uint32) {
	volatile.StoreUint32(&o.CLK_EN.Reg, volatile.LoadUint32(&o.CLK_EN.Reg)&^(0x10)|value<<4)
}
func (o *SYSCON_Type) GetCLK_EN_CLK_TIM0_EN() uint32 {
	return (volatile.LoadUint32(&o.CLK_EN.Reg) & 0x10) >> 4
}
func (o *SYSCON_Type) SetCLK_EN_CLK_TIM1_EN(value uint32) {
	volatile.StoreUint32(&o.CLK_EN.Reg, volatile.LoadUint32(&o.CLK_EN.Reg)&^(0x20)|value<<5)
}
func (o *SYSCON_Type) GetCLK_EN_CLK_TIM1_EN() uint32 {
	return (volatile.LoadUint32(&o.CLK_EN.Reg) & 0x20) >> 5
}
func (o *SYSCON_Type) SetCLK_EN_CLK_TIM2_EN(value uint32) {
	volatile.StoreUint32(&o.CLK_EN.Reg, volatile.LoadUint32(&o.CLK_EN.Reg)&^(0x40)|value<<6)
}
func (o *SYSCON_Type) GetCLK_EN_CLK_TIM2_EN() uint32 {
	return (volatile.LoadUint32(&o.CLK_EN.Reg) & 0x40) >> 6
}
func (o *SYSCON_Type) SetCLK_EN_CLK_TIM3_EN(value uint32) {
	volatile.StoreUint32(&o.CLK_EN.Reg, volatile.LoadUint32(&o.CLK_EN.Reg)&^(0x80)|value<<7)
}
func (o *SYSCON_Type) GetCLK_EN_CLK_TIM3_EN() uint32 {
	return (volatile.LoadUint32(&o.CLK_EN.Reg) & 0x80) >> 7
}
func (o *SYSCON_Type) SetCLK_EN_CLK_SCT_EN(value uint32) {
	volatile.StoreUint32(&o.CLK_EN.Reg, volatile.LoadUint32(&o.CLK_EN.Reg)&^(0x100)|value<<8)
}
func (o *SYSCON_Type) GetCLK_EN_CLK_SCT_EN() uint32 {
	return (volatile.LoadUint32(&o.CLK_EN.Reg) & 0x100) >> 8
}
func (o *SYSCON_Type) SetCLK_EN_CLK_WDT_EN(value uint32) {
	volatile.StoreUint32(&o.CLK_EN.Reg, volatile.LoadUint32(&o.CLK_EN.Reg)&^(0x200)|value<<9)
}
func (o *SYSCON_Type) GetCLK_EN_CLK_WDT_EN() uint32 {
	return (volatile.LoadUint32(&o.CLK_EN.Reg) & 0x200) >> 9
}
func (o *SYSCON_Type) SetCLK_EN_CLK_USB_EN(value uint32) {
	volatile.StoreUint32(&o.CLK_EN.Reg, volatile.LoadUint32(&o.CLK_EN.Reg)&^(0x400)|value<<10)
}
func (o *SYSCON_Type) GetCLK_EN_CLK_USB_EN() uint32 {
	return (volatile.LoadUint32(&o.CLK_EN.Reg) & 0x400) >> 10
}
func (o *SYSCON_Type) SetCLK_EN_CLK_GPIO_EN(value uint32) {
	volatile.StoreUint32(&o.CLK_EN.Reg, volatile.LoadUint32(&o.CLK_EN.Reg)&^(0x800)|value<<11)
}
func (o *SYSCON_Type) GetCLK_EN_CLK_GPIO_EN() uint32 {
	return (volatile.LoadUint32(&o.CLK_EN.Reg) & 0x800) >> 11
}
func (o *SYSCON_Type) SetCLK_EN_CLK_BIV_EN(value uint32) {
	volatile.StoreUint32(&o.CLK_EN.Reg, volatile.LoadUint32(&o.CLK_EN.Reg)&^(0x1000)|value<<12)
}
func (o *SYSCON_Type) GetCLK_EN_CLK_BIV_EN() uint32 {
	return (volatile.LoadUint32(&o.CLK_EN.Reg) & 0x1000) >> 12
}
func (o *SYSCON_Type) SetCLK_EN_CLK_ADC_EN(value uint32) {
	volatile.StoreUint32(&o.CLK_EN.Reg, volatile.LoadUint32(&o.CLK_EN.Reg)&^(0x2000)|value<<13)
}
func (o *SYSCON_Type) GetCLK_EN_CLK_ADC_EN() uint32 {
	return (volatile.LoadUint32(&o.CLK_EN.Reg) & 0x2000) >> 13
}
func (o *SYSCON_Type) SetCLK_EN_CLK_DAC_EN(value uint32) {
	volatile.StoreUint32(&o.CLK_EN.Reg, volatile.LoadUint32(&o.CLK_EN.Reg)&^(0x4000)|value<<14)
}
func (o *SYSCON_Type) GetCLK_EN_CLK_DAC_EN() uint32 {
	return (volatile.LoadUint32(&o.CLK_EN.Reg) & 0x4000) >> 14
}
func (o *SYSCON_Type) SetCLK_EN_CLK_CS_EN(value uint32) {
	volatile.StoreUint32(&o.CLK_EN.Reg, volatile.LoadUint32(&o.CLK_EN.Reg)&^(0x8000)|value<<15)
}
func (o *SYSCON_Type) GetCLK_EN_CLK_CS_EN() uint32 {
	return (volatile.LoadUint32(&o.CLK_EN.Reg) & 0x8000) >> 15
}
func (o *SYSCON_Type) SetCLK_EN_CLK_FSP_EN(value uint32) {
	volatile.StoreUint32(&o.CLK_EN.Reg, volatile.LoadUint32(&o.CLK_EN.Reg)&^(0x10000)|value<<16)
}
func (o *SYSCON_Type) GetCLK_EN_CLK_FSP_EN() uint32 {
	return (volatile.LoadUint32(&o.CLK_EN.Reg) & 0x10000) >> 16
}
func (o *SYSCON_Type) SetCLK_EN_CLK_DMA_EN(value uint32) {
	volatile.StoreUint32(&o.CLK_EN.Reg, volatile.LoadUint32(&o.CLK_EN.Reg)&^(0x20000)|value<<17)
}
func (o *SYSCON_Type) GetCLK_EN_CLK_DMA_EN() uint32 {
	return (volatile.LoadUint32(&o.CLK_EN.Reg) & 0x20000) >> 17
}
func (o *SYSCON_Type) SetCLK_EN_CLK_QDEC0_EN(value uint32) {
	volatile.StoreUint32(&o.CLK_EN.Reg, volatile.LoadUint32(&o.CLK_EN.Reg)&^(0x80000)|value<<19)
}
func (o *SYSCON_Type) GetCLK_EN_CLK_QDEC0_EN() uint32 {
	return (volatile.LoadUint32(&o.CLK_EN.Reg) & 0x80000) >> 19
}
func (o *SYSCON_Type) SetCLK_EN_CLK_QDEC1_EN(value uint32) {
	volatile.StoreUint32(&o.CLK_EN.Reg, volatile.LoadUint32(&o.CLK_EN.Reg)&^(0x100000)|value<<20)
}
func (o *SYSCON_Type) GetCLK_EN_CLK_QDEC1_EN() uint32 {
	return (volatile.LoadUint32(&o.CLK_EN.Reg) & 0x100000) >> 20
}
func (o *SYSCON_Type) SetCLK_EN_CLK_DP_EN(value uint32) {
	volatile.StoreUint32(&o.CLK_EN.Reg, volatile.LoadUint32(&o.CLK_EN.Reg)&^(0x200000)|value<<21)
}
func (o *SYSCON_Type) GetCLK_EN_CLK_DP_EN() uint32 {
	return (volatile.LoadUint32(&o.CLK_EN.Reg) & 0x200000) >> 21
}
func (o *SYSCON_Type) SetCLK_EN_CLK_SPIFI_EN(value uint32) {
	volatile.StoreUint32(&o.CLK_EN.Reg, volatile.LoadUint32(&o.CLK_EN.Reg)&^(0x400000)|value<<22)
}
func (o *SYSCON_Type) GetCLK_EN_CLK_SPIFI_EN() uint32 {
	return (volatile.LoadUint32(&o.CLK_EN.Reg) & 0x400000) >> 22
}
func (o *SYSCON_Type) SetCLK_EN_CLK_CAL_EN(value uint32) {
	volatile.StoreUint32(&o.CLK_EN.Reg, volatile.LoadUint32(&o.CLK_EN.Reg)&^(0x2000000)|value<<25)
}
func (o *SYSCON_Type) GetCLK_EN_CLK_CAL_EN() uint32 {
	return (volatile.LoadUint32(&o.CLK_EN.Reg) & 0x2000000) >> 25
}
func (o *SYSCON_Type) SetCLK_EN_CLK_BLE_EN(value uint32) {
	volatile.StoreUint32(&o.CLK_EN.Reg, volatile.LoadUint32(&o.CLK_EN.Reg)&^(0x8000000)|value<<27)
}
func (o *SYSCON_Type) GetCLK_EN_CLK_BLE_EN() uint32 {
	return (volatile.LoadUint32(&o.CLK_EN.Reg) & 0x8000000) >> 27
}

// SYSCON.CLK_CTRL: system clock source and divider register
func (o *SYSCON_Type) SetCLK_CTRL_APB_DIV(value uint32) {
	volatile.StoreUint32(&o.CLK_CTRL.Reg, volatile.LoadUint32(&o.CLK_CTRL.Reg)&^(0xf)|value)
}
func (o *SYSCON_Type) GetCLK_CTRL_APB_DIV() uint32 {
	return volatile.LoadUint32(&o.CLK_CTRL.Reg) & 0xf
}
func (o *SYSCON_Type) SetCLK_CTRL_AHB_DIV(value uint32) {
	volatile.StoreUint32(&o.CLK_CTRL.Reg, volatile.LoadUint32(&o.CLK_CTRL.Reg)&^(0x1fff0)|value<<4)
}
func (o *SYSCON_Type) GetCLK_CTRL_AHB_DIV() uint32 {
	return (volatile.LoadUint32(&o.CLK_CTRL.Reg) & 0x1fff0) >> 4
}
func (o *SYSCON_Type) SetCLK_CTRL_CLK_BLE_SEL(value uint32) {
	volatile.StoreUint32(&o.CLK_CTRL.Reg, volatile.LoadUint32(&o.CLK_CTRL.Reg)&^(0x20000)|value<<17)
}
func (o *SYSCON_Type) GetCLK_CTRL_CLK_BLE_SEL() uint32 {
	return (volatile.LoadUint32(&o.CLK_CTRL.Reg) & 0x20000) >> 17
}
func (o *SYSCON_Type) SetCLK_CTRL_CLK_WDT_SEL(value uint32) {
	volatile.StoreUint32(&o.CLK_CTRL.Reg, volatile.LoadUint32(&o.CLK_CTRL.Reg)&^(0x40000)|value<<18)
}
func (o *SYSCON_Type) GetCLK_CTRL_CLK_WDT_SEL() uint32 {
	return (volatile.LoadUint32(&o.CLK_CTRL.Reg) & 0x40000) >> 18
}
func (o *SYSCON_Type) SetCLK_CTRL_CLK_XTAL_SEL(value uint32) {
	volatile.StoreUint32(&o.CLK_CTRL.Reg, volatile.LoadUint32(&o.CLK_CTRL.Reg)&^(0x80000)|value<<19)
}
func (o *SYSCON_Type) GetCLK_CTRL_CLK_XTAL_SEL() uint32 {
	return (volatile.LoadUint32(&o.CLK_CTRL.Reg) & 0x80000) >> 19
}
func (o *SYSCON_Type) SetCLK_CTRL_CLK_OSC32M_DIV(value uint32) {
	volatile.StoreUint32(&o.CLK_CTRL.Reg, volatile.LoadUint32(&o.CLK_CTRL.Reg)&^(0x100000)|value<<20)
}
func (o *SYSCON_Type) GetCLK_CTRL_CLK_OSC32M_DIV() uint32 {
	return (volatile.LoadUint32(&o.CLK_CTRL.Reg) & 0x100000) >> 20
}
func (o *SYSCON_Type) SetCLK_CTRL_CLK_32K_SEL(value uint32) {
	volatile.StoreUint32(&o.CLK_CTRL.Reg, volatile.LoadUint32(&o.CLK_CTRL.Reg)&^(0x200000)|value<<21)
}
func (o *SYSCON_Type) GetCLK_CTRL_CLK_32K_SEL() uint32 {
	return (volatile.LoadUint32(&o.CLK_CTRL.Reg) & 0x200000) >> 21
}
func (o *SYSCON_Type) SetCLK_CTRL_CLK_XTAL_OE(value uint32) {
	volatile.StoreUint32(&o.CLK_CTRL.Reg, volatile.LoadUint32(&o.CLK_CTRL.Reg)&^(0x400000)|value<<22)
}
func (o *SYSCON_Type) GetCLK_CTRL_CLK_XTAL_OE() uint32 {
	return (volatile.LoadUint32(&o.CLK_CTRL.Reg) & 0x400000) >> 22
}
func (o *SYSCON_Type) SetCLK_CTRL_CLK_32K_OE(value uint32) {
	volatile.StoreUint32(&o.CLK_CTRL.Reg, volatile.LoadUint32(&o.CLK_CTRL.Reg)&^(0x800000)|value<<23)
}
func (o *SYSCON_Type) GetCLK_CTRL_CLK_32K_OE() uint32 {
	return (volatile.LoadUint32(&o.CLK_CTRL.Reg) & 0x800000) >> 23
}
func (o *SYSCON_Type) SetCLK_CTRL_XTAL_OUT_DIV(value uint32) {
	volatile.StoreUint32(&o.CLK_CTRL.Reg, volatile.LoadUint32(&o.CLK_CTRL.Reg)&^(0xf000000)|value<<24)
}
func (o *SYSCON_Type) GetCLK_CTRL_XTAL_OUT_DIV() uint32 {
	return (volatile.LoadUint32(&o.CLK_CTRL.Reg) & 0xf000000) >> 24
}
func (o *SYSCON_Type) SetCLK_CTRL_CGBYPASS(value uint32) {
	volatile.StoreUint32(&o.CLK_CTRL.Reg, volatile.LoadUint32(&o.CLK_CTRL.Reg)&^(0x10000000)|value<<28)
}
func (o *SYSCON_Type) GetCLK_CTRL_CGBYPASS() uint32 {
	return (volatile.LoadUint32(&o.CLK_CTRL.Reg) & 0x10000000) >> 28
}
func (o *SYSCON_Type) SetCLK_CTRL_SYS_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.CLK_CTRL.Reg, volatile.LoadUint32(&o.CLK_CTRL.Reg)&^(0xc0000000)|value<<30)
}
func (o *SYSCON_Type) GetCLK_CTRL_SYS_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.CLK_CTRL.Reg) & 0xc0000000) >> 30
}

// SYSCON.SYS_MODE_CTRL: system mode and address remap register
func (o *SYSCON_Type) SetSYS_MODE_CTRL_REMAP(value uint32) {
	volatile.StoreUint32(&o.SYS_MODE_CTRL.Reg, volatile.LoadUint32(&o.SYS_MODE_CTRL.Reg)&^(0x3)|value)
}
func (o *SYSCON_Type) GetSYS_MODE_CTRL_REMAP() uint32 {
	return volatile.LoadUint32(&o.SYS_MODE_CTRL.Reg) & 0x3
}
func (o *SYSCON_Type) SetSYS_MODE_CTRL_LOCKUP_EN(value uint32) {
	volatile.StoreUint32(&o.SYS_MODE_CTRL.Reg, volatile.LoadUint32(&o.SYS_MODE_CTRL.Reg)&^(0x4)|value<<2)
}
func (o *SYSCON_Type) GetSYS_MODE_CTRL_LOCKUP_EN() uint32 {
	return (volatile.LoadUint32(&o.SYS_MODE_CTRL.Reg) & 0x4) >> 2
}
func (o *SYSCON_Type) SetSYS_MODE_CTRL_XTAL_RDY(value uint32) {
	volatile.StoreUint32(&o.SYS_MODE_CTRL.Reg, volatile.LoadUint32(&o.SYS_MODE_CTRL.Reg)&^(0x2000000)|value<<25)
}
func (o *SYSCON_Type) GetSYS_MODE_CTRL_XTAL_RDY() uint32 {
	return (volatile.LoadUint32(&o.SYS_MODE_CTRL.Reg) & 0x2000000) >> 25
}
func (o *SYSCON_Type) SetSYS_MODE_CTRL_XTAL32K_RDY(value uint32) {
	volatile.StoreUint32(&o.SYS_MODE_CTRL.Reg, volatile.LoadUint32(&o.SYS_MODE_CTRL.Reg)&^(0x4000000)|value<<26)
}
func (o *SYSCON_Type) GetSYS_MODE_CTRL_XTAL32K_RDY() uint32 {
	return (volatile.LoadUint32(&o.SYS_MODE_CTRL.Reg) & 0x4000000) >> 26
}
func (o *SYSCON_Type) SetSYS_MODE_CTRL_PLL48M_RDY(value uint32) {
	volatile.StoreUint32(&o.SYS_MODE_CTRL.Reg, volatile.LoadUint32(&o.SYS_MODE_CTRL.Reg)&^(0x8000000)|value<<27)
}
func (o *SYSCON_Type) GetSYS_MODE_CTRL_PLL48M_RDY() uint32 {
	return (volatile.LoadUint32(&o.SYS_MODE_CTRL.Reg) & 0x8000000) >> 27
}
func (o *SYSCON_Type) SetSYS_MODE_CTRL_OSC32M_RDY(value uint32) {
	volatile.StoreUint32(&o.SYS_MODE_CTRL.Reg, volatile.LoadUint32(&o.SYS_MODE_CTRL.Reg)&^(0x10000000)|value<<28)
}
func (o *SYSCON_Type) GetSYS_MODE_CTRL_OSC32M_RDY() uint32 {
	return (volatile.LoadUint32(&o.SYS_MODE_CTRL.Reg) & 0x10000000) >> 28
}
func (o *SYSCON_Type) SetSYS_MODE_CTRL_BG_RDY(value uint32) {
	volatile.StoreUint32(&o.SYS_MODE_CTRL.Reg, volatile.LoadUint32(&o.SYS_MODE_CTRL.Reg)&^(0x20000000)|value<<29)
}
func (o *SYSCON_Type) GetSYS_MODE_CTRL_BG_RDY() uint32 {
	return (volatile.LoadUint32(&o.SYS_MODE_CTRL.Reg) & 0x20000000) >> 29
}
func (o *SYSCON_Type) SetSYS_MODE_CTRL_BOOT_MODE(value uint32) {
	volatile.StoreUint32(&o.SYS_MODE_CTRL.Reg, volatile.LoadUint32(&o.SYS_MODE_CTRL.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSCON_Type) GetSYS_MODE_CTRL_BOOT_MODE() uint32 {
	return (volatile.LoadUint32(&o.SYS_MODE_CTRL.Reg) & 0x80000000) >> 31
}

// SYSCON.SYS_STAT: system status register
func (o *SYSCON_Type) SetSYS_STAT_FREQ_WORD(value uint32) {
	volatile.StoreUint32(&o.SYS_STAT.Reg, volatile.LoadUint32(&o.SYS_STAT.Reg)&^(0xff)|value)
}
func (o *SYSCON_Type) GetSYS_STAT_FREQ_WORD() uint32 {
	return volatile.LoadUint32(&o.SYS_STAT.Reg) & 0xff
}
func (o *SYSCON_Type) SetSYS_STAT_BLE_FREQ_HOP(value uint32) {
	volatile.StoreUint32(&o.SYS_STAT.Reg, volatile.LoadUint32(&o.SYS_STAT.Reg)&^(0x100)|value<<8)
}
func (o *SYSCON_Type) GetSYS_STAT_BLE_FREQ_HOP() uint32 {
	return (volatile.LoadUint32(&o.SYS_STAT.Reg) & 0x100) >> 8
}
func (o *SYSCON_Type) SetSYS_STAT_EVENT_IN_PROCESS(value uint32) {
	volatile.StoreUint32(&o.SYS_STAT.Reg, volatile.LoadUint32(&o.SYS_STAT.Reg)&^(0x200)|value<<9)
}
func (o *SYSCON_Type) GetSYS_STAT_EVENT_IN_PROCESS() uint32 {
	return (volatile.LoadUint32(&o.SYS_STAT.Reg) & 0x200) >> 9
}
func (o *SYSCON_Type) SetSYS_STAT_RX_EN(value uint32) {
	volatile.StoreUint32(&o.SYS_STAT.Reg, volatile.LoadUint32(&o.SYS_STAT.Reg)&^(0x400)|value<<10)
}
func (o *SYSCON_Type) GetSYS_STAT_RX_EN() uint32 {
	return (volatile.LoadUint32(&o.SYS_STAT.Reg) & 0x400) >> 10
}
func (o *SYSCON_Type) SetSYS_STAT_TX_EN(value uint32) {
	volatile.StoreUint32(&o.SYS_STAT.Reg, volatile.LoadUint32(&o.SYS_STAT.Reg)&^(0x800)|value<<11)
}
func (o *SYSCON_Type) GetSYS_STAT_TX_EN() uint32 {
	return (volatile.LoadUint32(&o.SYS_STAT.Reg) & 0x800) >> 11
}
func (o *SYSCON_Type) SetSYS_STAT_OSC_EN(value uint32) {
	volatile.StoreUint32(&o.SYS_STAT.Reg, volatile.LoadUint32(&o.SYS_STAT.Reg)&^(0x1000)|value<<12)
}
func (o *SYSCON_Type) GetSYS_STAT_OSC_EN() uint32 {
	return (volatile.LoadUint32(&o.SYS_STAT.Reg) & 0x1000) >> 12
}
func (o *SYSCON_Type) SetSYS_STAT_RADIO_EN(value uint32) {
	volatile.StoreUint32(&o.SYS_STAT.Reg, volatile.LoadUint32(&o.SYS_STAT.Reg)&^(0x2000)|value<<13)
}
func (o *SYSCON_Type) GetSYS_STAT_RADIO_EN() uint32 {
	return (volatile.LoadUint32(&o.SYS_STAT.Reg) & 0x2000) >> 13
}
func (o *SYSCON_Type) SetSYS_STAT_CLK_STATUS(value uint32) {
	volatile.StoreUint32(&o.SYS_STAT.Reg, volatile.LoadUint32(&o.SYS_STAT.Reg)&^(0x4000)|value<<14)
}
func (o *SYSCON_Type) GetSYS_STAT_CLK_STATUS() uint32 {
	return (volatile.LoadUint32(&o.SYS_STAT.Reg) & 0x4000) >> 14
}

// SYSCON.SYS_TICK: systick timer control register
func (o *SYSCON_Type) SetSYS_TICK_TENMS(value uint32) {
	volatile.StoreUint32(&o.SYS_TICK.Reg, volatile.LoadUint32(&o.SYS_TICK.Reg)&^(0xffffff)|value)
}
func (o *SYSCON_Type) GetSYS_TICK_TENMS() uint32 {
	return volatile.LoadUint32(&o.SYS_TICK.Reg) & 0xffffff
}
func (o *SYSCON_Type) SetSYS_TICK_SKEW(value uint32) {
	volatile.StoreUint32(&o.SYS_TICK.Reg, volatile.LoadUint32(&o.SYS_TICK.Reg)&^(0x1000000)|value<<24)
}
func (o *SYSCON_Type) GetSYS_TICK_SKEW() uint32 {
	return (volatile.LoadUint32(&o.SYS_TICK.Reg) & 0x1000000) >> 24
}
func (o *SYSCON_Type) SetSYS_TICK_NOREF(value uint32) {
	volatile.StoreUint32(&o.SYS_TICK.Reg, volatile.LoadUint32(&o.SYS_TICK.Reg)&^(0x2000000)|value<<25)
}
func (o *SYSCON_Type) GetSYS_TICK_NOREF() uint32 {
	return (volatile.LoadUint32(&o.SYS_TICK.Reg) & 0x2000000) >> 25
}
func (o *SYSCON_Type) SetSYS_TICK_EN_STCLKEN(value uint32) {
	volatile.StoreUint32(&o.SYS_TICK.Reg, volatile.LoadUint32(&o.SYS_TICK.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSCON_Type) GetSYS_TICK_EN_STCLKEN() uint32 {
	return (volatile.LoadUint32(&o.SYS_TICK.Reg) & 0x80000000) >> 31
}

// SYSCON.SRAM_CTRL: Exchange memory base address register
func (o *SYSCON_Type) SetSRAM_CTRL_EM_BASE_ADDR(value uint32) {
	volatile.StoreUint32(&o.SRAM_CTRL.Reg, volatile.LoadUint32(&o.SRAM_CTRL.Reg)&^(0x7fff)|value)
}
func (o *SYSCON_Type) GetSRAM_CTRL_EM_BASE_ADDR() uint32 {
	return volatile.LoadUint32(&o.SRAM_CTRL.Reg) & 0x7fff
}

// SYSCON.CHIP_ID: chip id register
func (o *SYSCON_Type) SetCHIP_ID_CID0(value uint32) {
	volatile.StoreUint32(&o.CHIP_ID.Reg, volatile.LoadUint32(&o.CHIP_ID.Reg)&^(0x7)|value)
}
func (o *SYSCON_Type) GetCHIP_ID_CID0() uint32 {
	return volatile.LoadUint32(&o.CHIP_ID.Reg) & 0x7
}
func (o *SYSCON_Type) SetCHIP_ID_CID1(value uint32) {
	volatile.StoreUint32(&o.CHIP_ID.Reg, volatile.LoadUint32(&o.CHIP_ID.Reg)&^(0x38)|value<<3)
}
func (o *SYSCON_Type) GetCHIP_ID_CID1() uint32 {
	return (volatile.LoadUint32(&o.CHIP_ID.Reg) & 0x38) >> 3
}
func (o *SYSCON_Type) SetCHIP_ID_CID2(value uint32) {
	volatile.StoreUint32(&o.CHIP_ID.Reg, volatile.LoadUint32(&o.CHIP_ID.Reg)&^(0xc0)|value<<6)
}
func (o *SYSCON_Type) GetCHIP_ID_CID2() uint32 {
	return (volatile.LoadUint32(&o.CHIP_ID.Reg) & 0xc0) >> 6
}
func (o *SYSCON_Type) SetCHIP_ID_CID3(value uint32) {
	volatile.StoreUint32(&o.CHIP_ID.Reg, volatile.LoadUint32(&o.CHIP_ID.Reg)&^(0x3f00)|value<<8)
}
func (o *SYSCON_Type) GetCHIP_ID_CID3() uint32 {
	return (volatile.LoadUint32(&o.CHIP_ID.Reg) & 0x3f00) >> 8
}
func (o *SYSCON_Type) SetCHIP_ID_CID4(value uint32) {
	volatile.StoreUint32(&o.CHIP_ID.Reg, volatile.LoadUint32(&o.CHIP_ID.Reg)&^(0xc000)|value<<14)
}
func (o *SYSCON_Type) GetCHIP_ID_CID4() uint32 {
	return (volatile.LoadUint32(&o.CHIP_ID.Reg) & 0xc000) >> 14
}
func (o *SYSCON_Type) SetCHIP_ID_MEM_OPTION(value uint32) {
	volatile.StoreUint32(&o.CHIP_ID.Reg, volatile.LoadUint32(&o.CHIP_ID.Reg)&^(0x4000000)|value<<26)
}
func (o *SYSCON_Type) GetCHIP_ID_MEM_OPTION() uint32 {
	return (volatile.LoadUint32(&o.CHIP_ID.Reg) & 0x4000000) >> 26
}
func (o *SYSCON_Type) SetCHIP_ID_ADC_OPTION(value uint32) {
	volatile.StoreUint32(&o.CHIP_ID.Reg, volatile.LoadUint32(&o.CHIP_ID.Reg)&^(0x8000000)|value<<27)
}
func (o *SYSCON_Type) GetCHIP_ID_ADC_OPTION() uint32 {
	return (volatile.LoadUint32(&o.CHIP_ID.Reg) & 0x8000000) >> 27
}
func (o *SYSCON_Type) SetCHIP_ID_FLASH_OPTION(value uint32) {
	volatile.StoreUint32(&o.CHIP_ID.Reg, volatile.LoadUint32(&o.CHIP_ID.Reg)&^(0x10000000)|value<<28)
}
func (o *SYSCON_Type) GetCHIP_ID_FLASH_OPTION() uint32 {
	return (volatile.LoadUint32(&o.CHIP_ID.Reg) & 0x10000000) >> 28
}
func (o *SYSCON_Type) SetCHIP_ID_FPU_OPTION(value uint32) {
	volatile.StoreUint32(&o.CHIP_ID.Reg, volatile.LoadUint32(&o.CHIP_ID.Reg)&^(0x20000000)|value<<29)
}
func (o *SYSCON_Type) GetCHIP_ID_FPU_OPTION() uint32 {
	return (volatile.LoadUint32(&o.CHIP_ID.Reg) & 0x20000000) >> 29
}
func (o *SYSCON_Type) SetCHIP_ID_USB_OPTION(value uint32) {
	volatile.StoreUint32(&o.CHIP_ID.Reg, volatile.LoadUint32(&o.CHIP_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSCON_Type) GetCHIP_ID_USB_OPTION() uint32 {
	return (volatile.LoadUint32(&o.CHIP_ID.Reg) & 0x40000000) >> 30
}
func (o *SYSCON_Type) SetCHIP_ID_FSP_OPTION(value uint32) {
	volatile.StoreUint32(&o.CHIP_ID.Reg, volatile.LoadUint32(&o.CHIP_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSCON_Type) GetCHIP_ID_FSP_OPTION() uint32 {
	return (volatile.LoadUint32(&o.CHIP_ID.Reg) & 0x80000000) >> 31
}

// SYSCON.ANA_CTRL0: crystal and PA register
func (o *SYSCON_Type) SetANA_CTRL0_PA_POWER(value uint32) {
	volatile.StoreUint32(&o.ANA_CTRL0.Reg, volatile.LoadUint32(&o.ANA_CTRL0.Reg)&^(0xff)|value)
}
func (o *SYSCON_Type) GetANA_CTRL0_PA_POWER() uint32 {
	return volatile.LoadUint32(&o.ANA_CTRL0.Reg) & 0xff
}
func (o *SYSCON_Type) SetANA_CTRL0_XTAL_AMP(value uint32) {
	volatile.StoreUint32(&o.ANA_CTRL0.Reg, volatile.LoadUint32(&o.ANA_CTRL0.Reg)&^(0x300000)|value<<20)
}
func (o *SYSCON_Type) GetANA_CTRL0_XTAL_AMP() uint32 {
	return (volatile.LoadUint32(&o.ANA_CTRL0.Reg) & 0x300000) >> 20
}
func (o *SYSCON_Type) SetANA_CTRL0_XTAL_LOAD_CAP(value uint32) {
	volatile.StoreUint32(&o.ANA_CTRL0.Reg, volatile.LoadUint32(&o.ANA_CTRL0.Reg)&^(0xfc00000)|value<<22)
}
func (o *SYSCON_Type) GetANA_CTRL0_XTAL_LOAD_CAP() uint32 {
	return (volatile.LoadUint32(&o.ANA_CTRL0.Reg) & 0xfc00000) >> 22
}
func (o *SYSCON_Type) SetANA_CTRL0_XTAL_EXTRA_CAP(value uint32) {
	volatile.StoreUint32(&o.ANA_CTRL0.Reg, volatile.LoadUint32(&o.ANA_CTRL0.Reg)&^(0x10000000)|value<<28)
}
func (o *SYSCON_Type) GetANA_CTRL0_XTAL_EXTRA_CAP() uint32 {
	return (volatile.LoadUint32(&o.ANA_CTRL0.Reg) & 0x10000000) >> 28
}
func (o *SYSCON_Type) SetANA_CTRL0_XTAL_MODE(value uint32) {
	volatile.StoreUint32(&o.ANA_CTRL0.Reg, volatile.LoadUint32(&o.ANA_CTRL0.Reg)&^(0xc0000000)|value<<30)
}
func (o *SYSCON_Type) GetANA_CTRL0_XTAL_MODE() uint32 {
	return (volatile.LoadUint32(&o.ANA_CTRL0.Reg) & 0xc0000000) >> 30
}

// SYSCON.XTAL_CTRL: crystal control register
func (o *SYSCON_Type) SetXTAL_CTRL_XTAL_XCUR_BOOST_REG(value uint32) {
	volatile.StoreUint32(&o.XTAL_CTRL.Reg, volatile.LoadUint32(&o.XTAL_CTRL.Reg)&^(0x20)|value<<5)
}
func (o *SYSCON_Type) GetXTAL_CTRL_XTAL_XCUR_BOOST_REG() uint32 {
	return (volatile.LoadUint32(&o.XTAL_CTRL.Reg) & 0x20) >> 5
}
func (o *SYSCON_Type) SetXTAL_CTRL_XTAL_BPXDLY(value uint32) {
	volatile.StoreUint32(&o.XTAL_CTRL.Reg, volatile.LoadUint32(&o.XTAL_CTRL.Reg)&^(0x40)|value<<6)
}
func (o *SYSCON_Type) GetXTAL_CTRL_XTAL_BPXDLY() uint32 {
	return (volatile.LoadUint32(&o.XTAL_CTRL.Reg) & 0x40) >> 6
}
func (o *SYSCON_Type) SetXTAL_CTRL_XTAL_BP_HYSRES_REG(value uint32) {
	volatile.StoreUint32(&o.XTAL_CTRL.Reg, volatile.LoadUint32(&o.XTAL_CTRL.Reg)&^(0x80)|value<<7)
}
func (o *SYSCON_Type) GetXTAL_CTRL_XTAL_BP_HYSRES_REG() uint32 {
	return (volatile.LoadUint32(&o.XTAL_CTRL.Reg) & 0x80) >> 7
}
func (o *SYSCON_Type) SetXTAL_CTRL_XTAL_XSMT_EN_REG(value uint32) {
	volatile.StoreUint32(&o.XTAL_CTRL.Reg, volatile.LoadUint32(&o.XTAL_CTRL.Reg)&^(0x100)|value<<8)
}
func (o *SYSCON_Type) GetXTAL_CTRL_XTAL_XSMT_EN_REG() uint32 {
	return (volatile.LoadUint32(&o.XTAL_CTRL.Reg) & 0x100) >> 8
}
func (o *SYSCON_Type) SetXTAL_CTRL_XTAL_XRDY_REG(value uint32) {
	volatile.StoreUint32(&o.XTAL_CTRL.Reg, volatile.LoadUint32(&o.XTAL_CTRL.Reg)&^(0x200)|value<<9)
}
func (o *SYSCON_Type) GetXTAL_CTRL_XTAL_XRDY_REG() uint32 {
	return (volatile.LoadUint32(&o.XTAL_CTRL.Reg) & 0x200) >> 9
}
func (o *SYSCON_Type) SetXTAL_CTRL_XTAL_XOUT_DIS_REG(value uint32) {
	volatile.StoreUint32(&o.XTAL_CTRL.Reg, volatile.LoadUint32(&o.XTAL_CTRL.Reg)&^(0x400)|value<<10)
}
func (o *SYSCON_Type) GetXTAL_CTRL_XTAL_XOUT_DIS_REG() uint32 {
	return (volatile.LoadUint32(&o.XTAL_CTRL.Reg) & 0x400) >> 10
}
func (o *SYSCON_Type) SetXTAL_CTRL_DIV_DIFF_CLK_DIG_DIS(value uint32) {
	volatile.StoreUint32(&o.XTAL_CTRL.Reg, volatile.LoadUint32(&o.XTAL_CTRL.Reg)&^(0x800)|value<<11)
}
func (o *SYSCON_Type) GetXTAL_CTRL_DIV_DIFF_CLK_DIG_DIS() uint32 {
	return (volatile.LoadUint32(&o.XTAL_CTRL.Reg) & 0x800) >> 11
}
func (o *SYSCON_Type) SetXTAL_CTRL_XTAL_SU_CB_REG(value uint32) {
	volatile.StoreUint32(&o.XTAL_CTRL.Reg, volatile.LoadUint32(&o.XTAL_CTRL.Reg)&^(0x3f0000)|value<<16)
}
func (o *SYSCON_Type) GetXTAL_CTRL_XTAL_SU_CB_REG() uint32 {
	return (volatile.LoadUint32(&o.XTAL_CTRL.Reg) & 0x3f0000) >> 16
}
func (o *SYSCON_Type) SetXTAL_CTRL_XTAL_SU_CA_REG(value uint32) {
	volatile.StoreUint32(&o.XTAL_CTRL.Reg, volatile.LoadUint32(&o.XTAL_CTRL.Reg)&^(0x3f000000)|value<<24)
}
func (o *SYSCON_Type) GetXTAL_CTRL_XTAL_SU_CA_REG() uint32 {
	return (volatile.LoadUint32(&o.XTAL_CTRL.Reg) & 0x3f000000) >> 24
}
func (o *SYSCON_Type) SetXTAL_CTRL_XTAL_INV(value uint32) {
	volatile.StoreUint32(&o.XTAL_CTRL.Reg, volatile.LoadUint32(&o.XTAL_CTRL.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSCON_Type) GetXTAL_CTRL_XTAL_INV() uint32 {
	return (volatile.LoadUint32(&o.XTAL_CTRL.Reg) & 0x40000000) >> 30
}
func (o *SYSCON_Type) SetXTAL_CTRL_XTAL_DIV(value uint32) {
	volatile.StoreUint32(&o.XTAL_CTRL.Reg, volatile.LoadUint32(&o.XTAL_CTRL.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSCON_Type) GetXTAL_CTRL_XTAL_DIV() uint32 {
	return (volatile.LoadUint32(&o.XTAL_CTRL.Reg) & 0x80000000) >> 31
}

// SYSCON.BUCK: buck control register
func (o *SYSCON_Type) SetBUCK_BUCK_DRIVER_PART_EN(value uint32) {
	volatile.StoreUint32(&o.BUCK.Reg, volatile.LoadUint32(&o.BUCK.Reg)&^(0x1)|value)
}
func (o *SYSCON_Type) GetBUCK_BUCK_DRIVER_PART_EN() uint32 {
	return volatile.LoadUint32(&o.BUCK.Reg) & 0x1
}
func (o *SYSCON_Type) SetBUCK_BUCK_IND_USE_EN(value uint32) {
	volatile.StoreUint32(&o.BUCK.Reg, volatile.LoadUint32(&o.BUCK.Reg)&^(0x2)|value<<1)
}
func (o *SYSCON_Type) GetBUCK_BUCK_IND_USE_EN() uint32 {
	return (volatile.LoadUint32(&o.BUCK.Reg) & 0x2) >> 1
}
func (o *SYSCON_Type) SetBUCK_BUCK_ISEL(value uint32) {
	volatile.StoreUint32(&o.BUCK.Reg, volatile.LoadUint32(&o.BUCK.Reg)&^(0x300)|value<<8)
}
func (o *SYSCON_Type) GetBUCK_BUCK_ISEL() uint32 {
	return (volatile.LoadUint32(&o.BUCK.Reg) & 0x300) >> 8
}
func (o *SYSCON_Type) SetBUCK_BUCK_VREF_SEL(value uint32) {
	volatile.StoreUint32(&o.BUCK.Reg, volatile.LoadUint32(&o.BUCK.Reg)&^(0xc00)|value<<10)
}
func (o *SYSCON_Type) GetBUCK_BUCK_VREF_SEL() uint32 {
	return (volatile.LoadUint32(&o.BUCK.Reg) & 0xc00) >> 10
}
func (o *SYSCON_Type) SetBUCK_BUCK_VBG_SEL(value uint32) {
	volatile.StoreUint32(&o.BUCK.Reg, volatile.LoadUint32(&o.BUCK.Reg)&^(0x3000)|value<<12)
}
func (o *SYSCON_Type) GetBUCK_BUCK_VBG_SEL() uint32 {
	return (volatile.LoadUint32(&o.BUCK.Reg) & 0x3000) >> 12
}
func (o *SYSCON_Type) SetBUCK_BUCK_TMOS(value uint32) {
	volatile.StoreUint32(&o.BUCK.Reg, volatile.LoadUint32(&o.BUCK.Reg)&^(0x1f0000)|value<<16)
}
func (o *SYSCON_Type) GetBUCK_BUCK_TMOS() uint32 {
	return (volatile.LoadUint32(&o.BUCK.Reg) & 0x1f0000) >> 16
}
func (o *SYSCON_Type) SetBUCK_BUCK_IC(value uint32) {
	volatile.StoreUint32(&o.BUCK.Reg, volatile.LoadUint32(&o.BUCK.Reg)&^(0x200000)|value<<21)
}
func (o *SYSCON_Type) GetBUCK_BUCK_IC() uint32 {
	return (volatile.LoadUint32(&o.BUCK.Reg) & 0x200000) >> 21
}

// SYSCON.FC_FRG: flexcomm 0 and 1 clock divider register
func (o *SYSCON_Type) SetFC_FRG_FRG_DIV0(value uint32) {
	volatile.StoreUint32(&o.FC_FRG.Reg, volatile.LoadUint32(&o.FC_FRG.Reg)&^(0xff)|value)
}
func (o *SYSCON_Type) GetFC_FRG_FRG_DIV0() uint32 {
	return volatile.LoadUint32(&o.FC_FRG.Reg) & 0xff
}
func (o *SYSCON_Type) SetFC_FRG_FRG_MULT0(value uint32) {
	volatile.StoreUint32(&o.FC_FRG.Reg, volatile.LoadUint32(&o.FC_FRG.Reg)&^(0xff00)|value<<8)
}
func (o *SYSCON_Type) GetFC_FRG_FRG_MULT0() uint32 {
	return (volatile.LoadUint32(&o.FC_FRG.Reg) & 0xff00) >> 8
}
func (o *SYSCON_Type) SetFC_FRG_FRG_DIV1(value uint32) {
	volatile.StoreUint32(&o.FC_FRG.Reg, volatile.LoadUint32(&o.FC_FRG.Reg)&^(0xff0000)|value<<16)
}
func (o *SYSCON_Type) GetFC_FRG_FRG_DIV1() uint32 {
	return (volatile.LoadUint32(&o.FC_FRG.Reg) & 0xff0000) >> 16
}
func (o *SYSCON_Type) SetFC_FRG_FRG_MULT1(value uint32) {
	volatile.StoreUint32(&o.FC_FRG.Reg, volatile.LoadUint32(&o.FC_FRG.Reg)&^(0xff000000)|value<<24)
}
func (o *SYSCON_Type) GetFC_FRG_FRG_MULT1() uint32 {
	return (volatile.LoadUint32(&o.FC_FRG.Reg) & 0xff000000) >> 24
}

// SYSCON.PIO_PULL_CFG0: pad pull control register 0
func (o *SYSCON_Type) SetPIO_PULL_CFG0_PA00_PULL(value uint32) {
	volatile.StoreUint32(&o.PIO_PULL_CFG0.Reg, volatile.LoadUint32(&o.PIO_PULL_CFG0.Reg)&^(0x3)|value)
}
func (o *SYSCON_Type) GetPIO_PULL_CFG0_PA00_PULL() uint32 {
	return volatile.LoadUint32(&o.PIO_PULL_CFG0.Reg) & 0x3
}
func (o *SYSCON_Type) SetPIO_PULL_CFG0_PA01_PULL(value uint32) {
	volatile.StoreUint32(&o.PIO_PULL_CFG0.Reg, volatile.LoadUint32(&o.PIO_PULL_CFG0.Reg)&^(0xc)|value<<2)
}
func (o *SYSCON_Type) GetPIO_PULL_CFG0_PA01_PULL() uint32 {
	return (volatile.LoadUint32(&o.PIO_PULL_CFG0.Reg) & 0xc) >> 2
}
func (o *SYSCON_Type) SetPIO_PULL_CFG0_PA02_PULL(value uint32) {
	volatile.StoreUint32(&o.PIO_PULL_CFG0.Reg, volatile.LoadUint32(&o.PIO_PULL_CFG0.Reg)&^(0x30)|value<<4)
}
func (o *SYSCON_Type) GetPIO_PULL_CFG0_PA02_PULL() uint32 {
	return (volatile.LoadUint32(&o.PIO_PULL_CFG0.Reg) & 0x30) >> 4
}
func (o *SYSCON_Type) SetPIO_PULL_CFG0_PA03_PULL(value uint32) {
	volatile.StoreUint32(&o.PIO_PULL_CFG0.Reg, volatile.LoadUint32(&o.PIO_PULL_CFG0.Reg)&^(0xc0)|value<<6)
}
func (o *SYSCON_Type) GetPIO_PULL_CFG0_PA03_PULL() uint32 {
	return (volatile.LoadUint32(&o.PIO_PULL_CFG0.Reg) & 0xc0) >> 6
}
func (o *SYSCON_Type) SetPIO_PULL_CFG0_PA04_PULL(value uint32) {
	volatile.StoreUint32(&o.PIO_PULL_CFG0.Reg, volatile.LoadUint32(&o.PIO_PULL_CFG0.Reg)&^(0x300)|value<<8)
}
func (o *SYSCON_Type) GetPIO_PULL_CFG0_PA04_PULL() uint32 {
	return (volatile.LoadUint32(&o.PIO_PULL_CFG0.Reg) & 0x300) >> 8
}
func (o *SYSCON_Type) SetPIO_PULL_CFG0_PA05_PULL(value uint32) {
	volatile.StoreUint32(&o.PIO_PULL_CFG0.Reg, volatile.LoadUint32(&o.PIO_PULL_CFG0.Reg)&^(0xc00)|value<<10)
}
func (o *SYSCON_Type) GetPIO_PULL_CFG0_PA05_PULL() uint32 {
	return (volatile.LoadUint32(&o.PIO_PULL_CFG0.Reg) & 0xc00) >> 10
}
func (o *SYSCON_Type) SetPIO_PULL_CFG0_PA06_PULL(value uint32) {
	volatile.StoreUint32(&o.PIO_PULL_CFG0.Reg, volatile.LoadUint32(&o.PIO_PULL_CFG0.Reg)&^(0x3000)|value<<12)
}
func (o *SYSCON_Type) GetPIO_PULL_CFG0_PA06_PULL() uint32 {
	return (volatile.LoadUint32(&o.PIO_PULL_CFG0.Reg) & 0x3000) >> 12
}
func (o *SYSCON_Type) SetPIO_PULL_CFG0_PA07_PULL(value uint32) {
	volatile.StoreUint32(&o.PIO_PULL_CFG0.Reg, volatile.LoadUint32(&o.PIO_PULL_CFG0.Reg)&^(0xc000)|value<<14)
}
func (o *SYSCON_Type) GetPIO_PULL_CFG0_PA07_PULL() uint32 {
	return (volatile.LoadUint32(&o.PIO_PULL_CFG0.Reg) & 0xc000) >> 14
}
func (o *SYSCON_Type) SetPIO_PULL_CFG0_PA08_PULL(value uint32) {
	volatile.StoreUint32(&o.PIO_PULL_CFG0.Reg, volatile.LoadUint32(&o.PIO_PULL_CFG0.Reg)&^(0x30000)|value<<16)
}
func (o *SYSCON_Type) GetPIO_PULL_CFG0_PA08_PULL() uint32 {
	return (volatile.LoadUint32(&o.PIO_PULL_CFG0.Reg) & 0x30000) >> 16
}
func (o *SYSCON_Type) SetPIO_PULL_CFG0_PA09_PULL(value uint32) {
	volatile.StoreUint32(&o.PIO_PULL_CFG0.Reg, volatile.LoadUint32(&o.PIO_PULL_CFG0.Reg)&^(0xc0000)|value<<18)
}
func (o *SYSCON_Type) GetPIO_PULL_CFG0_PA09_PULL() uint32 {
	return (volatile.LoadUint32(&o.PIO_PULL_CFG0.Reg) & 0xc0000) >> 18
}
func (o *SYSCON_Type) SetPIO_PULL_CFG0_PA10_PULL(value uint32) {
	volatile.StoreUint32(&o.PIO_PULL_CFG0.Reg, volatile.LoadUint32(&o.PIO_PULL_CFG0.Reg)&^(0x300000)|value<<20)
}
func (o *SYSCON_Type) GetPIO_PULL_CFG0_PA10_PULL() uint32 {
	return (volatile.LoadUint32(&o.PIO_PULL_CFG0.Reg) & 0x300000) >> 20
}
func (o *SYSCON_Type) SetPIO_PULL_CFG0_PA11_PULL(value uint32) {
	volatile.StoreUint32(&o.PIO_PULL_CFG0.Reg, volatile.LoadUint32(&o.PIO_PULL_CFG0.Reg)&^(0xc00000)|value<<22)
}
func (o *SYSCON_Type) GetPIO_PULL_CFG0_PA11_PULL() uint32 {
	return (volatile.LoadUint32(&o.PIO_PULL_CFG0.Reg) & 0xc00000) >> 22
}
func (o *SYSCON_Type) SetPIO_PULL_CFG0_PA12_PULL(value uint32) {
	volatile.StoreUint32(&o.PIO_PULL_CFG0.Reg, volatile.LoadUint32(&o.PIO_PULL_CFG0.Reg)&^(0x3000000)|value<<24)
}
func (o *SYSCON_Type) GetPIO_PULL_CFG0_PA12_PULL() uint32 {
	return (volatile.LoadUint32(&o.PIO_PULL_CFG0.Reg) & 0x3000000) >> 24
}
func (o *SYSCON_Type) SetPIO_PULL_CFG0_PA13_PULL(value uint32) {
	volatile.StoreUint32(&o.PIO_PULL_CFG0.Reg, volatile.LoadUint32(&o.PIO_PULL_CFG0.Reg)&^(0xc000000)|value<<26)
}
func (o *SYSCON_Type) GetPIO_PULL_CFG0_PA13_PULL() uint32 {
	return (volatile.LoadUint32(&o.PIO_PULL_CFG0.Reg) & 0xc000000) >> 26
}
func (o *SYSCON_Type) SetPIO_PULL_CFG0_PA14_PULL(value uint32) {
	volatile.StoreUint32(&o.PIO_PULL_CFG0.Reg, volatile.LoadUint32(&o.PIO_PULL_CFG0.Reg)&^(0x30000000)|value<<28)
}
func (o *SYSCON_Type) GetPIO_PULL_CFG0_PA14_PULL() uint32 {
	return (volatile.LoadUint32(&o.PIO_PULL_CFG0.Reg) & 0x30000000) >> 28
}
func (o *SYSCON_Type) SetPIO_PULL_CFG0_PA15_PULL(value uint32) {
	volatile.StoreUint32(&o.PIO_PULL_CFG0.Reg, volatile.LoadUint32(&o.PIO_PULL_CFG0.Reg)&^(0xc0000000)|value<<30)
}
func (o *SYSCON_Type) GetPIO_PULL_CFG0_PA15_PULL() uint32 {
	return (volatile.LoadUint32(&o.PIO_PULL_CFG0.Reg) & 0xc0000000) >> 30
}

// SYSCON.PIO_PULL_CFG1: pad pull control register 1
func (o *SYSCON_Type) SetPIO_PULL_CFG1_PA16_PULL(value uint32) {
	volatile.StoreUint32(&o.PIO_PULL_CFG1.Reg, volatile.LoadUint32(&o.PIO_PULL_CFG1.Reg)&^(0x3)|value)
}
func (o *SYSCON_Type) GetPIO_PULL_CFG1_PA16_PULL() uint32 {
	return volatile.LoadUint32(&o.PIO_PULL_CFG1.Reg) & 0x3
}
func (o *SYSCON_Type) SetPIO_PULL_CFG1_PA17_PULL(value uint32) {
	volatile.StoreUint32(&o.PIO_PULL_CFG1.Reg, volatile.LoadUint32(&o.PIO_PULL_CFG1.Reg)&^(0xc)|value<<2)
}
func (o *SYSCON_Type) GetPIO_PULL_CFG1_PA17_PULL() uint32 {
	return (volatile.LoadUint32(&o.PIO_PULL_CFG1.Reg) & 0xc) >> 2
}
func (o *SYSCON_Type) SetPIO_PULL_CFG1_PA18_PULL(value uint32) {
	volatile.StoreUint32(&o.PIO_PULL_CFG1.Reg, volatile.LoadUint32(&o.PIO_PULL_CFG1.Reg)&^(0x30)|value<<4)
}
func (o *SYSCON_Type) GetPIO_PULL_CFG1_PA18_PULL() uint32 {
	return (volatile.LoadUint32(&o.PIO_PULL_CFG1.Reg) & 0x30) >> 4
}
func (o *SYSCON_Type) SetPIO_PULL_CFG1_PA19_PULL(value uint32) {
	volatile.StoreUint32(&o.PIO_PULL_CFG1.Reg, volatile.LoadUint32(&o.PIO_PULL_CFG1.Reg)&^(0xc0)|value<<6)
}
func (o *SYSCON_Type) GetPIO_PULL_CFG1_PA19_PULL() uint32 {
	return (volatile.LoadUint32(&o.PIO_PULL_CFG1.Reg) & 0xc0) >> 6
}
func (o *SYSCON_Type) SetPIO_PULL_CFG1_PA20_PULL(value uint32) {
	volatile.StoreUint32(&o.PIO_PULL_CFG1.Reg, volatile.LoadUint32(&o.PIO_PULL_CFG1.Reg)&^(0x300)|value<<8)
}
func (o *SYSCON_Type) GetPIO_PULL_CFG1_PA20_PULL() uint32 {
	return (volatile.LoadUint32(&o.PIO_PULL_CFG1.Reg) & 0x300) >> 8
}
func (o *SYSCON_Type) SetPIO_PULL_CFG1_PA21_PULL(value uint32) {
	volatile.StoreUint32(&o.PIO_PULL_CFG1.Reg, volatile.LoadUint32(&o.PIO_PULL_CFG1.Reg)&^(0xc00)|value<<10)
}
func (o *SYSCON_Type) GetPIO_PULL_CFG1_PA21_PULL() uint32 {
	return (volatile.LoadUint32(&o.PIO_PULL_CFG1.Reg) & 0xc00) >> 10
}
func (o *SYSCON_Type) SetPIO_PULL_CFG1_PA22_PULL(value uint32) {
	volatile.StoreUint32(&o.PIO_PULL_CFG1.Reg, volatile.LoadUint32(&o.PIO_PULL_CFG1.Reg)&^(0x3000)|value<<12)
}
func (o *SYSCON_Type) GetPIO_PULL_CFG1_PA22_PULL() uint32 {
	return (volatile.LoadUint32(&o.PIO_PULL_CFG1.Reg) & 0x3000) >> 12
}
func (o *SYSCON_Type) SetPIO_PULL_CFG1_PA23_PULL(value uint32) {
	volatile.StoreUint32(&o.PIO_PULL_CFG1.Reg, volatile.LoadUint32(&o.PIO_PULL_CFG1.Reg)&^(0xc000)|value<<14)
}
func (o *SYSCON_Type) GetPIO_PULL_CFG1_PA23_PULL() uint32 {
	return (volatile.LoadUint32(&o.PIO_PULL_CFG1.Reg) & 0xc000) >> 14
}
func (o *SYSCON_Type) SetPIO_PULL_CFG1_PA24_PULL(value uint32) {
	volatile.StoreUint32(&o.PIO_PULL_CFG1.Reg, volatile.LoadUint32(&o.PIO_PULL_CFG1.Reg)&^(0x30000)|value<<16)
}
func (o *SYSCON_Type) GetPIO_PULL_CFG1_PA24_PULL() uint32 {
	return (volatile.LoadUint32(&o.PIO_PULL_CFG1.Reg) & 0x30000) >> 16
}
func (o *SYSCON_Type) SetPIO_PULL_CFG1_PA25_PULL(value uint32) {
	volatile.StoreUint32(&o.PIO_PULL_CFG1.Reg, volatile.LoadUint32(&o.PIO_PULL_CFG1.Reg)&^(0xc0000)|value<<18)
}
func (o *SYSCON_Type) GetPIO_PULL_CFG1_PA25_PULL() uint32 {
	return (volatile.LoadUint32(&o.PIO_PULL_CFG1.Reg) & 0xc0000) >> 18
}
func (o *SYSCON_Type) SetPIO_PULL_CFG1_PA26_PULL(value uint32) {
	volatile.StoreUint32(&o.PIO_PULL_CFG1.Reg, volatile.LoadUint32(&o.PIO_PULL_CFG1.Reg)&^(0x300000)|value<<20)
}
func (o *SYSCON_Type) GetPIO_PULL_CFG1_PA26_PULL() uint32 {
	return (volatile.LoadUint32(&o.PIO_PULL_CFG1.Reg) & 0x300000) >> 20
}
func (o *SYSCON_Type) SetPIO_PULL_CFG1_PA27_PULL(value uint32) {
	volatile.StoreUint32(&o.PIO_PULL_CFG1.Reg, volatile.LoadUint32(&o.PIO_PULL_CFG1.Reg)&^(0xc00000)|value<<22)
}
func (o *SYSCON_Type) GetPIO_PULL_CFG1_PA27_PULL() uint32 {
	return (volatile.LoadUint32(&o.PIO_PULL_CFG1.Reg) & 0xc00000) >> 22
}
func (o *SYSCON_Type) SetPIO_PULL_CFG1_PA28_PULL(value uint32) {
	volatile.StoreUint32(&o.PIO_PULL_CFG1.Reg, volatile.LoadUint32(&o.PIO_PULL_CFG1.Reg)&^(0x3000000)|value<<24)
}
func (o *SYSCON_Type) GetPIO_PULL_CFG1_PA28_PULL() uint32 {
	return (volatile.LoadUint32(&o.PIO_PULL_CFG1.Reg) & 0x3000000) >> 24
}
func (o *SYSCON_Type) SetPIO_PULL_CFG1_PA29_PULL(value uint32) {
	volatile.StoreUint32(&o.PIO_PULL_CFG1.Reg, volatile.LoadUint32(&o.PIO_PULL_CFG1.Reg)&^(0xc000000)|value<<26)
}
func (o *SYSCON_Type) GetPIO_PULL_CFG1_PA29_PULL() uint32 {
	return (volatile.LoadUint32(&o.PIO_PULL_CFG1.Reg) & 0xc000000) >> 26
}
func (o *SYSCON_Type) SetPIO_PULL_CFG1_PA30_PULL(value uint32) {
	volatile.StoreUint32(&o.PIO_PULL_CFG1.Reg, volatile.LoadUint32(&o.PIO_PULL_CFG1.Reg)&^(0x30000000)|value<<28)
}
func (o *SYSCON_Type) GetPIO_PULL_CFG1_PA30_PULL() uint32 {
	return (volatile.LoadUint32(&o.PIO_PULL_CFG1.Reg) & 0x30000000) >> 28
}
func (o *SYSCON_Type) SetPIO_PULL_CFG1_PA31_PULL(value uint32) {
	volatile.StoreUint32(&o.PIO_PULL_CFG1.Reg, volatile.LoadUint32(&o.PIO_PULL_CFG1.Reg)&^(0xc0000000)|value<<30)
}
func (o *SYSCON_Type) GetPIO_PULL_CFG1_PA31_PULL() uint32 {
	return (volatile.LoadUint32(&o.PIO_PULL_CFG1.Reg) & 0xc0000000) >> 30
}

// SYSCON.PIO_PULL_CFG2: pad pull control register 2
func (o *SYSCON_Type) SetPIO_PULL_CFG2_PB00_PULL(value uint32) {
	volatile.StoreUint32(&o.PIO_PULL_CFG2.Reg, volatile.LoadUint32(&o.PIO_PULL_CFG2.Reg)&^(0x3)|value)
}
func (o *SYSCON_Type) GetPIO_PULL_CFG2_PB00_PULL() uint32 {
	return volatile.LoadUint32(&o.PIO_PULL_CFG2.Reg) & 0x3
}
func (o *SYSCON_Type) SetPIO_PULL_CFG2_PB01_PULL(value uint32) {
	volatile.StoreUint32(&o.PIO_PULL_CFG2.Reg, volatile.LoadUint32(&o.PIO_PULL_CFG2.Reg)&^(0xc)|value<<2)
}
func (o *SYSCON_Type) GetPIO_PULL_CFG2_PB01_PULL() uint32 {
	return (volatile.LoadUint32(&o.PIO_PULL_CFG2.Reg) & 0xc) >> 2
}
func (o *SYSCON_Type) SetPIO_PULL_CFG2_PB02_PULL(value uint32) {
	volatile.StoreUint32(&o.PIO_PULL_CFG2.Reg, volatile.LoadUint32(&o.PIO_PULL_CFG2.Reg)&^(0x30)|value<<4)
}
func (o *SYSCON_Type) GetPIO_PULL_CFG2_PB02_PULL() uint32 {
	return (volatile.LoadUint32(&o.PIO_PULL_CFG2.Reg) & 0x30) >> 4
}

// SYSCON.IO_CAP: io status capture register
func (o *SYSCON_Type) SetIO_CAP_PIN_RETENTION(value uint32) {
	volatile.StoreUint32(&o.IO_CAP.Reg, volatile.LoadUint32(&o.IO_CAP.Reg)&^(0x1)|value)
}
func (o *SYSCON_Type) GetIO_CAP_PIN_RETENTION() uint32 {
	return volatile.LoadUint32(&o.IO_CAP.Reg) & 0x1
}

// SYSCON.PIO_DRV_CFG0: pad drive strength register 0
func (o *SYSCON_Type) SetPIO_DRV_CFG0_PA00_DRV(value uint32) {
	volatile.StoreUint32(&o.PIO_DRV_CFG0.Reg, volatile.LoadUint32(&o.PIO_DRV_CFG0.Reg)&^(0x1)|value)
}
func (o *SYSCON_Type) GetPIO_DRV_CFG0_PA00_DRV() uint32 {
	return volatile.LoadUint32(&o.PIO_DRV_CFG0.Reg) & 0x1
}
func (o *SYSCON_Type) SetPIO_DRV_CFG0_PA01_DRV(value uint32) {
	volatile.StoreUint32(&o.PIO_DRV_CFG0.Reg, volatile.LoadUint32(&o.PIO_DRV_CFG0.Reg)&^(0x2)|value<<1)
}
func (o *SYSCON_Type) GetPIO_DRV_CFG0_PA01_DRV() uint32 {
	return (volatile.LoadUint32(&o.PIO_DRV_CFG0.Reg) & 0x2) >> 1
}
func (o *SYSCON_Type) SetPIO_DRV_CFG0_PA02_DRV(value uint32) {
	volatile.StoreUint32(&o.PIO_DRV_CFG0.Reg, volatile.LoadUint32(&o.PIO_DRV_CFG0.Reg)&^(0x4)|value<<2)
}
func (o *SYSCON_Type) GetPIO_DRV_CFG0_PA02_DRV() uint32 {
	return (volatile.LoadUint32(&o.PIO_DRV_CFG0.Reg) & 0x4) >> 2
}
func (o *SYSCON_Type) SetPIO_DRV_CFG0_PA03_DRV(value uint32) {
	volatile.StoreUint32(&o.PIO_DRV_CFG0.Reg, volatile.LoadUint32(&o.PIO_DRV_CFG0.Reg)&^(0x8)|value<<3)
}
func (o *SYSCON_Type) GetPIO_DRV_CFG0_PA03_DRV() uint32 {
	return (volatile.LoadUint32(&o.PIO_DRV_CFG0.Reg) & 0x8) >> 3
}
func (o *SYSCON_Type) SetPIO_DRV_CFG0_PA04_DRV(value uint32) {
	volatile.StoreUint32(&o.PIO_DRV_CFG0.Reg, volatile.LoadUint32(&o.PIO_DRV_CFG0.Reg)&^(0x10)|value<<4)
}
func (o *SYSCON_Type) GetPIO_DRV_CFG0_PA04_DRV() uint32 {
	return (volatile.LoadUint32(&o.PIO_DRV_CFG0.Reg) & 0x10) >> 4
}
func (o *SYSCON_Type) SetPIO_DRV_CFG0_PA05_DRV(value uint32) {
	volatile.StoreUint32(&o.PIO_DRV_CFG0.Reg, volatile.LoadUint32(&o.PIO_DRV_CFG0.Reg)&^(0x20)|value<<5)
}
func (o *SYSCON_Type) GetPIO_DRV_CFG0_PA05_DRV() uint32 {
	return (volatile.LoadUint32(&o.PIO_DRV_CFG0.Reg) & 0x20) >> 5
}
func (o *SYSCON_Type) SetPIO_DRV_CFG0_PA06_DRV(value uint32) {
	volatile.StoreUint32(&o.PIO_DRV_CFG0.Reg, volatile.LoadUint32(&o.PIO_DRV_CFG0.Reg)&^(0x40)|value<<6)
}
func (o *SYSCON_Type) GetPIO_DRV_CFG0_PA06_DRV() uint32 {
	return (volatile.LoadUint32(&o.PIO_DRV_CFG0.Reg) & 0x40) >> 6
}
func (o *SYSCON_Type) SetPIO_DRV_CFG0_PA07_DRV(value uint32) {
	volatile.StoreUint32(&o.PIO_DRV_CFG0.Reg, volatile.LoadUint32(&o.PIO_DRV_CFG0.Reg)&^(0x80)|value<<7)
}
func (o *SYSCON_Type) GetPIO_DRV_CFG0_PA07_DRV() uint32 {
	return (volatile.LoadUint32(&o.PIO_DRV_CFG0.Reg) & 0x80) >> 7
}
func (o *SYSCON_Type) SetPIO_DRV_CFG0_PA08_DRV(value uint32) {
	volatile.StoreUint32(&o.PIO_DRV_CFG0.Reg, volatile.LoadUint32(&o.PIO_DRV_CFG0.Reg)&^(0x100)|value<<8)
}
func (o *SYSCON_Type) GetPIO_DRV_CFG0_PA08_DRV() uint32 {
	return (volatile.LoadUint32(&o.PIO_DRV_CFG0.Reg) & 0x100) >> 8
}
func (o *SYSCON_Type) SetPIO_DRV_CFG0_PA09_DRV(value uint32) {
	volatile.StoreUint32(&o.PIO_DRV_CFG0.Reg, volatile.LoadUint32(&o.PIO_DRV_CFG0.Reg)&^(0x200)|value<<9)
}
func (o *SYSCON_Type) GetPIO_DRV_CFG0_PA09_DRV() uint32 {
	return (volatile.LoadUint32(&o.PIO_DRV_CFG0.Reg) & 0x200) >> 9
}
func (o *SYSCON_Type) SetPIO_DRV_CFG0_PA10_DRV(value uint32) {
	volatile.StoreUint32(&o.PIO_DRV_CFG0.Reg, volatile.LoadUint32(&o.PIO_DRV_CFG0.Reg)&^(0x400)|value<<10)
}
func (o *SYSCON_Type) GetPIO_DRV_CFG0_PA10_DRV() uint32 {
	return (volatile.LoadUint32(&o.PIO_DRV_CFG0.Reg) & 0x400) >> 10
}
func (o *SYSCON_Type) SetPIO_DRV_CFG0_PA11_DRV(value uint32) {
	volatile.StoreUint32(&o.PIO_DRV_CFG0.Reg, volatile.LoadUint32(&o.PIO_DRV_CFG0.Reg)&^(0x800)|value<<11)
}
func (o *SYSCON_Type) GetPIO_DRV_CFG0_PA11_DRV() uint32 {
	return (volatile.LoadUint32(&o.PIO_DRV_CFG0.Reg) & 0x800) >> 11
}
func (o *SYSCON_Type) SetPIO_DRV_CFG0_PA12_DRV(value uint32) {
	volatile.StoreUint32(&o.PIO_DRV_CFG0.Reg, volatile.LoadUint32(&o.PIO_DRV_CFG0.Reg)&^(0x1000)|value<<12)
}
func (o *SYSCON_Type) GetPIO_DRV_CFG0_PA12_DRV() uint32 {
	return (volatile.LoadUint32(&o.PIO_DRV_CFG0.Reg) & 0x1000) >> 12
}
func (o *SYSCON_Type) SetPIO_DRV_CFG0_PA13_DRV(value uint32) {
	volatile.StoreUint32(&o.PIO_DRV_CFG0.Reg, volatile.LoadUint32(&o.PIO_DRV_CFG0.Reg)&^(0x2000)|value<<13)
}
func (o *SYSCON_Type) GetPIO_DRV_CFG0_PA13_DRV() uint32 {
	return (volatile.LoadUint32(&o.PIO_DRV_CFG0.Reg) & 0x2000) >> 13
}
func (o *SYSCON_Type) SetPIO_DRV_CFG0_PA14_DRV(value uint32) {
	volatile.StoreUint32(&o.PIO_DRV_CFG0.Reg, volatile.LoadUint32(&o.PIO_DRV_CFG0.Reg)&^(0x4000)|value<<14)
}
func (o *SYSCON_Type) GetPIO_DRV_CFG0_PA14_DRV() uint32 {
	return (volatile.LoadUint32(&o.PIO_DRV_CFG0.Reg) & 0x4000) >> 14
}
func (o *SYSCON_Type) SetPIO_DRV_CFG0_PA15_DRV(value uint32) {
	volatile.StoreUint32(&o.PIO_DRV_CFG0.Reg, volatile.LoadUint32(&o.PIO_DRV_CFG0.Reg)&^(0x8000)|value<<15)
}
func (o *SYSCON_Type) GetPIO_DRV_CFG0_PA15_DRV() uint32 {
	return (volatile.LoadUint32(&o.PIO_DRV_CFG0.Reg) & 0x8000) >> 15
}
func (o *SYSCON_Type) SetPIO_DRV_CFG0_PA16_DRV(value uint32) {
	volatile.StoreUint32(&o.PIO_DRV_CFG0.Reg, volatile.LoadUint32(&o.PIO_DRV_CFG0.Reg)&^(0x10000)|value<<16)
}
func (o *SYSCON_Type) GetPIO_DRV_CFG0_PA16_DRV() uint32 {
	return (volatile.LoadUint32(&o.PIO_DRV_CFG0.Reg) & 0x10000) >> 16
}
func (o *SYSCON_Type) SetPIO_DRV_CFG0_PA17_DRV(value uint32) {
	volatile.StoreUint32(&o.PIO_DRV_CFG0.Reg, volatile.LoadUint32(&o.PIO_DRV_CFG0.Reg)&^(0x20000)|value<<17)
}
func (o *SYSCON_Type) GetPIO_DRV_CFG0_PA17_DRV() uint32 {
	return (volatile.LoadUint32(&o.PIO_DRV_CFG0.Reg) & 0x20000) >> 17
}
func (o *SYSCON_Type) SetPIO_DRV_CFG0_PA18_DRV(value uint32) {
	volatile.StoreUint32(&o.PIO_DRV_CFG0.Reg, volatile.LoadUint32(&o.PIO_DRV_CFG0.Reg)&^(0x40000)|value<<18)
}
func (o *SYSCON_Type) GetPIO_DRV_CFG0_PA18_DRV() uint32 {
	return (volatile.LoadUint32(&o.PIO_DRV_CFG0.Reg) & 0x40000) >> 18
}
func (o *SYSCON_Type) SetPIO_DRV_CFG0_PA19_DRV(value uint32) {
	volatile.StoreUint32(&o.PIO_DRV_CFG0.Reg, volatile.LoadUint32(&o.PIO_DRV_CFG0.Reg)&^(0x80000)|value<<19)
}
func (o *SYSCON_Type) GetPIO_DRV_CFG0_PA19_DRV() uint32 {
	return (volatile.LoadUint32(&o.PIO_DRV_CFG0.Reg) & 0x80000) >> 19
}
func (o *SYSCON_Type) SetPIO_DRV_CFG0_PA20_DRV(value uint32) {
	volatile.StoreUint32(&o.PIO_DRV_CFG0.Reg, volatile.LoadUint32(&o.PIO_DRV_CFG0.Reg)&^(0x100000)|value<<20)
}
func (o *SYSCON_Type) GetPIO_DRV_CFG0_PA20_DRV() uint32 {
	return (volatile.LoadUint32(&o.PIO_DRV_CFG0.Reg) & 0x100000) >> 20
}
func (o *SYSCON_Type) SetPIO_DRV_CFG0_PA21_DRV(value uint32) {
	volatile.StoreUint32(&o.PIO_DRV_CFG0.Reg, volatile.LoadUint32(&o.PIO_DRV_CFG0.Reg)&^(0x200000)|value<<21)
}
func (o *SYSCON_Type) GetPIO_DRV_CFG0_PA21_DRV() uint32 {
	return (volatile.LoadUint32(&o.PIO_DRV_CFG0.Reg) & 0x200000) >> 21
}
func (o *SYSCON_Type) SetPIO_DRV_CFG0_PA22_DRV(value uint32) {
	volatile.StoreUint32(&o.PIO_DRV_CFG0.Reg, volatile.LoadUint32(&o.PIO_DRV_CFG0.Reg)&^(0x400000)|value<<22)
}
func (o *SYSCON_Type) GetPIO_DRV_CFG0_PA22_DRV() uint32 {
	return (volatile.LoadUint32(&o.PIO_DRV_CFG0.Reg) & 0x400000) >> 22
}
func (o *SYSCON_Type) SetPIO_DRV_CFG0_PA23_DRV(value uint32) {
	volatile.StoreUint32(&o.PIO_DRV_CFG0.Reg, volatile.LoadUint32(&o.PIO_DRV_CFG0.Reg)&^(0x800000)|value<<23)
}
func (o *SYSCON_Type) GetPIO_DRV_CFG0_PA23_DRV() uint32 {
	return (volatile.LoadUint32(&o.PIO_DRV_CFG0.Reg) & 0x800000) >> 23
}
func (o *SYSCON_Type) SetPIO_DRV_CFG0_PA24_DRV(value uint32) {
	volatile.StoreUint32(&o.PIO_DRV_CFG0.Reg, volatile.LoadUint32(&o.PIO_DRV_CFG0.Reg)&^(0x1000000)|value<<24)
}
func (o *SYSCON_Type) GetPIO_DRV_CFG0_PA24_DRV() uint32 {
	return (volatile.LoadUint32(&o.PIO_DRV_CFG0.Reg) & 0x1000000) >> 24
}
func (o *SYSCON_Type) SetPIO_DRV_CFG0_PA25_DRV(value uint32) {
	volatile.StoreUint32(&o.PIO_DRV_CFG0.Reg, volatile.LoadUint32(&o.PIO_DRV_CFG0.Reg)&^(0x2000000)|value<<25)
}
func (o *SYSCON_Type) GetPIO_DRV_CFG0_PA25_DRV() uint32 {
	return (volatile.LoadUint32(&o.PIO_DRV_CFG0.Reg) & 0x2000000) >> 25
}
func (o *SYSCON_Type) SetPIO_DRV_CFG0_PA26_DRV(value uint32) {
	volatile.StoreUint32(&o.PIO_DRV_CFG0.Reg, volatile.LoadUint32(&o.PIO_DRV_CFG0.Reg)&^(0x4000000)|value<<26)
}
func (o *SYSCON_Type) GetPIO_DRV_CFG0_PA26_DRV() uint32 {
	return (volatile.LoadUint32(&o.PIO_DRV_CFG0.Reg) & 0x4000000) >> 26
}
func (o *SYSCON_Type) SetPIO_DRV_CFG0_PA27_DRV(value uint32) {
	volatile.StoreUint32(&o.PIO_DRV_CFG0.Reg, volatile.LoadUint32(&o.PIO_DRV_CFG0.Reg)&^(0x8000000)|value<<27)
}
func (o *SYSCON_Type) GetPIO_DRV_CFG0_PA27_DRV() uint32 {
	return (volatile.LoadUint32(&o.PIO_DRV_CFG0.Reg) & 0x8000000) >> 27
}
func (o *SYSCON_Type) SetPIO_DRV_CFG0_PA28_DRV(value uint32) {
	volatile.StoreUint32(&o.PIO_DRV_CFG0.Reg, volatile.LoadUint32(&o.PIO_DRV_CFG0.Reg)&^(0x10000000)|value<<28)
}
func (o *SYSCON_Type) GetPIO_DRV_CFG0_PA28_DRV() uint32 {
	return (volatile.LoadUint32(&o.PIO_DRV_CFG0.Reg) & 0x10000000) >> 28
}
func (o *SYSCON_Type) SetPIO_DRV_CFG0_PA29_DRV(value uint32) {
	volatile.StoreUint32(&o.PIO_DRV_CFG0.Reg, volatile.LoadUint32(&o.PIO_DRV_CFG0.Reg)&^(0x20000000)|value<<29)
}
func (o *SYSCON_Type) GetPIO_DRV_CFG0_PA29_DRV() uint32 {
	return (volatile.LoadUint32(&o.PIO_DRV_CFG0.Reg) & 0x20000000) >> 29
}
func (o *SYSCON_Type) SetPIO_DRV_CFG0_PA30_DRV(value uint32) {
	volatile.StoreUint32(&o.PIO_DRV_CFG0.Reg, volatile.LoadUint32(&o.PIO_DRV_CFG0.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSCON_Type) GetPIO_DRV_CFG0_PA30_DRV() uint32 {
	return (volatile.LoadUint32(&o.PIO_DRV_CFG0.Reg) & 0x40000000) >> 30
}
func (o *SYSCON_Type) SetPIO_DRV_CFG0_PA31_DRV(value uint32) {
	volatile.StoreUint32(&o.PIO_DRV_CFG0.Reg, volatile.LoadUint32(&o.PIO_DRV_CFG0.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSCON_Type) GetPIO_DRV_CFG0_PA31_DRV() uint32 {
	return (volatile.LoadUint32(&o.PIO_DRV_CFG0.Reg) & 0x80000000) >> 31
}

// SYSCON.PIO_DRV_CFG1: pad drive strength register 1
func (o *SYSCON_Type) SetPIO_DRV_CFG1_PB00_DRV(value uint32) {
	volatile.StoreUint32(&o.PIO_DRV_CFG1.Reg, volatile.LoadUint32(&o.PIO_DRV_CFG1.Reg)&^(0x1)|value)
}
func (o *SYSCON_Type) GetPIO_DRV_CFG1_PB00_DRV() uint32 {
	return volatile.LoadUint32(&o.PIO_DRV_CFG1.Reg) & 0x1
}
func (o *SYSCON_Type) SetPIO_DRV_CFG1_PB01_DRV(value uint32) {
	volatile.StoreUint32(&o.PIO_DRV_CFG1.Reg, volatile.LoadUint32(&o.PIO_DRV_CFG1.Reg)&^(0x2)|value<<1)
}
func (o *SYSCON_Type) GetPIO_DRV_CFG1_PB01_DRV() uint32 {
	return (volatile.LoadUint32(&o.PIO_DRV_CFG1.Reg) & 0x2) >> 1
}
func (o *SYSCON_Type) SetPIO_DRV_CFG1_PB02_DRV(value uint32) {
	volatile.StoreUint32(&o.PIO_DRV_CFG1.Reg, volatile.LoadUint32(&o.PIO_DRV_CFG1.Reg)&^(0x4)|value<<2)
}
func (o *SYSCON_Type) GetPIO_DRV_CFG1_PB02_DRV() uint32 {
	return (volatile.LoadUint32(&o.PIO_DRV_CFG1.Reg) & 0x4) >> 2
}

// SYSCON.PIO_DRV_CFG2: pad drive extra register
func (o *SYSCON_Type) SetPIO_DRV_CFG2_PA06_DRV_EXTRA(value uint32) {
	volatile.StoreUint32(&o.PIO_DRV_CFG2.Reg, volatile.LoadUint32(&o.PIO_DRV_CFG2.Reg)&^(0x40)|value<<6)
}
func (o *SYSCON_Type) GetPIO_DRV_CFG2_PA06_DRV_EXTRA() uint32 {
	return (volatile.LoadUint32(&o.PIO_DRV_CFG2.Reg) & 0x40) >> 6
}
func (o *SYSCON_Type) SetPIO_DRV_CFG2_PA11_DRV_EXTRA(value uint32) {
	volatile.StoreUint32(&o.PIO_DRV_CFG2.Reg, volatile.LoadUint32(&o.PIO_DRV_CFG2.Reg)&^(0x800)|value<<11)
}
func (o *SYSCON_Type) GetPIO_DRV_CFG2_PA11_DRV_EXTRA() uint32 {
	return (volatile.LoadUint32(&o.PIO_DRV_CFG2.Reg) & 0x800) >> 11
}
func (o *SYSCON_Type) SetPIO_DRV_CFG2_PA19_DRV_EXTRA(value uint32) {
	volatile.StoreUint32(&o.PIO_DRV_CFG2.Reg, volatile.LoadUint32(&o.PIO_DRV_CFG2.Reg)&^(0x80000)|value<<19)
}
func (o *SYSCON_Type) GetPIO_DRV_CFG2_PA19_DRV_EXTRA() uint32 {
	return (volatile.LoadUint32(&o.PIO_DRV_CFG2.Reg) & 0x80000) >> 19
}
func (o *SYSCON_Type) SetPIO_DRV_CFG2_PA26_DRV_EXTRA(value uint32) {
	volatile.StoreUint32(&o.PIO_DRV_CFG2.Reg, volatile.LoadUint32(&o.PIO_DRV_CFG2.Reg)&^(0x4000000)|value<<26)
}
func (o *SYSCON_Type) GetPIO_DRV_CFG2_PA26_DRV_EXTRA() uint32 {
	return (volatile.LoadUint32(&o.PIO_DRV_CFG2.Reg) & 0x4000000) >> 26
}
func (o *SYSCON_Type) SetPIO_DRV_CFG2_PA27_DRV_EXTRA(value uint32) {
	volatile.StoreUint32(&o.PIO_DRV_CFG2.Reg, volatile.LoadUint32(&o.PIO_DRV_CFG2.Reg)&^(0x8000000)|value<<27)
}
func (o *SYSCON_Type) GetPIO_DRV_CFG2_PA27_DRV_EXTRA() uint32 {
	return (volatile.LoadUint32(&o.PIO_DRV_CFG2.Reg) & 0x8000000) >> 27
}

// SYSCON.PIO_CFG_MISC: pin misc control register
func (o *SYSCON_Type) SetPIO_CFG_MISC_PB00_AE(value uint32) {
	volatile.StoreUint32(&o.PIO_CFG_MISC.Reg, volatile.LoadUint32(&o.PIO_CFG_MISC.Reg)&^(0x1)|value)
}
func (o *SYSCON_Type) GetPIO_CFG_MISC_PB00_AE() uint32 {
	return volatile.LoadUint32(&o.PIO_CFG_MISC.Reg) & 0x1
}
func (o *SYSCON_Type) SetPIO_CFG_MISC_PB01_AE(value uint32) {
	volatile.StoreUint32(&o.PIO_CFG_MISC.Reg, volatile.LoadUint32(&o.PIO_CFG_MISC.Reg)&^(0x2)|value<<1)
}
func (o *SYSCON_Type) GetPIO_CFG_MISC_PB01_AE() uint32 {
	return (volatile.LoadUint32(&o.PIO_CFG_MISC.Reg) & 0x2) >> 1
}
func (o *SYSCON_Type) SetPIO_CFG_MISC_PSYNC(value uint32) {
	volatile.StoreUint32(&o.PIO_CFG_MISC.Reg, volatile.LoadUint32(&o.PIO_CFG_MISC.Reg)&^(0x8000)|value<<15)
}
func (o *SYSCON_Type) GetPIO_CFG_MISC_PSYNC() uint32 {
	return (volatile.LoadUint32(&o.PIO_CFG_MISC.Reg) & 0x8000) >> 15
}
func (o *SYSCON_Type) SetPIO_CFG_MISC_PB02_MODE(value uint32) {
	volatile.StoreUint32(&o.PIO_CFG_MISC.Reg, volatile.LoadUint32(&o.PIO_CFG_MISC.Reg)&^(0x10000)|value<<16)
}
func (o *SYSCON_Type) GetPIO_CFG_MISC_PB02_MODE() uint32 {
	return (volatile.LoadUint32(&o.PIO_CFG_MISC.Reg) & 0x10000) >> 16
}
func (o *SYSCON_Type) SetPIO_CFG_MISC_TRX_EN_INV(value uint32) {
	volatile.StoreUint32(&o.PIO_CFG_MISC.Reg, volatile.LoadUint32(&o.PIO_CFG_MISC.Reg)&^(0x40000)|value<<18)
}
func (o *SYSCON_Type) GetPIO_CFG_MISC_TRX_EN_INV() uint32 {
	return (volatile.LoadUint32(&o.PIO_CFG_MISC.Reg) & 0x40000) >> 18
}
func (o *SYSCON_Type) SetPIO_CFG_MISC_RFE_INV(value uint32) {
	volatile.StoreUint32(&o.PIO_CFG_MISC.Reg, volatile.LoadUint32(&o.PIO_CFG_MISC.Reg)&^(0x80000)|value<<19)
}
func (o *SYSCON_Type) GetPIO_CFG_MISC_RFE_INV() uint32 {
	return (volatile.LoadUint32(&o.PIO_CFG_MISC.Reg) & 0x80000) >> 19
}

// SYSCON.PIO_WAKEUP_LVL0: pin wakeup polarity register 0
func (o *SYSCON_Type) SetPIO_WAKEUP_LVL0_PA00_WAKEUP_LVL(value uint32) {
	volatile.StoreUint32(&o.PIO_WAKEUP_LVL0.Reg, volatile.LoadUint32(&o.PIO_WAKEUP_LVL0.Reg)&^(0x1)|value)
}
func (o *SYSCON_Type) GetPIO_WAKEUP_LVL0_PA00_WAKEUP_LVL() uint32 {
	return volatile.LoadUint32(&o.PIO_WAKEUP_LVL0.Reg) & 0x1
}
func (o *SYSCON_Type) SetPIO_WAKEUP_LVL0_PA01_WAKEUP_LVL(value uint32) {
	volatile.StoreUint32(&o.PIO_WAKEUP_LVL0.Reg, volatile.LoadUint32(&o.PIO_WAKEUP_LVL0.Reg)&^(0x2)|value<<1)
}
func (o *SYSCON_Type) GetPIO_WAKEUP_LVL0_PA01_WAKEUP_LVL() uint32 {
	return (volatile.LoadUint32(&o.PIO_WAKEUP_LVL0.Reg) & 0x2) >> 1
}
func (o *SYSCON_Type) SetPIO_WAKEUP_LVL0_PA02_WAKEUP_LVL(value uint32) {
	volatile.StoreUint32(&o.PIO_WAKEUP_LVL0.Reg, volatile.LoadUint32(&o.PIO_WAKEUP_LVL0.Reg)&^(0x4)|value<<2)
}
func (o *SYSCON_Type) GetPIO_WAKEUP_LVL0_PA02_WAKEUP_LVL() uint32 {
	return (volatile.LoadUint32(&o.PIO_WAKEUP_LVL0.Reg) & 0x4) >> 2
}
func (o *SYSCON_Type) SetPIO_WAKEUP_LVL0_PA03_WAKEUP_LVL(value uint32) {
	volatile.StoreUint32(&o.PIO_WAKEUP_LVL0.Reg, volatile.LoadUint32(&o.PIO_WAKEUP_LVL0.Reg)&^(0x8)|value<<3)
}
func (o *SYSCON_Type) GetPIO_WAKEUP_LVL0_PA03_WAKEUP_LVL() uint32 {
	return (volatile.LoadUint32(&o.PIO_WAKEUP_LVL0.Reg) & 0x8) >> 3
}
func (o *SYSCON_Type) SetPIO_WAKEUP_LVL0_PA04_WAKEUP_LVL(value uint32) {
	volatile.StoreUint32(&o.PIO_WAKEUP_LVL0.Reg, volatile.LoadUint32(&o.PIO_WAKEUP_LVL0.Reg)&^(0x10)|value<<4)
}
func (o *SYSCON_Type) GetPIO_WAKEUP_LVL0_PA04_WAKEUP_LVL() uint32 {
	return (volatile.LoadUint32(&o.PIO_WAKEUP_LVL0.Reg) & 0x10) >> 4
}
func (o *SYSCON_Type) SetPIO_WAKEUP_LVL0_PA05_WAKEUP_LVL(value uint32) {
	volatile.StoreUint32(&o.PIO_WAKEUP_LVL0.Reg, volatile.LoadUint32(&o.PIO_WAKEUP_LVL0.Reg)&^(0x20)|value<<5)
}
func (o *SYSCON_Type) GetPIO_WAKEUP_LVL0_PA05_WAKEUP_LVL() uint32 {
	return (volatile.LoadUint32(&o.PIO_WAKEUP_LVL0.Reg) & 0x20) >> 5
}
func (o *SYSCON_Type) SetPIO_WAKEUP_LVL0_PA06_WAKEUP_LVL(value uint32) {
	volatile.StoreUint32(&o.PIO_WAKEUP_LVL0.Reg, volatile.LoadUint32(&o.PIO_WAKEUP_LVL0.Reg)&^(0x40)|value<<6)
}
func (o *SYSCON_Type) GetPIO_WAKEUP_LVL0_PA06_WAKEUP_LVL() uint32 {
	return (volatile.LoadUint32(&o.PIO_WAKEUP_LVL0.Reg) & 0x40) >> 6
}
func (o *SYSCON_Type) SetPIO_WAKEUP_LVL0_PA07_WAKEUP_LVL(value uint32) {
	volatile.StoreUint32(&o.PIO_WAKEUP_LVL0.Reg, volatile.LoadUint32(&o.PIO_WAKEUP_LVL0.Reg)&^(0x80)|value<<7)
}
func (o *SYSCON_Type) GetPIO_WAKEUP_LVL0_PA07_WAKEUP_LVL() uint32 {
	return (volatile.LoadUint32(&o.PIO_WAKEUP_LVL0.Reg) & 0x80) >> 7
}
func (o *SYSCON_Type) SetPIO_WAKEUP_LVL0_PA08_WAKEUP_LVL(value uint32) {
	volatile.StoreUint32(&o.PIO_WAKEUP_LVL0.Reg, volatile.LoadUint32(&o.PIO_WAKEUP_LVL0.Reg)&^(0x100)|value<<8)
}
func (o *SYSCON_Type) GetPIO_WAKEUP_LVL0_PA08_WAKEUP_LVL() uint32 {
	return (volatile.LoadUint32(&o.PIO_WAKEUP_LVL0.Reg) & 0x100) >> 8
}
func (o *SYSCON_Type) SetPIO_WAKEUP_LVL0_PA09_WAKEUP_LVL(value uint32) {
	volatile.StoreUint32(&o.PIO_WAKEUP_LVL0.Reg, volatile.LoadUint32(&o.PIO_WAKEUP_LVL0.Reg)&^(0x200)|value<<9)
}
func (o *SYSCON_Type) GetPIO_WAKEUP_LVL0_PA09_WAKEUP_LVL() uint32 {
	return (volatile.LoadUint32(&o.PIO_WAKEUP_LVL0.Reg) & 0x200) >> 9
}
func (o *SYSCON_Type) SetPIO_WAKEUP_LVL0_PA10_WAKEUP_LVL(value uint32) {
	volatile.StoreUint32(&o.PIO_WAKEUP_LVL0.Reg, volatile.LoadUint32(&o.PIO_WAKEUP_LVL0.Reg)&^(0x400)|value<<10)
}
func (o *SYSCON_Type) GetPIO_WAKEUP_LVL0_PA10_WAKEUP_LVL() uint32 {
	return (volatile.LoadUint32(&o.PIO_WAKEUP_LVL0.Reg) & 0x400) >> 10
}
func (o *SYSCON_Type) SetPIO_WAKEUP_LVL0_PA11_WAKEUP_LVL(value uint32) {
	volatile.StoreUint32(&o.PIO_WAKEUP_LVL0.Reg, volatile.LoadUint32(&o.PIO_WAKEUP_LVL0.Reg)&^(0x800)|value<<11)
}
func (o *SYSCON_Type) GetPIO_WAKEUP_LVL0_PA11_WAKEUP_LVL() uint32 {
	return (volatile.LoadUint32(&o.PIO_WAKEUP_LVL0.Reg) & 0x800) >> 11
}
func (o *SYSCON_Type) SetPIO_WAKEUP_LVL0_PA12_WAKEUP_LVL(value uint32) {
	volatile.StoreUint32(&o.PIO_WAKEUP_LVL0.Reg, volatile.LoadUint32(&o.PIO_WAKEUP_LVL0.Reg)&^(0x1000)|value<<12)
}
func (o *SYSCON_Type) GetPIO_WAKEUP_LVL0_PA12_WAKEUP_LVL() uint32 {
	return (volatile.LoadUint32(&o.PIO_WAKEUP_LVL0.Reg) & 0x1000) >> 12
}
func (o *SYSCON_Type) SetPIO_WAKEUP_LVL0_PA13_WAKEUP_LVL(value uint32) {
	volatile.StoreUint32(&o.PIO_WAKEUP_LVL0.Reg, volatile.LoadUint32(&o.PIO_WAKEUP_LVL0.Reg)&^(0x2000)|value<<13)
}
func (o *SYSCON_Type) GetPIO_WAKEUP_LVL0_PA13_WAKEUP_LVL() uint32 {
	return (volatile.LoadUint32(&o.PIO_WAKEUP_LVL0.Reg) & 0x2000) >> 13
}
func (o *SYSCON_Type) SetPIO_WAKEUP_LVL0_PA14_WAKEUP_LVL(value uint32) {
	volatile.StoreUint32(&o.PIO_WAKEUP_LVL0.Reg, volatile.LoadUint32(&o.PIO_WAKEUP_LVL0.Reg)&^(0x4000)|value<<14)
}
func (o *SYSCON_Type) GetPIO_WAKEUP_LVL0_PA14_WAKEUP_LVL() uint32 {
	return (volatile.LoadUint32(&o.PIO_WAKEUP_LVL0.Reg) & 0x4000) >> 14
}
func (o *SYSCON_Type) SetPIO_WAKEUP_LVL0_PA15_WAKEUP_LVL(value uint32) {
	volatile.StoreUint32(&o.PIO_WAKEUP_LVL0.Reg, volatile.LoadUint32(&o.PIO_WAKEUP_LVL0.Reg)&^(0x8000)|value<<15)
}
func (o *SYSCON_Type) GetPIO_WAKEUP_LVL0_PA15_WAKEUP_LVL() uint32 {
	return (volatile.LoadUint32(&o.PIO_WAKEUP_LVL0.Reg) & 0x8000) >> 15
}
func (o *SYSCON_Type) SetPIO_WAKEUP_LVL0_PA16_WAKEUP_LVL(value uint32) {
	volatile.StoreUint32(&o.PIO_WAKEUP_LVL0.Reg, volatile.LoadUint32(&o.PIO_WAKEUP_LVL0.Reg)&^(0x10000)|value<<16)
}
func (o *SYSCON_Type) GetPIO_WAKEUP_LVL0_PA16_WAKEUP_LVL() uint32 {
	return (volatile.LoadUint32(&o.PIO_WAKEUP_LVL0.Reg) & 0x10000) >> 16
}
func (o *SYSCON_Type) SetPIO_WAKEUP_LVL0_PA17_WAKEUP_LVL(value uint32) {
	volatile.StoreUint32(&o.PIO_WAKEUP_LVL0.Reg, volatile.LoadUint32(&o.PIO_WAKEUP_LVL0.Reg)&^(0x20000)|value<<17)
}
func (o *SYSCON_Type) GetPIO_WAKEUP_LVL0_PA17_WAKEUP_LVL() uint32 {
	return (volatile.LoadUint32(&o.PIO_WAKEUP_LVL0.Reg) & 0x20000) >> 17
}
func (o *SYSCON_Type) SetPIO_WAKEUP_LVL0_PA18_WAKEUP_LVL(value uint32) {
	volatile.StoreUint32(&o.PIO_WAKEUP_LVL0.Reg, volatile.LoadUint32(&o.PIO_WAKEUP_LVL0.Reg)&^(0x40000)|value<<18)
}
func (o *SYSCON_Type) GetPIO_WAKEUP_LVL0_PA18_WAKEUP_LVL() uint32 {
	return (volatile.LoadUint32(&o.PIO_WAKEUP_LVL0.Reg) & 0x40000) >> 18
}
func (o *SYSCON_Type) SetPIO_WAKEUP_LVL0_PA19_WAKEUP_LVL(value uint32) {
	volatile.StoreUint32(&o.PIO_WAKEUP_LVL0.Reg, volatile.LoadUint32(&o.PIO_WAKEUP_LVL0.Reg)&^(0x80000)|value<<19)
}
func (o *SYSCON_Type) GetPIO_WAKEUP_LVL0_PA19_WAKEUP_LVL() uint32 {
	return (volatile.LoadUint32(&o.PIO_WAKEUP_LVL0.Reg) & 0x80000) >> 19
}
func (o *SYSCON_Type) SetPIO_WAKEUP_LVL0_PA20_WAKEUP_LVL(value uint32) {
	volatile.StoreUint32(&o.PIO_WAKEUP_LVL0.Reg, volatile.LoadUint32(&o.PIO_WAKEUP_LVL0.Reg)&^(0x100000)|value<<20)
}
func (o *SYSCON_Type) GetPIO_WAKEUP_LVL0_PA20_WAKEUP_LVL() uint32 {
	return (volatile.LoadUint32(&o.PIO_WAKEUP_LVL0.Reg) & 0x100000) >> 20
}
func (o *SYSCON_Type) SetPIO_WAKEUP_LVL0_PA21_WAKEUP_LVL(value uint32) {
	volatile.StoreUint32(&o.PIO_WAKEUP_LVL0.Reg, volatile.LoadUint32(&o.PIO_WAKEUP_LVL0.Reg)&^(0x200000)|value<<21)
}
func (o *SYSCON_Type) GetPIO_WAKEUP_LVL0_PA21_WAKEUP_LVL() uint32 {
	return (volatile.LoadUint32(&o.PIO_WAKEUP_LVL0.Reg) & 0x200000) >> 21
}
func (o *SYSCON_Type) SetPIO_WAKEUP_LVL0_PA22_WAKEUP_LVL(value uint32) {
	volatile.StoreUint32(&o.PIO_WAKEUP_LVL0.Reg, volatile.LoadUint32(&o.PIO_WAKEUP_LVL0.Reg)&^(0x400000)|value<<22)
}
func (o *SYSCON_Type) GetPIO_WAKEUP_LVL0_PA22_WAKEUP_LVL() uint32 {
	return (volatile.LoadUint32(&o.PIO_WAKEUP_LVL0.Reg) & 0x400000) >> 22
}
func (o *SYSCON_Type) SetPIO_WAKEUP_LVL0_PA23_WAKEUP_LVL(value uint32) {
	volatile.StoreUint32(&o.PIO_WAKEUP_LVL0.Reg, volatile.LoadUint32(&o.PIO_WAKEUP_LVL0.Reg)&^(0x800000)|value<<23)
}
func (o *SYSCON_Type) GetPIO_WAKEUP_LVL0_PA23_WAKEUP_LVL() uint32 {
	return (volatile.LoadUint32(&o.PIO_WAKEUP_LVL0.Reg) & 0x800000) >> 23
}
func (o *SYSCON_Type) SetPIO_WAKEUP_LVL0_PA24_WAKEUP_LVL(value uint32) {
	volatile.StoreUint32(&o.PIO_WAKEUP_LVL0.Reg, volatile.LoadUint32(&o.PIO_WAKEUP_LVL0.Reg)&^(0x1000000)|value<<24)
}
func (o *SYSCON_Type) GetPIO_WAKEUP_LVL0_PA24_WAKEUP_LVL() uint32 {
	return (volatile.LoadUint32(&o.PIO_WAKEUP_LVL0.Reg) & 0x1000000) >> 24
}
func (o *SYSCON_Type) SetPIO_WAKEUP_LVL0_PA25_WAKEUP_LVL(value uint32) {
	volatile.StoreUint32(&o.PIO_WAKEUP_LVL0.Reg, volatile.LoadUint32(&o.PIO_WAKEUP_LVL0.Reg)&^(0x2000000)|value<<25)
}
func (o *SYSCON_Type) GetPIO_WAKEUP_LVL0_PA25_WAKEUP_LVL() uint32 {
	return (volatile.LoadUint32(&o.PIO_WAKEUP_LVL0.Reg) & 0x2000000) >> 25
}
func (o *SYSCON_Type) SetPIO_WAKEUP_LVL0_PA26_WAKEUP_LVL(value uint32) {
	volatile.StoreUint32(&o.PIO_WAKEUP_LVL0.Reg, volatile.LoadUint32(&o.PIO_WAKEUP_LVL0.Reg)&^(0x4000000)|value<<26)
}
func (o *SYSCON_Type) GetPIO_WAKEUP_LVL0_PA26_WAKEUP_LVL() uint32 {
	return (volatile.LoadUint32(&o.PIO_WAKEUP_LVL0.Reg) & 0x4000000) >> 26
}
func (o *SYSCON_Type) SetPIO_WAKEUP_LVL0_PA27_WAKEUP_LVL(value uint32) {
	volatile.StoreUint32(&o.PIO_WAKEUP_LVL0.Reg, volatile.LoadUint32(&o.PIO_WAKEUP_LVL0.Reg)&^(0x8000000)|value<<27)
}
func (o *SYSCON_Type) GetPIO_WAKEUP_LVL0_PA27_WAKEUP_LVL() uint32 {
	return (volatile.LoadUint32(&o.PIO_WAKEUP_LVL0.Reg) & 0x8000000) >> 27
}
func (o *SYSCON_Type) SetPIO_WAKEUP_LVL0_PA28_WAKEUP_LVL(value uint32) {
	volatile.StoreUint32(&o.PIO_WAKEUP_LVL0.Reg, volatile.LoadUint32(&o.PIO_WAKEUP_LVL0.Reg)&^(0x10000000)|value<<28)
}
func (o *SYSCON_Type) GetPIO_WAKEUP_LVL0_PA28_WAKEUP_LVL() uint32 {
	return (volatile.LoadUint32(&o.PIO_WAKEUP_LVL0.Reg) & 0x10000000) >> 28
}
func (o *SYSCON_Type) SetPIO_WAKEUP_LVL0_PA29_WAKEUP_LVL(value uint32) {
	volatile.StoreUint32(&o.PIO_WAKEUP_LVL0.Reg, volatile.LoadUint32(&o.PIO_WAKEUP_LVL0.Reg)&^(0x20000000)|value<<29)
}
func (o *SYSCON_Type) GetPIO_WAKEUP_LVL0_PA29_WAKEUP_LVL() uint32 {
	return (volatile.LoadUint32(&o.PIO_WAKEUP_LVL0.Reg) & 0x20000000) >> 29
}
func (o *SYSCON_Type) SetPIO_WAKEUP_LVL0_PA30_WAKEUP_LVL(value uint32) {
	volatile.StoreUint32(&o.PIO_WAKEUP_LVL0.Reg, volatile.LoadUint32(&o.PIO_WAKEUP_LVL0.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSCON_Type) GetPIO_WAKEUP_LVL0_PA30_WAKEUP_LVL() uint32 {
	return (volatile.LoadUint32(&o.PIO_WAKEUP_LVL0.Reg) & 0x40000000) >> 30
}
func (o *SYSCON_Type) SetPIO_WAKEUP_LVL0_PA31_WAKEUP_LVL(value uint32) {
	volatile.StoreUint32(&o.PIO_WAKEUP_LVL0.Reg, volatile.LoadUint32(&o.PIO_WAKEUP_LVL0.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSCON_Type) GetPIO_WAKEUP_LVL0_PA31_WAKEUP_LVL() uint32 {
	return (volatile.LoadUint32(&o.PIO_WAKEUP_LVL0.Reg) & 0x80000000) >> 31
}

// SYSCON.PIO_WAKEUP_LVL1: pin wakeup polarity register 1
func (o *SYSCON_Type) SetPIO_WAKEUP_LVL1_PB00_WAKEUP_LVL(value uint32) {
	volatile.StoreUint32(&o.PIO_WAKEUP_LVL1.Reg, volatile.LoadUint32(&o.PIO_WAKEUP_LVL1.Reg)&^(0x1)|value)
}
func (o *SYSCON_Type) GetPIO_WAKEUP_LVL1_PB00_WAKEUP_LVL() uint32 {
	return volatile.LoadUint32(&o.PIO_WAKEUP_LVL1.Reg) & 0x1
}
func (o *SYSCON_Type) SetPIO_WAKEUP_LVL1_PB01_WAKEUP_LVL(value uint32) {
	volatile.StoreUint32(&o.PIO_WAKEUP_LVL1.Reg, volatile.LoadUint32(&o.PIO_WAKEUP_LVL1.Reg)&^(0x2)|value<<1)
}
func (o *SYSCON_Type) GetPIO_WAKEUP_LVL1_PB01_WAKEUP_LVL() uint32 {
	return (volatile.LoadUint32(&o.PIO_WAKEUP_LVL1.Reg) & 0x2) >> 1
}
func (o *SYSCON_Type) SetPIO_WAKEUP_LVL1_PB02_WAKEUP_LVL(value uint32) {
	volatile.StoreUint32(&o.PIO_WAKEUP_LVL1.Reg, volatile.LoadUint32(&o.PIO_WAKEUP_LVL1.Reg)&^(0x4)|value<<2)
}
func (o *SYSCON_Type) GetPIO_WAKEUP_LVL1_PB02_WAKEUP_LVL() uint32 {
	return (volatile.LoadUint32(&o.PIO_WAKEUP_LVL1.Reg) & 0x4) >> 2
}

// SYSCON.PIO_IE_CFG0: pad input enable register 0
func (o *SYSCON_Type) SetPIO_IE_CFG0_PA00_IE(value uint32) {
	volatile.StoreUint32(&o.PIO_IE_CFG0.Reg, volatile.LoadUint32(&o.PIO_IE_CFG0.Reg)&^(0x1)|value)
}
func (o *SYSCON_Type) GetPIO_IE_CFG0_PA00_IE() uint32 {
	return volatile.LoadUint32(&o.PIO_IE_CFG0.Reg) & 0x1
}
func (o *SYSCON_Type) SetPIO_IE_CFG0_PA01_IE(value uint32) {
	volatile.StoreUint32(&o.PIO_IE_CFG0.Reg, volatile.LoadUint32(&o.PIO_IE_CFG0.Reg)&^(0x2)|value<<1)
}
func (o *SYSCON_Type) GetPIO_IE_CFG0_PA01_IE() uint32 {
	return (volatile.LoadUint32(&o.PIO_IE_CFG0.Reg) & 0x2) >> 1
}
func (o *SYSCON_Type) SetPIO_IE_CFG0_PA02_IE(value uint32) {
	volatile.StoreUint32(&o.PIO_IE_CFG0.Reg, volatile.LoadUint32(&o.PIO_IE_CFG0.Reg)&^(0x4)|value<<2)
}
func (o *SYSCON_Type) GetPIO_IE_CFG0_PA02_IE() uint32 {
	return (volatile.LoadUint32(&o.PIO_IE_CFG0.Reg) & 0x4) >> 2
}
func (o *SYSCON_Type) SetPIO_IE_CFG0_PA03_IE(value uint32) {
	volatile.StoreUint32(&o.PIO_IE_CFG0.Reg, volatile.LoadUint32(&o.PIO_IE_CFG0.Reg)&^(0x8)|value<<3)
}
func (o *SYSCON_Type) GetPIO_IE_CFG0_PA03_IE() uint32 {
	return (volatile.LoadUint32(&o.PIO_IE_CFG0.Reg) & 0x8) >> 3
}
func (o *SYSCON_Type) SetPIO_IE_CFG0_PA04_IE(value uint32) {
	volatile.StoreUint32(&o.PIO_IE_CFG0.Reg, volatile.LoadUint32(&o.PIO_IE_CFG0.Reg)&^(0x10)|value<<4)
}
func (o *SYSCON_Type) GetPIO_IE_CFG0_PA04_IE() uint32 {
	return (volatile.LoadUint32(&o.PIO_IE_CFG0.Reg) & 0x10) >> 4
}
func (o *SYSCON_Type) SetPIO_IE_CFG0_PA05_IE(value uint32) {
	volatile.StoreUint32(&o.PIO_IE_CFG0.Reg, volatile.LoadUint32(&o.PIO_IE_CFG0.Reg)&^(0x20)|value<<5)
}
func (o *SYSCON_Type) GetPIO_IE_CFG0_PA05_IE() uint32 {
	return (volatile.LoadUint32(&o.PIO_IE_CFG0.Reg) & 0x20) >> 5
}
func (o *SYSCON_Type) SetPIO_IE_CFG0_PA06_IE(value uint32) {
	volatile.StoreUint32(&o.PIO_IE_CFG0.Reg, volatile.LoadUint32(&o.PIO_IE_CFG0.Reg)&^(0x40)|value<<6)
}
func (o *SYSCON_Type) GetPIO_IE_CFG0_PA06_IE() uint32 {
	return (volatile.LoadUint32(&o.PIO_IE_CFG0.Reg) & 0x40) >> 6
}
func (o *SYSCON_Type) SetPIO_IE_CFG0_PA07_IE(value uint32) {
	volatile.StoreUint32(&o.PIO_IE_CFG0.Reg, volatile.LoadUint32(&o.PIO_IE_CFG0.Reg)&^(0x80)|value<<7)
}
func (o *SYSCON_Type) GetPIO_IE_CFG0_PA07_IE() uint32 {
	return (volatile.LoadUint32(&o.PIO_IE_CFG0.Reg) & 0x80) >> 7
}
func (o *SYSCON_Type) SetPIO_IE_CFG0_PA08_IE(value uint32) {
	volatile.StoreUint32(&o.PIO_IE_CFG0.Reg, volatile.LoadUint32(&o.PIO_IE_CFG0.Reg)&^(0x100)|value<<8)
}
func (o *SYSCON_Type) GetPIO_IE_CFG0_PA08_IE() uint32 {
	return (volatile.LoadUint32(&o.PIO_IE_CFG0.Reg) & 0x100) >> 8
}
func (o *SYSCON_Type) SetPIO_IE_CFG0_PA09_IE(value uint32) {
	volatile.StoreUint32(&o.PIO_IE_CFG0.Reg, volatile.LoadUint32(&o.PIO_IE_CFG0.Reg)&^(0x200)|value<<9)
}
func (o *SYSCON_Type) GetPIO_IE_CFG0_PA09_IE() uint32 {
	return (volatile.LoadUint32(&o.PIO_IE_CFG0.Reg) & 0x200) >> 9
}
func (o *SYSCON_Type) SetPIO_IE_CFG0_PA10_IE(value uint32) {
	volatile.StoreUint32(&o.PIO_IE_CFG0.Reg, volatile.LoadUint32(&o.PIO_IE_CFG0.Reg)&^(0x400)|value<<10)
}
func (o *SYSCON_Type) GetPIO_IE_CFG0_PA10_IE() uint32 {
	return (volatile.LoadUint32(&o.PIO_IE_CFG0.Reg) & 0x400) >> 10
}
func (o *SYSCON_Type) SetPIO_IE_CFG0_PA11_IE(value uint32) {
	volatile.StoreUint32(&o.PIO_IE_CFG0.Reg, volatile.LoadUint32(&o.PIO_IE_CFG0.Reg)&^(0x800)|value<<11)
}
func (o *SYSCON_Type) GetPIO_IE_CFG0_PA11_IE() uint32 {
	return (volatile.LoadUint32(&o.PIO_IE_CFG0.Reg) & 0x800) >> 11
}
func (o *SYSCON_Type) SetPIO_IE_CFG0_PA12_IE(value uint32) {
	volatile.StoreUint32(&o.PIO_IE_CFG0.Reg, volatile.LoadUint32(&o.PIO_IE_CFG0.Reg)&^(0x1000)|value<<12)
}
func (o *SYSCON_Type) GetPIO_IE_CFG0_PA12_IE() uint32 {
	return (volatile.LoadUint32(&o.PIO_IE_CFG0.Reg) & 0x1000) >> 12
}
func (o *SYSCON_Type) SetPIO_IE_CFG0_PA13_IE(value uint32) {
	volatile.StoreUint32(&o.PIO_IE_CFG0.Reg, volatile.LoadUint32(&o.PIO_IE_CFG0.Reg)&^(0x2000)|value<<13)
}
func (o *SYSCON_Type) GetPIO_IE_CFG0_PA13_IE() uint32 {
	return (volatile.LoadUint32(&o.PIO_IE_CFG0.Reg) & 0x2000) >> 13
}
func (o *SYSCON_Type) SetPIO_IE_CFG0_PA14_IE(value uint32) {
	volatile.StoreUint32(&o.PIO_IE_CFG0.Reg, volatile.LoadUint32(&o.PIO_IE_CFG0.Reg)&^(0x4000)|value<<14)
}
func (o *SYSCON_Type) GetPIO_IE_CFG0_PA14_IE() uint32 {
	return (volatile.LoadUint32(&o.PIO_IE_CFG0.Reg) & 0x4000) >> 14
}
func (o *SYSCON_Type) SetPIO_IE_CFG0_PA15_IE(value uint32) {
	volatile.StoreUint32(&o.PIO_IE_CFG0.Reg, volatile.LoadUint32(&o.PIO_IE_CFG0.Reg)&^(0x8000)|value<<15)
}
func (o *SYSCON_Type) GetPIO_IE_CFG0_PA15_IE() uint32 {
	return (volatile.LoadUint32(&o.PIO_IE_CFG0.Reg) & 0x8000) >> 15
}
func (o *SYSCON_Type) SetPIO_IE_CFG0_PA16_IE(value uint32) {
	volatile.StoreUint32(&o.PIO_IE_CFG0.Reg, volatile.LoadUint32(&o.PIO_IE_CFG0.Reg)&^(0x10000)|value<<16)
}
func (o *SYSCON_Type) GetPIO_IE_CFG0_PA16_IE() uint32 {
	return (volatile.LoadUint32(&o.PIO_IE_CFG0.Reg) & 0x10000) >> 16
}
func (o *SYSCON_Type) SetPIO_IE_CFG0_PA17_IE(value uint32) {
	volatile.StoreUint32(&o.PIO_IE_CFG0.Reg, volatile.LoadUint32(&o.PIO_IE_CFG0.Reg)&^(0x20000)|value<<17)
}
func (o *SYSCON_Type) GetPIO_IE_CFG0_PA17_IE() uint32 {
	return (volatile.LoadUint32(&o.PIO_IE_CFG0.Reg) & 0x20000) >> 17
}
func (o *SYSCON_Type) SetPIO_IE_CFG0_PA18_IE(value uint32) {
	volatile.StoreUint32(&o.PIO_IE_CFG0.Reg, volatile.LoadUint32(&o.PIO_IE_CFG0.Reg)&^(0x40000)|value<<18)
}
func (o *SYSCON_Type) GetPIO_IE_CFG0_PA18_IE() uint32 {
	return (volatile.LoadUint32(&o.PIO_IE_CFG0.Reg) & 0x40000) >> 18
}
func (o *SYSCON_Type) SetPIO_IE_CFG0_PA19_IE(value uint32) {
	volatile.StoreUint32(&o.PIO_IE_CFG0.Reg, volatile.LoadUint32(&o.PIO_IE_CFG0.Reg)&^(0x80000)|value<<19)
}
func (o *SYSCON_Type) GetPIO_IE_CFG0_PA19_IE() uint32 {
	return (volatile.LoadUint32(&o.PIO_IE_CFG0.Reg) & 0x80000) >> 19
}
func (o *SYSCON_Type) SetPIO_IE_CFG0_PA20_IE(value uint32) {
	volatile.StoreUint32(&o.PIO_IE_CFG0.Reg, volatile.LoadUint32(&o.PIO_IE_CFG0.Reg)&^(0x100000)|value<<20)
}
func (o *SYSCON_Type) GetPIO_IE_CFG0_PA20_IE() uint32 {
	return (volatile.LoadUint32(&o.PIO_IE_CFG0.Reg) & 0x100000) >> 20
}
func (o *SYSCON_Type) SetPIO_IE_CFG0_PA21_IE(value uint32) {
	volatile.StoreUint32(&o.PIO_IE_CFG0.Reg, volatile.LoadUint32(&o.PIO_IE_CFG0.Reg)&^(0x200000)|value<<21)
}
func (o *SYSCON_Type) GetPIO_IE_CFG0_PA21_IE() uint32 {
	return (volatile.LoadUint32(&o.PIO_IE_CFG0.Reg) & 0x200000) >> 21
}
func (o *SYSCON_Type) SetPIO_IE_CFG0_PA22_IE(value uint32) {
	volatile.StoreUint32(&o.PIO_IE_CFG0.Reg, volatile.LoadUint32(&o.PIO_IE_CFG0.Reg)&^(0x400000)|value<<22)
}
func (o *SYSCON_Type) GetPIO_IE_CFG0_PA22_IE() uint32 {
	return (volatile.LoadUint32(&o.PIO_IE_CFG0.Reg) & 0x400000) >> 22
}
func (o *SYSCON_Type) SetPIO_IE_CFG0_PA23_IE(value uint32) {
	volatile.StoreUint32(&o.PIO_IE_CFG0.Reg, volatile.LoadUint32(&o.PIO_IE_CFG0.Reg)&^(0x800000)|value<<23)
}
func (o *SYSCON_Type) GetPIO_IE_CFG0_PA23_IE() uint32 {
	return (volatile.LoadUint32(&o.PIO_IE_CFG0.Reg) & 0x800000) >> 23
}
func (o *SYSCON_Type) SetPIO_IE_CFG0_PA24_IE(value uint32) {
	volatile.StoreUint32(&o.PIO_IE_CFG0.Reg, volatile.LoadUint32(&o.PIO_IE_CFG0.Reg)&^(0x1000000)|value<<24)
}
func (o *SYSCON_Type) GetPIO_IE_CFG0_PA24_IE() uint32 {
	return (volatile.LoadUint32(&o.PIO_IE_CFG0.Reg) & 0x1000000) >> 24
}
func (o *SYSCON_Type) SetPIO_IE_CFG0_PA25_IE(value uint32) {
	volatile.StoreUint32(&o.PIO_IE_CFG0.Reg, volatile.LoadUint32(&o.PIO_IE_CFG0.Reg)&^(0x2000000)|value<<25)
}
func (o *SYSCON_Type) GetPIO_IE_CFG0_PA25_IE() uint32 {
	return (volatile.LoadUint32(&o.PIO_IE_CFG0.Reg) & 0x2000000) >> 25
}
func (o *SYSCON_Type) SetPIO_IE_CFG0_PA26_IE(value uint32) {
	volatile.StoreUint32(&o.PIO_IE_CFG0.Reg, volatile.LoadUint32(&o.PIO_IE_CFG0.Reg)&^(0x4000000)|value<<26)
}
func (o *SYSCON_Type) GetPIO_IE_CFG0_PA26_IE() uint32 {
	return (volatile.LoadUint32(&o.PIO_IE_CFG0.Reg) & 0x4000000) >> 26
}
func (o *SYSCON_Type) SetPIO_IE_CFG0_PA27_IE(value uint32) {
	volatile.StoreUint32(&o.PIO_IE_CFG0.Reg, volatile.LoadUint32(&o.PIO_IE_CFG0.Reg)&^(0x8000000)|value<<27)
}
func (o *SYSCON_Type) GetPIO_IE_CFG0_PA27_IE() uint32 {
	return (volatile.LoadUint32(&o.PIO_IE_CFG0.Reg) & 0x8000000) >> 27
}
func (o *SYSCON_Type) SetPIO_IE_CFG0_PA28_IE(value uint32) {
	volatile.StoreUint32(&o.PIO_IE_CFG0.Reg, volatile.LoadUint32(&o.PIO_IE_CFG0.Reg)&^(0x10000000)|value<<28)
}
func (o *SYSCON_Type) GetPIO_IE_CFG0_PA28_IE() uint32 {
	return (volatile.LoadUint32(&o.PIO_IE_CFG0.Reg) & 0x10000000) >> 28
}
func (o *SYSCON_Type) SetPIO_IE_CFG0_PA29_IE(value uint32) {
	volatile.StoreUint32(&o.PIO_IE_CFG0.Reg, volatile.LoadUint32(&o.PIO_IE_CFG0.Reg)&^(0x20000000)|value<<29)
}
func (o *SYSCON_Type) GetPIO_IE_CFG0_PA29_IE() uint32 {
	return (volatile.LoadUint32(&o.PIO_IE_CFG0.Reg) & 0x20000000) >> 29
}
func (o *SYSCON_Type) SetPIO_IE_CFG0_PA30_IE(value uint32) {
	volatile.StoreUint32(&o.PIO_IE_CFG0.Reg, volatile.LoadUint32(&o.PIO_IE_CFG0.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSCON_Type) GetPIO_IE_CFG0_PA30_IE() uint32 {
	return (volatile.LoadUint32(&o.PIO_IE_CFG0.Reg) & 0x40000000) >> 30
}
func (o *SYSCON_Type) SetPIO_IE_CFG0_PA31_IE(value uint32) {
	volatile.StoreUint32(&o.PIO_IE_CFG0.Reg, volatile.LoadUint32(&o.PIO_IE_CFG0.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSCON_Type) GetPIO_IE_CFG0_PA31_IE() uint32 {
	return (volatile.LoadUint32(&o.PIO_IE_CFG0.Reg) & 0x80000000) >> 31
}

// SYSCON.PIO_IE_CFG1: pad input enable register 1
func (o *SYSCON_Type) SetPIO_IE_CFG1_PB00_IE(value uint32) {
	volatile.StoreUint32(&o.PIO_IE_CFG1.Reg, volatile.LoadUint32(&o.PIO_IE_CFG1.Reg)&^(0x1)|value)
}
func (o *SYSCON_Type) GetPIO_IE_CFG1_PB00_IE() uint32 {
	return volatile.LoadUint32(&o.PIO_IE_CFG1.Reg) & 0x1
}
func (o *SYSCON_Type) SetPIO_IE_CFG1_PB01_IE(value uint32) {
	volatile.StoreUint32(&o.PIO_IE_CFG1.Reg, volatile.LoadUint32(&o.PIO_IE_CFG1.Reg)&^(0x2)|value<<1)
}
func (o *SYSCON_Type) GetPIO_IE_CFG1_PB01_IE() uint32 {
	return (volatile.LoadUint32(&o.PIO_IE_CFG1.Reg) & 0x2) >> 1
}
func (o *SYSCON_Type) SetPIO_IE_CFG1_BOOT_MODE_IE(value uint32) {
	volatile.StoreUint32(&o.PIO_IE_CFG1.Reg, volatile.LoadUint32(&o.PIO_IE_CFG1.Reg)&^(0x4)|value<<2)
}
func (o *SYSCON_Type) GetPIO_IE_CFG1_BOOT_MODE_IE() uint32 {
	return (volatile.LoadUint32(&o.PIO_IE_CFG1.Reg) & 0x4) >> 2
}

// SYSCON.PIO_FUNC_CFG0: pin mux control register 0
func (o *SYSCON_Type) SetPIO_FUNC_CFG0_PA00_FUNC(value uint32) {
	volatile.StoreUint32(&o.PIO_FUNC_CFG0.Reg, volatile.LoadUint32(&o.PIO_FUNC_CFG0.Reg)&^(0x7)|value)
}
func (o *SYSCON_Type) GetPIO_FUNC_CFG0_PA00_FUNC() uint32 {
	return volatile.LoadUint32(&o.PIO_FUNC_CFG0.Reg) & 0x7
}
func (o *SYSCON_Type) SetPIO_FUNC_CFG0_PA01_FUNC(value uint32) {
	volatile.StoreUint32(&o.PIO_FUNC_CFG0.Reg, volatile.LoadUint32(&o.PIO_FUNC_CFG0.Reg)&^(0x70)|value<<4)
}
func (o *SYSCON_Type) GetPIO_FUNC_CFG0_PA01_FUNC() uint32 {
	return (volatile.LoadUint32(&o.PIO_FUNC_CFG0.Reg) & 0x70) >> 4
}
func (o *SYSCON_Type) SetPIO_FUNC_CFG0_PA02_FUNC(value uint32) {
	volatile.StoreUint32(&o.PIO_FUNC_CFG0.Reg, volatile.LoadUint32(&o.PIO_FUNC_CFG0.Reg)&^(0x700)|value<<8)
}
func (o *SYSCON_Type) GetPIO_FUNC_CFG0_PA02_FUNC() uint32 {
	return (volatile.LoadUint32(&o.PIO_FUNC_CFG0.Reg) & 0x700) >> 8
}
func (o *SYSCON_Type) SetPIO_FUNC_CFG0_PA03_FUNC(value uint32) {
	volatile.StoreUint32(&o.PIO_FUNC_CFG0.Reg, volatile.LoadUint32(&o.PIO_FUNC_CFG0.Reg)&^(0x7000)|value<<12)
}
func (o *SYSCON_Type) GetPIO_FUNC_CFG0_PA03_FUNC() uint32 {
	return (volatile.LoadUint32(&o.PIO_FUNC_CFG0.Reg) & 0x7000) >> 12
}
func (o *SYSCON_Type) SetPIO_FUNC_CFG0_PA04_FUNC(value uint32) {
	volatile.StoreUint32(&o.PIO_FUNC_CFG0.Reg, volatile.LoadUint32(&o.PIO_FUNC_CFG0.Reg)&^(0x70000)|value<<16)
}
func (o *SYSCON_Type) GetPIO_FUNC_CFG0_PA04_FUNC() uint32 {
	return (volatile.LoadUint32(&o.PIO_FUNC_CFG0.Reg) & 0x70000) >> 16
}
func (o *SYSCON_Type) SetPIO_FUNC_CFG0_PA05_FUNC(value uint32) {
	volatile.StoreUint32(&o.PIO_FUNC_CFG0.Reg, volatile.LoadUint32(&o.PIO_FUNC_CFG0.Reg)&^(0x700000)|value<<20)
}
func (o *SYSCON_Type) GetPIO_FUNC_CFG0_PA05_FUNC() uint32 {
	return (volatile.LoadUint32(&o.PIO_FUNC_CFG0.Reg) & 0x700000) >> 20
}
func (o *SYSCON_Type) SetPIO_FUNC_CFG0_PA06_FUNC(value uint32) {
	volatile.StoreUint32(&o.PIO_FUNC_CFG0.Reg, volatile.LoadUint32(&o.PIO_FUNC_CFG0.Reg)&^(0x7000000)|value<<24)
}
func (o *SYSCON_Type) GetPIO_FUNC_CFG0_PA06_FUNC() uint32 {
	return (volatile.LoadUint32(&o.PIO_FUNC_CFG0.Reg) & 0x7000000) >> 24
}
func (o *SYSCON_Type) SetPIO_FUNC_CFG0_PA07_FUNC(value uint32) {
	volatile.StoreUint32(&o.PIO_FUNC_CFG0.Reg, volatile.LoadUint32(&o.PIO_FUNC_CFG0.Reg)&^(0x70000000)|value<<28)
}
func (o *SYSCON_Type) GetPIO_FUNC_CFG0_PA07_FUNC() uint32 {
	return (volatile.LoadUint32(&o.PIO_FUNC_CFG0.Reg) & 0x70000000) >> 28
}

// SYSCON.PIO_FUNC_CFG1: pin mux control register 1
func (o *SYSCON_Type) SetPIO_FUNC_CFG1_PA08_FUNC(value uint32) {
	volatile.StoreUint32(&o.PIO_FUNC_CFG1.Reg, volatile.LoadUint32(&o.PIO_FUNC_CFG1.Reg)&^(0x7)|value)
}
func (o *SYSCON_Type) GetPIO_FUNC_CFG1_PA08_FUNC() uint32 {
	return volatile.LoadUint32(&o.PIO_FUNC_CFG1.Reg) & 0x7
}
func (o *SYSCON_Type) SetPIO_FUNC_CFG1_PA09_FUNC(value uint32) {
	volatile.StoreUint32(&o.PIO_FUNC_CFG1.Reg, volatile.LoadUint32(&o.PIO_FUNC_CFG1.Reg)&^(0x70)|value<<4)
}
func (o *SYSCON_Type) GetPIO_FUNC_CFG1_PA09_FUNC() uint32 {
	return (volatile.LoadUint32(&o.PIO_FUNC_CFG1.Reg) & 0x70) >> 4
}
func (o *SYSCON_Type) SetPIO_FUNC_CFG1_PA10_FUNC(value uint32) {
	volatile.StoreUint32(&o.PIO_FUNC_CFG1.Reg, volatile.LoadUint32(&o.PIO_FUNC_CFG1.Reg)&^(0x700)|value<<8)
}
func (o *SYSCON_Type) GetPIO_FUNC_CFG1_PA10_FUNC() uint32 {
	return (volatile.LoadUint32(&o.PIO_FUNC_CFG1.Reg) & 0x700) >> 8
}
func (o *SYSCON_Type) SetPIO_FUNC_CFG1_PA11_FUNC(value uint32) {
	volatile.StoreUint32(&o.PIO_FUNC_CFG1.Reg, volatile.LoadUint32(&o.PIO_FUNC_CFG1.Reg)&^(0x7000)|value<<12)
}
func (o *SYSCON_Type) GetPIO_FUNC_CFG1_PA11_FUNC() uint32 {
	return (volatile.LoadUint32(&o.PIO_FUNC_CFG1.Reg) & 0x7000) >> 12
}
func (o *SYSCON_Type) SetPIO_FUNC_CFG1_PA12_FUNC(value uint32) {
	volatile.StoreUint32(&o.PIO_FUNC_CFG1.Reg, volatile.LoadUint32(&o.PIO_FUNC_CFG1.Reg)&^(0x70000)|value<<16)
}
func (o *SYSCON_Type) GetPIO_FUNC_CFG1_PA12_FUNC() uint32 {
	return (volatile.LoadUint32(&o.PIO_FUNC_CFG1.Reg) & 0x70000) >> 16
}
func (o *SYSCON_Type) SetPIO_FUNC_CFG1_PA13_FUNC(value uint32) {
	volatile.StoreUint32(&o.PIO_FUNC_CFG1.Reg, volatile.LoadUint32(&o.PIO_FUNC_CFG1.Reg)&^(0x700000)|value<<20)
}
func (o *SYSCON_Type) GetPIO_FUNC_CFG1_PA13_FUNC() uint32 {
	return (volatile.LoadUint32(&o.PIO_FUNC_CFG1.Reg) & 0x700000) >> 20
}
func (o *SYSCON_Type) SetPIO_FUNC_CFG1_PA14_FUNC(value uint32) {
	volatile.StoreUint32(&o.PIO_FUNC_CFG1.Reg, volatile.LoadUint32(&o.PIO_FUNC_CFG1.Reg)&^(0x7000000)|value<<24)
}
func (o *SYSCON_Type) GetPIO_FUNC_CFG1_PA14_FUNC() uint32 {
	return (volatile.LoadUint32(&o.PIO_FUNC_CFG1.Reg) & 0x7000000) >> 24
}
func (o *SYSCON_Type) SetPIO_FUNC_CFG1_PA15_FUNC(value uint32) {
	volatile.StoreUint32(&o.PIO_FUNC_CFG1.Reg, volatile.LoadUint32(&o.PIO_FUNC_CFG1.Reg)&^(0x70000000)|value<<28)
}
func (o *SYSCON_Type) GetPIO_FUNC_CFG1_PA15_FUNC() uint32 {
	return (volatile.LoadUint32(&o.PIO_FUNC_CFG1.Reg) & 0x70000000) >> 28
}

// SYSCON.PIO_FUNC_CFG2: pin mux control register 2
func (o *SYSCON_Type) SetPIO_FUNC_CFG2_PA16_FUNC(value uint32) {
	volatile.StoreUint32(&o.PIO_FUNC_CFG2.Reg, volatile.LoadUint32(&o.PIO_FUNC_CFG2.Reg)&^(0x7)|value)
}
func (o *SYSCON_Type) GetPIO_FUNC_CFG2_PA16_FUNC() uint32 {
	return volatile.LoadUint32(&o.PIO_FUNC_CFG2.Reg) & 0x7
}
func (o *SYSCON_Type) SetPIO_FUNC_CFG2_PA17_FUNC(value uint32) {
	volatile.StoreUint32(&o.PIO_FUNC_CFG2.Reg, volatile.LoadUint32(&o.PIO_FUNC_CFG2.Reg)&^(0x70)|value<<4)
}
func (o *SYSCON_Type) GetPIO_FUNC_CFG2_PA17_FUNC() uint32 {
	return (volatile.LoadUint32(&o.PIO_FUNC_CFG2.Reg) & 0x70) >> 4
}
func (o *SYSCON_Type) SetPIO_FUNC_CFG2_PA18_FUNC(value uint32) {
	volatile.StoreUint32(&o.PIO_FUNC_CFG2.Reg, volatile.LoadUint32(&o.PIO_FUNC_CFG2.Reg)&^(0x700)|value<<8)
}
func (o *SYSCON_Type) GetPIO_FUNC_CFG2_PA18_FUNC() uint32 {
	return (volatile.LoadUint32(&o.PIO_FUNC_CFG2.Reg) & 0x700) >> 8
}
func (o *SYSCON_Type) SetPIO_FUNC_CFG2_PA19_FUNC(value uint32) {
	volatile.StoreUint32(&o.PIO_FUNC_CFG2.Reg, volatile.LoadUint32(&o.PIO_FUNC_CFG2.Reg)&^(0x7000)|value<<12)
}
func (o *SYSCON_Type) GetPIO_FUNC_CFG2_PA19_FUNC() uint32 {
	return (volatile.LoadUint32(&o.PIO_FUNC_CFG2.Reg) & 0x7000) >> 12
}
func (o *SYSCON_Type) SetPIO_FUNC_CFG2_PA20_FUNC(value uint32) {
	volatile.StoreUint32(&o.PIO_FUNC_CFG2.Reg, volatile.LoadUint32(&o.PIO_FUNC_CFG2.Reg)&^(0x70000)|value<<16)
}
func (o *SYSCON_Type) GetPIO_FUNC_CFG2_PA20_FUNC() uint32 {
	return (volatile.LoadUint32(&o.PIO_FUNC_CFG2.Reg) & 0x70000) >> 16
}
func (o *SYSCON_Type) SetPIO_FUNC_CFG2_PA21_FUNC(value uint32) {
	volatile.StoreUint32(&o.PIO_FUNC_CFG2.Reg, volatile.LoadUint32(&o.PIO_FUNC_CFG2.Reg)&^(0x700000)|value<<20)
}
func (o *SYSCON_Type) GetPIO_FUNC_CFG2_PA21_FUNC() uint32 {
	return (volatile.LoadUint32(&o.PIO_FUNC_CFG2.Reg) & 0x700000) >> 20
}
func (o *SYSCON_Type) SetPIO_FUNC_CFG2_PA22_FUNC(value uint32) {
	volatile.StoreUint32(&o.PIO_FUNC_CFG2.Reg, volatile.LoadUint32(&o.PIO_FUNC_CFG2.Reg)&^(0x7000000)|value<<24)
}
func (o *SYSCON_Type) GetPIO_FUNC_CFG2_PA22_FUNC() uint32 {
	return (volatile.LoadUint32(&o.PIO_FUNC_CFG2.Reg) & 0x7000000) >> 24
}
func (o *SYSCON_Type) SetPIO_FUNC_CFG2_PA23_FUNC(value uint32) {
	volatile.StoreUint32(&o.PIO_FUNC_CFG2.Reg, volatile.LoadUint32(&o.PIO_FUNC_CFG2.Reg)&^(0x70000000)|value<<28)
}
func (o *SYSCON_Type) GetPIO_FUNC_CFG2_PA23_FUNC() uint32 {
	return (volatile.LoadUint32(&o.PIO_FUNC_CFG2.Reg) & 0x70000000) >> 28
}

// SYSCON.PIO_FUNC_CFG3: pin mux control register 3
func (o *SYSCON_Type) SetPIO_FUNC_CFG3_PA24_FUNC(value uint32) {
	volatile.StoreUint32(&o.PIO_FUNC_CFG3.Reg, volatile.LoadUint32(&o.PIO_FUNC_CFG3.Reg)&^(0x7)|value)
}
func (o *SYSCON_Type) GetPIO_FUNC_CFG3_PA24_FUNC() uint32 {
	return volatile.LoadUint32(&o.PIO_FUNC_CFG3.Reg) & 0x7
}
func (o *SYSCON_Type) SetPIO_FUNC_CFG3_PA25_FUNC(value uint32) {
	volatile.StoreUint32(&o.PIO_FUNC_CFG3.Reg, volatile.LoadUint32(&o.PIO_FUNC_CFG3.Reg)&^(0x70)|value<<4)
}
func (o *SYSCON_Type) GetPIO_FUNC_CFG3_PA25_FUNC() uint32 {
	return (volatile.LoadUint32(&o.PIO_FUNC_CFG3.Reg) & 0x70) >> 4
}
func (o *SYSCON_Type) SetPIO_FUNC_CFG3_PA26_FUNC(value uint32) {
	volatile.StoreUint32(&o.PIO_FUNC_CFG3.Reg, volatile.LoadUint32(&o.PIO_FUNC_CFG3.Reg)&^(0x700)|value<<8)
}
func (o *SYSCON_Type) GetPIO_FUNC_CFG3_PA26_FUNC() uint32 {
	return (volatile.LoadUint32(&o.PIO_FUNC_CFG3.Reg) & 0x700) >> 8
}
func (o *SYSCON_Type) SetPIO_FUNC_CFG3_PA27_FUNC(value uint32) {
	volatile.StoreUint32(&o.PIO_FUNC_CFG3.Reg, volatile.LoadUint32(&o.PIO_FUNC_CFG3.Reg)&^(0x7000)|value<<12)
}
func (o *SYSCON_Type) GetPIO_FUNC_CFG3_PA27_FUNC() uint32 {
	return (volatile.LoadUint32(&o.PIO_FUNC_CFG3.Reg) & 0x7000) >> 12
}
func (o *SYSCON_Type) SetPIO_FUNC_CFG3_PA28_FUNC(value uint32) {
	volatile.StoreUint32(&o.PIO_FUNC_CFG3.Reg, volatile.LoadUint32(&o.PIO_FUNC_CFG3.Reg)&^(0x70000)|value<<16)
}
func (o *SYSCON_Type) GetPIO_FUNC_CFG3_PA28_FUNC() uint32 {
	return (volatile.LoadUint32(&o.PIO_FUNC_CFG3.Reg) & 0x70000) >> 16
}
func (o *SYSCON_Type) SetPIO_FUNC_CFG3_PA29_FUNC(value uint32) {
	volatile.StoreUint32(&o.PIO_FUNC_CFG3.Reg, volatile.LoadUint32(&o.PIO_FUNC_CFG3.Reg)&^(0x700000)|value<<20)
}
func (o *SYSCON_Type) GetPIO_FUNC_CFG3_PA29_FUNC() uint32 {
	return (volatile.LoadUint32(&o.PIO_FUNC_CFG3.Reg) & 0x700000) >> 20
}
func (o *SYSCON_Type) SetPIO_FUNC_CFG3_PA30_FUNC(value uint32) {
	volatile.StoreUint32(&o.PIO_FUNC_CFG3.Reg, volatile.LoadUint32(&o.PIO_FUNC_CFG3.Reg)&^(0x7000000)|value<<24)
}
func (o *SYSCON_Type) GetPIO_FUNC_CFG3_PA30_FUNC() uint32 {
	return (volatile.LoadUint32(&o.PIO_FUNC_CFG3.Reg) & 0x7000000) >> 24
}
func (o *SYSCON_Type) SetPIO_FUNC_CFG3_PA31_FUNC(value uint32) {
	volatile.StoreUint32(&o.PIO_FUNC_CFG3.Reg, volatile.LoadUint32(&o.PIO_FUNC_CFG3.Reg)&^(0x70000000)|value<<28)
}
func (o *SYSCON_Type) GetPIO_FUNC_CFG3_PA31_FUNC() uint32 {
	return (volatile.LoadUint32(&o.PIO_FUNC_CFG3.Reg) & 0x70000000) >> 28
}

// SYSCON.PIO_WAKEUP_EN0: pin function selection in power down mode register 0
func (o *SYSCON_Type) SetPIO_WAKEUP_EN0_PA00_WAKEUP_EN(value uint32) {
	volatile.StoreUint32(&o.PIO_WAKEUP_EN0.Reg, volatile.LoadUint32(&o.PIO_WAKEUP_EN0.Reg)&^(0x1)|value)
}
func (o *SYSCON_Type) GetPIO_WAKEUP_EN0_PA00_WAKEUP_EN() uint32 {
	return volatile.LoadUint32(&o.PIO_WAKEUP_EN0.Reg) & 0x1
}
func (o *SYSCON_Type) SetPIO_WAKEUP_EN0_PA01_WAKEUP_EN(value uint32) {
	volatile.StoreUint32(&o.PIO_WAKEUP_EN0.Reg, volatile.LoadUint32(&o.PIO_WAKEUP_EN0.Reg)&^(0x2)|value<<1)
}
func (o *SYSCON_Type) GetPIO_WAKEUP_EN0_PA01_WAKEUP_EN() uint32 {
	return (volatile.LoadUint32(&o.PIO_WAKEUP_EN0.Reg) & 0x2) >> 1
}
func (o *SYSCON_Type) SetPIO_WAKEUP_EN0_PA02_WAKEUP_EN(value uint32) {
	volatile.StoreUint32(&o.PIO_WAKEUP_EN0.Reg, volatile.LoadUint32(&o.PIO_WAKEUP_EN0.Reg)&^(0x4)|value<<2)
}
func (o *SYSCON_Type) GetPIO_WAKEUP_EN0_PA02_WAKEUP_EN() uint32 {
	return (volatile.LoadUint32(&o.PIO_WAKEUP_EN0.Reg) & 0x4) >> 2
}
func (o *SYSCON_Type) SetPIO_WAKEUP_EN0_PA03_WAKEUP_EN(value uint32) {
	volatile.StoreUint32(&o.PIO_WAKEUP_EN0.Reg, volatile.LoadUint32(&o.PIO_WAKEUP_EN0.Reg)&^(0x8)|value<<3)
}
func (o *SYSCON_Type) GetPIO_WAKEUP_EN0_PA03_WAKEUP_EN() uint32 {
	return (volatile.LoadUint32(&o.PIO_WAKEUP_EN0.Reg) & 0x8) >> 3
}
func (o *SYSCON_Type) SetPIO_WAKEUP_EN0_PA04_WAKEUP_EN(value uint32) {
	volatile.StoreUint32(&o.PIO_WAKEUP_EN0.Reg, volatile.LoadUint32(&o.PIO_WAKEUP_EN0.Reg)&^(0x10)|value<<4)
}
func (o *SYSCON_Type) GetPIO_WAKEUP_EN0_PA04_WAKEUP_EN() uint32 {
	return (volatile.LoadUint32(&o.PIO_WAKEUP_EN0.Reg) & 0x10) >> 4
}
func (o *SYSCON_Type) SetPIO_WAKEUP_EN0_PA05_WAKEUP_EN(value uint32) {
	volatile.StoreUint32(&o.PIO_WAKEUP_EN0.Reg, volatile.LoadUint32(&o.PIO_WAKEUP_EN0.Reg)&^(0x20)|value<<5)
}
func (o *SYSCON_Type) GetPIO_WAKEUP_EN0_PA05_WAKEUP_EN() uint32 {
	return (volatile.LoadUint32(&o.PIO_WAKEUP_EN0.Reg) & 0x20) >> 5
}
func (o *SYSCON_Type) SetPIO_WAKEUP_EN0_PA06_WAKEUP_EN(value uint32) {
	volatile.StoreUint32(&o.PIO_WAKEUP_EN0.Reg, volatile.LoadUint32(&o.PIO_WAKEUP_EN0.Reg)&^(0x40)|value<<6)
}
func (o *SYSCON_Type) GetPIO_WAKEUP_EN0_PA06_WAKEUP_EN() uint32 {
	return (volatile.LoadUint32(&o.PIO_WAKEUP_EN0.Reg) & 0x40) >> 6
}
func (o *SYSCON_Type) SetPIO_WAKEUP_EN0_PA07_WAKEUP_EN(value uint32) {
	volatile.StoreUint32(&o.PIO_WAKEUP_EN0.Reg, volatile.LoadUint32(&o.PIO_WAKEUP_EN0.Reg)&^(0x80)|value<<7)
}
func (o *SYSCON_Type) GetPIO_WAKEUP_EN0_PA07_WAKEUP_EN() uint32 {
	return (volatile.LoadUint32(&o.PIO_WAKEUP_EN0.Reg) & 0x80) >> 7
}
func (o *SYSCON_Type) SetPIO_WAKEUP_EN0_PA08_WAKEUP_EN(value uint32) {
	volatile.StoreUint32(&o.PIO_WAKEUP_EN0.Reg, volatile.LoadUint32(&o.PIO_WAKEUP_EN0.Reg)&^(0x100)|value<<8)
}
func (o *SYSCON_Type) GetPIO_WAKEUP_EN0_PA08_WAKEUP_EN() uint32 {
	return (volatile.LoadUint32(&o.PIO_WAKEUP_EN0.Reg) & 0x100) >> 8
}
func (o *SYSCON_Type) SetPIO_WAKEUP_EN0_PA09_WAKEUP_EN(value uint32) {
	volatile.StoreUint32(&o.PIO_WAKEUP_EN0.Reg, volatile.LoadUint32(&o.PIO_WAKEUP_EN0.Reg)&^(0x200)|value<<9)
}
func (o *SYSCON_Type) GetPIO_WAKEUP_EN0_PA09_WAKEUP_EN() uint32 {
	return (volatile.LoadUint32(&o.PIO_WAKEUP_EN0.Reg) & 0x200) >> 9
}
func (o *SYSCON_Type) SetPIO_WAKEUP_EN0_PA10_WAKEUP_EN(value uint32) {
	volatile.StoreUint32(&o.PIO_WAKEUP_EN0.Reg, volatile.LoadUint32(&o.PIO_WAKEUP_EN0.Reg)&^(0x400)|value<<10)
}
func (o *SYSCON_Type) GetPIO_WAKEUP_EN0_PA10_WAKEUP_EN() uint32 {
	return (volatile.LoadUint32(&o.PIO_WAKEUP_EN0.Reg) & 0x400) >> 10
}
func (o *SYSCON_Type) SetPIO_WAKEUP_EN0_PA11_WAKEUP_EN(value uint32) {
	volatile.StoreUint32(&o.PIO_WAKEUP_EN0.Reg, volatile.LoadUint32(&o.PIO_WAKEUP_EN0.Reg)&^(0x800)|value<<11)
}
func (o *SYSCON_Type) GetPIO_WAKEUP_EN0_PA11_WAKEUP_EN() uint32 {
	return (volatile.LoadUint32(&o.PIO_WAKEUP_EN0.Reg) & 0x800) >> 11
}
func (o *SYSCON_Type) SetPIO_WAKEUP_EN0_PA12_WAKEUP_EN(value uint32) {
	volatile.StoreUint32(&o.PIO_WAKEUP_EN0.Reg, volatile.LoadUint32(&o.PIO_WAKEUP_EN0.Reg)&^(0x1000)|value<<12)
}
func (o *SYSCON_Type) GetPIO_WAKEUP_EN0_PA12_WAKEUP_EN() uint32 {
	return (volatile.LoadUint32(&o.PIO_WAKEUP_EN0.Reg) & 0x1000) >> 12
}
func (o *SYSCON_Type) SetPIO_WAKEUP_EN0_PA13_WAKEUP_EN(value uint32) {
	volatile.StoreUint32(&o.PIO_WAKEUP_EN0.Reg, volatile.LoadUint32(&o.PIO_WAKEUP_EN0.Reg)&^(0x2000)|value<<13)
}
func (o *SYSCON_Type) GetPIO_WAKEUP_EN0_PA13_WAKEUP_EN() uint32 {
	return (volatile.LoadUint32(&o.PIO_WAKEUP_EN0.Reg) & 0x2000) >> 13
}
func (o *SYSCON_Type) SetPIO_WAKEUP_EN0_PA14_WAKEUP_EN(value uint32) {
	volatile.StoreUint32(&o.PIO_WAKEUP_EN0.Reg, volatile.LoadUint32(&o.PIO_WAKEUP_EN0.Reg)&^(0x4000)|value<<14)
}
func (o *SYSCON_Type) GetPIO_WAKEUP_EN0_PA14_WAKEUP_EN() uint32 {
	return (volatile.LoadUint32(&o.PIO_WAKEUP_EN0.Reg) & 0x4000) >> 14
}
func (o *SYSCON_Type) SetPIO_WAKEUP_EN0_PA15_WAKEUP_EN(value uint32) {
	volatile.StoreUint32(&o.PIO_WAKEUP_EN0.Reg, volatile.LoadUint32(&o.PIO_WAKEUP_EN0.Reg)&^(0x8000)|value<<15)
}
func (o *SYSCON_Type) GetPIO_WAKEUP_EN0_PA15_WAKEUP_EN() uint32 {
	return (volatile.LoadUint32(&o.PIO_WAKEUP_EN0.Reg) & 0x8000) >> 15
}
func (o *SYSCON_Type) SetPIO_WAKEUP_EN0_PA16_WAKEUP_EN(value uint32) {
	volatile.StoreUint32(&o.PIO_WAKEUP_EN0.Reg, volatile.LoadUint32(&o.PIO_WAKEUP_EN0.Reg)&^(0x10000)|value<<16)
}
func (o *SYSCON_Type) GetPIO_WAKEUP_EN0_PA16_WAKEUP_EN() uint32 {
	return (volatile.LoadUint32(&o.PIO_WAKEUP_EN0.Reg) & 0x10000) >> 16
}
func (o *SYSCON_Type) SetPIO_WAKEUP_EN0_PA17_WAKEUP_EN(value uint32) {
	volatile.StoreUint32(&o.PIO_WAKEUP_EN0.Reg, volatile.LoadUint32(&o.PIO_WAKEUP_EN0.Reg)&^(0x20000)|value<<17)
}
func (o *SYSCON_Type) GetPIO_WAKEUP_EN0_PA17_WAKEUP_EN() uint32 {
	return (volatile.LoadUint32(&o.PIO_WAKEUP_EN0.Reg) & 0x20000) >> 17
}
func (o *SYSCON_Type) SetPIO_WAKEUP_EN0_PA18_WAKEUP_EN(value uint32) {
	volatile.StoreUint32(&o.PIO_WAKEUP_EN0.Reg, volatile.LoadUint32(&o.PIO_WAKEUP_EN0.Reg)&^(0x40000)|value<<18)
}
func (o *SYSCON_Type) GetPIO_WAKEUP_EN0_PA18_WAKEUP_EN() uint32 {
	return (volatile.LoadUint32(&o.PIO_WAKEUP_EN0.Reg) & 0x40000) >> 18
}
func (o *SYSCON_Type) SetPIO_WAKEUP_EN0_PA19_WAKEUP_EN(value uint32) {
	volatile.StoreUint32(&o.PIO_WAKEUP_EN0.Reg, volatile.LoadUint32(&o.PIO_WAKEUP_EN0.Reg)&^(0x80000)|value<<19)
}
func (o *SYSCON_Type) GetPIO_WAKEUP_EN0_PA19_WAKEUP_EN() uint32 {
	return (volatile.LoadUint32(&o.PIO_WAKEUP_EN0.Reg) & 0x80000) >> 19
}
func (o *SYSCON_Type) SetPIO_WAKEUP_EN0_PA20_WAKEUP_EN(value uint32) {
	volatile.StoreUint32(&o.PIO_WAKEUP_EN0.Reg, volatile.LoadUint32(&o.PIO_WAKEUP_EN0.Reg)&^(0x100000)|value<<20)
}
func (o *SYSCON_Type) GetPIO_WAKEUP_EN0_PA20_WAKEUP_EN() uint32 {
	return (volatile.LoadUint32(&o.PIO_WAKEUP_EN0.Reg) & 0x100000) >> 20
}
func (o *SYSCON_Type) SetPIO_WAKEUP_EN0_PA21_WAKEUP_EN(value uint32) {
	volatile.StoreUint32(&o.PIO_WAKEUP_EN0.Reg, volatile.LoadUint32(&o.PIO_WAKEUP_EN0.Reg)&^(0x200000)|value<<21)
}
func (o *SYSCON_Type) GetPIO_WAKEUP_EN0_PA21_WAKEUP_EN() uint32 {
	return (volatile.LoadUint32(&o.PIO_WAKEUP_EN0.Reg) & 0x200000) >> 21
}
func (o *SYSCON_Type) SetPIO_WAKEUP_EN0_PA22_WAKEUP_EN(value uint32) {
	volatile.StoreUint32(&o.PIO_WAKEUP_EN0.Reg, volatile.LoadUint32(&o.PIO_WAKEUP_EN0.Reg)&^(0x400000)|value<<22)
}
func (o *SYSCON_Type) GetPIO_WAKEUP_EN0_PA22_WAKEUP_EN() uint32 {
	return (volatile.LoadUint32(&o.PIO_WAKEUP_EN0.Reg) & 0x400000) >> 22
}
func (o *SYSCON_Type) SetPIO_WAKEUP_EN0_PA23_WAKEUP_EN(value uint32) {
	volatile.StoreUint32(&o.PIO_WAKEUP_EN0.Reg, volatile.LoadUint32(&o.PIO_WAKEUP_EN0.Reg)&^(0x800000)|value<<23)
}
func (o *SYSCON_Type) GetPIO_WAKEUP_EN0_PA23_WAKEUP_EN() uint32 {
	return (volatile.LoadUint32(&o.PIO_WAKEUP_EN0.Reg) & 0x800000) >> 23
}
func (o *SYSCON_Type) SetPIO_WAKEUP_EN0_PA24_WAKEUP_EN(value uint32) {
	volatile.StoreUint32(&o.PIO_WAKEUP_EN0.Reg, volatile.LoadUint32(&o.PIO_WAKEUP_EN0.Reg)&^(0x1000000)|value<<24)
}
func (o *SYSCON_Type) GetPIO_WAKEUP_EN0_PA24_WAKEUP_EN() uint32 {
	return (volatile.LoadUint32(&o.PIO_WAKEUP_EN0.Reg) & 0x1000000) >> 24
}
func (o *SYSCON_Type) SetPIO_WAKEUP_EN0_PA25_WAKEUP_EN(value uint32) {
	volatile.StoreUint32(&o.PIO_WAKEUP_EN0.Reg, volatile.LoadUint32(&o.PIO_WAKEUP_EN0.Reg)&^(0x2000000)|value<<25)
}
func (o *SYSCON_Type) GetPIO_WAKEUP_EN0_PA25_WAKEUP_EN() uint32 {
	return (volatile.LoadUint32(&o.PIO_WAKEUP_EN0.Reg) & 0x2000000) >> 25
}
func (o *SYSCON_Type) SetPIO_WAKEUP_EN0_PA26_WAKEUP_EN(value uint32) {
	volatile.StoreUint32(&o.PIO_WAKEUP_EN0.Reg, volatile.LoadUint32(&o.PIO_WAKEUP_EN0.Reg)&^(0x4000000)|value<<26)
}
func (o *SYSCON_Type) GetPIO_WAKEUP_EN0_PA26_WAKEUP_EN() uint32 {
	return (volatile.LoadUint32(&o.PIO_WAKEUP_EN0.Reg) & 0x4000000) >> 26
}
func (o *SYSCON_Type) SetPIO_WAKEUP_EN0_PA27_WAKEUP_EN(value uint32) {
	volatile.StoreUint32(&o.PIO_WAKEUP_EN0.Reg, volatile.LoadUint32(&o.PIO_WAKEUP_EN0.Reg)&^(0x8000000)|value<<27)
}
func (o *SYSCON_Type) GetPIO_WAKEUP_EN0_PA27_WAKEUP_EN() uint32 {
	return (volatile.LoadUint32(&o.PIO_WAKEUP_EN0.Reg) & 0x8000000) >> 27
}
func (o *SYSCON_Type) SetPIO_WAKEUP_EN0_PA28_WAKEUP_EN(value uint32) {
	volatile.StoreUint32(&o.PIO_WAKEUP_EN0.Reg, volatile.LoadUint32(&o.PIO_WAKEUP_EN0.Reg)&^(0x10000000)|value<<28)
}
func (o *SYSCON_Type) GetPIO_WAKEUP_EN0_PA28_WAKEUP_EN() uint32 {
	return (volatile.LoadUint32(&o.PIO_WAKEUP_EN0.Reg) & 0x10000000) >> 28
}
func (o *SYSCON_Type) SetPIO_WAKEUP_EN0_PA29_WAKEUP_EN(value uint32) {
	volatile.StoreUint32(&o.PIO_WAKEUP_EN0.Reg, volatile.LoadUint32(&o.PIO_WAKEUP_EN0.Reg)&^(0x20000000)|value<<29)
}
func (o *SYSCON_Type) GetPIO_WAKEUP_EN0_PA29_WAKEUP_EN() uint32 {
	return (volatile.LoadUint32(&o.PIO_WAKEUP_EN0.Reg) & 0x20000000) >> 29
}
func (o *SYSCON_Type) SetPIO_WAKEUP_EN0_PA30_WAKEUP_EN(value uint32) {
	volatile.StoreUint32(&o.PIO_WAKEUP_EN0.Reg, volatile.LoadUint32(&o.PIO_WAKEUP_EN0.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSCON_Type) GetPIO_WAKEUP_EN0_PA30_WAKEUP_EN() uint32 {
	return (volatile.LoadUint32(&o.PIO_WAKEUP_EN0.Reg) & 0x40000000) >> 30
}
func (o *SYSCON_Type) SetPIO_WAKEUP_EN0_PA31_WAKEUP_EN(value uint32) {
	volatile.StoreUint32(&o.PIO_WAKEUP_EN0.Reg, volatile.LoadUint32(&o.PIO_WAKEUP_EN0.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSCON_Type) GetPIO_WAKEUP_EN0_PA31_WAKEUP_EN() uint32 {
	return (volatile.LoadUint32(&o.PIO_WAKEUP_EN0.Reg) & 0x80000000) >> 31
}

// SYSCON.PIO_WAKEUP_EN1: pin function selection in power down mode register 1
func (o *SYSCON_Type) SetPIO_WAKEUP_EN1_PB00_WAKEUP_EN(value uint32) {
	volatile.StoreUint32(&o.PIO_WAKEUP_EN1.Reg, volatile.LoadUint32(&o.PIO_WAKEUP_EN1.Reg)&^(0x1)|value)
}
func (o *SYSCON_Type) GetPIO_WAKEUP_EN1_PB00_WAKEUP_EN() uint32 {
	return volatile.LoadUint32(&o.PIO_WAKEUP_EN1.Reg) & 0x1
}
func (o *SYSCON_Type) SetPIO_WAKEUP_EN1_PB01_WAKEUP_EN(value uint32) {
	volatile.StoreUint32(&o.PIO_WAKEUP_EN1.Reg, volatile.LoadUint32(&o.PIO_WAKEUP_EN1.Reg)&^(0x2)|value<<1)
}
func (o *SYSCON_Type) GetPIO_WAKEUP_EN1_PB01_WAKEUP_EN() uint32 {
	return (volatile.LoadUint32(&o.PIO_WAKEUP_EN1.Reg) & 0x2) >> 1
}
func (o *SYSCON_Type) SetPIO_WAKEUP_EN1_PB02_WAKEUP_EN(value uint32) {
	volatile.StoreUint32(&o.PIO_WAKEUP_EN1.Reg, volatile.LoadUint32(&o.PIO_WAKEUP_EN1.Reg)&^(0x4)|value<<2)
}
func (o *SYSCON_Type) GetPIO_WAKEUP_EN1_PB02_WAKEUP_EN() uint32 {
	return (volatile.LoadUint32(&o.PIO_WAKEUP_EN1.Reg) & 0x4) >> 2
}
func (o *SYSCON_Type) SetPIO_WAKEUP_EN1_PA04_32K_OE(value uint32) {
	volatile.StoreUint32(&o.PIO_WAKEUP_EN1.Reg, volatile.LoadUint32(&o.PIO_WAKEUP_EN1.Reg)&^(0x10)|value<<4)
}
func (o *SYSCON_Type) GetPIO_WAKEUP_EN1_PA04_32K_OE() uint32 {
	return (volatile.LoadUint32(&o.PIO_WAKEUP_EN1.Reg) & 0x10) >> 4
}
func (o *SYSCON_Type) SetPIO_WAKEUP_EN1_PA05_XTAL_OE(value uint32) {
	volatile.StoreUint32(&o.PIO_WAKEUP_EN1.Reg, volatile.LoadUint32(&o.PIO_WAKEUP_EN1.Reg)&^(0x20)|value<<5)
}
func (o *SYSCON_Type) GetPIO_WAKEUP_EN1_PA05_XTAL_OE() uint32 {
	return (volatile.LoadUint32(&o.PIO_WAKEUP_EN1.Reg) & 0x20) >> 5
}
func (o *SYSCON_Type) SetPIO_WAKEUP_EN1_PA10_32K_OE(value uint32) {
	volatile.StoreUint32(&o.PIO_WAKEUP_EN1.Reg, volatile.LoadUint32(&o.PIO_WAKEUP_EN1.Reg)&^(0x400)|value<<10)
}
func (o *SYSCON_Type) GetPIO_WAKEUP_EN1_PA10_32K_OE() uint32 {
	return (volatile.LoadUint32(&o.PIO_WAKEUP_EN1.Reg) & 0x400) >> 10
}
func (o *SYSCON_Type) SetPIO_WAKEUP_EN1_PA11_XTAL_OE(value uint32) {
	volatile.StoreUint32(&o.PIO_WAKEUP_EN1.Reg, volatile.LoadUint32(&o.PIO_WAKEUP_EN1.Reg)&^(0x800)|value<<11)
}
func (o *SYSCON_Type) GetPIO_WAKEUP_EN1_PA11_XTAL_OE() uint32 {
	return (volatile.LoadUint32(&o.PIO_WAKEUP_EN1.Reg) & 0x800) >> 11
}
func (o *SYSCON_Type) SetPIO_WAKEUP_EN1_PA18_32K_OE(value uint32) {
	volatile.StoreUint32(&o.PIO_WAKEUP_EN1.Reg, volatile.LoadUint32(&o.PIO_WAKEUP_EN1.Reg)&^(0x40000)|value<<18)
}
func (o *SYSCON_Type) GetPIO_WAKEUP_EN1_PA18_32K_OE() uint32 {
	return (volatile.LoadUint32(&o.PIO_WAKEUP_EN1.Reg) & 0x40000) >> 18
}
func (o *SYSCON_Type) SetPIO_WAKEUP_EN1_PA19_XTAL_OE(value uint32) {
	volatile.StoreUint32(&o.PIO_WAKEUP_EN1.Reg, volatile.LoadUint32(&o.PIO_WAKEUP_EN1.Reg)&^(0x80000)|value<<19)
}
func (o *SYSCON_Type) GetPIO_WAKEUP_EN1_PA19_XTAL_OE() uint32 {
	return (volatile.LoadUint32(&o.PIO_WAKEUP_EN1.Reg) & 0x80000) >> 19
}
func (o *SYSCON_Type) SetPIO_WAKEUP_EN1_PA24_32K_OE(value uint32) {
	volatile.StoreUint32(&o.PIO_WAKEUP_EN1.Reg, volatile.LoadUint32(&o.PIO_WAKEUP_EN1.Reg)&^(0x1000000)|value<<24)
}
func (o *SYSCON_Type) GetPIO_WAKEUP_EN1_PA24_32K_OE() uint32 {
	return (volatile.LoadUint32(&o.PIO_WAKEUP_EN1.Reg) & 0x1000000) >> 24
}
func (o *SYSCON_Type) SetPIO_WAKEUP_EN1_PA25_XTAL_OE(value uint32) {
	volatile.StoreUint32(&o.PIO_WAKEUP_EN1.Reg, volatile.LoadUint32(&o.PIO_WAKEUP_EN1.Reg)&^(0x2000000)|value<<25)
}
func (o *SYSCON_Type) GetPIO_WAKEUP_EN1_PA25_XTAL_OE() uint32 {
	return (volatile.LoadUint32(&o.PIO_WAKEUP_EN1.Reg) & 0x2000000) >> 25
}
func (o *SYSCON_Type) SetPIO_WAKEUP_EN1_PDM_IO_SEL(value uint32) {
	volatile.StoreUint32(&o.PIO_WAKEUP_EN1.Reg, volatile.LoadUint32(&o.PIO_WAKEUP_EN1.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSCON_Type) GetPIO_WAKEUP_EN1_PDM_IO_SEL() uint32 {
	return (volatile.LoadUint32(&o.PIO_WAKEUP_EN1.Reg) & 0x80000000) >> 31
}

// SYSCON.PIO_CAP_OE0: pin output enable status register 0 while captured by writing 1 to IO_CAP
func (o *SYSCON_Type) SetPIO_CAP_OE0_PA00_CAP_OE(value uint32) {
	volatile.StoreUint32(&o.PIO_CAP_OE0.Reg, volatile.LoadUint32(&o.PIO_CAP_OE0.Reg)&^(0x1)|value)
}
func (o *SYSCON_Type) GetPIO_CAP_OE0_PA00_CAP_OE() uint32 {
	return volatile.LoadUint32(&o.PIO_CAP_OE0.Reg) & 0x1
}
func (o *SYSCON_Type) SetPIO_CAP_OE0_PA01_CAP_OE(value uint32) {
	volatile.StoreUint32(&o.PIO_CAP_OE0.Reg, volatile.LoadUint32(&o.PIO_CAP_OE0.Reg)&^(0x2)|value<<1)
}
func (o *SYSCON_Type) GetPIO_CAP_OE0_PA01_CAP_OE() uint32 {
	return (volatile.LoadUint32(&o.PIO_CAP_OE0.Reg) & 0x2) >> 1
}
func (o *SYSCON_Type) SetPIO_CAP_OE0_PA02_CAP_OE(value uint32) {
	volatile.StoreUint32(&o.PIO_CAP_OE0.Reg, volatile.LoadUint32(&o.PIO_CAP_OE0.Reg)&^(0x4)|value<<2)
}
func (o *SYSCON_Type) GetPIO_CAP_OE0_PA02_CAP_OE() uint32 {
	return (volatile.LoadUint32(&o.PIO_CAP_OE0.Reg) & 0x4) >> 2
}
func (o *SYSCON_Type) SetPIO_CAP_OE0_PA03_CAP_OE(value uint32) {
	volatile.StoreUint32(&o.PIO_CAP_OE0.Reg, volatile.LoadUint32(&o.PIO_CAP_OE0.Reg)&^(0x8)|value<<3)
}
func (o *SYSCON_Type) GetPIO_CAP_OE0_PA03_CAP_OE() uint32 {
	return (volatile.LoadUint32(&o.PIO_CAP_OE0.Reg) & 0x8) >> 3
}
func (o *SYSCON_Type) SetPIO_CAP_OE0_PA04_CAP_OE(value uint32) {
	volatile.StoreUint32(&o.PIO_CAP_OE0.Reg, volatile.LoadUint32(&o.PIO_CAP_OE0.Reg)&^(0x10)|value<<4)
}
func (o *SYSCON_Type) GetPIO_CAP_OE0_PA04_CAP_OE() uint32 {
	return (volatile.LoadUint32(&o.PIO_CAP_OE0.Reg) & 0x10) >> 4
}
func (o *SYSCON_Type) SetPIO_CAP_OE0_PA05_CAP_OE(value uint32) {
	volatile.StoreUint32(&o.PIO_CAP_OE0.Reg, volatile.LoadUint32(&o.PIO_CAP_OE0.Reg)&^(0x20)|value<<5)
}
func (o *SYSCON_Type) GetPIO_CAP_OE0_PA05_CAP_OE() uint32 {
	return (volatile.LoadUint32(&o.PIO_CAP_OE0.Reg) & 0x20) >> 5
}
func (o *SYSCON_Type) SetPIO_CAP_OE0_PA06_CAP_OE(value uint32) {
	volatile.StoreUint32(&o.PIO_CAP_OE0.Reg, volatile.LoadUint32(&o.PIO_CAP_OE0.Reg)&^(0x40)|value<<6)
}
func (o *SYSCON_Type) GetPIO_CAP_OE0_PA06_CAP_OE() uint32 {
	return (volatile.LoadUint32(&o.PIO_CAP_OE0.Reg) & 0x40) >> 6
}
func (o *SYSCON_Type) SetPIO_CAP_OE0_PA07_CAP_OE(value uint32) {
	volatile.StoreUint32(&o.PIO_CAP_OE0.Reg, volatile.LoadUint32(&o.PIO_CAP_OE0.Reg)&^(0x80)|value<<7)
}
func (o *SYSCON_Type) GetPIO_CAP_OE0_PA07_CAP_OE() uint32 {
	return (volatile.LoadUint32(&o.PIO_CAP_OE0.Reg) & 0x80) >> 7
}
func (o *SYSCON_Type) SetPIO_CAP_OE0_PA08_CAP_OE(value uint32) {
	volatile.StoreUint32(&o.PIO_CAP_OE0.Reg, volatile.LoadUint32(&o.PIO_CAP_OE0.Reg)&^(0x100)|value<<8)
}
func (o *SYSCON_Type) GetPIO_CAP_OE0_PA08_CAP_OE() uint32 {
	return (volatile.LoadUint32(&o.PIO_CAP_OE0.Reg) & 0x100) >> 8
}
func (o *SYSCON_Type) SetPIO_CAP_OE0_PA09_CAP_OE(value uint32) {
	volatile.StoreUint32(&o.PIO_CAP_OE0.Reg, volatile.LoadUint32(&o.PIO_CAP_OE0.Reg)&^(0x200)|value<<9)
}
func (o *SYSCON_Type) GetPIO_CAP_OE0_PA09_CAP_OE() uint32 {
	return (volatile.LoadUint32(&o.PIO_CAP_OE0.Reg) & 0x200) >> 9
}
func (o *SYSCON_Type) SetPIO_CAP_OE0_PA10_CAP_OE(value uint32) {
	volatile.StoreUint32(&o.PIO_CAP_OE0.Reg, volatile.LoadUint32(&o.PIO_CAP_OE0.Reg)&^(0x400)|value<<10)
}
func (o *SYSCON_Type) GetPIO_CAP_OE0_PA10_CAP_OE() uint32 {
	return (volatile.LoadUint32(&o.PIO_CAP_OE0.Reg) & 0x400) >> 10
}
func (o *SYSCON_Type) SetPIO_CAP_OE0_PA11_CAP_OE(value uint32) {
	volatile.StoreUint32(&o.PIO_CAP_OE0.Reg, volatile.LoadUint32(&o.PIO_CAP_OE0.Reg)&^(0x800)|value<<11)
}
func (o *SYSCON_Type) GetPIO_CAP_OE0_PA11_CAP_OE() uint32 {
	return (volatile.LoadUint32(&o.PIO_CAP_OE0.Reg) & 0x800) >> 11
}
func (o *SYSCON_Type) SetPIO_CAP_OE0_PA12_CAP_OE(value uint32) {
	volatile.StoreUint32(&o.PIO_CAP_OE0.Reg, volatile.LoadUint32(&o.PIO_CAP_OE0.Reg)&^(0x1000)|value<<12)
}
func (o *SYSCON_Type) GetPIO_CAP_OE0_PA12_CAP_OE() uint32 {
	return (volatile.LoadUint32(&o.PIO_CAP_OE0.Reg) & 0x1000) >> 12
}
func (o *SYSCON_Type) SetPIO_CAP_OE0_PA13_CAP_OE(value uint32) {
	volatile.StoreUint32(&o.PIO_CAP_OE0.Reg, volatile.LoadUint32(&o.PIO_CAP_OE0.Reg)&^(0x2000)|value<<13)
}
func (o *SYSCON_Type) GetPIO_CAP_OE0_PA13_CAP_OE() uint32 {
	return (volatile.LoadUint32(&o.PIO_CAP_OE0.Reg) & 0x2000) >> 13
}
func (o *SYSCON_Type) SetPIO_CAP_OE0_PA14_CAP_OE(value uint32) {
	volatile.StoreUint32(&o.PIO_CAP_OE0.Reg, volatile.LoadUint32(&o.PIO_CAP_OE0.Reg)&^(0x4000)|value<<14)
}
func (o *SYSCON_Type) GetPIO_CAP_OE0_PA14_CAP_OE() uint32 {
	return (volatile.LoadUint32(&o.PIO_CAP_OE0.Reg) & 0x4000) >> 14
}
func (o *SYSCON_Type) SetPIO_CAP_OE0_PA15_CAP_OE(value uint32) {
	volatile.StoreUint32(&o.PIO_CAP_OE0.Reg, volatile.LoadUint32(&o.PIO_CAP_OE0.Reg)&^(0x8000)|value<<15)
}
func (o *SYSCON_Type) GetPIO_CAP_OE0_PA15_CAP_OE() uint32 {
	return (volatile.LoadUint32(&o.PIO_CAP_OE0.Reg) & 0x8000) >> 15
}
func (o *SYSCON_Type) SetPIO_CAP_OE0_PA16_CAP_OE(value uint32) {
	volatile.StoreUint32(&o.PIO_CAP_OE0.Reg, volatile.LoadUint32(&o.PIO_CAP_OE0.Reg)&^(0x10000)|value<<16)
}
func (o *SYSCON_Type) GetPIO_CAP_OE0_PA16_CAP_OE() uint32 {
	return (volatile.LoadUint32(&o.PIO_CAP_OE0.Reg) & 0x10000) >> 16
}
func (o *SYSCON_Type) SetPIO_CAP_OE0_PA17_CAP_OE(value uint32) {
	volatile.StoreUint32(&o.PIO_CAP_OE0.Reg, volatile.LoadUint32(&o.PIO_CAP_OE0.Reg)&^(0x20000)|value<<17)
}
func (o *SYSCON_Type) GetPIO_CAP_OE0_PA17_CAP_OE() uint32 {
	return (volatile.LoadUint32(&o.PIO_CAP_OE0.Reg) & 0x20000) >> 17
}
func (o *SYSCON_Type) SetPIO_CAP_OE0_PA18_CAP_OE(value uint32) {
	volatile.StoreUint32(&o.PIO_CAP_OE0.Reg, volatile.LoadUint32(&o.PIO_CAP_OE0.Reg)&^(0x40000)|value<<18)
}
func (o *SYSCON_Type) GetPIO_CAP_OE0_PA18_CAP_OE() uint32 {
	return (volatile.LoadUint32(&o.PIO_CAP_OE0.Reg) & 0x40000) >> 18
}
func (o *SYSCON_Type) SetPIO_CAP_OE0_PA19_CAP_OE(value uint32) {
	volatile.StoreUint32(&o.PIO_CAP_OE0.Reg, volatile.LoadUint32(&o.PIO_CAP_OE0.Reg)&^(0x80000)|value<<19)
}
func (o *SYSCON_Type) GetPIO_CAP_OE0_PA19_CAP_OE() uint32 {
	return (volatile.LoadUint32(&o.PIO_CAP_OE0.Reg) & 0x80000) >> 19
}
func (o *SYSCON_Type) SetPIO_CAP_OE0_PA20_CAP_OE(value uint32) {
	volatile.StoreUint32(&o.PIO_CAP_OE0.Reg, volatile.LoadUint32(&o.PIO_CAP_OE0.Reg)&^(0x100000)|value<<20)
}
func (o *SYSCON_Type) GetPIO_CAP_OE0_PA20_CAP_OE() uint32 {
	return (volatile.LoadUint32(&o.PIO_CAP_OE0.Reg) & 0x100000) >> 20
}
func (o *SYSCON_Type) SetPIO_CAP_OE0_PA21_CAP_OE(value uint32) {
	volatile.StoreUint32(&o.PIO_CAP_OE0.Reg, volatile.LoadUint32(&o.PIO_CAP_OE0.Reg)&^(0x200000)|value<<21)
}
func (o *SYSCON_Type) GetPIO_CAP_OE0_PA21_CAP_OE() uint32 {
	return (volatile.LoadUint32(&o.PIO_CAP_OE0.Reg) & 0x200000) >> 21
}
func (o *SYSCON_Type) SetPIO_CAP_OE0_PA22_CAP_OE(value uint32) {
	volatile.StoreUint32(&o.PIO_CAP_OE0.Reg, volatile.LoadUint32(&o.PIO_CAP_OE0.Reg)&^(0x400000)|value<<22)
}
func (o *SYSCON_Type) GetPIO_CAP_OE0_PA22_CAP_OE() uint32 {
	return (volatile.LoadUint32(&o.PIO_CAP_OE0.Reg) & 0x400000) >> 22
}
func (o *SYSCON_Type) SetPIO_CAP_OE0_PA23_CAP_OE(value uint32) {
	volatile.StoreUint32(&o.PIO_CAP_OE0.Reg, volatile.LoadUint32(&o.PIO_CAP_OE0.Reg)&^(0x800000)|value<<23)
}
func (o *SYSCON_Type) GetPIO_CAP_OE0_PA23_CAP_OE() uint32 {
	return (volatile.LoadUint32(&o.PIO_CAP_OE0.Reg) & 0x800000) >> 23
}
func (o *SYSCON_Type) SetPIO_CAP_OE0_PA24_CAP_OE(value uint32) {
	volatile.StoreUint32(&o.PIO_CAP_OE0.Reg, volatile.LoadUint32(&o.PIO_CAP_OE0.Reg)&^(0x1000000)|value<<24)
}
func (o *SYSCON_Type) GetPIO_CAP_OE0_PA24_CAP_OE() uint32 {
	return (volatile.LoadUint32(&o.PIO_CAP_OE0.Reg) & 0x1000000) >> 24
}
func (o *SYSCON_Type) SetPIO_CAP_OE0_PA25_CAP_OE(value uint32) {
	volatile.StoreUint32(&o.PIO_CAP_OE0.Reg, volatile.LoadUint32(&o.PIO_CAP_OE0.Reg)&^(0x2000000)|value<<25)
}
func (o *SYSCON_Type) GetPIO_CAP_OE0_PA25_CAP_OE() uint32 {
	return (volatile.LoadUint32(&o.PIO_CAP_OE0.Reg) & 0x2000000) >> 25
}
func (o *SYSCON_Type) SetPIO_CAP_OE0_PA26_CAP_OE(value uint32) {
	volatile.StoreUint32(&o.PIO_CAP_OE0.Reg, volatile.LoadUint32(&o.PIO_CAP_OE0.Reg)&^(0x4000000)|value<<26)
}
func (o *SYSCON_Type) GetPIO_CAP_OE0_PA26_CAP_OE() uint32 {
	return (volatile.LoadUint32(&o.PIO_CAP_OE0.Reg) & 0x4000000) >> 26
}
func (o *SYSCON_Type) SetPIO_CAP_OE0_PA27_CAP_OE(value uint32) {
	volatile.StoreUint32(&o.PIO_CAP_OE0.Reg, volatile.LoadUint32(&o.PIO_CAP_OE0.Reg)&^(0x8000000)|value<<27)
}
func (o *SYSCON_Type) GetPIO_CAP_OE0_PA27_CAP_OE() uint32 {
	return (volatile.LoadUint32(&o.PIO_CAP_OE0.Reg) & 0x8000000) >> 27
}
func (o *SYSCON_Type) SetPIO_CAP_OE0_PA28_CAP_OE(value uint32) {
	volatile.StoreUint32(&o.PIO_CAP_OE0.Reg, volatile.LoadUint32(&o.PIO_CAP_OE0.Reg)&^(0x10000000)|value<<28)
}
func (o *SYSCON_Type) GetPIO_CAP_OE0_PA28_CAP_OE() uint32 {
	return (volatile.LoadUint32(&o.PIO_CAP_OE0.Reg) & 0x10000000) >> 28
}
func (o *SYSCON_Type) SetPIO_CAP_OE0_PA29_CAP_OE(value uint32) {
	volatile.StoreUint32(&o.PIO_CAP_OE0.Reg, volatile.LoadUint32(&o.PIO_CAP_OE0.Reg)&^(0x20000000)|value<<29)
}
func (o *SYSCON_Type) GetPIO_CAP_OE0_PA29_CAP_OE() uint32 {
	return (volatile.LoadUint32(&o.PIO_CAP_OE0.Reg) & 0x20000000) >> 29
}
func (o *SYSCON_Type) SetPIO_CAP_OE0_PA30_CAP_OE(value uint32) {
	volatile.StoreUint32(&o.PIO_CAP_OE0.Reg, volatile.LoadUint32(&o.PIO_CAP_OE0.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSCON_Type) GetPIO_CAP_OE0_PA30_CAP_OE() uint32 {
	return (volatile.LoadUint32(&o.PIO_CAP_OE0.Reg) & 0x40000000) >> 30
}
func (o *SYSCON_Type) SetPIO_CAP_OE0_PA31_CAP_OE(value uint32) {
	volatile.StoreUint32(&o.PIO_CAP_OE0.Reg, volatile.LoadUint32(&o.PIO_CAP_OE0.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSCON_Type) GetPIO_CAP_OE0_PA31_CAP_OE() uint32 {
	return (volatile.LoadUint32(&o.PIO_CAP_OE0.Reg) & 0x80000000) >> 31
}

// SYSCON.PIO_CAP_OE1: pin output enable status register 1 while captured by writing 1 to IO_CAP
func (o *SYSCON_Type) SetPIO_CAP_OE1_PB00_CAP_OE(value uint32) {
	volatile.StoreUint32(&o.PIO_CAP_OE1.Reg, volatile.LoadUint32(&o.PIO_CAP_OE1.Reg)&^(0x1)|value)
}
func (o *SYSCON_Type) GetPIO_CAP_OE1_PB00_CAP_OE() uint32 {
	return volatile.LoadUint32(&o.PIO_CAP_OE1.Reg) & 0x1
}
func (o *SYSCON_Type) SetPIO_CAP_OE1_PB01_CAP_OE(value uint32) {
	volatile.StoreUint32(&o.PIO_CAP_OE1.Reg, volatile.LoadUint32(&o.PIO_CAP_OE1.Reg)&^(0x2)|value<<1)
}
func (o *SYSCON_Type) GetPIO_CAP_OE1_PB01_CAP_OE() uint32 {
	return (volatile.LoadUint32(&o.PIO_CAP_OE1.Reg) & 0x2) >> 1
}
func (o *SYSCON_Type) SetPIO_CAP_OE1_PB02_CAP_OE(value uint32) {
	volatile.StoreUint32(&o.PIO_CAP_OE1.Reg, volatile.LoadUint32(&o.PIO_CAP_OE1.Reg)&^(0x4)|value<<2)
}
func (o *SYSCON_Type) GetPIO_CAP_OE1_PB02_CAP_OE() uint32 {
	return (volatile.LoadUint32(&o.PIO_CAP_OE1.Reg) & 0x4) >> 2
}

// SYSCON.PIO_CAP_OUT0: pin output status register 0 while captured by writing 1 to IO_CAP
func (o *SYSCON_Type) SetPIO_CAP_OUT0_PA00_CAP_OUT(value uint32) {
	volatile.StoreUint32(&o.PIO_CAP_OUT0.Reg, volatile.LoadUint32(&o.PIO_CAP_OUT0.Reg)&^(0x1)|value)
}
func (o *SYSCON_Type) GetPIO_CAP_OUT0_PA00_CAP_OUT() uint32 {
	return volatile.LoadUint32(&o.PIO_CAP_OUT0.Reg) & 0x1
}
func (o *SYSCON_Type) SetPIO_CAP_OUT0_PA01_CAP_OUT(value uint32) {
	volatile.StoreUint32(&o.PIO_CAP_OUT0.Reg, volatile.LoadUint32(&o.PIO_CAP_OUT0.Reg)&^(0x2)|value<<1)
}
func (o *SYSCON_Type) GetPIO_CAP_OUT0_PA01_CAP_OUT() uint32 {
	return (volatile.LoadUint32(&o.PIO_CAP_OUT0.Reg) & 0x2) >> 1
}
func (o *SYSCON_Type) SetPIO_CAP_OUT0_PA02_CAP_OUT(value uint32) {
	volatile.StoreUint32(&o.PIO_CAP_OUT0.Reg, volatile.LoadUint32(&o.PIO_CAP_OUT0.Reg)&^(0x4)|value<<2)
}
func (o *SYSCON_Type) GetPIO_CAP_OUT0_PA02_CAP_OUT() uint32 {
	return (volatile.LoadUint32(&o.PIO_CAP_OUT0.Reg) & 0x4) >> 2
}
func (o *SYSCON_Type) SetPIO_CAP_OUT0_PA03_CAP_OUT(value uint32) {
	volatile.StoreUint32(&o.PIO_CAP_OUT0.Reg, volatile.LoadUint32(&o.PIO_CAP_OUT0.Reg)&^(0x8)|value<<3)
}
func (o *SYSCON_Type) GetPIO_CAP_OUT0_PA03_CAP_OUT() uint32 {
	return (volatile.LoadUint32(&o.PIO_CAP_OUT0.Reg) & 0x8) >> 3
}
func (o *SYSCON_Type) SetPIO_CAP_OUT0_PA04_CAP_OUT(value uint32) {
	volatile.StoreUint32(&o.PIO_CAP_OUT0.Reg, volatile.LoadUint32(&o.PIO_CAP_OUT0.Reg)&^(0x10)|value<<4)
}
func (o *SYSCON_Type) GetPIO_CAP_OUT0_PA04_CAP_OUT() uint32 {
	return (volatile.LoadUint32(&o.PIO_CAP_OUT0.Reg) & 0x10) >> 4
}
func (o *SYSCON_Type) SetPIO_CAP_OUT0_PA05_CAP_OUT(value uint32) {
	volatile.StoreUint32(&o.PIO_CAP_OUT0.Reg, volatile.LoadUint32(&o.PIO_CAP_OUT0.Reg)&^(0x20)|value<<5)
}
func (o *SYSCON_Type) GetPIO_CAP_OUT0_PA05_CAP_OUT() uint32 {
	return (volatile.LoadUint32(&o.PIO_CAP_OUT0.Reg) & 0x20) >> 5
}
func (o *SYSCON_Type) SetPIO_CAP_OUT0_PA06_CAP_OUT(value uint32) {
	volatile.StoreUint32(&o.PIO_CAP_OUT0.Reg, volatile.LoadUint32(&o.PIO_CAP_OUT0.Reg)&^(0x40)|value<<6)
}
func (o *SYSCON_Type) GetPIO_CAP_OUT0_PA06_CAP_OUT() uint32 {
	return (volatile.LoadUint32(&o.PIO_CAP_OUT0.Reg) & 0x40) >> 6
}
func (o *SYSCON_Type) SetPIO_CAP_OUT0_PA07_CAP_OUT(value uint32) {
	volatile.StoreUint32(&o.PIO_CAP_OUT0.Reg, volatile.LoadUint32(&o.PIO_CAP_OUT0.Reg)&^(0x80)|value<<7)
}
func (o *SYSCON_Type) GetPIO_CAP_OUT0_PA07_CAP_OUT() uint32 {
	return (volatile.LoadUint32(&o.PIO_CAP_OUT0.Reg) & 0x80) >> 7
}
func (o *SYSCON_Type) SetPIO_CAP_OUT0_PA08_CAP_OUT(value uint32) {
	volatile.StoreUint32(&o.PIO_CAP_OUT0.Reg, volatile.LoadUint32(&o.PIO_CAP_OUT0.Reg)&^(0x100)|value<<8)
}
func (o *SYSCON_Type) GetPIO_CAP_OUT0_PA08_CAP_OUT() uint32 {
	return (volatile.LoadUint32(&o.PIO_CAP_OUT0.Reg) & 0x100) >> 8
}
func (o *SYSCON_Type) SetPIO_CAP_OUT0_PA09_CAP_OUT(value uint32) {
	volatile.StoreUint32(&o.PIO_CAP_OUT0.Reg, volatile.LoadUint32(&o.PIO_CAP_OUT0.Reg)&^(0x200)|value<<9)
}
func (o *SYSCON_Type) GetPIO_CAP_OUT0_PA09_CAP_OUT() uint32 {
	return (volatile.LoadUint32(&o.PIO_CAP_OUT0.Reg) & 0x200) >> 9
}
func (o *SYSCON_Type) SetPIO_CAP_OUT0_PA10_CAP_OUT(value uint32) {
	volatile.StoreUint32(&o.PIO_CAP_OUT0.Reg, volatile.LoadUint32(&o.PIO_CAP_OUT0.Reg)&^(0x400)|value<<10)
}
func (o *SYSCON_Type) GetPIO_CAP_OUT0_PA10_CAP_OUT() uint32 {
	return (volatile.LoadUint32(&o.PIO_CAP_OUT0.Reg) & 0x400) >> 10
}
func (o *SYSCON_Type) SetPIO_CAP_OUT0_PA11_CAP_OUT(value uint32) {
	volatile.StoreUint32(&o.PIO_CAP_OUT0.Reg, volatile.LoadUint32(&o.PIO_CAP_OUT0.Reg)&^(0x800)|value<<11)
}
func (o *SYSCON_Type) GetPIO_CAP_OUT0_PA11_CAP_OUT() uint32 {
	return (volatile.LoadUint32(&o.PIO_CAP_OUT0.Reg) & 0x800) >> 11
}
func (o *SYSCON_Type) SetPIO_CAP_OUT0_PA12_CAP_OUT(value uint32) {
	volatile.StoreUint32(&o.PIO_CAP_OUT0.Reg, volatile.LoadUint32(&o.PIO_CAP_OUT0.Reg)&^(0x1000)|value<<12)
}
func (o *SYSCON_Type) GetPIO_CAP_OUT0_PA12_CAP_OUT() uint32 {
	return (volatile.LoadUint32(&o.PIO_CAP_OUT0.Reg) & 0x1000) >> 12
}
func (o *SYSCON_Type) SetPIO_CAP_OUT0_PA13_CAP_OUT(value uint32) {
	volatile.StoreUint32(&o.PIO_CAP_OUT0.Reg, volatile.LoadUint32(&o.PIO_CAP_OUT0.Reg)&^(0x2000)|value<<13)
}
func (o *SYSCON_Type) GetPIO_CAP_OUT0_PA13_CAP_OUT() uint32 {
	return (volatile.LoadUint32(&o.PIO_CAP_OUT0.Reg) & 0x2000) >> 13
}
func (o *SYSCON_Type) SetPIO_CAP_OUT0_PA14_CAP_OUT(value uint32) {
	volatile.StoreUint32(&o.PIO_CAP_OUT0.Reg, volatile.LoadUint32(&o.PIO_CAP_OUT0.Reg)&^(0x4000)|value<<14)
}
func (o *SYSCON_Type) GetPIO_CAP_OUT0_PA14_CAP_OUT() uint32 {
	return (volatile.LoadUint32(&o.PIO_CAP_OUT0.Reg) & 0x4000) >> 14
}
func (o *SYSCON_Type) SetPIO_CAP_OUT0_PA15_CAP_OUT(value uint32) {
	volatile.StoreUint32(&o.PIO_CAP_OUT0.Reg, volatile.LoadUint32(&o.PIO_CAP_OUT0.Reg)&^(0x8000)|value<<15)
}
func (o *SYSCON_Type) GetPIO_CAP_OUT0_PA15_CAP_OUT() uint32 {
	return (volatile.LoadUint32(&o.PIO_CAP_OUT0.Reg) & 0x8000) >> 15
}
func (o *SYSCON_Type) SetPIO_CAP_OUT0_PA16_CAP_OUT(value uint32) {
	volatile.StoreUint32(&o.PIO_CAP_OUT0.Reg, volatile.LoadUint32(&o.PIO_CAP_OUT0.Reg)&^(0x10000)|value<<16)
}
func (o *SYSCON_Type) GetPIO_CAP_OUT0_PA16_CAP_OUT() uint32 {
	return (volatile.LoadUint32(&o.PIO_CAP_OUT0.Reg) & 0x10000) >> 16
}
func (o *SYSCON_Type) SetPIO_CAP_OUT0_PA17_CAP_OUT(value uint32) {
	volatile.StoreUint32(&o.PIO_CAP_OUT0.Reg, volatile.LoadUint32(&o.PIO_CAP_OUT0.Reg)&^(0x20000)|value<<17)
}
func (o *SYSCON_Type) GetPIO_CAP_OUT0_PA17_CAP_OUT() uint32 {
	return (volatile.LoadUint32(&o.PIO_CAP_OUT0.Reg) & 0x20000) >> 17
}
func (o *SYSCON_Type) SetPIO_CAP_OUT0_PA18_CAP_OUT(value uint32) {
	volatile.StoreUint32(&o.PIO_CAP_OUT0.Reg, volatile.LoadUint32(&o.PIO_CAP_OUT0.Reg)&^(0x40000)|value<<18)
}
func (o *SYSCON_Type) GetPIO_CAP_OUT0_PA18_CAP_OUT() uint32 {
	return (volatile.LoadUint32(&o.PIO_CAP_OUT0.Reg) & 0x40000) >> 18
}
func (o *SYSCON_Type) SetPIO_CAP_OUT0_PA19_CAP_OUT(value uint32) {
	volatile.StoreUint32(&o.PIO_CAP_OUT0.Reg, volatile.LoadUint32(&o.PIO_CAP_OUT0.Reg)&^(0x80000)|value<<19)
}
func (o *SYSCON_Type) GetPIO_CAP_OUT0_PA19_CAP_OUT() uint32 {
	return (volatile.LoadUint32(&o.PIO_CAP_OUT0.Reg) & 0x80000) >> 19
}
func (o *SYSCON_Type) SetPIO_CAP_OUT0_PA20_CAP_OUT(value uint32) {
	volatile.StoreUint32(&o.PIO_CAP_OUT0.Reg, volatile.LoadUint32(&o.PIO_CAP_OUT0.Reg)&^(0x100000)|value<<20)
}
func (o *SYSCON_Type) GetPIO_CAP_OUT0_PA20_CAP_OUT() uint32 {
	return (volatile.LoadUint32(&o.PIO_CAP_OUT0.Reg) & 0x100000) >> 20
}
func (o *SYSCON_Type) SetPIO_CAP_OUT0_PA21_CAP_OUT(value uint32) {
	volatile.StoreUint32(&o.PIO_CAP_OUT0.Reg, volatile.LoadUint32(&o.PIO_CAP_OUT0.Reg)&^(0x200000)|value<<21)
}
func (o *SYSCON_Type) GetPIO_CAP_OUT0_PA21_CAP_OUT() uint32 {
	return (volatile.LoadUint32(&o.PIO_CAP_OUT0.Reg) & 0x200000) >> 21
}
func (o *SYSCON_Type) SetPIO_CAP_OUT0_PA22_CAP_OUT(value uint32) {
	volatile.StoreUint32(&o.PIO_CAP_OUT0.Reg, volatile.LoadUint32(&o.PIO_CAP_OUT0.Reg)&^(0x400000)|value<<22)
}
func (o *SYSCON_Type) GetPIO_CAP_OUT0_PA22_CAP_OUT() uint32 {
	return (volatile.LoadUint32(&o.PIO_CAP_OUT0.Reg) & 0x400000) >> 22
}
func (o *SYSCON_Type) SetPIO_CAP_OUT0_PA23_CAP_OUT(value uint32) {
	volatile.StoreUint32(&o.PIO_CAP_OUT0.Reg, volatile.LoadUint32(&o.PIO_CAP_OUT0.Reg)&^(0x800000)|value<<23)
}
func (o *SYSCON_Type) GetPIO_CAP_OUT0_PA23_CAP_OUT() uint32 {
	return (volatile.LoadUint32(&o.PIO_CAP_OUT0.Reg) & 0x800000) >> 23
}
func (o *SYSCON_Type) SetPIO_CAP_OUT0_PA24_CAP_OUT(value uint32) {
	volatile.StoreUint32(&o.PIO_CAP_OUT0.Reg, volatile.LoadUint32(&o.PIO_CAP_OUT0.Reg)&^(0x1000000)|value<<24)
}
func (o *SYSCON_Type) GetPIO_CAP_OUT0_PA24_CAP_OUT() uint32 {
	return (volatile.LoadUint32(&o.PIO_CAP_OUT0.Reg) & 0x1000000) >> 24
}
func (o *SYSCON_Type) SetPIO_CAP_OUT0_PA25_CAP_OUT(value uint32) {
	volatile.StoreUint32(&o.PIO_CAP_OUT0.Reg, volatile.LoadUint32(&o.PIO_CAP_OUT0.Reg)&^(0x2000000)|value<<25)
}
func (o *SYSCON_Type) GetPIO_CAP_OUT0_PA25_CAP_OUT() uint32 {
	return (volatile.LoadUint32(&o.PIO_CAP_OUT0.Reg) & 0x2000000) >> 25
}
func (o *SYSCON_Type) SetPIO_CAP_OUT0_PA26_CAP_OUT(value uint32) {
	volatile.StoreUint32(&o.PIO_CAP_OUT0.Reg, volatile.LoadUint32(&o.PIO_CAP_OUT0.Reg)&^(0x4000000)|value<<26)
}
func (o *SYSCON_Type) GetPIO_CAP_OUT0_PA26_CAP_OUT() uint32 {
	return (volatile.LoadUint32(&o.PIO_CAP_OUT0.Reg) & 0x4000000) >> 26
}
func (o *SYSCON_Type) SetPIO_CAP_OUT0_PA27_CAP_OUT(value uint32) {
	volatile.StoreUint32(&o.PIO_CAP_OUT0.Reg, volatile.LoadUint32(&o.PIO_CAP_OUT0.Reg)&^(0x8000000)|value<<27)
}
func (o *SYSCON_Type) GetPIO_CAP_OUT0_PA27_CAP_OUT() uint32 {
	return (volatile.LoadUint32(&o.PIO_CAP_OUT0.Reg) & 0x8000000) >> 27
}
func (o *SYSCON_Type) SetPIO_CAP_OUT0_PA28_CAP_OUT(value uint32) {
	volatile.StoreUint32(&o.PIO_CAP_OUT0.Reg, volatile.LoadUint32(&o.PIO_CAP_OUT0.Reg)&^(0x10000000)|value<<28)
}
func (o *SYSCON_Type) GetPIO_CAP_OUT0_PA28_CAP_OUT() uint32 {
	return (volatile.LoadUint32(&o.PIO_CAP_OUT0.Reg) & 0x10000000) >> 28
}
func (o *SYSCON_Type) SetPIO_CAP_OUT0_PA29_CAP_OUT(value uint32) {
	volatile.StoreUint32(&o.PIO_CAP_OUT0.Reg, volatile.LoadUint32(&o.PIO_CAP_OUT0.Reg)&^(0x20000000)|value<<29)
}
func (o *SYSCON_Type) GetPIO_CAP_OUT0_PA29_CAP_OUT() uint32 {
	return (volatile.LoadUint32(&o.PIO_CAP_OUT0.Reg) & 0x20000000) >> 29
}
func (o *SYSCON_Type) SetPIO_CAP_OUT0_PA30_CAP_OUT(value uint32) {
	volatile.StoreUint32(&o.PIO_CAP_OUT0.Reg, volatile.LoadUint32(&o.PIO_CAP_OUT0.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSCON_Type) GetPIO_CAP_OUT0_PA30_CAP_OUT() uint32 {
	return (volatile.LoadUint32(&o.PIO_CAP_OUT0.Reg) & 0x40000000) >> 30
}
func (o *SYSCON_Type) SetPIO_CAP_OUT0_PA31_CAP_OUT(value uint32) {
	volatile.StoreUint32(&o.PIO_CAP_OUT0.Reg, volatile.LoadUint32(&o.PIO_CAP_OUT0.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSCON_Type) GetPIO_CAP_OUT0_PA31_CAP_OUT() uint32 {
	return (volatile.LoadUint32(&o.PIO_CAP_OUT0.Reg) & 0x80000000) >> 31
}

// SYSCON.PIO_CAP_OUT1: pin output status register 0 while captured by writing 1 to IO_CAP
func (o *SYSCON_Type) SetPIO_CAP_OUT1_PB00_CAP_OUT(value uint32) {
	volatile.StoreUint32(&o.PIO_CAP_OUT1.Reg, volatile.LoadUint32(&o.PIO_CAP_OUT1.Reg)&^(0x1)|value)
}
func (o *SYSCON_Type) GetPIO_CAP_OUT1_PB00_CAP_OUT() uint32 {
	return volatile.LoadUint32(&o.PIO_CAP_OUT1.Reg) & 0x1
}
func (o *SYSCON_Type) SetPIO_CAP_OUT1_PB01_CAP_OUT(value uint32) {
	volatile.StoreUint32(&o.PIO_CAP_OUT1.Reg, volatile.LoadUint32(&o.PIO_CAP_OUT1.Reg)&^(0x2)|value<<1)
}
func (o *SYSCON_Type) GetPIO_CAP_OUT1_PB01_CAP_OUT() uint32 {
	return (volatile.LoadUint32(&o.PIO_CAP_OUT1.Reg) & 0x2) >> 1
}
func (o *SYSCON_Type) SetPIO_CAP_OUT1_PB02_CAP_OUT(value uint32) {
	volatile.StoreUint32(&o.PIO_CAP_OUT1.Reg, volatile.LoadUint32(&o.PIO_CAP_OUT1.Reg)&^(0x4)|value<<2)
}
func (o *SYSCON_Type) GetPIO_CAP_OUT1_PB02_CAP_OUT() uint32 {
	return (volatile.LoadUint32(&o.PIO_CAP_OUT1.Reg) & 0x4) >> 2
}

// SYSCON.RST_CAUSE_SRC: reset source status register
func (o *SYSCON_Type) SetRST_CAUSE_SRC_RESET_CAUSE(value uint32) {
	volatile.StoreUint32(&o.RST_CAUSE_SRC.Reg, volatile.LoadUint32(&o.RST_CAUSE_SRC.Reg)&^(0x1ff)|value)
}
func (o *SYSCON_Type) GetRST_CAUSE_SRC_RESET_CAUSE() uint32 {
	return volatile.LoadUint32(&o.RST_CAUSE_SRC.Reg) & 0x1ff
}
func (o *SYSCON_Type) SetRST_CAUSE_SRC_RST_CAUSE_CLR(value uint32) {
	volatile.StoreUint32(&o.RST_CAUSE_SRC.Reg, volatile.LoadUint32(&o.RST_CAUSE_SRC.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSCON_Type) GetRST_CAUSE_SRC_RST_CAUSE_CLR() uint32 {
	return (volatile.LoadUint32(&o.RST_CAUSE_SRC.Reg) & 0x80000000) >> 31
}

// SYSCON.PMU_CTRL0: power management uinit control register 0
func (o *SYSCON_Type) SetPMU_CTRL0_MEM0_DIS(value uint32) {
	volatile.StoreUint32(&o.PMU_CTRL0.Reg, volatile.LoadUint32(&o.PMU_CTRL0.Reg)&^(0x1)|value)
}
func (o *SYSCON_Type) GetPMU_CTRL0_MEM0_DIS() uint32 {
	return volatile.LoadUint32(&o.PMU_CTRL0.Reg) & 0x1
}
func (o *SYSCON_Type) SetPMU_CTRL0_MEM1_DIS(value uint32) {
	volatile.StoreUint32(&o.PMU_CTRL0.Reg, volatile.LoadUint32(&o.PMU_CTRL0.Reg)&^(0x2)|value<<1)
}
func (o *SYSCON_Type) GetPMU_CTRL0_MEM1_DIS() uint32 {
	return (volatile.LoadUint32(&o.PMU_CTRL0.Reg) & 0x2) >> 1
}
func (o *SYSCON_Type) SetPMU_CTRL0_MEM2_DIS(value uint32) {
	volatile.StoreUint32(&o.PMU_CTRL0.Reg, volatile.LoadUint32(&o.PMU_CTRL0.Reg)&^(0x4)|value<<2)
}
func (o *SYSCON_Type) GetPMU_CTRL0_MEM2_DIS() uint32 {
	return (volatile.LoadUint32(&o.PMU_CTRL0.Reg) & 0x4) >> 2
}
func (o *SYSCON_Type) SetPMU_CTRL0_MEM3_DIS(value uint32) {
	volatile.StoreUint32(&o.PMU_CTRL0.Reg, volatile.LoadUint32(&o.PMU_CTRL0.Reg)&^(0x8)|value<<3)
}
func (o *SYSCON_Type) GetPMU_CTRL0_MEM3_DIS() uint32 {
	return (volatile.LoadUint32(&o.PMU_CTRL0.Reg) & 0x8) >> 3
}
func (o *SYSCON_Type) SetPMU_CTRL0_MEM4_DIS(value uint32) {
	volatile.StoreUint32(&o.PMU_CTRL0.Reg, volatile.LoadUint32(&o.PMU_CTRL0.Reg)&^(0x10)|value<<4)
}
func (o *SYSCON_Type) GetPMU_CTRL0_MEM4_DIS() uint32 {
	return (volatile.LoadUint32(&o.PMU_CTRL0.Reg) & 0x10) >> 4
}
func (o *SYSCON_Type) SetPMU_CTRL0_MEM5_DIS(value uint32) {
	volatile.StoreUint32(&o.PMU_CTRL0.Reg, volatile.LoadUint32(&o.PMU_CTRL0.Reg)&^(0x20)|value<<5)
}
func (o *SYSCON_Type) GetPMU_CTRL0_MEM5_DIS() uint32 {
	return (volatile.LoadUint32(&o.PMU_CTRL0.Reg) & 0x20) >> 5
}
func (o *SYSCON_Type) SetPMU_CTRL0_MEM6_DIS(value uint32) {
	volatile.StoreUint32(&o.PMU_CTRL0.Reg, volatile.LoadUint32(&o.PMU_CTRL0.Reg)&^(0x40)|value<<6)
}
func (o *SYSCON_Type) GetPMU_CTRL0_MEM6_DIS() uint32 {
	return (volatile.LoadUint32(&o.PMU_CTRL0.Reg) & 0x40) >> 6
}
func (o *SYSCON_Type) SetPMU_CTRL0_MEM7_DIS(value uint32) {
	volatile.StoreUint32(&o.PMU_CTRL0.Reg, volatile.LoadUint32(&o.PMU_CTRL0.Reg)&^(0x80)|value<<7)
}
func (o *SYSCON_Type) GetPMU_CTRL0_MEM7_DIS() uint32 {
	return (volatile.LoadUint32(&o.PMU_CTRL0.Reg) & 0x80) >> 7
}
func (o *SYSCON_Type) SetPMU_CTRL0_MEM8_DIS(value uint32) {
	volatile.StoreUint32(&o.PMU_CTRL0.Reg, volatile.LoadUint32(&o.PMU_CTRL0.Reg)&^(0x100)|value<<8)
}
func (o *SYSCON_Type) GetPMU_CTRL0_MEM8_DIS() uint32 {
	return (volatile.LoadUint32(&o.PMU_CTRL0.Reg) & 0x100) >> 8
}
func (o *SYSCON_Type) SetPMU_CTRL0_MEM9_DIS(value uint32) {
	volatile.StoreUint32(&o.PMU_CTRL0.Reg, volatile.LoadUint32(&o.PMU_CTRL0.Reg)&^(0x200)|value<<9)
}
func (o *SYSCON_Type) GetPMU_CTRL0_MEM9_DIS() uint32 {
	return (volatile.LoadUint32(&o.PMU_CTRL0.Reg) & 0x200) >> 9
}
func (o *SYSCON_Type) SetPMU_CTRL0_BLE_DIS(value uint32) {
	volatile.StoreUint32(&o.PMU_CTRL0.Reg, volatile.LoadUint32(&o.PMU_CTRL0.Reg)&^(0x10000)|value<<16)
}
func (o *SYSCON_Type) GetPMU_CTRL0_BLE_DIS() uint32 {
	return (volatile.LoadUint32(&o.PMU_CTRL0.Reg) & 0x10000) >> 16
}
func (o *SYSCON_Type) SetPMU_CTRL0_FIR_DIS(value uint32) {
	volatile.StoreUint32(&o.PMU_CTRL0.Reg, volatile.LoadUint32(&o.PMU_CTRL0.Reg)&^(0x20000)|value<<17)
}
func (o *SYSCON_Type) GetPMU_CTRL0_FIR_DIS() uint32 {
	return (volatile.LoadUint32(&o.PMU_CTRL0.Reg) & 0x20000) >> 17
}
func (o *SYSCON_Type) SetPMU_CTRL0_FSP_DIS(value uint32) {
	volatile.StoreUint32(&o.PMU_CTRL0.Reg, volatile.LoadUint32(&o.PMU_CTRL0.Reg)&^(0x40000)|value<<18)
}
func (o *SYSCON_Type) GetPMU_CTRL0_FSP_DIS() uint32 {
	return (volatile.LoadUint32(&o.PMU_CTRL0.Reg) & 0x40000) >> 18
}
func (o *SYSCON_Type) SetPMU_CTRL0_MCU_MODE(value uint32) {
	volatile.StoreUint32(&o.PMU_CTRL0.Reg, volatile.LoadUint32(&o.PMU_CTRL0.Reg)&^(0x100000)|value<<20)
}
func (o *SYSCON_Type) GetPMU_CTRL0_MCU_MODE() uint32 {
	return (volatile.LoadUint32(&o.PMU_CTRL0.Reg) & 0x100000) >> 20
}
func (o *SYSCON_Type) SetPMU_CTRL0_OSC_INT_EN(value uint32) {
	volatile.StoreUint32(&o.PMU_CTRL0.Reg, volatile.LoadUint32(&o.PMU_CTRL0.Reg)&^(0x4000000)|value<<26)
}
func (o *SYSCON_Type) GetPMU_CTRL0_OSC_INT_EN() uint32 {
	return (volatile.LoadUint32(&o.PMU_CTRL0.Reg) & 0x4000000) >> 26
}
func (o *SYSCON_Type) SetPMU_CTRL0_RTC_SEC_WAKEUP_EN(value uint32) {
	volatile.StoreUint32(&o.PMU_CTRL0.Reg, volatile.LoadUint32(&o.PMU_CTRL0.Reg)&^(0x8000000)|value<<27)
}
func (o *SYSCON_Type) GetPMU_CTRL0_RTC_SEC_WAKEUP_EN() uint32 {
	return (volatile.LoadUint32(&o.PMU_CTRL0.Reg) & 0x8000000) >> 27
}
func (o *SYSCON_Type) SetPMU_CTRL0_WAKEUP_EN(value uint32) {
	volatile.StoreUint32(&o.PMU_CTRL0.Reg, volatile.LoadUint32(&o.PMU_CTRL0.Reg)&^(0x10000000)|value<<28)
}
func (o *SYSCON_Type) GetPMU_CTRL0_WAKEUP_EN() uint32 {
	return (volatile.LoadUint32(&o.PMU_CTRL0.Reg) & 0x10000000) >> 28
}
func (o *SYSCON_Type) SetPMU_CTRL0_PMU_EN(value uint32) {
	volatile.StoreUint32(&o.PMU_CTRL0.Reg, volatile.LoadUint32(&o.PMU_CTRL0.Reg)&^(0x20000000)|value<<29)
}
func (o *SYSCON_Type) GetPMU_CTRL0_PMU_EN() uint32 {
	return (volatile.LoadUint32(&o.PMU_CTRL0.Reg) & 0x20000000) >> 29
}
func (o *SYSCON_Type) SetPMU_CTRL0_RETENTION_EN(value uint32) {
	volatile.StoreUint32(&o.PMU_CTRL0.Reg, volatile.LoadUint32(&o.PMU_CTRL0.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSCON_Type) GetPMU_CTRL0_RETENTION_EN() uint32 {
	return (volatile.LoadUint32(&o.PMU_CTRL0.Reg) & 0x40000000) >> 30
}
func (o *SYSCON_Type) SetPMU_CTRL0_BOND_EN(value uint32) {
	volatile.StoreUint32(&o.PMU_CTRL0.Reg, volatile.LoadUint32(&o.PMU_CTRL0.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSCON_Type) GetPMU_CTRL0_BOND_EN() uint32 {
	return (volatile.LoadUint32(&o.PMU_CTRL0.Reg) & 0x80000000) >> 31
}

// SYSCON.PMU_CTRL1: power management uinit control register 1
func (o *SYSCON_Type) SetPMU_CTRL1_RCO32K_DIS(value uint32) {
	volatile.StoreUint32(&o.PMU_CTRL1.Reg, volatile.LoadUint32(&o.PMU_CTRL1.Reg)&^(0x1)|value)
}
func (o *SYSCON_Type) GetPMU_CTRL1_RCO32K_DIS() uint32 {
	return volatile.LoadUint32(&o.PMU_CTRL1.Reg) & 0x1
}
func (o *SYSCON_Type) SetPMU_CTRL1_XTAL32K_DIS(value uint32) {
	volatile.StoreUint32(&o.PMU_CTRL1.Reg, volatile.LoadUint32(&o.PMU_CTRL1.Reg)&^(0x2)|value<<1)
}
func (o *SYSCON_Type) GetPMU_CTRL1_XTAL32K_DIS() uint32 {
	return (volatile.LoadUint32(&o.PMU_CTRL1.Reg) & 0x2) >> 1
}
func (o *SYSCON_Type) SetPMU_CTRL1_XTAL_DIS(value uint32) {
	volatile.StoreUint32(&o.PMU_CTRL1.Reg, volatile.LoadUint32(&o.PMU_CTRL1.Reg)&^(0x4)|value<<2)
}
func (o *SYSCON_Type) GetPMU_CTRL1_XTAL_DIS() uint32 {
	return (volatile.LoadUint32(&o.PMU_CTRL1.Reg) & 0x4) >> 2
}
func (o *SYSCON_Type) SetPMU_CTRL1_OSC32M_DIS(value uint32) {
	volatile.StoreUint32(&o.PMU_CTRL1.Reg, volatile.LoadUint32(&o.PMU_CTRL1.Reg)&^(0x8)|value<<3)
}
func (o *SYSCON_Type) GetPMU_CTRL1_OSC32M_DIS() uint32 {
	return (volatile.LoadUint32(&o.PMU_CTRL1.Reg) & 0x8) >> 3
}
func (o *SYSCON_Type) SetPMU_CTRL1_USBPLL_DIS(value uint32) {
	volatile.StoreUint32(&o.PMU_CTRL1.Reg, volatile.LoadUint32(&o.PMU_CTRL1.Reg)&^(0x10)|value<<4)
}
func (o *SYSCON_Type) GetPMU_CTRL1_USBPLL_DIS() uint32 {
	return (volatile.LoadUint32(&o.PMU_CTRL1.Reg) & 0x10) >> 4
}
func (o *SYSCON_Type) SetPMU_CTRL1_ADC_BUF_DIS(value uint32) {
	volatile.StoreUint32(&o.PMU_CTRL1.Reg, volatile.LoadUint32(&o.PMU_CTRL1.Reg)&^(0x20)|value<<5)
}
func (o *SYSCON_Type) GetPMU_CTRL1_ADC_BUF_DIS() uint32 {
	return (volatile.LoadUint32(&o.PMU_CTRL1.Reg) & 0x20) >> 5
}
func (o *SYSCON_Type) SetPMU_CTRL1_ADC_BG_DIS(value uint32) {
	volatile.StoreUint32(&o.PMU_CTRL1.Reg, volatile.LoadUint32(&o.PMU_CTRL1.Reg)&^(0x40)|value<<6)
}
func (o *SYSCON_Type) GetPMU_CTRL1_ADC_BG_DIS() uint32 {
	return (volatile.LoadUint32(&o.PMU_CTRL1.Reg) & 0x40) >> 6
}
func (o *SYSCON_Type) SetPMU_CTRL1_ADC_DIS(value uint32) {
	volatile.StoreUint32(&o.PMU_CTRL1.Reg, volatile.LoadUint32(&o.PMU_CTRL1.Reg)&^(0x80)|value<<7)
}
func (o *SYSCON_Type) GetPMU_CTRL1_ADC_DIS() uint32 {
	return (volatile.LoadUint32(&o.PMU_CTRL1.Reg) & 0x80) >> 7
}
func (o *SYSCON_Type) SetPMU_CTRL1_ADC_VCM_DIS(value uint32) {
	volatile.StoreUint32(&o.PMU_CTRL1.Reg, volatile.LoadUint32(&o.PMU_CTRL1.Reg)&^(0x100)|value<<8)
}
func (o *SYSCON_Type) GetPMU_CTRL1_ADC_VCM_DIS() uint32 {
	return (volatile.LoadUint32(&o.PMU_CTRL1.Reg) & 0x100) >> 8
}
func (o *SYSCON_Type) SetPMU_CTRL1_ADC_VREF_DIS(value uint32) {
	volatile.StoreUint32(&o.PMU_CTRL1.Reg, volatile.LoadUint32(&o.PMU_CTRL1.Reg)&^(0x200)|value<<9)
}
func (o *SYSCON_Type) GetPMU_CTRL1_ADC_VREF_DIS() uint32 {
	return (volatile.LoadUint32(&o.PMU_CTRL1.Reg) & 0x200) >> 9
}
func (o *SYSCON_Type) SetPMU_CTRL1_DAC_DIS(value uint32) {
	volatile.StoreUint32(&o.PMU_CTRL1.Reg, volatile.LoadUint32(&o.PMU_CTRL1.Reg)&^(0x400)|value<<10)
}
func (o *SYSCON_Type) GetPMU_CTRL1_DAC_DIS() uint32 {
	return (volatile.LoadUint32(&o.PMU_CTRL1.Reg) & 0x400) >> 10
}
func (o *SYSCON_Type) SetPMU_CTRL1_CAP_SEN_DIS(value uint32) {
	volatile.StoreUint32(&o.PMU_CTRL1.Reg, volatile.LoadUint32(&o.PMU_CTRL1.Reg)&^(0x800)|value<<11)
}
func (o *SYSCON_Type) GetPMU_CTRL1_CAP_SEN_DIS() uint32 {
	return (volatile.LoadUint32(&o.PMU_CTRL1.Reg) & 0x800) >> 11
}
func (o *SYSCON_Type) SetPMU_CTRL1_BUCK_CTRL(value uint32) {
	volatile.StoreUint32(&o.PMU_CTRL1.Reg, volatile.LoadUint32(&o.PMU_CTRL1.Reg)&^(0xf0000)|value<<16)
}
func (o *SYSCON_Type) GetPMU_CTRL1_BUCK_CTRL() uint32 {
	return (volatile.LoadUint32(&o.PMU_CTRL1.Reg) & 0xf0000) >> 16
}
func (o *SYSCON_Type) SetPMU_CTRL1_RCO32K_PDM_DIS(value uint32) {
	volatile.StoreUint32(&o.PMU_CTRL1.Reg, volatile.LoadUint32(&o.PMU_CTRL1.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSCON_Type) GetPMU_CTRL1_RCO32K_PDM_DIS() uint32 {
	return (volatile.LoadUint32(&o.PMU_CTRL1.Reg) & 0x40000000) >> 30
}
func (o *SYSCON_Type) SetPMU_CTRL1_XTAL32K_PDM_DIS(value uint32) {
	volatile.StoreUint32(&o.PMU_CTRL1.Reg, volatile.LoadUint32(&o.PMU_CTRL1.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSCON_Type) GetPMU_CTRL1_XTAL32K_PDM_DIS() uint32 {
	return (volatile.LoadUint32(&o.PMU_CTRL1.Reg) & 0x80000000) >> 31
}

// SYSCON.ANA_EN: analog setting register
func (o *SYSCON_Type) SetANA_EN_BOD_AMP_EN(value uint32) {
	volatile.StoreUint32(&o.ANA_EN.Reg, volatile.LoadUint32(&o.ANA_EN.Reg)&^(0x1)|value)
}
func (o *SYSCON_Type) GetANA_EN_BOD_AMP_EN() uint32 {
	return volatile.LoadUint32(&o.ANA_EN.Reg) & 0x1
}
func (o *SYSCON_Type) SetANA_EN_BOD_EN(value uint32) {
	volatile.StoreUint32(&o.ANA_EN.Reg, volatile.LoadUint32(&o.ANA_EN.Reg)&^(0x2)|value<<1)
}
func (o *SYSCON_Type) GetANA_EN_BOD_EN() uint32 {
	return (volatile.LoadUint32(&o.ANA_EN.Reg) & 0x2) >> 1
}
func (o *SYSCON_Type) SetANA_EN_BAT_MON_EN(value uint32) {
	volatile.StoreUint32(&o.ANA_EN.Reg, volatile.LoadUint32(&o.ANA_EN.Reg)&^(0x4)|value<<2)
}
func (o *SYSCON_Type) GetANA_EN_BAT_MON_EN() uint32 {
	return (volatile.LoadUint32(&o.ANA_EN.Reg) & 0x4) >> 2
}
func (o *SYSCON_Type) SetANA_EN_ACMP0_EN(value uint32) {
	volatile.StoreUint32(&o.ANA_EN.Reg, volatile.LoadUint32(&o.ANA_EN.Reg)&^(0x8)|value<<3)
}
func (o *SYSCON_Type) GetANA_EN_ACMP0_EN() uint32 {
	return (volatile.LoadUint32(&o.ANA_EN.Reg) & 0x8) >> 3
}
func (o *SYSCON_Type) SetANA_EN_ACMP1_EN(value uint32) {
	volatile.StoreUint32(&o.ANA_EN.Reg, volatile.LoadUint32(&o.ANA_EN.Reg)&^(0x10)|value<<4)
}
func (o *SYSCON_Type) GetANA_EN_ACMP1_EN() uint32 {
	return (volatile.LoadUint32(&o.ANA_EN.Reg) & 0x10) >> 4
}
func (o *SYSCON_Type) SetANA_EN_BOR_AMP_EN(value uint32) {
	volatile.StoreUint32(&o.ANA_EN.Reg, volatile.LoadUint32(&o.ANA_EN.Reg)&^(0x20)|value<<5)
}
func (o *SYSCON_Type) GetANA_EN_BOR_AMP_EN() uint32 {
	return (volatile.LoadUint32(&o.ANA_EN.Reg) & 0x20) >> 5
}
func (o *SYSCON_Type) SetANA_EN_BOR_EN(value uint32) {
	volatile.StoreUint32(&o.ANA_EN.Reg, volatile.LoadUint32(&o.ANA_EN.Reg)&^(0x40)|value<<6)
}
func (o *SYSCON_Type) GetANA_EN_BOR_EN() uint32 {
	return (volatile.LoadUint32(&o.ANA_EN.Reg) & 0x40) >> 6
}
func (o *SYSCON_Type) SetANA_EN_ACMP0_REF(value uint32) {
	volatile.StoreUint32(&o.ANA_EN.Reg, volatile.LoadUint32(&o.ANA_EN.Reg)&^(0xf00)|value<<8)
}
func (o *SYSCON_Type) GetANA_EN_ACMP0_REF() uint32 {
	return (volatile.LoadUint32(&o.ANA_EN.Reg) & 0xf00) >> 8
}
func (o *SYSCON_Type) SetANA_EN_ACMP1_REF(value uint32) {
	volatile.StoreUint32(&o.ANA_EN.Reg, volatile.LoadUint32(&o.ANA_EN.Reg)&^(0xf000)|value<<12)
}
func (o *SYSCON_Type) GetANA_EN_ACMP1_REF() uint32 {
	return (volatile.LoadUint32(&o.ANA_EN.Reg) & 0xf000) >> 12
}
func (o *SYSCON_Type) SetANA_EN_ACMP0_HYST_EN(value uint32) {
	volatile.StoreUint32(&o.ANA_EN.Reg, volatile.LoadUint32(&o.ANA_EN.Reg)&^(0x10000)|value<<16)
}
func (o *SYSCON_Type) GetANA_EN_ACMP0_HYST_EN() uint32 {
	return (volatile.LoadUint32(&o.ANA_EN.Reg) & 0x10000) >> 16
}
func (o *SYSCON_Type) SetANA_EN_ACMP1_HYST_EN(value uint32) {
	volatile.StoreUint32(&o.ANA_EN.Reg, volatile.LoadUint32(&o.ANA_EN.Reg)&^(0x20000)|value<<17)
}
func (o *SYSCON_Type) GetANA_EN_ACMP1_HYST_EN() uint32 {
	return (volatile.LoadUint32(&o.ANA_EN.Reg) & 0x20000) >> 17
}
func (o *SYSCON_Type) SetANA_EN_ACMP_VREF_SEL(value uint32) {
	volatile.StoreUint32(&o.ANA_EN.Reg, volatile.LoadUint32(&o.ANA_EN.Reg)&^(0x40000)|value<<18)
}
func (o *SYSCON_Type) GetANA_EN_ACMP_VREF_SEL() uint32 {
	return (volatile.LoadUint32(&o.ANA_EN.Reg) & 0x40000) >> 18
}
func (o *SYSCON_Type) SetANA_EN_BOD_THR(value uint32) {
	volatile.StoreUint32(&o.ANA_EN.Reg, volatile.LoadUint32(&o.ANA_EN.Reg)&^(0x180000)|value<<19)
}
func (o *SYSCON_Type) GetANA_EN_BOD_THR() uint32 {
	return (volatile.LoadUint32(&o.ANA_EN.Reg) & 0x180000) >> 19
}
func (o *SYSCON_Type) SetANA_EN_BOR_THR(value uint32) {
	volatile.StoreUint32(&o.ANA_EN.Reg, volatile.LoadUint32(&o.ANA_EN.Reg)&^(0x600000)|value<<21)
}
func (o *SYSCON_Type) GetANA_EN_BOR_THR() uint32 {
	return (volatile.LoadUint32(&o.ANA_EN.Reg) & 0x600000) >> 21
}
func (o *SYSCON_Type) SetANA_EN_ACMP0_OUT(value uint32) {
	volatile.StoreUint32(&o.ANA_EN.Reg, volatile.LoadUint32(&o.ANA_EN.Reg)&^(0x1000000)|value<<24)
}
func (o *SYSCON_Type) GetANA_EN_ACMP0_OUT() uint32 {
	return (volatile.LoadUint32(&o.ANA_EN.Reg) & 0x1000000) >> 24
}
func (o *SYSCON_Type) SetANA_EN_ACMP1_OUT(value uint32) {
	volatile.StoreUint32(&o.ANA_EN.Reg, volatile.LoadUint32(&o.ANA_EN.Reg)&^(0x2000000)|value<<25)
}
func (o *SYSCON_Type) GetANA_EN_ACMP1_OUT() uint32 {
	return (volatile.LoadUint32(&o.ANA_EN.Reg) & 0x2000000) >> 25
}
func (o *SYSCON_Type) SetANA_EN_ACMP0_EDGE_SEL(value uint32) {
	volatile.StoreUint32(&o.ANA_EN.Reg, volatile.LoadUint32(&o.ANA_EN.Reg)&^(0xc000000)|value<<26)
}
func (o *SYSCON_Type) GetANA_EN_ACMP0_EDGE_SEL() uint32 {
	return (volatile.LoadUint32(&o.ANA_EN.Reg) & 0xc000000) >> 26
}
func (o *SYSCON_Type) SetANA_EN_ACMP1_EDGE_SEL(value uint32) {
	volatile.StoreUint32(&o.ANA_EN.Reg, volatile.LoadUint32(&o.ANA_EN.Reg)&^(0x30000000)|value<<28)
}
func (o *SYSCON_Type) GetANA_EN_ACMP1_EDGE_SEL() uint32 {
	return (volatile.LoadUint32(&o.ANA_EN.Reg) & 0x30000000) >> 28
}
func (o *SYSCON_Type) SetANA_EN_ACMP0_INTEN(value uint32) {
	volatile.StoreUint32(&o.ANA_EN.Reg, volatile.LoadUint32(&o.ANA_EN.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSCON_Type) GetANA_EN_ACMP0_INTEN() uint32 {
	return (volatile.LoadUint32(&o.ANA_EN.Reg) & 0x40000000) >> 30
}
func (o *SYSCON_Type) SetANA_EN_ACMP1_INTEN(value uint32) {
	volatile.StoreUint32(&o.ANA_EN.Reg, volatile.LoadUint32(&o.ANA_EN.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSCON_Type) GetANA_EN_ACMP1_INTEN() uint32 {
	return (volatile.LoadUint32(&o.ANA_EN.Reg) & 0x80000000) >> 31
}

// SYSCON.XTAL32K_CTRL: crystal 32K control register
func (o *SYSCON_Type) SetXTAL32K_CTRL_XTAL32K_ICTRL(value uint32) {
	volatile.StoreUint32(&o.XTAL32K_CTRL.Reg, volatile.LoadUint32(&o.XTAL32K_CTRL.Reg)&^(0x3f)|value)
}
func (o *SYSCON_Type) GetXTAL32K_CTRL_XTAL32K_ICTRL() uint32 {
	return volatile.LoadUint32(&o.XTAL32K_CTRL.Reg) & 0x3f
}
func (o *SYSCON_Type) SetXTAL32K_CTRL_XTAL32K_INJ(value uint32) {
	volatile.StoreUint32(&o.XTAL32K_CTRL.Reg, volatile.LoadUint32(&o.XTAL32K_CTRL.Reg)&^(0xc0)|value<<6)
}
func (o *SYSCON_Type) GetXTAL32K_CTRL_XTAL32K_INJ() uint32 {
	return (volatile.LoadUint32(&o.XTAL32K_CTRL.Reg) & 0xc0) >> 6
}
func (o *SYSCON_Type) SetXTAL32K_CTRL_XTAL32K_LOAD_CAP(value uint32) {
	volatile.StoreUint32(&o.XTAL32K_CTRL.Reg, volatile.LoadUint32(&o.XTAL32K_CTRL.Reg)&^(0x3f00)|value<<8)
}
func (o *SYSCON_Type) GetXTAL32K_CTRL_XTAL32K_LOAD_CAP() uint32 {
	return (volatile.LoadUint32(&o.XTAL32K_CTRL.Reg) & 0x3f00) >> 8
}
func (o *SYSCON_Type) SetXTAL32K_CTRL_XTAL32K_EXTRA_CAP(value uint32) {
	volatile.StoreUint32(&o.XTAL32K_CTRL.Reg, volatile.LoadUint32(&o.XTAL32K_CTRL.Reg)&^(0x4000)|value<<14)
}
func (o *SYSCON_Type) GetXTAL32K_CTRL_XTAL32K_EXTRA_CAP() uint32 {
	return (volatile.LoadUint32(&o.XTAL32K_CTRL.Reg) & 0x4000) >> 14
}

// SYSCON.USB_CFG: USB configuration register
func (o *SYSCON_Type) SetUSB_CFG_DPPUEN_B_PHY_POL(value uint32) {
	volatile.StoreUint32(&o.USB_CFG.Reg, volatile.LoadUint32(&o.USB_CFG.Reg)&^(0x1)|value)
}
func (o *SYSCON_Type) GetUSB_CFG_DPPUEN_B_PHY_POL() uint32 {
	return volatile.LoadUint32(&o.USB_CFG.Reg) & 0x1
}
func (o *SYSCON_Type) SetUSB_CFG_DPPUEN_B_PHY_SEL(value uint32) {
	volatile.StoreUint32(&o.USB_CFG.Reg, volatile.LoadUint32(&o.USB_CFG.Reg)&^(0x2)|value<<1)
}
func (o *SYSCON_Type) GetUSB_CFG_DPPUEN_B_PHY_SEL() uint32 {
	return (volatile.LoadUint32(&o.USB_CFG.Reg) & 0x2) >> 1
}
func (o *SYSCON_Type) SetUSB_CFG_USB_VBUS(value uint32) {
	volatile.StoreUint32(&o.USB_CFG.Reg, volatile.LoadUint32(&o.USB_CFG.Reg)&^(0x8)|value<<3)
}
func (o *SYSCON_Type) GetUSB_CFG_USB_VBUS() uint32 {
	return (volatile.LoadUint32(&o.USB_CFG.Reg) & 0x8) >> 3
}
func (o *SYSCON_Type) SetUSB_CFG_USB_PHYSTDBY(value uint32) {
	volatile.StoreUint32(&o.USB_CFG.Reg, volatile.LoadUint32(&o.USB_CFG.Reg)&^(0x10)|value<<4)
}
func (o *SYSCON_Type) GetUSB_CFG_USB_PHYSTDBY() uint32 {
	return (volatile.LoadUint32(&o.USB_CFG.Reg) & 0x10) >> 4
}
func (o *SYSCON_Type) SetUSB_CFG_USB_PHYSTDBY_WEN(value uint32) {
	volatile.StoreUint32(&o.USB_CFG.Reg, volatile.LoadUint32(&o.USB_CFG.Reg)&^(0x20)|value<<5)
}
func (o *SYSCON_Type) GetUSB_CFG_USB_PHYSTDBY_WEN() uint32 {
	return (volatile.LoadUint32(&o.USB_CFG.Reg) & 0x20) >> 5
}

// SYSCON.PMU_CTRL2: power management uinit control register 2
func (o *SYSCON_Type) SetPMU_CTRL2_BG_PDM_DIS(value uint32) {
	volatile.StoreUint32(&o.PMU_CTRL2.Reg, volatile.LoadUint32(&o.PMU_CTRL2.Reg)&^(0x1)|value)
}
func (o *SYSCON_Type) GetPMU_CTRL2_BG_PDM_DIS() uint32 {
	return volatile.LoadUint32(&o.PMU_CTRL2.Reg) & 0x1
}
func (o *SYSCON_Type) SetPMU_CTRL2_V2I_PDM_DIS(value uint32) {
	volatile.StoreUint32(&o.PMU_CTRL2.Reg, volatile.LoadUint32(&o.PMU_CTRL2.Reg)&^(0x2)|value<<1)
}
func (o *SYSCON_Type) GetPMU_CTRL2_V2I_PDM_DIS() uint32 {
	return (volatile.LoadUint32(&o.PMU_CTRL2.Reg) & 0x2) >> 1
}
func (o *SYSCON_Type) SetPMU_CTRL2_VREG_A_PDM_DIS(value uint32) {
	volatile.StoreUint32(&o.PMU_CTRL2.Reg, volatile.LoadUint32(&o.PMU_CTRL2.Reg)&^(0x4)|value<<2)
}
func (o *SYSCON_Type) GetPMU_CTRL2_VREG_A_PDM_DIS() uint32 {
	return (volatile.LoadUint32(&o.PMU_CTRL2.Reg) & 0x4) >> 2
}
func (o *SYSCON_Type) SetPMU_CTRL2_VREG_D_PDM_DIS(value uint32) {
	volatile.StoreUint32(&o.PMU_CTRL2.Reg, volatile.LoadUint32(&o.PMU_CTRL2.Reg)&^(0x8)|value<<3)
}
func (o *SYSCON_Type) GetPMU_CTRL2_VREG_D_PDM_DIS() uint32 {
	return (volatile.LoadUint32(&o.PMU_CTRL2.Reg) & 0x8) >> 3
}
func (o *SYSCON_Type) SetPMU_CTRL2_XTAL_PDM_DIS(value uint32) {
	volatile.StoreUint32(&o.PMU_CTRL2.Reg, volatile.LoadUint32(&o.PMU_CTRL2.Reg)&^(0x10)|value<<4)
}
func (o *SYSCON_Type) GetPMU_CTRL2_XTAL_PDM_DIS() uint32 {
	return (volatile.LoadUint32(&o.PMU_CTRL2.Reg) & 0x10) >> 4
}
func (o *SYSCON_Type) SetPMU_CTRL2_OSC32M_PDM_DIS(value uint32) {
	volatile.StoreUint32(&o.PMU_CTRL2.Reg, volatile.LoadUint32(&o.PMU_CTRL2.Reg)&^(0x20)|value<<5)
}
func (o *SYSCON_Type) GetPMU_CTRL2_OSC32M_PDM_DIS() uint32 {
	return (volatile.LoadUint32(&o.PMU_CTRL2.Reg) & 0x20) >> 5
}
func (o *SYSCON_Type) SetPMU_CTRL2_RFAGC_ON(value uint32) {
	volatile.StoreUint32(&o.PMU_CTRL2.Reg, volatile.LoadUint32(&o.PMU_CTRL2.Reg)&^(0x40)|value<<6)
}
func (o *SYSCON_Type) GetPMU_CTRL2_RFAGC_ON() uint32 {
	return (volatile.LoadUint32(&o.PMU_CTRL2.Reg) & 0x40) >> 6
}
func (o *SYSCON_Type) SetPMU_CTRL2_RX_EN_SEL(value uint32) {
	volatile.StoreUint32(&o.PMU_CTRL2.Reg, volatile.LoadUint32(&o.PMU_CTRL2.Reg)&^(0x80)|value<<7)
}
func (o *SYSCON_Type) GetPMU_CTRL2_RX_EN_SEL() uint32 {
	return (volatile.LoadUint32(&o.PMU_CTRL2.Reg) & 0x80) >> 7
}
func (o *SYSCON_Type) SetPMU_CTRL2_BG_DIS(value uint32) {
	volatile.StoreUint32(&o.PMU_CTRL2.Reg, volatile.LoadUint32(&o.PMU_CTRL2.Reg)&^(0x100)|value<<8)
}
func (o *SYSCON_Type) GetPMU_CTRL2_BG_DIS() uint32 {
	return (volatile.LoadUint32(&o.PMU_CTRL2.Reg) & 0x100) >> 8
}
func (o *SYSCON_Type) SetPMU_CTRL2_V2I_DIS(value uint32) {
	volatile.StoreUint32(&o.PMU_CTRL2.Reg, volatile.LoadUint32(&o.PMU_CTRL2.Reg)&^(0x200)|value<<9)
}
func (o *SYSCON_Type) GetPMU_CTRL2_V2I_DIS() uint32 {
	return (volatile.LoadUint32(&o.PMU_CTRL2.Reg) & 0x200) >> 9
}
func (o *SYSCON_Type) SetPMU_CTRL2_VREG_A_DIS(value uint32) {
	volatile.StoreUint32(&o.PMU_CTRL2.Reg, volatile.LoadUint32(&o.PMU_CTRL2.Reg)&^(0x400)|value<<10)
}
func (o *SYSCON_Type) GetPMU_CTRL2_VREG_A_DIS() uint32 {
	return (volatile.LoadUint32(&o.PMU_CTRL2.Reg) & 0x400) >> 10
}
func (o *SYSCON_Type) SetPMU_CTRL2_VREG_D_DIS(value uint32) {
	volatile.StoreUint32(&o.PMU_CTRL2.Reg, volatile.LoadUint32(&o.PMU_CTRL2.Reg)&^(0x800)|value<<11)
}
func (o *SYSCON_Type) GetPMU_CTRL2_VREG_D_DIS() uint32 {
	return (volatile.LoadUint32(&o.PMU_CTRL2.Reg) & 0x800) >> 11
}
func (o *SYSCON_Type) SetPMU_CTRL2_LO_DIS(value uint32) {
	volatile.StoreUint32(&o.PMU_CTRL2.Reg, volatile.LoadUint32(&o.PMU_CTRL2.Reg)&^(0x1000)|value<<12)
}
func (o *SYSCON_Type) GetPMU_CTRL2_LO_DIS() uint32 {
	return (volatile.LoadUint32(&o.PMU_CTRL2.Reg) & 0x1000) >> 12
}
func (o *SYSCON_Type) SetPMU_CTRL2_VCO_DIS(value uint32) {
	volatile.StoreUint32(&o.PMU_CTRL2.Reg, volatile.LoadUint32(&o.PMU_CTRL2.Reg)&^(0x2000)|value<<13)
}
func (o *SYSCON_Type) GetPMU_CTRL2_VCO_DIS() uint32 {
	return (volatile.LoadUint32(&o.PMU_CTRL2.Reg) & 0x2000) >> 13
}
func (o *SYSCON_Type) SetPMU_CTRL2_PA_PK_DIS(value uint32) {
	volatile.StoreUint32(&o.PMU_CTRL2.Reg, volatile.LoadUint32(&o.PMU_CTRL2.Reg)&^(0x4000)|value<<14)
}
func (o *SYSCON_Type) GetPMU_CTRL2_PA_PK_DIS() uint32 {
	return (volatile.LoadUint32(&o.PMU_CTRL2.Reg) & 0x4000) >> 14
}
func (o *SYSCON_Type) SetPMU_CTRL2_PA_DIS(value uint32) {
	volatile.StoreUint32(&o.PMU_CTRL2.Reg, volatile.LoadUint32(&o.PMU_CTRL2.Reg)&^(0x8000)|value<<15)
}
func (o *SYSCON_Type) GetPMU_CTRL2_PA_DIS() uint32 {
	return (volatile.LoadUint32(&o.PMU_CTRL2.Reg) & 0x8000) >> 15
}
func (o *SYSCON_Type) SetPMU_CTRL2_LNA_DIS(value uint32) {
	volatile.StoreUint32(&o.PMU_CTRL2.Reg, volatile.LoadUint32(&o.PMU_CTRL2.Reg)&^(0x10000)|value<<16)
}
func (o *SYSCON_Type) GetPMU_CTRL2_LNA_DIS() uint32 {
	return (volatile.LoadUint32(&o.PMU_CTRL2.Reg) & 0x10000) >> 16
}
func (o *SYSCON_Type) SetPMU_CTRL2_MIXER_DIS(value uint32) {
	volatile.StoreUint32(&o.PMU_CTRL2.Reg, volatile.LoadUint32(&o.PMU_CTRL2.Reg)&^(0x20000)|value<<17)
}
func (o *SYSCON_Type) GetPMU_CTRL2_MIXER_DIS() uint32 {
	return (volatile.LoadUint32(&o.PMU_CTRL2.Reg) & 0x20000) >> 17
}
func (o *SYSCON_Type) SetPMU_CTRL2_PKDET_DIS(value uint32) {
	volatile.StoreUint32(&o.PMU_CTRL2.Reg, volatile.LoadUint32(&o.PMU_CTRL2.Reg)&^(0x40000)|value<<18)
}
func (o *SYSCON_Type) GetPMU_CTRL2_PKDET_DIS() uint32 {
	return (volatile.LoadUint32(&o.PMU_CTRL2.Reg) & 0x40000) >> 18
}
func (o *SYSCON_Type) SetPMU_CTRL2_PPF_DIS(value uint32) {
	volatile.StoreUint32(&o.PMU_CTRL2.Reg, volatile.LoadUint32(&o.PMU_CTRL2.Reg)&^(0x80000)|value<<19)
}
func (o *SYSCON_Type) GetPMU_CTRL2_PPF_DIS() uint32 {
	return (volatile.LoadUint32(&o.PMU_CTRL2.Reg) & 0x80000) >> 19
}
func (o *SYSCON_Type) SetPMU_CTRL2_SAR_DIS(value uint32) {
	volatile.StoreUint32(&o.PMU_CTRL2.Reg, volatile.LoadUint32(&o.PMU_CTRL2.Reg)&^(0x100000)|value<<20)
}
func (o *SYSCON_Type) GetPMU_CTRL2_SAR_DIS() uint32 {
	return (volatile.LoadUint32(&o.PMU_CTRL2.Reg) & 0x100000) >> 20
}
func (o *SYSCON_Type) SetPMU_CTRL2_RC_CAL_DIS(value uint32) {
	volatile.StoreUint32(&o.PMU_CTRL2.Reg, volatile.LoadUint32(&o.PMU_CTRL2.Reg)&^(0x200000)|value<<21)
}
func (o *SYSCON_Type) GetPMU_CTRL2_RC_CAL_DIS() uint32 {
	return (volatile.LoadUint32(&o.PMU_CTRL2.Reg) & 0x200000) >> 21
}
func (o *SYSCON_Type) SetPMU_CTRL2_FLSH_DIS(value uint32) {
	volatile.StoreUint32(&o.PMU_CTRL2.Reg, volatile.LoadUint32(&o.PMU_CTRL2.Reg)&^(0x20000000)|value<<29)
}
func (o *SYSCON_Type) GetPMU_CTRL2_FLSH_DIS() uint32 {
	return (volatile.LoadUint32(&o.PMU_CTRL2.Reg) & 0x20000000) >> 29
}
func (o *SYSCON_Type) SetPMU_CTRL2_FLSH_PDM_DIS(value uint32) {
	volatile.StoreUint32(&o.PMU_CTRL2.Reg, volatile.LoadUint32(&o.PMU_CTRL2.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSCON_Type) GetPMU_CTRL2_FLSH_PDM_DIS() uint32 {
	return (volatile.LoadUint32(&o.PMU_CTRL2.Reg) & 0x40000000) >> 30
}
func (o *SYSCON_Type) SetPMU_CTRL2_SEL_PD(value uint32) {
	volatile.StoreUint32(&o.PMU_CTRL2.Reg, volatile.LoadUint32(&o.PMU_CTRL2.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSCON_Type) GetPMU_CTRL2_SEL_PD() uint32 {
	return (volatile.LoadUint32(&o.PMU_CTRL2.Reg) & 0x80000000) >> 31
}

// SYSCON.ANA_CTRL1: IVREF and DVREG setting register
func (o *SYSCON_Type) SetANA_CTRL1_VDD_PMU_SET_PDM(value uint32) {
	volatile.StoreUint32(&o.ANA_CTRL1.Reg, volatile.LoadUint32(&o.ANA_CTRL1.Reg)&^(0x3)|value)
}
func (o *SYSCON_Type) GetANA_CTRL1_VDD_PMU_SET_PDM() uint32 {
	return volatile.LoadUint32(&o.ANA_CTRL1.Reg) & 0x3
}
func (o *SYSCON_Type) SetANA_CTRL1_VDD_PMU_SET(value uint32) {
	volatile.StoreUint32(&o.ANA_CTRL1.Reg, volatile.LoadUint32(&o.ANA_CTRL1.Reg)&^(0xc)|value<<2)
}
func (o *SYSCON_Type) GetANA_CTRL1_VDD_PMU_SET() uint32 {
	return (volatile.LoadUint32(&o.ANA_CTRL1.Reg) & 0xc) >> 2
}
func (o *SYSCON_Type) SetANA_CTRL1_VDD_MEM_SET_PDM(value uint32) {
	volatile.StoreUint32(&o.ANA_CTRL1.Reg, volatile.LoadUint32(&o.ANA_CTRL1.Reg)&^(0x30)|value<<4)
}
func (o *SYSCON_Type) GetANA_CTRL1_VDD_MEM_SET_PDM() uint32 {
	return (volatile.LoadUint32(&o.ANA_CTRL1.Reg) & 0x30) >> 4
}
func (o *SYSCON_Type) SetANA_CTRL1_VDD_MEM_SET(value uint32) {
	volatile.StoreUint32(&o.ANA_CTRL1.Reg, volatile.LoadUint32(&o.ANA_CTRL1.Reg)&^(0xc0)|value<<6)
}
func (o *SYSCON_Type) GetANA_CTRL1_VDD_MEM_SET() uint32 {
	return (volatile.LoadUint32(&o.ANA_CTRL1.Reg) & 0xc0) >> 6
}
func (o *SYSCON_Type) SetANA_CTRL1_VDD_PMU_SET_EXTRA(value uint32) {
	volatile.StoreUint32(&o.ANA_CTRL1.Reg, volatile.LoadUint32(&o.ANA_CTRL1.Reg)&^(0x100)|value<<8)
}
func (o *SYSCON_Type) GetANA_CTRL1_VDD_PMU_SET_EXTRA() uint32 {
	return (volatile.LoadUint32(&o.ANA_CTRL1.Reg) & 0x100) >> 8
}
func (o *SYSCON_Type) SetANA_CTRL1_VDD_MEM_SET_EXTRA(value uint32) {
	volatile.StoreUint32(&o.ANA_CTRL1.Reg, volatile.LoadUint32(&o.ANA_CTRL1.Reg)&^(0x200)|value<<9)
}
func (o *SYSCON_Type) GetANA_CTRL1_VDD_MEM_SET_EXTRA() uint32 {
	return (volatile.LoadUint32(&o.ANA_CTRL1.Reg) & 0x200) >> 9
}
func (o *SYSCON_Type) SetANA_CTRL1_VDD_PMU_SET_ULTRA_LOW(value uint32) {
	volatile.StoreUint32(&o.ANA_CTRL1.Reg, volatile.LoadUint32(&o.ANA_CTRL1.Reg)&^(0x400)|value<<10)
}
func (o *SYSCON_Type) GetANA_CTRL1_VDD_PMU_SET_ULTRA_LOW() uint32 {
	return (volatile.LoadUint32(&o.ANA_CTRL1.Reg) & 0x400) >> 10
}
func (o *SYSCON_Type) SetANA_CTRL1_VDD_PMU_MEM_SW(value uint32) {
	volatile.StoreUint32(&o.ANA_CTRL1.Reg, volatile.LoadUint32(&o.ANA_CTRL1.Reg)&^(0x800)|value<<11)
}
func (o *SYSCON_Type) GetANA_CTRL1_VDD_PMU_MEM_SW() uint32 {
	return (volatile.LoadUint32(&o.ANA_CTRL1.Reg) & 0x800) >> 11
}
func (o *SYSCON_Type) SetANA_CTRL1_IV_BG_SEL(value uint32) {
	volatile.StoreUint32(&o.ANA_CTRL1.Reg, volatile.LoadUint32(&o.ANA_CTRL1.Reg)&^(0xf000)|value<<12)
}
func (o *SYSCON_Type) GetANA_CTRL1_IV_BG_SEL() uint32 {
	return (volatile.LoadUint32(&o.ANA_CTRL1.Reg) & 0xf000) >> 12
}
func (o *SYSCON_Type) SetANA_CTRL1_PDM_DIS_BUCK(value uint32) {
	volatile.StoreUint32(&o.ANA_CTRL1.Reg, volatile.LoadUint32(&o.ANA_CTRL1.Reg)&^(0x10000)|value<<16)
}
func (o *SYSCON_Type) GetANA_CTRL1_PDM_DIS_BUCK() uint32 {
	return (volatile.LoadUint32(&o.ANA_CTRL1.Reg) & 0x10000) >> 16
}
func (o *SYSCON_Type) SetANA_CTRL1_BUCK_PD_CCM(value uint32) {
	volatile.StoreUint32(&o.ANA_CTRL1.Reg, volatile.LoadUint32(&o.ANA_CTRL1.Reg)&^(0x20000)|value<<17)
}
func (o *SYSCON_Type) GetANA_CTRL1_BUCK_PD_CCM() uint32 {
	return (volatile.LoadUint32(&o.ANA_CTRL1.Reg) & 0x20000) >> 17
}
func (o *SYSCON_Type) SetANA_CTRL1_BUCK_PD_DCM(value uint32) {
	volatile.StoreUint32(&o.ANA_CTRL1.Reg, volatile.LoadUint32(&o.ANA_CTRL1.Reg)&^(0x40000)|value<<18)
}
func (o *SYSCON_Type) GetANA_CTRL1_BUCK_PD_DCM() uint32 {
	return (volatile.LoadUint32(&o.ANA_CTRL1.Reg) & 0x40000) >> 18
}
func (o *SYSCON_Type) SetANA_CTRL1_IV_IREF_SEL(value uint32) {
	volatile.StoreUint32(&o.ANA_CTRL1.Reg, volatile.LoadUint32(&o.ANA_CTRL1.Reg)&^(0x180000)|value<<19)
}
func (o *SYSCON_Type) GetANA_CTRL1_IV_IREF_SEL() uint32 {
	return (volatile.LoadUint32(&o.ANA_CTRL1.Reg) & 0x180000) >> 19
}
func (o *SYSCON_Type) SetANA_CTRL1_IV_VREG11_SET(value uint32) {
	volatile.StoreUint32(&o.ANA_CTRL1.Reg, volatile.LoadUint32(&o.ANA_CTRL1.Reg)&^(0xe00000)|value<<21)
}
func (o *SYSCON_Type) GetANA_CTRL1_IV_VREG11_SET() uint32 {
	return (volatile.LoadUint32(&o.ANA_CTRL1.Reg) & 0xe00000) >> 21
}
func (o *SYSCON_Type) SetANA_CTRL1_XTAL32K_FORCE_RDY(value uint32) {
	volatile.StoreUint32(&o.ANA_CTRL1.Reg, volatile.LoadUint32(&o.ANA_CTRL1.Reg)&^(0x1000000)|value<<24)
}
func (o *SYSCON_Type) GetANA_CTRL1_XTAL32K_FORCE_RDY() uint32 {
	return (volatile.LoadUint32(&o.ANA_CTRL1.Reg) & 0x1000000) >> 24
}
func (o *SYSCON_Type) SetANA_CTRL1_X32_SMT_EN(value uint32) {
	volatile.StoreUint32(&o.ANA_CTRL1.Reg, volatile.LoadUint32(&o.ANA_CTRL1.Reg)&^(0x2000000)|value<<25)
}
func (o *SYSCON_Type) GetANA_CTRL1_X32_SMT_EN() uint32 {
	return (volatile.LoadUint32(&o.ANA_CTRL1.Reg) & 0x2000000) >> 25
}
func (o *SYSCON_Type) SetANA_CTRL1_BM_X32BUF(value uint32) {
	volatile.StoreUint32(&o.ANA_CTRL1.Reg, volatile.LoadUint32(&o.ANA_CTRL1.Reg)&^(0xc000000)|value<<26)
}
func (o *SYSCON_Type) GetANA_CTRL1_BM_X32BUF() uint32 {
	return (volatile.LoadUint32(&o.ANA_CTRL1.Reg) & 0xc000000) >> 26
}
func (o *SYSCON_Type) SetANA_CTRL1_DVREG11_SET_DIG(value uint32) {
	volatile.StoreUint32(&o.ANA_CTRL1.Reg, volatile.LoadUint32(&o.ANA_CTRL1.Reg)&^(0x70000000)|value<<28)
}
func (o *SYSCON_Type) GetANA_CTRL1_DVREG11_SET_DIG() uint32 {
	return (volatile.LoadUint32(&o.ANA_CTRL1.Reg) & 0x70000000) >> 28
}
func (o *SYSCON_Type) SetANA_CTRL1_BUCK_DPD(value uint32) {
	volatile.StoreUint32(&o.ANA_CTRL1.Reg, volatile.LoadUint32(&o.ANA_CTRL1.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSCON_Type) GetANA_CTRL1_BUCK_DPD() uint32 {
	return (volatile.LoadUint32(&o.ANA_CTRL1.Reg) & 0x80000000) >> 31
}

// SYSCON.MISC: MISC register
func (o *SYSCON_Type) SetMISC_RCO_PWR_MODE(value uint32) {
	volatile.StoreUint32(&o.MISC.Reg, volatile.LoadUint32(&o.MISC.Reg)&^(0x3)|value)
}
func (o *SYSCON_Type) GetMISC_RCO_PWR_MODE() uint32 {
	return volatile.LoadUint32(&o.MISC.Reg) & 0x3
}
func (o *SYSCON_Type) SetMISC_EN_SWD(value uint32) {
	volatile.StoreUint32(&o.MISC.Reg, volatile.LoadUint32(&o.MISC.Reg)&^(0x10000)|value<<16)
}
func (o *SYSCON_Type) GetMISC_EN_SWD() uint32 {
	return (volatile.LoadUint32(&o.MISC.Reg) & 0x10000) >> 16
}
func (o *SYSCON_Type) SetMISC_DIS_FLSH_POWER(value uint32) {
	volatile.StoreUint32(&o.MISC.Reg, volatile.LoadUint32(&o.MISC.Reg)&^(0x20000)|value<<17)
}
func (o *SYSCON_Type) GetMISC_DIS_FLSH_POWER() uint32 {
	return (volatile.LoadUint32(&o.MISC.Reg) & 0x20000) >> 17
}
func (o *SYSCON_Type) SetMISC_DIS_USB_PULLUP(value uint32) {
	volatile.StoreUint32(&o.MISC.Reg, volatile.LoadUint32(&o.MISC.Reg)&^(0x40000)|value<<18)
}
func (o *SYSCON_Type) GetMISC_DIS_USB_PULLUP() uint32 {
	return (volatile.LoadUint32(&o.MISC.Reg) & 0x40000) >> 18
}
func (o *SYSCON_Type) SetMISC_DPPU_OPT_SEL(value uint32) {
	volatile.StoreUint32(&o.MISC.Reg, volatile.LoadUint32(&o.MISC.Reg)&^(0x1000000)|value<<24)
}
func (o *SYSCON_Type) GetMISC_DPPU_OPT_SEL() uint32 {
	return (volatile.LoadUint32(&o.MISC.Reg) & 0x1000000) >> 24
}
func (o *SYSCON_Type) SetMISC_DPPU_OPT_POL(value uint32) {
	volatile.StoreUint32(&o.MISC.Reg, volatile.LoadUint32(&o.MISC.Reg)&^(0x2000000)|value<<25)
}
func (o *SYSCON_Type) GetMISC_DPPU_OPT_POL() uint32 {
	return (volatile.LoadUint32(&o.MISC.Reg) & 0x2000000) >> 25
}

// wdog
type WDT_Type struct {
	LOAD    volatile.Register32 // 0x0
	VALUE   volatile.Register32 // 0x4
	CTRL    volatile.Register32 // 0x8
	INT_CLR volatile.Register32 // 0xC
	INT_RAW volatile.Register32 // 0x10
	MIS     volatile.Register32 // 0x14
	_       [8]byte
	LOCK    volatile.Register32 // 0x20
}

// WDT.LOAD: watch dog counter start value register
func (o *WDT_Type) SetLOAD(value uint32) {
	volatile.StoreUint32(&o.LOAD.Reg, value)
}
func (o *WDT_Type) GetLOAD() uint32 {
	return volatile.LoadUint32(&o.LOAD.Reg)
}

// WDT.VALUE: watch dog counter value register
func (o *WDT_Type) SetVALUE(value uint32) {
	volatile.StoreUint32(&o.VALUE.Reg, value)
}
func (o *WDT_Type) GetVALUE() uint32 {
	return volatile.LoadUint32(&o.VALUE.Reg)
}

// WDT.CTRL: watch dog control register
func (o *WDT_Type) SetCTRL_INTEN(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x1)|value)
}
func (o *WDT_Type) GetCTRL_INTEN() uint32 {
	return volatile.LoadUint32(&o.CTRL.Reg) & 0x1
}
func (o *WDT_Type) SetCTRL_RESEN(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x2)|value<<1)
}
func (o *WDT_Type) GetCTRL_RESEN() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x2) >> 1
}

// WDT.INT_CLR: interrupt clear register
func (o *WDT_Type) SetINT_CLR_INTCLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x1)|value)
}
func (o *WDT_Type) GetINT_CLR_INTCLR() uint32 {
	return volatile.LoadUint32(&o.INT_CLR.Reg) & 0x1
}

// WDT.INT_RAW: raw interrupt status register
func (o *WDT_Type) SetINT_RAW_RAWINTSTAT(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x1)|value)
}
func (o *WDT_Type) GetINT_RAW_RAWINTSTAT() uint32 {
	return volatile.LoadUint32(&o.INT_RAW.Reg) & 0x1
}

// WDT.MIS: interrupt mask register
func (o *WDT_Type) SetMIS_MASKINTSTAT(value uint32) {
	volatile.StoreUint32(&o.MIS.Reg, volatile.LoadUint32(&o.MIS.Reg)&^(0x1)|value)
}
func (o *WDT_Type) GetMIS_MASKINTSTAT() uint32 {
	return volatile.LoadUint32(&o.MIS.Reg) & 0x1
}

// WDT.LOCK: watch dog lock register
func (o *WDT_Type) SetLOCK(value uint32) {
	volatile.StoreUint32(&o.LOCK.Reg, value)
}
func (o *WDT_Type) GetLOCK() uint32 {
	return volatile.LoadUint32(&o.LOCK.Reg)
}

// timer
type CTIMER_Type struct {
	IR   volatile.Register32    // 0x0
	TCR  volatile.Register32    // 0x4
	TC   volatile.Register32    // 0x8
	PR   volatile.Register32    // 0xC
	PC   volatile.Register32    // 0x10
	MCR  volatile.Register32    // 0x14
	MR   [4]volatile.Register32 // 0x18
	CCR  volatile.Register32    // 0x28
	CR   [3]volatile.Register32 // 0x2C
	_    [4]byte
	EMR  volatile.Register32 // 0x3C
	_    [48]byte
	CTCR volatile.Register32 // 0x70
	PWMC volatile.Register32 // 0x74
}

// CTIMER.IR: Interrupt Register. The IR can be written to clear interrupts. The IR can be read to identify which of eight possible interrupt sources are pending.
func (o *CTIMER_Type) SetIR_MR0INT(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x1)|value)
}
func (o *CTIMER_Type) GetIR_MR0INT() uint32 {
	return volatile.LoadUint32(&o.IR.Reg) & 0x1
}
func (o *CTIMER_Type) SetIR_MR1INT(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x2)|value<<1)
}
func (o *CTIMER_Type) GetIR_MR1INT() uint32 {
	return (volatile.LoadUint32(&o.IR.Reg) & 0x2) >> 1
}
func (o *CTIMER_Type) SetIR_MR2INT(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x4)|value<<2)
}
func (o *CTIMER_Type) GetIR_MR2INT() uint32 {
	return (volatile.LoadUint32(&o.IR.Reg) & 0x4) >> 2
}
func (o *CTIMER_Type) SetIR_MR3INT(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x8)|value<<3)
}
func (o *CTIMER_Type) GetIR_MR3INT() uint32 {
	return (volatile.LoadUint32(&o.IR.Reg) & 0x8) >> 3
}
func (o *CTIMER_Type) SetIR_CR0INT(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x10)|value<<4)
}
func (o *CTIMER_Type) GetIR_CR0INT() uint32 {
	return (volatile.LoadUint32(&o.IR.Reg) & 0x10) >> 4
}
func (o *CTIMER_Type) SetIR_CR1INT(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x20)|value<<5)
}
func (o *CTIMER_Type) GetIR_CR1INT() uint32 {
	return (volatile.LoadUint32(&o.IR.Reg) & 0x20) >> 5
}
func (o *CTIMER_Type) SetIR_CR2INT(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x40)|value<<6)
}
func (o *CTIMER_Type) GetIR_CR2INT() uint32 {
	return (volatile.LoadUint32(&o.IR.Reg) & 0x40) >> 6
}

// CTIMER.TCR: Timer Control Register. The TCR is used to control the Timer Counter functions. The Timer Counter can be disabled or reset through the TCR.
func (o *CTIMER_Type) SetTCR_CEN(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0x1)|value)
}
func (o *CTIMER_Type) GetTCR_CEN() uint32 {
	return volatile.LoadUint32(&o.TCR.Reg) & 0x1
}
func (o *CTIMER_Type) SetTCR_CRST(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0x2)|value<<1)
}
func (o *CTIMER_Type) GetTCR_CRST() uint32 {
	return (volatile.LoadUint32(&o.TCR.Reg) & 0x2) >> 1
}

// CTIMER.TC: Timer Counter. The 32 bit TC is incremented every PR+1 cycles of the APB bus clock. The TC is controlled through the TCR.
func (o *CTIMER_Type) SetTC(value uint32) {
	volatile.StoreUint32(&o.TC.Reg, value)
}
func (o *CTIMER_Type) GetTC() uint32 {
	return volatile.LoadUint32(&o.TC.Reg)
}

// CTIMER.PR: Prescale Register. When the Prescale Counter (PC) is equal to this value, the next clock increments the TC and clears the PC.
func (o *CTIMER_Type) SetPR(value uint32) {
	volatile.StoreUint32(&o.PR.Reg, value)
}
func (o *CTIMER_Type) GetPR() uint32 {
	return volatile.LoadUint32(&o.PR.Reg)
}

// CTIMER.PC: Prescale Counter. The 32 bit PC is a counter which is incremented to the value stored in PR. When the value in PR is reached, the TC is incremented and the PC is cleared. The PC is observable and controllable through the bus interface.
func (o *CTIMER_Type) SetPC(value uint32) {
	volatile.StoreUint32(&o.PC.Reg, value)
}
func (o *CTIMER_Type) GetPC() uint32 {
	return volatile.LoadUint32(&o.PC.Reg)
}

// CTIMER.MCR: Match Control Register. The MCR is used to control if an interrupt is generated and if the TC is reset when a Match occurs.
func (o *CTIMER_Type) SetMCR_MR0I(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x1)|value)
}
func (o *CTIMER_Type) GetMCR_MR0I() uint32 {
	return volatile.LoadUint32(&o.MCR.Reg) & 0x1
}
func (o *CTIMER_Type) SetMCR_MR0R(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x2)|value<<1)
}
func (o *CTIMER_Type) GetMCR_MR0R() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x2) >> 1
}
func (o *CTIMER_Type) SetMCR_MR0S(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x4)|value<<2)
}
func (o *CTIMER_Type) GetMCR_MR0S() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x4) >> 2
}
func (o *CTIMER_Type) SetMCR_MR1I(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x8)|value<<3)
}
func (o *CTIMER_Type) GetMCR_MR1I() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x8) >> 3
}
func (o *CTIMER_Type) SetMCR_MR1R(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x10)|value<<4)
}
func (o *CTIMER_Type) GetMCR_MR1R() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x10) >> 4
}
func (o *CTIMER_Type) SetMCR_MR1S(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x20)|value<<5)
}
func (o *CTIMER_Type) GetMCR_MR1S() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x20) >> 5
}
func (o *CTIMER_Type) SetMCR_MR2I(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x40)|value<<6)
}
func (o *CTIMER_Type) GetMCR_MR2I() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x40) >> 6
}
func (o *CTIMER_Type) SetMCR_MR2R(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x80)|value<<7)
}
func (o *CTIMER_Type) GetMCR_MR2R() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x80) >> 7
}
func (o *CTIMER_Type) SetMCR_MR2S(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x100)|value<<8)
}
func (o *CTIMER_Type) GetMCR_MR2S() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x100) >> 8
}
func (o *CTIMER_Type) SetMCR_MR3I(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x200)|value<<9)
}
func (o *CTIMER_Type) GetMCR_MR3I() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x200) >> 9
}
func (o *CTIMER_Type) SetMCR_MR3R(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x400)|value<<10)
}
func (o *CTIMER_Type) GetMCR_MR3R() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x400) >> 10
}
func (o *CTIMER_Type) SetMCR_MR3S(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x800)|value<<11)
}
func (o *CTIMER_Type) GetMCR_MR3S() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x800) >> 11
}

// CTIMER.MR: Match Register . MR can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR matches the TC.
func (o *CTIMER_Type) SetMR(idx int, value uint32) {
	volatile.StoreUint32(&o.MR[idx].Reg, value)
}
func (o *CTIMER_Type) GetMR(idx int) uint32 {
	return volatile.LoadUint32(&o.MR[idx].Reg)
}

// CTIMER.CCR: Capture Control Register. The CCR controls which edges of the capture inputs are used to load the Capture Registers and whether or not an interrupt is generated when a capture takes place.
func (o *CTIMER_Type) SetCCR_CAP0RE(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x1)|value)
}
func (o *CTIMER_Type) GetCCR_CAP0RE() uint32 {
	return volatile.LoadUint32(&o.CCR.Reg) & 0x1
}
func (o *CTIMER_Type) SetCCR_CAP0FE(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x2)|value<<1)
}
func (o *CTIMER_Type) GetCCR_CAP0FE() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x2) >> 1
}
func (o *CTIMER_Type) SetCCR_CAP0I(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x4)|value<<2)
}
func (o *CTIMER_Type) GetCCR_CAP0I() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x4) >> 2
}
func (o *CTIMER_Type) SetCCR_CAP1RE(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x8)|value<<3)
}
func (o *CTIMER_Type) GetCCR_CAP1RE() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x8) >> 3
}
func (o *CTIMER_Type) SetCCR_CAP1FE(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x10)|value<<4)
}
func (o *CTIMER_Type) GetCCR_CAP1FE() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x10) >> 4
}
func (o *CTIMER_Type) SetCCR_CAP1I(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x20)|value<<5)
}
func (o *CTIMER_Type) GetCCR_CAP1I() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x20) >> 5
}
func (o *CTIMER_Type) SetCCR_CAP2RE(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x40)|value<<6)
}
func (o *CTIMER_Type) GetCCR_CAP2RE() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x40) >> 6
}
func (o *CTIMER_Type) SetCCR_CAP2FE(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x80)|value<<7)
}
func (o *CTIMER_Type) GetCCR_CAP2FE() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x80) >> 7
}
func (o *CTIMER_Type) SetCCR_CAP2I(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x100)|value<<8)
}
func (o *CTIMER_Type) GetCCR_CAP2I() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x100) >> 8
}

// CTIMER.CR: Capture Register . CR is loaded with the value of TC when there is an event on the CAPn. input.
func (o *CTIMER_Type) SetCR(idx int, value uint32) {
	volatile.StoreUint32(&o.CR[idx].Reg, value)
}
func (o *CTIMER_Type) GetCR(idx int) uint32 {
	return volatile.LoadUint32(&o.CR[idx].Reg)
}

// CTIMER.EMR: External Match Register. The EMR controls the match function and the external match pins.
func (o *CTIMER_Type) SetEMR_EM0(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0x1)|value)
}
func (o *CTIMER_Type) GetEMR_EM0() uint32 {
	return volatile.LoadUint32(&o.EMR.Reg) & 0x1
}
func (o *CTIMER_Type) SetEMR_EM1(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0x2)|value<<1)
}
func (o *CTIMER_Type) GetEMR_EM1() uint32 {
	return (volatile.LoadUint32(&o.EMR.Reg) & 0x2) >> 1
}
func (o *CTIMER_Type) SetEMR_EM2(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0x4)|value<<2)
}
func (o *CTIMER_Type) GetEMR_EM2() uint32 {
	return (volatile.LoadUint32(&o.EMR.Reg) & 0x4) >> 2
}
func (o *CTIMER_Type) SetEMR_EM3(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0x8)|value<<3)
}
func (o *CTIMER_Type) GetEMR_EM3() uint32 {
	return (volatile.LoadUint32(&o.EMR.Reg) & 0x8) >> 3
}
func (o *CTIMER_Type) SetEMR_EMC0(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0x30)|value<<4)
}
func (o *CTIMER_Type) GetEMR_EMC0() uint32 {
	return (volatile.LoadUint32(&o.EMR.Reg) & 0x30) >> 4
}
func (o *CTIMER_Type) SetEMR_EMC1(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0xc0)|value<<6)
}
func (o *CTIMER_Type) GetEMR_EMC1() uint32 {
	return (volatile.LoadUint32(&o.EMR.Reg) & 0xc0) >> 6
}
func (o *CTIMER_Type) SetEMR_EMC2(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0x300)|value<<8)
}
func (o *CTIMER_Type) GetEMR_EMC2() uint32 {
	return (volatile.LoadUint32(&o.EMR.Reg) & 0x300) >> 8
}
func (o *CTIMER_Type) SetEMR_EMC3(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0xc00)|value<<10)
}
func (o *CTIMER_Type) GetEMR_EMC3() uint32 {
	return (volatile.LoadUint32(&o.EMR.Reg) & 0xc00) >> 10
}

// CTIMER.CTCR: Count Control Register. The CTCR selects between Timer and Counter mode, and in Counter mode selects the signal and edge(s) for counting.
func (o *CTIMER_Type) SetCTCR_CTMODE(value uint32) {
	volatile.StoreUint32(&o.CTCR.Reg, volatile.LoadUint32(&o.CTCR.Reg)&^(0x3)|value)
}
func (o *CTIMER_Type) GetCTCR_CTMODE() uint32 {
	return volatile.LoadUint32(&o.CTCR.Reg) & 0x3
}
func (o *CTIMER_Type) SetCTCR_CINSEL(value uint32) {
	volatile.StoreUint32(&o.CTCR.Reg, volatile.LoadUint32(&o.CTCR.Reg)&^(0xc)|value<<2)
}
func (o *CTIMER_Type) GetCTCR_CINSEL() uint32 {
	return (volatile.LoadUint32(&o.CTCR.Reg) & 0xc) >> 2
}
func (o *CTIMER_Type) SetCTCR_ENCC(value uint32) {
	volatile.StoreUint32(&o.CTCR.Reg, volatile.LoadUint32(&o.CTCR.Reg)&^(0x10)|value<<4)
}
func (o *CTIMER_Type) GetCTCR_ENCC() uint32 {
	return (volatile.LoadUint32(&o.CTCR.Reg) & 0x10) >> 4
}
func (o *CTIMER_Type) SetCTCR_SELCC(value uint32) {
	volatile.StoreUint32(&o.CTCR.Reg, volatile.LoadUint32(&o.CTCR.Reg)&^(0xe0)|value<<5)
}
func (o *CTIMER_Type) GetCTCR_SELCC() uint32 {
	return (volatile.LoadUint32(&o.CTCR.Reg) & 0xe0) >> 5
}

// CTIMER.PWMC: PWM Control Register. The PWMCON enables PWM mode for the external match pins.
func (o *CTIMER_Type) SetPWMC_PWMEN0(value uint32) {
	volatile.StoreUint32(&o.PWMC.Reg, volatile.LoadUint32(&o.PWMC.Reg)&^(0x1)|value)
}
func (o *CTIMER_Type) GetPWMC_PWMEN0() uint32 {
	return volatile.LoadUint32(&o.PWMC.Reg) & 0x1
}
func (o *CTIMER_Type) SetPWMC_PWMEN1(value uint32) {
	volatile.StoreUint32(&o.PWMC.Reg, volatile.LoadUint32(&o.PWMC.Reg)&^(0x2)|value<<1)
}
func (o *CTIMER_Type) GetPWMC_PWMEN1() uint32 {
	return (volatile.LoadUint32(&o.PWMC.Reg) & 0x2) >> 1
}
func (o *CTIMER_Type) SetPWMC_PWMEN2(value uint32) {
	volatile.StoreUint32(&o.PWMC.Reg, volatile.LoadUint32(&o.PWMC.Reg)&^(0x4)|value<<2)
}
func (o *CTIMER_Type) GetPWMC_PWMEN2() uint32 {
	return (volatile.LoadUint32(&o.PWMC.Reg) & 0x4) >> 2
}
func (o *CTIMER_Type) SetPWMC_PWMEN3(value uint32) {
	volatile.StoreUint32(&o.PWMC.Reg, volatile.LoadUint32(&o.PWMC.Reg)&^(0x8)|value<<3)
}
func (o *CTIMER_Type) GetPWMC_PWMEN3() uint32 {
	return (volatile.LoadUint32(&o.PWMC.Reg) & 0x8) >> 3
}

// QN908X Pin interrupt and pattern match (PINT)
type PINT_Type struct {
	ISEL   volatile.Register32 // 0x0
	IENR   volatile.Register32 // 0x4
	SIENR  volatile.Register32 // 0x8
	CIENR  volatile.Register32 // 0xC
	IENF   volatile.Register32 // 0x10
	SIENF  volatile.Register32 // 0x14
	CIENF  volatile.Register32 // 0x18
	RISE   volatile.Register32 // 0x1C
	FALL   volatile.Register32 // 0x20
	IST    volatile.Register32 // 0x24
	PMCTRL volatile.Register32 // 0x28
	PMSRC  volatile.Register32 // 0x2C
	PMCFG  volatile.Register32 // 0x30
}

// PINT.ISEL: Pin Interrupt Mode register
func (o *PINT_Type) SetISEL_PMODE(value uint32) {
	volatile.StoreUint32(&o.ISEL.Reg, volatile.LoadUint32(&o.ISEL.Reg)&^(0xf)|value)
}
func (o *PINT_Type) GetISEL_PMODE() uint32 {
	return volatile.LoadUint32(&o.ISEL.Reg) & 0xf
}

// PINT.IENR: Pin interrupt level or rising edge interrupt enable register
func (o *PINT_Type) SetIENR_ENRL(value uint32) {
	volatile.StoreUint32(&o.IENR.Reg, volatile.LoadUint32(&o.IENR.Reg)&^(0xf)|value)
}
func (o *PINT_Type) GetIENR_ENRL() uint32 {
	return volatile.LoadUint32(&o.IENR.Reg) & 0xf
}

// PINT.SIENR: Pin interrupt level or rising edge interrupt set register
func (o *PINT_Type) SetSIENR_SETENRL(value uint32) {
	volatile.StoreUint32(&o.SIENR.Reg, volatile.LoadUint32(&o.SIENR.Reg)&^(0xf)|value)
}
func (o *PINT_Type) GetSIENR_SETENRL() uint32 {
	return volatile.LoadUint32(&o.SIENR.Reg) & 0xf
}

// PINT.CIENR: Pin interrupt level (rising edge interrupt) clear register
func (o *PINT_Type) SetCIENR_CENRL(value uint32) {
	volatile.StoreUint32(&o.CIENR.Reg, volatile.LoadUint32(&o.CIENR.Reg)&^(0xf)|value)
}
func (o *PINT_Type) GetCIENR_CENRL() uint32 {
	return volatile.LoadUint32(&o.CIENR.Reg) & 0xf
}

// PINT.IENF: Pin interrupt active level or falling edge interrupt enable register
func (o *PINT_Type) SetIENF_ENAF(value uint32) {
	volatile.StoreUint32(&o.IENF.Reg, volatile.LoadUint32(&o.IENF.Reg)&^(0xf)|value)
}
func (o *PINT_Type) GetIENF_ENAF() uint32 {
	return volatile.LoadUint32(&o.IENF.Reg) & 0xf
}

// PINT.SIENF: Pin interrupt active level or falling edge interrupt set register
func (o *PINT_Type) SetSIENF_SETENAF(value uint32) {
	volatile.StoreUint32(&o.SIENF.Reg, volatile.LoadUint32(&o.SIENF.Reg)&^(0xf)|value)
}
func (o *PINT_Type) GetSIENF_SETENAF() uint32 {
	return volatile.LoadUint32(&o.SIENF.Reg) & 0xf
}

// PINT.CIENF: Pin interrupt active level or falling edge interrupt clear register
func (o *PINT_Type) SetCIENF_CENAF(value uint32) {
	volatile.StoreUint32(&o.CIENF.Reg, volatile.LoadUint32(&o.CIENF.Reg)&^(0xf)|value)
}
func (o *PINT_Type) GetCIENF_CENAF() uint32 {
	return volatile.LoadUint32(&o.CIENF.Reg) & 0xf
}

// PINT.RISE: Pin interrupt rising edge register
func (o *PINT_Type) SetRISE_RDET(value uint32) {
	volatile.StoreUint32(&o.RISE.Reg, volatile.LoadUint32(&o.RISE.Reg)&^(0xf)|value)
}
func (o *PINT_Type) GetRISE_RDET() uint32 {
	return volatile.LoadUint32(&o.RISE.Reg) & 0xf
}

// PINT.FALL: Pin interrupt falling edge register
func (o *PINT_Type) SetFALL_FDET(value uint32) {
	volatile.StoreUint32(&o.FALL.Reg, volatile.LoadUint32(&o.FALL.Reg)&^(0xf)|value)
}
func (o *PINT_Type) GetFALL_FDET() uint32 {
	return volatile.LoadUint32(&o.FALL.Reg) & 0xf
}

// PINT.IST: Pin interrupt status register
func (o *PINT_Type) SetIST_PSTAT(value uint32) {
	volatile.StoreUint32(&o.IST.Reg, volatile.LoadUint32(&o.IST.Reg)&^(0xf)|value)
}
func (o *PINT_Type) GetIST_PSTAT() uint32 {
	return volatile.LoadUint32(&o.IST.Reg) & 0xf
}

// PINT.PMCTRL: Pattern match interrupt control register
func (o *PINT_Type) SetPMCTRL_SEL_PMATCH(value uint32) {
	volatile.StoreUint32(&o.PMCTRL.Reg, volatile.LoadUint32(&o.PMCTRL.Reg)&^(0x1)|value)
}
func (o *PINT_Type) GetPMCTRL_SEL_PMATCH() uint32 {
	return volatile.LoadUint32(&o.PMCTRL.Reg) & 0x1
}
func (o *PINT_Type) SetPMCTRL_ENA_RXEV(value uint32) {
	volatile.StoreUint32(&o.PMCTRL.Reg, volatile.LoadUint32(&o.PMCTRL.Reg)&^(0x2)|value<<1)
}
func (o *PINT_Type) GetPMCTRL_ENA_RXEV() uint32 {
	return (volatile.LoadUint32(&o.PMCTRL.Reg) & 0x2) >> 1
}
func (o *PINT_Type) SetPMCTRL_PMAT(value uint32) {
	volatile.StoreUint32(&o.PMCTRL.Reg, volatile.LoadUint32(&o.PMCTRL.Reg)&^(0xff000000)|value<<24)
}
func (o *PINT_Type) GetPMCTRL_PMAT() uint32 {
	return (volatile.LoadUint32(&o.PMCTRL.Reg) & 0xff000000) >> 24
}

// PINT.PMSRC: Pattern match interrupt bit-slice source register
func (o *PINT_Type) SetPMSRC_SRC0(value uint32) {
	volatile.StoreUint32(&o.PMSRC.Reg, volatile.LoadUint32(&o.PMSRC.Reg)&^(0x700)|value<<8)
}
func (o *PINT_Type) GetPMSRC_SRC0() uint32 {
	return (volatile.LoadUint32(&o.PMSRC.Reg) & 0x700) >> 8
}
func (o *PINT_Type) SetPMSRC_SRC1(value uint32) {
	volatile.StoreUint32(&o.PMSRC.Reg, volatile.LoadUint32(&o.PMSRC.Reg)&^(0x3800)|value<<11)
}
func (o *PINT_Type) GetPMSRC_SRC1() uint32 {
	return (volatile.LoadUint32(&o.PMSRC.Reg) & 0x3800) >> 11
}
func (o *PINT_Type) SetPMSRC_SRC2(value uint32) {
	volatile.StoreUint32(&o.PMSRC.Reg, volatile.LoadUint32(&o.PMSRC.Reg)&^(0x1c000)|value<<14)
}
func (o *PINT_Type) GetPMSRC_SRC2() uint32 {
	return (volatile.LoadUint32(&o.PMSRC.Reg) & 0x1c000) >> 14
}
func (o *PINT_Type) SetPMSRC_SRC3(value uint32) {
	volatile.StoreUint32(&o.PMSRC.Reg, volatile.LoadUint32(&o.PMSRC.Reg)&^(0xe0000)|value<<17)
}
func (o *PINT_Type) GetPMSRC_SRC3() uint32 {
	return (volatile.LoadUint32(&o.PMSRC.Reg) & 0xe0000) >> 17
}
func (o *PINT_Type) SetPMSRC_SRC4(value uint32) {
	volatile.StoreUint32(&o.PMSRC.Reg, volatile.LoadUint32(&o.PMSRC.Reg)&^(0x700000)|value<<20)
}
func (o *PINT_Type) GetPMSRC_SRC4() uint32 {
	return (volatile.LoadUint32(&o.PMSRC.Reg) & 0x700000) >> 20
}
func (o *PINT_Type) SetPMSRC_SRC5(value uint32) {
	volatile.StoreUint32(&o.PMSRC.Reg, volatile.LoadUint32(&o.PMSRC.Reg)&^(0x3800000)|value<<23)
}
func (o *PINT_Type) GetPMSRC_SRC5() uint32 {
	return (volatile.LoadUint32(&o.PMSRC.Reg) & 0x3800000) >> 23
}
func (o *PINT_Type) SetPMSRC_SRC6(value uint32) {
	volatile.StoreUint32(&o.PMSRC.Reg, volatile.LoadUint32(&o.PMSRC.Reg)&^(0x1c000000)|value<<26)
}
func (o *PINT_Type) GetPMSRC_SRC6() uint32 {
	return (volatile.LoadUint32(&o.PMSRC.Reg) & 0x1c000000) >> 26
}
func (o *PINT_Type) SetPMSRC_SRC7(value uint32) {
	volatile.StoreUint32(&o.PMSRC.Reg, volatile.LoadUint32(&o.PMSRC.Reg)&^(0xe0000000)|value<<29)
}
func (o *PINT_Type) GetPMSRC_SRC7() uint32 {
	return (volatile.LoadUint32(&o.PMSRC.Reg) & 0xe0000000) >> 29
}

// PINT.PMCFG: Pattern match interrupt bit slice configuration register
func (o *PINT_Type) SetPMCFG_PROD_ENDPTS0(value uint32) {
	volatile.StoreUint32(&o.PMCFG.Reg, volatile.LoadUint32(&o.PMCFG.Reg)&^(0x1)|value)
}
func (o *PINT_Type) GetPMCFG_PROD_ENDPTS0() uint32 {
	return volatile.LoadUint32(&o.PMCFG.Reg) & 0x1
}
func (o *PINT_Type) SetPMCFG_PROD_ENDPTS1(value uint32) {
	volatile.StoreUint32(&o.PMCFG.Reg, volatile.LoadUint32(&o.PMCFG.Reg)&^(0x2)|value<<1)
}
func (o *PINT_Type) GetPMCFG_PROD_ENDPTS1() uint32 {
	return (volatile.LoadUint32(&o.PMCFG.Reg) & 0x2) >> 1
}
func (o *PINT_Type) SetPMCFG_PROD_ENDPTS2(value uint32) {
	volatile.StoreUint32(&o.PMCFG.Reg, volatile.LoadUint32(&o.PMCFG.Reg)&^(0x4)|value<<2)
}
func (o *PINT_Type) GetPMCFG_PROD_ENDPTS2() uint32 {
	return (volatile.LoadUint32(&o.PMCFG.Reg) & 0x4) >> 2
}
func (o *PINT_Type) SetPMCFG_PROD_ENDPTS3(value uint32) {
	volatile.StoreUint32(&o.PMCFG.Reg, volatile.LoadUint32(&o.PMCFG.Reg)&^(0x8)|value<<3)
}
func (o *PINT_Type) GetPMCFG_PROD_ENDPTS3() uint32 {
	return (volatile.LoadUint32(&o.PMCFG.Reg) & 0x8) >> 3
}
func (o *PINT_Type) SetPMCFG_PROD_ENDPTS4(value uint32) {
	volatile.StoreUint32(&o.PMCFG.Reg, volatile.LoadUint32(&o.PMCFG.Reg)&^(0x10)|value<<4)
}
func (o *PINT_Type) GetPMCFG_PROD_ENDPTS4() uint32 {
	return (volatile.LoadUint32(&o.PMCFG.Reg) & 0x10) >> 4
}
func (o *PINT_Type) SetPMCFG_PROD_ENDPTS5(value uint32) {
	volatile.StoreUint32(&o.PMCFG.Reg, volatile.LoadUint32(&o.PMCFG.Reg)&^(0x20)|value<<5)
}
func (o *PINT_Type) GetPMCFG_PROD_ENDPTS5() uint32 {
	return (volatile.LoadUint32(&o.PMCFG.Reg) & 0x20) >> 5
}
func (o *PINT_Type) SetPMCFG_PROD_ENDPTS6(value uint32) {
	volatile.StoreUint32(&o.PMCFG.Reg, volatile.LoadUint32(&o.PMCFG.Reg)&^(0x40)|value<<6)
}
func (o *PINT_Type) GetPMCFG_PROD_ENDPTS6() uint32 {
	return (volatile.LoadUint32(&o.PMCFG.Reg) & 0x40) >> 6
}
func (o *PINT_Type) SetPMCFG_CFG0(value uint32) {
	volatile.StoreUint32(&o.PMCFG.Reg, volatile.LoadUint32(&o.PMCFG.Reg)&^(0x700)|value<<8)
}
func (o *PINT_Type) GetPMCFG_CFG0() uint32 {
	return (volatile.LoadUint32(&o.PMCFG.Reg) & 0x700) >> 8
}
func (o *PINT_Type) SetPMCFG_CFG1(value uint32) {
	volatile.StoreUint32(&o.PMCFG.Reg, volatile.LoadUint32(&o.PMCFG.Reg)&^(0x3800)|value<<11)
}
func (o *PINT_Type) GetPMCFG_CFG1() uint32 {
	return (volatile.LoadUint32(&o.PMCFG.Reg) & 0x3800) >> 11
}
func (o *PINT_Type) SetPMCFG_CFG2(value uint32) {
	volatile.StoreUint32(&o.PMCFG.Reg, volatile.LoadUint32(&o.PMCFG.Reg)&^(0x1c000)|value<<14)
}
func (o *PINT_Type) GetPMCFG_CFG2() uint32 {
	return (volatile.LoadUint32(&o.PMCFG.Reg) & 0x1c000) >> 14
}
func (o *PINT_Type) SetPMCFG_CFG3(value uint32) {
	volatile.StoreUint32(&o.PMCFG.Reg, volatile.LoadUint32(&o.PMCFG.Reg)&^(0xe0000)|value<<17)
}
func (o *PINT_Type) GetPMCFG_CFG3() uint32 {
	return (volatile.LoadUint32(&o.PMCFG.Reg) & 0xe0000) >> 17
}
func (o *PINT_Type) SetPMCFG_CFG4(value uint32) {
	volatile.StoreUint32(&o.PMCFG.Reg, volatile.LoadUint32(&o.PMCFG.Reg)&^(0x700000)|value<<20)
}
func (o *PINT_Type) GetPMCFG_CFG4() uint32 {
	return (volatile.LoadUint32(&o.PMCFG.Reg) & 0x700000) >> 20
}
func (o *PINT_Type) SetPMCFG_CFG5(value uint32) {
	volatile.StoreUint32(&o.PMCFG.Reg, volatile.LoadUint32(&o.PMCFG.Reg)&^(0x3800000)|value<<23)
}
func (o *PINT_Type) GetPMCFG_CFG5() uint32 {
	return (volatile.LoadUint32(&o.PMCFG.Reg) & 0x3800000) >> 23
}
func (o *PINT_Type) SetPMCFG_CFG6(value uint32) {
	volatile.StoreUint32(&o.PMCFG.Reg, volatile.LoadUint32(&o.PMCFG.Reg)&^(0x1c000000)|value<<26)
}
func (o *PINT_Type) GetPMCFG_CFG6() uint32 {
	return (volatile.LoadUint32(&o.PMCFG.Reg) & 0x1c000000) >> 26
}
func (o *PINT_Type) SetPMCFG_CFG7(value uint32) {
	volatile.StoreUint32(&o.PMCFG.Reg, volatile.LoadUint32(&o.PMCFG.Reg)&^(0xe0000000)|value<<29)
}
func (o *PINT_Type) GetPMCFG_CFG7() uint32 {
	return (volatile.LoadUint32(&o.PMCFG.Reg) & 0xe0000000) >> 29
}

// dmamux
type INPUTMUX_Type struct {
	PINTSEL         [4]volatile.Register32 // 0x0
	_               [496]byte
	DMA_ITRIG_INMUX [20]volatile.Register32 // 0x200
	_               [1456]byte
	DMA_OTRIG_INMUX [4]volatile.Register32 // 0x800
}

// INPUTMUX.PINTSEL: Pin interrupt select register
func (o *INPUTMUX_Type) SetPINTSEL_INTPIN(idx int, value uint32) {
	volatile.StoreUint32(&o.PINTSEL[idx].Reg, volatile.LoadUint32(&o.PINTSEL[idx].Reg)&^(0x1f)|value)
}
func (o *INPUTMUX_Type) GetPINTSEL_INTPIN(idx int) uint32 {
	return volatile.LoadUint32(&o.PINTSEL[idx].Reg) & 0x1f
}

// INPUTMUX.DMA_ITRIG_INMUX: Trigger select register for DMA channel
func (o *INPUTMUX_Type) SetDMA_ITRIG_INMUX_INP(idx int, value uint32) {
	volatile.StoreUint32(&o.DMA_ITRIG_INMUX[idx].Reg, volatile.LoadUint32(&o.DMA_ITRIG_INMUX[idx].Reg)&^(0x1f)|value)
}
func (o *INPUTMUX_Type) GetDMA_ITRIG_INMUX_INP(idx int) uint32 {
	return volatile.LoadUint32(&o.DMA_ITRIG_INMUX[idx].Reg) & 0x1f
}

// INPUTMUX.DMA_OTRIG_INMUX: DMA output trigger selection to become DMA trigger
func (o *INPUTMUX_Type) SetDMA_OTRIG_INMUX_INP(idx int, value uint32) {
	volatile.StoreUint32(&o.DMA_OTRIG_INMUX[idx].Reg, volatile.LoadUint32(&o.DMA_OTRIG_INMUX[idx].Reg)&^(0x1f)|value)
}
func (o *INPUTMUX_Type) GetDMA_OTRIG_INMUX_INP(idx int) uint32 {
	return volatile.LoadUint32(&o.DMA_OTRIG_INMUX[idx].Reg) & 0x1f
}

// adc
type ADC_Type struct {
	CTRL     volatile.Register32 // 0x0
	CH_SEL   volatile.Register32 // 0x4
	CH_CFG   volatile.Register32 // 0x8
	WCMP_THR volatile.Register32 // 0xC
	INTEN    volatile.Register32 // 0x10
	INT      volatile.Register32 // 0x14
	DATA     volatile.Register32 // 0x18
	_        [4]byte
	CFG      [2]volatile.Register32 // 0x20
	BG_BF    volatile.Register32    // 0x28
	ANA_CTRL volatile.Register32    // 0x2C
}

// ADC.CTRL: ADC control register
func (o *ADC_Type) SetCTRL_ENABLE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x1)|value)
}
func (o *ADC_Type) GetCTRL_ENABLE() uint32 {
	return volatile.LoadUint32(&o.CTRL.Reg) & 0x1
}
func (o *ADC_Type) SetCTRL_CONV_MODE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x2)|value<<1)
}
func (o *ADC_Type) GetCTRL_CONV_MODE() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x2) >> 1
}
func (o *ADC_Type) SetCTRL_SCAN_EN(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x4)|value<<2)
}
func (o *ADC_Type) GetCTRL_SCAN_EN() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x4) >> 2
}
func (o *ADC_Type) SetCTRL_WCMP_EN(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x8)|value<<3)
}
func (o *ADC_Type) GetCTRL_WCMP_EN() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x8) >> 3
}
func (o *ADC_Type) SetCTRL_SW_START(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x80)|value<<7)
}
func (o *ADC_Type) GetCTRL_SW_START() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x80) >> 7
}
func (o *ADC_Type) SetCTRL_CLKSEL(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x1f00)|value<<8)
}
func (o *ADC_Type) GetCTRL_CLKSEL() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x1f00) >> 8
}
func (o *ADC_Type) SetCTRL_SIG_INV_EN(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x2000)|value<<13)
}
func (o *ADC_Type) GetCTRL_SIG_INV_EN() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x2000) >> 13
}
func (o *ADC_Type) SetCTRL_VREF_SEL(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0xc000)|value<<14)
}
func (o *ADC_Type) GetCTRL_VREF_SEL() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0xc000) >> 14
}
func (o *ADC_Type) SetCTRL_CH_IDX_EN(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x40000)|value<<18)
}
func (o *ADC_Type) GetCTRL_CH_IDX_EN() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x40000) >> 18
}
func (o *ADC_Type) SetCTRL_DATA_FORMAT(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x80000)|value<<19)
}
func (o *ADC_Type) GetCTRL_DATA_FORMAT() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x80000) >> 19
}
func (o *ADC_Type) SetCTRL_VREFO_EN(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x100000)|value<<20)
}
func (o *ADC_Type) GetCTRL_VREFO_EN() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x100000) >> 20
}
func (o *ADC_Type) SetCTRL_SRST_DIS(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x200000)|value<<21)
}
func (o *ADC_Type) GetCTRL_SRST_DIS() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x200000) >> 21
}
func (o *ADC_Type) SetCTRL_TRIGGER(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x1f800000)|value<<23)
}
func (o *ADC_Type) GetCTRL_TRIGGER() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x1f800000) >> 23
}

// ADC.CH_SEL: ADC channel selection register
func (o *ADC_Type) SetCH_SEL(value uint32) {
	volatile.StoreUint32(&o.CH_SEL.Reg, value)
}
func (o *ADC_Type) GetCH_SEL() uint32 {
	return volatile.LoadUint32(&o.CH_SEL.Reg)
}

// ADC.CH_CFG: ADC channel configuration register
func (o *ADC_Type) SetCH_CFG(value uint32) {
	volatile.StoreUint32(&o.CH_CFG.Reg, value)
}
func (o *ADC_Type) GetCH_CFG() uint32 {
	return volatile.LoadUint32(&o.CH_CFG.Reg)
}

// ADC.WCMP_THR: Window compare threshold register
func (o *ADC_Type) SetWCMP_THR_WCMP_THR_LOW(value uint32) {
	volatile.StoreUint32(&o.WCMP_THR.Reg, volatile.LoadUint32(&o.WCMP_THR.Reg)&^(0xffff)|value)
}
func (o *ADC_Type) GetWCMP_THR_WCMP_THR_LOW() uint32 {
	return volatile.LoadUint32(&o.WCMP_THR.Reg) & 0xffff
}
func (o *ADC_Type) SetWCMP_THR_WCMP_THR_HIGH(value uint32) {
	volatile.StoreUint32(&o.WCMP_THR.Reg, volatile.LoadUint32(&o.WCMP_THR.Reg)&^(0xffff0000)|value<<16)
}
func (o *ADC_Type) GetWCMP_THR_WCMP_THR_HIGH() uint32 {
	return (volatile.LoadUint32(&o.WCMP_THR.Reg) & 0xffff0000) >> 16
}

// ADC.INTEN: ADC interrupt enable register
func (o *ADC_Type) SetINTEN_DAT_RDY_INTEN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x1)|value)
}
func (o *ADC_Type) GetINTEN_DAT_RDY_INTEN() uint32 {
	return volatile.LoadUint32(&o.INTEN.Reg) & 0x1
}
func (o *ADC_Type) SetINTEN_WCMP_INTEN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x2)|value<<1)
}
func (o *ADC_Type) GetINTEN_WCMP_INTEN() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x2) >> 1
}
func (o *ADC_Type) SetINTEN_FIFO_OF_INTEN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x4)|value<<2)
}
func (o *ADC_Type) GetINTEN_FIFO_OF_INTEN() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x4) >> 2
}
func (o *ADC_Type) SetINTEN_ADC_INTEN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x80000000)|value<<31)
}
func (o *ADC_Type) GetINTEN_ADC_INTEN() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x80000000) >> 31
}

// ADC.INT: ADC interrupt status register
func (o *ADC_Type) SetINT_DAT_RDY_INT(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x1)|value)
}
func (o *ADC_Type) GetINT_DAT_RDY_INT() uint32 {
	return volatile.LoadUint32(&o.INT.Reg) & 0x1
}
func (o *ADC_Type) SetINT_WCMP_INT(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x2)|value<<1)
}
func (o *ADC_Type) GetINT_WCMP_INT() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x2) >> 1
}
func (o *ADC_Type) SetINT_FIFO_OF_INT(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x4)|value<<2)
}
func (o *ADC_Type) GetINT_FIFO_OF_INT() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x4) >> 2
}
func (o *ADC_Type) SetINT_ADC_INT(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x80000000)|value<<31)
}
func (o *ADC_Type) GetINT_ADC_INT() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x80000000) >> 31
}

// ADC.DATA: ADC converted data output
func (o *ADC_Type) SetDATA(value uint32) {
	volatile.StoreUint32(&o.DATA.Reg, value)
}
func (o *ADC_Type) GetDATA() uint32 {
	return volatile.LoadUint32(&o.DATA.Reg)
}

// ADC.CFG: ADC configuration register
func (o *ADC_Type) SetCFG_PGA_GAIN(idx int, value uint32) {
	volatile.StoreUint32(&o.CFG[idx].Reg, volatile.LoadUint32(&o.CFG[idx].Reg)&^(0x7)|value)
}
func (o *ADC_Type) GetCFG_PGA_GAIN(idx int) uint32 {
	return volatile.LoadUint32(&o.CFG[idx].Reg) & 0x7
}
func (o *ADC_Type) SetCFG_PGA_BP(idx int, value uint32) {
	volatile.StoreUint32(&o.CFG[idx].Reg, volatile.LoadUint32(&o.CFG[idx].Reg)&^(0x8)|value<<3)
}
func (o *ADC_Type) GetCFG_PGA_BP(idx int) uint32 {
	return (volatile.LoadUint32(&o.CFG[idx].Reg) & 0x8) >> 3
}
func (o *ADC_Type) SetCFG_PGA_VINN(idx int, value uint32) {
	volatile.StoreUint32(&o.CFG[idx].Reg, volatile.LoadUint32(&o.CFG[idx].Reg)&^(0x30)|value<<4)
}
func (o *ADC_Type) GetCFG_PGA_VINN(idx int) uint32 {
	return (volatile.LoadUint32(&o.CFG[idx].Reg) & 0x30) >> 4
}
func (o *ADC_Type) SetCFG_ADC_GAIN(idx int, value uint32) {
	volatile.StoreUint32(&o.CFG[idx].Reg, volatile.LoadUint32(&o.CFG[idx].Reg)&^(0xc0)|value<<6)
}
func (o *ADC_Type) GetCFG_ADC_GAIN(idx int) uint32 {
	return (volatile.LoadUint32(&o.CFG[idx].Reg) & 0xc0) >> 6
}
func (o *ADC_Type) SetCFG_VREF_GAIN(idx int, value uint32) {
	volatile.StoreUint32(&o.CFG[idx].Reg, volatile.LoadUint32(&o.CFG[idx].Reg)&^(0x100)|value<<8)
}
func (o *ADC_Type) GetCFG_VREF_GAIN(idx int) uint32 {
	return (volatile.LoadUint32(&o.CFG[idx].Reg) & 0x100) >> 8
}
func (o *ADC_Type) SetCFG_ADC_VCM(idx int, value uint32) {
	volatile.StoreUint32(&o.CFG[idx].Reg, volatile.LoadUint32(&o.CFG[idx].Reg)&^(0xe00)|value<<9)
}
func (o *ADC_Type) GetCFG_ADC_VCM(idx int) uint32 {
	return (volatile.LoadUint32(&o.CFG[idx].Reg) & 0xe00) >> 9
}
func (o *ADC_Type) SetCFG_PGA_VCM_EN(idx int, value uint32) {
	volatile.StoreUint32(&o.CFG[idx].Reg, volatile.LoadUint32(&o.CFG[idx].Reg)&^(0x1000)|value<<12)
}
func (o *ADC_Type) GetCFG_PGA_VCM_EN(idx int) uint32 {
	return (volatile.LoadUint32(&o.CFG[idx].Reg) & 0x1000) >> 12
}
func (o *ADC_Type) SetCFG_PGA_VCM_DIR(idx int, value uint32) {
	volatile.StoreUint32(&o.CFG[idx].Reg, volatile.LoadUint32(&o.CFG[idx].Reg)&^(0x2000)|value<<13)
}
func (o *ADC_Type) GetCFG_PGA_VCM_DIR(idx int) uint32 {
	return (volatile.LoadUint32(&o.CFG[idx].Reg) & 0x2000) >> 13
}
func (o *ADC_Type) SetCFG_PGA_VCM(idx int, value uint32) {
	volatile.StoreUint32(&o.CFG[idx].Reg, volatile.LoadUint32(&o.CFG[idx].Reg)&^(0xfc000)|value<<14)
}
func (o *ADC_Type) GetCFG_PGA_VCM(idx int) uint32 {
	return (volatile.LoadUint32(&o.CFG[idx].Reg) & 0xfc000) >> 14
}
func (o *ADC_Type) SetCFG_DOWN_SAMPLE_RATE(idx int, value uint32) {
	volatile.StoreUint32(&o.CFG[idx].Reg, volatile.LoadUint32(&o.CFG[idx].Reg)&^(0x700000)|value<<20)
}
func (o *ADC_Type) GetCFG_DOWN_SAMPLE_RATE(idx int) uint32 {
	return (volatile.LoadUint32(&o.CFG[idx].Reg) & 0x700000) >> 20
}
func (o *ADC_Type) SetCFG_DS_DATA_STABLE(idx int, value uint32) {
	volatile.StoreUint32(&o.CFG[idx].Reg, volatile.LoadUint32(&o.CFG[idx].Reg)&^(0x1f800000)|value<<23)
}
func (o *ADC_Type) GetCFG_DS_DATA_STABLE(idx int) uint32 {
	return (volatile.LoadUint32(&o.CFG[idx].Reg) & 0x1f800000) >> 23
}
func (o *ADC_Type) SetCFG_SCAN_INTV(idx int, value uint32) {
	volatile.StoreUint32(&o.CFG[idx].Reg, volatile.LoadUint32(&o.CFG[idx].Reg)&^(0xe0000000)|value<<29)
}
func (o *ADC_Type) GetCFG_SCAN_INTV(idx int) uint32 {
	return (volatile.LoadUint32(&o.CFG[idx].Reg) & 0xe0000000) >> 29
}

// ADC.BG_BF: ADC bandcap and buffer setting register
func (o *ADC_Type) SetBG_BF_PGA_BM(value uint32) {
	volatile.StoreUint32(&o.BG_BF.Reg, volatile.LoadUint32(&o.BG_BF.Reg)&^(0x7)|value)
}
func (o *ADC_Type) GetBG_BF_PGA_BM() uint32 {
	return volatile.LoadUint32(&o.BG_BF.Reg) & 0x7
}
func (o *ADC_Type) SetBG_BF_BG_SEL(value uint32) {
	volatile.StoreUint32(&o.BG_BF.Reg, volatile.LoadUint32(&o.BG_BF.Reg)&^(0xf0)|value<<4)
}
func (o *ADC_Type) GetBG_BF_BG_SEL() uint32 {
	return (volatile.LoadUint32(&o.BG_BF.Reg) & 0xf0) >> 4
}
func (o *ADC_Type) SetBG_BF_TEMP_EN(value uint32) {
	volatile.StoreUint32(&o.BG_BF.Reg, volatile.LoadUint32(&o.BG_BF.Reg)&^(0x1000)|value<<12)
}
func (o *ADC_Type) GetBG_BF_TEMP_EN() uint32 {
	return (volatile.LoadUint32(&o.BG_BF.Reg) & 0x1000) >> 12
}
func (o *ADC_Type) SetBG_BF_PGA_CHOP_EN(value uint32) {
	volatile.StoreUint32(&o.BG_BF.Reg, volatile.LoadUint32(&o.BG_BF.Reg)&^(0x2000)|value<<13)
}
func (o *ADC_Type) GetBG_BF_PGA_CHOP_EN() uint32 {
	return (volatile.LoadUint32(&o.BG_BF.Reg) & 0x2000) >> 13
}
func (o *ADC_Type) SetBG_BF_PGA_BM_DIV2(value uint32) {
	volatile.StoreUint32(&o.BG_BF.Reg, volatile.LoadUint32(&o.BG_BF.Reg)&^(0x4000)|value<<14)
}
func (o *ADC_Type) GetBG_BF_PGA_BM_DIV2() uint32 {
	return (volatile.LoadUint32(&o.BG_BF.Reg) & 0x4000) >> 14
}

// ADC.ANA_CTRL: ADC core and reference setting regsiter
func (o *ADC_Type) SetANA_CTRL_ADC_BM(value uint32) {
	volatile.StoreUint32(&o.ANA_CTRL.Reg, volatile.LoadUint32(&o.ANA_CTRL.Reg)&^(0x7)|value)
}
func (o *ADC_Type) GetANA_CTRL_ADC_BM() uint32 {
	return volatile.LoadUint32(&o.ANA_CTRL.Reg) & 0x7
}
func (o *ADC_Type) SetANA_CTRL_ADC_ORDER(value uint32) {
	volatile.StoreUint32(&o.ANA_CTRL.Reg, volatile.LoadUint32(&o.ANA_CTRL.Reg)&^(0x10)|value<<4)
}
func (o *ADC_Type) GetANA_CTRL_ADC_ORDER() uint32 {
	return (volatile.LoadUint32(&o.ANA_CTRL.Reg) & 0x10) >> 4
}
func (o *ADC_Type) SetANA_CTRL_DITHER_EN(value uint32) {
	volatile.StoreUint32(&o.ANA_CTRL.Reg, volatile.LoadUint32(&o.ANA_CTRL.Reg)&^(0x20)|value<<5)
}
func (o *ADC_Type) GetANA_CTRL_DITHER_EN() uint32 {
	return (volatile.LoadUint32(&o.ANA_CTRL.Reg) & 0x20) >> 5
}
func (o *ADC_Type) SetANA_CTRL_CHOP_EN(value uint32) {
	volatile.StoreUint32(&o.ANA_CTRL.Reg, volatile.LoadUint32(&o.ANA_CTRL.Reg)&^(0x40)|value<<6)
}
func (o *ADC_Type) GetANA_CTRL_CHOP_EN() uint32 {
	return (volatile.LoadUint32(&o.ANA_CTRL.Reg) & 0x40) >> 6
}
func (o *ADC_Type) SetANA_CTRL_INV_CLK(value uint32) {
	volatile.StoreUint32(&o.ANA_CTRL.Reg, volatile.LoadUint32(&o.ANA_CTRL.Reg)&^(0x80)|value<<7)
}
func (o *ADC_Type) GetANA_CTRL_INV_CLK() uint32 {
	return (volatile.LoadUint32(&o.ANA_CTRL.Reg) & 0x80) >> 7
}
func (o *ADC_Type) SetANA_CTRL_VREF_BM(value uint32) {
	volatile.StoreUint32(&o.ANA_CTRL.Reg, volatile.LoadUint32(&o.ANA_CTRL.Reg)&^(0x700)|value<<8)
}
func (o *ADC_Type) GetANA_CTRL_VREF_BM() uint32 {
	return (volatile.LoadUint32(&o.ANA_CTRL.Reg) & 0x700) >> 8
}
func (o *ADC_Type) SetANA_CTRL_VREF_BM_X3(value uint32) {
	volatile.StoreUint32(&o.ANA_CTRL.Reg, volatile.LoadUint32(&o.ANA_CTRL.Reg)&^(0x800)|value<<11)
}
func (o *ADC_Type) GetANA_CTRL_VREF_BM_X3() uint32 {
	return (volatile.LoadUint32(&o.ANA_CTRL.Reg) & 0x800) >> 11
}
func (o *ADC_Type) SetANA_CTRL_VINN_IN_BM(value uint32) {
	volatile.StoreUint32(&o.ANA_CTRL.Reg, volatile.LoadUint32(&o.ANA_CTRL.Reg)&^(0x7000)|value<<12)
}
func (o *ADC_Type) GetANA_CTRL_VINN_IN_BM() uint32 {
	return (volatile.LoadUint32(&o.ANA_CTRL.Reg) & 0x7000) >> 12
}
func (o *ADC_Type) SetANA_CTRL_VINN_OUT_BM(value uint32) {
	volatile.StoreUint32(&o.ANA_CTRL.Reg, volatile.LoadUint32(&o.ANA_CTRL.Reg)&^(0x70000)|value<<16)
}
func (o *ADC_Type) GetANA_CTRL_VINN_OUT_BM() uint32 {
	return (volatile.LoadUint32(&o.ANA_CTRL.Reg) & 0x70000) >> 16
}
func (o *ADC_Type) SetANA_CTRL_VINN_OUT_BM_X3(value uint32) {
	volatile.StoreUint32(&o.ANA_CTRL.Reg, volatile.LoadUint32(&o.ANA_CTRL.Reg)&^(0x80000)|value<<19)
}
func (o *ADC_Type) GetANA_CTRL_VINN_OUT_BM_X3() uint32 {
	return (volatile.LoadUint32(&o.ANA_CTRL.Reg) & 0x80000) >> 19
}
func (o *ADC_Type) SetANA_CTRL_ADC_BM_DIV2(value uint32) {
	volatile.StoreUint32(&o.ANA_CTRL.Reg, volatile.LoadUint32(&o.ANA_CTRL.Reg)&^(0x100000)|value<<20)
}
func (o *ADC_Type) GetANA_CTRL_ADC_BM_DIV2() uint32 {
	return (volatile.LoadUint32(&o.ANA_CTRL.Reg) & 0x100000) >> 20
}

// dac
type DAC_Type struct {
	ANA_CFG   volatile.Register32 // 0x0
	CTRL      volatile.Register32 // 0x4
	SIN_CFG0  volatile.Register32 // 0x8
	SIN_CFG1  volatile.Register32 // 0xC
	GAIN_CTRL volatile.Register32 // 0x10
	CLR_TRG   volatile.Register32 // 0x14
	DIN       volatile.Register32 // 0x18
	INT       volatile.Register32 // 0x1C
	INTEN     volatile.Register32 // 0x20
	INT_STAT  volatile.Register32 // 0x24
	STATUS    volatile.Register32 // 0x28
}

// DAC.ANA_CFG: reserved
func (o *DAC_Type) SetANA_CFG_FILTER_BM(value uint32) {
	volatile.StoreUint32(&o.ANA_CFG.Reg, volatile.LoadUint32(&o.ANA_CFG.Reg)&^(0x7)|value)
}
func (o *DAC_Type) GetANA_CFG_FILTER_BM() uint32 {
	return volatile.LoadUint32(&o.ANA_CFG.Reg) & 0x7
}
func (o *DAC_Type) SetANA_CFG_DAC_AMP(value uint32) {
	volatile.StoreUint32(&o.ANA_CFG.Reg, volatile.LoadUint32(&o.ANA_CFG.Reg)&^(0x70)|value<<4)
}
func (o *DAC_Type) GetANA_CFG_DAC_AMP() uint32 {
	return (volatile.LoadUint32(&o.ANA_CFG.Reg) & 0x70) >> 4
}
func (o *DAC_Type) SetANA_CFG_FILTER_BW(value uint32) {
	volatile.StoreUint32(&o.ANA_CFG.Reg, volatile.LoadUint32(&o.ANA_CFG.Reg)&^(0x300)|value<<8)
}
func (o *DAC_Type) GetANA_CFG_FILTER_BW() uint32 {
	return (volatile.LoadUint32(&o.ANA_CFG.Reg) & 0x300) >> 8
}
func (o *DAC_Type) SetANA_CFG_FILTER_150K_EN(value uint32) {
	volatile.StoreUint32(&o.ANA_CFG.Reg, volatile.LoadUint32(&o.ANA_CFG.Reg)&^(0x1000)|value<<12)
}
func (o *DAC_Type) GetANA_CFG_FILTER_150K_EN() uint32 {
	return (volatile.LoadUint32(&o.ANA_CFG.Reg) & 0x1000) >> 12
}
func (o *DAC_Type) SetANA_CFG_VCM(value uint32) {
	volatile.StoreUint32(&o.ANA_CFG.Reg, volatile.LoadUint32(&o.ANA_CFG.Reg)&^(0xf0000)|value<<16)
}
func (o *DAC_Type) GetANA_CFG_VCM() uint32 {
	return (volatile.LoadUint32(&o.ANA_CFG.Reg) & 0xf0000) >> 16
}

// DAC.CTRL: DAC clock invert
func (o *DAC_Type) SetCTRL_ENABLE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x1)|value)
}
func (o *DAC_Type) GetCTRL_ENABLE() uint32 {
	return volatile.LoadUint32(&o.CTRL.Reg) & 0x1
}
func (o *DAC_Type) SetCTRL_SIN_EN(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x2)|value<<1)
}
func (o *DAC_Type) GetCTRL_SIN_EN() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x2) >> 1
}
func (o *DAC_Type) SetCTRL_MOD_EN(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x4)|value<<2)
}
func (o *DAC_Type) GetCTRL_MOD_EN() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x4) >> 2
}
func (o *DAC_Type) SetCTRL_MOD_WD(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x8)|value<<3)
}
func (o *DAC_Type) GetCTRL_MOD_WD() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x8) >> 3
}
func (o *DAC_Type) SetCTRL_SMPL_RATE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x70)|value<<4)
}
func (o *DAC_Type) GetCTRL_SMPL_RATE() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x70) >> 4
}
func (o *DAC_Type) SetCTRL_SGN_INV(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x80)|value<<7)
}
func (o *DAC_Type) GetCTRL_SGN_INV() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x80) >> 7
}
func (o *DAC_Type) SetCTRL_BUF_IN_ALGN(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x100)|value<<8)
}
func (o *DAC_Type) GetCTRL_BUF_IN_ALGN() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x100) >> 8
}
func (o *DAC_Type) SetCTRL_BUF_OUT_ALGN(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x200)|value<<9)
}
func (o *DAC_Type) GetCTRL_BUF_OUT_ALGN() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x200) >> 9
}
func (o *DAC_Type) SetCTRL_TRG_MODE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x400)|value<<10)
}
func (o *DAC_Type) GetCTRL_TRG_MODE() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x400) >> 10
}
func (o *DAC_Type) SetCTRL_TRG_EDGE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x1800)|value<<11)
}
func (o *DAC_Type) GetCTRL_TRG_EDGE() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x1800) >> 11
}
func (o *DAC_Type) SetCTRL_TRG_SEL(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x3f0000)|value<<16)
}
func (o *DAC_Type) GetCTRL_TRG_SEL() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x3f0000) >> 16
}
func (o *DAC_Type) SetCTRL_CLK_DIV(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x7f000000)|value<<24)
}
func (o *DAC_Type) GetCTRL_CLK_DIV() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x7f000000) >> 24
}
func (o *DAC_Type) SetCTRL_CLK_INV(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x80000000)|value<<31)
}
func (o *DAC_Type) GetCTRL_CLK_INV() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x80000000) >> 31
}

// DAC.SIN_CFG0: sin amplitude
func (o *DAC_Type) SetSIN_CFG0_SIN_FREQ(value uint32) {
	volatile.StoreUint32(&o.SIN_CFG0.Reg, volatile.LoadUint32(&o.SIN_CFG0.Reg)&^(0xffff)|value)
}
func (o *DAC_Type) GetSIN_CFG0_SIN_FREQ() uint32 {
	return volatile.LoadUint32(&o.SIN_CFG0.Reg) & 0xffff
}
func (o *DAC_Type) SetSIN_CFG0_SIN_AMP(value uint32) {
	volatile.StoreUint32(&o.SIN_CFG0.Reg, volatile.LoadUint32(&o.SIN_CFG0.Reg)&^(0xffff0000)|value<<16)
}
func (o *DAC_Type) GetSIN_CFG0_SIN_AMP() uint32 {
	return (volatile.LoadUint32(&o.SIN_CFG0.Reg) & 0xffff0000) >> 16
}

// DAC.SIN_CFG1: reserved
func (o *DAC_Type) SetSIN_CFG1_SIN_DC(value uint32) {
	volatile.StoreUint32(&o.SIN_CFG1.Reg, volatile.LoadUint32(&o.SIN_CFG1.Reg)&^(0xfffff)|value)
}
func (o *DAC_Type) GetSIN_CFG1_SIN_DC() uint32 {
	return volatile.LoadUint32(&o.SIN_CFG1.Reg) & 0xfffff
}

// DAC.GAIN_CTRL: reserved
func (o *DAC_Type) SetGAIN_CTRL(value uint32) {
	volatile.StoreUint32(&o.GAIN_CTRL.Reg, volatile.LoadUint32(&o.GAIN_CTRL.Reg)&^(0xff)|value)
}
func (o *DAC_Type) GetGAIN_CTRL() uint32 {
	return volatile.LoadUint32(&o.GAIN_CTRL.Reg) & 0xff
}

// DAC.CLR_TRG: Reserved
func (o *DAC_Type) SetCLR_TRG_BUF_CLR(value uint32) {
	volatile.StoreUint32(&o.CLR_TRG.Reg, volatile.LoadUint32(&o.CLR_TRG.Reg)&^(0x1)|value)
}
func (o *DAC_Type) GetCLR_TRG_BUF_CLR() uint32 {
	return volatile.LoadUint32(&o.CLR_TRG.Reg) & 0x1
}
func (o *DAC_Type) SetCLR_TRG_SW_TRG(value uint32) {
	volatile.StoreUint32(&o.CLR_TRG.Reg, volatile.LoadUint32(&o.CLR_TRG.Reg)&^(0x2)|value<<1)
}
func (o *DAC_Type) GetCLR_TRG_SW_TRG() uint32 {
	return (volatile.LoadUint32(&o.CLR_TRG.Reg) & 0x2) >> 1
}

// DAC.DIN: DAC data input
func (o *DAC_Type) SetDIN(value uint32) {
	volatile.StoreUint32(&o.DIN.Reg, value)
}
func (o *DAC_Type) GetDIN() uint32 {
	return volatile.LoadUint32(&o.DIN.Reg)
}

// DAC.INT: Reserved
func (o *DAC_Type) SetINT_BUF_NFUL_INT(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x1)|value)
}
func (o *DAC_Type) GetINT_BUF_NFUL_INT() uint32 {
	return volatile.LoadUint32(&o.INT.Reg) & 0x1
}
func (o *DAC_Type) SetINT_BUF_FUL_INT(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x2)|value<<1)
}
func (o *DAC_Type) GetINT_BUF_FUL_INT() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x2) >> 1
}
func (o *DAC_Type) SetINT_BUF_EMT_INT(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x4)|value<<2)
}
func (o *DAC_Type) GetINT_BUF_EMT_INT() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x4) >> 2
}
func (o *DAC_Type) SetINT_BUF_HEMT_INT(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x8)|value<<3)
}
func (o *DAC_Type) GetINT_BUF_HEMT_INT() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x8) >> 3
}
func (o *DAC_Type) SetINT_BUF_OV_INT(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x10)|value<<4)
}
func (o *DAC_Type) GetINT_BUF_OV_INT() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x10) >> 4
}
func (o *DAC_Type) SetINT_BUF_UD_INT(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x20)|value<<5)
}
func (o *DAC_Type) GetINT_BUF_UD_INT() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x20) >> 5
}
func (o *DAC_Type) SetINT_BUF_HFUL_INT(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x40)|value<<6)
}
func (o *DAC_Type) GetINT_BUF_HFUL_INT() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x40) >> 6
}

// DAC.INTEN: Reserved
func (o *DAC_Type) SetINTEN_BUF_NFUL_INTEN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x1)|value)
}
func (o *DAC_Type) GetINTEN_BUF_NFUL_INTEN() uint32 {
	return volatile.LoadUint32(&o.INTEN.Reg) & 0x1
}
func (o *DAC_Type) SetINTEN_BUF_FUL_INTEN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x2)|value<<1)
}
func (o *DAC_Type) GetINTEN_BUF_FUL_INTEN() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x2) >> 1
}
func (o *DAC_Type) SetINTEN_BUF_EMT_INTEN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x4)|value<<2)
}
func (o *DAC_Type) GetINTEN_BUF_EMT_INTEN() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x4) >> 2
}
func (o *DAC_Type) SetINTEN_BUF_HEMT_INTEN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x8)|value<<3)
}
func (o *DAC_Type) GetINTEN_BUF_HEMT_INTEN() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x8) >> 3
}
func (o *DAC_Type) SetINTEN_BUF_OV_INTEN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x10)|value<<4)
}
func (o *DAC_Type) GetINTEN_BUF_OV_INTEN() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x10) >> 4
}
func (o *DAC_Type) SetINTEN_BUF_UD_INTEN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x20)|value<<5)
}
func (o *DAC_Type) GetINTEN_BUF_UD_INTEN() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x20) >> 5
}
func (o *DAC_Type) SetINTEN_BUF_HFUL_INTEN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x40)|value<<6)
}
func (o *DAC_Type) GetINTEN_BUF_HFUL_INTEN() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x40) >> 6
}

// DAC.INT_STAT: Reserved
func (o *DAC_Type) SetINT_STAT_BUF_NFUL_INT_STAT(value uint32) {
	volatile.StoreUint32(&o.INT_STAT.Reg, volatile.LoadUint32(&o.INT_STAT.Reg)&^(0x1)|value)
}
func (o *DAC_Type) GetINT_STAT_BUF_NFUL_INT_STAT() uint32 {
	return volatile.LoadUint32(&o.INT_STAT.Reg) & 0x1
}
func (o *DAC_Type) SetINT_STAT_BUF_FUL_INT_STAT(value uint32) {
	volatile.StoreUint32(&o.INT_STAT.Reg, volatile.LoadUint32(&o.INT_STAT.Reg)&^(0x2)|value<<1)
}
func (o *DAC_Type) GetINT_STAT_BUF_FUL_INT_STAT() uint32 {
	return (volatile.LoadUint32(&o.INT_STAT.Reg) & 0x2) >> 1
}
func (o *DAC_Type) SetINT_STAT_BUF_EMT_INT_STAT(value uint32) {
	volatile.StoreUint32(&o.INT_STAT.Reg, volatile.LoadUint32(&o.INT_STAT.Reg)&^(0x4)|value<<2)
}
func (o *DAC_Type) GetINT_STAT_BUF_EMT_INT_STAT() uint32 {
	return (volatile.LoadUint32(&o.INT_STAT.Reg) & 0x4) >> 2
}
func (o *DAC_Type) SetINT_STAT_BUF_HEMT_INT_STAT(value uint32) {
	volatile.StoreUint32(&o.INT_STAT.Reg, volatile.LoadUint32(&o.INT_STAT.Reg)&^(0x8)|value<<3)
}
func (o *DAC_Type) GetINT_STAT_BUF_HEMT_INT_STAT() uint32 {
	return (volatile.LoadUint32(&o.INT_STAT.Reg) & 0x8) >> 3
}
func (o *DAC_Type) SetINT_STAT_BUF_OV_INT_STAT(value uint32) {
	volatile.StoreUint32(&o.INT_STAT.Reg, volatile.LoadUint32(&o.INT_STAT.Reg)&^(0x10)|value<<4)
}
func (o *DAC_Type) GetINT_STAT_BUF_OV_INT_STAT() uint32 {
	return (volatile.LoadUint32(&o.INT_STAT.Reg) & 0x10) >> 4
}
func (o *DAC_Type) SetINT_STAT_BUF_UD_INT_STAT(value uint32) {
	volatile.StoreUint32(&o.INT_STAT.Reg, volatile.LoadUint32(&o.INT_STAT.Reg)&^(0x20)|value<<5)
}
func (o *DAC_Type) GetINT_STAT_BUF_UD_INT_STAT() uint32 {
	return (volatile.LoadUint32(&o.INT_STAT.Reg) & 0x20) >> 5
}
func (o *DAC_Type) SetINT_STAT_BUF_HFUL_INT_STAT(value uint32) {
	volatile.StoreUint32(&o.INT_STAT.Reg, volatile.LoadUint32(&o.INT_STAT.Reg)&^(0x40)|value<<6)
}
func (o *DAC_Type) GetINT_STAT_BUF_HFUL_INT_STAT() uint32 {
	return (volatile.LoadUint32(&o.INT_STAT.Reg) & 0x40) >> 6
}
func (o *DAC_Type) SetINT_STAT_DAC_INT_STAT(value uint32) {
	volatile.StoreUint32(&o.INT_STAT.Reg, volatile.LoadUint32(&o.INT_STAT.Reg)&^(0x10000)|value<<16)
}
func (o *DAC_Type) GetINT_STAT_DAC_INT_STAT() uint32 {
	return (volatile.LoadUint32(&o.INT_STAT.Reg) & 0x10000) >> 16
}

// DAC.STATUS: Reserved
func (o *DAC_Type) SetSTATUS_BUSY(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x1)|value)
}
func (o *DAC_Type) GetSTATUS_BUSY() uint32 {
	return volatile.LoadUint32(&o.STATUS.Reg) & 0x1
}
func (o *DAC_Type) SetSTATUS_BUF_WR_PTR(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x70000)|value<<16)
}
func (o *DAC_Type) GetSTATUS_BUF_WR_PTR() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x70000) >> 16
}
func (o *DAC_Type) SetSTATUS_BUF_RD_PTR(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x700000)|value<<20)
}
func (o *DAC_Type) GetSTATUS_BUF_RD_PTR() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x700000) >> 20
}

// tsc
type CS_Type struct {
	CTRL0       volatile.Register32 // 0x0
	CTRL1       volatile.Register32 // 0x4
	INT         volatile.Register32 // 0x8
	INTEN       volatile.Register32 // 0xC
	DATA        volatile.Register32 // 0x10
	LP_CTRL     volatile.Register32 // 0x14
	LP_INT      volatile.Register32 // 0x18
	LP_INTEN    volatile.Register32 // 0x1C
	IDLE_PERIOD volatile.Register32 // 0x20
}

// CS.CTRL0: CapSense control register 0
func (o *CS_Type) SetCTRL0_ENABLE(value uint32) {
	volatile.StoreUint32(&o.CTRL0.Reg, volatile.LoadUint32(&o.CTRL0.Reg)&^(0x1)|value)
}
func (o *CS_Type) GetCTRL0_ENABLE() uint32 {
	return volatile.LoadUint32(&o.CTRL0.Reg) & 0x1
}
func (o *CS_Type) SetCTRL0_SRST(value uint32) {
	volatile.StoreUint32(&o.CTRL0.Reg, volatile.LoadUint32(&o.CTRL0.Reg)&^(0x2)|value<<1)
}
func (o *CS_Type) GetCTRL0_SRST() uint32 {
	return (volatile.LoadUint32(&o.CTRL0.Reg) & 0x2) >> 1
}
func (o *CS_Type) SetCTRL0_OSC_FREQ(value uint32) {
	volatile.StoreUint32(&o.CTRL0.Reg, volatile.LoadUint32(&o.CTRL0.Reg)&^(0xfc)|value<<2)
}
func (o *CS_Type) GetCTRL0_OSC_FREQ() uint32 {
	return (volatile.LoadUint32(&o.CTRL0.Reg) & 0xfc) >> 2
}
func (o *CS_Type) SetCTRL0_CLK_DIV(value uint32) {
	volatile.StoreUint32(&o.CTRL0.Reg, volatile.LoadUint32(&o.CTRL0.Reg)&^(0x1ff0000)|value<<16)
}
func (o *CS_Type) GetCTRL0_CLK_DIV() uint32 {
	return (volatile.LoadUint32(&o.CTRL0.Reg) & 0x1ff0000) >> 16
}

// CS.CTRL1: CapSense control register 1
func (o *CS_Type) SetCTRL1_PERIOD(value uint32) {
	volatile.StoreUint32(&o.CTRL1.Reg, volatile.LoadUint32(&o.CTRL1.Reg)&^(0xffff)|value)
}
func (o *CS_Type) GetCTRL1_PERIOD() uint32 {
	return volatile.LoadUint32(&o.CTRL1.Reg) & 0xffff
}
func (o *CS_Type) SetCTRL1_CH(value uint32) {
	volatile.StoreUint32(&o.CTRL1.Reg, volatile.LoadUint32(&o.CTRL1.Reg)&^(0xff0000)|value<<16)
}
func (o *CS_Type) GetCTRL1_CH() uint32 {
	return (volatile.LoadUint32(&o.CTRL1.Reg) & 0xff0000) >> 16
}

// CS.INT: Interrupt status register
func (o *CS_Type) SetINT_FIFO_NOTEMPTY_INT(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x1)|value)
}
func (o *CS_Type) GetINT_FIFO_NOTEMPTY_INT() uint32 {
	return volatile.LoadUint32(&o.INT.Reg) & 0x1
}
func (o *CS_Type) SetINT_FIFO_HFULL_INT(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x2)|value<<1)
}
func (o *CS_Type) GetINT_FIFO_HFULL_INT() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x2) >> 1
}
func (o *CS_Type) SetINT_FIFO_FULL_INT(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x4)|value<<2)
}
func (o *CS_Type) GetINT_FIFO_FULL_INT() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x4) >> 2
}
func (o *CS_Type) SetINT_SCAN_INT(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x8)|value<<3)
}
func (o *CS_Type) GetINT_SCAN_INT() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x8) >> 3
}

// CS.INTEN: Interrupt mask register
func (o *CS_Type) SetINTEN_FIFO_NOTEMPTY_INTEN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x1)|value)
}
func (o *CS_Type) GetINTEN_FIFO_NOTEMPTY_INTEN() uint32 {
	return volatile.LoadUint32(&o.INTEN.Reg) & 0x1
}
func (o *CS_Type) SetINTEN_FIFO_HFULL_INTEN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x2)|value<<1)
}
func (o *CS_Type) GetINTEN_FIFO_HFULL_INTEN() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x2) >> 1
}
func (o *CS_Type) SetINTEN_FIFO_FULL_INTEN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x4)|value<<2)
}
func (o *CS_Type) GetINTEN_FIFO_FULL_INTEN() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x4) >> 2
}
func (o *CS_Type) SetINTEN_SCAN_INTEN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x8)|value<<3)
}
func (o *CS_Type) GetINTEN_SCAN_INTEN() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x8) >> 3
}

// CS.DATA: Output data register
func (o *CS_Type) SetDATA(value uint32) {
	volatile.StoreUint32(&o.DATA.Reg, volatile.LoadUint32(&o.DATA.Reg)&^(0x7ffff)|value)
}
func (o *CS_Type) GetDATA() uint32 {
	return volatile.LoadUint32(&o.DATA.Reg) & 0x7ffff
}

// CS.LP_CTRL: Control register for low power mode
func (o *CS_Type) SetLP_CTRL_DEBONCE_NUM(value uint32) {
	volatile.StoreUint32(&o.LP_CTRL.Reg, volatile.LoadUint32(&o.LP_CTRL.Reg)&^(0xf)|value)
}
func (o *CS_Type) GetLP_CTRL_DEBONCE_NUM() uint32 {
	return volatile.LoadUint32(&o.LP_CTRL.Reg) & 0xf
}
func (o *CS_Type) SetLP_CTRL_LP_EN(value uint32) {
	volatile.StoreUint32(&o.LP_CTRL.Reg, volatile.LoadUint32(&o.LP_CTRL.Reg)&^(0x10)|value<<4)
}
func (o *CS_Type) GetLP_CTRL_LP_EN() uint32 {
	return (volatile.LoadUint32(&o.LP_CTRL.Reg) & 0x10) >> 4
}
func (o *CS_Type) SetLP_CTRL_LP_CH(value uint32) {
	volatile.StoreUint32(&o.LP_CTRL.Reg, volatile.LoadUint32(&o.LP_CTRL.Reg)&^(0xe0)|value<<5)
}
func (o *CS_Type) GetLP_CTRL_LP_CH() uint32 {
	return (volatile.LoadUint32(&o.LP_CTRL.Reg) & 0xe0) >> 5
}
func (o *CS_Type) SetLP_CTRL_THR(value uint32) {
	volatile.StoreUint32(&o.LP_CTRL.Reg, volatile.LoadUint32(&o.LP_CTRL.Reg)&^(0xffff0000)|value<<16)
}
func (o *CS_Type) GetLP_CTRL_THR() uint32 {
	return (volatile.LoadUint32(&o.LP_CTRL.Reg) & 0xffff0000) >> 16
}

// CS.LP_INT: Low power interrupt register
func (o *CS_Type) SetLP_INT(value uint32) {
	volatile.StoreUint32(&o.LP_INT.Reg, volatile.LoadUint32(&o.LP_INT.Reg)&^(0x1)|value)
}
func (o *CS_Type) GetLP_INT() uint32 {
	return volatile.LoadUint32(&o.LP_INT.Reg) & 0x1
}

// CS.LP_INTEN: low power interrupt enable register
func (o *CS_Type) SetLP_INTEN(value uint32) {
	volatile.StoreUint32(&o.LP_INTEN.Reg, volatile.LoadUint32(&o.LP_INTEN.Reg)&^(0x1)|value)
}
func (o *CS_Type) GetLP_INTEN() uint32 {
	return volatile.LoadUint32(&o.LP_INTEN.Reg) & 0x1
}

// CS.IDLE_PERIOD: Idle preiod number register
func (o *CS_Type) SetIDLE_PERIOD(value uint32) {
	volatile.StoreUint32(&o.IDLE_PERIOD.Reg, volatile.LoadUint32(&o.IDLE_PERIOD.Reg)&^(0xffff)|value)
}
func (o *CS_Type) GetIDLE_PERIOD() uint32 {
	return volatile.LoadUint32(&o.IDLE_PERIOD.Reg) & 0xffff
}

// rng
type RNG_Type struct {
	CTRL  volatile.Register32 // 0x0
	STAT  volatile.Register32 // 0x4
	DATA  volatile.Register32 // 0x8
	INT   volatile.Register32 // 0xC
	INTEN volatile.Register32 // 0x10
}

// RNG.CTRL: control register
func (o *RNG_Type) SetCTRL_ENABLE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x1)|value)
}
func (o *RNG_Type) GetCTRL_ENABLE() uint32 {
	return volatile.LoadUint32(&o.CTRL.Reg) & 0x1
}
func (o *RNG_Type) SetCTRL_START(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x2)|value<<1)
}
func (o *RNG_Type) GetCTRL_START() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x2) >> 1
}
func (o *RNG_Type) SetCTRL_NUM(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x30)|value<<4)
}
func (o *RNG_Type) GetCTRL_NUM() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x30) >> 4
}

// RNG.STAT: status register
func (o *RNG_Type) SetSTAT_BUSY(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x1)|value)
}
func (o *RNG_Type) GetSTAT_BUSY() uint32 {
	return volatile.LoadUint32(&o.STAT.Reg) & 0x1
}

// RNG.DATA: random data output register
func (o *RNG_Type) SetDATA(value uint32) {
	volatile.StoreUint32(&o.DATA.Reg, value)
}
func (o *RNG_Type) GetDATA() uint32 {
	return volatile.LoadUint32(&o.DATA.Reg)
}

// RNG.INT: interrupt register
func (o *RNG_Type) SetINT_DONE(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x1)|value)
}
func (o *RNG_Type) GetINT_DONE() uint32 {
	return volatile.LoadUint32(&o.INT.Reg) & 0x1
}

// RNG.INTEN: interrupt mask register
func (o *RNG_Type) SetINTEN_DONE_INTEN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x1)|value)
}
func (o *RNG_Type) GetINTEN_DONE_INTEN() uint32 {
	return volatile.LoadUint32(&o.INTEN.Reg) & 0x1
}

// qdec
type QDEC_Type struct {
	CTRL      volatile.Register32 // 0x0
	SAMP_CTRL volatile.Register32 // 0x4
	SAMPLE    volatile.Register32 // 0x8
	ACC       volatile.Register32 // 0xC
	ACC_R     volatile.Register32 // 0x10
	DB        volatile.Register32 // 0x14
	DB_R      volatile.Register32 // 0x18
	INT       volatile.Register32 // 0x1C
	INTEN     volatile.Register32 // 0x20
	STAT      volatile.Register32 // 0x24
}

// QDEC.CTRL: control register
func (o *QDEC_Type) SetCTRL_QDEC_EN(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x1)|value)
}
func (o *QDEC_Type) GetCTRL_QDEC_EN() uint32 {
	return volatile.LoadUint32(&o.CTRL.Reg) & 0x1
}
func (o *QDEC_Type) SetCTRL_START(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x2)|value<<1)
}
func (o *QDEC_Type) GetCTRL_START() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x2) >> 1
}
func (o *QDEC_Type) SetCTRL_STOP(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x4)|value<<2)
}
func (o *QDEC_Type) GetCTRL_STOP() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x4) >> 2
}
func (o *QDEC_Type) SetCTRL_SOFT_CLR(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x8)|value<<3)
}
func (o *QDEC_Type) GetCTRL_SOFT_CLR() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x8) >> 3
}
func (o *QDEC_Type) SetCTRL_AUTO_CLR_EN(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x10)|value<<4)
}
func (o *QDEC_Type) GetCTRL_AUTO_CLR_EN() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x10) >> 4
}
func (o *QDEC_Type) SetCTRL_SINGLE_SAMPLE_SRST_EN(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x20)|value<<5)
}
func (o *QDEC_Type) GetCTRL_SINGLE_SAMPLE_SRST_EN() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x20) >> 5
}
func (o *QDEC_Type) SetCTRL_DB_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x40)|value<<6)
}
func (o *QDEC_Type) GetCTRL_DB_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x40) >> 6
}

// QDEC.SAMP_CTRL: QDEC sample settting register
func (o *QDEC_Type) SetSAMP_CTRL_DIVIDE(value uint32) {
	volatile.StoreUint32(&o.SAMP_CTRL.Reg, volatile.LoadUint32(&o.SAMP_CTRL.Reg)&^(0x1f)|value)
}
func (o *QDEC_Type) GetSAMP_CTRL_DIVIDE() uint32 {
	return volatile.LoadUint32(&o.SAMP_CTRL.Reg) & 0x1f
}
func (o *QDEC_Type) SetSAMP_CTRL_PTS(value uint32) {
	volatile.StoreUint32(&o.SAMP_CTRL.Reg, volatile.LoadUint32(&o.SAMP_CTRL.Reg)&^(0xf00)|value<<8)
}
func (o *QDEC_Type) GetSAMP_CTRL_PTS() uint32 {
	return (volatile.LoadUint32(&o.SAMP_CTRL.Reg) & 0xf00) >> 8
}
func (o *QDEC_Type) SetSAMP_CTRL_DB_SAMP_DIV(value uint32) {
	volatile.StoreUint32(&o.SAMP_CTRL.Reg, volatile.LoadUint32(&o.SAMP_CTRL.Reg)&^(0xf0000)|value<<16)
}
func (o *QDEC_Type) GetSAMP_CTRL_DB_SAMP_DIV() uint32 {
	return (volatile.LoadUint32(&o.SAMP_CTRL.Reg) & 0xf0000) >> 16
}

// QDEC.SAMPLE: QDEC sample result register
func (o *QDEC_Type) SetSAMPLE(value uint32) {
	volatile.StoreUint32(&o.SAMPLE.Reg, volatile.LoadUint32(&o.SAMPLE.Reg)&^(0x3)|value)
}
func (o *QDEC_Type) GetSAMPLE() uint32 {
	return volatile.LoadUint32(&o.SAMPLE.Reg) & 0x3
}

// QDEC.ACC: QDEC accumulate register
func (o *QDEC_Type) SetACC(value uint32) {
	volatile.StoreUint32(&o.ACC.Reg, volatile.LoadUint32(&o.ACC.Reg)&^(0x7ff)|value)
}
func (o *QDEC_Type) GetACC() uint32 {
	return volatile.LoadUint32(&o.ACC.Reg) & 0x7ff
}

// QDEC.ACC_R: QDEC accumulate snapshot register
func (o *QDEC_Type) SetACC_R(value uint32) {
	volatile.StoreUint32(&o.ACC_R.Reg, volatile.LoadUint32(&o.ACC_R.Reg)&^(0x7ff)|value)
}
func (o *QDEC_Type) GetACC_R() uint32 {
	return volatile.LoadUint32(&o.ACC_R.Reg) & 0x7ff
}

// QDEC.DB: double sample register
func (o *QDEC_Type) SetDB(value uint32) {
	volatile.StoreUint32(&o.DB.Reg, volatile.LoadUint32(&o.DB.Reg)&^(0xf)|value)
}
func (o *QDEC_Type) GetDB() uint32 {
	return volatile.LoadUint32(&o.DB.Reg) & 0xf
}

// QDEC.DB_R: DB snapshot register
func (o *QDEC_Type) SetDB_R(value uint32) {
	volatile.StoreUint32(&o.DB_R.Reg, volatile.LoadUint32(&o.DB_R.Reg)&^(0xf)|value)
}
func (o *QDEC_Type) GetDB_R() uint32 {
	return volatile.LoadUint32(&o.DB_R.Reg) & 0xf
}

// QDEC.INT: interrupt register
func (o *QDEC_Type) SetINT_SINGLE_SAMPLE(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x1)|value)
}
func (o *QDEC_Type) GetINT_SINGLE_SAMPLE() uint32 {
	return volatile.LoadUint32(&o.INT.Reg) & 0x1
}
func (o *QDEC_Type) SetINT_SAMPLE_END(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x2)|value<<1)
}
func (o *QDEC_Type) GetINT_SAMPLE_END() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x2) >> 1
}
func (o *QDEC_Type) SetINT_ACC_OF(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x4)|value<<2)
}
func (o *QDEC_Type) GetINT_ACC_OF() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x4) >> 2
}
func (o *QDEC_Type) SetINT_DB_OF(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x8)|value<<3)
}
func (o *QDEC_Type) GetINT_DB_OF() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x8) >> 3
}

// QDEC.INTEN: interrupt mask register
func (o *QDEC_Type) SetINTEN_SINGLE_SAMPLE_INTEN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x1)|value)
}
func (o *QDEC_Type) GetINTEN_SINGLE_SAMPLE_INTEN() uint32 {
	return volatile.LoadUint32(&o.INTEN.Reg) & 0x1
}
func (o *QDEC_Type) SetINTEN_SAMPLE_END_INTEN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x2)|value<<1)
}
func (o *QDEC_Type) GetINTEN_SAMPLE_END_INTEN() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x2) >> 1
}
func (o *QDEC_Type) SetINTEN_ACC_OF_INTEN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x4)|value<<2)
}
func (o *QDEC_Type) GetINTEN_ACC_OF_INTEN() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x4) >> 2
}
func (o *QDEC_Type) SetINTEN_DB_OF_INTEN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x8)|value<<3)
}
func (o *QDEC_Type) GetINTEN_DB_OF_INTEN() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x8) >> 3
}

// QDEC.STAT: QDEC is running
func (o *QDEC_Type) SetSTAT_BUSY(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x1)|value)
}
func (o *QDEC_Type) GetSTAT_BUSY() uint32 {
	return volatile.LoadUint32(&o.STAT.Reg) & 0x1
}

// rtc
type RTC_Type struct {
	CTRL      volatile.Register32 // 0x0
	STATUS    volatile.Register32 // 0x4
	SEC       volatile.Register32 // 0x8
	_         [4]byte
	CAL       volatile.Register32 // 0x10
	CNT_VAL   volatile.Register32 // 0x14
	_         [8]byte
	CNT2_CTRL volatile.Register32 // 0x20
	THR_INT   volatile.Register32 // 0x24
	THR_RST   volatile.Register32 // 0x28
	CNT2      volatile.Register32 // 0x2C
}

// RTC.CTRL: RTC control register
func (o *RTC_Type) SetCTRL_SEC_INT_EN(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetCTRL_SEC_INT_EN() uint32 {
	return volatile.LoadUint32(&o.CTRL.Reg) & 0x1
}
func (o *RTC_Type) SetCTRL_CFG(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x4)|value<<2)
}
func (o *RTC_Type) GetCTRL_CFG() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x4) >> 2
}
func (o *RTC_Type) SetCTRL_CAL_EN(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x100)|value<<8)
}
func (o *RTC_Type) GetCTRL_CAL_EN() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x100) >> 8
}

// RTC.STATUS: RTC status register
func (o *RTC_Type) SetSTATUS_SEC_INT(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetSTATUS_SEC_INT() uint32 {
	return volatile.LoadUint32(&o.STATUS.Reg) & 0x1
}
func (o *RTC_Type) SetSTATUS_CTRL_SYNC(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x100)|value<<8)
}
func (o *RTC_Type) GetSTATUS_CTRL_SYNC() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x100) >> 8
}
func (o *RTC_Type) SetSTATUS_STATUS_SYNC(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x200)|value<<9)
}
func (o *RTC_Type) GetSTATUS_STATUS_SYNC() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x200) >> 9
}
func (o *RTC_Type) SetSTATUS_SEC_SYNC(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x400)|value<<10)
}
func (o *RTC_Type) GetSTATUS_SEC_SYNC() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x400) >> 10
}
func (o *RTC_Type) SetSTATUS_CALIB_SYNC(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x1000)|value<<12)
}
func (o *RTC_Type) GetSTATUS_CALIB_SYNC() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x1000) >> 12
}
func (o *RTC_Type) SetSTATUS_FREE_SYNC(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x10000)|value<<16)
}
func (o *RTC_Type) GetSTATUS_FREE_SYNC() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x10000) >> 16
}
func (o *RTC_Type) SetSTATUS_THR_INT_SYNC(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x20000)|value<<17)
}
func (o *RTC_Type) GetSTATUS_THR_INT_SYNC() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x20000) >> 17
}
func (o *RTC_Type) SetSTATUS_THR_RST_SYNC(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x40000)|value<<18)
}
func (o *RTC_Type) GetSTATUS_THR_RST_SYNC() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x40000) >> 18
}
func (o *RTC_Type) SetSTATUS_FREE_RUNNING_INT(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_Type) GetSTATUS_FREE_RUNNING_INT() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x80000000) >> 31
}

// RTC.SEC: RTC second register
func (o *RTC_Type) SetSEC(value uint32) {
	volatile.StoreUint32(&o.SEC.Reg, value)
}
func (o *RTC_Type) GetSEC() uint32 {
	return volatile.LoadUint32(&o.SEC.Reg)
}

// RTC.CAL: RTC calibration register
func (o *RTC_Type) SetCAL_PPM(value uint32) {
	volatile.StoreUint32(&o.CAL.Reg, volatile.LoadUint32(&o.CAL.Reg)&^(0xffff)|value)
}
func (o *RTC_Type) GetCAL_PPM() uint32 {
	return volatile.LoadUint32(&o.CAL.Reg) & 0xffff
}
func (o *RTC_Type) SetCAL_DIR(value uint32) {
	volatile.StoreUint32(&o.CAL.Reg, volatile.LoadUint32(&o.CAL.Reg)&^(0x10000)|value<<16)
}
func (o *RTC_Type) GetCAL_DIR() uint32 {
	return (volatile.LoadUint32(&o.CAL.Reg) & 0x10000) >> 16
}

// RTC.CNT_VAL: RTC count value register
func (o *RTC_Type) SetCNT_VAL_CNT(value uint32) {
	volatile.StoreUint32(&o.CNT_VAL.Reg, volatile.LoadUint32(&o.CNT_VAL.Reg)&^(0x7fff)|value)
}
func (o *RTC_Type) GetCNT_VAL_CNT() uint32 {
	return volatile.LoadUint32(&o.CNT_VAL.Reg) & 0x7fff
}

// RTC.CNT2_CTRL: Free running control register
func (o *RTC_Type) SetCNT2_CTRL_CNT2_EN(value uint32) {
	volatile.StoreUint32(&o.CNT2_CTRL.Reg, volatile.LoadUint32(&o.CNT2_CTRL.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetCNT2_CTRL_CNT2_EN() uint32 {
	return volatile.LoadUint32(&o.CNT2_CTRL.Reg) & 0x1
}
func (o *RTC_Type) SetCNT2_CTRL_CNT2_INT_EN(value uint32) {
	volatile.StoreUint32(&o.CNT2_CTRL.Reg, volatile.LoadUint32(&o.CNT2_CTRL.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetCNT2_CTRL_CNT2_INT_EN() uint32 {
	return (volatile.LoadUint32(&o.CNT2_CTRL.Reg) & 0x2) >> 1
}
func (o *RTC_Type) SetCNT2_CTRL_CNT2_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CNT2_CTRL.Reg, volatile.LoadUint32(&o.CNT2_CTRL.Reg)&^(0x4)|value<<2)
}
func (o *RTC_Type) GetCNT2_CTRL_CNT2_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CNT2_CTRL.Reg) & 0x4) >> 2
}
func (o *RTC_Type) SetCNT2_CTRL_CNT2_RST(value uint32) {
	volatile.StoreUint32(&o.CNT2_CTRL.Reg, volatile.LoadUint32(&o.CNT2_CTRL.Reg)&^(0x8)|value<<3)
}
func (o *RTC_Type) GetCNT2_CTRL_CNT2_RST() uint32 {
	return (volatile.LoadUint32(&o.CNT2_CTRL.Reg) & 0x8) >> 3
}

// RTC.THR_INT: interrupt threshold of free running counter register
func (o *RTC_Type) SetTHR_INT(value uint32) {
	volatile.StoreUint32(&o.THR_INT.Reg, value)
}
func (o *RTC_Type) GetTHR_INT() uint32 {
	return volatile.LoadUint32(&o.THR_INT.Reg)
}

// RTC.THR_RST: reset threshold of free running counter register
func (o *RTC_Type) SetTHR_RST(value uint32) {
	volatile.StoreUint32(&o.THR_RST.Reg, value)
}
func (o *RTC_Type) GetTHR_RST() uint32 {
	return volatile.LoadUint32(&o.THR_RST.Reg)
}

// RTC.CNT2: free running count value
func (o *RTC_Type) SetCNT2(value uint32) {
	volatile.StoreUint32(&o.CNT2.Reg, value)
}
func (o *RTC_Type) GetCNT2() uint32 {
	return volatile.LoadUint32(&o.CNT2.Reg)
}

// agc
type AGC_Type struct {
	CTRL0 volatile.Register32 // 0x0
	CTRL1 volatile.Register32 // 0x4
	CTRL2 volatile.Register32 // 0x8
	CTRL3 volatile.Register32 // 0xC
	CTRL4 volatile.Register32 // 0x10
	CTRL5 volatile.Register32 // 0x14
	STAT  volatile.Register32 // 0x18
}

// AGC.CTRL0: AGC control register 0
func (o *AGC_Type) SetCTRL0_PPF_INTRPT_MOD(value uint32) {
	volatile.StoreUint32(&o.CTRL0.Reg, volatile.LoadUint32(&o.CTRL0.Reg)&^(0x3)|value)
}
func (o *AGC_Type) GetCTRL0_PPF_INTRPT_MOD() uint32 {
	return volatile.LoadUint32(&o.CTRL0.Reg) & 0x3
}
func (o *AGC_Type) SetCTRL0_FREZ_MOD(value uint32) {
	volatile.StoreUint32(&o.CTRL0.Reg, volatile.LoadUint32(&o.CTRL0.Reg)&^(0xc)|value<<2)
}
func (o *AGC_Type) GetCTRL0_FREZ_MOD() uint32 {
	return (volatile.LoadUint32(&o.CTRL0.Reg) & 0xc) >> 2
}
func (o *AGC_Type) SetCTRL0_RRF_GAIN_SEL(value uint32) {
	volatile.StoreUint32(&o.CTRL0.Reg, volatile.LoadUint32(&o.CTRL0.Reg)&^(0x70)|value<<4)
}
func (o *AGC_Type) GetCTRL0_RRF_GAIN_SEL() uint32 {
	return (volatile.LoadUint32(&o.CTRL0.Reg) & 0x70) >> 4
}
func (o *AGC_Type) SetCTRL0_RRF_WEN(value uint32) {
	volatile.StoreUint32(&o.CTRL0.Reg, volatile.LoadUint32(&o.CTRL0.Reg)&^(0x80)|value<<7)
}
func (o *AGC_Type) GetCTRL0_RRF_WEN() uint32 {
	return (volatile.LoadUint32(&o.CTRL0.Reg) & 0x80) >> 7
}
func (o *AGC_Type) SetCTRL0_PPF_GAIN(value uint32) {
	volatile.StoreUint32(&o.CTRL0.Reg, volatile.LoadUint32(&o.CTRL0.Reg)&^(0xf00)|value<<8)
}
func (o *AGC_Type) GetCTRL0_PPF_GAIN() uint32 {
	return (volatile.LoadUint32(&o.CTRL0.Reg) & 0xf00) >> 8
}
func (o *AGC_Type) SetCTRL0_PPF_WEN(value uint32) {
	volatile.StoreUint32(&o.CTRL0.Reg, volatile.LoadUint32(&o.CTRL0.Reg)&^(0x1000)|value<<12)
}
func (o *AGC_Type) GetCTRL0_PPF_WEN() uint32 {
	return (volatile.LoadUint32(&o.CTRL0.Reg) & 0x1000) >> 12
}
func (o *AGC_Type) SetCTRL0_PKWT_TH_DIG_1(value uint32) {
	volatile.StoreUint32(&o.CTRL0.Reg, volatile.LoadUint32(&o.CTRL0.Reg)&^(0x3e000)|value<<13)
}
func (o *AGC_Type) GetCTRL0_PKWT_TH_DIG_1() uint32 {
	return (volatile.LoadUint32(&o.CTRL0.Reg) & 0x3e000) >> 13
}
func (o *AGC_Type) SetCTRL0_PD_CLR_EN(value uint32) {
	volatile.StoreUint32(&o.CTRL0.Reg, volatile.LoadUint32(&o.CTRL0.Reg)&^(0x40000)|value<<18)
}
func (o *AGC_Type) GetCTRL0_PD_CLR_EN() uint32 {
	return (volatile.LoadUint32(&o.CTRL0.Reg) & 0x40000) >> 18
}
func (o *AGC_Type) SetCTRL0_PD_RST_LEN(value uint32) {
	volatile.StoreUint32(&o.CTRL0.Reg, volatile.LoadUint32(&o.CTRL0.Reg)&^(0x380000)|value<<19)
}
func (o *AGC_Type) GetCTRL0_PD_RST_LEN() uint32 {
	return (volatile.LoadUint32(&o.CTRL0.Reg) & 0x380000) >> 19
}
func (o *AGC_Type) SetCTRL0_RFAGC_FSYNC_DET_DIS(value uint32) {
	volatile.StoreUint32(&o.CTRL0.Reg, volatile.LoadUint32(&o.CTRL0.Reg)&^(0x400000)|value<<22)
}
func (o *AGC_Type) GetCTRL0_RFAGC_FSYNC_DET_DIS() uint32 {
	return (volatile.LoadUint32(&o.CTRL0.Reg) & 0x400000) >> 22
}
func (o *AGC_Type) SetCTRL0_RFAGC_DIRECTION_FREEZE(value uint32) {
	volatile.StoreUint32(&o.CTRL0.Reg, volatile.LoadUint32(&o.CTRL0.Reg)&^(0x800000)|value<<23)
}
func (o *AGC_Type) GetCTRL0_RFAGC_DIRECTION_FREEZE() uint32 {
	return (volatile.LoadUint32(&o.CTRL0.Reg) & 0x800000) >> 23
}
func (o *AGC_Type) SetCTRL0_DOWN_24_EN(value uint32) {
	volatile.StoreUint32(&o.CTRL0.Reg, volatile.LoadUint32(&o.CTRL0.Reg)&^(0x1000000)|value<<24)
}
func (o *AGC_Type) GetCTRL0_DOWN_24_EN() uint32 {
	return (volatile.LoadUint32(&o.CTRL0.Reg) & 0x1000000) >> 24
}
func (o *AGC_Type) SetCTRL0_SWITCH_PD_RST_LEN(value uint32) {
	volatile.StoreUint32(&o.CTRL0.Reg, volatile.LoadUint32(&o.CTRL0.Reg)&^(0x6000000)|value<<25)
}
func (o *AGC_Type) GetCTRL0_SWITCH_PD_RST_LEN() uint32 {
	return (volatile.LoadUint32(&o.CTRL0.Reg) & 0x6000000) >> 25
}
func (o *AGC_Type) SetCTRL0_GLNA_MAX_REDU(value uint32) {
	volatile.StoreUint32(&o.CTRL0.Reg, volatile.LoadUint32(&o.CTRL0.Reg)&^(0x8000000)|value<<27)
}
func (o *AGC_Type) GetCTRL0_GLNA_MAX_REDU() uint32 {
	return (volatile.LoadUint32(&o.CTRL0.Reg) & 0x8000000) >> 27
}

// AGC.CTRL1: AGC control register 1
func (o *AGC_Type) SetCTRL1_PD3_TH_REG(value uint32) {
	volatile.StoreUint32(&o.CTRL1.Reg, volatile.LoadUint32(&o.CTRL1.Reg)&^(0x7)|value)
}
func (o *AGC_Type) GetCTRL1_PD3_TH_REG() uint32 {
	return volatile.LoadUint32(&o.CTRL1.Reg) & 0x7
}
func (o *AGC_Type) SetCTRL1_PD3_TH_HYST_REG(value uint32) {
	volatile.StoreUint32(&o.CTRL1.Reg, volatile.LoadUint32(&o.CTRL1.Reg)&^(0x78)|value<<3)
}
func (o *AGC_Type) GetCTRL1_PD3_TH_HYST_REG() uint32 {
	return (volatile.LoadUint32(&o.CTRL1.Reg) & 0x78) >> 3
}
func (o *AGC_Type) SetCTRL1_PKWT_TH_ANA_1(value uint32) {
	volatile.StoreUint32(&o.CTRL1.Reg, volatile.LoadUint32(&o.CTRL1.Reg)&^(0x1f80)|value<<7)
}
func (o *AGC_Type) GetCTRL1_PKWT_TH_ANA_1() uint32 {
	return (volatile.LoadUint32(&o.CTRL1.Reg) & 0x1f80) >> 7
}
func (o *AGC_Type) SetCTRL1_PKWT_TH_ANA_0(value uint32) {
	volatile.StoreUint32(&o.CTRL1.Reg, volatile.LoadUint32(&o.CTRL1.Reg)&^(0x3e000)|value<<13)
}
func (o *AGC_Type) GetCTRL1_PKWT_TH_ANA_0() uint32 {
	return (volatile.LoadUint32(&o.CTRL1.Reg) & 0x3e000) >> 13
}
func (o *AGC_Type) SetCTRL1_PKWT_TH_DIG_0(value uint32) {
	volatile.StoreUint32(&o.CTRL1.Reg, volatile.LoadUint32(&o.CTRL1.Reg)&^(0x7c0000)|value<<18)
}
func (o *AGC_Type) GetCTRL1_PKWT_TH_DIG_0() uint32 {
	return (volatile.LoadUint32(&o.CTRL1.Reg) & 0x7c0000) >> 18
}
func (o *AGC_Type) SetCTRL1_SETL_TH_PPF_2(value uint32) {
	volatile.StoreUint32(&o.CTRL1.Reg, volatile.LoadUint32(&o.CTRL1.Reg)&^(0xf800000)|value<<23)
}
func (o *AGC_Type) GetCTRL1_SETL_TH_PPF_2() uint32 {
	return (volatile.LoadUint32(&o.CTRL1.Reg) & 0xf800000) >> 23
}

// AGC.CTRL2: AGC control register 2
func (o *AGC_Type) SetCTRL2_PPF_PDVTH_LOW(value uint32) {
	volatile.StoreUint32(&o.CTRL2.Reg, volatile.LoadUint32(&o.CTRL2.Reg)&^(0x100)|value<<8)
}
func (o *AGC_Type) GetCTRL2_PPF_PDVTH_LOW() uint32 {
	return (volatile.LoadUint32(&o.CTRL2.Reg) & 0x100) >> 8
}
func (o *AGC_Type) SetCTRL2_RRF_MG_PK(value uint32) {
	volatile.StoreUint32(&o.CTRL2.Reg, volatile.LoadUint32(&o.CTRL2.Reg)&^(0xe00)|value<<9)
}
func (o *AGC_Type) GetCTRL2_RRF_MG_PK() uint32 {
	return (volatile.LoadUint32(&o.CTRL2.Reg) & 0xe00) >> 9
}
func (o *AGC_Type) SetCTRL2_RRF_HG_PK(value uint32) {
	volatile.StoreUint32(&o.CTRL2.Reg, volatile.LoadUint32(&o.CTRL2.Reg)&^(0x7000)|value<<12)
}
func (o *AGC_Type) GetCTRL2_RRF_HG_PK() uint32 {
	return (volatile.LoadUint32(&o.CTRL2.Reg) & 0x7000) >> 12
}

// AGC.CTRL3: AGC control register 3
func (o *AGC_Type) SetCTRL3_GF2_PAR00(value uint32) {
	volatile.StoreUint32(&o.CTRL3.Reg, volatile.LoadUint32(&o.CTRL3.Reg)&^(0xf)|value)
}
func (o *AGC_Type) GetCTRL3_GF2_PAR00() uint32 {
	return volatile.LoadUint32(&o.CTRL3.Reg) & 0xf
}
func (o *AGC_Type) SetCTRL3_GF2_PAR01(value uint32) {
	volatile.StoreUint32(&o.CTRL3.Reg, volatile.LoadUint32(&o.CTRL3.Reg)&^(0xf0)|value<<4)
}
func (o *AGC_Type) GetCTRL3_GF2_PAR01() uint32 {
	return (volatile.LoadUint32(&o.CTRL3.Reg) & 0xf0) >> 4
}
func (o *AGC_Type) SetCTRL3_GF2_PAR10(value uint32) {
	volatile.StoreUint32(&o.CTRL3.Reg, volatile.LoadUint32(&o.CTRL3.Reg)&^(0xf00)|value<<8)
}
func (o *AGC_Type) GetCTRL3_GF2_PAR10() uint32 {
	return (volatile.LoadUint32(&o.CTRL3.Reg) & 0xf00) >> 8
}
func (o *AGC_Type) SetCTRL3_SETL_TH_OVSHT_DIG(value uint32) {
	volatile.StoreUint32(&o.CTRL3.Reg, volatile.LoadUint32(&o.CTRL3.Reg)&^(0x7000)|value<<12)
}
func (o *AGC_Type) GetCTRL3_SETL_TH_OVSHT_DIG() uint32 {
	return (volatile.LoadUint32(&o.CTRL3.Reg) & 0x7000) >> 12
}
func (o *AGC_Type) SetCTRL3_SETL_TH_OVSHT_INTRPT(value uint32) {
	volatile.StoreUint32(&o.CTRL3.Reg, volatile.LoadUint32(&o.CTRL3.Reg)&^(0x38000)|value<<15)
}
func (o *AGC_Type) GetCTRL3_SETL_TH_OVSHT_INTRPT() uint32 {
	return (volatile.LoadUint32(&o.CTRL3.Reg) & 0x38000) >> 15
}
func (o *AGC_Type) SetCTRL3_SETL_TH_OVSHT(value uint32) {
	volatile.StoreUint32(&o.CTRL3.Reg, volatile.LoadUint32(&o.CTRL3.Reg)&^(0x1c0000)|value<<18)
}
func (o *AGC_Type) GetCTRL3_SETL_TH_OVSHT() uint32 {
	return (volatile.LoadUint32(&o.CTRL3.Reg) & 0x1c0000) >> 18
}

// AGC.CTRL4: AGC control register 4
func (o *AGC_Type) SetCTRL4_SETL_TH_PD1(value uint32) {
	volatile.StoreUint32(&o.CTRL4.Reg, volatile.LoadUint32(&o.CTRL4.Reg)&^(0xf)|value)
}
func (o *AGC_Type) GetCTRL4_SETL_TH_PD1() uint32 {
	return volatile.LoadUint32(&o.CTRL4.Reg) & 0xf
}
func (o *AGC_Type) SetCTRL4_SETL_TH_PD2(value uint32) {
	volatile.StoreUint32(&o.CTRL4.Reg, volatile.LoadUint32(&o.CTRL4.Reg)&^(0xf0)|value<<4)
}
func (o *AGC_Type) GetCTRL4_SETL_TH_PD2() uint32 {
	return (volatile.LoadUint32(&o.CTRL4.Reg) & 0xf0) >> 4
}
func (o *AGC_Type) SetCTRL4_SETL_TH_PD3_1(value uint32) {
	volatile.StoreUint32(&o.CTRL4.Reg, volatile.LoadUint32(&o.CTRL4.Reg)&^(0x3f00)|value<<8)
}
func (o *AGC_Type) GetCTRL4_SETL_TH_PD3_1() uint32 {
	return (volatile.LoadUint32(&o.CTRL4.Reg) & 0x3f00) >> 8
}
func (o *AGC_Type) SetCTRL4_SETL_TH_PD3_2(value uint32) {
	volatile.StoreUint32(&o.CTRL4.Reg, volatile.LoadUint32(&o.CTRL4.Reg)&^(0xfc000)|value<<14)
}
func (o *AGC_Type) GetCTRL4_SETL_TH_PD3_2() uint32 {
	return (volatile.LoadUint32(&o.CTRL4.Reg) & 0xfc000) >> 14
}
func (o *AGC_Type) SetCTRL4_GF2_STAT24_TH(value uint32) {
	volatile.StoreUint32(&o.CTRL4.Reg, volatile.LoadUint32(&o.CTRL4.Reg)&^(0xf00000)|value<<20)
}
func (o *AGC_Type) GetCTRL4_GF2_STAT24_TH() uint32 {
	return (volatile.LoadUint32(&o.CTRL4.Reg) & 0xf00000) >> 20
}

// AGC.CTRL5: AGC control register 5
func (o *AGC_Type) SetCTRL5_TEST_CTRL(value uint32) {
	volatile.StoreUint32(&o.CTRL5.Reg, volatile.LoadUint32(&o.CTRL5.Reg)&^(0xf)|value)
}
func (o *AGC_Type) GetCTRL5_TEST_CTRL() uint32 {
	return volatile.LoadUint32(&o.CTRL5.Reg) & 0xf
}

// AGC.STAT: AGC status register
func (o *AGC_Type) SetSTAT_GLNA_CODE_OUT(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x7)|value)
}
func (o *AGC_Type) GetSTAT_GLNA_CODE_OUT() uint32 {
	return volatile.LoadUint32(&o.STAT.Reg) & 0x7
}
func (o *AGC_Type) SetSTAT_GF2_CODE_OUT(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x78)|value<<3)
}
func (o *AGC_Type) GetSTAT_GF2_CODE_OUT() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x78) >> 3
}
func (o *AGC_Type) SetSTAT_RFAGC_TRIGGER_O(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x80)|value<<7)
}
func (o *AGC_Type) GetSTAT_RFAGC_TRIGGER_O() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x80) >> 7
}
func (o *AGC_Type) SetSTAT_RF_GAIN(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x7f00)|value<<8)
}
func (o *AGC_Type) GetSTAT_RF_GAIN() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x7f00) >> 8
}
func (o *AGC_Type) SetSTAT_NUM_GAIN_ADJ(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0xf8000)|value<<15)
}
func (o *AGC_Type) GetSTAT_NUM_GAIN_ADJ() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0xf8000) >> 15
}
func (o *AGC_Type) SetSTAT_CUR_STAT(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x700000)|value<<20)
}
func (o *AGC_Type) GetSTAT_CUR_STAT() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x700000) >> 20
}

// prop
type PROP_Type struct {
	TX_BUF volatile.Register32 // 0x0
	RX_BUF volatile.Register32 // 0x4
	STAT   volatile.Register32 // 0x8
}

// PROP.TX_BUF: transmit data buffer input port register
func (o *PROP_Type) SetTX_BUF(value uint32) {
	volatile.StoreUint32(&o.TX_BUF.Reg, volatile.LoadUint32(&o.TX_BUF.Reg)&^(0xff)|value)
}
func (o *PROP_Type) GetTX_BUF() uint32 {
	return volatile.LoadUint32(&o.TX_BUF.Reg) & 0xff
}

// PROP.RX_BUF: received data buffer output register
func (o *PROP_Type) SetRX_BUF(value uint32) {
	volatile.StoreUint32(&o.RX_BUF.Reg, volatile.LoadUint32(&o.RX_BUF.Reg)&^(0xff)|value)
}
func (o *PROP_Type) GetRX_BUF() uint32 {
	return volatile.LoadUint32(&o.RX_BUF.Reg) & 0xff
}

// PROP.STAT: status register
func (o *PROP_Type) SetSTAT_BIT_ORDER(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x1)|value)
}
func (o *PROP_Type) GetSTAT_BIT_ORDER() uint32 {
	return volatile.LoadUint32(&o.STAT.Reg) & 0x1
}
func (o *PROP_Type) SetSTAT_TX_INTEN(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x2)|value<<1)
}
func (o *PROP_Type) GetSTAT_TX_INTEN() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x2) >> 1
}
func (o *PROP_Type) SetSTAT_RX_INTEN(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x4)|value<<2)
}
func (o *PROP_Type) GetSTAT_RX_INTEN() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x4) >> 2
}
func (o *PROP_Type) SetSTAT_RX_INT(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x8)|value<<3)
}
func (o *PROP_Type) GetSTAT_RX_INT() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x8) >> 3
}
func (o *PROP_Type) SetSTAT_TX_INT(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x10)|value<<4)
}
func (o *PROP_Type) GetSTAT_TX_INT() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x10) >> 4
}
func (o *PROP_Type) SetSTAT_RX_BUSY(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x20)|value<<5)
}
func (o *PROP_Type) GetSTAT_RX_BUSY() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x20) >> 5
}
func (o *PROP_Type) SetSTAT_TX_BUSY(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x40)|value<<6)
}
func (o *PROP_Type) GetSTAT_TX_BUSY() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x40) >> 6
}
func (o *PROP_Type) SetSTAT_CLR(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x80)|value<<7)
}
func (o *PROP_Type) GetSTAT_CLR() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x80) >> 7
}

// bledp
type BLEDP_Type struct {
	DP_TOP_SYSTEM_CTRL  volatile.Register32 // 0x0
	PROP_MODE_CTRL      volatile.Register32 // 0x4
	ACCESS_ADDRESS      volatile.Register32 // 0x8
	ANT_PDU_DATA0       volatile.Register32 // 0xC
	ANT_PDU_DATA1       volatile.Register32 // 0x10
	ANT_PDU_DATA2       volatile.Register32 // 0x14
	ANT_PDU_DATA3       volatile.Register32 // 0x18
	ANT_PDU_DATA4       volatile.Register32 // 0x1C
	ANT_PDU_DATA5       volatile.Register32 // 0x20
	ANT_PDU_DATA6       volatile.Register32 // 0x24
	ANT_PDU_DATA7       volatile.Register32 // 0x28
	CRCSEED             volatile.Register32 // 0x2C
	DP_FUNCTION_CTRL    volatile.Register32 // 0x30
	DP_TEST_CTRL        volatile.Register32 // 0x34
	BLE_DP_STATUS1      volatile.Register32 // 0x38
	BLE_DP_STATUS2      volatile.Register32 // 0x3C
	BLE_DP_STATUS3      volatile.Register32 // 0x40
	BLE_DP_STATUS4      volatile.Register32 // 0x44
	RX_FRONT_END_CTRL1  volatile.Register32 // 0x48
	RX_FRONT_END_CTRL2  volatile.Register32 // 0x4C
	FREQ_DOMAIN_CTRL1   volatile.Register32 // 0x50
	FREQ_DOMAIN_CTRL2   volatile.Register32 // 0x54
	FREQ_DOMAIN_CTRL3   volatile.Register32 // 0x58
	FREQ_DOMAIN_CTRL4   volatile.Register32 // 0x5C
	FREQ_DOMAIN_CTRL5   volatile.Register32 // 0x60
	FREQ_DOMAIN_CTRL6   volatile.Register32 // 0x64
	HP_MODE_CTRL1       volatile.Register32 // 0x68
	HP_MODE_CTRL2       volatile.Register32 // 0x6C
	FREQ_DOMAIN_STATUS1 volatile.Register32 // 0x70
	FREQ_DOMAIN_STATUS2 volatile.Register32 // 0x74
	_                   [12]byte
	DP_AA_ERROR_CTRL    volatile.Register32 // 0x84
	DP_INT              volatile.Register32 // 0x88
	DP_AA_ERROR_TH      volatile.Register32 // 0x8C
	DF_ANTENNA_CTRL     volatile.Register32 // 0x90
	ANTENNA_MAP01       volatile.Register32 // 0x94
	ANTENNA_MAP23       volatile.Register32 // 0x98
	ANTENNA_MAP45       volatile.Register32 // 0x9C
	ANTENNA_MAP67       volatile.Register32 // 0xA0
}

// BLEDP.DP_TOP_SYSTEM_CTRL: datapath system control register
func (o *BLEDP_Type) SetDP_TOP_SYSTEM_CTRL_RX_PDU_LEN_IN(value uint32) {
	volatile.StoreUint32(&o.DP_TOP_SYSTEM_CTRL.Reg, volatile.LoadUint32(&o.DP_TOP_SYSTEM_CTRL.Reg)&^(0x3fff)|value)
}
func (o *BLEDP_Type) GetDP_TOP_SYSTEM_CTRL_RX_PDU_LEN_IN() uint32 {
	return volatile.LoadUint32(&o.DP_TOP_SYSTEM_CTRL.Reg) & 0x3fff
}
func (o *BLEDP_Type) SetDP_TOP_SYSTEM_CTRL_AA_SEL(value uint32) {
	volatile.StoreUint32(&o.DP_TOP_SYSTEM_CTRL.Reg, volatile.LoadUint32(&o.DP_TOP_SYSTEM_CTRL.Reg)&^(0x4000)|value<<14)
}
func (o *BLEDP_Type) GetDP_TOP_SYSTEM_CTRL_AA_SEL() uint32 {
	return (volatile.LoadUint32(&o.DP_TOP_SYSTEM_CTRL.Reg) & 0x4000) >> 14
}
func (o *BLEDP_Type) SetDP_TOP_SYSTEM_CTRL_PDU_LEN_SEL(value uint32) {
	volatile.StoreUint32(&o.DP_TOP_SYSTEM_CTRL.Reg, volatile.LoadUint32(&o.DP_TOP_SYSTEM_CTRL.Reg)&^(0x8000)|value<<15)
}
func (o *BLEDP_Type) GetDP_TOP_SYSTEM_CTRL_PDU_LEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.DP_TOP_SYSTEM_CTRL.Reg) & 0x8000) >> 15
}
func (o *BLEDP_Type) SetDP_TOP_SYSTEM_CTRL_H_IDX(value uint32) {
	volatile.StoreUint32(&o.DP_TOP_SYSTEM_CTRL.Reg, volatile.LoadUint32(&o.DP_TOP_SYSTEM_CTRL.Reg)&^(0xff0000)|value<<16)
}
func (o *BLEDP_Type) GetDP_TOP_SYSTEM_CTRL_H_IDX() uint32 {
	return (volatile.LoadUint32(&o.DP_TOP_SYSTEM_CTRL.Reg) & 0xff0000) >> 16
}
func (o *BLEDP_Type) SetDP_TOP_SYSTEM_CTRL_RX_EN_SEL(value uint32) {
	volatile.StoreUint32(&o.DP_TOP_SYSTEM_CTRL.Reg, volatile.LoadUint32(&o.DP_TOP_SYSTEM_CTRL.Reg)&^(0x1000000)|value<<24)
}
func (o *BLEDP_Type) GetDP_TOP_SYSTEM_CTRL_RX_EN_SEL() uint32 {
	return (volatile.LoadUint32(&o.DP_TOP_SYSTEM_CTRL.Reg) & 0x1000000) >> 24
}
func (o *BLEDP_Type) SetDP_TOP_SYSTEM_CTRL_TX_EN_SEL(value uint32) {
	volatile.StoreUint32(&o.DP_TOP_SYSTEM_CTRL.Reg, volatile.LoadUint32(&o.DP_TOP_SYSTEM_CTRL.Reg)&^(0x2000000)|value<<25)
}
func (o *BLEDP_Type) GetDP_TOP_SYSTEM_CTRL_TX_EN_SEL() uint32 {
	return (volatile.LoadUint32(&o.DP_TOP_SYSTEM_CTRL.Reg) & 0x2000000) >> 25
}
func (o *BLEDP_Type) SetDP_TOP_SYSTEM_CTRL_RX_REQ(value uint32) {
	volatile.StoreUint32(&o.DP_TOP_SYSTEM_CTRL.Reg, volatile.LoadUint32(&o.DP_TOP_SYSTEM_CTRL.Reg)&^(0x4000000)|value<<26)
}
func (o *BLEDP_Type) GetDP_TOP_SYSTEM_CTRL_RX_REQ() uint32 {
	return (volatile.LoadUint32(&o.DP_TOP_SYSTEM_CTRL.Reg) & 0x4000000) >> 26
}
func (o *BLEDP_Type) SetDP_TOP_SYSTEM_CTRL_TX_REQ(value uint32) {
	volatile.StoreUint32(&o.DP_TOP_SYSTEM_CTRL.Reg, volatile.LoadUint32(&o.DP_TOP_SYSTEM_CTRL.Reg)&^(0x8000000)|value<<27)
}
func (o *BLEDP_Type) GetDP_TOP_SYSTEM_CTRL_TX_REQ() uint32 {
	return (volatile.LoadUint32(&o.DP_TOP_SYSTEM_CTRL.Reg) & 0x8000000) >> 27
}
func (o *BLEDP_Type) SetDP_TOP_SYSTEM_CTRL_RX_MODE(value uint32) {
	volatile.StoreUint32(&o.DP_TOP_SYSTEM_CTRL.Reg, volatile.LoadUint32(&o.DP_TOP_SYSTEM_CTRL.Reg)&^(0x30000000)|value<<28)
}
func (o *BLEDP_Type) GetDP_TOP_SYSTEM_CTRL_RX_MODE() uint32 {
	return (volatile.LoadUint32(&o.DP_TOP_SYSTEM_CTRL.Reg) & 0x30000000) >> 28
}
func (o *BLEDP_Type) SetDP_TOP_SYSTEM_CTRL_ANT_DATA_START(value uint32) {
	volatile.StoreUint32(&o.DP_TOP_SYSTEM_CTRL.Reg, volatile.LoadUint32(&o.DP_TOP_SYSTEM_CTRL.Reg)&^(0x40000000)|value<<30)
}
func (o *BLEDP_Type) GetDP_TOP_SYSTEM_CTRL_ANT_DATA_START() uint32 {
	return (volatile.LoadUint32(&o.DP_TOP_SYSTEM_CTRL.Reg) & 0x40000000) >> 30
}
func (o *BLEDP_Type) SetDP_TOP_SYSTEM_CTRL_DET_MODE(value uint32) {
	volatile.StoreUint32(&o.DP_TOP_SYSTEM_CTRL.Reg, volatile.LoadUint32(&o.DP_TOP_SYSTEM_CTRL.Reg)&^(0x80000000)|value<<31)
}
func (o *BLEDP_Type) GetDP_TOP_SYSTEM_CTRL_DET_MODE() uint32 {
	return (volatile.LoadUint32(&o.DP_TOP_SYSTEM_CTRL.Reg) & 0x80000000) >> 31
}

// BLEDP.PROP_MODE_CTRL: properity mode control register
func (o *BLEDP_Type) SetPROP_MODE_CTRL_PROP_AA_ADDR_IN(value uint32) {
	volatile.StoreUint32(&o.PROP_MODE_CTRL.Reg, volatile.LoadUint32(&o.PROP_MODE_CTRL.Reg)&^(0xff)|value)
}
func (o *BLEDP_Type) GetPROP_MODE_CTRL_PROP_AA_ADDR_IN() uint32 {
	return volatile.LoadUint32(&o.PROP_MODE_CTRL.Reg) & 0xff
}
func (o *BLEDP_Type) SetPROP_MODE_CTRL_PROP_CRC_NUM(value uint32) {
	volatile.StoreUint32(&o.PROP_MODE_CTRL.Reg, volatile.LoadUint32(&o.PROP_MODE_CTRL.Reg)&^(0x300)|value<<8)
}
func (o *BLEDP_Type) GetPROP_MODE_CTRL_PROP_CRC_NUM() uint32 {
	return (volatile.LoadUint32(&o.PROP_MODE_CTRL.Reg) & 0x300) >> 8
}
func (o *BLEDP_Type) SetPROP_MODE_CTRL_PROP_AA_NUM(value uint32) {
	volatile.StoreUint32(&o.PROP_MODE_CTRL.Reg, volatile.LoadUint32(&o.PROP_MODE_CTRL.Reg)&^(0x3000)|value<<12)
}
func (o *BLEDP_Type) GetPROP_MODE_CTRL_PROP_AA_NUM() uint32 {
	return (volatile.LoadUint32(&o.PROP_MODE_CTRL.Reg) & 0x3000) >> 12
}
func (o *BLEDP_Type) SetPROP_MODE_CTRL_PROP_PRE_NUM(value uint32) {
	volatile.StoreUint32(&o.PROP_MODE_CTRL.Reg, volatile.LoadUint32(&o.PROP_MODE_CTRL.Reg)&^(0x70000)|value<<16)
}
func (o *BLEDP_Type) GetPROP_MODE_CTRL_PROP_PRE_NUM() uint32 {
	return (volatile.LoadUint32(&o.PROP_MODE_CTRL.Reg) & 0x70000) >> 16
}
func (o *BLEDP_Type) SetPROP_MODE_CTRL_PROP_DATA_RATE(value uint32) {
	volatile.StoreUint32(&o.PROP_MODE_CTRL.Reg, volatile.LoadUint32(&o.PROP_MODE_CTRL.Reg)&^(0x300000)|value<<20)
}
func (o *BLEDP_Type) GetPROP_MODE_CTRL_PROP_DATA_RATE() uint32 {
	return (volatile.LoadUint32(&o.PROP_MODE_CTRL.Reg) & 0x300000) >> 20
}
func (o *BLEDP_Type) SetPROP_MODE_CTRL_PROP_DIRECTION_RATE(value uint32) {
	volatile.StoreUint32(&o.PROP_MODE_CTRL.Reg, volatile.LoadUint32(&o.PROP_MODE_CTRL.Reg)&^(0xc00000)|value<<22)
}
func (o *BLEDP_Type) GetPROP_MODE_CTRL_PROP_DIRECTION_RATE() uint32 {
	return (volatile.LoadUint32(&o.PROP_MODE_CTRL.Reg) & 0xc00000) >> 22
}
func (o *BLEDP_Type) SetPROP_MODE_CTRL_PROP_DIRECTION_MODE(value uint32) {
	volatile.StoreUint32(&o.PROP_MODE_CTRL.Reg, volatile.LoadUint32(&o.PROP_MODE_CTRL.Reg)&^(0x1000000)|value<<24)
}
func (o *BLEDP_Type) GetPROP_MODE_CTRL_PROP_DIRECTION_MODE() uint32 {
	return (volatile.LoadUint32(&o.PROP_MODE_CTRL.Reg) & 0x1000000) >> 24
}
func (o *BLEDP_Type) SetPROP_MODE_CTRL_RX_ALWAYS_ON(value uint32) {
	volatile.StoreUint32(&o.PROP_MODE_CTRL.Reg, volatile.LoadUint32(&o.PROP_MODE_CTRL.Reg)&^(0x2000000)|value<<25)
}
func (o *BLEDP_Type) GetPROP_MODE_CTRL_RX_ALWAYS_ON() uint32 {
	return (volatile.LoadUint32(&o.PROP_MODE_CTRL.Reg) & 0x2000000) >> 25
}
func (o *BLEDP_Type) SetPROP_MODE_CTRL_TX_ALWAYS_ON(value uint32) {
	volatile.StoreUint32(&o.PROP_MODE_CTRL.Reg, volatile.LoadUint32(&o.PROP_MODE_CTRL.Reg)&^(0x4000000)|value<<26)
}
func (o *BLEDP_Type) GetPROP_MODE_CTRL_TX_ALWAYS_ON() uint32 {
	return (volatile.LoadUint32(&o.PROP_MODE_CTRL.Reg) & 0x4000000) >> 26
}
func (o *BLEDP_Type) SetPROP_MODE_CTRL_TX_POWER_DONE_TIME(value uint32) {
	volatile.StoreUint32(&o.PROP_MODE_CTRL.Reg, volatile.LoadUint32(&o.PROP_MODE_CTRL.Reg)&^(0xf8000000)|value<<27)
}
func (o *BLEDP_Type) GetPROP_MODE_CTRL_TX_POWER_DONE_TIME() uint32 {
	return (volatile.LoadUint32(&o.PROP_MODE_CTRL.Reg) & 0xf8000000) >> 27
}

// BLEDP.ACCESS_ADDRESS: access address register
func (o *BLEDP_Type) SetACCESS_ADDRESS(value uint32) {
	volatile.StoreUint32(&o.ACCESS_ADDRESS.Reg, value)
}
func (o *BLEDP_Type) GetACCESS_ADDRESS() uint32 {
	return volatile.LoadUint32(&o.ACCESS_ADDRESS.Reg)
}

// BLEDP.ANT_PDU_DATA0: pdu data 0 to 1 byte, and preamble register
func (o *BLEDP_Type) SetANT_PDU_DATA0_PDU_DATA0(value uint32) {
	volatile.StoreUint32(&o.ANT_PDU_DATA0.Reg, volatile.LoadUint32(&o.ANT_PDU_DATA0.Reg)&^(0xffff)|value)
}
func (o *BLEDP_Type) GetANT_PDU_DATA0_PDU_DATA0() uint32 {
	return volatile.LoadUint32(&o.ANT_PDU_DATA0.Reg) & 0xffff
}
func (o *BLEDP_Type) SetANT_PDU_DATA0_PATTERN_SEL(value uint32) {
	volatile.StoreUint32(&o.ANT_PDU_DATA0.Reg, volatile.LoadUint32(&o.ANT_PDU_DATA0.Reg)&^(0xf0000)|value<<16)
}
func (o *BLEDP_Type) GetANT_PDU_DATA0_PATTERN_SEL() uint32 {
	return (volatile.LoadUint32(&o.ANT_PDU_DATA0.Reg) & 0xf0000) >> 16
}
func (o *BLEDP_Type) SetANT_PDU_DATA0_TEST_PATTERN_EN(value uint32) {
	volatile.StoreUint32(&o.ANT_PDU_DATA0.Reg, volatile.LoadUint32(&o.ANT_PDU_DATA0.Reg)&^(0x100000)|value<<20)
}
func (o *BLEDP_Type) GetANT_PDU_DATA0_TEST_PATTERN_EN() uint32 {
	return (volatile.LoadUint32(&o.ANT_PDU_DATA0.Reg) & 0x100000) >> 20
}
func (o *BLEDP_Type) SetANT_PDU_DATA0_PROP_PREAMBLE_WEN(value uint32) {
	volatile.StoreUint32(&o.ANT_PDU_DATA0.Reg, volatile.LoadUint32(&o.ANT_PDU_DATA0.Reg)&^(0x800000)|value<<23)
}
func (o *BLEDP_Type) GetANT_PDU_DATA0_PROP_PREAMBLE_WEN() uint32 {
	return (volatile.LoadUint32(&o.ANT_PDU_DATA0.Reg) & 0x800000) >> 23
}
func (o *BLEDP_Type) SetANT_PDU_DATA0_PROP_PREAMBLE(value uint32) {
	volatile.StoreUint32(&o.ANT_PDU_DATA0.Reg, volatile.LoadUint32(&o.ANT_PDU_DATA0.Reg)&^(0xff000000)|value<<24)
}
func (o *BLEDP_Type) GetANT_PDU_DATA0_PROP_PREAMBLE() uint32 {
	return (volatile.LoadUint32(&o.ANT_PDU_DATA0.Reg) & 0xff000000) >> 24
}

// BLEDP.ANT_PDU_DATA1: pdu data 2 to 5 byte
func (o *BLEDP_Type) SetANT_PDU_DATA1(value uint32) {
	volatile.StoreUint32(&o.ANT_PDU_DATA1.Reg, value)
}
func (o *BLEDP_Type) GetANT_PDU_DATA1() uint32 {
	return volatile.LoadUint32(&o.ANT_PDU_DATA1.Reg)
}

// BLEDP.ANT_PDU_DATA2: pdu data 6 to 9 byte
func (o *BLEDP_Type) SetANT_PDU_DATA2(value uint32) {
	volatile.StoreUint32(&o.ANT_PDU_DATA2.Reg, value)
}
func (o *BLEDP_Type) GetANT_PDU_DATA2() uint32 {
	return volatile.LoadUint32(&o.ANT_PDU_DATA2.Reg)
}

// BLEDP.ANT_PDU_DATA3: pdu data 10 to 13 byte
func (o *BLEDP_Type) SetANT_PDU_DATA3(value uint32) {
	volatile.StoreUint32(&o.ANT_PDU_DATA3.Reg, value)
}
func (o *BLEDP_Type) GetANT_PDU_DATA3() uint32 {
	return volatile.LoadUint32(&o.ANT_PDU_DATA3.Reg)
}

// BLEDP.ANT_PDU_DATA4: pdu data 14 to 17 byte
func (o *BLEDP_Type) SetANT_PDU_DATA4(value uint32) {
	volatile.StoreUint32(&o.ANT_PDU_DATA4.Reg, value)
}
func (o *BLEDP_Type) GetANT_PDU_DATA4() uint32 {
	return volatile.LoadUint32(&o.ANT_PDU_DATA4.Reg)
}

// BLEDP.ANT_PDU_DATA5: pdu data 18 to 21 byte
func (o *BLEDP_Type) SetANT_PDU_DATA5(value uint32) {
	volatile.StoreUint32(&o.ANT_PDU_DATA5.Reg, value)
}
func (o *BLEDP_Type) GetANT_PDU_DATA5() uint32 {
	return volatile.LoadUint32(&o.ANT_PDU_DATA5.Reg)
}

// BLEDP.ANT_PDU_DATA6: pdu data 22 to 25 byte
func (o *BLEDP_Type) SetANT_PDU_DATA6(value uint32) {
	volatile.StoreUint32(&o.ANT_PDU_DATA6.Reg, value)
}
func (o *BLEDP_Type) GetANT_PDU_DATA6() uint32 {
	return volatile.LoadUint32(&o.ANT_PDU_DATA6.Reg)
}

// BLEDP.ANT_PDU_DATA7: pdu data 26 to 29 byte
func (o *BLEDP_Type) SetANT_PDU_DATA7(value uint32) {
	volatile.StoreUint32(&o.ANT_PDU_DATA7.Reg, value)
}
func (o *BLEDP_Type) GetANT_PDU_DATA7() uint32 {
	return volatile.LoadUint32(&o.ANT_PDU_DATA7.Reg)
}

// BLEDP.CRCSEED: crc seed
func (o *BLEDP_Type) SetCRCSEED_CRC_SEED_IN(value uint32) {
	volatile.StoreUint32(&o.CRCSEED.Reg, volatile.LoadUint32(&o.CRCSEED.Reg)&^(0xffffff)|value)
}
func (o *BLEDP_Type) GetCRCSEED_CRC_SEED_IN() uint32 {
	return volatile.LoadUint32(&o.CRCSEED.Reg) & 0xffffff
}
func (o *BLEDP_Type) SetCRCSEED_CRC_SEED_WEN(value uint32) {
	volatile.StoreUint32(&o.CRCSEED.Reg, volatile.LoadUint32(&o.CRCSEED.Reg)&^(0x1000000)|value<<24)
}
func (o *BLEDP_Type) GetCRCSEED_CRC_SEED_WEN() uint32 {
	return (volatile.LoadUint32(&o.CRCSEED.Reg) & 0x1000000) >> 24
}

// BLEDP.DP_FUNCTION_CTRL: datapath function control register
func (o *BLEDP_Type) SetDP_FUNCTION_CTRL_DP_STATISTICS_SEL(value uint32) {
	volatile.StoreUint32(&o.DP_FUNCTION_CTRL.Reg, volatile.LoadUint32(&o.DP_FUNCTION_CTRL.Reg)&^(0x7)|value)
}
func (o *BLEDP_Type) GetDP_FUNCTION_CTRL_DP_STATISTICS_SEL() uint32 {
	return volatile.LoadUint32(&o.DP_FUNCTION_CTRL.Reg) & 0x7
}
func (o *BLEDP_Type) SetDP_FUNCTION_CTRL_CHF_COEF_WEN(value uint32) {
	volatile.StoreUint32(&o.DP_FUNCTION_CTRL.Reg, volatile.LoadUint32(&o.DP_FUNCTION_CTRL.Reg)&^(0x8)|value<<3)
}
func (o *BLEDP_Type) GetDP_FUNCTION_CTRL_CHF_COEF_WEN() uint32 {
	return (volatile.LoadUint32(&o.DP_FUNCTION_CTRL.Reg) & 0x8) >> 3
}
func (o *BLEDP_Type) SetDP_FUNCTION_CTRL_CHF_COEF_IDX(value uint32) {
	volatile.StoreUint32(&o.DP_FUNCTION_CTRL.Reg, volatile.LoadUint32(&o.DP_FUNCTION_CTRL.Reg)&^(0x30)|value<<4)
}
func (o *BLEDP_Type) GetDP_FUNCTION_CTRL_CHF_COEF_IDX() uint32 {
	return (volatile.LoadUint32(&o.DP_FUNCTION_CTRL.Reg) & 0x30) >> 4
}
func (o *BLEDP_Type) SetDP_FUNCTION_CTRL_LP_SNR_LEN_AUTO(value uint32) {
	volatile.StoreUint32(&o.DP_FUNCTION_CTRL.Reg, volatile.LoadUint32(&o.DP_FUNCTION_CTRL.Reg)&^(0x40)|value<<6)
}
func (o *BLEDP_Type) GetDP_FUNCTION_CTRL_LP_SNR_LEN_AUTO() uint32 {
	return (volatile.LoadUint32(&o.DP_FUNCTION_CTRL.Reg) & 0x40) >> 6
}
func (o *BLEDP_Type) SetDP_FUNCTION_CTRL_DOUT_ADJ_DIS(value uint32) {
	volatile.StoreUint32(&o.DP_FUNCTION_CTRL.Reg, volatile.LoadUint32(&o.DP_FUNCTION_CTRL.Reg)&^(0x80)|value<<7)
}
func (o *BLEDP_Type) GetDP_FUNCTION_CTRL_DOUT_ADJ_DIS() uint32 {
	return (volatile.LoadUint32(&o.DP_FUNCTION_CTRL.Reg) & 0x80) >> 7
}
func (o *BLEDP_Type) SetDP_FUNCTION_CTRL_LP_ADJ_MODE(value uint32) {
	volatile.StoreUint32(&o.DP_FUNCTION_CTRL.Reg, volatile.LoadUint32(&o.DP_FUNCTION_CTRL.Reg)&^(0x100)|value<<8)
}
func (o *BLEDP_Type) GetDP_FUNCTION_CTRL_LP_ADJ_MODE() uint32 {
	return (volatile.LoadUint32(&o.DP_FUNCTION_CTRL.Reg) & 0x100) >> 8
}
func (o *BLEDP_Type) SetDP_FUNCTION_CTRL_FR_OFFSET_EN(value uint32) {
	volatile.StoreUint32(&o.DP_FUNCTION_CTRL.Reg, volatile.LoadUint32(&o.DP_FUNCTION_CTRL.Reg)&^(0x200)|value<<9)
}
func (o *BLEDP_Type) GetDP_FUNCTION_CTRL_FR_OFFSET_EN() uint32 {
	return (volatile.LoadUint32(&o.DP_FUNCTION_CTRL.Reg) & 0x200) >> 9
}
func (o *BLEDP_Type) SetDP_FUNCTION_CTRL_DC_AVE_EN(value uint32) {
	volatile.StoreUint32(&o.DP_FUNCTION_CTRL.Reg, volatile.LoadUint32(&o.DP_FUNCTION_CTRL.Reg)&^(0x400)|value<<10)
}
func (o *BLEDP_Type) GetDP_FUNCTION_CTRL_DC_AVE_EN() uint32 {
	return (volatile.LoadUint32(&o.DP_FUNCTION_CTRL.Reg) & 0x400) >> 10
}
func (o *BLEDP_Type) SetDP_FUNCTION_CTRL_FIX_DELAY_EN(value uint32) {
	volatile.StoreUint32(&o.DP_FUNCTION_CTRL.Reg, volatile.LoadUint32(&o.DP_FUNCTION_CTRL.Reg)&^(0x800)|value<<11)
}
func (o *BLEDP_Type) GetDP_FUNCTION_CTRL_FIX_DELAY_EN() uint32 {
	return (volatile.LoadUint32(&o.DP_FUNCTION_CTRL.Reg) & 0x800) >> 11
}
func (o *BLEDP_Type) SetDP_FUNCTION_CTRL_TRACK_LEN(value uint32) {
	volatile.StoreUint32(&o.DP_FUNCTION_CTRL.Reg, volatile.LoadUint32(&o.DP_FUNCTION_CTRL.Reg)&^(0x3000)|value<<12)
}
func (o *BLEDP_Type) GetDP_FUNCTION_CTRL_TRACK_LEN() uint32 {
	return (volatile.LoadUint32(&o.DP_FUNCTION_CTRL.Reg) & 0x3000) >> 12
}
func (o *BLEDP_Type) SetDP_FUNCTION_CTRL_TRACK_LEN_WEN(value uint32) {
	volatile.StoreUint32(&o.DP_FUNCTION_CTRL.Reg, volatile.LoadUint32(&o.DP_FUNCTION_CTRL.Reg)&^(0x4000)|value<<14)
}
func (o *BLEDP_Type) GetDP_FUNCTION_CTRL_TRACK_LEN_WEN() uint32 {
	return (volatile.LoadUint32(&o.DP_FUNCTION_CTRL.Reg) & 0x4000) >> 14
}
func (o *BLEDP_Type) SetDP_FUNCTION_CTRL_XCORR_FILT_EN(value uint32) {
	volatile.StoreUint32(&o.DP_FUNCTION_CTRL.Reg, volatile.LoadUint32(&o.DP_FUNCTION_CTRL.Reg)&^(0x10000)|value<<16)
}
func (o *BLEDP_Type) GetDP_FUNCTION_CTRL_XCORR_FILT_EN() uint32 {
	return (volatile.LoadUint32(&o.DP_FUNCTION_CTRL.Reg) & 0x10000) >> 16
}
func (o *BLEDP_Type) SetDP_FUNCTION_CTRL_XCORR_FULLWIN_EN(value uint32) {
	volatile.StoreUint32(&o.DP_FUNCTION_CTRL.Reg, volatile.LoadUint32(&o.DP_FUNCTION_CTRL.Reg)&^(0x20000)|value<<17)
}
func (o *BLEDP_Type) GetDP_FUNCTION_CTRL_XCORR_FULLWIN_EN() uint32 {
	return (volatile.LoadUint32(&o.DP_FUNCTION_CTRL.Reg) & 0x20000) >> 17
}
func (o *BLEDP_Type) SetDP_FUNCTION_CTRL_XCORR_AA_LEN(value uint32) {
	volatile.StoreUint32(&o.DP_FUNCTION_CTRL.Reg, volatile.LoadUint32(&o.DP_FUNCTION_CTRL.Reg)&^(0x40000)|value<<18)
}
func (o *BLEDP_Type) GetDP_FUNCTION_CTRL_XCORR_AA_LEN() uint32 {
	return (volatile.LoadUint32(&o.DP_FUNCTION_CTRL.Reg) & 0x40000) >> 18
}
func (o *BLEDP_Type) SetDP_FUNCTION_CTRL_XCORR_AA_LEN_WEN(value uint32) {
	volatile.StoreUint32(&o.DP_FUNCTION_CTRL.Reg, volatile.LoadUint32(&o.DP_FUNCTION_CTRL.Reg)&^(0x80000)|value<<19)
}
func (o *BLEDP_Type) GetDP_FUNCTION_CTRL_XCORR_AA_LEN_WEN() uint32 {
	return (volatile.LoadUint32(&o.DP_FUNCTION_CTRL.Reg) & 0x80000) >> 19
}
func (o *BLEDP_Type) SetDP_FUNCTION_CTRL_XCORR_WIN_AUTO_EN(value uint32) {
	volatile.StoreUint32(&o.DP_FUNCTION_CTRL.Reg, volatile.LoadUint32(&o.DP_FUNCTION_CTRL.Reg)&^(0x100000)|value<<20)
}
func (o *BLEDP_Type) GetDP_FUNCTION_CTRL_XCORR_WIN_AUTO_EN() uint32 {
	return (volatile.LoadUint32(&o.DP_FUNCTION_CTRL.Reg) & 0x100000) >> 20
}
func (o *BLEDP_Type) SetDP_FUNCTION_CTRL_RESAMPLER_TAP(value uint32) {
	volatile.StoreUint32(&o.DP_FUNCTION_CTRL.Reg, volatile.LoadUint32(&o.DP_FUNCTION_CTRL.Reg)&^(0x200000)|value<<21)
}
func (o *BLEDP_Type) GetDP_FUNCTION_CTRL_RESAMPLER_TAP() uint32 {
	return (volatile.LoadUint32(&o.DP_FUNCTION_CTRL.Reg) & 0x200000) >> 21
}
func (o *BLEDP_Type) SetDP_FUNCTION_CTRL_RESAMPLER_TAP_WEN(value uint32) {
	volatile.StoreUint32(&o.DP_FUNCTION_CTRL.Reg, volatile.LoadUint32(&o.DP_FUNCTION_CTRL.Reg)&^(0x400000)|value<<22)
}
func (o *BLEDP_Type) GetDP_FUNCTION_CTRL_RESAMPLER_TAP_WEN() uint32 {
	return (volatile.LoadUint32(&o.DP_FUNCTION_CTRL.Reg) & 0x400000) >> 22
}
func (o *BLEDP_Type) SetDP_FUNCTION_CTRL_RESAMPLER_BP(value uint32) {
	volatile.StoreUint32(&o.DP_FUNCTION_CTRL.Reg, volatile.LoadUint32(&o.DP_FUNCTION_CTRL.Reg)&^(0x800000)|value<<23)
}
func (o *BLEDP_Type) GetDP_FUNCTION_CTRL_RESAMPLER_BP() uint32 {
	return (volatile.LoadUint32(&o.DP_FUNCTION_CTRL.Reg) & 0x800000) >> 23
}
func (o *BLEDP_Type) SetDP_FUNCTION_CTRL_FAGC_WIN_LEN(value uint32) {
	volatile.StoreUint32(&o.DP_FUNCTION_CTRL.Reg, volatile.LoadUint32(&o.DP_FUNCTION_CTRL.Reg)&^(0x1000000)|value<<24)
}
func (o *BLEDP_Type) GetDP_FUNCTION_CTRL_FAGC_WIN_LEN() uint32 {
	return (volatile.LoadUint32(&o.DP_FUNCTION_CTRL.Reg) & 0x1000000) >> 24
}
func (o *BLEDP_Type) SetDP_FUNCTION_CTRL_FAGC_WEN(value uint32) {
	volatile.StoreUint32(&o.DP_FUNCTION_CTRL.Reg, volatile.LoadUint32(&o.DP_FUNCTION_CTRL.Reg)&^(0x2000000)|value<<25)
}
func (o *BLEDP_Type) GetDP_FUNCTION_CTRL_FAGC_WEN() uint32 {
	return (volatile.LoadUint32(&o.DP_FUNCTION_CTRL.Reg) & 0x2000000) >> 25
}
func (o *BLEDP_Type) SetDP_FUNCTION_CTRL_HP_CFO_EN(value uint32) {
	volatile.StoreUint32(&o.DP_FUNCTION_CTRL.Reg, volatile.LoadUint32(&o.DP_FUNCTION_CTRL.Reg)&^(0x4000000)|value<<26)
}
func (o *BLEDP_Type) GetDP_FUNCTION_CTRL_HP_CFO_EN() uint32 {
	return (volatile.LoadUint32(&o.DP_FUNCTION_CTRL.Reg) & 0x4000000) >> 26
}
func (o *BLEDP_Type) SetDP_FUNCTION_CTRL_CFO_TRACK_EN(value uint32) {
	volatile.StoreUint32(&o.DP_FUNCTION_CTRL.Reg, volatile.LoadUint32(&o.DP_FUNCTION_CTRL.Reg)&^(0x8000000)|value<<27)
}
func (o *BLEDP_Type) GetDP_FUNCTION_CTRL_CFO_TRACK_EN() uint32 {
	return (volatile.LoadUint32(&o.DP_FUNCTION_CTRL.Reg) & 0x8000000) >> 27
}
func (o *BLEDP_Type) SetDP_FUNCTION_CTRL_CFO_INI_EN(value uint32) {
	volatile.StoreUint32(&o.DP_FUNCTION_CTRL.Reg, volatile.LoadUint32(&o.DP_FUNCTION_CTRL.Reg)&^(0x10000000)|value<<28)
}
func (o *BLEDP_Type) GetDP_FUNCTION_CTRL_CFO_INI_EN() uint32 {
	return (volatile.LoadUint32(&o.DP_FUNCTION_CTRL.Reg) & 0x10000000) >> 28
}
func (o *BLEDP_Type) SetDP_FUNCTION_CTRL_ADC_IN_FLIP(value uint32) {
	volatile.StoreUint32(&o.DP_FUNCTION_CTRL.Reg, volatile.LoadUint32(&o.DP_FUNCTION_CTRL.Reg)&^(0x20000000)|value<<29)
}
func (o *BLEDP_Type) GetDP_FUNCTION_CTRL_ADC_IN_FLIP() uint32 {
	return (volatile.LoadUint32(&o.DP_FUNCTION_CTRL.Reg) & 0x20000000) >> 29
}
func (o *BLEDP_Type) SetDP_FUNCTION_CTRL_TX_EN_MODE(value uint32) {
	volatile.StoreUint32(&o.DP_FUNCTION_CTRL.Reg, volatile.LoadUint32(&o.DP_FUNCTION_CTRL.Reg)&^(0x40000000)|value<<30)
}
func (o *BLEDP_Type) GetDP_FUNCTION_CTRL_TX_EN_MODE() uint32 {
	return (volatile.LoadUint32(&o.DP_FUNCTION_CTRL.Reg) & 0x40000000) >> 30
}
func (o *BLEDP_Type) SetDP_FUNCTION_CTRL_RX_EN_MODE(value uint32) {
	volatile.StoreUint32(&o.DP_FUNCTION_CTRL.Reg, volatile.LoadUint32(&o.DP_FUNCTION_CTRL.Reg)&^(0x80000000)|value<<31)
}
func (o *BLEDP_Type) GetDP_FUNCTION_CTRL_RX_EN_MODE() uint32 {
	return (volatile.LoadUint32(&o.DP_FUNCTION_CTRL.Reg) & 0x80000000) >> 31
}

// BLEDP.DP_TEST_CTRL: datapath test iinterface register
func (o *BLEDP_Type) SetDP_TEST_CTRL_TIF_SEL(value uint32) {
	volatile.StoreUint32(&o.DP_TEST_CTRL.Reg, volatile.LoadUint32(&o.DP_TEST_CTRL.Reg)&^(0xff)|value)
}
func (o *BLEDP_Type) GetDP_TEST_CTRL_TIF_SEL() uint32 {
	return volatile.LoadUint32(&o.DP_TEST_CTRL.Reg) & 0xff
}
func (o *BLEDP_Type) SetDP_TEST_CTRL_TIF_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.DP_TEST_CTRL.Reg, volatile.LoadUint32(&o.DP_TEST_CTRL.Reg)&^(0x300)|value<<8)
}
func (o *BLEDP_Type) GetDP_TEST_CTRL_TIF_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.DP_TEST_CTRL.Reg) & 0x300) >> 8
}
func (o *BLEDP_Type) SetDP_TEST_CTRL_CORDIC_DAC_OUT(value uint32) {
	volatile.StoreUint32(&o.DP_TEST_CTRL.Reg, volatile.LoadUint32(&o.DP_TEST_CTRL.Reg)&^(0x800)|value<<11)
}
func (o *BLEDP_Type) GetDP_TEST_CTRL_CORDIC_DAC_OUT() uint32 {
	return (volatile.LoadUint32(&o.DP_TEST_CTRL.Reg) & 0x800) >> 11
}
func (o *BLEDP_Type) SetDP_TEST_CTRL_TIF_EN(value uint32) {
	volatile.StoreUint32(&o.DP_TEST_CTRL.Reg, volatile.LoadUint32(&o.DP_TEST_CTRL.Reg)&^(0x1000)|value<<12)
}
func (o *BLEDP_Type) GetDP_TEST_CTRL_TIF_EN() uint32 {
	return (volatile.LoadUint32(&o.DP_TEST_CTRL.Reg) & 0x1000) >> 12
}
func (o *BLEDP_Type) SetDP_TEST_CTRL_IMR_INV(value uint32) {
	volatile.StoreUint32(&o.DP_TEST_CTRL.Reg, volatile.LoadUint32(&o.DP_TEST_CTRL.Reg)&^(0x2000)|value<<13)
}
func (o *BLEDP_Type) GetDP_TEST_CTRL_IMR_INV() uint32 {
	return (volatile.LoadUint32(&o.DP_TEST_CTRL.Reg) & 0x2000) >> 13
}
func (o *BLEDP_Type) SetDP_TEST_CTRL_CLK_TX_GATE_DIS(value uint32) {
	volatile.StoreUint32(&o.DP_TEST_CTRL.Reg, volatile.LoadUint32(&o.DP_TEST_CTRL.Reg)&^(0x4000)|value<<14)
}
func (o *BLEDP_Type) GetDP_TEST_CTRL_CLK_TX_GATE_DIS() uint32 {
	return (volatile.LoadUint32(&o.DP_TEST_CTRL.Reg) & 0x4000) >> 14
}
func (o *BLEDP_Type) SetDP_TEST_CTRL_BUF_FULL_OFFRF_DIS(value uint32) {
	volatile.StoreUint32(&o.DP_TEST_CTRL.Reg, volatile.LoadUint32(&o.DP_TEST_CTRL.Reg)&^(0x8000)|value<<15)
}
func (o *BLEDP_Type) GetDP_TEST_CTRL_BUF_FULL_OFFRF_DIS() uint32 {
	return (volatile.LoadUint32(&o.DP_TEST_CTRL.Reg) & 0x8000) >> 15
}
func (o *BLEDP_Type) SetDP_TEST_CTRL_CLK_BUST_GATE_DIS(value uint32) {
	volatile.StoreUint32(&o.DP_TEST_CTRL.Reg, volatile.LoadUint32(&o.DP_TEST_CTRL.Reg)&^(0x10000)|value<<16)
}
func (o *BLEDP_Type) GetDP_TEST_CTRL_CLK_BUST_GATE_DIS() uint32 {
	return (volatile.LoadUint32(&o.DP_TEST_CTRL.Reg) & 0x10000) >> 16
}
func (o *BLEDP_Type) SetDP_TEST_CTRL_CLK_RX_GATE_DIS(value uint32) {
	volatile.StoreUint32(&o.DP_TEST_CTRL.Reg, volatile.LoadUint32(&o.DP_TEST_CTRL.Reg)&^(0x20000)|value<<17)
}
func (o *BLEDP_Type) GetDP_TEST_CTRL_CLK_RX_GATE_DIS() uint32 {
	return (volatile.LoadUint32(&o.DP_TEST_CTRL.Reg) & 0x20000) >> 17
}
func (o *BLEDP_Type) SetDP_TEST_CTRL_CLK_LPDET_GATE_DIS(value uint32) {
	volatile.StoreUint32(&o.DP_TEST_CTRL.Reg, volatile.LoadUint32(&o.DP_TEST_CTRL.Reg)&^(0x40000)|value<<18)
}
func (o *BLEDP_Type) GetDP_TEST_CTRL_CLK_LPDET_GATE_DIS() uint32 {
	return (volatile.LoadUint32(&o.DP_TEST_CTRL.Reg) & 0x40000) >> 18
}
func (o *BLEDP_Type) SetDP_TEST_CTRL_CLK_HPDET_GATE_DIS(value uint32) {
	volatile.StoreUint32(&o.DP_TEST_CTRL.Reg, volatile.LoadUint32(&o.DP_TEST_CTRL.Reg)&^(0x80000)|value<<19)
}
func (o *BLEDP_Type) GetDP_TEST_CTRL_CLK_HPDET_GATE_DIS() uint32 {
	return (volatile.LoadUint32(&o.DP_TEST_CTRL.Reg) & 0x80000) >> 19
}
func (o *BLEDP_Type) SetDP_TEST_CTRL_CLK_RFE_GATE_DIS(value uint32) {
	volatile.StoreUint32(&o.DP_TEST_CTRL.Reg, volatile.LoadUint32(&o.DP_TEST_CTRL.Reg)&^(0x100000)|value<<20)
}
func (o *BLEDP_Type) GetDP_TEST_CTRL_CLK_RFE_GATE_DIS() uint32 {
	return (volatile.LoadUint32(&o.DP_TEST_CTRL.Reg) & 0x100000) >> 20
}
func (o *BLEDP_Type) SetDP_TEST_CTRL_IQSWAP_XOR(value uint32) {
	volatile.StoreUint32(&o.DP_TEST_CTRL.Reg, volatile.LoadUint32(&o.DP_TEST_CTRL.Reg)&^(0x200000)|value<<21)
}
func (o *BLEDP_Type) GetDP_TEST_CTRL_IQSWAP_XOR() uint32 {
	return (volatile.LoadUint32(&o.DP_TEST_CTRL.Reg) & 0x200000) >> 21
}
func (o *BLEDP_Type) SetDP_TEST_CTRL_DAC_TEST_EN(value uint32) {
	volatile.StoreUint32(&o.DP_TEST_CTRL.Reg, volatile.LoadUint32(&o.DP_TEST_CTRL.Reg)&^(0x800000)|value<<23)
}
func (o *BLEDP_Type) GetDP_TEST_CTRL_DAC_TEST_EN() uint32 {
	return (volatile.LoadUint32(&o.DP_TEST_CTRL.Reg) & 0x800000) >> 23
}
func (o *BLEDP_Type) SetDP_TEST_CTRL_DAC_TEST(value uint32) {
	volatile.StoreUint32(&o.DP_TEST_CTRL.Reg, volatile.LoadUint32(&o.DP_TEST_CTRL.Reg)&^(0xff000000)|value<<24)
}
func (o *BLEDP_Type) GetDP_TEST_CTRL_DAC_TEST() uint32 {
	return (volatile.LoadUint32(&o.DP_TEST_CTRL.Reg) & 0xff000000) >> 24
}

// BLEDP.BLE_DP_STATUS1: datapath status register 1
func (o *BLEDP_Type) SetBLE_DP_STATUS1_SNR_EST(value uint32) {
	volatile.StoreUint32(&o.BLE_DP_STATUS1.Reg, volatile.LoadUint32(&o.BLE_DP_STATUS1.Reg)&^(0xff)|value)
}
func (o *BLEDP_Type) GetBLE_DP_STATUS1_SNR_EST() uint32 {
	return volatile.LoadUint32(&o.BLE_DP_STATUS1.Reg) & 0xff
}
func (o *BLEDP_Type) SetBLE_DP_STATUS1_CNR_EST(value uint32) {
	volatile.StoreUint32(&o.BLE_DP_STATUS1.Reg, volatile.LoadUint32(&o.BLE_DP_STATUS1.Reg)&^(0x3f00)|value<<8)
}
func (o *BLEDP_Type) GetBLE_DP_STATUS1_CNR_EST() uint32 {
	return (volatile.LoadUint32(&o.BLE_DP_STATUS1.Reg) & 0x3f00) >> 8
}
func (o *BLEDP_Type) SetBLE_DP_STATUS1_AGC_RSSI(value uint32) {
	volatile.StoreUint32(&o.BLE_DP_STATUS1.Reg, volatile.LoadUint32(&o.BLE_DP_STATUS1.Reg)&^(0xff0000)|value<<16)
}
func (o *BLEDP_Type) GetBLE_DP_STATUS1_AGC_RSSI() uint32 {
	return (volatile.LoadUint32(&o.BLE_DP_STATUS1.Reg) & 0xff0000) >> 16
}
func (o *BLEDP_Type) SetBLE_DP_STATUS1_AGC_RSSI_READY(value uint32) {
	volatile.StoreUint32(&o.BLE_DP_STATUS1.Reg, volatile.LoadUint32(&o.BLE_DP_STATUS1.Reg)&^(0x1000000)|value<<24)
}
func (o *BLEDP_Type) GetBLE_DP_STATUS1_AGC_RSSI_READY() uint32 {
	return (volatile.LoadUint32(&o.BLE_DP_STATUS1.Reg) & 0x1000000) >> 24
}
func (o *BLEDP_Type) SetBLE_DP_STATUS1_SNR_VLD(value uint32) {
	volatile.StoreUint32(&o.BLE_DP_STATUS1.Reg, volatile.LoadUint32(&o.BLE_DP_STATUS1.Reg)&^(0x2000000)|value<<25)
}
func (o *BLEDP_Type) GetBLE_DP_STATUS1_SNR_VLD() uint32 {
	return (volatile.LoadUint32(&o.BLE_DP_STATUS1.Reg) & 0x2000000) >> 25
}
func (o *BLEDP_Type) SetBLE_DP_STATUS1_CNR_VLD(value uint32) {
	volatile.StoreUint32(&o.BLE_DP_STATUS1.Reg, volatile.LoadUint32(&o.BLE_DP_STATUS1.Reg)&^(0x4000000)|value<<26)
}
func (o *BLEDP_Type) GetBLE_DP_STATUS1_CNR_VLD() uint32 {
	return (volatile.LoadUint32(&o.BLE_DP_STATUS1.Reg) & 0x4000000) >> 26
}
func (o *BLEDP_Type) SetBLE_DP_STATUS1_TX_BUSY(value uint32) {
	volatile.StoreUint32(&o.BLE_DP_STATUS1.Reg, volatile.LoadUint32(&o.BLE_DP_STATUS1.Reg)&^(0x8000000)|value<<27)
}
func (o *BLEDP_Type) GetBLE_DP_STATUS1_TX_BUSY() uint32 {
	return (volatile.LoadUint32(&o.BLE_DP_STATUS1.Reg) & 0x8000000) >> 27
}

// BLEDP.BLE_DP_STATUS2: datapath status register 2
func (o *BLEDP_Type) SetBLE_DP_STATUS2_VALID_PCK_NUM(value uint32) {
	volatile.StoreUint32(&o.BLE_DP_STATUS2.Reg, volatile.LoadUint32(&o.BLE_DP_STATUS2.Reg)&^(0xffff)|value)
}
func (o *BLEDP_Type) GetBLE_DP_STATUS2_VALID_PCK_NUM() uint32 {
	return volatile.LoadUint32(&o.BLE_DP_STATUS2.Reg) & 0xffff
}
func (o *BLEDP_Type) SetBLE_DP_STATUS2_AA_ERR_NUM(value uint32) {
	volatile.StoreUint32(&o.BLE_DP_STATUS2.Reg, volatile.LoadUint32(&o.BLE_DP_STATUS2.Reg)&^(0x3f0000)|value<<16)
}
func (o *BLEDP_Type) GetBLE_DP_STATUS2_AA_ERR_NUM() uint32 {
	return (volatile.LoadUint32(&o.BLE_DP_STATUS2.Reg) & 0x3f0000) >> 16
}
func (o *BLEDP_Type) SetBLE_DP_STATUS2_CRC_ERROR(value uint32) {
	volatile.StoreUint32(&o.BLE_DP_STATUS2.Reg, volatile.LoadUint32(&o.BLE_DP_STATUS2.Reg)&^(0x20000000)|value<<29)
}
func (o *BLEDP_Type) GetBLE_DP_STATUS2_CRC_ERROR() uint32 {
	return (volatile.LoadUint32(&o.BLE_DP_STATUS2.Reg) & 0x20000000) >> 29
}
func (o *BLEDP_Type) SetBLE_DP_STATUS2_BURST_DET(value uint32) {
	volatile.StoreUint32(&o.BLE_DP_STATUS2.Reg, volatile.LoadUint32(&o.BLE_DP_STATUS2.Reg)&^(0x40000000)|value<<30)
}
func (o *BLEDP_Type) GetBLE_DP_STATUS2_BURST_DET() uint32 {
	return (volatile.LoadUint32(&o.BLE_DP_STATUS2.Reg) & 0x40000000) >> 30
}
func (o *BLEDP_Type) SetBLE_DP_STATUS2_DP_STATUS_VLD_0(value uint32) {
	volatile.StoreUint32(&o.BLE_DP_STATUS2.Reg, volatile.LoadUint32(&o.BLE_DP_STATUS2.Reg)&^(0x80000000)|value<<31)
}
func (o *BLEDP_Type) GetBLE_DP_STATUS2_DP_STATUS_VLD_0() uint32 {
	return (volatile.LoadUint32(&o.BLE_DP_STATUS2.Reg) & 0x80000000) >> 31
}

// BLEDP.BLE_DP_STATUS3: datapath status register 3
func (o *BLEDP_Type) SetBLE_DP_STATUS3_FD_CFO_TRACK(value uint32) {
	volatile.StoreUint32(&o.BLE_DP_STATUS3.Reg, volatile.LoadUint32(&o.BLE_DP_STATUS3.Reg)&^(0x7ff)|value)
}
func (o *BLEDP_Type) GetBLE_DP_STATUS3_FD_CFO_TRACK() uint32 {
	return volatile.LoadUint32(&o.BLE_DP_STATUS3.Reg) & 0x7ff
}
func (o *BLEDP_Type) SetBLE_DP_STATUS3_CFO_EST_FD(value uint32) {
	volatile.StoreUint32(&o.BLE_DP_STATUS3.Reg, volatile.LoadUint32(&o.BLE_DP_STATUS3.Reg)&^(0x7ff0000)|value<<16)
}
func (o *BLEDP_Type) GetBLE_DP_STATUS3_CFO_EST_FD() uint32 {
	return (volatile.LoadUint32(&o.BLE_DP_STATUS3.Reg) & 0x7ff0000) >> 16
}

// BLEDP.BLE_DP_STATUS4: datapath status register 4
func (o *BLEDP_Type) SetBLE_DP_STATUS4_RESAMPLER_PH(value uint32) {
	volatile.StoreUint32(&o.BLE_DP_STATUS4.Reg, volatile.LoadUint32(&o.BLE_DP_STATUS4.Reg)&^(0x3ff)|value)
}
func (o *BLEDP_Type) GetBLE_DP_STATUS4_RESAMPLER_PH() uint32 {
	return volatile.LoadUint32(&o.BLE_DP_STATUS4.Reg) & 0x3ff
}
func (o *BLEDP_Type) SetBLE_DP_STATUS4_HP_CFO(value uint32) {
	volatile.StoreUint32(&o.BLE_DP_STATUS4.Reg, volatile.LoadUint32(&o.BLE_DP_STATUS4.Reg)&^(0xfff0000)|value<<16)
}
func (o *BLEDP_Type) GetBLE_DP_STATUS4_HP_CFO() uint32 {
	return (volatile.LoadUint32(&o.BLE_DP_STATUS4.Reg) & 0xfff0000) >> 16
}
func (o *BLEDP_Type) SetBLE_DP_STATUS4_HP_CFO_VLD(value uint32) {
	volatile.StoreUint32(&o.BLE_DP_STATUS4.Reg, volatile.LoadUint32(&o.BLE_DP_STATUS4.Reg)&^(0x80000000)|value<<31)
}
func (o *BLEDP_Type) GetBLE_DP_STATUS4_HP_CFO_VLD() uint32 {
	return (volatile.LoadUint32(&o.BLE_DP_STATUS4.Reg) & 0x80000000) >> 31
}

// BLEDP.RX_FRONT_END_CTRL1: rx front end control register 1
func (o *BLEDP_Type) SetRX_FRONT_END_CTRL1_CFO_COMP(value uint32) {
	volatile.StoreUint32(&o.RX_FRONT_END_CTRL1.Reg, volatile.LoadUint32(&o.RX_FRONT_END_CTRL1.Reg)&^(0x7fff)|value)
}
func (o *BLEDP_Type) GetRX_FRONT_END_CTRL1_CFO_COMP() uint32 {
	return volatile.LoadUint32(&o.RX_FRONT_END_CTRL1.Reg) & 0x7fff
}
func (o *BLEDP_Type) SetRX_FRONT_END_CTRL1_DCNOTCH_GIN(value uint32) {
	volatile.StoreUint32(&o.RX_FRONT_END_CTRL1.Reg, volatile.LoadUint32(&o.RX_FRONT_END_CTRL1.Reg)&^(0x30000)|value<<16)
}
func (o *BLEDP_Type) GetRX_FRONT_END_CTRL1_DCNOTCH_GIN() uint32 {
	return (volatile.LoadUint32(&o.RX_FRONT_END_CTRL1.Reg) & 0x30000) >> 16
}

// BLEDP.RX_FRONT_END_CTRL2: rx front end control register 2
func (o *BLEDP_Type) SetRX_FRONT_END_CTRL2_FAGC_GAIN(value uint32) {
	volatile.StoreUint32(&o.RX_FRONT_END_CTRL2.Reg, volatile.LoadUint32(&o.RX_FRONT_END_CTRL2.Reg)&^(0x7ff)|value)
}
func (o *BLEDP_Type) GetRX_FRONT_END_CTRL2_FAGC_GAIN() uint32 {
	return volatile.LoadUint32(&o.RX_FRONT_END_CTRL2.Reg) & 0x7ff
}
func (o *BLEDP_Type) SetRX_FRONT_END_CTRL2_FAGC_INI_VAL(value uint32) {
	volatile.StoreUint32(&o.RX_FRONT_END_CTRL2.Reg, volatile.LoadUint32(&o.RX_FRONT_END_CTRL2.Reg)&^(0x800)|value<<11)
}
func (o *BLEDP_Type) GetRX_FRONT_END_CTRL2_FAGC_INI_VAL() uint32 {
	return (volatile.LoadUint32(&o.RX_FRONT_END_CTRL2.Reg) & 0x800) >> 11
}
func (o *BLEDP_Type) SetRX_FRONT_END_CTRL2_CNR_IDX_DELTA(value uint32) {
	volatile.StoreUint32(&o.RX_FRONT_END_CTRL2.Reg, volatile.LoadUint32(&o.RX_FRONT_END_CTRL2.Reg)&^(0xf000)|value<<12)
}
func (o *BLEDP_Type) GetRX_FRONT_END_CTRL2_CNR_IDX_DELTA() uint32 {
	return (volatile.LoadUint32(&o.RX_FRONT_END_CTRL2.Reg) & 0xf000) >> 12
}
func (o *BLEDP_Type) SetRX_FRONT_END_CTRL2_FAGC_REF(value uint32) {
	volatile.StoreUint32(&o.RX_FRONT_END_CTRL2.Reg, volatile.LoadUint32(&o.RX_FRONT_END_CTRL2.Reg)&^(0xff0000)|value<<16)
}
func (o *BLEDP_Type) GetRX_FRONT_END_CTRL2_FAGC_REF() uint32 {
	return (volatile.LoadUint32(&o.RX_FRONT_END_CTRL2.Reg) & 0xff0000) >> 16
}
func (o *BLEDP_Type) SetRX_FRONT_END_CTRL2_CORDIC_MIN_VIN_TH(value uint32) {
	volatile.StoreUint32(&o.RX_FRONT_END_CTRL2.Reg, volatile.LoadUint32(&o.RX_FRONT_END_CTRL2.Reg)&^(0xf000000)|value<<24)
}
func (o *BLEDP_Type) GetRX_FRONT_END_CTRL2_CORDIC_MIN_VIN_TH() uint32 {
	return (volatile.LoadUint32(&o.RX_FRONT_END_CTRL2.Reg) & 0xf000000) >> 24
}
func (o *BLEDP_Type) SetRX_FRONT_END_CTRL2_FREQ_TRADE_EN(value uint32) {
	volatile.StoreUint32(&o.RX_FRONT_END_CTRL2.Reg, volatile.LoadUint32(&o.RX_FRONT_END_CTRL2.Reg)&^(0x10000000)|value<<28)
}
func (o *BLEDP_Type) GetRX_FRONT_END_CTRL2_FREQ_TRADE_EN() uint32 {
	return (volatile.LoadUint32(&o.RX_FRONT_END_CTRL2.Reg) & 0x10000000) >> 28
}
func (o *BLEDP_Type) SetRX_FRONT_END_CTRL2_CHN_SHIFT(value uint32) {
	volatile.StoreUint32(&o.RX_FRONT_END_CTRL2.Reg, volatile.LoadUint32(&o.RX_FRONT_END_CTRL2.Reg)&^(0xe0000000)|value<<29)
}
func (o *BLEDP_Type) GetRX_FRONT_END_CTRL2_CHN_SHIFT() uint32 {
	return (volatile.LoadUint32(&o.RX_FRONT_END_CTRL2.Reg) & 0xe0000000) >> 29
}

// BLEDP.FREQ_DOMAIN_CTRL1: frequency domain control register 1
func (o *BLEDP_Type) SetFREQ_DOMAIN_CTRL1_SYNC_WORD_IN0(value uint32) {
	volatile.StoreUint32(&o.FREQ_DOMAIN_CTRL1.Reg, volatile.LoadUint32(&o.FREQ_DOMAIN_CTRL1.Reg)&^(0xff)|value)
}
func (o *BLEDP_Type) GetFREQ_DOMAIN_CTRL1_SYNC_WORD_IN0() uint32 {
	return volatile.LoadUint32(&o.FREQ_DOMAIN_CTRL1.Reg) & 0xff
}
func (o *BLEDP_Type) SetFREQ_DOMAIN_CTRL1_SYNC_WORD_WEN(value uint32) {
	volatile.StoreUint32(&o.FREQ_DOMAIN_CTRL1.Reg, volatile.LoadUint32(&o.FREQ_DOMAIN_CTRL1.Reg)&^(0x100)|value<<8)
}
func (o *BLEDP_Type) GetFREQ_DOMAIN_CTRL1_SYNC_WORD_WEN() uint32 {
	return (volatile.LoadUint32(&o.FREQ_DOMAIN_CTRL1.Reg) & 0x100) >> 8
}
func (o *BLEDP_Type) SetFREQ_DOMAIN_CTRL1_SYNC_P_SEL(value uint32) {
	volatile.StoreUint32(&o.FREQ_DOMAIN_CTRL1.Reg, volatile.LoadUint32(&o.FREQ_DOMAIN_CTRL1.Reg)&^(0x8000)|value<<15)
}
func (o *BLEDP_Type) GetFREQ_DOMAIN_CTRL1_SYNC_P_SEL() uint32 {
	return (volatile.LoadUint32(&o.FREQ_DOMAIN_CTRL1.Reg) & 0x8000) >> 15
}
func (o *BLEDP_Type) SetFREQ_DOMAIN_CTRL1_RD_EXBIT_EN(value uint32) {
	volatile.StoreUint32(&o.FREQ_DOMAIN_CTRL1.Reg, volatile.LoadUint32(&o.FREQ_DOMAIN_CTRL1.Reg)&^(0x10000)|value<<16)
}
func (o *BLEDP_Type) GetFREQ_DOMAIN_CTRL1_RD_EXBIT_EN() uint32 {
	return (volatile.LoadUint32(&o.FREQ_DOMAIN_CTRL1.Reg) & 0x10000) >> 16
}
func (o *BLEDP_Type) SetFREQ_DOMAIN_CTRL1_RFAGC_TRACK_DLY(value uint32) {
	volatile.StoreUint32(&o.FREQ_DOMAIN_CTRL1.Reg, volatile.LoadUint32(&o.FREQ_DOMAIN_CTRL1.Reg)&^(0xe0000)|value<<17)
}
func (o *BLEDP_Type) GetFREQ_DOMAIN_CTRL1_RFAGC_TRACK_DLY() uint32 {
	return (volatile.LoadUint32(&o.FREQ_DOMAIN_CTRL1.Reg) & 0xe0000) >> 17
}
func (o *BLEDP_Type) SetFREQ_DOMAIN_CTRL1_PROP_DF_16US(value uint32) {
	volatile.StoreUint32(&o.FREQ_DOMAIN_CTRL1.Reg, volatile.LoadUint32(&o.FREQ_DOMAIN_CTRL1.Reg)&^(0xff000000)|value<<24)
}
func (o *BLEDP_Type) GetFREQ_DOMAIN_CTRL1_PROP_DF_16US() uint32 {
	return (volatile.LoadUint32(&o.FREQ_DOMAIN_CTRL1.Reg) & 0xff000000) >> 24
}

// BLEDP.FREQ_DOMAIN_CTRL2: frequency domain control register 2
func (o *BLEDP_Type) SetFREQ_DOMAIN_CTRL2(value uint32) {
	volatile.StoreUint32(&o.FREQ_DOMAIN_CTRL2.Reg, value)
}
func (o *BLEDP_Type) GetFREQ_DOMAIN_CTRL2() uint32 {
	return volatile.LoadUint32(&o.FREQ_DOMAIN_CTRL2.Reg)
}

// BLEDP.FREQ_DOMAIN_CTRL3: frequency domain control register 3
func (o *BLEDP_Type) SetFREQ_DOMAIN_CTRL3_XCORR_PAR_TH3(value uint32) {
	volatile.StoreUint32(&o.FREQ_DOMAIN_CTRL3.Reg, volatile.LoadUint32(&o.FREQ_DOMAIN_CTRL3.Reg)&^(0x3f)|value)
}
func (o *BLEDP_Type) GetFREQ_DOMAIN_CTRL3_XCORR_PAR_TH3() uint32 {
	return volatile.LoadUint32(&o.FREQ_DOMAIN_CTRL3.Reg) & 0x3f
}
func (o *BLEDP_Type) SetFREQ_DOMAIN_CTRL3_XCORR_PAR_TH2(value uint32) {
	volatile.StoreUint32(&o.FREQ_DOMAIN_CTRL3.Reg, volatile.LoadUint32(&o.FREQ_DOMAIN_CTRL3.Reg)&^(0x3f00)|value<<8)
}
func (o *BLEDP_Type) GetFREQ_DOMAIN_CTRL3_XCORR_PAR_TH2() uint32 {
	return (volatile.LoadUint32(&o.FREQ_DOMAIN_CTRL3.Reg) & 0x3f00) >> 8
}
func (o *BLEDP_Type) SetFREQ_DOMAIN_CTRL3_XCORR_PAR_TH1(value uint32) {
	volatile.StoreUint32(&o.FREQ_DOMAIN_CTRL3.Reg, volatile.LoadUint32(&o.FREQ_DOMAIN_CTRL3.Reg)&^(0x3f0000)|value<<16)
}
func (o *BLEDP_Type) GetFREQ_DOMAIN_CTRL3_XCORR_PAR_TH1() uint32 {
	return (volatile.LoadUint32(&o.FREQ_DOMAIN_CTRL3.Reg) & 0x3f0000) >> 16
}
func (o *BLEDP_Type) SetFREQ_DOMAIN_CTRL3_XCORR_PAR_TH0(value uint32) {
	volatile.StoreUint32(&o.FREQ_DOMAIN_CTRL3.Reg, volatile.LoadUint32(&o.FREQ_DOMAIN_CTRL3.Reg)&^(0x3f000000)|value<<24)
}
func (o *BLEDP_Type) GetFREQ_DOMAIN_CTRL3_XCORR_PAR_TH0() uint32 {
	return (volatile.LoadUint32(&o.FREQ_DOMAIN_CTRL3.Reg) & 0x3f000000) >> 24
}

// BLEDP.FREQ_DOMAIN_CTRL4: frequency domain control register 4
func (o *BLEDP_Type) SetFREQ_DOMAIN_CTRL4_XCORR_POW_TH3(value uint32) {
	volatile.StoreUint32(&o.FREQ_DOMAIN_CTRL4.Reg, volatile.LoadUint32(&o.FREQ_DOMAIN_CTRL4.Reg)&^(0x3f)|value)
}
func (o *BLEDP_Type) GetFREQ_DOMAIN_CTRL4_XCORR_POW_TH3() uint32 {
	return volatile.LoadUint32(&o.FREQ_DOMAIN_CTRL4.Reg) & 0x3f
}
func (o *BLEDP_Type) SetFREQ_DOMAIN_CTRL4_XCORR_POW_TH2(value uint32) {
	volatile.StoreUint32(&o.FREQ_DOMAIN_CTRL4.Reg, volatile.LoadUint32(&o.FREQ_DOMAIN_CTRL4.Reg)&^(0x3f00)|value<<8)
}
func (o *BLEDP_Type) GetFREQ_DOMAIN_CTRL4_XCORR_POW_TH2() uint32 {
	return (volatile.LoadUint32(&o.FREQ_DOMAIN_CTRL4.Reg) & 0x3f00) >> 8
}
func (o *BLEDP_Type) SetFREQ_DOMAIN_CTRL4_XCORR_POW_TH1(value uint32) {
	volatile.StoreUint32(&o.FREQ_DOMAIN_CTRL4.Reg, volatile.LoadUint32(&o.FREQ_DOMAIN_CTRL4.Reg)&^(0x3f0000)|value<<16)
}
func (o *BLEDP_Type) GetFREQ_DOMAIN_CTRL4_XCORR_POW_TH1() uint32 {
	return (volatile.LoadUint32(&o.FREQ_DOMAIN_CTRL4.Reg) & 0x3f0000) >> 16
}
func (o *BLEDP_Type) SetFREQ_DOMAIN_CTRL4_XCORR_POW_TH0(value uint32) {
	volatile.StoreUint32(&o.FREQ_DOMAIN_CTRL4.Reg, volatile.LoadUint32(&o.FREQ_DOMAIN_CTRL4.Reg)&^(0x3f000000)|value<<24)
}
func (o *BLEDP_Type) GetFREQ_DOMAIN_CTRL4_XCORR_POW_TH0() uint32 {
	return (volatile.LoadUint32(&o.FREQ_DOMAIN_CTRL4.Reg) & 0x3f000000) >> 24
}

// BLEDP.FREQ_DOMAIN_CTRL5: frequency domain control register 5
func (o *BLEDP_Type) SetFREQ_DOMAIN_CTRL5_GAIN_TED(value uint32) {
	volatile.StoreUint32(&o.FREQ_DOMAIN_CTRL5.Reg, volatile.LoadUint32(&o.FREQ_DOMAIN_CTRL5.Reg)&^(0x3)|value)
}
func (o *BLEDP_Type) GetFREQ_DOMAIN_CTRL5_GAIN_TED() uint32 {
	return volatile.LoadUint32(&o.FREQ_DOMAIN_CTRL5.Reg) & 0x3
}
func (o *BLEDP_Type) SetFREQ_DOMAIN_CTRL5_SYNC_DIN_SAT_VALUE(value uint32) {
	volatile.StoreUint32(&o.FREQ_DOMAIN_CTRL5.Reg, volatile.LoadUint32(&o.FREQ_DOMAIN_CTRL5.Reg)&^(0x70)|value<<4)
}
func (o *BLEDP_Type) GetFREQ_DOMAIN_CTRL5_SYNC_DIN_SAT_VALUE() uint32 {
	return (volatile.LoadUint32(&o.FREQ_DOMAIN_CTRL5.Reg) & 0x70) >> 4
}
func (o *BLEDP_Type) SetFREQ_DOMAIN_CTRL5_SYNC_DIN_SAT_EN(value uint32) {
	volatile.StoreUint32(&o.FREQ_DOMAIN_CTRL5.Reg, volatile.LoadUint32(&o.FREQ_DOMAIN_CTRL5.Reg)&^(0x80)|value<<7)
}
func (o *BLEDP_Type) GetFREQ_DOMAIN_CTRL5_SYNC_DIN_SAT_EN() uint32 {
	return (volatile.LoadUint32(&o.FREQ_DOMAIN_CTRL5.Reg) & 0x80) >> 7
}
func (o *BLEDP_Type) SetFREQ_DOMAIN_CTRL5_CNT_SETTLE_IDX(value uint32) {
	volatile.StoreUint32(&o.FREQ_DOMAIN_CTRL5.Reg, volatile.LoadUint32(&o.FREQ_DOMAIN_CTRL5.Reg)&^(0x700)|value<<8)
}
func (o *BLEDP_Type) GetFREQ_DOMAIN_CTRL5_CNT_SETTLE_IDX() uint32 {
	return (volatile.LoadUint32(&o.FREQ_DOMAIN_CTRL5.Reg) & 0x700) >> 8
}
func (o *BLEDP_Type) SetFREQ_DOMAIN_CTRL5_TRIG_XCORR_CNT(value uint32) {
	volatile.StoreUint32(&o.FREQ_DOMAIN_CTRL5.Reg, volatile.LoadUint32(&o.FREQ_DOMAIN_CTRL5.Reg)&^(0xf000)|value<<12)
}
func (o *BLEDP_Type) GetFREQ_DOMAIN_CTRL5_TRIG_XCORR_CNT() uint32 {
	return (volatile.LoadUint32(&o.FREQ_DOMAIN_CTRL5.Reg) & 0xf000) >> 12
}
func (o *BLEDP_Type) SetFREQ_DOMAIN_CTRL5_XCORR_RSSI_TH3(value uint32) {
	volatile.StoreUint32(&o.FREQ_DOMAIN_CTRL5.Reg, volatile.LoadUint32(&o.FREQ_DOMAIN_CTRL5.Reg)&^(0xf0000)|value<<16)
}
func (o *BLEDP_Type) GetFREQ_DOMAIN_CTRL5_XCORR_RSSI_TH3() uint32 {
	return (volatile.LoadUint32(&o.FREQ_DOMAIN_CTRL5.Reg) & 0xf0000) >> 16
}
func (o *BLEDP_Type) SetFREQ_DOMAIN_CTRL5_XCORR_RSSI_TH2(value uint32) {
	volatile.StoreUint32(&o.FREQ_DOMAIN_CTRL5.Reg, volatile.LoadUint32(&o.FREQ_DOMAIN_CTRL5.Reg)&^(0xf00000)|value<<20)
}
func (o *BLEDP_Type) GetFREQ_DOMAIN_CTRL5_XCORR_RSSI_TH2() uint32 {
	return (volatile.LoadUint32(&o.FREQ_DOMAIN_CTRL5.Reg) & 0xf00000) >> 20
}
func (o *BLEDP_Type) SetFREQ_DOMAIN_CTRL5_XCORR_RSSI_TH1(value uint32) {
	volatile.StoreUint32(&o.FREQ_DOMAIN_CTRL5.Reg, volatile.LoadUint32(&o.FREQ_DOMAIN_CTRL5.Reg)&^(0xf000000)|value<<24)
}
func (o *BLEDP_Type) GetFREQ_DOMAIN_CTRL5_XCORR_RSSI_TH1() uint32 {
	return (volatile.LoadUint32(&o.FREQ_DOMAIN_CTRL5.Reg) & 0xf000000) >> 24
}
func (o *BLEDP_Type) SetFREQ_DOMAIN_CTRL5_XCORR_RSSI_TH0(value uint32) {
	volatile.StoreUint32(&o.FREQ_DOMAIN_CTRL5.Reg, volatile.LoadUint32(&o.FREQ_DOMAIN_CTRL5.Reg)&^(0xf0000000)|value<<28)
}
func (o *BLEDP_Type) GetFREQ_DOMAIN_CTRL5_XCORR_RSSI_TH0() uint32 {
	return (volatile.LoadUint32(&o.FREQ_DOMAIN_CTRL5.Reg) & 0xf0000000) >> 28
}

// BLEDP.FREQ_DOMAIN_CTRL6: frequency domain control register 5
func (o *BLEDP_Type) SetFREQ_DOMAIN_CTRL6_HP_TRAIN_SIZ(value uint32) {
	volatile.StoreUint32(&o.FREQ_DOMAIN_CTRL6.Reg, volatile.LoadUint32(&o.FREQ_DOMAIN_CTRL6.Reg)&^(0x1f)|value)
}
func (o *BLEDP_Type) GetFREQ_DOMAIN_CTRL6_HP_TRAIN_SIZ() uint32 {
	return volatile.LoadUint32(&o.FREQ_DOMAIN_CTRL6.Reg) & 0x1f
}
func (o *BLEDP_Type) SetFREQ_DOMAIN_CTRL6_HP_HIDX_GAIN(value uint32) {
	volatile.StoreUint32(&o.FREQ_DOMAIN_CTRL6.Reg, volatile.LoadUint32(&o.FREQ_DOMAIN_CTRL6.Reg)&^(0xff00)|value<<8)
}
func (o *BLEDP_Type) GetFREQ_DOMAIN_CTRL6_HP_HIDX_GAIN() uint32 {
	return (volatile.LoadUint32(&o.FREQ_DOMAIN_CTRL6.Reg) & 0xff00) >> 8
}
func (o *BLEDP_Type) SetFREQ_DOMAIN_CTRL6_H_REF_GAIN(value uint32) {
	volatile.StoreUint32(&o.FREQ_DOMAIN_CTRL6.Reg, volatile.LoadUint32(&o.FREQ_DOMAIN_CTRL6.Reg)&^(0x3f0000)|value<<16)
}
func (o *BLEDP_Type) GetFREQ_DOMAIN_CTRL6_H_REF_GAIN() uint32 {
	return (volatile.LoadUint32(&o.FREQ_DOMAIN_CTRL6.Reg) & 0x3f0000) >> 16
}
func (o *BLEDP_Type) SetFREQ_DOMAIN_CTRL6_DET_FR_IDX(value uint32) {
	volatile.StoreUint32(&o.FREQ_DOMAIN_CTRL6.Reg, volatile.LoadUint32(&o.FREQ_DOMAIN_CTRL6.Reg)&^(0x3000000)|value<<24)
}
func (o *BLEDP_Type) GetFREQ_DOMAIN_CTRL6_DET_FR_IDX() uint32 {
	return (volatile.LoadUint32(&o.FREQ_DOMAIN_CTRL6.Reg) & 0x3000000) >> 24
}
func (o *BLEDP_Type) SetFREQ_DOMAIN_CTRL6_CFO_FR_IDX(value uint32) {
	volatile.StoreUint32(&o.FREQ_DOMAIN_CTRL6.Reg, volatile.LoadUint32(&o.FREQ_DOMAIN_CTRL6.Reg)&^(0x30000000)|value<<28)
}
func (o *BLEDP_Type) GetFREQ_DOMAIN_CTRL6_CFO_FR_IDX() uint32 {
	return (volatile.LoadUint32(&o.FREQ_DOMAIN_CTRL6.Reg) & 0x30000000) >> 28
}

// BLEDP.HP_MODE_CTRL1: when high hp mode training size same as cfo tracking.
func (o *BLEDP_Type) SetHP_MODE_CTRL1_HP_BMC_P_TRACK(value uint32) {
	volatile.StoreUint32(&o.HP_MODE_CTRL1.Reg, volatile.LoadUint32(&o.HP_MODE_CTRL1.Reg)&^(0x3f)|value)
}
func (o *BLEDP_Type) GetHP_MODE_CTRL1_HP_BMC_P_TRACK() uint32 {
	return volatile.LoadUint32(&o.HP_MODE_CTRL1.Reg) & 0x3f
}
func (o *BLEDP_Type) SetHP_MODE_CTRL1_HP_BMC_P_TRAIN(value uint32) {
	volatile.StoreUint32(&o.HP_MODE_CTRL1.Reg, volatile.LoadUint32(&o.HP_MODE_CTRL1.Reg)&^(0x3f00)|value<<8)
}
func (o *BLEDP_Type) GetHP_MODE_CTRL1_HP_BMC_P_TRAIN() uint32 {
	return (volatile.LoadUint32(&o.HP_MODE_CTRL1.Reg) & 0x3f00) >> 8
}
func (o *BLEDP_Type) SetHP_MODE_CTRL1_HP_BMC_CZ1(value uint32) {
	volatile.StoreUint32(&o.HP_MODE_CTRL1.Reg, volatile.LoadUint32(&o.HP_MODE_CTRL1.Reg)&^(0x3f0000)|value<<16)
}
func (o *BLEDP_Type) GetHP_MODE_CTRL1_HP_BMC_CZ1() uint32 {
	return (volatile.LoadUint32(&o.HP_MODE_CTRL1.Reg) & 0x3f0000) >> 16
}
func (o *BLEDP_Type) SetHP_MODE_CTRL1_BUF_IDX_DELTA(value uint32) {
	volatile.StoreUint32(&o.HP_MODE_CTRL1.Reg, volatile.LoadUint32(&o.HP_MODE_CTRL1.Reg)&^(0xf000000)|value<<24)
}
func (o *BLEDP_Type) GetHP_MODE_CTRL1_BUF_IDX_DELTA() uint32 {
	return (volatile.LoadUint32(&o.HP_MODE_CTRL1.Reg) & 0xf000000) >> 24
}
func (o *BLEDP_Type) SetHP_MODE_CTRL1_WMF2_DSAMP_IDX(value uint32) {
	volatile.StoreUint32(&o.HP_MODE_CTRL1.Reg, volatile.LoadUint32(&o.HP_MODE_CTRL1.Reg)&^(0x70000000)|value<<28)
}
func (o *BLEDP_Type) GetHP_MODE_CTRL1_WMF2_DSAMP_IDX() uint32 {
	return (volatile.LoadUint32(&o.HP_MODE_CTRL1.Reg) & 0x70000000) >> 28
}
func (o *BLEDP_Type) SetHP_MODE_CTRL1_HP_TRAIN_SIZ_FIX(value uint32) {
	volatile.StoreUint32(&o.HP_MODE_CTRL1.Reg, volatile.LoadUint32(&o.HP_MODE_CTRL1.Reg)&^(0x80000000)|value<<31)
}
func (o *BLEDP_Type) GetHP_MODE_CTRL1_HP_TRAIN_SIZ_FIX() uint32 {
	return (volatile.LoadUint32(&o.HP_MODE_CTRL1.Reg) & 0x80000000) >> 31
}

// BLEDP.HP_MODE_CTRL2: q paramter in training period of phase offset iir of bmc
func (o *BLEDP_Type) SetHP_MODE_CTRL2_SNR_EST_REF(value uint32) {
	volatile.StoreUint32(&o.HP_MODE_CTRL2.Reg, volatile.LoadUint32(&o.HP_MODE_CTRL2.Reg)&^(0xff)|value)
}
func (o *BLEDP_Type) GetHP_MODE_CTRL2_SNR_EST_REF() uint32 {
	return volatile.LoadUint32(&o.HP_MODE_CTRL2.Reg) & 0xff
}
func (o *BLEDP_Type) SetHP_MODE_CTRL2_SNR_EST_LEN(value uint32) {
	volatile.StoreUint32(&o.HP_MODE_CTRL2.Reg, volatile.LoadUint32(&o.HP_MODE_CTRL2.Reg)&^(0x300)|value<<8)
}
func (o *BLEDP_Type) GetHP_MODE_CTRL2_SNR_EST_LEN() uint32 {
	return (volatile.LoadUint32(&o.HP_MODE_CTRL2.Reg) & 0x300) >> 8
}
func (o *BLEDP_Type) SetHP_MODE_CTRL2_SNR_EST_EN(value uint32) {
	volatile.StoreUint32(&o.HP_MODE_CTRL2.Reg, volatile.LoadUint32(&o.HP_MODE_CTRL2.Reg)&^(0x1000)|value<<12)
}
func (o *BLEDP_Type) GetHP_MODE_CTRL2_SNR_EST_EN() uint32 {
	return (volatile.LoadUint32(&o.HP_MODE_CTRL2.Reg) & 0x1000) >> 12
}
func (o *BLEDP_Type) SetHP_MODE_CTRL2_HP_BMC_Q_TRACK(value uint32) {
	volatile.StoreUint32(&o.HP_MODE_CTRL2.Reg, volatile.LoadUint32(&o.HP_MODE_CTRL2.Reg)&^(0xff0000)|value<<16)
}
func (o *BLEDP_Type) GetHP_MODE_CTRL2_HP_BMC_Q_TRACK() uint32 {
	return (volatile.LoadUint32(&o.HP_MODE_CTRL2.Reg) & 0xff0000) >> 16
}
func (o *BLEDP_Type) SetHP_MODE_CTRL2_HP_BMC_Q_TRAIN(value uint32) {
	volatile.StoreUint32(&o.HP_MODE_CTRL2.Reg, volatile.LoadUint32(&o.HP_MODE_CTRL2.Reg)&^(0xff000000)|value<<24)
}
func (o *BLEDP_Type) GetHP_MODE_CTRL2_HP_BMC_Q_TRAIN() uint32 {
	return (volatile.LoadUint32(&o.HP_MODE_CTRL2.Reg) & 0xff000000) >> 24
}

// BLEDP.FREQ_DOMAIN_STATUS1: frequency domain status register 1
func (o *BLEDP_Type) SetFREQ_DOMAIN_STATUS1_MAX_XCORR(value uint32) {
	volatile.StoreUint32(&o.FREQ_DOMAIN_STATUS1.Reg, volatile.LoadUint32(&o.FREQ_DOMAIN_STATUS1.Reg)&^(0x3ff)|value)
}
func (o *BLEDP_Type) GetFREQ_DOMAIN_STATUS1_MAX_XCORR() uint32 {
	return volatile.LoadUint32(&o.FREQ_DOMAIN_STATUS1.Reg) & 0x3ff
}
func (o *BLEDP_Type) SetFREQ_DOMAIN_STATUS1_PKT_OFFSET_COM(value uint32) {
	volatile.StoreUint32(&o.FREQ_DOMAIN_STATUS1.Reg, volatile.LoadUint32(&o.FREQ_DOMAIN_STATUS1.Reg)&^(0x1ff0000)|value<<16)
}
func (o *BLEDP_Type) GetFREQ_DOMAIN_STATUS1_PKT_OFFSET_COM() uint32 {
	return (volatile.LoadUint32(&o.FREQ_DOMAIN_STATUS1.Reg) & 0x1ff0000) >> 16
}
func (o *BLEDP_Type) SetFREQ_DOMAIN_STATUS1_NIDX(value uint32) {
	volatile.StoreUint32(&o.FREQ_DOMAIN_STATUS1.Reg, volatile.LoadUint32(&o.FREQ_DOMAIN_STATUS1.Reg)&^(0xf0000000)|value<<28)
}
func (o *BLEDP_Type) GetFREQ_DOMAIN_STATUS1_NIDX() uint32 {
	return (volatile.LoadUint32(&o.FREQ_DOMAIN_STATUS1.Reg) & 0xf0000000) >> 28
}

// BLEDP.FREQ_DOMAIN_STATUS2: frequency domain status register 2
func (o *BLEDP_Type) SetFREQ_DOMAIN_STATUS2_MAX_PAR_SPWR(value uint32) {
	volatile.StoreUint32(&o.FREQ_DOMAIN_STATUS2.Reg, volatile.LoadUint32(&o.FREQ_DOMAIN_STATUS2.Reg)&^(0x3ff)|value)
}
func (o *BLEDP_Type) GetFREQ_DOMAIN_STATUS2_MAX_PAR_SPWR() uint32 {
	return volatile.LoadUint32(&o.FREQ_DOMAIN_STATUS2.Reg) & 0x3ff
}
func (o *BLEDP_Type) SetFREQ_DOMAIN_STATUS2_MAX_PAR_XCORR(value uint32) {
	volatile.StoreUint32(&o.FREQ_DOMAIN_STATUS2.Reg, volatile.LoadUint32(&o.FREQ_DOMAIN_STATUS2.Reg)&^(0x3ff0000)|value<<16)
}
func (o *BLEDP_Type) GetFREQ_DOMAIN_STATUS2_MAX_PAR_XCORR() uint32 {
	return (volatile.LoadUint32(&o.FREQ_DOMAIN_STATUS2.Reg) & 0x3ff0000) >> 16
}

// BLEDP.DP_AA_ERROR_CTRL: AA error control register
func (o *BLEDP_Type) SetDP_AA_ERROR_CTRL_IQSWAP_SEL(value uint32) {
	volatile.StoreUint32(&o.DP_AA_ERROR_CTRL.Reg, volatile.LoadUint32(&o.DP_AA_ERROR_CTRL.Reg)&^(0x1)|value)
}
func (o *BLEDP_Type) GetDP_AA_ERROR_CTRL_IQSWAP_SEL() uint32 {
	return volatile.LoadUint32(&o.DP_AA_ERROR_CTRL.Reg) & 0x1
}
func (o *BLEDP_Type) SetDP_AA_ERROR_CTRL_AA_ERROR_EN(value uint32) {
	volatile.StoreUint32(&o.DP_AA_ERROR_CTRL.Reg, volatile.LoadUint32(&o.DP_AA_ERROR_CTRL.Reg)&^(0x2)|value<<1)
}
func (o *BLEDP_Type) GetDP_AA_ERROR_CTRL_AA_ERROR_EN() uint32 {
	return (volatile.LoadUint32(&o.DP_AA_ERROR_CTRL.Reg) & 0x2) >> 1
}
func (o *BLEDP_Type) SetDP_AA_ERROR_CTRL_AA_ERROR_CNR_EN(value uint32) {
	volatile.StoreUint32(&o.DP_AA_ERROR_CTRL.Reg, volatile.LoadUint32(&o.DP_AA_ERROR_CTRL.Reg)&^(0x4)|value<<2)
}
func (o *BLEDP_Type) GetDP_AA_ERROR_CTRL_AA_ERROR_CNR_EN() uint32 {
	return (volatile.LoadUint32(&o.DP_AA_ERROR_CTRL.Reg) & 0x4) >> 2
}
func (o *BLEDP_Type) SetDP_AA_ERROR_CTRL_AA_ERROR_CNR_SEL(value uint32) {
	volatile.StoreUint32(&o.DP_AA_ERROR_CTRL.Reg, volatile.LoadUint32(&o.DP_AA_ERROR_CTRL.Reg)&^(0x8)|value<<3)
}
func (o *BLEDP_Type) GetDP_AA_ERROR_CTRL_AA_ERROR_CNR_SEL() uint32 {
	return (volatile.LoadUint32(&o.DP_AA_ERROR_CTRL.Reg) & 0x8) >> 3
}

// BLEDP.DP_INT: data path interrupt register
func (o *BLEDP_Type) SetDP_INT_DP_INTERRUPT0(value uint32) {
	volatile.StoreUint32(&o.DP_INT.Reg, volatile.LoadUint32(&o.DP_INT.Reg)&^(0x1)|value)
}
func (o *BLEDP_Type) GetDP_INT_DP_INTERRUPT0() uint32 {
	return volatile.LoadUint32(&o.DP_INT.Reg) & 0x1
}
func (o *BLEDP_Type) SetDP_INT_DP_INTERRUPT1(value uint32) {
	volatile.StoreUint32(&o.DP_INT.Reg, volatile.LoadUint32(&o.DP_INT.Reg)&^(0x2)|value<<1)
}
func (o *BLEDP_Type) GetDP_INT_DP_INTERRUPT1() uint32 {
	return (volatile.LoadUint32(&o.DP_INT.Reg) & 0x2) >> 1
}
func (o *BLEDP_Type) SetDP_INT_DP_INTERRUPT2(value uint32) {
	volatile.StoreUint32(&o.DP_INT.Reg, volatile.LoadUint32(&o.DP_INT.Reg)&^(0x4)|value<<2)
}
func (o *BLEDP_Type) GetDP_INT_DP_INTERRUPT2() uint32 {
	return (volatile.LoadUint32(&o.DP_INT.Reg) & 0x4) >> 2
}
func (o *BLEDP_Type) SetDP_INT_DP_INTERRUPT(value uint32) {
	volatile.StoreUint32(&o.DP_INT.Reg, volatile.LoadUint32(&o.DP_INT.Reg)&^(0x8)|value<<3)
}
func (o *BLEDP_Type) GetDP_INT_DP_INTERRUPT() uint32 {
	return (volatile.LoadUint32(&o.DP_INT.Reg) & 0x8) >> 3
}
func (o *BLEDP_Type) SetDP_INT_DP_INTERRUPT0_SEL(value uint32) {
	volatile.StoreUint32(&o.DP_INT.Reg, volatile.LoadUint32(&o.DP_INT.Reg)&^(0xf0000)|value<<16)
}
func (o *BLEDP_Type) GetDP_INT_DP_INTERRUPT0_SEL() uint32 {
	return (volatile.LoadUint32(&o.DP_INT.Reg) & 0xf0000) >> 16
}
func (o *BLEDP_Type) SetDP_INT_DP_INTERRUPT1_SEL(value uint32) {
	volatile.StoreUint32(&o.DP_INT.Reg, volatile.LoadUint32(&o.DP_INT.Reg)&^(0xf00000)|value<<20)
}
func (o *BLEDP_Type) GetDP_INT_DP_INTERRUPT1_SEL() uint32 {
	return (volatile.LoadUint32(&o.DP_INT.Reg) & 0xf00000) >> 20
}
func (o *BLEDP_Type) SetDP_INT_DP_INTERRUPT2_SEL(value uint32) {
	volatile.StoreUint32(&o.DP_INT.Reg, volatile.LoadUint32(&o.DP_INT.Reg)&^(0xf000000)|value<<24)
}
func (o *BLEDP_Type) GetDP_INT_DP_INTERRUPT2_SEL() uint32 {
	return (volatile.LoadUint32(&o.DP_INT.Reg) & 0xf000000) >> 24
}
func (o *BLEDP_Type) SetDP_INT_DP_INTERRUPT0_MSK(value uint32) {
	volatile.StoreUint32(&o.DP_INT.Reg, volatile.LoadUint32(&o.DP_INT.Reg)&^(0x10000000)|value<<28)
}
func (o *BLEDP_Type) GetDP_INT_DP_INTERRUPT0_MSK() uint32 {
	return (volatile.LoadUint32(&o.DP_INT.Reg) & 0x10000000) >> 28
}
func (o *BLEDP_Type) SetDP_INT_DP_INTERRUPT1_MSK(value uint32) {
	volatile.StoreUint32(&o.DP_INT.Reg, volatile.LoadUint32(&o.DP_INT.Reg)&^(0x20000000)|value<<29)
}
func (o *BLEDP_Type) GetDP_INT_DP_INTERRUPT1_MSK() uint32 {
	return (volatile.LoadUint32(&o.DP_INT.Reg) & 0x20000000) >> 29
}
func (o *BLEDP_Type) SetDP_INT_DP_INTERRUPT2_MSK(value uint32) {
	volatile.StoreUint32(&o.DP_INT.Reg, volatile.LoadUint32(&o.DP_INT.Reg)&^(0x40000000)|value<<30)
}
func (o *BLEDP_Type) GetDP_INT_DP_INTERRUPT2_MSK() uint32 {
	return (volatile.LoadUint32(&o.DP_INT.Reg) & 0x40000000) >> 30
}
func (o *BLEDP_Type) SetDP_INT_DP_INTERRUPT_MSK(value uint32) {
	volatile.StoreUint32(&o.DP_INT.Reg, volatile.LoadUint32(&o.DP_INT.Reg)&^(0x80000000)|value<<31)
}
func (o *BLEDP_Type) GetDP_INT_DP_INTERRUPT_MSK() uint32 {
	return (volatile.LoadUint32(&o.DP_INT.Reg) & 0x80000000) >> 31
}

// BLEDP.DP_AA_ERROR_TH: AA error threshold register
func (o *BLEDP_Type) SetDP_AA_ERROR_TH_HP_TRAIN_POSITION(value uint32) {
	volatile.StoreUint32(&o.DP_AA_ERROR_TH.Reg, volatile.LoadUint32(&o.DP_AA_ERROR_TH.Reg)&^(0x1)|value)
}
func (o *BLEDP_Type) GetDP_AA_ERROR_TH_HP_TRAIN_POSITION() uint32 {
	return volatile.LoadUint32(&o.DP_AA_ERROR_TH.Reg) & 0x1
}
func (o *BLEDP_Type) SetDP_AA_ERROR_TH_CORDIC_IN_SCALE(value uint32) {
	volatile.StoreUint32(&o.DP_AA_ERROR_TH.Reg, volatile.LoadUint32(&o.DP_AA_ERROR_TH.Reg)&^(0x2)|value<<1)
}
func (o *BLEDP_Type) GetDP_AA_ERROR_TH_CORDIC_IN_SCALE() uint32 {
	return (volatile.LoadUint32(&o.DP_AA_ERROR_TH.Reg) & 0x2) >> 1
}
func (o *BLEDP_Type) SetDP_AA_ERROR_TH_PAR_AUTO_HIGHER_SEL(value uint32) {
	volatile.StoreUint32(&o.DP_AA_ERROR_TH.Reg, volatile.LoadUint32(&o.DP_AA_ERROR_TH.Reg)&^(0x4)|value<<2)
}
func (o *BLEDP_Type) GetDP_AA_ERROR_TH_PAR_AUTO_HIGHER_SEL() uint32 {
	return (volatile.LoadUint32(&o.DP_AA_ERROR_TH.Reg) & 0x4) >> 2
}
func (o *BLEDP_Type) SetDP_AA_ERROR_TH_PAR_AUTO_HIGHER_EN(value uint32) {
	volatile.StoreUint32(&o.DP_AA_ERROR_TH.Reg, volatile.LoadUint32(&o.DP_AA_ERROR_TH.Reg)&^(0x8)|value<<3)
}
func (o *BLEDP_Type) GetDP_AA_ERROR_TH_PAR_AUTO_HIGHER_EN() uint32 {
	return (volatile.LoadUint32(&o.DP_AA_ERROR_TH.Reg) & 0x8) >> 3
}
func (o *BLEDP_Type) SetDP_AA_ERROR_TH_SNR_GOOD_TH(value uint32) {
	volatile.StoreUint32(&o.DP_AA_ERROR_TH.Reg, volatile.LoadUint32(&o.DP_AA_ERROR_TH.Reg)&^(0x70)|value<<4)
}
func (o *BLEDP_Type) GetDP_AA_ERROR_TH_SNR_GOOD_TH() uint32 {
	return (volatile.LoadUint32(&o.DP_AA_ERROR_TH.Reg) & 0x70) >> 4
}
func (o *BLEDP_Type) SetDP_AA_ERROR_TH_CNR_GOOD_TH(value uint32) {
	volatile.StoreUint32(&o.DP_AA_ERROR_TH.Reg, volatile.LoadUint32(&o.DP_AA_ERROR_TH.Reg)&^(0x3f00)|value<<8)
}
func (o *BLEDP_Type) GetDP_AA_ERROR_TH_CNR_GOOD_TH() uint32 {
	return (volatile.LoadUint32(&o.DP_AA_ERROR_TH.Reg) & 0x3f00) >> 8
}
func (o *BLEDP_Type) SetDP_AA_ERROR_TH_RSSI_GOOD_TH(value uint32) {
	volatile.StoreUint32(&o.DP_AA_ERROR_TH.Reg, volatile.LoadUint32(&o.DP_AA_ERROR_TH.Reg)&^(0xff0000)|value<<16)
}
func (o *BLEDP_Type) GetDP_AA_ERROR_TH_RSSI_GOOD_TH() uint32 {
	return (volatile.LoadUint32(&o.DP_AA_ERROR_TH.Reg) & 0xff0000) >> 16
}
func (o *BLEDP_Type) SetDP_AA_ERROR_TH_RSSI_GOOD_DBM(value uint32) {
	volatile.StoreUint32(&o.DP_AA_ERROR_TH.Reg, volatile.LoadUint32(&o.DP_AA_ERROR_TH.Reg)&^(0xff000000)|value<<24)
}
func (o *BLEDP_Type) GetDP_AA_ERROR_TH_RSSI_GOOD_DBM() uint32 {
	return (volatile.LoadUint32(&o.DP_AA_ERROR_TH.Reg) & 0xff000000) >> 24
}

// BLEDP.DF_ANTENNA_CTRL: antenna register
func (o *BLEDP_Type) SetDF_ANTENNA_CTRL_SWITCH_MAP_SEL_8F(value uint32) {
	volatile.StoreUint32(&o.DF_ANTENNA_CTRL.Reg, volatile.LoadUint32(&o.DF_ANTENNA_CTRL.Reg)&^(0x3)|value)
}
func (o *BLEDP_Type) GetDF_ANTENNA_CTRL_SWITCH_MAP_SEL_8F() uint32 {
	return volatile.LoadUint32(&o.DF_ANTENNA_CTRL.Reg) & 0x3
}
func (o *BLEDP_Type) SetDF_ANTENNA_CTRL_SWITCH_MAP_SEL_07(value uint32) {
	volatile.StoreUint32(&o.DF_ANTENNA_CTRL.Reg, volatile.LoadUint32(&o.DF_ANTENNA_CTRL.Reg)&^(0xc)|value<<2)
}
func (o *BLEDP_Type) GetDF_ANTENNA_CTRL_SWITCH_MAP_SEL_07() uint32 {
	return (volatile.LoadUint32(&o.DF_ANTENNA_CTRL.Reg) & 0xc) >> 2
}
func (o *BLEDP_Type) SetDF_ANTENNA_CTRL_EXT_ANTENNA_NUM(value uint32) {
	volatile.StoreUint32(&o.DF_ANTENNA_CTRL.Reg, volatile.LoadUint32(&o.DF_ANTENNA_CTRL.Reg)&^(0xf0)|value<<4)
}
func (o *BLEDP_Type) GetDF_ANTENNA_CTRL_EXT_ANTENNA_NUM() uint32 {
	return (volatile.LoadUint32(&o.DF_ANTENNA_CTRL.Reg) & 0xf0) >> 4
}
func (o *BLEDP_Type) SetDF_ANTENNA_CTRL_EXT_ANTENNA_NUM_WEN(value uint32) {
	volatile.StoreUint32(&o.DF_ANTENNA_CTRL.Reg, volatile.LoadUint32(&o.DF_ANTENNA_CTRL.Reg)&^(0x100)|value<<8)
}
func (o *BLEDP_Type) GetDF_ANTENNA_CTRL_EXT_ANTENNA_NUM_WEN() uint32 {
	return (volatile.LoadUint32(&o.DF_ANTENNA_CTRL.Reg) & 0x100) >> 8
}
func (o *BLEDP_Type) SetDF_ANTENNA_CTRL_BUFFER_BP(value uint32) {
	volatile.StoreUint32(&o.DF_ANTENNA_CTRL.Reg, volatile.LoadUint32(&o.DF_ANTENNA_CTRL.Reg)&^(0x10000)|value<<16)
}
func (o *BLEDP_Type) GetDF_ANTENNA_CTRL_BUFFER_BP() uint32 {
	return (volatile.LoadUint32(&o.DF_ANTENNA_CTRL.Reg) & 0x10000) >> 16
}
func (o *BLEDP_Type) SetDF_ANTENNA_CTRL_TEST_TD_POWER(value uint32) {
	volatile.StoreUint32(&o.DF_ANTENNA_CTRL.Reg, volatile.LoadUint32(&o.DF_ANTENNA_CTRL.Reg)&^(0x20000)|value<<17)
}
func (o *BLEDP_Type) GetDF_ANTENNA_CTRL_TEST_TD_POWER() uint32 {
	return (volatile.LoadUint32(&o.DF_ANTENNA_CTRL.Reg) & 0x20000) >> 17
}
func (o *BLEDP_Type) SetDF_ANTENNA_CTRL_TEST_FD_POWER(value uint32) {
	volatile.StoreUint32(&o.DF_ANTENNA_CTRL.Reg, volatile.LoadUint32(&o.DF_ANTENNA_CTRL.Reg)&^(0x40000)|value<<18)
}
func (o *BLEDP_Type) GetDF_ANTENNA_CTRL_TEST_FD_POWER() uint32 {
	return (volatile.LoadUint32(&o.DF_ANTENNA_CTRL.Reg) & 0x40000) >> 18
}
func (o *BLEDP_Type) SetDF_ANTENNA_CTRL_TEST_SYNC_POWER(value uint32) {
	volatile.StoreUint32(&o.DF_ANTENNA_CTRL.Reg, volatile.LoadUint32(&o.DF_ANTENNA_CTRL.Reg)&^(0x80000)|value<<19)
}
func (o *BLEDP_Type) GetDF_ANTENNA_CTRL_TEST_SYNC_POWER() uint32 {
	return (volatile.LoadUint32(&o.DF_ANTENNA_CTRL.Reg) & 0x80000) >> 19
}
func (o *BLEDP_Type) SetDF_ANTENNA_CTRL_TEST_RFE_CORDIC_POWER(value uint32) {
	volatile.StoreUint32(&o.DF_ANTENNA_CTRL.Reg, volatile.LoadUint32(&o.DF_ANTENNA_CTRL.Reg)&^(0x100000)|value<<20)
}
func (o *BLEDP_Type) GetDF_ANTENNA_CTRL_TEST_RFE_CORDIC_POWER() uint32 {
	return (volatile.LoadUint32(&o.DF_ANTENNA_CTRL.Reg) & 0x100000) >> 20
}
func (o *BLEDP_Type) SetDF_ANTENNA_CTRL_TEST_RFE_POWER(value uint32) {
	volatile.StoreUint32(&o.DF_ANTENNA_CTRL.Reg, volatile.LoadUint32(&o.DF_ANTENNA_CTRL.Reg)&^(0x200000)|value<<21)
}
func (o *BLEDP_Type) GetDF_ANTENNA_CTRL_TEST_RFE_POWER() uint32 {
	return (volatile.LoadUint32(&o.DF_ANTENNA_CTRL.Reg) & 0x200000) >> 21
}
func (o *BLEDP_Type) SetDF_ANTENNA_CTRL_ADC01_SAMPLE_TIME(value uint32) {
	volatile.StoreUint32(&o.DF_ANTENNA_CTRL.Reg, volatile.LoadUint32(&o.DF_ANTENNA_CTRL.Reg)&^(0x400000)|value<<22)
}
func (o *BLEDP_Type) GetDF_ANTENNA_CTRL_ADC01_SAMPLE_TIME() uint32 {
	return (volatile.LoadUint32(&o.DF_ANTENNA_CTRL.Reg) & 0x400000) >> 22
}
func (o *BLEDP_Type) SetDF_ANTENNA_CTRL_PHY_RATE_MUX(value uint32) {
	volatile.StoreUint32(&o.DF_ANTENNA_CTRL.Reg, volatile.LoadUint32(&o.DF_ANTENNA_CTRL.Reg)&^(0x800000)|value<<23)
}
func (o *BLEDP_Type) GetDF_ANTENNA_CTRL_PHY_RATE_MUX() uint32 {
	return (volatile.LoadUint32(&o.DF_ANTENNA_CTRL.Reg) & 0x800000) >> 23
}
func (o *BLEDP_Type) SetDF_ANTENNA_CTRL_PHY_RATE_REG(value uint32) {
	volatile.StoreUint32(&o.DF_ANTENNA_CTRL.Reg, volatile.LoadUint32(&o.DF_ANTENNA_CTRL.Reg)&^(0x1000000)|value<<24)
}
func (o *BLEDP_Type) GetDF_ANTENNA_CTRL_PHY_RATE_REG() uint32 {
	return (volatile.LoadUint32(&o.DF_ANTENNA_CTRL.Reg) & 0x1000000) >> 24
}
func (o *BLEDP_Type) SetDF_ANTENNA_CTRL_PHY_RATE_WEN(value uint32) {
	volatile.StoreUint32(&o.DF_ANTENNA_CTRL.Reg, volatile.LoadUint32(&o.DF_ANTENNA_CTRL.Reg)&^(0x2000000)|value<<25)
}
func (o *BLEDP_Type) GetDF_ANTENNA_CTRL_PHY_RATE_WEN() uint32 {
	return (volatile.LoadUint32(&o.DF_ANTENNA_CTRL.Reg) & 0x2000000) >> 25
}
func (o *BLEDP_Type) SetDF_ANTENNA_CTRL_PDU_RSSI_WAIT_TIME(value uint32) {
	volatile.StoreUint32(&o.DF_ANTENNA_CTRL.Reg, volatile.LoadUint32(&o.DF_ANTENNA_CTRL.Reg)&^(0x4000000)|value<<26)
}
func (o *BLEDP_Type) GetDF_ANTENNA_CTRL_PDU_RSSI_WAIT_TIME() uint32 {
	return (volatile.LoadUint32(&o.DF_ANTENNA_CTRL.Reg) & 0x4000000) >> 26
}
func (o *BLEDP_Type) SetDF_ANTENNA_CTRL_PDU_RSSI_WIN_LEN(value uint32) {
	volatile.StoreUint32(&o.DF_ANTENNA_CTRL.Reg, volatile.LoadUint32(&o.DF_ANTENNA_CTRL.Reg)&^(0x8000000)|value<<27)
}
func (o *BLEDP_Type) GetDF_ANTENNA_CTRL_PDU_RSSI_WIN_LEN() uint32 {
	return (volatile.LoadUint32(&o.DF_ANTENNA_CTRL.Reg) & 0x8000000) >> 27
}
func (o *BLEDP_Type) SetDF_ANTENNA_CTRL_CAL_PDU_RSSI_EN(value uint32) {
	volatile.StoreUint32(&o.DF_ANTENNA_CTRL.Reg, volatile.LoadUint32(&o.DF_ANTENNA_CTRL.Reg)&^(0x10000000)|value<<28)
}
func (o *BLEDP_Type) GetDF_ANTENNA_CTRL_CAL_PDU_RSSI_EN() uint32 {
	return (volatile.LoadUint32(&o.DF_ANTENNA_CTRL.Reg) & 0x10000000) >> 28
}
func (o *BLEDP_Type) SetDF_ANTENNA_CTRL_PROP_CRC_AA_DIS(value uint32) {
	volatile.StoreUint32(&o.DF_ANTENNA_CTRL.Reg, volatile.LoadUint32(&o.DF_ANTENNA_CTRL.Reg)&^(0x20000000)|value<<29)
}
func (o *BLEDP_Type) GetDF_ANTENNA_CTRL_PROP_CRC_AA_DIS() uint32 {
	return (volatile.LoadUint32(&o.DF_ANTENNA_CTRL.Reg) & 0x20000000) >> 29
}
func (o *BLEDP_Type) SetDF_ANTENNA_CTRL_PROP_AA_LSB_FIRST(value uint32) {
	volatile.StoreUint32(&o.DF_ANTENNA_CTRL.Reg, volatile.LoadUint32(&o.DF_ANTENNA_CTRL.Reg)&^(0x40000000)|value<<30)
}
func (o *BLEDP_Type) GetDF_ANTENNA_CTRL_PROP_AA_LSB_FIRST() uint32 {
	return (volatile.LoadUint32(&o.DF_ANTENNA_CTRL.Reg) & 0x40000000) >> 30
}
func (o *BLEDP_Type) SetDF_ANTENNA_CTRL_PRE_NUM_WEN(value uint32) {
	volatile.StoreUint32(&o.DF_ANTENNA_CTRL.Reg, volatile.LoadUint32(&o.DF_ANTENNA_CTRL.Reg)&^(0x80000000)|value<<31)
}
func (o *BLEDP_Type) GetDF_ANTENNA_CTRL_PRE_NUM_WEN() uint32 {
	return (volatile.LoadUint32(&o.DF_ANTENNA_CTRL.Reg) & 0x80000000) >> 31
}

// BLEDP.ANTENNA_MAP01: antenna switch map register 0
func (o *BLEDP_Type) SetANTENNA_MAP01_SWITCH_MAP_1(value uint32) {
	volatile.StoreUint32(&o.ANTENNA_MAP01.Reg, volatile.LoadUint32(&o.ANTENNA_MAP01.Reg)&^(0x3fff)|value)
}
func (o *BLEDP_Type) GetANTENNA_MAP01_SWITCH_MAP_1() uint32 {
	return volatile.LoadUint32(&o.ANTENNA_MAP01.Reg) & 0x3fff
}
func (o *BLEDP_Type) SetANTENNA_MAP01_SWITCH_MAP_0(value uint32) {
	volatile.StoreUint32(&o.ANTENNA_MAP01.Reg, volatile.LoadUint32(&o.ANTENNA_MAP01.Reg)&^(0x3fff0000)|value<<16)
}
func (o *BLEDP_Type) GetANTENNA_MAP01_SWITCH_MAP_0() uint32 {
	return (volatile.LoadUint32(&o.ANTENNA_MAP01.Reg) & 0x3fff0000) >> 16
}

// BLEDP.ANTENNA_MAP23: antenna switch map register 1
func (o *BLEDP_Type) SetANTENNA_MAP23_SWITCH_MAP_3(value uint32) {
	volatile.StoreUint32(&o.ANTENNA_MAP23.Reg, volatile.LoadUint32(&o.ANTENNA_MAP23.Reg)&^(0x3fff)|value)
}
func (o *BLEDP_Type) GetANTENNA_MAP23_SWITCH_MAP_3() uint32 {
	return volatile.LoadUint32(&o.ANTENNA_MAP23.Reg) & 0x3fff
}
func (o *BLEDP_Type) SetANTENNA_MAP23_SWITCH_MAP_2(value uint32) {
	volatile.StoreUint32(&o.ANTENNA_MAP23.Reg, volatile.LoadUint32(&o.ANTENNA_MAP23.Reg)&^(0x3fff0000)|value<<16)
}
func (o *BLEDP_Type) GetANTENNA_MAP23_SWITCH_MAP_2() uint32 {
	return (volatile.LoadUint32(&o.ANTENNA_MAP23.Reg) & 0x3fff0000) >> 16
}

// BLEDP.ANTENNA_MAP45: antenna switch map register 2
func (o *BLEDP_Type) SetANTENNA_MAP45_SWITCH_MAP_5(value uint32) {
	volatile.StoreUint32(&o.ANTENNA_MAP45.Reg, volatile.LoadUint32(&o.ANTENNA_MAP45.Reg)&^(0x3fff)|value)
}
func (o *BLEDP_Type) GetANTENNA_MAP45_SWITCH_MAP_5() uint32 {
	return volatile.LoadUint32(&o.ANTENNA_MAP45.Reg) & 0x3fff
}
func (o *BLEDP_Type) SetANTENNA_MAP45_SWITCH_MAP_4(value uint32) {
	volatile.StoreUint32(&o.ANTENNA_MAP45.Reg, volatile.LoadUint32(&o.ANTENNA_MAP45.Reg)&^(0x3fff0000)|value<<16)
}
func (o *BLEDP_Type) GetANTENNA_MAP45_SWITCH_MAP_4() uint32 {
	return (volatile.LoadUint32(&o.ANTENNA_MAP45.Reg) & 0x3fff0000) >> 16
}

// BLEDP.ANTENNA_MAP67: antenna switch map register 3
func (o *BLEDP_Type) SetANTENNA_MAP67_SWITCH_MAP_7(value uint32) {
	volatile.StoreUint32(&o.ANTENNA_MAP67.Reg, volatile.LoadUint32(&o.ANTENNA_MAP67.Reg)&^(0x3fff)|value)
}
func (o *BLEDP_Type) GetANTENNA_MAP67_SWITCH_MAP_7() uint32 {
	return volatile.LoadUint32(&o.ANTENNA_MAP67.Reg) & 0x3fff
}
func (o *BLEDP_Type) SetANTENNA_MAP67_SWITCH_MAP_6(value uint32) {
	volatile.StoreUint32(&o.ANTENNA_MAP67.Reg, volatile.LoadUint32(&o.ANTENNA_MAP67.Reg)&^(0x3fff0000)|value<<16)
}
func (o *BLEDP_Type) GetANTENNA_MAP67_SWITCH_MAP_6() uint32 {
	return (volatile.LoadUint32(&o.ANTENNA_MAP67.Reg) & 0x3fff0000) >> 16
}

// calib
type CALIB_Type struct {
	START               volatile.Register32 // 0x0
	STATUS              volatile.Register32 // 0x4
	DC_CODE             volatile.Register32 // 0x8
	DC_CFG              volatile.Register32 // 0xC
	RCO_RC_REF_OSC_CODE volatile.Register32 // 0x10
	RCO_RC_REF_OSC_CFG  volatile.Register32 // 0x14
	VCOA_KVCO2M_CODE    volatile.Register32 // 0x18
	VCOA_KVCO2M_CFG     volatile.Register32 // 0x1C
	VCOF_KVCO_PO_CODE   volatile.Register32 // 0x20
	VCOF_KVCO_CFG       volatile.Register32 // 0x24
	VCOF_KVCO_CODE      volatile.Register32 // 0x28
	KVCO_HOP_CODE       volatile.Register32 // 0x2C
	VCOF_CNT_SLOPE      volatile.Register32 // 0x30
	XTL_CODE            volatile.Register32 // 0x34
	XTL_CFG             volatile.Register32 // 0x38
	CAL_DLY             volatile.Register32 // 0x3C
	DONE                volatile.Register32 // 0x40
	_                   [956]byte
	RRF1                volatile.Register32 // 0x400
	PLL48_PPF           volatile.Register32 // 0x404
	LO0                 volatile.Register32 // 0x408
	LO1                 volatile.Register32 // 0x40C
	PA_CTRL             volatile.Register32 // 0x410
	_                   [1004]byte
	CTRL                volatile.Register32 // 0x800
	INT_RAW             volatile.Register32 // 0x804
	INTEN               volatile.Register32 // 0x808
	INT_STAT            volatile.Register32 // 0x80C
	TIF                 volatile.Register32 // 0x810
	KVCO_MEAN           volatile.Register32 // 0x814
	KVCO_DLT            volatile.Register32 // 0x818
	LO_CFG              volatile.Register32 // 0x81C
	LO_TABLE            volatile.Register32 // 0x820
	LO_RATIO            volatile.Register32 // 0x824
	VCO_MOD_CFG         volatile.Register32 // 0x828
	VCO_MOD_STAT        volatile.Register32 // 0x82C
	CH_IDX              volatile.Register32 // 0x830
	VCOF_CNT_UP         volatile.Register32 // 0x834
	VCOF_CNT_DN         volatile.Register32 // 0x838
}

// CALIB.START: calibration start register
func (o *CALIB_Type) SetSTART_PO_CLB_START(value uint32) {
	volatile.StoreUint32(&o.START.Reg, volatile.LoadUint32(&o.START.Reg)&^(0x1)|value)
}
func (o *CALIB_Type) GetSTART_PO_CLB_START() uint32 {
	return volatile.LoadUint32(&o.START.Reg) & 0x1
}
func (o *CALIB_Type) SetSTART_HOP_CLB_START(value uint32) {
	volatile.StoreUint32(&o.START.Reg, volatile.LoadUint32(&o.START.Reg)&^(0x2)|value<<1)
}
func (o *CALIB_Type) GetSTART_HOP_CLB_START() uint32 {
	return (volatile.LoadUint32(&o.START.Reg) & 0x2) >> 1
}
func (o *CALIB_Type) SetSTART_OSC_CLB_START(value uint32) {
	volatile.StoreUint32(&o.START.Reg, volatile.LoadUint32(&o.START.Reg)&^(0x4)|value<<2)
}
func (o *CALIB_Type) GetSTART_OSC_CLB_START() uint32 {
	return (volatile.LoadUint32(&o.START.Reg) & 0x4) >> 2
}
func (o *CALIB_Type) SetSTART_REF_CLB_START(value uint32) {
	volatile.StoreUint32(&o.START.Reg, volatile.LoadUint32(&o.START.Reg)&^(0x8)|value<<3)
}
func (o *CALIB_Type) GetSTART_REF_CLB_START() uint32 {
	return (volatile.LoadUint32(&o.START.Reg) & 0x8) >> 3
}
func (o *CALIB_Type) SetSTART_RCO_CLB_START(value uint32) {
	volatile.StoreUint32(&o.START.Reg, volatile.LoadUint32(&o.START.Reg)&^(0x10)|value<<4)
}
func (o *CALIB_Type) GetSTART_RCO_CLB_START() uint32 {
	return (volatile.LoadUint32(&o.START.Reg) & 0x10) >> 4
}
func (o *CALIB_Type) SetSTART_XTL_CLB_START(value uint32) {
	volatile.StoreUint32(&o.START.Reg, volatile.LoadUint32(&o.START.Reg)&^(0x20)|value<<5)
}
func (o *CALIB_Type) GetSTART_XTL_CLB_START() uint32 {
	return (volatile.LoadUint32(&o.START.Reg) & 0x20) >> 5
}

// CALIB.STATUS: calibration FSM status register
func (o *CALIB_Type) SetSTATUS_TOP_FSM(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x1f)|value)
}
func (o *CALIB_Type) GetSTATUS_TOP_FSM() uint32 {
	return volatile.LoadUint32(&o.STATUS.Reg) & 0x1f
}
func (o *CALIB_Type) SetSTATUS_DC_FSM(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x1e0)|value<<5)
}
func (o *CALIB_Type) GetSTATUS_DC_FSM() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x1e0) >> 5
}
func (o *CALIB_Type) SetSTATUS_VCOA_FSM(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0xe00)|value<<9)
}
func (o *CALIB_Type) GetSTATUS_VCOA_FSM() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0xe00) >> 9
}
func (o *CALIB_Type) SetSTATUS_VCOF_FSM(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x1f000)|value<<12)
}
func (o *CALIB_Type) GetSTATUS_VCOF_FSM() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x1f000) >> 12
}
func (o *CALIB_Type) SetSTATUS_KVCO_FSM(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x1e0000)|value<<17)
}
func (o *CALIB_Type) GetSTATUS_KVCO_FSM() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x1e0000) >> 17
}
func (o *CALIB_Type) SetSTATUS_RCO_FSM(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0xe00000)|value<<21)
}
func (o *CALIB_Type) GetSTATUS_RCO_FSM() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0xe00000) >> 21
}
func (o *CALIB_Type) SetSTATUS_OSC_FSM(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x7000000)|value<<24)
}
func (o *CALIB_Type) GetSTATUS_OSC_FSM() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x7000000) >> 24
}
func (o *CALIB_Type) SetSTATUS_REF_FSM(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x38000000)|value<<27)
}
func (o *CALIB_Type) GetSTATUS_REF_FSM() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x38000000) >> 27
}

// CALIB.DC_CODE: DC code status register
func (o *CALIB_Type) SetDC_CODE_PPF_DCCAL2_I(value uint32) {
	volatile.StoreUint32(&o.DC_CODE.Reg, volatile.LoadUint32(&o.DC_CODE.Reg)&^(0xf)|value)
}
func (o *CALIB_Type) GetDC_CODE_PPF_DCCAL2_I() uint32 {
	return volatile.LoadUint32(&o.DC_CODE.Reg) & 0xf
}
func (o *CALIB_Type) SetDC_CODE_PPF_DCCAL2_Q(value uint32) {
	volatile.StoreUint32(&o.DC_CODE.Reg, volatile.LoadUint32(&o.DC_CODE.Reg)&^(0xf0)|value<<4)
}
func (o *CALIB_Type) GetDC_CODE_PPF_DCCAL2_Q() uint32 {
	return (volatile.LoadUint32(&o.DC_CODE.Reg) & 0xf0) >> 4
}
func (o *CALIB_Type) SetDC_CODE_PPF_DCCAL_I(value uint32) {
	volatile.StoreUint32(&o.DC_CODE.Reg, volatile.LoadUint32(&o.DC_CODE.Reg)&^(0x3f0000)|value<<16)
}
func (o *CALIB_Type) GetDC_CODE_PPF_DCCAL_I() uint32 {
	return (volatile.LoadUint32(&o.DC_CODE.Reg) & 0x3f0000) >> 16
}
func (o *CALIB_Type) SetDC_CODE_PPF_DCCAL_Q(value uint32) {
	volatile.StoreUint32(&o.DC_CODE.Reg, volatile.LoadUint32(&o.DC_CODE.Reg)&^(0x3f000000)|value<<24)
}
func (o *CALIB_Type) GetDC_CODE_PPF_DCCAL_Q() uint32 {
	return (volatile.LoadUint32(&o.DC_CODE.Reg) & 0x3f000000) >> 24
}

// CALIB.DC_CFG: DC code configured code register
func (o *CALIB_Type) SetDC_CFG_PPF_DCCAL2_CFG_I(value uint32) {
	volatile.StoreUint32(&o.DC_CFG.Reg, volatile.LoadUint32(&o.DC_CFG.Reg)&^(0xf)|value)
}
func (o *CALIB_Type) GetDC_CFG_PPF_DCCAL2_CFG_I() uint32 {
	return volatile.LoadUint32(&o.DC_CFG.Reg) & 0xf
}
func (o *CALIB_Type) SetDC_CFG_PPF_DCCAL2_CFG_Q(value uint32) {
	volatile.StoreUint32(&o.DC_CFG.Reg, volatile.LoadUint32(&o.DC_CFG.Reg)&^(0xf0)|value<<4)
}
func (o *CALIB_Type) GetDC_CFG_PPF_DCCAL2_CFG_Q() uint32 {
	return (volatile.LoadUint32(&o.DC_CFG.Reg) & 0xf0) >> 4
}
func (o *CALIB_Type) SetDC_CFG_DC_2NDCAL_DIS(value uint32) {
	volatile.StoreUint32(&o.DC_CFG.Reg, volatile.LoadUint32(&o.DC_CFG.Reg)&^(0x100)|value<<8)
}
func (o *CALIB_Type) GetDC_CFG_DC_2NDCAL_DIS() uint32 {
	return (volatile.LoadUint32(&o.DC_CFG.Reg) & 0x100) >> 8
}
func (o *CALIB_Type) SetDC_CFG_DC_2NDCAL_REQ(value uint32) {
	volatile.StoreUint32(&o.DC_CFG.Reg, volatile.LoadUint32(&o.DC_CFG.Reg)&^(0x200)|value<<9)
}
func (o *CALIB_Type) GetDC_CFG_DC_2NDCAL_REQ() uint32 {
	return (volatile.LoadUint32(&o.DC_CFG.Reg) & 0x200) >> 9
}
func (o *CALIB_Type) SetDC_CFG_PPF_DCCAL_CFG_I(value uint32) {
	volatile.StoreUint32(&o.DC_CFG.Reg, volatile.LoadUint32(&o.DC_CFG.Reg)&^(0x3f0000)|value<<16)
}
func (o *CALIB_Type) GetDC_CFG_PPF_DCCAL_CFG_I() uint32 {
	return (volatile.LoadUint32(&o.DC_CFG.Reg) & 0x3f0000) >> 16
}
func (o *CALIB_Type) SetDC_CFG_DC_HOP_CAL_BP(value uint32) {
	volatile.StoreUint32(&o.DC_CFG.Reg, volatile.LoadUint32(&o.DC_CFG.Reg)&^(0x400000)|value<<22)
}
func (o *CALIB_Type) GetDC_CFG_DC_HOP_CAL_BP() uint32 {
	return (volatile.LoadUint32(&o.DC_CFG.Reg) & 0x400000) >> 22
}
func (o *CALIB_Type) SetDC_CFG_PPF_DCCAL_CFG_Q(value uint32) {
	volatile.StoreUint32(&o.DC_CFG.Reg, volatile.LoadUint32(&o.DC_CFG.Reg)&^(0x3f000000)|value<<24)
}
func (o *CALIB_Type) GetDC_CFG_PPF_DCCAL_CFG_Q() uint32 {
	return (volatile.LoadUint32(&o.DC_CFG.Reg) & 0x3f000000) >> 24
}
func (o *CALIB_Type) SetDC_CFG_DC_1STCAL_DIS(value uint32) {
	volatile.StoreUint32(&o.DC_CFG.Reg, volatile.LoadUint32(&o.DC_CFG.Reg)&^(0x40000000)|value<<30)
}
func (o *CALIB_Type) GetDC_CFG_DC_1STCAL_DIS() uint32 {
	return (volatile.LoadUint32(&o.DC_CFG.Reg) & 0x40000000) >> 30
}
func (o *CALIB_Type) SetDC_CFG_DC_1STCAL_REQ(value uint32) {
	volatile.StoreUint32(&o.DC_CFG.Reg, volatile.LoadUint32(&o.DC_CFG.Reg)&^(0x80000000)|value<<31)
}
func (o *CALIB_Type) GetDC_CFG_DC_1STCAL_REQ() uint32 {
	return (volatile.LoadUint32(&o.DC_CFG.Reg) & 0x80000000) >> 31
}

// CALIB.RCO_RC_REF_OSC_CODE: RCO RC PLL48M OSC code status register
func (o *CALIB_Type) SetRCO_RC_REF_OSC_CODE_CAU_RCO_CAP(value uint32) {
	volatile.StoreUint32(&o.RCO_RC_REF_OSC_CODE.Reg, volatile.LoadUint32(&o.RCO_RC_REF_OSC_CODE.Reg)&^(0xf)|value)
}
func (o *CALIB_Type) GetRCO_RC_REF_OSC_CODE_CAU_RCO_CAP() uint32 {
	return volatile.LoadUint32(&o.RCO_RC_REF_OSC_CODE.Reg) & 0xf
}
func (o *CALIB_Type) SetRCO_RC_REF_OSC_CODE_CAU_OSC_CUR(value uint32) {
	volatile.StoreUint32(&o.RCO_RC_REF_OSC_CODE.Reg, volatile.LoadUint32(&o.RCO_RC_REF_OSC_CODE.Reg)&^(0x1f00)|value<<8)
}
func (o *CALIB_Type) GetRCO_RC_REF_OSC_CODE_CAU_OSC_CUR() uint32 {
	return (volatile.LoadUint32(&o.RCO_RC_REF_OSC_CODE.Reg) & 0x1f00) >> 8
}
func (o *CALIB_Type) SetRCO_RC_REF_OSC_CODE_CAU_RC_CAL_OUT2REG(value uint32) {
	volatile.StoreUint32(&o.RCO_RC_REF_OSC_CODE.Reg, volatile.LoadUint32(&o.RCO_RC_REF_OSC_CODE.Reg)&^(0xf0000)|value<<16)
}
func (o *CALIB_Type) GetRCO_RC_REF_OSC_CODE_CAU_RC_CAL_OUT2REG() uint32 {
	return (volatile.LoadUint32(&o.RCO_RC_REF_OSC_CODE.Reg) & 0xf0000) >> 16
}
func (o *CALIB_Type) SetRCO_RC_REF_OSC_CODE_PLL48_ENREF(value uint32) {
	volatile.StoreUint32(&o.RCO_RC_REF_OSC_CODE.Reg, volatile.LoadUint32(&o.RCO_RC_REF_OSC_CODE.Reg)&^(0xf000000)|value<<24)
}
func (o *CALIB_Type) GetRCO_RC_REF_OSC_CODE_PLL48_ENREF() uint32 {
	return (volatile.LoadUint32(&o.RCO_RC_REF_OSC_CODE.Reg) & 0xf000000) >> 24
}

// CALIB.RCO_RC_REF_OSC_CFG: RCO RC PLL48M OSC configured code register
func (o *CALIB_Type) SetRCO_RC_REF_OSC_CFG_CAU_RCO_CAP_CFG(value uint32) {
	volatile.StoreUint32(&o.RCO_RC_REF_OSC_CFG.Reg, volatile.LoadUint32(&o.RCO_RC_REF_OSC_CFG.Reg)&^(0xf)|value)
}
func (o *CALIB_Type) GetRCO_RC_REF_OSC_CFG_CAU_RCO_CAP_CFG() uint32 {
	return volatile.LoadUint32(&o.RCO_RC_REF_OSC_CFG.Reg) & 0xf
}
func (o *CALIB_Type) SetRCO_RC_REF_OSC_CFG_RCO_CAL_DIS(value uint32) {
	volatile.StoreUint32(&o.RCO_RC_REF_OSC_CFG.Reg, volatile.LoadUint32(&o.RCO_RC_REF_OSC_CFG.Reg)&^(0x10)|value<<4)
}
func (o *CALIB_Type) GetRCO_RC_REF_OSC_CFG_RCO_CAL_DIS() uint32 {
	return (volatile.LoadUint32(&o.RCO_RC_REF_OSC_CFG.Reg) & 0x10) >> 4
}
func (o *CALIB_Type) SetRCO_RC_REF_OSC_CFG_RCO_CAL_REQ(value uint32) {
	volatile.StoreUint32(&o.RCO_RC_REF_OSC_CFG.Reg, volatile.LoadUint32(&o.RCO_RC_REF_OSC_CFG.Reg)&^(0x20)|value<<5)
}
func (o *CALIB_Type) GetRCO_RC_REF_OSC_CFG_RCO_CAL_REQ() uint32 {
	return (volatile.LoadUint32(&o.RCO_RC_REF_OSC_CFG.Reg) & 0x20) >> 5
}
func (o *CALIB_Type) SetRCO_RC_REF_OSC_CFG_CAU_OSC_CUR_CFG(value uint32) {
	volatile.StoreUint32(&o.RCO_RC_REF_OSC_CFG.Reg, volatile.LoadUint32(&o.RCO_RC_REF_OSC_CFG.Reg)&^(0x1f00)|value<<8)
}
func (o *CALIB_Type) GetRCO_RC_REF_OSC_CFG_CAU_OSC_CUR_CFG() uint32 {
	return (volatile.LoadUint32(&o.RCO_RC_REF_OSC_CFG.Reg) & 0x1f00) >> 8
}
func (o *CALIB_Type) SetRCO_RC_REF_OSC_CFG_OSC_CAL_DIS(value uint32) {
	volatile.StoreUint32(&o.RCO_RC_REF_OSC_CFG.Reg, volatile.LoadUint32(&o.RCO_RC_REF_OSC_CFG.Reg)&^(0x2000)|value<<13)
}
func (o *CALIB_Type) GetRCO_RC_REF_OSC_CFG_OSC_CAL_DIS() uint32 {
	return (volatile.LoadUint32(&o.RCO_RC_REF_OSC_CFG.Reg) & 0x2000) >> 13
}
func (o *CALIB_Type) SetRCO_RC_REF_OSC_CFG_OSC_CAL_REQ(value uint32) {
	volatile.StoreUint32(&o.RCO_RC_REF_OSC_CFG.Reg, volatile.LoadUint32(&o.RCO_RC_REF_OSC_CFG.Reg)&^(0x4000)|value<<14)
}
func (o *CALIB_Type) GetRCO_RC_REF_OSC_CFG_OSC_CAL_REQ() uint32 {
	return (volatile.LoadUint32(&o.RCO_RC_REF_OSC_CFG.Reg) & 0x4000) >> 14
}
func (o *CALIB_Type) SetRCO_RC_REF_OSC_CFG_CAU_RC_CAL_REG_IN(value uint32) {
	volatile.StoreUint32(&o.RCO_RC_REF_OSC_CFG.Reg, volatile.LoadUint32(&o.RCO_RC_REF_OSC_CFG.Reg)&^(0xf0000)|value<<16)
}
func (o *CALIB_Type) GetRCO_RC_REF_OSC_CFG_CAU_RC_CAL_REG_IN() uint32 {
	return (volatile.LoadUint32(&o.RCO_RC_REF_OSC_CFG.Reg) & 0xf0000) >> 16
}
func (o *CALIB_Type) SetRCO_RC_REF_OSC_CFG_CAU_RC_CAL_DIS(value uint32) {
	volatile.StoreUint32(&o.RCO_RC_REF_OSC_CFG.Reg, volatile.LoadUint32(&o.RCO_RC_REF_OSC_CFG.Reg)&^(0x100000)|value<<20)
}
func (o *CALIB_Type) GetRCO_RC_REF_OSC_CFG_CAU_RC_CAL_DIS() uint32 {
	return (volatile.LoadUint32(&o.RCO_RC_REF_OSC_CFG.Reg) & 0x100000) >> 20
}
func (o *CALIB_Type) SetRCO_RC_REF_OSC_CFG_RC_CAL_REQ(value uint32) {
	volatile.StoreUint32(&o.RCO_RC_REF_OSC_CFG.Reg, volatile.LoadUint32(&o.RCO_RC_REF_OSC_CFG.Reg)&^(0x200000)|value<<21)
}
func (o *CALIB_Type) GetRCO_RC_REF_OSC_CFG_RC_CAL_REQ() uint32 {
	return (volatile.LoadUint32(&o.RCO_RC_REF_OSC_CFG.Reg) & 0x200000) >> 21
}
func (o *CALIB_Type) SetRCO_RC_REF_OSC_CFG_PLL48_ENREF_CFG(value uint32) {
	volatile.StoreUint32(&o.RCO_RC_REF_OSC_CFG.Reg, volatile.LoadUint32(&o.RCO_RC_REF_OSC_CFG.Reg)&^(0xf000000)|value<<24)
}
func (o *CALIB_Type) GetRCO_RC_REF_OSC_CFG_PLL48_ENREF_CFG() uint32 {
	return (volatile.LoadUint32(&o.RCO_RC_REF_OSC_CFG.Reg) & 0xf000000) >> 24
}
func (o *CALIB_Type) SetRCO_RC_REF_OSC_CFG_REF_CAL_DIS(value uint32) {
	volatile.StoreUint32(&o.RCO_RC_REF_OSC_CFG.Reg, volatile.LoadUint32(&o.RCO_RC_REF_OSC_CFG.Reg)&^(0x10000000)|value<<28)
}
func (o *CALIB_Type) GetRCO_RC_REF_OSC_CFG_REF_CAL_DIS() uint32 {
	return (volatile.LoadUint32(&o.RCO_RC_REF_OSC_CFG.Reg) & 0x10000000) >> 28
}
func (o *CALIB_Type) SetRCO_RC_REF_OSC_CFG_REF_CAL_REQ(value uint32) {
	volatile.StoreUint32(&o.RCO_RC_REF_OSC_CFG.Reg, volatile.LoadUint32(&o.RCO_RC_REF_OSC_CFG.Reg)&^(0x20000000)|value<<29)
}
func (o *CALIB_Type) GetRCO_RC_REF_OSC_CFG_REF_CAL_REQ() uint32 {
	return (volatile.LoadUint32(&o.RCO_RC_REF_OSC_CFG.Reg) & 0x20000000) >> 29
}

// CALIB.VCOA_KVCO2M_CODE: reserved
func (o *CALIB_Type) SetVCOA_KVCO2M_CODE_KCALF2M_PO(value uint32) {
	volatile.StoreUint32(&o.VCOA_KVCO2M_CODE.Reg, volatile.LoadUint32(&o.VCOA_KVCO2M_CODE.Reg)&^(0x7ff)|value)
}
func (o *CALIB_Type) GetVCOA_KVCO2M_CODE_KCALF2M_PO() uint32 {
	return volatile.LoadUint32(&o.VCOA_KVCO2M_CODE.Reg) & 0x7ff
}
func (o *CALIB_Type) SetVCOA_KVCO2M_CODE_TX_VCO_AMP(value uint32) {
	volatile.StoreUint32(&o.VCOA_KVCO2M_CODE.Reg, volatile.LoadUint32(&o.VCOA_KVCO2M_CODE.Reg)&^(0x1f0000)|value<<16)
}
func (o *CALIB_Type) GetVCOA_KVCO2M_CODE_TX_VCO_AMP() uint32 {
	return (volatile.LoadUint32(&o.VCOA_KVCO2M_CODE.Reg) & 0x1f0000) >> 16
}
func (o *CALIB_Type) SetVCOA_KVCO2M_CODE_RX_VCO_AMP(value uint32) {
	volatile.StoreUint32(&o.VCOA_KVCO2M_CODE.Reg, volatile.LoadUint32(&o.VCOA_KVCO2M_CODE.Reg)&^(0x1f000000)|value<<24)
}
func (o *CALIB_Type) GetVCOA_KVCO2M_CODE_RX_VCO_AMP() uint32 {
	return (volatile.LoadUint32(&o.VCOA_KVCO2M_CODE.Reg) & 0x1f000000) >> 24
}

// CALIB.VCOA_KVCO2M_CFG: reserved
func (o *CALIB_Type) SetVCOA_KVCO2M_CFG_KCALF2M_CFG(value uint32) {
	volatile.StoreUint32(&o.VCOA_KVCO2M_CFG.Reg, volatile.LoadUint32(&o.VCOA_KVCO2M_CFG.Reg)&^(0x7ff)|value)
}
func (o *CALIB_Type) GetVCOA_KVCO2M_CFG_KCALF2M_CFG() uint32 {
	return volatile.LoadUint32(&o.VCOA_KVCO2M_CFG.Reg) & 0x7ff
}
func (o *CALIB_Type) SetVCOA_KVCO2M_CFG_KCALF2M_BP(value uint32) {
	volatile.StoreUint32(&o.VCOA_KVCO2M_CFG.Reg, volatile.LoadUint32(&o.VCOA_KVCO2M_CFG.Reg)&^(0x800)|value<<11)
}
func (o *CALIB_Type) GetVCOA_KVCO2M_CFG_KCALF2M_BP() uint32 {
	return (volatile.LoadUint32(&o.VCOA_KVCO2M_CFG.Reg) & 0x800) >> 11
}
func (o *CALIB_Type) SetVCOA_KVCO2M_CFG_KVCO_CAL_E(value uint32) {
	volatile.StoreUint32(&o.VCOA_KVCO2M_CFG.Reg, volatile.LoadUint32(&o.VCOA_KVCO2M_CFG.Reg)&^(0x7000)|value<<12)
}
func (o *CALIB_Type) GetVCOA_KVCO2M_CFG_KVCO_CAL_E() uint32 {
	return (volatile.LoadUint32(&o.VCOA_KVCO2M_CFG.Reg) & 0x7000) >> 12
}
func (o *CALIB_Type) SetVCOA_KVCO2M_CFG_TX_VCO_AMP_CFG(value uint32) {
	volatile.StoreUint32(&o.VCOA_KVCO2M_CFG.Reg, volatile.LoadUint32(&o.VCOA_KVCO2M_CFG.Reg)&^(0x1f0000)|value<<16)
}
func (o *CALIB_Type) GetVCOA_KVCO2M_CFG_TX_VCO_AMP_CFG() uint32 {
	return (volatile.LoadUint32(&o.VCOA_KVCO2M_CFG.Reg) & 0x1f0000) >> 16
}
func (o *CALIB_Type) SetVCOA_KVCO2M_CFG_VCOA_CAL_DIS(value uint32) {
	volatile.StoreUint32(&o.VCOA_KVCO2M_CFG.Reg, volatile.LoadUint32(&o.VCOA_KVCO2M_CFG.Reg)&^(0x200000)|value<<21)
}
func (o *CALIB_Type) GetVCOA_KVCO2M_CFG_VCOA_CAL_DIS() uint32 {
	return (volatile.LoadUint32(&o.VCOA_KVCO2M_CFG.Reg) & 0x200000) >> 21
}
func (o *CALIB_Type) SetVCOA_KVCO2M_CFG_VCOA_CAL_REQ(value uint32) {
	volatile.StoreUint32(&o.VCOA_KVCO2M_CFG.Reg, volatile.LoadUint32(&o.VCOA_KVCO2M_CFG.Reg)&^(0x400000)|value<<22)
}
func (o *CALIB_Type) GetVCOA_KVCO2M_CFG_VCOA_CAL_REQ() uint32 {
	return (volatile.LoadUint32(&o.VCOA_KVCO2M_CFG.Reg) & 0x400000) >> 22
}
func (o *CALIB_Type) SetVCOA_KVCO2M_CFG_RX_VCO_AMP_CFG(value uint32) {
	volatile.StoreUint32(&o.VCOA_KVCO2M_CFG.Reg, volatile.LoadUint32(&o.VCOA_KVCO2M_CFG.Reg)&^(0x1f000000)|value<<24)
}
func (o *CALIB_Type) GetVCOA_KVCO2M_CFG_RX_VCO_AMP_CFG() uint32 {
	return (volatile.LoadUint32(&o.VCOA_KVCO2M_CFG.Reg) & 0x1f000000) >> 24
}

// CALIB.VCOF_KVCO_PO_CODE: reserved
func (o *CALIB_Type) SetVCOF_KVCO_PO_CODE_KCALF_PO(value uint32) {
	volatile.StoreUint32(&o.VCOF_KVCO_PO_CODE.Reg, volatile.LoadUint32(&o.VCOF_KVCO_PO_CODE.Reg)&^(0x7ff)|value)
}
func (o *CALIB_Type) GetVCOF_KVCO_PO_CODE_KCALF_PO() uint32 {
	return volatile.LoadUint32(&o.VCOF_KVCO_PO_CODE.Reg) & 0x7ff
}
func (o *CALIB_Type) SetVCOF_KVCO_PO_CODE_TX_VCO_CBANK_PO(value uint32) {
	volatile.StoreUint32(&o.VCOF_KVCO_PO_CODE.Reg, volatile.LoadUint32(&o.VCOF_KVCO_PO_CODE.Reg)&^(0x3f0000)|value<<16)
}
func (o *CALIB_Type) GetVCOF_KVCO_PO_CODE_TX_VCO_CBANK_PO() uint32 {
	return (volatile.LoadUint32(&o.VCOF_KVCO_PO_CODE.Reg) & 0x3f0000) >> 16
}
func (o *CALIB_Type) SetVCOF_KVCO_PO_CODE_RX_VCO_CBANK_PO(value uint32) {
	volatile.StoreUint32(&o.VCOF_KVCO_PO_CODE.Reg, volatile.LoadUint32(&o.VCOF_KVCO_PO_CODE.Reg)&^(0x3f000000)|value<<24)
}
func (o *CALIB_Type) GetVCOF_KVCO_PO_CODE_RX_VCO_CBANK_PO() uint32 {
	return (volatile.LoadUint32(&o.VCOF_KVCO_PO_CODE.Reg) & 0x3f000000) >> 24
}

// CALIB.VCOF_KVCO_CFG: VCOF hop calibration bypass
func (o *CALIB_Type) SetVCOF_KVCO_CFG_KCALF_CFG(value uint32) {
	volatile.StoreUint32(&o.VCOF_KVCO_CFG.Reg, volatile.LoadUint32(&o.VCOF_KVCO_CFG.Reg)&^(0x7ff)|value)
}
func (o *CALIB_Type) GetVCOF_KVCO_CFG_KCALF_CFG() uint32 {
	return volatile.LoadUint32(&o.VCOF_KVCO_CFG.Reg) & 0x7ff
}
func (o *CALIB_Type) SetVCOF_KVCO_CFG_KVCO_REQ(value uint32) {
	volatile.StoreUint32(&o.VCOF_KVCO_CFG.Reg, volatile.LoadUint32(&o.VCOF_KVCO_CFG.Reg)&^(0x800)|value<<11)
}
func (o *CALIB_Type) GetVCOF_KVCO_CFG_KVCO_REQ() uint32 {
	return (volatile.LoadUint32(&o.VCOF_KVCO_CFG.Reg) & 0x800) >> 11
}
func (o *CALIB_Type) SetVCOF_KVCO_CFG_KVCO_DIS(value uint32) {
	volatile.StoreUint32(&o.VCOF_KVCO_CFG.Reg, volatile.LoadUint32(&o.VCOF_KVCO_CFG.Reg)&^(0x1000)|value<<12)
}
func (o *CALIB_Type) GetVCOF_KVCO_CFG_KVCO_DIS() uint32 {
	return (volatile.LoadUint32(&o.VCOF_KVCO_CFG.Reg) & 0x1000) >> 12
}
func (o *CALIB_Type) SetVCOF_KVCO_CFG_KVCO_SKIP(value uint32) {
	volatile.StoreUint32(&o.VCOF_KVCO_CFG.Reg, volatile.LoadUint32(&o.VCOF_KVCO_CFG.Reg)&^(0x2000)|value<<13)
}
func (o *CALIB_Type) GetVCOF_KVCO_CFG_KVCO_SKIP() uint32 {
	return (volatile.LoadUint32(&o.VCOF_KVCO_CFG.Reg) & 0x2000) >> 13
}
func (o *CALIB_Type) SetVCOF_KVCO_CFG_TX_VCO_CBANK_CFG(value uint32) {
	volatile.StoreUint32(&o.VCOF_KVCO_CFG.Reg, volatile.LoadUint32(&o.VCOF_KVCO_CFG.Reg)&^(0x3f0000)|value<<16)
}
func (o *CALIB_Type) GetVCOF_KVCO_CFG_TX_VCO_CBANK_CFG() uint32 {
	return (volatile.LoadUint32(&o.VCOF_KVCO_CFG.Reg) & 0x3f0000) >> 16
}
func (o *CALIB_Type) SetVCOF_KVCO_CFG_VCOF_CAL_DIS(value uint32) {
	volatile.StoreUint32(&o.VCOF_KVCO_CFG.Reg, volatile.LoadUint32(&o.VCOF_KVCO_CFG.Reg)&^(0x400000)|value<<22)
}
func (o *CALIB_Type) GetVCOF_KVCO_CFG_VCOF_CAL_DIS() uint32 {
	return (volatile.LoadUint32(&o.VCOF_KVCO_CFG.Reg) & 0x400000) >> 22
}
func (o *CALIB_Type) SetVCOF_KVCO_CFG_VCOF_CAL_REQ(value uint32) {
	volatile.StoreUint32(&o.VCOF_KVCO_CFG.Reg, volatile.LoadUint32(&o.VCOF_KVCO_CFG.Reg)&^(0x800000)|value<<23)
}
func (o *CALIB_Type) GetVCOF_KVCO_CFG_VCOF_CAL_REQ() uint32 {
	return (volatile.LoadUint32(&o.VCOF_KVCO_CFG.Reg) & 0x800000) >> 23
}
func (o *CALIB_Type) SetVCOF_KVCO_CFG_RX_VCO_CBANK_CFG(value uint32) {
	volatile.StoreUint32(&o.VCOF_KVCO_CFG.Reg, volatile.LoadUint32(&o.VCOF_KVCO_CFG.Reg)&^(0x3f000000)|value<<24)
}
func (o *CALIB_Type) GetVCOF_KVCO_CFG_RX_VCO_CBANK_CFG() uint32 {
	return (volatile.LoadUint32(&o.VCOF_KVCO_CFG.Reg) & 0x3f000000) >> 24
}
func (o *CALIB_Type) SetVCOF_KVCO_CFG_VCOF_SKIP(value uint32) {
	volatile.StoreUint32(&o.VCOF_KVCO_CFG.Reg, volatile.LoadUint32(&o.VCOF_KVCO_CFG.Reg)&^(0x40000000)|value<<30)
}
func (o *CALIB_Type) GetVCOF_KVCO_CFG_VCOF_SKIP() uint32 {
	return (volatile.LoadUint32(&o.VCOF_KVCO_CFG.Reg) & 0x40000000) >> 30
}
func (o *CALIB_Type) SetVCOF_KVCO_CFG_VCOF_HOP_BP(value uint32) {
	volatile.StoreUint32(&o.VCOF_KVCO_CFG.Reg, volatile.LoadUint32(&o.VCOF_KVCO_CFG.Reg)&^(0x80000000)|value<<31)
}
func (o *CALIB_Type) GetVCOF_KVCO_CFG_VCOF_HOP_BP() uint32 {
	return (volatile.LoadUint32(&o.VCOF_KVCO_CFG.Reg) & 0x80000000) >> 31
}

// CALIB.VCOF_KVCO_CODE: reserved
func (o *CALIB_Type) SetVCOF_KVCO_CODE_KCALF(value uint32) {
	volatile.StoreUint32(&o.VCOF_KVCO_CODE.Reg, volatile.LoadUint32(&o.VCOF_KVCO_CODE.Reg)&^(0x7ff)|value)
}
func (o *CALIB_Type) GetVCOF_KVCO_CODE_KCALF() uint32 {
	return volatile.LoadUint32(&o.VCOF_KVCO_CODE.Reg) & 0x7ff
}
func (o *CALIB_Type) SetVCOF_KVCO_CODE_TX_VCO_CBANK(value uint32) {
	volatile.StoreUint32(&o.VCOF_KVCO_CODE.Reg, volatile.LoadUint32(&o.VCOF_KVCO_CODE.Reg)&^(0x3f0000)|value<<16)
}
func (o *CALIB_Type) GetVCOF_KVCO_CODE_TX_VCO_CBANK() uint32 {
	return (volatile.LoadUint32(&o.VCOF_KVCO_CODE.Reg) & 0x3f0000) >> 16
}
func (o *CALIB_Type) SetVCOF_KVCO_CODE_RX_VCO_CBANK(value uint32) {
	volatile.StoreUint32(&o.VCOF_KVCO_CODE.Reg, volatile.LoadUint32(&o.VCOF_KVCO_CODE.Reg)&^(0x3f000000)|value<<24)
}
func (o *CALIB_Type) GetVCOF_KVCO_CODE_RX_VCO_CBANK() uint32 {
	return (volatile.LoadUint32(&o.VCOF_KVCO_CODE.Reg) & 0x3f000000) >> 24
}

// CALIB.KVCO_HOP_CODE: reserved
func (o *CALIB_Type) SetKVCO_HOP_CODE_KCALF1M(value uint32) {
	volatile.StoreUint32(&o.KVCO_HOP_CODE.Reg, volatile.LoadUint32(&o.KVCO_HOP_CODE.Reg)&^(0x7ff)|value)
}
func (o *CALIB_Type) GetKVCO_HOP_CODE_KCALF1M() uint32 {
	return volatile.LoadUint32(&o.KVCO_HOP_CODE.Reg) & 0x7ff
}
func (o *CALIB_Type) SetKVCO_HOP_CODE_KCALF2M(value uint32) {
	volatile.StoreUint32(&o.KVCO_HOP_CODE.Reg, volatile.LoadUint32(&o.KVCO_HOP_CODE.Reg)&^(0x7ff0000)|value<<16)
}
func (o *CALIB_Type) GetKVCO_HOP_CODE_KCALF2M() uint32 {
	return (volatile.LoadUint32(&o.KVCO_HOP_CODE.Reg) & 0x7ff0000) >> 16
}

// CALIB.VCOF_CNT_SLOPE: reserved
func (o *CALIB_Type) SetVCOF_CNT_SLOPE_TX_VCOF_CNT(value uint32) {
	volatile.StoreUint32(&o.VCOF_CNT_SLOPE.Reg, volatile.LoadUint32(&o.VCOF_CNT_SLOPE.Reg)&^(0xff)|value)
}
func (o *CALIB_Type) GetVCOF_CNT_SLOPE_TX_VCOF_CNT() uint32 {
	return volatile.LoadUint32(&o.VCOF_CNT_SLOPE.Reg) & 0xff
}
func (o *CALIB_Type) SetVCOF_CNT_SLOPE_TX_SLOPE(value uint32) {
	volatile.StoreUint32(&o.VCOF_CNT_SLOPE.Reg, volatile.LoadUint32(&o.VCOF_CNT_SLOPE.Reg)&^(0x3f00)|value<<8)
}
func (o *CALIB_Type) GetVCOF_CNT_SLOPE_TX_SLOPE() uint32 {
	return (volatile.LoadUint32(&o.VCOF_CNT_SLOPE.Reg) & 0x3f00) >> 8
}
func (o *CALIB_Type) SetVCOF_CNT_SLOPE_RX_VCOF_CNT(value uint32) {
	volatile.StoreUint32(&o.VCOF_CNT_SLOPE.Reg, volatile.LoadUint32(&o.VCOF_CNT_SLOPE.Reg)&^(0xff0000)|value<<16)
}
func (o *CALIB_Type) GetVCOF_CNT_SLOPE_RX_VCOF_CNT() uint32 {
	return (volatile.LoadUint32(&o.VCOF_CNT_SLOPE.Reg) & 0xff0000) >> 16
}
func (o *CALIB_Type) SetVCOF_CNT_SLOPE_RX_SLOPE(value uint32) {
	volatile.StoreUint32(&o.VCOF_CNT_SLOPE.Reg, volatile.LoadUint32(&o.VCOF_CNT_SLOPE.Reg)&^(0x3f000000)|value<<24)
}
func (o *CALIB_Type) GetVCOF_CNT_SLOPE_RX_SLOPE() uint32 {
	return (volatile.LoadUint32(&o.VCOF_CNT_SLOPE.Reg) & 0x3f000000) >> 24
}

// CALIB.XTL_CODE: Reserved
func (o *CALIB_Type) SetXTL_CODE_XTL_XICTRL_CODE(value uint32) {
	volatile.StoreUint32(&o.XTL_CODE.Reg, volatile.LoadUint32(&o.XTL_CODE.Reg)&^(0x3f)|value)
}
func (o *CALIB_Type) GetXTL_CODE_XTL_XICTRL_CODE() uint32 {
	return volatile.LoadUint32(&o.XTL_CODE.Reg) & 0x3f
}
func (o *CALIB_Type) SetXTL_CODE_XTL_AMP_DET_OUT(value uint32) {
	volatile.StoreUint32(&o.XTL_CODE.Reg, volatile.LoadUint32(&o.XTL_CODE.Reg)&^(0x100)|value<<8)
}
func (o *CALIB_Type) GetXTL_CODE_XTL_AMP_DET_OUT() uint32 {
	return (volatile.LoadUint32(&o.XTL_CODE.Reg) & 0x100) >> 8
}

// CALIB.XTL_CFG: Reserved
func (o *CALIB_Type) SetXTL_CFG_XTL_XICTRL_CFG(value uint32) {
	volatile.StoreUint32(&o.XTL_CFG.Reg, volatile.LoadUint32(&o.XTL_CFG.Reg)&^(0x3f)|value)
}
func (o *CALIB_Type) GetXTL_CFG_XTL_XICTRL_CFG() uint32 {
	return volatile.LoadUint32(&o.XTL_CFG.Reg) & 0x3f
}
func (o *CALIB_Type) SetXTL_CFG_XTL_CAL_DIS(value uint32) {
	volatile.StoreUint32(&o.XTL_CFG.Reg, volatile.LoadUint32(&o.XTL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *CALIB_Type) GetXTL_CFG_XTL_CAL_DIS() uint32 {
	return (volatile.LoadUint32(&o.XTL_CFG.Reg) & 0x40) >> 6
}
func (o *CALIB_Type) SetXTL_CFG_XTL_CAL_REQ(value uint32) {
	volatile.StoreUint32(&o.XTL_CFG.Reg, volatile.LoadUint32(&o.XTL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *CALIB_Type) GetXTL_CFG_XTL_CAL_REQ() uint32 {
	return (volatile.LoadUint32(&o.XTL_CFG.Reg) & 0x80) >> 7
}

// CALIB.CAL_DLY: hop calibration delay bypass
func (o *CALIB_Type) SetCAL_DLY_HOP_DLY(value uint32) {
	volatile.StoreUint32(&o.CAL_DLY.Reg, volatile.LoadUint32(&o.CAL_DLY.Reg)&^(0x3f)|value)
}
func (o *CALIB_Type) GetCAL_DLY_HOP_DLY() uint32 {
	return volatile.LoadUint32(&o.CAL_DLY.Reg) & 0x3f
}
func (o *CALIB_Type) SetCAL_DLY_HOP_DLY_BP(value uint32) {
	volatile.StoreUint32(&o.CAL_DLY.Reg, volatile.LoadUint32(&o.CAL_DLY.Reg)&^(0x80)|value<<7)
}
func (o *CALIB_Type) GetCAL_DLY_HOP_DLY_BP() uint32 {
	return (volatile.LoadUint32(&o.CAL_DLY.Reg) & 0x80) >> 7
}
func (o *CALIB_Type) SetCAL_DLY_TX_DLY_DIG1M(value uint32) {
	volatile.StoreUint32(&o.CAL_DLY.Reg, volatile.LoadUint32(&o.CAL_DLY.Reg)&^(0x300)|value<<8)
}
func (o *CALIB_Type) GetCAL_DLY_TX_DLY_DIG1M() uint32 {
	return (volatile.LoadUint32(&o.CAL_DLY.Reg) & 0x300) >> 8
}
func (o *CALIB_Type) SetCAL_DLY_TX_DLY_DIG2M(value uint32) {
	volatile.StoreUint32(&o.CAL_DLY.Reg, volatile.LoadUint32(&o.CAL_DLY.Reg)&^(0xc00)|value<<10)
}
func (o *CALIB_Type) GetCAL_DLY_TX_DLY_DIG2M() uint32 {
	return (volatile.LoadUint32(&o.CAL_DLY.Reg) & 0xc00) >> 10
}
func (o *CALIB_Type) SetCAL_DLY_TX_DLY_DAC_1M(value uint32) {
	volatile.StoreUint32(&o.CAL_DLY.Reg, volatile.LoadUint32(&o.CAL_DLY.Reg)&^(0x3000)|value<<12)
}
func (o *CALIB_Type) GetCAL_DLY_TX_DLY_DAC_1M() uint32 {
	return (volatile.LoadUint32(&o.CAL_DLY.Reg) & 0x3000) >> 12
}
func (o *CALIB_Type) SetCAL_DLY_TX_DLY_DAC_2M(value uint32) {
	volatile.StoreUint32(&o.CAL_DLY.Reg, volatile.LoadUint32(&o.CAL_DLY.Reg)&^(0xc000)|value<<14)
}
func (o *CALIB_Type) GetCAL_DLY_TX_DLY_DAC_2M() uint32 {
	return (volatile.LoadUint32(&o.CAL_DLY.Reg) & 0xc000) >> 14
}
func (o *CALIB_Type) SetCAL_DLY_RX_PWRUP_CNT_TH1M(value uint32) {
	volatile.StoreUint32(&o.CAL_DLY.Reg, volatile.LoadUint32(&o.CAL_DLY.Reg)&^(0xff0000)|value<<16)
}
func (o *CALIB_Type) GetCAL_DLY_RX_PWRUP_CNT_TH1M() uint32 {
	return (volatile.LoadUint32(&o.CAL_DLY.Reg) & 0xff0000) >> 16
}
func (o *CALIB_Type) SetCAL_DLY_RX_PWRUP_CNT_TH2M(value uint32) {
	volatile.StoreUint32(&o.CAL_DLY.Reg, volatile.LoadUint32(&o.CAL_DLY.Reg)&^(0xff000000)|value<<24)
}
func (o *CALIB_Type) GetCAL_DLY_RX_PWRUP_CNT_TH2M() uint32 {
	return (volatile.LoadUint32(&o.CAL_DLY.Reg) & 0xff000000) >> 24
}

// CALIB.DONE: Reserved
func (o *CALIB_Type) SetDONE_OSC_CAL_DONE(value uint32) {
	volatile.StoreUint32(&o.DONE.Reg, volatile.LoadUint32(&o.DONE.Reg)&^(0x4)|value<<2)
}
func (o *CALIB_Type) GetDONE_OSC_CAL_DONE() uint32 {
	return (volatile.LoadUint32(&o.DONE.Reg) & 0x4) >> 2
}
func (o *CALIB_Type) SetDONE_REF_CAL_DONE(value uint32) {
	volatile.StoreUint32(&o.DONE.Reg, volatile.LoadUint32(&o.DONE.Reg)&^(0x8)|value<<3)
}
func (o *CALIB_Type) GetDONE_REF_CAL_DONE() uint32 {
	return (volatile.LoadUint32(&o.DONE.Reg) & 0x8) >> 3
}
func (o *CALIB_Type) SetDONE_RCO_CAL_DONE(value uint32) {
	volatile.StoreUint32(&o.DONE.Reg, volatile.LoadUint32(&o.DONE.Reg)&^(0x10)|value<<4)
}
func (o *CALIB_Type) GetDONE_RCO_CAL_DONE() uint32 {
	return (volatile.LoadUint32(&o.DONE.Reg) & 0x10) >> 4
}
func (o *CALIB_Type) SetDONE_RC_CAL_DONE(value uint32) {
	volatile.StoreUint32(&o.DONE.Reg, volatile.LoadUint32(&o.DONE.Reg)&^(0x20)|value<<5)
}
func (o *CALIB_Type) GetDONE_RC_CAL_DONE() uint32 {
	return (volatile.LoadUint32(&o.DONE.Reg) & 0x20) >> 5
}
func (o *CALIB_Type) SetDONE_VCOF_CAL_DONE(value uint32) {
	volatile.StoreUint32(&o.DONE.Reg, volatile.LoadUint32(&o.DONE.Reg)&^(0x40)|value<<6)
}
func (o *CALIB_Type) GetDONE_VCOF_CAL_DONE() uint32 {
	return (volatile.LoadUint32(&o.DONE.Reg) & 0x40) >> 6
}
func (o *CALIB_Type) SetDONE_VCOA_CAL_DONE(value uint32) {
	volatile.StoreUint32(&o.DONE.Reg, volatile.LoadUint32(&o.DONE.Reg)&^(0x80)|value<<7)
}
func (o *CALIB_Type) GetDONE_VCOA_CAL_DONE() uint32 {
	return (volatile.LoadUint32(&o.DONE.Reg) & 0x80) >> 7
}
func (o *CALIB_Type) SetDONE_DC2ND_CAL_DONE(value uint32) {
	volatile.StoreUint32(&o.DONE.Reg, volatile.LoadUint32(&o.DONE.Reg)&^(0x100)|value<<8)
}
func (o *CALIB_Type) GetDONE_DC2ND_CAL_DONE() uint32 {
	return (volatile.LoadUint32(&o.DONE.Reg) & 0x100) >> 8
}
func (o *CALIB_Type) SetDONE_DC1ST_CAL_DONE(value uint32) {
	volatile.StoreUint32(&o.DONE.Reg, volatile.LoadUint32(&o.DONE.Reg)&^(0x200)|value<<9)
}
func (o *CALIB_Type) GetDONE_DC1ST_CAL_DONE() uint32 {
	return (volatile.LoadUint32(&o.DONE.Reg) & 0x200) >> 9
}
func (o *CALIB_Type) SetDONE_XTL_CAL_DONE(value uint32) {
	volatile.StoreUint32(&o.DONE.Reg, volatile.LoadUint32(&o.DONE.Reg)&^(0x400)|value<<10)
}
func (o *CALIB_Type) GetDONE_XTL_CAL_DONE() uint32 {
	return (volatile.LoadUint32(&o.DONE.Reg) & 0x400) >> 10
}
func (o *CALIB_Type) SetDONE_KVCO_CAL_DONE(value uint32) {
	volatile.StoreUint32(&o.DONE.Reg, volatile.LoadUint32(&o.DONE.Reg)&^(0x800)|value<<11)
}
func (o *CALIB_Type) GetDONE_KVCO_CAL_DONE() uint32 {
	return (volatile.LoadUint32(&o.DONE.Reg) & 0x800) >> 11
}
func (o *CALIB_Type) SetDONE_KVCO_HOP_DONE(value uint32) {
	volatile.StoreUint32(&o.DONE.Reg, volatile.LoadUint32(&o.DONE.Reg)&^(0x1000)|value<<12)
}
func (o *CALIB_Type) GetDONE_KVCO_HOP_DONE() uint32 {
	return (volatile.LoadUint32(&o.DONE.Reg) & 0x1000) >> 12
}

// CALIB.RRF1: Amplitude of LO buffer for active mixer
func (o *CALIB_Type) SetRRF1_RRF_INCAP2(value uint32) {
	volatile.StoreUint32(&o.RRF1.Reg, volatile.LoadUint32(&o.RRF1.Reg)&^(0x7)|value)
}
func (o *CALIB_Type) GetRRF1_RRF_INCAP2() uint32 {
	return volatile.LoadUint32(&o.RRF1.Reg) & 0x7
}
func (o *CALIB_Type) SetRRF1_RRF_LOAD_CAP(value uint32) {
	volatile.StoreUint32(&o.RRF1.Reg, volatile.LoadUint32(&o.RRF1.Reg)&^(0x78)|value<<3)
}
func (o *CALIB_Type) GetRRF1_RRF_LOAD_CAP() uint32 {
	return (volatile.LoadUint32(&o.RRF1.Reg) & 0x78) >> 3
}
func (o *CALIB_Type) SetRRF1_RRF_TX_INCAP1(value uint32) {
	volatile.StoreUint32(&o.RRF1.Reg, volatile.LoadUint32(&o.RRF1.Reg)&^(0x380)|value<<7)
}
func (o *CALIB_Type) GetRRF1_RRF_TX_INCAP1() uint32 {
	return (volatile.LoadUint32(&o.RRF1.Reg) & 0x380) >> 7
}
func (o *CALIB_Type) SetRRF1_RRF_RX_INCAP1(value uint32) {
	volatile.StoreUint32(&o.RRF1.Reg, volatile.LoadUint32(&o.RRF1.Reg)&^(0x1c00)|value<<10)
}
func (o *CALIB_Type) GetRRF1_RRF_RX_INCAP1() uint32 {
	return (volatile.LoadUint32(&o.RRF1.Reg) & 0x1c00) >> 10
}
func (o *CALIB_Type) SetRRF1_RRF_VGATE11_LNA(value uint32) {
	volatile.StoreUint32(&o.RRF1.Reg, volatile.LoadUint32(&o.RRF1.Reg)&^(0xe000)|value<<13)
}
func (o *CALIB_Type) GetRRF1_RRF_VGATE11_LNA() uint32 {
	return (volatile.LoadUint32(&o.RRF1.Reg) & 0xe000) >> 13
}
func (o *CALIB_Type) SetRRF1_RRF_BM_GM(value uint32) {
	volatile.StoreUint32(&o.RRF1.Reg, volatile.LoadUint32(&o.RRF1.Reg)&^(0x30000)|value<<16)
}
func (o *CALIB_Type) GetRRF1_RRF_BM_GM() uint32 {
	return (volatile.LoadUint32(&o.RRF1.Reg) & 0x30000) >> 16
}
func (o *CALIB_Type) SetRRF1_RRF_BM_LNA(value uint32) {
	volatile.StoreUint32(&o.RRF1.Reg, volatile.LoadUint32(&o.RRF1.Reg)&^(0xc0000)|value<<18)
}
func (o *CALIB_Type) GetRRF1_RRF_BM_LNA() uint32 {
	return (volatile.LoadUint32(&o.RRF1.Reg) & 0xc0000) >> 18
}
func (o *CALIB_Type) SetRRF1_RRF_BM_MIXER(value uint32) {
	volatile.StoreUint32(&o.RRF1.Reg, volatile.LoadUint32(&o.RRF1.Reg)&^(0x300000)|value<<20)
}
func (o *CALIB_Type) GetRRF1_RRF_BM_MIXER() uint32 {
	return (volatile.LoadUint32(&o.RRF1.Reg) & 0x300000) >> 20
}
func (o *CALIB_Type) SetRRF1_PPF_DCCAL_RES(value uint32) {
	volatile.StoreUint32(&o.RRF1.Reg, volatile.LoadUint32(&o.RRF1.Reg)&^(0xc00000)|value<<22)
}
func (o *CALIB_Type) GetRRF1_PPF_DCCAL_RES() uint32 {
	return (volatile.LoadUint32(&o.RRF1.Reg) & 0xc00000) >> 22
}
func (o *CALIB_Type) SetRRF1_RRF_CAL_MIX_EN(value uint32) {
	volatile.StoreUint32(&o.RRF1.Reg, volatile.LoadUint32(&o.RRF1.Reg)&^(0x1000000)|value<<24)
}
func (o *CALIB_Type) GetRRF1_RRF_CAL_MIX_EN() uint32 {
	return (volatile.LoadUint32(&o.RRF1.Reg) & 0x1000000) >> 24
}
func (o *CALIB_Type) SetRRF1_RRF_CAL_MIX1_EN(value uint32) {
	volatile.StoreUint32(&o.RRF1.Reg, volatile.LoadUint32(&o.RRF1.Reg)&^(0x2000000)|value<<25)
}
func (o *CALIB_Type) GetRRF1_RRF_CAL_MIX1_EN() uint32 {
	return (volatile.LoadUint32(&o.RRF1.Reg) & 0x2000000) >> 25
}
func (o *CALIB_Type) SetRRF1_RRF_LO_SEL_P(value uint32) {
	volatile.StoreUint32(&o.RRF1.Reg, volatile.LoadUint32(&o.RRF1.Reg)&^(0xc000000)|value<<26)
}
func (o *CALIB_Type) GetRRF1_RRF_LO_SEL_P() uint32 {
	return (volatile.LoadUint32(&o.RRF1.Reg) & 0xc000000) >> 26
}
func (o *CALIB_Type) SetRRF1_RRF_LO_SEL_N(value uint32) {
	volatile.StoreUint32(&o.RRF1.Reg, volatile.LoadUint32(&o.RRF1.Reg)&^(0x30000000)|value<<28)
}
func (o *CALIB_Type) GetRRF1_RRF_LO_SEL_N() uint32 {
	return (volatile.LoadUint32(&o.RRF1.Reg) & 0x30000000) >> 28
}
func (o *CALIB_Type) SetRRF1_RRF_LO_AMP(value uint32) {
	volatile.StoreUint32(&o.RRF1.Reg, volatile.LoadUint32(&o.RRF1.Reg)&^(0xc0000000)|value<<30)
}
func (o *CALIB_Type) GetRRF1_RRF_LO_AMP() uint32 {
	return (volatile.LoadUint32(&o.RRF1.Reg) & 0xc0000000) >> 30
}

// CALIB.PLL48_PPF: reserved
func (o *CALIB_Type) SetPLL48_PPF_PPF_BM(value uint32) {
	volatile.StoreUint32(&o.PLL48_PPF.Reg, volatile.LoadUint32(&o.PLL48_PPF.Reg)&^(0x3)|value)
}
func (o *CALIB_Type) GetPLL48_PPF_PPF_BM() uint32 {
	return volatile.LoadUint32(&o.PLL48_PPF.Reg) & 0x3
}
func (o *CALIB_Type) SetPLL48_PPF_PPF_IQSW(value uint32) {
	volatile.StoreUint32(&o.PLL48_PPF.Reg, volatile.LoadUint32(&o.PLL48_PPF.Reg)&^(0x4)|value<<2)
}
func (o *CALIB_Type) GetPLL48_PPF_PPF_IQSW() uint32 {
	return (volatile.LoadUint32(&o.PLL48_PPF.Reg) & 0x4) >> 2
}
func (o *CALIB_Type) SetPLL48_PPF_PLL48_DIFF_CLK_48M_DIS(value uint32) {
	volatile.StoreUint32(&o.PLL48_PPF.Reg, volatile.LoadUint32(&o.PLL48_PPF.Reg)&^(0x8)|value<<3)
}
func (o *CALIB_Type) GetPLL48_PPF_PLL48_DIFF_CLK_48M_DIS() uint32 {
	return (volatile.LoadUint32(&o.PLL48_PPF.Reg) & 0x8) >> 3
}
func (o *CALIB_Type) SetPLL48_PPF_PLL48_TST_CPREF(value uint32) {
	volatile.StoreUint32(&o.PLL48_PPF.Reg, volatile.LoadUint32(&o.PLL48_PPF.Reg)&^(0xf0)|value<<4)
}
func (o *CALIB_Type) GetPLL48_PPF_PLL48_TST_CPREF() uint32 {
	return (volatile.LoadUint32(&o.PLL48_PPF.Reg) & 0xf0) >> 4
}

// CALIB.LO0: reserved
func (o *CALIB_Type) SetLO0_VCO_DAC_IPTAT(value uint32) {
	volatile.StoreUint32(&o.LO0.Reg, volatile.LoadUint32(&o.LO0.Reg)&^(0xf)|value)
}
func (o *CALIB_Type) GetLO0_VCO_DAC_IPTAT() uint32 {
	return volatile.LoadUint32(&o.LO0.Reg) & 0xf
}
func (o *CALIB_Type) SetLO0_VCO_TST_CP(value uint32) {
	volatile.StoreUint32(&o.LO0.Reg, volatile.LoadUint32(&o.LO0.Reg)&^(0xf0)|value<<4)
}
func (o *CALIB_Type) GetLO0_VCO_TST_CP() uint32 {
	return (volatile.LoadUint32(&o.LO0.Reg) & 0xf0) >> 4
}
func (o *CALIB_Type) SetLO0_VCO_VTUN_SET(value uint32) {
	volatile.StoreUint32(&o.LO0.Reg, volatile.LoadUint32(&o.LO0.Reg)&^(0x1f00)|value<<8)
}
func (o *CALIB_Type) GetLO0_VCO_VTUN_SET() uint32 {
	return (volatile.LoadUint32(&o.LO0.Reg) & 0x1f00) >> 8
}
func (o *CALIB_Type) SetLO0_VCO_ACAL_SET(value uint32) {
	volatile.StoreUint32(&o.LO0.Reg, volatile.LoadUint32(&o.LO0.Reg)&^(0xe000)|value<<13)
}
func (o *CALIB_Type) GetLO0_VCO_ACAL_SET() uint32 {
	return (volatile.LoadUint32(&o.LO0.Reg) & 0xe000) >> 13
}
func (o *CALIB_Type) SetLO0_VCO_BM_TXFIL(value uint32) {
	volatile.StoreUint32(&o.LO0.Reg, volatile.LoadUint32(&o.LO0.Reg)&^(0x30000)|value<<16)
}
func (o *CALIB_Type) GetLO0_VCO_BM_TXFIL() uint32 {
	return (volatile.LoadUint32(&o.LO0.Reg) & 0x30000) >> 16
}
func (o *CALIB_Type) SetLO0_VCO_BM_TXDAC(value uint32) {
	volatile.StoreUint32(&o.LO0.Reg, volatile.LoadUint32(&o.LO0.Reg)&^(0xc0000)|value<<18)
}
func (o *CALIB_Type) GetLO0_VCO_BM_TXDAC() uint32 {
	return (volatile.LoadUint32(&o.LO0.Reg) & 0xc0000) >> 18
}
func (o *CALIB_Type) SetLO0_VCO_SAMP_EN(value uint32) {
	volatile.StoreUint32(&o.LO0.Reg, volatile.LoadUint32(&o.LO0.Reg)&^(0x800000)|value<<23)
}
func (o *CALIB_Type) GetLO0_VCO_SAMP_EN() uint32 {
	return (volatile.LoadUint32(&o.LO0.Reg) & 0x800000) >> 23
}
func (o *CALIB_Type) SetLO0_VCO_CAP_HALF_EN(value uint32) {
	volatile.StoreUint32(&o.LO0.Reg, volatile.LoadUint32(&o.LO0.Reg)&^(0x1000000)|value<<24)
}
func (o *CALIB_Type) GetLO0_VCO_CAP_HALF_EN() uint32 {
	return (volatile.LoadUint32(&o.LO0.Reg) & 0x1000000) >> 24
}
func (o *CALIB_Type) SetLO0_VCO_SET_VCO_VDD_LOW(value uint32) {
	volatile.StoreUint32(&o.LO0.Reg, volatile.LoadUint32(&o.LO0.Reg)&^(0x2000000)|value<<25)
}
func (o *CALIB_Type) GetLO0_VCO_SET_VCO_VDD_LOW() uint32 {
	return (volatile.LoadUint32(&o.LO0.Reg) & 0x2000000) >> 25
}
func (o *CALIB_Type) SetLO0_VCO_8OR16M_INV_EN(value uint32) {
	volatile.StoreUint32(&o.LO0.Reg, volatile.LoadUint32(&o.LO0.Reg)&^(0x4000000)|value<<26)
}
func (o *CALIB_Type) GetLO0_VCO_8OR16M_INV_EN() uint32 {
	return (volatile.LoadUint32(&o.LO0.Reg) & 0x4000000) >> 26
}
func (o *CALIB_Type) SetLO0_VCO_DIV_PD_EN(value uint32) {
	volatile.StoreUint32(&o.LO0.Reg, volatile.LoadUint32(&o.LO0.Reg)&^(0x8000000)|value<<27)
}
func (o *CALIB_Type) GetLO0_VCO_DIV_PD_EN() uint32 {
	return (volatile.LoadUint32(&o.LO0.Reg) & 0x8000000) >> 27
}
func (o *CALIB_Type) SetLO0_VCO_TXDLY1M(value uint32) {
	volatile.StoreUint32(&o.LO0.Reg, volatile.LoadUint32(&o.LO0.Reg)&^(0x10000000)|value<<28)
}
func (o *CALIB_Type) GetLO0_VCO_TXDLY1M() uint32 {
	return (volatile.LoadUint32(&o.LO0.Reg) & 0x10000000) >> 28
}
func (o *CALIB_Type) SetLO0_VCO_TXDLY2M(value uint32) {
	volatile.StoreUint32(&o.LO0.Reg, volatile.LoadUint32(&o.LO0.Reg)&^(0x20000000)|value<<29)
}
func (o *CALIB_Type) GetLO0_VCO_TXDLY2M() uint32 {
	return (volatile.LoadUint32(&o.LO0.Reg) & 0x20000000) >> 29
}
func (o *CALIB_Type) SetLO0_VCO_RX_CK_TST(value uint32) {
	volatile.StoreUint32(&o.LO0.Reg, volatile.LoadUint32(&o.LO0.Reg)&^(0x40000000)|value<<30)
}
func (o *CALIB_Type) GetLO0_VCO_RX_CK_TST() uint32 {
	return (volatile.LoadUint32(&o.LO0.Reg) & 0x40000000) >> 30
}
func (o *CALIB_Type) SetLO0_VCO_DSM_INT_EN(value uint32) {
	volatile.StoreUint32(&o.LO0.Reg, volatile.LoadUint32(&o.LO0.Reg)&^(0x80000000)|value<<31)
}
func (o *CALIB_Type) GetLO0_VCO_DSM_INT_EN() uint32 {
	return (volatile.LoadUint32(&o.LO0.Reg) & 0x80000000) >> 31
}

// CALIB.LO1: Reserved
func (o *CALIB_Type) SetLO1_SPEED_UP_TIME(value uint32) {
	volatile.StoreUint32(&o.LO1.Reg, volatile.LoadUint32(&o.LO1.Reg)&^(0x1f)|value)
}
func (o *CALIB_Type) GetLO1_SPEED_UP_TIME() uint32 {
	return volatile.LoadUint32(&o.LO1.Reg) & 0x1f
}
func (o *CALIB_Type) SetLO1_SW_LO_SPEED_UP(value uint32) {
	volatile.StoreUint32(&o.LO1.Reg, volatile.LoadUint32(&o.LO1.Reg)&^(0x20)|value<<5)
}
func (o *CALIB_Type) GetLO1_SW_LO_SPEED_UP() uint32 {
	return (volatile.LoadUint32(&o.LO1.Reg) & 0x20) >> 5
}
func (o *CALIB_Type) SetLO1_RX_PLLPFD_EN(value uint32) {
	volatile.StoreUint32(&o.LO1.Reg, volatile.LoadUint32(&o.LO1.Reg)&^(0x40)|value<<6)
}
func (o *CALIB_Type) GetLO1_RX_PLLPFD_EN() uint32 {
	return (volatile.LoadUint32(&o.LO1.Reg) & 0x40) >> 6
}
func (o *CALIB_Type) SetLO1_TX_PLLPFD_EN(value uint32) {
	volatile.StoreUint32(&o.LO1.Reg, volatile.LoadUint32(&o.LO1.Reg)&^(0x80)|value<<7)
}
func (o *CALIB_Type) GetLO1_TX_PLLPFD_EN() uint32 {
	return (volatile.LoadUint32(&o.LO1.Reg) & 0x80) >> 7
}
func (o *CALIB_Type) SetLO1_LO_SET_TIME(value uint32) {
	volatile.StoreUint32(&o.LO1.Reg, volatile.LoadUint32(&o.LO1.Reg)&^(0x3f00)|value<<8)
}
func (o *CALIB_Type) GetLO1_LO_SET_TIME() uint32 {
	return (volatile.LoadUint32(&o.LO1.Reg) & 0x3f00) >> 8
}
func (o *CALIB_Type) SetLO1_MOD_TEST(value uint32) {
	volatile.StoreUint32(&o.LO1.Reg, volatile.LoadUint32(&o.LO1.Reg)&^(0x4000)|value<<14)
}
func (o *CALIB_Type) GetLO1_MOD_TEST() uint32 {
	return (volatile.LoadUint32(&o.LO1.Reg) & 0x4000) >> 14
}
func (o *CALIB_Type) SetLO1_DIV_DIFF_CLK_LO_DIS(value uint32) {
	volatile.StoreUint32(&o.LO1.Reg, volatile.LoadUint32(&o.LO1.Reg)&^(0x8000)|value<<15)
}
func (o *CALIB_Type) GetLO1_DIV_DIFF_CLK_LO_DIS() uint32 {
	return (volatile.LoadUint32(&o.LO1.Reg) & 0x8000) >> 15
}
func (o *CALIB_Type) SetLO1_TX_VCO_FTC_SET(value uint32) {
	volatile.StoreUint32(&o.LO1.Reg, volatile.LoadUint32(&o.LO1.Reg)&^(0x30000)|value<<16)
}
func (o *CALIB_Type) GetLO1_TX_VCO_FTC_SET() uint32 {
	return (volatile.LoadUint32(&o.LO1.Reg) & 0x30000) >> 16
}
func (o *CALIB_Type) SetLO1_RX_VCO_FTC_SET(value uint32) {
	volatile.StoreUint32(&o.LO1.Reg, volatile.LoadUint32(&o.LO1.Reg)&^(0xc0000)|value<<18)
}
func (o *CALIB_Type) GetLO1_RX_VCO_FTC_SET() uint32 {
	return (volatile.LoadUint32(&o.LO1.Reg) & 0xc0000) >> 18
}

// CALIB.PA_CTRL: Reserved
func (o *CALIB_Type) SetPA_CTRL_PA_ON_DLY(value uint32) {
	volatile.StoreUint32(&o.PA_CTRL.Reg, volatile.LoadUint32(&o.PA_CTRL.Reg)&^(0x3f)|value)
}
func (o *CALIB_Type) GetPA_CTRL_PA_ON_DLY() uint32 {
	return volatile.LoadUint32(&o.PA_CTRL.Reg) & 0x3f
}
func (o *CALIB_Type) SetPA_CTRL_PA_OFF_DLY(value uint32) {
	volatile.StoreUint32(&o.PA_CTRL.Reg, volatile.LoadUint32(&o.PA_CTRL.Reg)&^(0xf00)|value<<8)
}
func (o *CALIB_Type) GetPA_CTRL_PA_OFF_DLY() uint32 {
	return (volatile.LoadUint32(&o.PA_CTRL.Reg) & 0xf00) >> 8
}
func (o *CALIB_Type) SetPA_CTRL_PA_INCREASE_SEL(value uint32) {
	volatile.StoreUint32(&o.PA_CTRL.Reg, volatile.LoadUint32(&o.PA_CTRL.Reg)&^(0x70000)|value<<16)
}
func (o *CALIB_Type) GetPA_CTRL_PA_INCREASE_SEL() uint32 {
	return (volatile.LoadUint32(&o.PA_CTRL.Reg) & 0x70000) >> 16
}
func (o *CALIB_Type) SetPA_CTRL_PA_SEL_BIAS(value uint32) {
	volatile.StoreUint32(&o.PA_CTRL.Reg, volatile.LoadUint32(&o.PA_CTRL.Reg)&^(0x80000)|value<<19)
}
func (o *CALIB_Type) GetPA_CTRL_PA_SEL_BIAS() uint32 {
	return (volatile.LoadUint32(&o.PA_CTRL.Reg) & 0x80000) >> 19
}
func (o *CALIB_Type) SetPA_CTRL_PA_BM_CUR(value uint32) {
	volatile.StoreUint32(&o.PA_CTRL.Reg, volatile.LoadUint32(&o.PA_CTRL.Reg)&^(0x300000)|value<<20)
}
func (o *CALIB_Type) GetPA_CTRL_PA_BM_CUR() uint32 {
	return (volatile.LoadUint32(&o.PA_CTRL.Reg) & 0x300000) >> 20
}
func (o *CALIB_Type) SetPA_CTRL_PA_VDUTY_CYCLE_SEL(value uint32) {
	volatile.StoreUint32(&o.PA_CTRL.Reg, volatile.LoadUint32(&o.PA_CTRL.Reg)&^(0xc00000)|value<<22)
}
func (o *CALIB_Type) GetPA_CTRL_PA_VDUTY_CYCLE_SEL() uint32 {
	return (volatile.LoadUint32(&o.PA_CTRL.Reg) & 0xc00000) >> 22
}
func (o *CALIB_Type) SetPA_CTRL_PA_VCDCG(value uint32) {
	volatile.StoreUint32(&o.PA_CTRL.Reg, volatile.LoadUint32(&o.PA_CTRL.Reg)&^(0x1000000)|value<<24)
}
func (o *CALIB_Type) GetPA_CTRL_PA_VCDCG() uint32 {
	return (volatile.LoadUint32(&o.PA_CTRL.Reg) & 0x1000000) >> 24
}

// CALIB.CTRL: Reserved
func (o *CALIB_Type) SetCTRL_RC_TIM(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x3)|value)
}
func (o *CALIB_Type) GetCTRL_RC_TIM() uint32 {
	return volatile.LoadUint32(&o.CTRL.Reg) & 0x3
}
func (o *CALIB_Type) SetCTRL_VCO_TEST_INT(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x10)|value<<4)
}
func (o *CALIB_Type) GetCTRL_VCO_TEST_INT() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x10) >> 4
}
func (o *CALIB_Type) SetCTRL_HOP_CLB_SEL(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x100)|value<<8)
}
func (o *CALIB_Type) GetCTRL_HOP_CLB_SEL() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x100) >> 8
}
func (o *CALIB_Type) SetCTRL_XTL_PO_TIM(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x30000)|value<<16)
}
func (o *CALIB_Type) GetCTRL_XTL_PO_TIM() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x30000) >> 16
}
func (o *CALIB_Type) SetCTRL_XTL_CAL_TIM(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0xc0000)|value<<18)
}
func (o *CALIB_Type) GetCTRL_XTL_CAL_TIM() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0xc0000) >> 18
}
func (o *CALIB_Type) SetCTRL_XTL_AMP_DET_PWR_SEL(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x300000)|value<<20)
}
func (o *CALIB_Type) GetCTRL_XTL_AMP_DET_PWR_SEL() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x300000) >> 20
}
func (o *CALIB_Type) SetCTRL_XTL_SWCAL_EN(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x400000)|value<<22)
}
func (o *CALIB_Type) GetCTRL_XTL_SWCAL_EN() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x400000) >> 22
}

// CALIB.INT_RAW: Reserved
func (o *CALIB_Type) SetINT_RAW_PO_CAL_DONE_INT(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x1)|value)
}
func (o *CALIB_Type) GetINT_RAW_PO_CAL_DONE_INT() uint32 {
	return volatile.LoadUint32(&o.INT_RAW.Reg) & 0x1
}
func (o *CALIB_Type) SetINT_RAW_HOP_CAL_DONE_INT(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x2)|value<<1)
}
func (o *CALIB_Type) GetINT_RAW_HOP_CAL_DONE_INT() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x2) >> 1
}
func (o *CALIB_Type) SetINT_RAW_OSC_CAL_DONE_INT(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x4)|value<<2)
}
func (o *CALIB_Type) GetINT_RAW_OSC_CAL_DONE_INT() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x4) >> 2
}
func (o *CALIB_Type) SetINT_RAW_REF_CAL_DONE_INT(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x8)|value<<3)
}
func (o *CALIB_Type) GetINT_RAW_REF_CAL_DONE_INT() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x8) >> 3
}
func (o *CALIB_Type) SetINT_RAW_RCO_CAL_DONE_INT(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x10)|value<<4)
}
func (o *CALIB_Type) GetINT_RAW_RCO_CAL_DONE_INT() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x10) >> 4
}
func (o *CALIB_Type) SetINT_RAW_XTL_CAL_DONE_INT(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x20)|value<<5)
}
func (o *CALIB_Type) GetINT_RAW_XTL_CAL_DONE_INT() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x20) >> 5
}
func (o *CALIB_Type) SetINT_RAW_PO_ALL_DONE_INT(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x100)|value<<8)
}
func (o *CALIB_Type) GetINT_RAW_PO_ALL_DONE_INT() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x100) >> 8
}
func (o *CALIB_Type) SetINT_RAW_CAL_INT(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x10000)|value<<16)
}
func (o *CALIB_Type) GetINT_RAW_CAL_INT() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x10000) >> 16
}

// CALIB.INTEN: Reserved
func (o *CALIB_Type) SetINTEN_PO_CAL_DONE_INTEN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x1)|value)
}
func (o *CALIB_Type) GetINTEN_PO_CAL_DONE_INTEN() uint32 {
	return volatile.LoadUint32(&o.INTEN.Reg) & 0x1
}
func (o *CALIB_Type) SetINTEN_HOP_CAL_DONE_INTEN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x2)|value<<1)
}
func (o *CALIB_Type) GetINTEN_HOP_CAL_DONE_INTEN() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x2) >> 1
}
func (o *CALIB_Type) SetINTEN_OSC_CAL_DONE_INTEN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x4)|value<<2)
}
func (o *CALIB_Type) GetINTEN_OSC_CAL_DONE_INTEN() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x4) >> 2
}
func (o *CALIB_Type) SetINTEN_REF_CAL_DONE_INTEN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x8)|value<<3)
}
func (o *CALIB_Type) GetINTEN_REF_CAL_DONE_INTEN() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x8) >> 3
}
func (o *CALIB_Type) SetINTEN_RCO_CAL_DONE_INTEN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x10)|value<<4)
}
func (o *CALIB_Type) GetINTEN_RCO_CAL_DONE_INTEN() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x10) >> 4
}
func (o *CALIB_Type) SetINTEN_XTL_CAL_DONE_INTEN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x20)|value<<5)
}
func (o *CALIB_Type) GetINTEN_XTL_CAL_DONE_INTEN() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x20) >> 5
}
func (o *CALIB_Type) SetINTEN_PO_ALL_DONE_INTEN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x100)|value<<8)
}
func (o *CALIB_Type) GetINTEN_PO_ALL_DONE_INTEN() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x100) >> 8
}

// CALIB.INT_STAT: Reserved
func (o *CALIB_Type) SetINT_STAT_PO_CAL_DONE_INT_STAT(value uint32) {
	volatile.StoreUint32(&o.INT_STAT.Reg, volatile.LoadUint32(&o.INT_STAT.Reg)&^(0x1)|value)
}
func (o *CALIB_Type) GetINT_STAT_PO_CAL_DONE_INT_STAT() uint32 {
	return volatile.LoadUint32(&o.INT_STAT.Reg) & 0x1
}
func (o *CALIB_Type) SetINT_STAT_HOP_CAL_DONE_INT_STAT(value uint32) {
	volatile.StoreUint32(&o.INT_STAT.Reg, volatile.LoadUint32(&o.INT_STAT.Reg)&^(0x2)|value<<1)
}
func (o *CALIB_Type) GetINT_STAT_HOP_CAL_DONE_INT_STAT() uint32 {
	return (volatile.LoadUint32(&o.INT_STAT.Reg) & 0x2) >> 1
}
func (o *CALIB_Type) SetINT_STAT_OSC_CAL_DONE_INT_STAT(value uint32) {
	volatile.StoreUint32(&o.INT_STAT.Reg, volatile.LoadUint32(&o.INT_STAT.Reg)&^(0x4)|value<<2)
}
func (o *CALIB_Type) GetINT_STAT_OSC_CAL_DONE_INT_STAT() uint32 {
	return (volatile.LoadUint32(&o.INT_STAT.Reg) & 0x4) >> 2
}
func (o *CALIB_Type) SetINT_STAT_REF_CAL_DONE_INT_STAT(value uint32) {
	volatile.StoreUint32(&o.INT_STAT.Reg, volatile.LoadUint32(&o.INT_STAT.Reg)&^(0x8)|value<<3)
}
func (o *CALIB_Type) GetINT_STAT_REF_CAL_DONE_INT_STAT() uint32 {
	return (volatile.LoadUint32(&o.INT_STAT.Reg) & 0x8) >> 3
}
func (o *CALIB_Type) SetINT_STAT_RCO_CAL_DONE_INT_STAT(value uint32) {
	volatile.StoreUint32(&o.INT_STAT.Reg, volatile.LoadUint32(&o.INT_STAT.Reg)&^(0x10)|value<<4)
}
func (o *CALIB_Type) GetINT_STAT_RCO_CAL_DONE_INT_STAT() uint32 {
	return (volatile.LoadUint32(&o.INT_STAT.Reg) & 0x10) >> 4
}
func (o *CALIB_Type) SetINT_STAT_XTL_CAL_DONE_INT_STAT(value uint32) {
	volatile.StoreUint32(&o.INT_STAT.Reg, volatile.LoadUint32(&o.INT_STAT.Reg)&^(0x20)|value<<5)
}
func (o *CALIB_Type) GetINT_STAT_XTL_CAL_DONE_INT_STAT() uint32 {
	return (volatile.LoadUint32(&o.INT_STAT.Reg) & 0x20) >> 5
}
func (o *CALIB_Type) SetINT_STAT_PO_ALL_DONE_INT_STAT(value uint32) {
	volatile.StoreUint32(&o.INT_STAT.Reg, volatile.LoadUint32(&o.INT_STAT.Reg)&^(0x100)|value<<8)
}
func (o *CALIB_Type) GetINT_STAT_PO_ALL_DONE_INT_STAT() uint32 {
	return (volatile.LoadUint32(&o.INT_STAT.Reg) & 0x100) >> 8
}
func (o *CALIB_Type) SetINT_STAT_CAL_INT_STAT(value uint32) {
	volatile.StoreUint32(&o.INT_STAT.Reg, volatile.LoadUint32(&o.INT_STAT.Reg)&^(0x10000)|value<<16)
}
func (o *CALIB_Type) GetINT_STAT_CAL_INT_STAT() uint32 {
	return (volatile.LoadUint32(&o.INT_STAT.Reg) & 0x10000) >> 16
}

// CALIB.TIF: reserved
func (o *CALIB_Type) SetTIF_TEST_CTRL(value uint32) {
	volatile.StoreUint32(&o.TIF.Reg, volatile.LoadUint32(&o.TIF.Reg)&^(0xf)|value)
}
func (o *CALIB_Type) GetTIF_TEST_CTRL() uint32 {
	return volatile.LoadUint32(&o.TIF.Reg) & 0xf
}

// CALIB.KVCO_MEAN: reserved
func (o *CALIB_Type) SetKVCO_MEAN_KVCO_CNT_MEAN(value uint32) {
	volatile.StoreUint32(&o.KVCO_MEAN.Reg, volatile.LoadUint32(&o.KVCO_MEAN.Reg)&^(0x1fffff)|value)
}
func (o *CALIB_Type) GetKVCO_MEAN_KVCO_CNT_MEAN() uint32 {
	return volatile.LoadUint32(&o.KVCO_MEAN.Reg) & 0x1fffff
}

// CALIB.KVCO_DLT: reserved
func (o *CALIB_Type) SetKVCO_DLT_KVCO_CNT_DLT(value uint32) {
	volatile.StoreUint32(&o.KVCO_DLT.Reg, volatile.LoadUint32(&o.KVCO_DLT.Reg)&^(0x1ff)|value)
}
func (o *CALIB_Type) GetKVCO_DLT_KVCO_CNT_DLT() uint32 {
	return volatile.LoadUint32(&o.KVCO_DLT.Reg) & 0x1ff
}

// CALIB.LO_CFG: no description available
func (o *CALIB_Type) SetLO_CFG_LO_INT_CFG(value uint32) {
	volatile.StoreUint32(&o.LO_CFG.Reg, volatile.LoadUint32(&o.LO_CFG.Reg)&^(0x3f)|value)
}
func (o *CALIB_Type) GetLO_CFG_LO_INT_CFG() uint32 {
	return volatile.LoadUint32(&o.LO_CFG.Reg) & 0x3f
}
func (o *CALIB_Type) SetLO_CFG_LO_FRAC_CFG(value uint32) {
	volatile.StoreUint32(&o.LO_CFG.Reg, volatile.LoadUint32(&o.LO_CFG.Reg)&^(0xfffffc0)|value<<6)
}
func (o *CALIB_Type) GetLO_CFG_LO_FRAC_CFG() uint32 {
	return (volatile.LoadUint32(&o.LO_CFG.Reg) & 0xfffffc0) >> 6
}
func (o *CALIB_Type) SetLO_CFG_LO_SEL(value uint32) {
	volatile.StoreUint32(&o.LO_CFG.Reg, volatile.LoadUint32(&o.LO_CFG.Reg)&^(0x40000000)|value<<30)
}
func (o *CALIB_Type) GetLO_CFG_LO_SEL() uint32 {
	return (volatile.LoadUint32(&o.LO_CFG.Reg) & 0x40000000) >> 30
}
func (o *CALIB_Type) SetLO_CFG_LO_CHANGE(value uint32) {
	volatile.StoreUint32(&o.LO_CFG.Reg, volatile.LoadUint32(&o.LO_CFG.Reg)&^(0x80000000)|value<<31)
}
func (o *CALIB_Type) GetLO_CFG_LO_CHANGE() uint32 {
	return (volatile.LoadUint32(&o.LO_CFG.Reg) & 0x80000000) >> 31
}

// CALIB.LO_TABLE: no description available
func (o *CALIB_Type) SetLO_TABLE_LO_INT_TABLE(value uint32) {
	volatile.StoreUint32(&o.LO_TABLE.Reg, volatile.LoadUint32(&o.LO_TABLE.Reg)&^(0x3f)|value)
}
func (o *CALIB_Type) GetLO_TABLE_LO_INT_TABLE() uint32 {
	return volatile.LoadUint32(&o.LO_TABLE.Reg) & 0x3f
}
func (o *CALIB_Type) SetLO_TABLE_LO_FRAC_TABLE(value uint32) {
	volatile.StoreUint32(&o.LO_TABLE.Reg, volatile.LoadUint32(&o.LO_TABLE.Reg)&^(0x3ffffc0)|value<<6)
}
func (o *CALIB_Type) GetLO_TABLE_LO_FRAC_TABLE() uint32 {
	return (volatile.LoadUint32(&o.LO_TABLE.Reg) & 0x3ffffc0) >> 6
}

// CALIB.LO_RATIO: no description available
func (o *CALIB_Type) SetLO_RATIO_LO_INT(value uint32) {
	volatile.StoreUint32(&o.LO_RATIO.Reg, volatile.LoadUint32(&o.LO_RATIO.Reg)&^(0x3f)|value)
}
func (o *CALIB_Type) GetLO_RATIO_LO_INT() uint32 {
	return volatile.LoadUint32(&o.LO_RATIO.Reg) & 0x3f
}
func (o *CALIB_Type) SetLO_RATIO_LO_FRAC(value uint32) {
	volatile.StoreUint32(&o.LO_RATIO.Reg, volatile.LoadUint32(&o.LO_RATIO.Reg)&^(0xfffffc0)|value<<6)
}
func (o *CALIB_Type) GetLO_RATIO_LO_FRAC() uint32 {
	return (volatile.LoadUint32(&o.LO_RATIO.Reg) & 0xfffffc0) >> 6
}

// CALIB.VCO_MOD_CFG: TRX 2M mode selection signal
func (o *CALIB_Type) SetVCO_MOD_CFG_VCO_MOD_TX_CFG(value uint32) {
	volatile.StoreUint32(&o.VCO_MOD_CFG.Reg, volatile.LoadUint32(&o.VCO_MOD_CFG.Reg)&^(0x1)|value)
}
func (o *CALIB_Type) GetVCO_MOD_CFG_VCO_MOD_TX_CFG() uint32 {
	return volatile.LoadUint32(&o.VCO_MOD_CFG.Reg) & 0x1
}
func (o *CALIB_Type) SetVCO_MOD_CFG_VCO_MOD_TX_SEL(value uint32) {
	volatile.StoreUint32(&o.VCO_MOD_CFG.Reg, volatile.LoadUint32(&o.VCO_MOD_CFG.Reg)&^(0x2)|value<<1)
}
func (o *CALIB_Type) GetVCO_MOD_CFG_VCO_MOD_TX_SEL() uint32 {
	return (volatile.LoadUint32(&o.VCO_MOD_CFG.Reg) & 0x2) >> 1
}
func (o *CALIB_Type) SetVCO_MOD_CFG_TRX2M_MODE_CFG(value uint32) {
	volatile.StoreUint32(&o.VCO_MOD_CFG.Reg, volatile.LoadUint32(&o.VCO_MOD_CFG.Reg)&^(0x4)|value<<2)
}
func (o *CALIB_Type) GetVCO_MOD_CFG_TRX2M_MODE_CFG() uint32 {
	return (volatile.LoadUint32(&o.VCO_MOD_CFG.Reg) & 0x4) >> 2
}
func (o *CALIB_Type) SetVCO_MOD_CFG_TRX2M_MODE_SEL(value uint32) {
	volatile.StoreUint32(&o.VCO_MOD_CFG.Reg, volatile.LoadUint32(&o.VCO_MOD_CFG.Reg)&^(0x8)|value<<3)
}
func (o *CALIB_Type) GetVCO_MOD_CFG_TRX2M_MODE_SEL() uint32 {
	return (volatile.LoadUint32(&o.VCO_MOD_CFG.Reg) & 0x8) >> 3
}
func (o *CALIB_Type) SetVCO_MOD_CFG_IMR(value uint32) {
	volatile.StoreUint32(&o.VCO_MOD_CFG.Reg, volatile.LoadUint32(&o.VCO_MOD_CFG.Reg)&^(0x10)|value<<4)
}
func (o *CALIB_Type) GetVCO_MOD_CFG_IMR() uint32 {
	return (volatile.LoadUint32(&o.VCO_MOD_CFG.Reg) & 0x10) >> 4
}

// CALIB.VCO_MOD_STAT: no description available
func (o *CALIB_Type) SetVCO_MOD_STAT_VCO_MOD_TX(value uint32) {
	volatile.StoreUint32(&o.VCO_MOD_STAT.Reg, volatile.LoadUint32(&o.VCO_MOD_STAT.Reg)&^(0x1)|value)
}
func (o *CALIB_Type) GetVCO_MOD_STAT_VCO_MOD_TX() uint32 {
	return volatile.LoadUint32(&o.VCO_MOD_STAT.Reg) & 0x1
}
func (o *CALIB_Type) SetVCO_MOD_STAT_TRX2M_MODE(value uint32) {
	volatile.StoreUint32(&o.VCO_MOD_STAT.Reg, volatile.LoadUint32(&o.VCO_MOD_STAT.Reg)&^(0x4)|value<<2)
}
func (o *CALIB_Type) GetVCO_MOD_STAT_TRX2M_MODE() uint32 {
	return (volatile.LoadUint32(&o.VCO_MOD_STAT.Reg) & 0x4) >> 2
}

// CALIB.CH_IDX: no description available
func (o *CALIB_Type) SetCH_IDX(value uint32) {
	volatile.StoreUint32(&o.CH_IDX.Reg, volatile.LoadUint32(&o.CH_IDX.Reg)&^(0xff)|value)
}
func (o *CALIB_Type) GetCH_IDX() uint32 {
	return volatile.LoadUint32(&o.CH_IDX.Reg) & 0xff
}

// CALIB.VCOF_CNT_UP: reserved
func (o *CALIB_Type) SetVCOF_CNT_UP_TX_VCOF_CNT_UP(value uint32) {
	volatile.StoreUint32(&o.VCOF_CNT_UP.Reg, volatile.LoadUint32(&o.VCOF_CNT_UP.Reg)&^(0xff)|value)
}
func (o *CALIB_Type) GetVCOF_CNT_UP_TX_VCOF_CNT_UP() uint32 {
	return volatile.LoadUint32(&o.VCOF_CNT_UP.Reg) & 0xff
}
func (o *CALIB_Type) SetVCOF_CNT_UP_RX_VCOF_CNT_UP(value uint32) {
	volatile.StoreUint32(&o.VCOF_CNT_UP.Reg, volatile.LoadUint32(&o.VCOF_CNT_UP.Reg)&^(0xff0000)|value<<16)
}
func (o *CALIB_Type) GetVCOF_CNT_UP_RX_VCOF_CNT_UP() uint32 {
	return (volatile.LoadUint32(&o.VCOF_CNT_UP.Reg) & 0xff0000) >> 16
}

// CALIB.VCOF_CNT_DN: reserved
func (o *CALIB_Type) SetVCOF_CNT_DN_TX_VCOF_CNT_DN(value uint32) {
	volatile.StoreUint32(&o.VCOF_CNT_DN.Reg, volatile.LoadUint32(&o.VCOF_CNT_DN.Reg)&^(0xff)|value)
}
func (o *CALIB_Type) GetVCOF_CNT_DN_TX_VCOF_CNT_DN() uint32 {
	return volatile.LoadUint32(&o.VCOF_CNT_DN.Reg) & 0xff
}
func (o *CALIB_Type) SetVCOF_CNT_DN_RX_VCOF_CNT_DN(value uint32) {
	volatile.StoreUint32(&o.VCOF_CNT_DN.Reg, volatile.LoadUint32(&o.VCOF_CNT_DN.Reg)&^(0xff0000)|value<<16)
}
func (o *CALIB_Type) GetVCOF_CNT_DN_RX_VCOF_CNT_DN() uint32 {
	return (volatile.LoadUint32(&o.VCOF_CNT_DN.Reg) & 0xff0000) >> 16
}

// spifi
type SPIFI_Type struct {
	CTRL   volatile.Register32 // 0x0
	CMD    volatile.Register32 // 0x4
	ADDR   volatile.Register32 // 0x8
	IDATA  volatile.Register32 // 0xC
	CLIMIT volatile.Register32 // 0x10
	DATA   volatile.Register32 // 0x14
	MCMD   volatile.Register32 // 0x18
	STAT   volatile.Register32 // 0x1C
}

// SPIFI.CTRL: SPIFI control register
func (o *SPIFI_Type) SetCTRL_TIMEOUT(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0xffff)|value)
}
func (o *SPIFI_Type) GetCTRL_TIMEOUT() uint32 {
	return volatile.LoadUint32(&o.CTRL.Reg) & 0xffff
}
func (o *SPIFI_Type) SetCTRL_CSHIGH(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0xf0000)|value<<16)
}
func (o *SPIFI_Type) GetCTRL_CSHIGH() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0xf0000) >> 16
}
func (o *SPIFI_Type) SetCTRL_D_PRFTCH_DIS(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x200000)|value<<21)
}
func (o *SPIFI_Type) GetCTRL_D_PRFTCH_DIS() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x200000) >> 21
}
func (o *SPIFI_Type) SetCTRL_INTEN(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x400000)|value<<22)
}
func (o *SPIFI_Type) GetCTRL_INTEN() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x400000) >> 22
}
func (o *SPIFI_Type) SetCTRL_MODE3(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x800000)|value<<23)
}
func (o *SPIFI_Type) GetCTRL_MODE3() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x800000) >> 23
}
func (o *SPIFI_Type) SetCTRL_PRFTCH_DIS(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x8000000)|value<<27)
}
func (o *SPIFI_Type) GetCTRL_PRFTCH_DIS() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x8000000) >> 27
}
func (o *SPIFI_Type) SetCTRL_DUAL(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x10000000)|value<<28)
}
func (o *SPIFI_Type) GetCTRL_DUAL() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x10000000) >> 28
}
func (o *SPIFI_Type) SetCTRL_RFCLK(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x20000000)|value<<29)
}
func (o *SPIFI_Type) GetCTRL_RFCLK() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x20000000) >> 29
}
func (o *SPIFI_Type) SetCTRL_FBCLK(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x40000000)|value<<30)
}
func (o *SPIFI_Type) GetCTRL_FBCLK() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x40000000) >> 30
}
func (o *SPIFI_Type) SetCTRL_DMAEN(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x80000000)|value<<31)
}
func (o *SPIFI_Type) GetCTRL_DMAEN() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x80000000) >> 31
}

// SPIFI.CMD: SPIFI command register
func (o *SPIFI_Type) SetCMD_DATALEN(value uint32) {
	volatile.StoreUint32(&o.CMD.Reg, volatile.LoadUint32(&o.CMD.Reg)&^(0x3fff)|value)
}
func (o *SPIFI_Type) GetCMD_DATALEN() uint32 {
	return volatile.LoadUint32(&o.CMD.Reg) & 0x3fff
}
func (o *SPIFI_Type) SetCMD_POLL(value uint32) {
	volatile.StoreUint32(&o.CMD.Reg, volatile.LoadUint32(&o.CMD.Reg)&^(0x4000)|value<<14)
}
func (o *SPIFI_Type) GetCMD_POLL() uint32 {
	return (volatile.LoadUint32(&o.CMD.Reg) & 0x4000) >> 14
}
func (o *SPIFI_Type) SetCMD_DOUT(value uint32) {
	volatile.StoreUint32(&o.CMD.Reg, volatile.LoadUint32(&o.CMD.Reg)&^(0x8000)|value<<15)
}
func (o *SPIFI_Type) GetCMD_DOUT() uint32 {
	return (volatile.LoadUint32(&o.CMD.Reg) & 0x8000) >> 15
}
func (o *SPIFI_Type) SetCMD_INTLEN(value uint32) {
	volatile.StoreUint32(&o.CMD.Reg, volatile.LoadUint32(&o.CMD.Reg)&^(0x70000)|value<<16)
}
func (o *SPIFI_Type) GetCMD_INTLEN() uint32 {
	return (volatile.LoadUint32(&o.CMD.Reg) & 0x70000) >> 16
}
func (o *SPIFI_Type) SetCMD_FIELDFORM(value uint32) {
	volatile.StoreUint32(&o.CMD.Reg, volatile.LoadUint32(&o.CMD.Reg)&^(0x180000)|value<<19)
}
func (o *SPIFI_Type) GetCMD_FIELDFORM() uint32 {
	return (volatile.LoadUint32(&o.CMD.Reg) & 0x180000) >> 19
}
func (o *SPIFI_Type) SetCMD_FRAMEFORM(value uint32) {
	volatile.StoreUint32(&o.CMD.Reg, volatile.LoadUint32(&o.CMD.Reg)&^(0xe00000)|value<<21)
}
func (o *SPIFI_Type) GetCMD_FRAMEFORM() uint32 {
	return (volatile.LoadUint32(&o.CMD.Reg) & 0xe00000) >> 21
}
func (o *SPIFI_Type) SetCMD_OPCODE(value uint32) {
	volatile.StoreUint32(&o.CMD.Reg, volatile.LoadUint32(&o.CMD.Reg)&^(0xff000000)|value<<24)
}
func (o *SPIFI_Type) GetCMD_OPCODE() uint32 {
	return (volatile.LoadUint32(&o.CMD.Reg) & 0xff000000) >> 24
}

// SPIFI.ADDR: SPIFI address register
func (o *SPIFI_Type) SetADDR(value uint32) {
	volatile.StoreUint32(&o.ADDR.Reg, value)
}
func (o *SPIFI_Type) GetADDR() uint32 {
	return volatile.LoadUint32(&o.ADDR.Reg)
}

// SPIFI.IDATA: SPIFI intermediate data register
func (o *SPIFI_Type) SetIDATA(value uint32) {
	volatile.StoreUint32(&o.IDATA.Reg, value)
}
func (o *SPIFI_Type) GetIDATA() uint32 {
	return volatile.LoadUint32(&o.IDATA.Reg)
}

// SPIFI.CLIMIT: SPIFI limit register
func (o *SPIFI_Type) SetCLIMIT(value uint32) {
	volatile.StoreUint32(&o.CLIMIT.Reg, value)
}
func (o *SPIFI_Type) GetCLIMIT() uint32 {
	return volatile.LoadUint32(&o.CLIMIT.Reg)
}

// SPIFI.DATA: SPIFI data register
func (o *SPIFI_Type) SetDATA(value uint32) {
	volatile.StoreUint32(&o.DATA.Reg, value)
}
func (o *SPIFI_Type) GetDATA() uint32 {
	return volatile.LoadUint32(&o.DATA.Reg)
}

// SPIFI.MCMD: SPIFI memory command register
func (o *SPIFI_Type) SetMCMD_POLL(value uint32) {
	volatile.StoreUint32(&o.MCMD.Reg, volatile.LoadUint32(&o.MCMD.Reg)&^(0x4000)|value<<14)
}
func (o *SPIFI_Type) GetMCMD_POLL() uint32 {
	return (volatile.LoadUint32(&o.MCMD.Reg) & 0x4000) >> 14
}
func (o *SPIFI_Type) SetMCMD_DOUT(value uint32) {
	volatile.StoreUint32(&o.MCMD.Reg, volatile.LoadUint32(&o.MCMD.Reg)&^(0x8000)|value<<15)
}
func (o *SPIFI_Type) GetMCMD_DOUT() uint32 {
	return (volatile.LoadUint32(&o.MCMD.Reg) & 0x8000) >> 15
}
func (o *SPIFI_Type) SetMCMD_INTLEN(value uint32) {
	volatile.StoreUint32(&o.MCMD.Reg, volatile.LoadUint32(&o.MCMD.Reg)&^(0x70000)|value<<16)
}
func (o *SPIFI_Type) GetMCMD_INTLEN() uint32 {
	return (volatile.LoadUint32(&o.MCMD.Reg) & 0x70000) >> 16
}
func (o *SPIFI_Type) SetMCMD_FIELDFORM(value uint32) {
	volatile.StoreUint32(&o.MCMD.Reg, volatile.LoadUint32(&o.MCMD.Reg)&^(0x180000)|value<<19)
}
func (o *SPIFI_Type) GetMCMD_FIELDFORM() uint32 {
	return (volatile.LoadUint32(&o.MCMD.Reg) & 0x180000) >> 19
}
func (o *SPIFI_Type) SetMCMD_FRAMEFORM(value uint32) {
	volatile.StoreUint32(&o.MCMD.Reg, volatile.LoadUint32(&o.MCMD.Reg)&^(0xe00000)|value<<21)
}
func (o *SPIFI_Type) GetMCMD_FRAMEFORM() uint32 {
	return (volatile.LoadUint32(&o.MCMD.Reg) & 0xe00000) >> 21
}
func (o *SPIFI_Type) SetMCMD_OPCODE(value uint32) {
	volatile.StoreUint32(&o.MCMD.Reg, volatile.LoadUint32(&o.MCMD.Reg)&^(0xff000000)|value<<24)
}
func (o *SPIFI_Type) GetMCMD_OPCODE() uint32 {
	return (volatile.LoadUint32(&o.MCMD.Reg) & 0xff000000) >> 24
}

// SPIFI.STAT: SPIFI status register
func (o *SPIFI_Type) SetSTAT_MCINIT(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x1)|value)
}
func (o *SPIFI_Type) GetSTAT_MCINIT() uint32 {
	return volatile.LoadUint32(&o.STAT.Reg) & 0x1
}
func (o *SPIFI_Type) SetSTAT_CMD(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x2)|value<<1)
}
func (o *SPIFI_Type) GetSTAT_CMD() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x2) >> 1
}
func (o *SPIFI_Type) SetSTAT_RESET(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x10)|value<<4)
}
func (o *SPIFI_Type) GetSTAT_RESET() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x10) >> 4
}
func (o *SPIFI_Type) SetSTAT_INTRQ(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x20)|value<<5)
}
func (o *SPIFI_Type) GetSTAT_INTRQ() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x20) >> 5
}
func (o *SPIFI_Type) SetSTAT_VERSION(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0xff000000)|value<<24)
}
func (o *SPIFI_Type) GetSTAT_VERSION() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0xff000000) >> 24
}

// flash
type FLASH_Type struct {
	INI_RD_EN      volatile.Register32 // 0x0
	ERASE_CTRL     volatile.Register32 // 0x4
	ERASE_TIME     volatile.Register32 // 0x8
	TIME_CTRL      volatile.Register32 // 0xC
	SMART_CTRL     volatile.Register32 // 0x10
	INTEN          volatile.Register32 // 0x14
	INT_STAT       volatile.Register32 // 0x18
	INTCLR         volatile.Register32 // 0x1C
	LOCK_STAT0     volatile.Register32 // 0x20
	LOCK_STAT1     volatile.Register32 // 0x24
	LOCK_STAT2     volatile.Register32 // 0x28
	LOCK_STAT3     volatile.Register32 // 0x2C
	LOCK_STAT4     volatile.Register32 // 0x30
	LOCK_STAT5     volatile.Register32 // 0x34
	LOCK_STAT6     volatile.Register32 // 0x38
	LOCK_STAT7     volatile.Register32 // 0x3C
	LOCK_STAT8     volatile.Register32 // 0x40
	_              [4]byte
	STATUS1        volatile.Register32 // 0x48
	_              [16]byte
	ERR_INFOL1     volatile.Register32 // 0x5C
	ERR_INFOL2     volatile.Register32 // 0x60
	ERR_INFOL3     volatile.Register32 // 0x64
	ERR_INFOH1     volatile.Register32 // 0x68
	ERR_INFOH2     volatile.Register32 // 0x6C
	ERR_INFOH3     volatile.Register32 // 0x70
	_              [52]byte
	DEBUG_PASSWORD volatile.Register32 // 0xA8
	ERASE_PASSWORD volatile.Register32 // 0xAC
}

// FLASH.INI_RD_EN: flash initial read register
func (o *FLASH_Type) SetINI_RD_EN(value uint32) {
	volatile.StoreUint32(&o.INI_RD_EN.Reg, volatile.LoadUint32(&o.INI_RD_EN.Reg)&^(0x1)|value)
}
func (o *FLASH_Type) GetINI_RD_EN() uint32 {
	return volatile.LoadUint32(&o.INI_RD_EN.Reg) & 0x1
}

// FLASH.ERASE_CTRL: flash erase control register
func (o *FLASH_Type) SetERASE_CTRL_PAGE_IDXL(value uint32) {
	volatile.StoreUint32(&o.ERASE_CTRL.Reg, volatile.LoadUint32(&o.ERASE_CTRL.Reg)&^(0x7f)|value)
}
func (o *FLASH_Type) GetERASE_CTRL_PAGE_IDXL() uint32 {
	return volatile.LoadUint32(&o.ERASE_CTRL.Reg) & 0x7f
}
func (o *FLASH_Type) SetERASE_CTRL_PAGE_IDXH(value uint32) {
	volatile.StoreUint32(&o.ERASE_CTRL.Reg, volatile.LoadUint32(&o.ERASE_CTRL.Reg)&^(0x7f00)|value<<8)
}
func (o *FLASH_Type) GetERASE_CTRL_PAGE_IDXH() uint32 {
	return (volatile.LoadUint32(&o.ERASE_CTRL.Reg) & 0x7f00) >> 8
}
func (o *FLASH_Type) SetERASE_CTRL_HALF_ERASEL_EN(value uint32) {
	volatile.StoreUint32(&o.ERASE_CTRL.Reg, volatile.LoadUint32(&o.ERASE_CTRL.Reg)&^(0x10000000)|value<<28)
}
func (o *FLASH_Type) GetERASE_CTRL_HALF_ERASEL_EN() uint32 {
	return (volatile.LoadUint32(&o.ERASE_CTRL.Reg) & 0x10000000) >> 28
}
func (o *FLASH_Type) SetERASE_CTRL_HALF_ERASEH_EN(value uint32) {
	volatile.StoreUint32(&o.ERASE_CTRL.Reg, volatile.LoadUint32(&o.ERASE_CTRL.Reg)&^(0x20000000)|value<<29)
}
func (o *FLASH_Type) GetERASE_CTRL_HALF_ERASEH_EN() uint32 {
	return (volatile.LoadUint32(&o.ERASE_CTRL.Reg) & 0x20000000) >> 29
}
func (o *FLASH_Type) SetERASE_CTRL_PAGE_ERASEL_EN(value uint32) {
	volatile.StoreUint32(&o.ERASE_CTRL.Reg, volatile.LoadUint32(&o.ERASE_CTRL.Reg)&^(0x40000000)|value<<30)
}
func (o *FLASH_Type) GetERASE_CTRL_PAGE_ERASEL_EN() uint32 {
	return (volatile.LoadUint32(&o.ERASE_CTRL.Reg) & 0x40000000) >> 30
}
func (o *FLASH_Type) SetERASE_CTRL_PAGE_ERASEH_EN(value uint32) {
	volatile.StoreUint32(&o.ERASE_CTRL.Reg, volatile.LoadUint32(&o.ERASE_CTRL.Reg)&^(0x80000000)|value<<31)
}
func (o *FLASH_Type) GetERASE_CTRL_PAGE_ERASEH_EN() uint32 {
	return (volatile.LoadUint32(&o.ERASE_CTRL.Reg) & 0x80000000) >> 31
}

// FLASH.ERASE_TIME: flash erase time setting register
func (o *FLASH_Type) SetERASE_TIME_ERASE_TIME_BASE(value uint32) {
	volatile.StoreUint32(&o.ERASE_TIME.Reg, volatile.LoadUint32(&o.ERASE_TIME.Reg)&^(0xfffff)|value)
}
func (o *FLASH_Type) GetERASE_TIME_ERASE_TIME_BASE() uint32 {
	return volatile.LoadUint32(&o.ERASE_TIME.Reg) & 0xfffff
}

// FLASH.TIME_CTRL: flash operation time setting register
func (o *FLASH_Type) SetTIME_CTRL_PRGM_CYCLE(value uint32) {
	volatile.StoreUint32(&o.TIME_CTRL.Reg, volatile.LoadUint32(&o.TIME_CTRL.Reg)&^(0xfff)|value)
}
func (o *FLASH_Type) GetTIME_CTRL_PRGM_CYCLE() uint32 {
	return volatile.LoadUint32(&o.TIME_CTRL.Reg) & 0xfff
}
func (o *FLASH_Type) SetTIME_CTRL_TIME_BASE(value uint32) {
	volatile.StoreUint32(&o.TIME_CTRL.Reg, volatile.LoadUint32(&o.TIME_CTRL.Reg)&^(0xff000)|value<<12)
}
func (o *FLASH_Type) GetTIME_CTRL_TIME_BASE() uint32 {
	return (volatile.LoadUint32(&o.TIME_CTRL.Reg) & 0xff000) >> 12
}

// FLASH.SMART_CTRL: smart erase control register
func (o *FLASH_Type) SetSMART_CTRL_PRGML_EN(value uint32) {
	volatile.StoreUint32(&o.SMART_CTRL.Reg, volatile.LoadUint32(&o.SMART_CTRL.Reg)&^(0x1)|value)
}
func (o *FLASH_Type) GetSMART_CTRL_PRGML_EN() uint32 {
	return volatile.LoadUint32(&o.SMART_CTRL.Reg) & 0x1
}
func (o *FLASH_Type) SetSMART_CTRL_PRGMH_EN(value uint32) {
	volatile.StoreUint32(&o.SMART_CTRL.Reg, volatile.LoadUint32(&o.SMART_CTRL.Reg)&^(0x2)|value<<1)
}
func (o *FLASH_Type) GetSMART_CTRL_PRGMH_EN() uint32 {
	return (volatile.LoadUint32(&o.SMART_CTRL.Reg) & 0x2) >> 1
}
func (o *FLASH_Type) SetSMART_CTRL_SMART_WRITEL_EN(value uint32) {
	volatile.StoreUint32(&o.SMART_CTRL.Reg, volatile.LoadUint32(&o.SMART_CTRL.Reg)&^(0x4)|value<<2)
}
func (o *FLASH_Type) GetSMART_CTRL_SMART_WRITEL_EN() uint32 {
	return (volatile.LoadUint32(&o.SMART_CTRL.Reg) & 0x4) >> 2
}
func (o *FLASH_Type) SetSMART_CTRL_SMART_WRITEH_EN(value uint32) {
	volatile.StoreUint32(&o.SMART_CTRL.Reg, volatile.LoadUint32(&o.SMART_CTRL.Reg)&^(0x8)|value<<3)
}
func (o *FLASH_Type) GetSMART_CTRL_SMART_WRITEH_EN() uint32 {
	return (volatile.LoadUint32(&o.SMART_CTRL.Reg) & 0x8) >> 3
}
func (o *FLASH_Type) SetSMART_CTRL_SMART_ERASEL_EN(value uint32) {
	volatile.StoreUint32(&o.SMART_CTRL.Reg, volatile.LoadUint32(&o.SMART_CTRL.Reg)&^(0x10)|value<<4)
}
func (o *FLASH_Type) GetSMART_CTRL_SMART_ERASEL_EN() uint32 {
	return (volatile.LoadUint32(&o.SMART_CTRL.Reg) & 0x10) >> 4
}
func (o *FLASH_Type) SetSMART_CTRL_SMART_ERASEH_EN(value uint32) {
	volatile.StoreUint32(&o.SMART_CTRL.Reg, volatile.LoadUint32(&o.SMART_CTRL.Reg)&^(0x20)|value<<5)
}
func (o *FLASH_Type) GetSMART_CTRL_SMART_ERASEH_EN() uint32 {
	return (volatile.LoadUint32(&o.SMART_CTRL.Reg) & 0x20) >> 5
}
func (o *FLASH_Type) SetSMART_CTRL_MAX_WRITE(value uint32) {
	volatile.StoreUint32(&o.SMART_CTRL.Reg, volatile.LoadUint32(&o.SMART_CTRL.Reg)&^(0xf00)|value<<8)
}
func (o *FLASH_Type) GetSMART_CTRL_MAX_WRITE() uint32 {
	return (volatile.LoadUint32(&o.SMART_CTRL.Reg) & 0xf00) >> 8
}
func (o *FLASH_Type) SetSMART_CTRL_MAX_ERASE(value uint32) {
	volatile.StoreUint32(&o.SMART_CTRL.Reg, volatile.LoadUint32(&o.SMART_CTRL.Reg)&^(0x3f000)|value<<12)
}
func (o *FLASH_Type) GetSMART_CTRL_MAX_ERASE() uint32 {
	return (volatile.LoadUint32(&o.SMART_CTRL.Reg) & 0x3f000) >> 12
}

// FLASH.INTEN: interrupt enable register
func (o *FLASH_Type) SetINTEN_AHBL_INTEN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x1)|value)
}
func (o *FLASH_Type) GetINTEN_AHBL_INTEN() uint32 {
	return volatile.LoadUint32(&o.INTEN.Reg) & 0x1
}
func (o *FLASH_Type) SetINTEN_LOCKL_INTEN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x2)|value<<1)
}
func (o *FLASH_Type) GetINTEN_LOCKL_INTEN() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x2) >> 1
}
func (o *FLASH_Type) SetINTEN_ERASEL_INTEN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x4)|value<<2)
}
func (o *FLASH_Type) GetINTEN_ERASEL_INTEN() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x4) >> 2
}
func (o *FLASH_Type) SetINTEN_WRITEL_INTEN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x8)|value<<3)
}
func (o *FLASH_Type) GetINTEN_WRITEL_INTEN() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x8) >> 3
}
func (o *FLASH_Type) SetINTEN_WRBUFL_INTEN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x10)|value<<4)
}
func (o *FLASH_Type) GetINTEN_WRBUFL_INTEN() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x10) >> 4
}
func (o *FLASH_Type) SetINTEN_AHBH_INTEN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x100)|value<<8)
}
func (o *FLASH_Type) GetINTEN_AHBH_INTEN() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x100) >> 8
}
func (o *FLASH_Type) SetINTEN_LOCKH_INTEN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x200)|value<<9)
}
func (o *FLASH_Type) GetINTEN_LOCKH_INTEN() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x200) >> 9
}
func (o *FLASH_Type) SetINTEN_ERASEH_INTEN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x400)|value<<10)
}
func (o *FLASH_Type) GetINTEN_ERASEH_INTEN() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x400) >> 10
}
func (o *FLASH_Type) SetINTEN_WRITEH_INTEN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x800)|value<<11)
}
func (o *FLASH_Type) GetINTEN_WRITEH_INTEN() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x800) >> 11
}
func (o *FLASH_Type) SetINTEN_WRBUFH_INTEN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x1000)|value<<12)
}
func (o *FLASH_Type) GetINTEN_WRBUFH_INTEN() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x1000) >> 12
}
func (o *FLASH_Type) SetINTEN_FLASH_INTEN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x80000000)|value<<31)
}
func (o *FLASH_Type) GetINTEN_FLASH_INTEN() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x80000000) >> 31
}

// FLASH.INT_STAT: interrupt status register
func (o *FLASH_Type) SetINT_STAT_AHBL_INT(value uint32) {
	volatile.StoreUint32(&o.INT_STAT.Reg, volatile.LoadUint32(&o.INT_STAT.Reg)&^(0x1)|value)
}
func (o *FLASH_Type) GetINT_STAT_AHBL_INT() uint32 {
	return volatile.LoadUint32(&o.INT_STAT.Reg) & 0x1
}
func (o *FLASH_Type) SetINT_STAT_LOCKL_INT(value uint32) {
	volatile.StoreUint32(&o.INT_STAT.Reg, volatile.LoadUint32(&o.INT_STAT.Reg)&^(0x2)|value<<1)
}
func (o *FLASH_Type) GetINT_STAT_LOCKL_INT() uint32 {
	return (volatile.LoadUint32(&o.INT_STAT.Reg) & 0x2) >> 1
}
func (o *FLASH_Type) SetINT_STAT_ERASEL_INT(value uint32) {
	volatile.StoreUint32(&o.INT_STAT.Reg, volatile.LoadUint32(&o.INT_STAT.Reg)&^(0x4)|value<<2)
}
func (o *FLASH_Type) GetINT_STAT_ERASEL_INT() uint32 {
	return (volatile.LoadUint32(&o.INT_STAT.Reg) & 0x4) >> 2
}
func (o *FLASH_Type) SetINT_STAT_WRITEL_INT(value uint32) {
	volatile.StoreUint32(&o.INT_STAT.Reg, volatile.LoadUint32(&o.INT_STAT.Reg)&^(0x8)|value<<3)
}
func (o *FLASH_Type) GetINT_STAT_WRITEL_INT() uint32 {
	return (volatile.LoadUint32(&o.INT_STAT.Reg) & 0x8) >> 3
}
func (o *FLASH_Type) SetINT_STAT_WRBUFL_INT(value uint32) {
	volatile.StoreUint32(&o.INT_STAT.Reg, volatile.LoadUint32(&o.INT_STAT.Reg)&^(0x10)|value<<4)
}
func (o *FLASH_Type) GetINT_STAT_WRBUFL_INT() uint32 {
	return (volatile.LoadUint32(&o.INT_STAT.Reg) & 0x10) >> 4
}
func (o *FLASH_Type) SetINT_STAT_WRITE_FAIL_L_INT(value uint32) {
	volatile.StoreUint32(&o.INT_STAT.Reg, volatile.LoadUint32(&o.INT_STAT.Reg)&^(0x20)|value<<5)
}
func (o *FLASH_Type) GetINT_STAT_WRITE_FAIL_L_INT() uint32 {
	return (volatile.LoadUint32(&o.INT_STAT.Reg) & 0x20) >> 5
}
func (o *FLASH_Type) SetINT_STAT_ERASE_FAIL_L_INT(value uint32) {
	volatile.StoreUint32(&o.INT_STAT.Reg, volatile.LoadUint32(&o.INT_STAT.Reg)&^(0x40)|value<<6)
}
func (o *FLASH_Type) GetINT_STAT_ERASE_FAIL_L_INT() uint32 {
	return (volatile.LoadUint32(&o.INT_STAT.Reg) & 0x40) >> 6
}
func (o *FLASH_Type) SetINT_STAT_AHBH_INT(value uint32) {
	volatile.StoreUint32(&o.INT_STAT.Reg, volatile.LoadUint32(&o.INT_STAT.Reg)&^(0x100)|value<<8)
}
func (o *FLASH_Type) GetINT_STAT_AHBH_INT() uint32 {
	return (volatile.LoadUint32(&o.INT_STAT.Reg) & 0x100) >> 8
}
func (o *FLASH_Type) SetINT_STAT_LOCKH_INT(value uint32) {
	volatile.StoreUint32(&o.INT_STAT.Reg, volatile.LoadUint32(&o.INT_STAT.Reg)&^(0x200)|value<<9)
}
func (o *FLASH_Type) GetINT_STAT_LOCKH_INT() uint32 {
	return (volatile.LoadUint32(&o.INT_STAT.Reg) & 0x200) >> 9
}
func (o *FLASH_Type) SetINT_STAT_ERASEH_INT(value uint32) {
	volatile.StoreUint32(&o.INT_STAT.Reg, volatile.LoadUint32(&o.INT_STAT.Reg)&^(0x400)|value<<10)
}
func (o *FLASH_Type) GetINT_STAT_ERASEH_INT() uint32 {
	return (volatile.LoadUint32(&o.INT_STAT.Reg) & 0x400) >> 10
}
func (o *FLASH_Type) SetINT_STAT_WRITEH_INT(value uint32) {
	volatile.StoreUint32(&o.INT_STAT.Reg, volatile.LoadUint32(&o.INT_STAT.Reg)&^(0x800)|value<<11)
}
func (o *FLASH_Type) GetINT_STAT_WRITEH_INT() uint32 {
	return (volatile.LoadUint32(&o.INT_STAT.Reg) & 0x800) >> 11
}
func (o *FLASH_Type) SetINT_STAT_WRBUFH_INT(value uint32) {
	volatile.StoreUint32(&o.INT_STAT.Reg, volatile.LoadUint32(&o.INT_STAT.Reg)&^(0x1000)|value<<12)
}
func (o *FLASH_Type) GetINT_STAT_WRBUFH_INT() uint32 {
	return (volatile.LoadUint32(&o.INT_STAT.Reg) & 0x1000) >> 12
}
func (o *FLASH_Type) SetINT_STAT_WRITE_FAIL_H_INT(value uint32) {
	volatile.StoreUint32(&o.INT_STAT.Reg, volatile.LoadUint32(&o.INT_STAT.Reg)&^(0x2000)|value<<13)
}
func (o *FLASH_Type) GetINT_STAT_WRITE_FAIL_H_INT() uint32 {
	return (volatile.LoadUint32(&o.INT_STAT.Reg) & 0x2000) >> 13
}
func (o *FLASH_Type) SetINT_STAT_ERASE_FAIL_H_INT(value uint32) {
	volatile.StoreUint32(&o.INT_STAT.Reg, volatile.LoadUint32(&o.INT_STAT.Reg)&^(0x4000)|value<<14)
}
func (o *FLASH_Type) GetINT_STAT_ERASE_FAIL_H_INT() uint32 {
	return (volatile.LoadUint32(&o.INT_STAT.Reg) & 0x4000) >> 14
}

// FLASH.INTCLR: interrupt clear register
func (o *FLASH_Type) SetINTCLR_AHBL_INTCLR(value uint32) {
	volatile.StoreUint32(&o.INTCLR.Reg, volatile.LoadUint32(&o.INTCLR.Reg)&^(0x1)|value)
}
func (o *FLASH_Type) GetINTCLR_AHBL_INTCLR() uint32 {
	return volatile.LoadUint32(&o.INTCLR.Reg) & 0x1
}
func (o *FLASH_Type) SetINTCLR_LOCKL_INTCLR(value uint32) {
	volatile.StoreUint32(&o.INTCLR.Reg, volatile.LoadUint32(&o.INTCLR.Reg)&^(0x2)|value<<1)
}
func (o *FLASH_Type) GetINTCLR_LOCKL_INTCLR() uint32 {
	return (volatile.LoadUint32(&o.INTCLR.Reg) & 0x2) >> 1
}
func (o *FLASH_Type) SetINTCLR_ERASEL_INTCLR(value uint32) {
	volatile.StoreUint32(&o.INTCLR.Reg, volatile.LoadUint32(&o.INTCLR.Reg)&^(0x4)|value<<2)
}
func (o *FLASH_Type) GetINTCLR_ERASEL_INTCLR() uint32 {
	return (volatile.LoadUint32(&o.INTCLR.Reg) & 0x4) >> 2
}
func (o *FLASH_Type) SetINTCLR_WRITEL_INTCLR(value uint32) {
	volatile.StoreUint32(&o.INTCLR.Reg, volatile.LoadUint32(&o.INTCLR.Reg)&^(0x8)|value<<3)
}
func (o *FLASH_Type) GetINTCLR_WRITEL_INTCLR() uint32 {
	return (volatile.LoadUint32(&o.INTCLR.Reg) & 0x8) >> 3
}
func (o *FLASH_Type) SetINTCLR_AHBH_INTCLR(value uint32) {
	volatile.StoreUint32(&o.INTCLR.Reg, volatile.LoadUint32(&o.INTCLR.Reg)&^(0x100)|value<<8)
}
func (o *FLASH_Type) GetINTCLR_AHBH_INTCLR() uint32 {
	return (volatile.LoadUint32(&o.INTCLR.Reg) & 0x100) >> 8
}
func (o *FLASH_Type) SetINTCLR_LOCKH_INTCLR(value uint32) {
	volatile.StoreUint32(&o.INTCLR.Reg, volatile.LoadUint32(&o.INTCLR.Reg)&^(0x200)|value<<9)
}
func (o *FLASH_Type) GetINTCLR_LOCKH_INTCLR() uint32 {
	return (volatile.LoadUint32(&o.INTCLR.Reg) & 0x200) >> 9
}
func (o *FLASH_Type) SetINTCLR_ERASEH_INTCLR(value uint32) {
	volatile.StoreUint32(&o.INTCLR.Reg, volatile.LoadUint32(&o.INTCLR.Reg)&^(0x400)|value<<10)
}
func (o *FLASH_Type) GetINTCLR_ERASEH_INTCLR() uint32 {
	return (volatile.LoadUint32(&o.INTCLR.Reg) & 0x400) >> 10
}
func (o *FLASH_Type) SetINTCLR_WRITEH_INTCLR(value uint32) {
	volatile.StoreUint32(&o.INTCLR.Reg, volatile.LoadUint32(&o.INTCLR.Reg)&^(0x800)|value<<11)
}
func (o *FLASH_Type) GetINTCLR_WRITEH_INTCLR() uint32 {
	return (volatile.LoadUint32(&o.INTCLR.Reg) & 0x800) >> 11
}

// FLASH.LOCK_STAT0: lock control register 0
func (o *FLASH_Type) SetLOCK_STAT0(value uint32) {
	volatile.StoreUint32(&o.LOCK_STAT0.Reg, value)
}
func (o *FLASH_Type) GetLOCK_STAT0() uint32 {
	return volatile.LoadUint32(&o.LOCK_STAT0.Reg)
}

// FLASH.LOCK_STAT1: no description available
func (o *FLASH_Type) SetLOCK_STAT1(value uint32) {
	volatile.StoreUint32(&o.LOCK_STAT1.Reg, value)
}
func (o *FLASH_Type) GetLOCK_STAT1() uint32 {
	return volatile.LoadUint32(&o.LOCK_STAT1.Reg)
}

// FLASH.LOCK_STAT2: no description available
func (o *FLASH_Type) SetLOCK_STAT2(value uint32) {
	volatile.StoreUint32(&o.LOCK_STAT2.Reg, value)
}
func (o *FLASH_Type) GetLOCK_STAT2() uint32 {
	return volatile.LoadUint32(&o.LOCK_STAT2.Reg)
}

// FLASH.LOCK_STAT3: no description available
func (o *FLASH_Type) SetLOCK_STAT3(value uint32) {
	volatile.StoreUint32(&o.LOCK_STAT3.Reg, value)
}
func (o *FLASH_Type) GetLOCK_STAT3() uint32 {
	return volatile.LoadUint32(&o.LOCK_STAT3.Reg)
}

// FLASH.LOCK_STAT4: no description available
func (o *FLASH_Type) SetLOCK_STAT4(value uint32) {
	volatile.StoreUint32(&o.LOCK_STAT4.Reg, value)
}
func (o *FLASH_Type) GetLOCK_STAT4() uint32 {
	return volatile.LoadUint32(&o.LOCK_STAT4.Reg)
}

// FLASH.LOCK_STAT5: no description available
func (o *FLASH_Type) SetLOCK_STAT5(value uint32) {
	volatile.StoreUint32(&o.LOCK_STAT5.Reg, value)
}
func (o *FLASH_Type) GetLOCK_STAT5() uint32 {
	return volatile.LoadUint32(&o.LOCK_STAT5.Reg)
}

// FLASH.LOCK_STAT6: no description available
func (o *FLASH_Type) SetLOCK_STAT6(value uint32) {
	volatile.StoreUint32(&o.LOCK_STAT6.Reg, value)
}
func (o *FLASH_Type) GetLOCK_STAT6() uint32 {
	return volatile.LoadUint32(&o.LOCK_STAT6.Reg)
}

// FLASH.LOCK_STAT7: no description available
func (o *FLASH_Type) SetLOCK_STAT7(value uint32) {
	volatile.StoreUint32(&o.LOCK_STAT7.Reg, value)
}
func (o *FLASH_Type) GetLOCK_STAT7() uint32 {
	return volatile.LoadUint32(&o.LOCK_STAT7.Reg)
}

// FLASH.LOCK_STAT8: no description available
func (o *FLASH_Type) SetLOCK_STAT8_MASS_ERASE_LOCK(value uint32) {
	volatile.StoreUint32(&o.LOCK_STAT8.Reg, volatile.LoadUint32(&o.LOCK_STAT8.Reg)&^(0x1)|value)
}
func (o *FLASH_Type) GetLOCK_STAT8_MASS_ERASE_LOCK() uint32 {
	return volatile.LoadUint32(&o.LOCK_STAT8.Reg) & 0x1
}
func (o *FLASH_Type) SetLOCK_STAT8_FSH_PROTECT(value uint32) {
	volatile.StoreUint32(&o.LOCK_STAT8.Reg, volatile.LoadUint32(&o.LOCK_STAT8.Reg)&^(0x2)|value<<1)
}
func (o *FLASH_Type) GetLOCK_STAT8_FSH_PROTECT() uint32 {
	return (volatile.LoadUint32(&o.LOCK_STAT8.Reg) & 0x2) >> 1
}
func (o *FLASH_Type) SetLOCK_STAT8_MEM_PROTECT(value uint32) {
	volatile.StoreUint32(&o.LOCK_STAT8.Reg, volatile.LoadUint32(&o.LOCK_STAT8.Reg)&^(0x4)|value<<2)
}
func (o *FLASH_Type) GetLOCK_STAT8_MEM_PROTECT() uint32 {
	return (volatile.LoadUint32(&o.LOCK_STAT8.Reg) & 0x4) >> 2
}

// FLASH.STATUS1: no description available
func (o *FLASH_Type) SetSTATUS1_FSH_ERA_BUSY_L(value uint32) {
	volatile.StoreUint32(&o.STATUS1.Reg, volatile.LoadUint32(&o.STATUS1.Reg)&^(0x200)|value<<9)
}
func (o *FLASH_Type) GetSTATUS1_FSH_ERA_BUSY_L() uint32 {
	return (volatile.LoadUint32(&o.STATUS1.Reg) & 0x200) >> 9
}
func (o *FLASH_Type) SetSTATUS1_FSH_WR_BUSY_L(value uint32) {
	volatile.StoreUint32(&o.STATUS1.Reg, volatile.LoadUint32(&o.STATUS1.Reg)&^(0x400)|value<<10)
}
func (o *FLASH_Type) GetSTATUS1_FSH_WR_BUSY_L() uint32 {
	return (volatile.LoadUint32(&o.STATUS1.Reg) & 0x400) >> 10
}
func (o *FLASH_Type) SetSTATUS1_DBG_ERA_DONE_L(value uint32) {
	volatile.StoreUint32(&o.STATUS1.Reg, volatile.LoadUint32(&o.STATUS1.Reg)&^(0x800)|value<<11)
}
func (o *FLASH_Type) GetSTATUS1_DBG_ERA_DONE_L() uint32 {
	return (volatile.LoadUint32(&o.STATUS1.Reg) & 0x800) >> 11
}
func (o *FLASH_Type) SetSTATUS1_FSH_ERA_BUSY_H(value uint32) {
	volatile.StoreUint32(&o.STATUS1.Reg, volatile.LoadUint32(&o.STATUS1.Reg)&^(0x1000)|value<<12)
}
func (o *FLASH_Type) GetSTATUS1_FSH_ERA_BUSY_H() uint32 {
	return (volatile.LoadUint32(&o.STATUS1.Reg) & 0x1000) >> 12
}
func (o *FLASH_Type) SetSTATUS1_FSH_WR_BUSY_H(value uint32) {
	volatile.StoreUint32(&o.STATUS1.Reg, volatile.LoadUint32(&o.STATUS1.Reg)&^(0x2000)|value<<13)
}
func (o *FLASH_Type) GetSTATUS1_FSH_WR_BUSY_H() uint32 {
	return (volatile.LoadUint32(&o.STATUS1.Reg) & 0x2000) >> 13
}
func (o *FLASH_Type) SetSTATUS1_DBG_ERA_DONE_H(value uint32) {
	volatile.StoreUint32(&o.STATUS1.Reg, volatile.LoadUint32(&o.STATUS1.Reg)&^(0x4000)|value<<14)
}
func (o *FLASH_Type) GetSTATUS1_DBG_ERA_DONE_H() uint32 {
	return (volatile.LoadUint32(&o.STATUS1.Reg) & 0x4000) >> 14
}
func (o *FLASH_Type) SetSTATUS1_INI_RD_DONE(value uint32) {
	volatile.StoreUint32(&o.STATUS1.Reg, volatile.LoadUint32(&o.STATUS1.Reg)&^(0x8000)|value<<15)
}
func (o *FLASH_Type) GetSTATUS1_INI_RD_DONE() uint32 {
	return (volatile.LoadUint32(&o.STATUS1.Reg) & 0x8000) >> 15
}
func (o *FLASH_Type) SetSTATUS1_FSH_STA(value uint32) {
	volatile.StoreUint32(&o.STATUS1.Reg, volatile.LoadUint32(&o.STATUS1.Reg)&^(0x4000000)|value<<26)
}
func (o *FLASH_Type) GetSTATUS1_FSH_STA() uint32 {
	return (volatile.LoadUint32(&o.STATUS1.Reg) & 0x4000000) >> 26
}
func (o *FLASH_Type) SetSTATUS1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATUS1.Reg, volatile.LoadUint32(&o.STATUS1.Reg)&^(0xf8000000)|value<<27)
}
func (o *FLASH_Type) GetSTATUS1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATUS1.Reg) & 0xf8000000) >> 27
}

// FLASH.ERR_INFOL1: no description available
func (o *FLASH_Type) SetERR_INFOL1_WR_FAILEDL_ADDR(value uint32) {
	volatile.StoreUint32(&o.ERR_INFOL1.Reg, volatile.LoadUint32(&o.ERR_INFOL1.Reg)&^(0x3ffff)|value)
}
func (o *FLASH_Type) GetERR_INFOL1_WR_FAILEDL_ADDR() uint32 {
	return volatile.LoadUint32(&o.ERR_INFOL1.Reg) & 0x3ffff
}
func (o *FLASH_Type) SetERR_INFOL1_SMART_FAILL_CTR(value uint32) {
	volatile.StoreUint32(&o.ERR_INFOL1.Reg, volatile.LoadUint32(&o.ERR_INFOL1.Reg)&^(0xfc0000)|value<<18)
}
func (o *FLASH_Type) GetERR_INFOL1_SMART_FAILL_CTR() uint32 {
	return (volatile.LoadUint32(&o.ERR_INFOL1.Reg) & 0xfc0000) >> 18
}

// FLASH.ERR_INFOL2: no description available
func (o *FLASH_Type) SetERR_INFOL2(value uint32) {
	volatile.StoreUint32(&o.ERR_INFOL2.Reg, value)
}
func (o *FLASH_Type) GetERR_INFOL2() uint32 {
	return volatile.LoadUint32(&o.ERR_INFOL2.Reg)
}

// FLASH.ERR_INFOL3: no description available
func (o *FLASH_Type) SetERR_INFOL3_ERA_FAILEDL_INFO(value uint32) {
	volatile.StoreUint32(&o.ERR_INFOL3.Reg, volatile.LoadUint32(&o.ERR_INFOL3.Reg)&^(0x3ffff)|value)
}
func (o *FLASH_Type) GetERR_INFOL3_ERA_FAILEDL_INFO() uint32 {
	return volatile.LoadUint32(&o.ERR_INFOL3.Reg) & 0x3ffff
}

// FLASH.ERR_INFOH1: no description available
func (o *FLASH_Type) SetERR_INFOH1_WR_FAILEDH_ADDR(value uint32) {
	volatile.StoreUint32(&o.ERR_INFOH1.Reg, volatile.LoadUint32(&o.ERR_INFOH1.Reg)&^(0x3ffff)|value)
}
func (o *FLASH_Type) GetERR_INFOH1_WR_FAILEDH_ADDR() uint32 {
	return volatile.LoadUint32(&o.ERR_INFOH1.Reg) & 0x3ffff
}
func (o *FLASH_Type) SetERR_INFOH1_SMART_FAILH_CTR(value uint32) {
	volatile.StoreUint32(&o.ERR_INFOH1.Reg, volatile.LoadUint32(&o.ERR_INFOH1.Reg)&^(0xfc0000)|value<<18)
}
func (o *FLASH_Type) GetERR_INFOH1_SMART_FAILH_CTR() uint32 {
	return (volatile.LoadUint32(&o.ERR_INFOH1.Reg) & 0xfc0000) >> 18
}

// FLASH.ERR_INFOH2: no description available
func (o *FLASH_Type) SetERR_INFOH2(value uint32) {
	volatile.StoreUint32(&o.ERR_INFOH2.Reg, value)
}
func (o *FLASH_Type) GetERR_INFOH2() uint32 {
	return volatile.LoadUint32(&o.ERR_INFOH2.Reg)
}

// FLASH.ERR_INFOH3: no description available
func (o *FLASH_Type) SetERR_INFOH3_ERA_FAILEDH_INFO(value uint32) {
	volatile.StoreUint32(&o.ERR_INFOH3.Reg, volatile.LoadUint32(&o.ERR_INFOH3.Reg)&^(0x3ffff)|value)
}
func (o *FLASH_Type) GetERR_INFOH3_ERA_FAILEDH_INFO() uint32 {
	return volatile.LoadUint32(&o.ERR_INFOH3.Reg) & 0x3ffff
}

// FLASH.DEBUG_PASSWORD: no description available
func (o *FLASH_Type) SetDEBUG_PASSWORD(value uint32) {
	volatile.StoreUint32(&o.DEBUG_PASSWORD.Reg, value)
}
func (o *FLASH_Type) GetDEBUG_PASSWORD() uint32 {
	return volatile.LoadUint32(&o.DEBUG_PASSWORD.Reg)
}

// FLASH.ERASE_PASSWORD: no description available
func (o *FLASH_Type) SetERASE_PASSWORD(value uint32) {
	volatile.StoreUint32(&o.ERASE_PASSWORD.Reg, value)
}
func (o *FLASH_Type) GetERASE_PASSWORD() uint32 {
	return volatile.LoadUint32(&o.ERASE_PASSWORD.Reg)
}

// LPC5411x DMA controller
type DMA_Type struct {
	CTRL       volatile.Register32 // 0x0
	INTSTAT    volatile.Register32 // 0x4
	SRAMBASE   volatile.Register32 // 0x8
	_          [20]byte
	ENABLESET0 volatile.Register32 // 0x20
	_          [4]byte
	ENABLECLR0 volatile.Register32 // 0x28
	_          [4]byte
	ACTIVE0    volatile.Register32 // 0x30
	_          [4]byte
	BUSY0      volatile.Register32 // 0x38
	_          [4]byte
	ERRINT0    volatile.Register32 // 0x40
	_          [4]byte
	INTENSET0  volatile.Register32 // 0x48
	_          [4]byte
	INTENCLR0  volatile.Register32 // 0x50
	_          [4]byte
	INTA0      volatile.Register32 // 0x58
	_          [4]byte
	INTB0      volatile.Register32 // 0x60
	_          [4]byte
	SETVALID0  volatile.Register32 // 0x68
	_          [4]byte
	SETTRIG0   volatile.Register32 // 0x70
	_          [4]byte
	ABORT0     volatile.Register32 // 0x78
	_          [900]byte
	CHANNEL    [20]DMA_CHANNEL_Type // 0x400
}

// DMA.CTRL: DMA control.
func (o *DMA_Type) SetCTRL_ENABLE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetCTRL_ENABLE() uint32 {
	return volatile.LoadUint32(&o.CTRL.Reg) & 0x1
}

// DMA.INTSTAT: Interrupt status.
func (o *DMA_Type) SetINTSTAT_ACTIVEINT(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetINTSTAT_ACTIVEINT() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetINTSTAT_ACTIVEERRINT(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetINTSTAT_ACTIVEERRINT() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x4) >> 2
}

// DMA.SRAMBASE: SRAM address of the channel configuration table.
func (o *DMA_Type) SetSRAMBASE_OFFSET(value uint32) {
	volatile.StoreUint32(&o.SRAMBASE.Reg, volatile.LoadUint32(&o.SRAMBASE.Reg)&^(0xfffffe00)|value<<9)
}
func (o *DMA_Type) GetSRAMBASE_OFFSET() uint32 {
	return (volatile.LoadUint32(&o.SRAMBASE.Reg) & 0xfffffe00) >> 9
}

// DMA.ENABLESET0: Channel Enable read and Set for all DMA channels.
func (o *DMA_Type) SetENABLESET0(value uint32) {
	volatile.StoreUint32(&o.ENABLESET0.Reg, value)
}
func (o *DMA_Type) GetENABLESET0() uint32 {
	return volatile.LoadUint32(&o.ENABLESET0.Reg)
}

// DMA.ENABLECLR0: Channel Enable Clear for all DMA channels.
func (o *DMA_Type) SetENABLECLR0(value uint32) {
	volatile.StoreUint32(&o.ENABLECLR0.Reg, value)
}
func (o *DMA_Type) GetENABLECLR0() uint32 {
	return volatile.LoadUint32(&o.ENABLECLR0.Reg)
}

// DMA.ACTIVE0: Channel Active status for all DMA channels.
func (o *DMA_Type) SetACTIVE0(value uint32) {
	volatile.StoreUint32(&o.ACTIVE0.Reg, value)
}
func (o *DMA_Type) GetACTIVE0() uint32 {
	return volatile.LoadUint32(&o.ACTIVE0.Reg)
}

// DMA.BUSY0: Channel Busy status for all DMA channels.
func (o *DMA_Type) SetBUSY0(value uint32) {
	volatile.StoreUint32(&o.BUSY0.Reg, value)
}
func (o *DMA_Type) GetBUSY0() uint32 {
	return volatile.LoadUint32(&o.BUSY0.Reg)
}

// DMA.ERRINT0: Error Interrupt status for all DMA channels.
func (o *DMA_Type) SetERRINT0(value uint32) {
	volatile.StoreUint32(&o.ERRINT0.Reg, value)
}
func (o *DMA_Type) GetERRINT0() uint32 {
	return volatile.LoadUint32(&o.ERRINT0.Reg)
}

// DMA.INTENSET0: Interrupt Enable read and Set for all DMA channels.
func (o *DMA_Type) SetINTENSET0(value uint32) {
	volatile.StoreUint32(&o.INTENSET0.Reg, value)
}
func (o *DMA_Type) GetINTENSET0() uint32 {
	return volatile.LoadUint32(&o.INTENSET0.Reg)
}

// DMA.INTENCLR0: Interrupt Enable Clear for all DMA channels.
func (o *DMA_Type) SetINTENCLR0(value uint32) {
	volatile.StoreUint32(&o.INTENCLR0.Reg, value)
}
func (o *DMA_Type) GetINTENCLR0() uint32 {
	return volatile.LoadUint32(&o.INTENCLR0.Reg)
}

// DMA.INTA0: Interrupt A status for all DMA channels.
func (o *DMA_Type) SetINTA0(value uint32) {
	volatile.StoreUint32(&o.INTA0.Reg, value)
}
func (o *DMA_Type) GetINTA0() uint32 {
	return volatile.LoadUint32(&o.INTA0.Reg)
}

// DMA.INTB0: Interrupt B status for all DMA channels.
func (o *DMA_Type) SetINTB0(value uint32) {
	volatile.StoreUint32(&o.INTB0.Reg, value)
}
func (o *DMA_Type) GetINTB0() uint32 {
	return volatile.LoadUint32(&o.INTB0.Reg)
}

// DMA.SETVALID0: Set ValidPending control bits for all DMA channels.
func (o *DMA_Type) SetSETVALID0(value uint32) {
	volatile.StoreUint32(&o.SETVALID0.Reg, value)
}
func (o *DMA_Type) GetSETVALID0() uint32 {
	return volatile.LoadUint32(&o.SETVALID0.Reg)
}

// DMA.SETTRIG0: Set Trigger control bits for all DMA channels.
func (o *DMA_Type) SetSETTRIG0(value uint32) {
	volatile.StoreUint32(&o.SETTRIG0.Reg, value)
}
func (o *DMA_Type) GetSETTRIG0() uint32 {
	return volatile.LoadUint32(&o.SETTRIG0.Reg)
}

// DMA.ABORT0: Channel Abort control for all DMA channels.
func (o *DMA_Type) SetABORT0(value uint32) {
	volatile.StoreUint32(&o.ABORT0.Reg, value)
}
func (o *DMA_Type) GetABORT0() uint32 {
	return volatile.LoadUint32(&o.ABORT0.Reg)
}

// no description available
type DMA_CHANNEL_Type struct {
	CFG     volatile.Register32 // 0x400
	CTLSTAT volatile.Register32 // 0x404
	XFERCFG volatile.Register32 // 0x408
	_       [4]byte
}

// DMA_CHANNEL.CFG: Configuration register for DMA channel .
func (o *DMA_CHANNEL_Type) SetCFG_PERIPHREQEN(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0x1)|value)
}
func (o *DMA_CHANNEL_Type) GetCFG_PERIPHREQEN() uint32 {
	return volatile.LoadUint32(&o.CFG.Reg) & 0x1
}
func (o *DMA_CHANNEL_Type) SetCFG_HWTRIGEN(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0x2)|value<<1)
}
func (o *DMA_CHANNEL_Type) GetCFG_HWTRIGEN() uint32 {
	return (volatile.LoadUint32(&o.CFG.Reg) & 0x2) >> 1
}
func (o *DMA_CHANNEL_Type) SetCFG_TRIGPOL(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0x10)|value<<4)
}
func (o *DMA_CHANNEL_Type) GetCFG_TRIGPOL() uint32 {
	return (volatile.LoadUint32(&o.CFG.Reg) & 0x10) >> 4
}
func (o *DMA_CHANNEL_Type) SetCFG_TRIGTYPE(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0x20)|value<<5)
}
func (o *DMA_CHANNEL_Type) GetCFG_TRIGTYPE() uint32 {
	return (volatile.LoadUint32(&o.CFG.Reg) & 0x20) >> 5
}
func (o *DMA_CHANNEL_Type) SetCFG_TRIGBURST(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0x40)|value<<6)
}
func (o *DMA_CHANNEL_Type) GetCFG_TRIGBURST() uint32 {
	return (volatile.LoadUint32(&o.CFG.Reg) & 0x40) >> 6
}
func (o *DMA_CHANNEL_Type) SetCFG_BURSTPOWER(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0xf00)|value<<8)
}
func (o *DMA_CHANNEL_Type) GetCFG_BURSTPOWER() uint32 {
	return (volatile.LoadUint32(&o.CFG.Reg) & 0xf00) >> 8
}
func (o *DMA_CHANNEL_Type) SetCFG_SRCBURSTWRAP(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0x4000)|value<<14)
}
func (o *DMA_CHANNEL_Type) GetCFG_SRCBURSTWRAP() uint32 {
	return (volatile.LoadUint32(&o.CFG.Reg) & 0x4000) >> 14
}
func (o *DMA_CHANNEL_Type) SetCFG_DSTBURSTWRAP(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_CHANNEL_Type) GetCFG_DSTBURSTWRAP() uint32 {
	return (volatile.LoadUint32(&o.CFG.Reg) & 0x8000) >> 15
}
func (o *DMA_CHANNEL_Type) SetCFG_CHPRIORITY(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0x70000)|value<<16)
}
func (o *DMA_CHANNEL_Type) GetCFG_CHPRIORITY() uint32 {
	return (volatile.LoadUint32(&o.CFG.Reg) & 0x70000) >> 16
}

// DMA_CHANNEL.CTLSTAT: Control and status register for DMA channel .
func (o *DMA_CHANNEL_Type) SetCTLSTAT_VALIDPENDING(value uint32) {
	volatile.StoreUint32(&o.CTLSTAT.Reg, volatile.LoadUint32(&o.CTLSTAT.Reg)&^(0x1)|value)
}
func (o *DMA_CHANNEL_Type) GetCTLSTAT_VALIDPENDING() uint32 {
	return volatile.LoadUint32(&o.CTLSTAT.Reg) & 0x1
}
func (o *DMA_CHANNEL_Type) SetCTLSTAT_TRIG(value uint32) {
	volatile.StoreUint32(&o.CTLSTAT.Reg, volatile.LoadUint32(&o.CTLSTAT.Reg)&^(0x4)|value<<2)
}
func (o *DMA_CHANNEL_Type) GetCTLSTAT_TRIG() uint32 {
	return (volatile.LoadUint32(&o.CTLSTAT.Reg) & 0x4) >> 2
}

// DMA_CHANNEL.XFERCFG: Transfer configuration register for DMA channel .
func (o *DMA_CHANNEL_Type) SetXFERCFG_CFGVALID(value uint32) {
	volatile.StoreUint32(&o.XFERCFG.Reg, volatile.LoadUint32(&o.XFERCFG.Reg)&^(0x1)|value)
}
func (o *DMA_CHANNEL_Type) GetXFERCFG_CFGVALID() uint32 {
	return volatile.LoadUint32(&o.XFERCFG.Reg) & 0x1
}
func (o *DMA_CHANNEL_Type) SetXFERCFG_RELOAD(value uint32) {
	volatile.StoreUint32(&o.XFERCFG.Reg, volatile.LoadUint32(&o.XFERCFG.Reg)&^(0x2)|value<<1)
}
func (o *DMA_CHANNEL_Type) GetXFERCFG_RELOAD() uint32 {
	return (volatile.LoadUint32(&o.XFERCFG.Reg) & 0x2) >> 1
}
func (o *DMA_CHANNEL_Type) SetXFERCFG_SWTRIG(value uint32) {
	volatile.StoreUint32(&o.XFERCFG.Reg, volatile.LoadUint32(&o.XFERCFG.Reg)&^(0x4)|value<<2)
}
func (o *DMA_CHANNEL_Type) GetXFERCFG_SWTRIG() uint32 {
	return (volatile.LoadUint32(&o.XFERCFG.Reg) & 0x4) >> 2
}
func (o *DMA_CHANNEL_Type) SetXFERCFG_CLRTRIG(value uint32) {
	volatile.StoreUint32(&o.XFERCFG.Reg, volatile.LoadUint32(&o.XFERCFG.Reg)&^(0x8)|value<<3)
}
func (o *DMA_CHANNEL_Type) GetXFERCFG_CLRTRIG() uint32 {
	return (volatile.LoadUint32(&o.XFERCFG.Reg) & 0x8) >> 3
}
func (o *DMA_CHANNEL_Type) SetXFERCFG_SETINTA(value uint32) {
	volatile.StoreUint32(&o.XFERCFG.Reg, volatile.LoadUint32(&o.XFERCFG.Reg)&^(0x10)|value<<4)
}
func (o *DMA_CHANNEL_Type) GetXFERCFG_SETINTA() uint32 {
	return (volatile.LoadUint32(&o.XFERCFG.Reg) & 0x10) >> 4
}
func (o *DMA_CHANNEL_Type) SetXFERCFG_SETINTB(value uint32) {
	volatile.StoreUint32(&o.XFERCFG.Reg, volatile.LoadUint32(&o.XFERCFG.Reg)&^(0x20)|value<<5)
}
func (o *DMA_CHANNEL_Type) GetXFERCFG_SETINTB() uint32 {
	return (volatile.LoadUint32(&o.XFERCFG.Reg) & 0x20) >> 5
}
func (o *DMA_CHANNEL_Type) SetXFERCFG_WIDTH(value uint32) {
	volatile.StoreUint32(&o.XFERCFG.Reg, volatile.LoadUint32(&o.XFERCFG.Reg)&^(0x300)|value<<8)
}
func (o *DMA_CHANNEL_Type) GetXFERCFG_WIDTH() uint32 {
	return (volatile.LoadUint32(&o.XFERCFG.Reg) & 0x300) >> 8
}
func (o *DMA_CHANNEL_Type) SetXFERCFG_SRCINC(value uint32) {
	volatile.StoreUint32(&o.XFERCFG.Reg, volatile.LoadUint32(&o.XFERCFG.Reg)&^(0x3000)|value<<12)
}
func (o *DMA_CHANNEL_Type) GetXFERCFG_SRCINC() uint32 {
	return (volatile.LoadUint32(&o.XFERCFG.Reg) & 0x3000) >> 12
}
func (o *DMA_CHANNEL_Type) SetXFERCFG_DSTINC(value uint32) {
	volatile.StoreUint32(&o.XFERCFG.Reg, volatile.LoadUint32(&o.XFERCFG.Reg)&^(0xc000)|value<<14)
}
func (o *DMA_CHANNEL_Type) GetXFERCFG_DSTINC() uint32 {
	return (volatile.LoadUint32(&o.XFERCFG.Reg) & 0xc000) >> 14
}
func (o *DMA_CHANNEL_Type) SetXFERCFG_XFERCOUNT(value uint32) {
	volatile.StoreUint32(&o.XFERCFG.Reg, volatile.LoadUint32(&o.XFERCFG.Reg)&^(0x3ff0000)|value<<16)
}
func (o *DMA_CHANNEL_Type) GetXFERCFG_XFERCOUNT() uint32 {
	return (volatile.LoadUint32(&o.XFERCFG.Reg) & 0x3ff0000) >> 16
}

// flexcomm
type FLEXCOMM_Type struct {
	_      [3840]byte
	IOMODE volatile.Register32 // 0xF00
	_      [244]byte
	PSELID volatile.Register32 // 0xFF8
	PID    volatile.Register32 // 0xFFC
}

// FLEXCOMM.IOMODE: io mode register
func (o *FLEXCOMM_Type) SetIOMODE_DIO_MODE(value uint32) {
	volatile.StoreUint32(&o.IOMODE.Reg, volatile.LoadUint32(&o.IOMODE.Reg)&^(0x1)|value)
}
func (o *FLEXCOMM_Type) GetIOMODE_DIO_MODE() uint32 {
	return volatile.LoadUint32(&o.IOMODE.Reg) & 0x1
}
func (o *FLEXCOMM_Type) SetIOMODE_DIO_OEN(value uint32) {
	volatile.StoreUint32(&o.IOMODE.Reg, volatile.LoadUint32(&o.IOMODE.Reg)&^(0x2)|value<<1)
}
func (o *FLEXCOMM_Type) GetIOMODE_DIO_OEN() uint32 {
	return (volatile.LoadUint32(&o.IOMODE.Reg) & 0x2) >> 1
}

// FLEXCOMM.PSELID: Peripheral Select and Flexcomm ID register.
func (o *FLEXCOMM_Type) SetPSELID_PERSEL(value uint32) {
	volatile.StoreUint32(&o.PSELID.Reg, volatile.LoadUint32(&o.PSELID.Reg)&^(0x7)|value)
}
func (o *FLEXCOMM_Type) GetPSELID_PERSEL() uint32 {
	return volatile.LoadUint32(&o.PSELID.Reg) & 0x7
}
func (o *FLEXCOMM_Type) SetPSELID_LOCK(value uint32) {
	volatile.StoreUint32(&o.PSELID.Reg, volatile.LoadUint32(&o.PSELID.Reg)&^(0x8)|value<<3)
}
func (o *FLEXCOMM_Type) GetPSELID_LOCK() uint32 {
	return (volatile.LoadUint32(&o.PSELID.Reg) & 0x8) >> 3
}
func (o *FLEXCOMM_Type) SetPSELID_USARTPRESENT(value uint32) {
	volatile.StoreUint32(&o.PSELID.Reg, volatile.LoadUint32(&o.PSELID.Reg)&^(0x10)|value<<4)
}
func (o *FLEXCOMM_Type) GetPSELID_USARTPRESENT() uint32 {
	return (volatile.LoadUint32(&o.PSELID.Reg) & 0x10) >> 4
}
func (o *FLEXCOMM_Type) SetPSELID_SPIPRESENT(value uint32) {
	volatile.StoreUint32(&o.PSELID.Reg, volatile.LoadUint32(&o.PSELID.Reg)&^(0x20)|value<<5)
}
func (o *FLEXCOMM_Type) GetPSELID_SPIPRESENT() uint32 {
	return (volatile.LoadUint32(&o.PSELID.Reg) & 0x20) >> 5
}
func (o *FLEXCOMM_Type) SetPSELID_I2CPRESENT(value uint32) {
	volatile.StoreUint32(&o.PSELID.Reg, volatile.LoadUint32(&o.PSELID.Reg)&^(0x40)|value<<6)
}
func (o *FLEXCOMM_Type) GetPSELID_I2CPRESENT() uint32 {
	return (volatile.LoadUint32(&o.PSELID.Reg) & 0x40) >> 6
}
func (o *FLEXCOMM_Type) SetPSELID_I2SPRESENT(value uint32) {
	volatile.StoreUint32(&o.PSELID.Reg, volatile.LoadUint32(&o.PSELID.Reg)&^(0x80)|value<<7)
}
func (o *FLEXCOMM_Type) GetPSELID_I2SPRESENT() uint32 {
	return (volatile.LoadUint32(&o.PSELID.Reg) & 0x80) >> 7
}
func (o *FLEXCOMM_Type) SetPSELID_SC3W(value uint32) {
	volatile.StoreUint32(&o.PSELID.Reg, volatile.LoadUint32(&o.PSELID.Reg)&^(0x100)|value<<8)
}
func (o *FLEXCOMM_Type) GetPSELID_SC3W() uint32 {
	return (volatile.LoadUint32(&o.PSELID.Reg) & 0x100) >> 8
}
func (o *FLEXCOMM_Type) SetPSELID_ID(value uint32) {
	volatile.StoreUint32(&o.PSELID.Reg, volatile.LoadUint32(&o.PSELID.Reg)&^(0xfffff000)|value<<12)
}
func (o *FLEXCOMM_Type) GetPSELID_ID() uint32 {
	return (volatile.LoadUint32(&o.PSELID.Reg) & 0xfffff000) >> 12
}

// FLEXCOMM.PID: Peripheral identification register.
func (o *FLEXCOMM_Type) SetPID_Minor_Rev(value uint32) {
	volatile.StoreUint32(&o.PID.Reg, volatile.LoadUint32(&o.PID.Reg)&^(0xf00)|value<<8)
}
func (o *FLEXCOMM_Type) GetPID_Minor_Rev() uint32 {
	return (volatile.LoadUint32(&o.PID.Reg) & 0xf00) >> 8
}
func (o *FLEXCOMM_Type) SetPID_Major_Rev(value uint32) {
	volatile.StoreUint32(&o.PID.Reg, volatile.LoadUint32(&o.PID.Reg)&^(0xf000)|value<<12)
}
func (o *FLEXCOMM_Type) GetPID_Major_Rev() uint32 {
	return (volatile.LoadUint32(&o.PID.Reg) & 0xf000) >> 12
}
func (o *FLEXCOMM_Type) SetPID_ID(value uint32) {
	volatile.StoreUint32(&o.PID.Reg, volatile.LoadUint32(&o.PID.Reg)&^(0xffff0000)|value<<16)
}
func (o *FLEXCOMM_Type) GetPID_ID() uint32 {
	return (volatile.LoadUint32(&o.PID.Reg) & 0xffff0000) >> 16
}

// usart
type USART_Type struct {
	CFG          volatile.Register32 // 0x0
	CTL          volatile.Register32 // 0x4
	STAT         volatile.Register32 // 0x8
	INTENSET     volatile.Register32 // 0xC
	INTENCLR     volatile.Register32 // 0x10
	_            [12]byte
	BRG          volatile.Register32 // 0x20
	INTSTAT      volatile.Register32 // 0x24
	OSR          volatile.Register32 // 0x28
	ADDR         volatile.Register32 // 0x2C
	_            [3536]byte
	FIFOCFG      volatile.Register32 // 0xE00
	FIFOSTAT     volatile.Register32 // 0xE04
	FIFOTRIG     volatile.Register32 // 0xE08
	_            [4]byte
	FIFOINTENSET volatile.Register32 // 0xE10
	FIFOINTENCLR volatile.Register32 // 0xE14
	FIFOINTSTAT  volatile.Register32 // 0xE18
	_            [4]byte
	FIFOWR       volatile.Register32 // 0xE20
	_            [12]byte
	FIFORD       volatile.Register32 // 0xE30
	_            [12]byte
	FIFORDNOPOP  volatile.Register32 // 0xE40
	_            [440]byte
	ID           volatile.Register32 // 0xFFC
}

// USART.CFG: USART Configuration register. Basic USART configuration settings that typically are not changed during operation.
func (o *USART_Type) SetCFG_ENABLE(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0x1)|value)
}
func (o *USART_Type) GetCFG_ENABLE() uint32 {
	return volatile.LoadUint32(&o.CFG.Reg) & 0x1
}
func (o *USART_Type) SetCFG_DATALEN(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0xc)|value<<2)
}
func (o *USART_Type) GetCFG_DATALEN() uint32 {
	return (volatile.LoadUint32(&o.CFG.Reg) & 0xc) >> 2
}
func (o *USART_Type) SetCFG_PARITYSEL(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0x30)|value<<4)
}
func (o *USART_Type) GetCFG_PARITYSEL() uint32 {
	return (volatile.LoadUint32(&o.CFG.Reg) & 0x30) >> 4
}
func (o *USART_Type) SetCFG_STOPLEN(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0x40)|value<<6)
}
func (o *USART_Type) GetCFG_STOPLEN() uint32 {
	return (volatile.LoadUint32(&o.CFG.Reg) & 0x40) >> 6
}
func (o *USART_Type) SetCFG_MODE32K(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0x80)|value<<7)
}
func (o *USART_Type) GetCFG_MODE32K() uint32 {
	return (volatile.LoadUint32(&o.CFG.Reg) & 0x80) >> 7
}
func (o *USART_Type) SetCFG_LINMODE(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0x100)|value<<8)
}
func (o *USART_Type) GetCFG_LINMODE() uint32 {
	return (volatile.LoadUint32(&o.CFG.Reg) & 0x100) >> 8
}
func (o *USART_Type) SetCFG_CTSEN(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0x200)|value<<9)
}
func (o *USART_Type) GetCFG_CTSEN() uint32 {
	return (volatile.LoadUint32(&o.CFG.Reg) & 0x200) >> 9
}
func (o *USART_Type) SetCFG_SYNCEN(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0x800)|value<<11)
}
func (o *USART_Type) GetCFG_SYNCEN() uint32 {
	return (volatile.LoadUint32(&o.CFG.Reg) & 0x800) >> 11
}
func (o *USART_Type) SetCFG_CLKPOL(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0x1000)|value<<12)
}
func (o *USART_Type) GetCFG_CLKPOL() uint32 {
	return (volatile.LoadUint32(&o.CFG.Reg) & 0x1000) >> 12
}
func (o *USART_Type) SetCFG_SYNCMST(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0x4000)|value<<14)
}
func (o *USART_Type) GetCFG_SYNCMST() uint32 {
	return (volatile.LoadUint32(&o.CFG.Reg) & 0x4000) >> 14
}
func (o *USART_Type) SetCFG_LOOP(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0x8000)|value<<15)
}
func (o *USART_Type) GetCFG_LOOP() uint32 {
	return (volatile.LoadUint32(&o.CFG.Reg) & 0x8000) >> 15
}
func (o *USART_Type) SetCFG_OETA(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0x40000)|value<<18)
}
func (o *USART_Type) GetCFG_OETA() uint32 {
	return (volatile.LoadUint32(&o.CFG.Reg) & 0x40000) >> 18
}
func (o *USART_Type) SetCFG_AUTOADDR(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0x80000)|value<<19)
}
func (o *USART_Type) GetCFG_AUTOADDR() uint32 {
	return (volatile.LoadUint32(&o.CFG.Reg) & 0x80000) >> 19
}
func (o *USART_Type) SetCFG_OESEL(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0x100000)|value<<20)
}
func (o *USART_Type) GetCFG_OESEL() uint32 {
	return (volatile.LoadUint32(&o.CFG.Reg) & 0x100000) >> 20
}
func (o *USART_Type) SetCFG_OEPOL(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0x200000)|value<<21)
}
func (o *USART_Type) GetCFG_OEPOL() uint32 {
	return (volatile.LoadUint32(&o.CFG.Reg) & 0x200000) >> 21
}
func (o *USART_Type) SetCFG_RXPOL(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0x400000)|value<<22)
}
func (o *USART_Type) GetCFG_RXPOL() uint32 {
	return (volatile.LoadUint32(&o.CFG.Reg) & 0x400000) >> 22
}
func (o *USART_Type) SetCFG_TXPOL(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0x800000)|value<<23)
}
func (o *USART_Type) GetCFG_TXPOL() uint32 {
	return (volatile.LoadUint32(&o.CFG.Reg) & 0x800000) >> 23
}

// USART.CTL: USART Control register. USART control settings that are more likely to change during operation.
func (o *USART_Type) SetCTL_TXBRKEN(value uint32) {
	volatile.StoreUint32(&o.CTL.Reg, volatile.LoadUint32(&o.CTL.Reg)&^(0x2)|value<<1)
}
func (o *USART_Type) GetCTL_TXBRKEN() uint32 {
	return (volatile.LoadUint32(&o.CTL.Reg) & 0x2) >> 1
}
func (o *USART_Type) SetCTL_ADDRDET(value uint32) {
	volatile.StoreUint32(&o.CTL.Reg, volatile.LoadUint32(&o.CTL.Reg)&^(0x4)|value<<2)
}
func (o *USART_Type) GetCTL_ADDRDET() uint32 {
	return (volatile.LoadUint32(&o.CTL.Reg) & 0x4) >> 2
}
func (o *USART_Type) SetCTL_TXDIS(value uint32) {
	volatile.StoreUint32(&o.CTL.Reg, volatile.LoadUint32(&o.CTL.Reg)&^(0x40)|value<<6)
}
func (o *USART_Type) GetCTL_TXDIS() uint32 {
	return (volatile.LoadUint32(&o.CTL.Reg) & 0x40) >> 6
}
func (o *USART_Type) SetCTL_CC(value uint32) {
	volatile.StoreUint32(&o.CTL.Reg, volatile.LoadUint32(&o.CTL.Reg)&^(0x100)|value<<8)
}
func (o *USART_Type) GetCTL_CC() uint32 {
	return (volatile.LoadUint32(&o.CTL.Reg) & 0x100) >> 8
}
func (o *USART_Type) SetCTL_CLRCCONRX(value uint32) {
	volatile.StoreUint32(&o.CTL.Reg, volatile.LoadUint32(&o.CTL.Reg)&^(0x200)|value<<9)
}
func (o *USART_Type) GetCTL_CLRCCONRX() uint32 {
	return (volatile.LoadUint32(&o.CTL.Reg) & 0x200) >> 9
}
func (o *USART_Type) SetCTL_AUTOBAUD(value uint32) {
	volatile.StoreUint32(&o.CTL.Reg, volatile.LoadUint32(&o.CTL.Reg)&^(0x10000)|value<<16)
}
func (o *USART_Type) GetCTL_AUTOBAUD() uint32 {
	return (volatile.LoadUint32(&o.CTL.Reg) & 0x10000) >> 16
}

// USART.STAT: USART Status register. The complete status value can be read here. Writing ones clears some bits in the register. Some bits can be cleared by writing a 1 to them.
func (o *USART_Type) SetSTAT_RXIDLE(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x2)|value<<1)
}
func (o *USART_Type) GetSTAT_RXIDLE() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x2) >> 1
}
func (o *USART_Type) SetSTAT_TXIDLE(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x8)|value<<3)
}
func (o *USART_Type) GetSTAT_TXIDLE() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x8) >> 3
}
func (o *USART_Type) SetSTAT_CTS(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x10)|value<<4)
}
func (o *USART_Type) GetSTAT_CTS() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x10) >> 4
}
func (o *USART_Type) SetSTAT_DELTACTS(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x20)|value<<5)
}
func (o *USART_Type) GetSTAT_DELTACTS() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x20) >> 5
}
func (o *USART_Type) SetSTAT_TXDISSTAT(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x40)|value<<6)
}
func (o *USART_Type) GetSTAT_TXDISSTAT() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x40) >> 6
}
func (o *USART_Type) SetSTAT_RXBRK(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x400)|value<<10)
}
func (o *USART_Type) GetSTAT_RXBRK() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x400) >> 10
}
func (o *USART_Type) SetSTAT_DELTARXBRK(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x800)|value<<11)
}
func (o *USART_Type) GetSTAT_DELTARXBRK() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x800) >> 11
}
func (o *USART_Type) SetSTAT_START(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x1000)|value<<12)
}
func (o *USART_Type) GetSTAT_START() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x1000) >> 12
}
func (o *USART_Type) SetSTAT_FRAMERRINT(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x2000)|value<<13)
}
func (o *USART_Type) GetSTAT_FRAMERRINT() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x2000) >> 13
}
func (o *USART_Type) SetSTAT_PARITYERRINT(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x4000)|value<<14)
}
func (o *USART_Type) GetSTAT_PARITYERRINT() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x4000) >> 14
}
func (o *USART_Type) SetSTAT_RXNOISEINT(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x8000)|value<<15)
}
func (o *USART_Type) GetSTAT_RXNOISEINT() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x8000) >> 15
}
func (o *USART_Type) SetSTAT_ABERR(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x10000)|value<<16)
}
func (o *USART_Type) GetSTAT_ABERR() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x10000) >> 16
}

// USART.INTENSET: Interrupt Enable read and Set register for USART (not FIFO) status. Contains individual interrupt enable bits for each potential USART interrupt. A complete value may be read from this register. Writing a 1 to any implemented bit position causes that bit to be set.
func (o *USART_Type) SetINTENSET_TXIDLEEN(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x8)|value<<3)
}
func (o *USART_Type) GetINTENSET_TXIDLEEN() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x8) >> 3
}
func (o *USART_Type) SetINTENSET_DELTACTSEN(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x20)|value<<5)
}
func (o *USART_Type) GetINTENSET_DELTACTSEN() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x20) >> 5
}
func (o *USART_Type) SetINTENSET_TXDISEN(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x40)|value<<6)
}
func (o *USART_Type) GetINTENSET_TXDISEN() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x40) >> 6
}
func (o *USART_Type) SetINTENSET_DELTARXBRKEN(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x800)|value<<11)
}
func (o *USART_Type) GetINTENSET_DELTARXBRKEN() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x800) >> 11
}
func (o *USART_Type) SetINTENSET_STARTEN(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1000)|value<<12)
}
func (o *USART_Type) GetINTENSET_STARTEN() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x1000) >> 12
}
func (o *USART_Type) SetINTENSET_FRAMERREN(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2000)|value<<13)
}
func (o *USART_Type) GetINTENSET_FRAMERREN() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2000) >> 13
}
func (o *USART_Type) SetINTENSET_PARITYERREN(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x4000)|value<<14)
}
func (o *USART_Type) GetINTENSET_PARITYERREN() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x4000) >> 14
}
func (o *USART_Type) SetINTENSET_RXNOISEEN(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x8000)|value<<15)
}
func (o *USART_Type) GetINTENSET_RXNOISEEN() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x8000) >> 15
}
func (o *USART_Type) SetINTENSET_ABERREN(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x10000)|value<<16)
}
func (o *USART_Type) GetINTENSET_ABERREN() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x10000) >> 16
}

// USART.INTENCLR: Interrupt Enable Clear register. Allows clearing any combination of bits in the INTENSET register. Writing a 1 to any implemented bit position causes the corresponding bit to be cleared.
func (o *USART_Type) SetINTENCLR_TXIDLECLR(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x8)|value<<3)
}
func (o *USART_Type) GetINTENCLR_TXIDLECLR() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x8) >> 3
}
func (o *USART_Type) SetINTENCLR_DELTACTSCLR(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x20)|value<<5)
}
func (o *USART_Type) GetINTENCLR_DELTACTSCLR() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x20) >> 5
}
func (o *USART_Type) SetINTENCLR_TXDISCLR(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x40)|value<<6)
}
func (o *USART_Type) GetINTENCLR_TXDISCLR() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x40) >> 6
}
func (o *USART_Type) SetINTENCLR_DELTARXBRKCLR(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x800)|value<<11)
}
func (o *USART_Type) GetINTENCLR_DELTARXBRKCLR() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x800) >> 11
}
func (o *USART_Type) SetINTENCLR_STARTCLR(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1000)|value<<12)
}
func (o *USART_Type) GetINTENCLR_STARTCLR() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1000) >> 12
}
func (o *USART_Type) SetINTENCLR_FRAMERRCLR(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2000)|value<<13)
}
func (o *USART_Type) GetINTENCLR_FRAMERRCLR() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2000) >> 13
}
func (o *USART_Type) SetINTENCLR_PARITYERRCLR(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x4000)|value<<14)
}
func (o *USART_Type) GetINTENCLR_PARITYERRCLR() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x4000) >> 14
}
func (o *USART_Type) SetINTENCLR_RXNOISECLR(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x8000)|value<<15)
}
func (o *USART_Type) GetINTENCLR_RXNOISECLR() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x8000) >> 15
}
func (o *USART_Type) SetINTENCLR_ABERRCLR(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x10000)|value<<16)
}
func (o *USART_Type) GetINTENCLR_ABERRCLR() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x10000) >> 16
}

// USART.BRG: Baud Rate Generator register. 16-bit integer baud rate divisor value.
func (o *USART_Type) SetBRG_BRGVAL(value uint32) {
	volatile.StoreUint32(&o.BRG.Reg, volatile.LoadUint32(&o.BRG.Reg)&^(0xffff)|value)
}
func (o *USART_Type) GetBRG_BRGVAL() uint32 {
	return volatile.LoadUint32(&o.BRG.Reg) & 0xffff
}

// USART.INTSTAT: Interrupt status register. Reflects interrupts that are currently enabled.
func (o *USART_Type) SetINTSTAT_TXIDLE(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x8)|value<<3)
}
func (o *USART_Type) GetINTSTAT_TXIDLE() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x8) >> 3
}
func (o *USART_Type) SetINTSTAT_DELTACTS(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x20)|value<<5)
}
func (o *USART_Type) GetINTSTAT_DELTACTS() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x20) >> 5
}
func (o *USART_Type) SetINTSTAT_TXDISINT(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x40)|value<<6)
}
func (o *USART_Type) GetINTSTAT_TXDISINT() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x40) >> 6
}
func (o *USART_Type) SetINTSTAT_DELTARXBRK(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x800)|value<<11)
}
func (o *USART_Type) GetINTSTAT_DELTARXBRK() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x800) >> 11
}
func (o *USART_Type) SetINTSTAT_START(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x1000)|value<<12)
}
func (o *USART_Type) GetINTSTAT_START() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x1000) >> 12
}
func (o *USART_Type) SetINTSTAT_FRAMERRINT(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x2000)|value<<13)
}
func (o *USART_Type) GetINTSTAT_FRAMERRINT() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x2000) >> 13
}
func (o *USART_Type) SetINTSTAT_PARITYERRINT(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x4000)|value<<14)
}
func (o *USART_Type) GetINTSTAT_PARITYERRINT() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x4000) >> 14
}
func (o *USART_Type) SetINTSTAT_RXNOISEINT(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x8000)|value<<15)
}
func (o *USART_Type) GetINTSTAT_RXNOISEINT() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x8000) >> 15
}
func (o *USART_Type) SetINTSTAT_ABERRINT(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x10000)|value<<16)
}
func (o *USART_Type) GetINTSTAT_ABERRINT() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x10000) >> 16
}

// USART.OSR: Oversample selection register for asynchronous communication.
func (o *USART_Type) SetOSR_OSRVAL(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0xf)|value)
}
func (o *USART_Type) GetOSR_OSRVAL() uint32 {
	return volatile.LoadUint32(&o.OSR.Reg) & 0xf
}

// USART.ADDR: Address register for automatic address matching.
func (o *USART_Type) SetADDR_ADDRESS(value uint32) {
	volatile.StoreUint32(&o.ADDR.Reg, volatile.LoadUint32(&o.ADDR.Reg)&^(0xff)|value)
}
func (o *USART_Type) GetADDR_ADDRESS() uint32 {
	return volatile.LoadUint32(&o.ADDR.Reg) & 0xff
}

// USART.FIFOCFG: FIFO configuration and enable register.
func (o *USART_Type) SetFIFOCFG_ENABLETX(value uint32) {
	volatile.StoreUint32(&o.FIFOCFG.Reg, volatile.LoadUint32(&o.FIFOCFG.Reg)&^(0x1)|value)
}
func (o *USART_Type) GetFIFOCFG_ENABLETX() uint32 {
	return volatile.LoadUint32(&o.FIFOCFG.Reg) & 0x1
}
func (o *USART_Type) SetFIFOCFG_ENABLERX(value uint32) {
	volatile.StoreUint32(&o.FIFOCFG.Reg, volatile.LoadUint32(&o.FIFOCFG.Reg)&^(0x2)|value<<1)
}
func (o *USART_Type) GetFIFOCFG_ENABLERX() uint32 {
	return (volatile.LoadUint32(&o.FIFOCFG.Reg) & 0x2) >> 1
}
func (o *USART_Type) SetFIFOCFG_SIZE(value uint32) {
	volatile.StoreUint32(&o.FIFOCFG.Reg, volatile.LoadUint32(&o.FIFOCFG.Reg)&^(0x30)|value<<4)
}
func (o *USART_Type) GetFIFOCFG_SIZE() uint32 {
	return (volatile.LoadUint32(&o.FIFOCFG.Reg) & 0x30) >> 4
}
func (o *USART_Type) SetFIFOCFG_DMATX(value uint32) {
	volatile.StoreUint32(&o.FIFOCFG.Reg, volatile.LoadUint32(&o.FIFOCFG.Reg)&^(0x1000)|value<<12)
}
func (o *USART_Type) GetFIFOCFG_DMATX() uint32 {
	return (volatile.LoadUint32(&o.FIFOCFG.Reg) & 0x1000) >> 12
}
func (o *USART_Type) SetFIFOCFG_DMARX(value uint32) {
	volatile.StoreUint32(&o.FIFOCFG.Reg, volatile.LoadUint32(&o.FIFOCFG.Reg)&^(0x2000)|value<<13)
}
func (o *USART_Type) GetFIFOCFG_DMARX() uint32 {
	return (volatile.LoadUint32(&o.FIFOCFG.Reg) & 0x2000) >> 13
}
func (o *USART_Type) SetFIFOCFG_EMPTYTX(value uint32) {
	volatile.StoreUint32(&o.FIFOCFG.Reg, volatile.LoadUint32(&o.FIFOCFG.Reg)&^(0x10000)|value<<16)
}
func (o *USART_Type) GetFIFOCFG_EMPTYTX() uint32 {
	return (volatile.LoadUint32(&o.FIFOCFG.Reg) & 0x10000) >> 16
}
func (o *USART_Type) SetFIFOCFG_EMPTYRX(value uint32) {
	volatile.StoreUint32(&o.FIFOCFG.Reg, volatile.LoadUint32(&o.FIFOCFG.Reg)&^(0x20000)|value<<17)
}
func (o *USART_Type) GetFIFOCFG_EMPTYRX() uint32 {
	return (volatile.LoadUint32(&o.FIFOCFG.Reg) & 0x20000) >> 17
}

// USART.FIFOSTAT: FIFO status register.
func (o *USART_Type) SetFIFOSTAT_TXERR(value uint32) {
	volatile.StoreUint32(&o.FIFOSTAT.Reg, volatile.LoadUint32(&o.FIFOSTAT.Reg)&^(0x1)|value)
}
func (o *USART_Type) GetFIFOSTAT_TXERR() uint32 {
	return volatile.LoadUint32(&o.FIFOSTAT.Reg) & 0x1
}
func (o *USART_Type) SetFIFOSTAT_RXERR(value uint32) {
	volatile.StoreUint32(&o.FIFOSTAT.Reg, volatile.LoadUint32(&o.FIFOSTAT.Reg)&^(0x2)|value<<1)
}
func (o *USART_Type) GetFIFOSTAT_RXERR() uint32 {
	return (volatile.LoadUint32(&o.FIFOSTAT.Reg) & 0x2) >> 1
}
func (o *USART_Type) SetFIFOSTAT_PERINT(value uint32) {
	volatile.StoreUint32(&o.FIFOSTAT.Reg, volatile.LoadUint32(&o.FIFOSTAT.Reg)&^(0x8)|value<<3)
}
func (o *USART_Type) GetFIFOSTAT_PERINT() uint32 {
	return (volatile.LoadUint32(&o.FIFOSTAT.Reg) & 0x8) >> 3
}
func (o *USART_Type) SetFIFOSTAT_TXEMPTY(value uint32) {
	volatile.StoreUint32(&o.FIFOSTAT.Reg, volatile.LoadUint32(&o.FIFOSTAT.Reg)&^(0x10)|value<<4)
}
func (o *USART_Type) GetFIFOSTAT_TXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.FIFOSTAT.Reg) & 0x10) >> 4
}
func (o *USART_Type) SetFIFOSTAT_TXNOTFULL(value uint32) {
	volatile.StoreUint32(&o.FIFOSTAT.Reg, volatile.LoadUint32(&o.FIFOSTAT.Reg)&^(0x20)|value<<5)
}
func (o *USART_Type) GetFIFOSTAT_TXNOTFULL() uint32 {
	return (volatile.LoadUint32(&o.FIFOSTAT.Reg) & 0x20) >> 5
}
func (o *USART_Type) SetFIFOSTAT_RXNOTEMPTY(value uint32) {
	volatile.StoreUint32(&o.FIFOSTAT.Reg, volatile.LoadUint32(&o.FIFOSTAT.Reg)&^(0x40)|value<<6)
}
func (o *USART_Type) GetFIFOSTAT_RXNOTEMPTY() uint32 {
	return (volatile.LoadUint32(&o.FIFOSTAT.Reg) & 0x40) >> 6
}
func (o *USART_Type) SetFIFOSTAT_RXFULL(value uint32) {
	volatile.StoreUint32(&o.FIFOSTAT.Reg, volatile.LoadUint32(&o.FIFOSTAT.Reg)&^(0x80)|value<<7)
}
func (o *USART_Type) GetFIFOSTAT_RXFULL() uint32 {
	return (volatile.LoadUint32(&o.FIFOSTAT.Reg) & 0x80) >> 7
}
func (o *USART_Type) SetFIFOSTAT_TXLVL(value uint32) {
	volatile.StoreUint32(&o.FIFOSTAT.Reg, volatile.LoadUint32(&o.FIFOSTAT.Reg)&^(0x1f00)|value<<8)
}
func (o *USART_Type) GetFIFOSTAT_TXLVL() uint32 {
	return (volatile.LoadUint32(&o.FIFOSTAT.Reg) & 0x1f00) >> 8
}
func (o *USART_Type) SetFIFOSTAT_RXLVL(value uint32) {
	volatile.StoreUint32(&o.FIFOSTAT.Reg, volatile.LoadUint32(&o.FIFOSTAT.Reg)&^(0x1f0000)|value<<16)
}
func (o *USART_Type) GetFIFOSTAT_RXLVL() uint32 {
	return (volatile.LoadUint32(&o.FIFOSTAT.Reg) & 0x1f0000) >> 16
}

// USART.FIFOTRIG: FIFO trigger settings for interrupt and DMA request.
func (o *USART_Type) SetFIFOTRIG_TXLVLENA(value uint32) {
	volatile.StoreUint32(&o.FIFOTRIG.Reg, volatile.LoadUint32(&o.FIFOTRIG.Reg)&^(0x1)|value)
}
func (o *USART_Type) GetFIFOTRIG_TXLVLENA() uint32 {
	return volatile.LoadUint32(&o.FIFOTRIG.Reg) & 0x1
}
func (o *USART_Type) SetFIFOTRIG_RXLVLENA(value uint32) {
	volatile.StoreUint32(&o.FIFOTRIG.Reg, volatile.LoadUint32(&o.FIFOTRIG.Reg)&^(0x2)|value<<1)
}
func (o *USART_Type) GetFIFOTRIG_RXLVLENA() uint32 {
	return (volatile.LoadUint32(&o.FIFOTRIG.Reg) & 0x2) >> 1
}
func (o *USART_Type) SetFIFOTRIG_TXLVL(value uint32) {
	volatile.StoreUint32(&o.FIFOTRIG.Reg, volatile.LoadUint32(&o.FIFOTRIG.Reg)&^(0xf00)|value<<8)
}
func (o *USART_Type) GetFIFOTRIG_TXLVL() uint32 {
	return (volatile.LoadUint32(&o.FIFOTRIG.Reg) & 0xf00) >> 8
}
func (o *USART_Type) SetFIFOTRIG_RXLVL(value uint32) {
	volatile.StoreUint32(&o.FIFOTRIG.Reg, volatile.LoadUint32(&o.FIFOTRIG.Reg)&^(0xf0000)|value<<16)
}
func (o *USART_Type) GetFIFOTRIG_RXLVL() uint32 {
	return (volatile.LoadUint32(&o.FIFOTRIG.Reg) & 0xf0000) >> 16
}

// USART.FIFOINTENSET: FIFO interrupt enable set (enable) and read register.
func (o *USART_Type) SetFIFOINTENSET_TXERR(value uint32) {
	volatile.StoreUint32(&o.FIFOINTENSET.Reg, volatile.LoadUint32(&o.FIFOINTENSET.Reg)&^(0x1)|value)
}
func (o *USART_Type) GetFIFOINTENSET_TXERR() uint32 {
	return volatile.LoadUint32(&o.FIFOINTENSET.Reg) & 0x1
}
func (o *USART_Type) SetFIFOINTENSET_RXERR(value uint32) {
	volatile.StoreUint32(&o.FIFOINTENSET.Reg, volatile.LoadUint32(&o.FIFOINTENSET.Reg)&^(0x2)|value<<1)
}
func (o *USART_Type) GetFIFOINTENSET_RXERR() uint32 {
	return (volatile.LoadUint32(&o.FIFOINTENSET.Reg) & 0x2) >> 1
}
func (o *USART_Type) SetFIFOINTENSET_TXLVL(value uint32) {
	volatile.StoreUint32(&o.FIFOINTENSET.Reg, volatile.LoadUint32(&o.FIFOINTENSET.Reg)&^(0x4)|value<<2)
}
func (o *USART_Type) GetFIFOINTENSET_TXLVL() uint32 {
	return (volatile.LoadUint32(&o.FIFOINTENSET.Reg) & 0x4) >> 2
}
func (o *USART_Type) SetFIFOINTENSET_RXLVL(value uint32) {
	volatile.StoreUint32(&o.FIFOINTENSET.Reg, volatile.LoadUint32(&o.FIFOINTENSET.Reg)&^(0x8)|value<<3)
}
func (o *USART_Type) GetFIFOINTENSET_RXLVL() uint32 {
	return (volatile.LoadUint32(&o.FIFOINTENSET.Reg) & 0x8) >> 3
}

// USART.FIFOINTENCLR: FIFO interrupt enable clear (disable) and read register.
func (o *USART_Type) SetFIFOINTENCLR_TXERR(value uint32) {
	volatile.StoreUint32(&o.FIFOINTENCLR.Reg, volatile.LoadUint32(&o.FIFOINTENCLR.Reg)&^(0x1)|value)
}
func (o *USART_Type) GetFIFOINTENCLR_TXERR() uint32 {
	return volatile.LoadUint32(&o.FIFOINTENCLR.Reg) & 0x1
}
func (o *USART_Type) SetFIFOINTENCLR_RXERR(value uint32) {
	volatile.StoreUint32(&o.FIFOINTENCLR.Reg, volatile.LoadUint32(&o.FIFOINTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *USART_Type) GetFIFOINTENCLR_RXERR() uint32 {
	return (volatile.LoadUint32(&o.FIFOINTENCLR.Reg) & 0x2) >> 1
}
func (o *USART_Type) SetFIFOINTENCLR_TXLVL(value uint32) {
	volatile.StoreUint32(&o.FIFOINTENCLR.Reg, volatile.LoadUint32(&o.FIFOINTENCLR.Reg)&^(0x4)|value<<2)
}
func (o *USART_Type) GetFIFOINTENCLR_TXLVL() uint32 {
	return (volatile.LoadUint32(&o.FIFOINTENCLR.Reg) & 0x4) >> 2
}
func (o *USART_Type) SetFIFOINTENCLR_RXLVL(value uint32) {
	volatile.StoreUint32(&o.FIFOINTENCLR.Reg, volatile.LoadUint32(&o.FIFOINTENCLR.Reg)&^(0x8)|value<<3)
}
func (o *USART_Type) GetFIFOINTENCLR_RXLVL() uint32 {
	return (volatile.LoadUint32(&o.FIFOINTENCLR.Reg) & 0x8) >> 3
}

// USART.FIFOINTSTAT: FIFO interrupt status register.
func (o *USART_Type) SetFIFOINTSTAT_TXERR(value uint32) {
	volatile.StoreUint32(&o.FIFOINTSTAT.Reg, volatile.LoadUint32(&o.FIFOINTSTAT.Reg)&^(0x1)|value)
}
func (o *USART_Type) GetFIFOINTSTAT_TXERR() uint32 {
	return volatile.LoadUint32(&o.FIFOINTSTAT.Reg) & 0x1
}
func (o *USART_Type) SetFIFOINTSTAT_RXERR(value uint32) {
	volatile.StoreUint32(&o.FIFOINTSTAT.Reg, volatile.LoadUint32(&o.FIFOINTSTAT.Reg)&^(0x2)|value<<1)
}
func (o *USART_Type) GetFIFOINTSTAT_RXERR() uint32 {
	return (volatile.LoadUint32(&o.FIFOINTSTAT.Reg) & 0x2) >> 1
}
func (o *USART_Type) SetFIFOINTSTAT_TXLVL(value uint32) {
	volatile.StoreUint32(&o.FIFOINTSTAT.Reg, volatile.LoadUint32(&o.FIFOINTSTAT.Reg)&^(0x4)|value<<2)
}
func (o *USART_Type) GetFIFOINTSTAT_TXLVL() uint32 {
	return (volatile.LoadUint32(&o.FIFOINTSTAT.Reg) & 0x4) >> 2
}
func (o *USART_Type) SetFIFOINTSTAT_RXLVL(value uint32) {
	volatile.StoreUint32(&o.FIFOINTSTAT.Reg, volatile.LoadUint32(&o.FIFOINTSTAT.Reg)&^(0x8)|value<<3)
}
func (o *USART_Type) GetFIFOINTSTAT_RXLVL() uint32 {
	return (volatile.LoadUint32(&o.FIFOINTSTAT.Reg) & 0x8) >> 3
}
func (o *USART_Type) SetFIFOINTSTAT_PERINT(value uint32) {
	volatile.StoreUint32(&o.FIFOINTSTAT.Reg, volatile.LoadUint32(&o.FIFOINTSTAT.Reg)&^(0x10)|value<<4)
}
func (o *USART_Type) GetFIFOINTSTAT_PERINT() uint32 {
	return (volatile.LoadUint32(&o.FIFOINTSTAT.Reg) & 0x10) >> 4
}

// USART.FIFOWR: FIFO write data.
func (o *USART_Type) SetFIFOWR_TXDATA(value uint32) {
	volatile.StoreUint32(&o.FIFOWR.Reg, volatile.LoadUint32(&o.FIFOWR.Reg)&^(0x1ff)|value)
}
func (o *USART_Type) GetFIFOWR_TXDATA() uint32 {
	return volatile.LoadUint32(&o.FIFOWR.Reg) & 0x1ff
}

// USART.FIFORD: FIFO read data.
func (o *USART_Type) SetFIFORD_RXDATA(value uint32) {
	volatile.StoreUint32(&o.FIFORD.Reg, volatile.LoadUint32(&o.FIFORD.Reg)&^(0x1ff)|value)
}
func (o *USART_Type) GetFIFORD_RXDATA() uint32 {
	return volatile.LoadUint32(&o.FIFORD.Reg) & 0x1ff
}
func (o *USART_Type) SetFIFORD_FRAMERR(value uint32) {
	volatile.StoreUint32(&o.FIFORD.Reg, volatile.LoadUint32(&o.FIFORD.Reg)&^(0x2000)|value<<13)
}
func (o *USART_Type) GetFIFORD_FRAMERR() uint32 {
	return (volatile.LoadUint32(&o.FIFORD.Reg) & 0x2000) >> 13
}
func (o *USART_Type) SetFIFORD_PARITYERR(value uint32) {
	volatile.StoreUint32(&o.FIFORD.Reg, volatile.LoadUint32(&o.FIFORD.Reg)&^(0x4000)|value<<14)
}
func (o *USART_Type) GetFIFORD_PARITYERR() uint32 {
	return (volatile.LoadUint32(&o.FIFORD.Reg) & 0x4000) >> 14
}
func (o *USART_Type) SetFIFORD_RXNOISE(value uint32) {
	volatile.StoreUint32(&o.FIFORD.Reg, volatile.LoadUint32(&o.FIFORD.Reg)&^(0x8000)|value<<15)
}
func (o *USART_Type) GetFIFORD_RXNOISE() uint32 {
	return (volatile.LoadUint32(&o.FIFORD.Reg) & 0x8000) >> 15
}

// USART.FIFORDNOPOP: FIFO data read with no FIFO pop.
func (o *USART_Type) SetFIFORDNOPOP_RXDATA(value uint32) {
	volatile.StoreUint32(&o.FIFORDNOPOP.Reg, volatile.LoadUint32(&o.FIFORDNOPOP.Reg)&^(0x1ff)|value)
}
func (o *USART_Type) GetFIFORDNOPOP_RXDATA() uint32 {
	return volatile.LoadUint32(&o.FIFORDNOPOP.Reg) & 0x1ff
}
func (o *USART_Type) SetFIFORDNOPOP_FRAMERR(value uint32) {
	volatile.StoreUint32(&o.FIFORDNOPOP.Reg, volatile.LoadUint32(&o.FIFORDNOPOP.Reg)&^(0x2000)|value<<13)
}
func (o *USART_Type) GetFIFORDNOPOP_FRAMERR() uint32 {
	return (volatile.LoadUint32(&o.FIFORDNOPOP.Reg) & 0x2000) >> 13
}
func (o *USART_Type) SetFIFORDNOPOP_PARITYERR(value uint32) {
	volatile.StoreUint32(&o.FIFORDNOPOP.Reg, volatile.LoadUint32(&o.FIFORDNOPOP.Reg)&^(0x4000)|value<<14)
}
func (o *USART_Type) GetFIFORDNOPOP_PARITYERR() uint32 {
	return (volatile.LoadUint32(&o.FIFORDNOPOP.Reg) & 0x4000) >> 14
}
func (o *USART_Type) SetFIFORDNOPOP_RXNOISE(value uint32) {
	volatile.StoreUint32(&o.FIFORDNOPOP.Reg, volatile.LoadUint32(&o.FIFORDNOPOP.Reg)&^(0x8000)|value<<15)
}
func (o *USART_Type) GetFIFORDNOPOP_RXNOISE() uint32 {
	return (volatile.LoadUint32(&o.FIFORDNOPOP.Reg) & 0x8000) >> 15
}

// USART.ID: USART module Identification. This value appears in the shared Flexcomm peripheral ID register when USART is selected.
func (o *USART_Type) SetID_APERTURE(value uint32) {
	volatile.StoreUint32(&o.ID.Reg, volatile.LoadUint32(&o.ID.Reg)&^(0xff)|value)
}
func (o *USART_Type) GetID_APERTURE() uint32 {
	return volatile.LoadUint32(&o.ID.Reg) & 0xff
}
func (o *USART_Type) SetID_MINOR_REV(value uint32) {
	volatile.StoreUint32(&o.ID.Reg, volatile.LoadUint32(&o.ID.Reg)&^(0xf00)|value<<8)
}
func (o *USART_Type) GetID_MINOR_REV() uint32 {
	return (volatile.LoadUint32(&o.ID.Reg) & 0xf00) >> 8
}
func (o *USART_Type) SetID_MAJOR_REV(value uint32) {
	volatile.StoreUint32(&o.ID.Reg, volatile.LoadUint32(&o.ID.Reg)&^(0xf000)|value<<12)
}
func (o *USART_Type) GetID_MAJOR_REV() uint32 {
	return (volatile.LoadUint32(&o.ID.Reg) & 0xf000) >> 12
}
func (o *USART_Type) SetID(value uint32) {
	volatile.StoreUint32(&o.ID.Reg, volatile.LoadUint32(&o.ID.Reg)&^(0xffff0000)|value<<16)
}
func (o *USART_Type) GetID() uint32 {
	return (volatile.LoadUint32(&o.ID.Reg) & 0xffff0000) >> 16
}

// usb
type USB_Type struct {
	DEVCMDSTAT   volatile.Register32 // 0x0
	INFO         volatile.Register32 // 0x4
	EPLISTSTART  volatile.Register32 // 0x8
	DATABUFSTART volatile.Register32 // 0xC
	LPM          volatile.Register32 // 0x10
	EPSKIP       volatile.Register32 // 0x14
	EPINUSE      volatile.Register32 // 0x18
	EPBUFCFG     volatile.Register32 // 0x1C
	INTSTAT      volatile.Register32 // 0x20
	INTEN        volatile.Register32 // 0x24
	INTSETSTAT   volatile.Register32 // 0x28
	_            [8]byte
	EPTOGGLE     volatile.Register32 // 0x34
}

// USB.DEVCMDSTAT: USB Device Command/Status register
func (o *USB_Type) SetDEVCMDSTAT_DEV_ADDR(value uint32) {
	volatile.StoreUint32(&o.DEVCMDSTAT.Reg, volatile.LoadUint32(&o.DEVCMDSTAT.Reg)&^(0x7f)|value)
}
func (o *USB_Type) GetDEVCMDSTAT_DEV_ADDR() uint32 {
	return volatile.LoadUint32(&o.DEVCMDSTAT.Reg) & 0x7f
}
func (o *USB_Type) SetDEVCMDSTAT_DEV_EN(value uint32) {
	volatile.StoreUint32(&o.DEVCMDSTAT.Reg, volatile.LoadUint32(&o.DEVCMDSTAT.Reg)&^(0x80)|value<<7)
}
func (o *USB_Type) GetDEVCMDSTAT_DEV_EN() uint32 {
	return (volatile.LoadUint32(&o.DEVCMDSTAT.Reg) & 0x80) >> 7
}
func (o *USB_Type) SetDEVCMDSTAT_SETUP(value uint32) {
	volatile.StoreUint32(&o.DEVCMDSTAT.Reg, volatile.LoadUint32(&o.DEVCMDSTAT.Reg)&^(0x100)|value<<8)
}
func (o *USB_Type) GetDEVCMDSTAT_SETUP() uint32 {
	return (volatile.LoadUint32(&o.DEVCMDSTAT.Reg) & 0x100) >> 8
}
func (o *USB_Type) SetDEVCMDSTAT_FORCE_NEEDCLK(value uint32) {
	volatile.StoreUint32(&o.DEVCMDSTAT.Reg, volatile.LoadUint32(&o.DEVCMDSTAT.Reg)&^(0x200)|value<<9)
}
func (o *USB_Type) GetDEVCMDSTAT_FORCE_NEEDCLK() uint32 {
	return (volatile.LoadUint32(&o.DEVCMDSTAT.Reg) & 0x200) >> 9
}
func (o *USB_Type) SetDEVCMDSTAT_LPM_SUP(value uint32) {
	volatile.StoreUint32(&o.DEVCMDSTAT.Reg, volatile.LoadUint32(&o.DEVCMDSTAT.Reg)&^(0x800)|value<<11)
}
func (o *USB_Type) GetDEVCMDSTAT_LPM_SUP() uint32 {
	return (volatile.LoadUint32(&o.DEVCMDSTAT.Reg) & 0x800) >> 11
}
func (o *USB_Type) SetDEVCMDSTAT_INTONNAK_AO(value uint32) {
	volatile.StoreUint32(&o.DEVCMDSTAT.Reg, volatile.LoadUint32(&o.DEVCMDSTAT.Reg)&^(0x1000)|value<<12)
}
func (o *USB_Type) GetDEVCMDSTAT_INTONNAK_AO() uint32 {
	return (volatile.LoadUint32(&o.DEVCMDSTAT.Reg) & 0x1000) >> 12
}
func (o *USB_Type) SetDEVCMDSTAT_INTONNAK_AI(value uint32) {
	volatile.StoreUint32(&o.DEVCMDSTAT.Reg, volatile.LoadUint32(&o.DEVCMDSTAT.Reg)&^(0x2000)|value<<13)
}
func (o *USB_Type) GetDEVCMDSTAT_INTONNAK_AI() uint32 {
	return (volatile.LoadUint32(&o.DEVCMDSTAT.Reg) & 0x2000) >> 13
}
func (o *USB_Type) SetDEVCMDSTAT_INTONNAK_CO(value uint32) {
	volatile.StoreUint32(&o.DEVCMDSTAT.Reg, volatile.LoadUint32(&o.DEVCMDSTAT.Reg)&^(0x4000)|value<<14)
}
func (o *USB_Type) GetDEVCMDSTAT_INTONNAK_CO() uint32 {
	return (volatile.LoadUint32(&o.DEVCMDSTAT.Reg) & 0x4000) >> 14
}
func (o *USB_Type) SetDEVCMDSTAT_INTONNAK_CI(value uint32) {
	volatile.StoreUint32(&o.DEVCMDSTAT.Reg, volatile.LoadUint32(&o.DEVCMDSTAT.Reg)&^(0x8000)|value<<15)
}
func (o *USB_Type) GetDEVCMDSTAT_INTONNAK_CI() uint32 {
	return (volatile.LoadUint32(&o.DEVCMDSTAT.Reg) & 0x8000) >> 15
}
func (o *USB_Type) SetDEVCMDSTAT_DCON(value uint32) {
	volatile.StoreUint32(&o.DEVCMDSTAT.Reg, volatile.LoadUint32(&o.DEVCMDSTAT.Reg)&^(0x10000)|value<<16)
}
func (o *USB_Type) GetDEVCMDSTAT_DCON() uint32 {
	return (volatile.LoadUint32(&o.DEVCMDSTAT.Reg) & 0x10000) >> 16
}
func (o *USB_Type) SetDEVCMDSTAT_DSUS(value uint32) {
	volatile.StoreUint32(&o.DEVCMDSTAT.Reg, volatile.LoadUint32(&o.DEVCMDSTAT.Reg)&^(0x20000)|value<<17)
}
func (o *USB_Type) GetDEVCMDSTAT_DSUS() uint32 {
	return (volatile.LoadUint32(&o.DEVCMDSTAT.Reg) & 0x20000) >> 17
}
func (o *USB_Type) SetDEVCMDSTAT_LPM_SUS(value uint32) {
	volatile.StoreUint32(&o.DEVCMDSTAT.Reg, volatile.LoadUint32(&o.DEVCMDSTAT.Reg)&^(0x80000)|value<<19)
}
func (o *USB_Type) GetDEVCMDSTAT_LPM_SUS() uint32 {
	return (volatile.LoadUint32(&o.DEVCMDSTAT.Reg) & 0x80000) >> 19
}
func (o *USB_Type) SetDEVCMDSTAT_LPM_REWP(value uint32) {
	volatile.StoreUint32(&o.DEVCMDSTAT.Reg, volatile.LoadUint32(&o.DEVCMDSTAT.Reg)&^(0x100000)|value<<20)
}
func (o *USB_Type) GetDEVCMDSTAT_LPM_REWP() uint32 {
	return (volatile.LoadUint32(&o.DEVCMDSTAT.Reg) & 0x100000) >> 20
}
func (o *USB_Type) SetDEVCMDSTAT_DCON_C(value uint32) {
	volatile.StoreUint32(&o.DEVCMDSTAT.Reg, volatile.LoadUint32(&o.DEVCMDSTAT.Reg)&^(0x1000000)|value<<24)
}
func (o *USB_Type) GetDEVCMDSTAT_DCON_C() uint32 {
	return (volatile.LoadUint32(&o.DEVCMDSTAT.Reg) & 0x1000000) >> 24
}
func (o *USB_Type) SetDEVCMDSTAT_DSUS_C(value uint32) {
	volatile.StoreUint32(&o.DEVCMDSTAT.Reg, volatile.LoadUint32(&o.DEVCMDSTAT.Reg)&^(0x2000000)|value<<25)
}
func (o *USB_Type) GetDEVCMDSTAT_DSUS_C() uint32 {
	return (volatile.LoadUint32(&o.DEVCMDSTAT.Reg) & 0x2000000) >> 25
}
func (o *USB_Type) SetDEVCMDSTAT_DRES_C(value uint32) {
	volatile.StoreUint32(&o.DEVCMDSTAT.Reg, volatile.LoadUint32(&o.DEVCMDSTAT.Reg)&^(0x4000000)|value<<26)
}
func (o *USB_Type) GetDEVCMDSTAT_DRES_C() uint32 {
	return (volatile.LoadUint32(&o.DEVCMDSTAT.Reg) & 0x4000000) >> 26
}
func (o *USB_Type) SetDEVCMDSTAT_VBUSDEBOUNCED(value uint32) {
	volatile.StoreUint32(&o.DEVCMDSTAT.Reg, volatile.LoadUint32(&o.DEVCMDSTAT.Reg)&^(0x10000000)|value<<28)
}
func (o *USB_Type) GetDEVCMDSTAT_VBUSDEBOUNCED() uint32 {
	return (volatile.LoadUint32(&o.DEVCMDSTAT.Reg) & 0x10000000) >> 28
}

// USB.INFO: USB Info register
func (o *USB_Type) SetINFO_FRAME_NR(value uint32) {
	volatile.StoreUint32(&o.INFO.Reg, volatile.LoadUint32(&o.INFO.Reg)&^(0x7ff)|value)
}
func (o *USB_Type) GetINFO_FRAME_NR() uint32 {
	return volatile.LoadUint32(&o.INFO.Reg) & 0x7ff
}
func (o *USB_Type) SetINFO_ERR_CODE(value uint32) {
	volatile.StoreUint32(&o.INFO.Reg, volatile.LoadUint32(&o.INFO.Reg)&^(0x7800)|value<<11)
}
func (o *USB_Type) GetINFO_ERR_CODE() uint32 {
	return (volatile.LoadUint32(&o.INFO.Reg) & 0x7800) >> 11
}

// USB.EPLISTSTART: USB EP Command/Status List start address
func (o *USB_Type) SetEPLISTSTART_EP_LIST(value uint32) {
	volatile.StoreUint32(&o.EPLISTSTART.Reg, volatile.LoadUint32(&o.EPLISTSTART.Reg)&^(0xffffff00)|value<<8)
}
func (o *USB_Type) GetEPLISTSTART_EP_LIST() uint32 {
	return (volatile.LoadUint32(&o.EPLISTSTART.Reg) & 0xffffff00) >> 8
}

// USB.DATABUFSTART: USB Data buffer start address
func (o *USB_Type) SetDATABUFSTART_DA_BUF(value uint32) {
	volatile.StoreUint32(&o.DATABUFSTART.Reg, volatile.LoadUint32(&o.DATABUFSTART.Reg)&^(0xffc00000)|value<<22)
}
func (o *USB_Type) GetDATABUFSTART_DA_BUF() uint32 {
	return (volatile.LoadUint32(&o.DATABUFSTART.Reg) & 0xffc00000) >> 22
}

// USB.LPM: USB Link Power Management register
func (o *USB_Type) SetLPM_HIRD_HW(value uint32) {
	volatile.StoreUint32(&o.LPM.Reg, volatile.LoadUint32(&o.LPM.Reg)&^(0xf)|value)
}
func (o *USB_Type) GetLPM_HIRD_HW() uint32 {
	return volatile.LoadUint32(&o.LPM.Reg) & 0xf
}
func (o *USB_Type) SetLPM_HIRD_SW(value uint32) {
	volatile.StoreUint32(&o.LPM.Reg, volatile.LoadUint32(&o.LPM.Reg)&^(0xf0)|value<<4)
}
func (o *USB_Type) GetLPM_HIRD_SW() uint32 {
	return (volatile.LoadUint32(&o.LPM.Reg) & 0xf0) >> 4
}
func (o *USB_Type) SetLPM_DATA_PENDING(value uint32) {
	volatile.StoreUint32(&o.LPM.Reg, volatile.LoadUint32(&o.LPM.Reg)&^(0x100)|value<<8)
}
func (o *USB_Type) GetLPM_DATA_PENDING() uint32 {
	return (volatile.LoadUint32(&o.LPM.Reg) & 0x100) >> 8
}

// USB.EPSKIP: USB Endpoint skip
func (o *USB_Type) SetEPSKIP_SKIP(value uint32) {
	volatile.StoreUint32(&o.EPSKIP.Reg, volatile.LoadUint32(&o.EPSKIP.Reg)&^(0x3fffffff)|value)
}
func (o *USB_Type) GetEPSKIP_SKIP() uint32 {
	return volatile.LoadUint32(&o.EPSKIP.Reg) & 0x3fffffff
}

// USB.EPINUSE: USB Endpoint Buffer in use
func (o *USB_Type) SetEPINUSE_BUF(value uint32) {
	volatile.StoreUint32(&o.EPINUSE.Reg, volatile.LoadUint32(&o.EPINUSE.Reg)&^(0x3fc)|value<<2)
}
func (o *USB_Type) GetEPINUSE_BUF() uint32 {
	return (volatile.LoadUint32(&o.EPINUSE.Reg) & 0x3fc) >> 2
}

// USB.EPBUFCFG: USB Endpoint Buffer Configuration register
func (o *USB_Type) SetEPBUFCFG_BUF_SB(value uint32) {
	volatile.StoreUint32(&o.EPBUFCFG.Reg, volatile.LoadUint32(&o.EPBUFCFG.Reg)&^(0x3fc)|value<<2)
}
func (o *USB_Type) GetEPBUFCFG_BUF_SB() uint32 {
	return (volatile.LoadUint32(&o.EPBUFCFG.Reg) & 0x3fc) >> 2
}

// USB.INTSTAT: USB interrupt status register
func (o *USB_Type) SetINTSTAT_EP0OUT(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetINTSTAT_EP0OUT() uint32 {
	return volatile.LoadUint32(&o.INTSTAT.Reg) & 0x1
}
func (o *USB_Type) SetINTSTAT_EP0IN(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetINTSTAT_EP0IN() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetINTSTAT_EP1OUT(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetINTSTAT_EP1OUT() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetINTSTAT_EP1IN(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x8)|value<<3)
}
func (o *USB_Type) GetINTSTAT_EP1IN() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x8) >> 3
}
func (o *USB_Type) SetINTSTAT_EP2OUT(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x10)|value<<4)
}
func (o *USB_Type) GetINTSTAT_EP2OUT() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x10) >> 4
}
func (o *USB_Type) SetINTSTAT_EP2IN(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x20)|value<<5)
}
func (o *USB_Type) GetINTSTAT_EP2IN() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x20) >> 5
}
func (o *USB_Type) SetINTSTAT_EP3OUT(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x40)|value<<6)
}
func (o *USB_Type) GetINTSTAT_EP3OUT() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x40) >> 6
}
func (o *USB_Type) SetINTSTAT_EP3IN(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x80)|value<<7)
}
func (o *USB_Type) GetINTSTAT_EP3IN() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x80) >> 7
}
func (o *USB_Type) SetINTSTAT_EP4OUT(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x100)|value<<8)
}
func (o *USB_Type) GetINTSTAT_EP4OUT() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x100) >> 8
}
func (o *USB_Type) SetINTSTAT_EP4IN(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x200)|value<<9)
}
func (o *USB_Type) GetINTSTAT_EP4IN() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x200) >> 9
}
func (o *USB_Type) SetINTSTAT_EP5OUT(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x400)|value<<10)
}
func (o *USB_Type) GetINTSTAT_EP5OUT() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x400) >> 10
}
func (o *USB_Type) SetINTSTAT_EP5IN(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x800)|value<<11)
}
func (o *USB_Type) GetINTSTAT_EP5IN() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x800) >> 11
}
func (o *USB_Type) SetINTSTAT_EP6OUT(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x1000)|value<<12)
}
func (o *USB_Type) GetINTSTAT_EP6OUT() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x1000) >> 12
}
func (o *USB_Type) SetINTSTAT_EP6IN(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x2000)|value<<13)
}
func (o *USB_Type) GetINTSTAT_EP6IN() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x2000) >> 13
}
func (o *USB_Type) SetINTSTAT_EP7OUT(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x4000)|value<<14)
}
func (o *USB_Type) GetINTSTAT_EP7OUT() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x4000) >> 14
}
func (o *USB_Type) SetINTSTAT_EP7IN(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x8000)|value<<15)
}
func (o *USB_Type) GetINTSTAT_EP7IN() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x8000) >> 15
}
func (o *USB_Type) SetINTSTAT_FRAME_INT(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_Type) GetINTSTAT_FRAME_INT() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x40000000) >> 30
}
func (o *USB_Type) SetINTSTAT_DEV_INT(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_Type) GetINTSTAT_DEV_INT() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x80000000) >> 31
}

// USB.INTEN: USB interrupt enable register
func (o *USB_Type) SetINTEN_EP_INT_EN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0xffff)|value)
}
func (o *USB_Type) GetINTEN_EP_INT_EN() uint32 {
	return volatile.LoadUint32(&o.INTEN.Reg) & 0xffff
}
func (o *USB_Type) SetINTEN_FRAME_INT_EN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_Type) GetINTEN_FRAME_INT_EN() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x40000000) >> 30
}
func (o *USB_Type) SetINTEN_DEV_INT_EN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_Type) GetINTEN_DEV_INT_EN() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x80000000) >> 31
}

// USB.INTSETSTAT: USB set interrupt status register
func (o *USB_Type) SetINTSETSTAT_EP_SET_INT(value uint32) {
	volatile.StoreUint32(&o.INTSETSTAT.Reg, volatile.LoadUint32(&o.INTSETSTAT.Reg)&^(0xffff)|value)
}
func (o *USB_Type) GetINTSETSTAT_EP_SET_INT() uint32 {
	return volatile.LoadUint32(&o.INTSETSTAT.Reg) & 0xffff
}
func (o *USB_Type) SetINTSETSTAT_FRAME_SET_INT(value uint32) {
	volatile.StoreUint32(&o.INTSETSTAT.Reg, volatile.LoadUint32(&o.INTSETSTAT.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_Type) GetINTSETSTAT_FRAME_SET_INT() uint32 {
	return (volatile.LoadUint32(&o.INTSETSTAT.Reg) & 0x40000000) >> 30
}
func (o *USB_Type) SetINTSETSTAT_DEV_SET_INT(value uint32) {
	volatile.StoreUint32(&o.INTSETSTAT.Reg, volatile.LoadUint32(&o.INTSETSTAT.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_Type) GetINTSETSTAT_DEV_SET_INT() uint32 {
	return (volatile.LoadUint32(&o.INTSETSTAT.Reg) & 0x80000000) >> 31
}

// USB.EPTOGGLE: USB Endpoint toggle register
func (o *USB_Type) SetEPTOGGLE_TOGGLE(value uint32) {
	volatile.StoreUint32(&o.EPTOGGLE.Reg, volatile.LoadUint32(&o.EPTOGGLE.Reg)&^(0xffff)|value)
}
func (o *USB_Type) GetEPTOGGLE_TOGGLE() uint32 {
	return volatile.LoadUint32(&o.EPTOGGLE.Reg) & 0xffff
}

// LPC5411x SCTimer/PWM (SCT)
type SCT_Type struct {
	CONFIG        volatile.Register32 // 0x0
	CTRL          volatile.Register32 // 0x4
	LIMIT         volatile.Register32 // 0x8
	HALT          volatile.Register32 // 0xC
	STOP          volatile.Register32 // 0x10
	START         volatile.Register32 // 0x14
	_             [40]byte
	COUNT         volatile.Register32 // 0x40
	STATE         volatile.Register32 // 0x44
	INPUT         volatile.Register32 // 0x48
	REGMODE       volatile.Register32 // 0x4C
	OUTPUT        volatile.Register32 // 0x50
	OUTPUTDIRCTRL volatile.Register32 // 0x54
	RES           volatile.Register32 // 0x58
	DMA0REQUEST   volatile.Register32 // 0x5C
	DMA1REQUEST   volatile.Register32 // 0x60
	_             [140]byte
	EVEN          volatile.Register32     // 0xF0
	EVFLAG        volatile.Register32     // 0xF4
	CONEN         volatile.Register32     // 0xF8
	CONFLAG       volatile.Register32     // 0xFC
	SCTCAP        [10]volatile.Register32 // 0x100
	_             [216]byte
	SCTCAPCTRL    [10]volatile.Register32 // 0x200
	_             [216]byte
	EVENT         [10]SCT_EVENT_Type // 0x300
	_             [432]byte
	OUT           [8]SCT_OUT_Type // 0x500
	_             [700]byte
	MODULECONTENT volatile.Register32 // 0x7FC
}

// SCT.CONFIG: SCT configuration register
func (o *SCT_Type) SetCONFIG_UNIFY(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x1)|value)
}
func (o *SCT_Type) GetCONFIG_UNIFY() uint32 {
	return volatile.LoadUint32(&o.CONFIG.Reg) & 0x1
}
func (o *SCT_Type) SetCONFIG_CLKMODE(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x6)|value<<1)
}
func (o *SCT_Type) GetCONFIG_CLKMODE() uint32 {
	return (volatile.LoadUint32(&o.CONFIG.Reg) & 0x6) >> 1
}
func (o *SCT_Type) SetCONFIG_CKSEL(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x78)|value<<3)
}
func (o *SCT_Type) GetCONFIG_CKSEL() uint32 {
	return (volatile.LoadUint32(&o.CONFIG.Reg) & 0x78) >> 3
}
func (o *SCT_Type) SetCONFIG_NORELAOD_L(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x80)|value<<7)
}
func (o *SCT_Type) GetCONFIG_NORELAOD_L() uint32 {
	return (volatile.LoadUint32(&o.CONFIG.Reg) & 0x80) >> 7
}
func (o *SCT_Type) SetCONFIG_NORELOAD_H(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x100)|value<<8)
}
func (o *SCT_Type) GetCONFIG_NORELOAD_H() uint32 {
	return (volatile.LoadUint32(&o.CONFIG.Reg) & 0x100) >> 8
}
func (o *SCT_Type) SetCONFIG_INSYNC(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x1e00)|value<<9)
}
func (o *SCT_Type) GetCONFIG_INSYNC() uint32 {
	return (volatile.LoadUint32(&o.CONFIG.Reg) & 0x1e00) >> 9
}
func (o *SCT_Type) SetCONFIG_AUTOLIMIT_L(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x20000)|value<<17)
}
func (o *SCT_Type) GetCONFIG_AUTOLIMIT_L() uint32 {
	return (volatile.LoadUint32(&o.CONFIG.Reg) & 0x20000) >> 17
}
func (o *SCT_Type) SetCONFIG_AUTOLIMIT_H(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x40000)|value<<18)
}
func (o *SCT_Type) GetCONFIG_AUTOLIMIT_H() uint32 {
	return (volatile.LoadUint32(&o.CONFIG.Reg) & 0x40000) >> 18
}

// SCT.CTRL: SCT control register
func (o *SCT_Type) SetCTRL_DOWN_L(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x1)|value)
}
func (o *SCT_Type) GetCTRL_DOWN_L() uint32 {
	return volatile.LoadUint32(&o.CTRL.Reg) & 0x1
}
func (o *SCT_Type) SetCTRL_STOP_L(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x2)|value<<1)
}
func (o *SCT_Type) GetCTRL_STOP_L() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x2) >> 1
}
func (o *SCT_Type) SetCTRL_HALT_L(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x4)|value<<2)
}
func (o *SCT_Type) GetCTRL_HALT_L() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x4) >> 2
}
func (o *SCT_Type) SetCTRL_CLRCTR_L(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x8)|value<<3)
}
func (o *SCT_Type) GetCTRL_CLRCTR_L() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x8) >> 3
}
func (o *SCT_Type) SetCTRL_BIDIR_L(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x10)|value<<4)
}
func (o *SCT_Type) GetCTRL_BIDIR_L() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x10) >> 4
}
func (o *SCT_Type) SetCTRL_PRE_L(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x1fe0)|value<<5)
}
func (o *SCT_Type) GetCTRL_PRE_L() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x1fe0) >> 5
}
func (o *SCT_Type) SetCTRL_DOWN_H(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x10000)|value<<16)
}
func (o *SCT_Type) GetCTRL_DOWN_H() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x10000) >> 16
}
func (o *SCT_Type) SetCTRL_STOP_H(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x20000)|value<<17)
}
func (o *SCT_Type) GetCTRL_STOP_H() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x20000) >> 17
}
func (o *SCT_Type) SetCTRL_HALT_H(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x40000)|value<<18)
}
func (o *SCT_Type) GetCTRL_HALT_H() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x40000) >> 18
}
func (o *SCT_Type) SetCTRL_CLRCTR_H(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x80000)|value<<19)
}
func (o *SCT_Type) GetCTRL_CLRCTR_H() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x80000) >> 19
}
func (o *SCT_Type) SetCTRL_BIDIR_H(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x100000)|value<<20)
}
func (o *SCT_Type) GetCTRL_BIDIR_H() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x100000) >> 20
}
func (o *SCT_Type) SetCTRL_PRE_H(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x1fe00000)|value<<21)
}
func (o *SCT_Type) GetCTRL_PRE_H() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x1fe00000) >> 21
}

// SCT.LIMIT: SCT limit event select register
func (o *SCT_Type) SetLIMIT_LIMMSK_L(value uint32) {
	volatile.StoreUint32(&o.LIMIT.Reg, volatile.LoadUint32(&o.LIMIT.Reg)&^(0xffff)|value)
}
func (o *SCT_Type) GetLIMIT_LIMMSK_L() uint32 {
	return volatile.LoadUint32(&o.LIMIT.Reg) & 0xffff
}
func (o *SCT_Type) SetLIMIT_LIMMSK_H(value uint32) {
	volatile.StoreUint32(&o.LIMIT.Reg, volatile.LoadUint32(&o.LIMIT.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCT_Type) GetLIMIT_LIMMSK_H() uint32 {
	return (volatile.LoadUint32(&o.LIMIT.Reg) & 0xffff0000) >> 16
}

// SCT.HALT: SCT halt event select register
func (o *SCT_Type) SetHALT_HALTMSK_L(value uint32) {
	volatile.StoreUint32(&o.HALT.Reg, volatile.LoadUint32(&o.HALT.Reg)&^(0xffff)|value)
}
func (o *SCT_Type) GetHALT_HALTMSK_L() uint32 {
	return volatile.LoadUint32(&o.HALT.Reg) & 0xffff
}
func (o *SCT_Type) SetHALT_HALTMSK_H(value uint32) {
	volatile.StoreUint32(&o.HALT.Reg, volatile.LoadUint32(&o.HALT.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCT_Type) GetHALT_HALTMSK_H() uint32 {
	return (volatile.LoadUint32(&o.HALT.Reg) & 0xffff0000) >> 16
}

// SCT.STOP: SCT stop event select register
func (o *SCT_Type) SetSTOP_STOPMSK_L(value uint32) {
	volatile.StoreUint32(&o.STOP.Reg, volatile.LoadUint32(&o.STOP.Reg)&^(0xffff)|value)
}
func (o *SCT_Type) GetSTOP_STOPMSK_L() uint32 {
	return volatile.LoadUint32(&o.STOP.Reg) & 0xffff
}
func (o *SCT_Type) SetSTOP_STOPMSK_H(value uint32) {
	volatile.StoreUint32(&o.STOP.Reg, volatile.LoadUint32(&o.STOP.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCT_Type) GetSTOP_STOPMSK_H() uint32 {
	return (volatile.LoadUint32(&o.STOP.Reg) & 0xffff0000) >> 16
}

// SCT.START: SCT start event select register
func (o *SCT_Type) SetSTART_STARTMSK_L(value uint32) {
	volatile.StoreUint32(&o.START.Reg, volatile.LoadUint32(&o.START.Reg)&^(0xffff)|value)
}
func (o *SCT_Type) GetSTART_STARTMSK_L() uint32 {
	return volatile.LoadUint32(&o.START.Reg) & 0xffff
}
func (o *SCT_Type) SetSTART_STARTMSK_H(value uint32) {
	volatile.StoreUint32(&o.START.Reg, volatile.LoadUint32(&o.START.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCT_Type) GetSTART_STARTMSK_H() uint32 {
	return (volatile.LoadUint32(&o.START.Reg) & 0xffff0000) >> 16
}

// SCT.COUNT: SCT counter register
func (o *SCT_Type) SetCOUNT_CTR_L(value uint32) {
	volatile.StoreUint32(&o.COUNT.Reg, volatile.LoadUint32(&o.COUNT.Reg)&^(0xffff)|value)
}
func (o *SCT_Type) GetCOUNT_CTR_L() uint32 {
	return volatile.LoadUint32(&o.COUNT.Reg) & 0xffff
}
func (o *SCT_Type) SetCOUNT_CTR_H(value uint32) {
	volatile.StoreUint32(&o.COUNT.Reg, volatile.LoadUint32(&o.COUNT.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCT_Type) GetCOUNT_CTR_H() uint32 {
	return (volatile.LoadUint32(&o.COUNT.Reg) & 0xffff0000) >> 16
}

// SCT.STATE: SCT state register
func (o *SCT_Type) SetSTATE_STATE_L(value uint32) {
	volatile.StoreUint32(&o.STATE.Reg, volatile.LoadUint32(&o.STATE.Reg)&^(0x1f)|value)
}
func (o *SCT_Type) GetSTATE_STATE_L() uint32 {
	return volatile.LoadUint32(&o.STATE.Reg) & 0x1f
}
func (o *SCT_Type) SetSTATE_STATE_H(value uint32) {
	volatile.StoreUint32(&o.STATE.Reg, volatile.LoadUint32(&o.STATE.Reg)&^(0x1f0000)|value<<16)
}
func (o *SCT_Type) GetSTATE_STATE_H() uint32 {
	return (volatile.LoadUint32(&o.STATE.Reg) & 0x1f0000) >> 16
}

// SCT.INPUT: SCT input register
func (o *SCT_Type) SetINPUT_AIN0(value uint32) {
	volatile.StoreUint32(&o.INPUT.Reg, volatile.LoadUint32(&o.INPUT.Reg)&^(0x1)|value)
}
func (o *SCT_Type) GetINPUT_AIN0() uint32 {
	return volatile.LoadUint32(&o.INPUT.Reg) & 0x1
}
func (o *SCT_Type) SetINPUT_AIN1(value uint32) {
	volatile.StoreUint32(&o.INPUT.Reg, volatile.LoadUint32(&o.INPUT.Reg)&^(0x2)|value<<1)
}
func (o *SCT_Type) GetINPUT_AIN1() uint32 {
	return (volatile.LoadUint32(&o.INPUT.Reg) & 0x2) >> 1
}
func (o *SCT_Type) SetINPUT_AIN2(value uint32) {
	volatile.StoreUint32(&o.INPUT.Reg, volatile.LoadUint32(&o.INPUT.Reg)&^(0x4)|value<<2)
}
func (o *SCT_Type) GetINPUT_AIN2() uint32 {
	return (volatile.LoadUint32(&o.INPUT.Reg) & 0x4) >> 2
}
func (o *SCT_Type) SetINPUT_AIN3(value uint32) {
	volatile.StoreUint32(&o.INPUT.Reg, volatile.LoadUint32(&o.INPUT.Reg)&^(0x8)|value<<3)
}
func (o *SCT_Type) GetINPUT_AIN3() uint32 {
	return (volatile.LoadUint32(&o.INPUT.Reg) & 0x8) >> 3
}
func (o *SCT_Type) SetINPUT_AIN4(value uint32) {
	volatile.StoreUint32(&o.INPUT.Reg, volatile.LoadUint32(&o.INPUT.Reg)&^(0x10)|value<<4)
}
func (o *SCT_Type) GetINPUT_AIN4() uint32 {
	return (volatile.LoadUint32(&o.INPUT.Reg) & 0x10) >> 4
}
func (o *SCT_Type) SetINPUT_AIN5(value uint32) {
	volatile.StoreUint32(&o.INPUT.Reg, volatile.LoadUint32(&o.INPUT.Reg)&^(0x20)|value<<5)
}
func (o *SCT_Type) GetINPUT_AIN5() uint32 {
	return (volatile.LoadUint32(&o.INPUT.Reg) & 0x20) >> 5
}
func (o *SCT_Type) SetINPUT_AIN6(value uint32) {
	volatile.StoreUint32(&o.INPUT.Reg, volatile.LoadUint32(&o.INPUT.Reg)&^(0x40)|value<<6)
}
func (o *SCT_Type) GetINPUT_AIN6() uint32 {
	return (volatile.LoadUint32(&o.INPUT.Reg) & 0x40) >> 6
}
func (o *SCT_Type) SetINPUT_AIN7(value uint32) {
	volatile.StoreUint32(&o.INPUT.Reg, volatile.LoadUint32(&o.INPUT.Reg)&^(0x80)|value<<7)
}
func (o *SCT_Type) GetINPUT_AIN7() uint32 {
	return (volatile.LoadUint32(&o.INPUT.Reg) & 0x80) >> 7
}
func (o *SCT_Type) SetINPUT_AIN8(value uint32) {
	volatile.StoreUint32(&o.INPUT.Reg, volatile.LoadUint32(&o.INPUT.Reg)&^(0x100)|value<<8)
}
func (o *SCT_Type) GetINPUT_AIN8() uint32 {
	return (volatile.LoadUint32(&o.INPUT.Reg) & 0x100) >> 8
}
func (o *SCT_Type) SetINPUT_AIN9(value uint32) {
	volatile.StoreUint32(&o.INPUT.Reg, volatile.LoadUint32(&o.INPUT.Reg)&^(0x200)|value<<9)
}
func (o *SCT_Type) GetINPUT_AIN9() uint32 {
	return (volatile.LoadUint32(&o.INPUT.Reg) & 0x200) >> 9
}
func (o *SCT_Type) SetINPUT_AIN10(value uint32) {
	volatile.StoreUint32(&o.INPUT.Reg, volatile.LoadUint32(&o.INPUT.Reg)&^(0x400)|value<<10)
}
func (o *SCT_Type) GetINPUT_AIN10() uint32 {
	return (volatile.LoadUint32(&o.INPUT.Reg) & 0x400) >> 10
}
func (o *SCT_Type) SetINPUT_AIN11(value uint32) {
	volatile.StoreUint32(&o.INPUT.Reg, volatile.LoadUint32(&o.INPUT.Reg)&^(0x800)|value<<11)
}
func (o *SCT_Type) GetINPUT_AIN11() uint32 {
	return (volatile.LoadUint32(&o.INPUT.Reg) & 0x800) >> 11
}
func (o *SCT_Type) SetINPUT_AIN12(value uint32) {
	volatile.StoreUint32(&o.INPUT.Reg, volatile.LoadUint32(&o.INPUT.Reg)&^(0x1000)|value<<12)
}
func (o *SCT_Type) GetINPUT_AIN12() uint32 {
	return (volatile.LoadUint32(&o.INPUT.Reg) & 0x1000) >> 12
}
func (o *SCT_Type) SetINPUT_AIN13(value uint32) {
	volatile.StoreUint32(&o.INPUT.Reg, volatile.LoadUint32(&o.INPUT.Reg)&^(0x2000)|value<<13)
}
func (o *SCT_Type) GetINPUT_AIN13() uint32 {
	return (volatile.LoadUint32(&o.INPUT.Reg) & 0x2000) >> 13
}
func (o *SCT_Type) SetINPUT_AIN14(value uint32) {
	volatile.StoreUint32(&o.INPUT.Reg, volatile.LoadUint32(&o.INPUT.Reg)&^(0x4000)|value<<14)
}
func (o *SCT_Type) GetINPUT_AIN14() uint32 {
	return (volatile.LoadUint32(&o.INPUT.Reg) & 0x4000) >> 14
}
func (o *SCT_Type) SetINPUT_AIN15(value uint32) {
	volatile.StoreUint32(&o.INPUT.Reg, volatile.LoadUint32(&o.INPUT.Reg)&^(0x8000)|value<<15)
}
func (o *SCT_Type) GetINPUT_AIN15() uint32 {
	return (volatile.LoadUint32(&o.INPUT.Reg) & 0x8000) >> 15
}
func (o *SCT_Type) SetINPUT_SIN0(value uint32) {
	volatile.StoreUint32(&o.INPUT.Reg, volatile.LoadUint32(&o.INPUT.Reg)&^(0x10000)|value<<16)
}
func (o *SCT_Type) GetINPUT_SIN0() uint32 {
	return (volatile.LoadUint32(&o.INPUT.Reg) & 0x10000) >> 16
}
func (o *SCT_Type) SetINPUT_SIN1(value uint32) {
	volatile.StoreUint32(&o.INPUT.Reg, volatile.LoadUint32(&o.INPUT.Reg)&^(0x20000)|value<<17)
}
func (o *SCT_Type) GetINPUT_SIN1() uint32 {
	return (volatile.LoadUint32(&o.INPUT.Reg) & 0x20000) >> 17
}
func (o *SCT_Type) SetINPUT_SIN2(value uint32) {
	volatile.StoreUint32(&o.INPUT.Reg, volatile.LoadUint32(&o.INPUT.Reg)&^(0x40000)|value<<18)
}
func (o *SCT_Type) GetINPUT_SIN2() uint32 {
	return (volatile.LoadUint32(&o.INPUT.Reg) & 0x40000) >> 18
}
func (o *SCT_Type) SetINPUT_SIN3(value uint32) {
	volatile.StoreUint32(&o.INPUT.Reg, volatile.LoadUint32(&o.INPUT.Reg)&^(0x80000)|value<<19)
}
func (o *SCT_Type) GetINPUT_SIN3() uint32 {
	return (volatile.LoadUint32(&o.INPUT.Reg) & 0x80000) >> 19
}
func (o *SCT_Type) SetINPUT_SIN4(value uint32) {
	volatile.StoreUint32(&o.INPUT.Reg, volatile.LoadUint32(&o.INPUT.Reg)&^(0x100000)|value<<20)
}
func (o *SCT_Type) GetINPUT_SIN4() uint32 {
	return (volatile.LoadUint32(&o.INPUT.Reg) & 0x100000) >> 20
}
func (o *SCT_Type) SetINPUT_SIN5(value uint32) {
	volatile.StoreUint32(&o.INPUT.Reg, volatile.LoadUint32(&o.INPUT.Reg)&^(0x200000)|value<<21)
}
func (o *SCT_Type) GetINPUT_SIN5() uint32 {
	return (volatile.LoadUint32(&o.INPUT.Reg) & 0x200000) >> 21
}
func (o *SCT_Type) SetINPUT_SIN6(value uint32) {
	volatile.StoreUint32(&o.INPUT.Reg, volatile.LoadUint32(&o.INPUT.Reg)&^(0x400000)|value<<22)
}
func (o *SCT_Type) GetINPUT_SIN6() uint32 {
	return (volatile.LoadUint32(&o.INPUT.Reg) & 0x400000) >> 22
}
func (o *SCT_Type) SetINPUT_SIN7(value uint32) {
	volatile.StoreUint32(&o.INPUT.Reg, volatile.LoadUint32(&o.INPUT.Reg)&^(0x800000)|value<<23)
}
func (o *SCT_Type) GetINPUT_SIN7() uint32 {
	return (volatile.LoadUint32(&o.INPUT.Reg) & 0x800000) >> 23
}
func (o *SCT_Type) SetINPUT_SIN8(value uint32) {
	volatile.StoreUint32(&o.INPUT.Reg, volatile.LoadUint32(&o.INPUT.Reg)&^(0x1000000)|value<<24)
}
func (o *SCT_Type) GetINPUT_SIN8() uint32 {
	return (volatile.LoadUint32(&o.INPUT.Reg) & 0x1000000) >> 24
}
func (o *SCT_Type) SetINPUT_SIN9(value uint32) {
	volatile.StoreUint32(&o.INPUT.Reg, volatile.LoadUint32(&o.INPUT.Reg)&^(0x2000000)|value<<25)
}
func (o *SCT_Type) GetINPUT_SIN9() uint32 {
	return (volatile.LoadUint32(&o.INPUT.Reg) & 0x2000000) >> 25
}
func (o *SCT_Type) SetINPUT_SIN10(value uint32) {
	volatile.StoreUint32(&o.INPUT.Reg, volatile.LoadUint32(&o.INPUT.Reg)&^(0x4000000)|value<<26)
}
func (o *SCT_Type) GetINPUT_SIN10() uint32 {
	return (volatile.LoadUint32(&o.INPUT.Reg) & 0x4000000) >> 26
}
func (o *SCT_Type) SetINPUT_SIN11(value uint32) {
	volatile.StoreUint32(&o.INPUT.Reg, volatile.LoadUint32(&o.INPUT.Reg)&^(0x8000000)|value<<27)
}
func (o *SCT_Type) GetINPUT_SIN11() uint32 {
	return (volatile.LoadUint32(&o.INPUT.Reg) & 0x8000000) >> 27
}
func (o *SCT_Type) SetINPUT_SIN12(value uint32) {
	volatile.StoreUint32(&o.INPUT.Reg, volatile.LoadUint32(&o.INPUT.Reg)&^(0x10000000)|value<<28)
}
func (o *SCT_Type) GetINPUT_SIN12() uint32 {
	return (volatile.LoadUint32(&o.INPUT.Reg) & 0x10000000) >> 28
}
func (o *SCT_Type) SetINPUT_SIN13(value uint32) {
	volatile.StoreUint32(&o.INPUT.Reg, volatile.LoadUint32(&o.INPUT.Reg)&^(0x20000000)|value<<29)
}
func (o *SCT_Type) GetINPUT_SIN13() uint32 {
	return (volatile.LoadUint32(&o.INPUT.Reg) & 0x20000000) >> 29
}
func (o *SCT_Type) SetINPUT_SIN14(value uint32) {
	volatile.StoreUint32(&o.INPUT.Reg, volatile.LoadUint32(&o.INPUT.Reg)&^(0x40000000)|value<<30)
}
func (o *SCT_Type) GetINPUT_SIN14() uint32 {
	return (volatile.LoadUint32(&o.INPUT.Reg) & 0x40000000) >> 30
}
func (o *SCT_Type) SetINPUT_SIN15(value uint32) {
	volatile.StoreUint32(&o.INPUT.Reg, volatile.LoadUint32(&o.INPUT.Reg)&^(0x80000000)|value<<31)
}
func (o *SCT_Type) GetINPUT_SIN15() uint32 {
	return (volatile.LoadUint32(&o.INPUT.Reg) & 0x80000000) >> 31
}

// SCT.REGMODE: SCT match/capture mode register
func (o *SCT_Type) SetREGMODE_REGMOD_L(value uint32) {
	volatile.StoreUint32(&o.REGMODE.Reg, volatile.LoadUint32(&o.REGMODE.Reg)&^(0xffff)|value)
}
func (o *SCT_Type) GetREGMODE_REGMOD_L() uint32 {
	return volatile.LoadUint32(&o.REGMODE.Reg) & 0xffff
}
func (o *SCT_Type) SetREGMODE_REGMOD_H(value uint32) {
	volatile.StoreUint32(&o.REGMODE.Reg, volatile.LoadUint32(&o.REGMODE.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCT_Type) GetREGMODE_REGMOD_H() uint32 {
	return (volatile.LoadUint32(&o.REGMODE.Reg) & 0xffff0000) >> 16
}

// SCT.OUTPUT: SCT output register
func (o *SCT_Type) SetOUTPUT_OUT(value uint32) {
	volatile.StoreUint32(&o.OUTPUT.Reg, volatile.LoadUint32(&o.OUTPUT.Reg)&^(0xffff)|value)
}
func (o *SCT_Type) GetOUTPUT_OUT() uint32 {
	return volatile.LoadUint32(&o.OUTPUT.Reg) & 0xffff
}

// SCT.OUTPUTDIRCTRL: SCT output counter direction control register
func (o *SCT_Type) SetOUTPUTDIRCTRL_SETCLR0(value uint32) {
	volatile.StoreUint32(&o.OUTPUTDIRCTRL.Reg, volatile.LoadUint32(&o.OUTPUTDIRCTRL.Reg)&^(0x3)|value)
}
func (o *SCT_Type) GetOUTPUTDIRCTRL_SETCLR0() uint32 {
	return volatile.LoadUint32(&o.OUTPUTDIRCTRL.Reg) & 0x3
}
func (o *SCT_Type) SetOUTPUTDIRCTRL_SETCLR1(value uint32) {
	volatile.StoreUint32(&o.OUTPUTDIRCTRL.Reg, volatile.LoadUint32(&o.OUTPUTDIRCTRL.Reg)&^(0xc)|value<<2)
}
func (o *SCT_Type) GetOUTPUTDIRCTRL_SETCLR1() uint32 {
	return (volatile.LoadUint32(&o.OUTPUTDIRCTRL.Reg) & 0xc) >> 2
}
func (o *SCT_Type) SetOUTPUTDIRCTRL_SETCLR2(value uint32) {
	volatile.StoreUint32(&o.OUTPUTDIRCTRL.Reg, volatile.LoadUint32(&o.OUTPUTDIRCTRL.Reg)&^(0x30)|value<<4)
}
func (o *SCT_Type) GetOUTPUTDIRCTRL_SETCLR2() uint32 {
	return (volatile.LoadUint32(&o.OUTPUTDIRCTRL.Reg) & 0x30) >> 4
}
func (o *SCT_Type) SetOUTPUTDIRCTRL_SETCLR3(value uint32) {
	volatile.StoreUint32(&o.OUTPUTDIRCTRL.Reg, volatile.LoadUint32(&o.OUTPUTDIRCTRL.Reg)&^(0xc0)|value<<6)
}
func (o *SCT_Type) GetOUTPUTDIRCTRL_SETCLR3() uint32 {
	return (volatile.LoadUint32(&o.OUTPUTDIRCTRL.Reg) & 0xc0) >> 6
}
func (o *SCT_Type) SetOUTPUTDIRCTRL_SETCLR4(value uint32) {
	volatile.StoreUint32(&o.OUTPUTDIRCTRL.Reg, volatile.LoadUint32(&o.OUTPUTDIRCTRL.Reg)&^(0x300)|value<<8)
}
func (o *SCT_Type) GetOUTPUTDIRCTRL_SETCLR4() uint32 {
	return (volatile.LoadUint32(&o.OUTPUTDIRCTRL.Reg) & 0x300) >> 8
}
func (o *SCT_Type) SetOUTPUTDIRCTRL_SETCLR5(value uint32) {
	volatile.StoreUint32(&o.OUTPUTDIRCTRL.Reg, volatile.LoadUint32(&o.OUTPUTDIRCTRL.Reg)&^(0xc00)|value<<10)
}
func (o *SCT_Type) GetOUTPUTDIRCTRL_SETCLR5() uint32 {
	return (volatile.LoadUint32(&o.OUTPUTDIRCTRL.Reg) & 0xc00) >> 10
}
func (o *SCT_Type) SetOUTPUTDIRCTRL_SETCLR6(value uint32) {
	volatile.StoreUint32(&o.OUTPUTDIRCTRL.Reg, volatile.LoadUint32(&o.OUTPUTDIRCTRL.Reg)&^(0x3000)|value<<12)
}
func (o *SCT_Type) GetOUTPUTDIRCTRL_SETCLR6() uint32 {
	return (volatile.LoadUint32(&o.OUTPUTDIRCTRL.Reg) & 0x3000) >> 12
}
func (o *SCT_Type) SetOUTPUTDIRCTRL_SETCLR7(value uint32) {
	volatile.StoreUint32(&o.OUTPUTDIRCTRL.Reg, volatile.LoadUint32(&o.OUTPUTDIRCTRL.Reg)&^(0xc000)|value<<14)
}
func (o *SCT_Type) GetOUTPUTDIRCTRL_SETCLR7() uint32 {
	return (volatile.LoadUint32(&o.OUTPUTDIRCTRL.Reg) & 0xc000) >> 14
}
func (o *SCT_Type) SetOUTPUTDIRCTRL_SETCLR8(value uint32) {
	volatile.StoreUint32(&o.OUTPUTDIRCTRL.Reg, volatile.LoadUint32(&o.OUTPUTDIRCTRL.Reg)&^(0x30000)|value<<16)
}
func (o *SCT_Type) GetOUTPUTDIRCTRL_SETCLR8() uint32 {
	return (volatile.LoadUint32(&o.OUTPUTDIRCTRL.Reg) & 0x30000) >> 16
}
func (o *SCT_Type) SetOUTPUTDIRCTRL_SETCLR9(value uint32) {
	volatile.StoreUint32(&o.OUTPUTDIRCTRL.Reg, volatile.LoadUint32(&o.OUTPUTDIRCTRL.Reg)&^(0xc0000)|value<<18)
}
func (o *SCT_Type) GetOUTPUTDIRCTRL_SETCLR9() uint32 {
	return (volatile.LoadUint32(&o.OUTPUTDIRCTRL.Reg) & 0xc0000) >> 18
}
func (o *SCT_Type) SetOUTPUTDIRCTRL_SETCLR10(value uint32) {
	volatile.StoreUint32(&o.OUTPUTDIRCTRL.Reg, volatile.LoadUint32(&o.OUTPUTDIRCTRL.Reg)&^(0x300000)|value<<20)
}
func (o *SCT_Type) GetOUTPUTDIRCTRL_SETCLR10() uint32 {
	return (volatile.LoadUint32(&o.OUTPUTDIRCTRL.Reg) & 0x300000) >> 20
}
func (o *SCT_Type) SetOUTPUTDIRCTRL_SETCLR11(value uint32) {
	volatile.StoreUint32(&o.OUTPUTDIRCTRL.Reg, volatile.LoadUint32(&o.OUTPUTDIRCTRL.Reg)&^(0xc00000)|value<<22)
}
func (o *SCT_Type) GetOUTPUTDIRCTRL_SETCLR11() uint32 {
	return (volatile.LoadUint32(&o.OUTPUTDIRCTRL.Reg) & 0xc00000) >> 22
}
func (o *SCT_Type) SetOUTPUTDIRCTRL_SETCLR12(value uint32) {
	volatile.StoreUint32(&o.OUTPUTDIRCTRL.Reg, volatile.LoadUint32(&o.OUTPUTDIRCTRL.Reg)&^(0x3000000)|value<<24)
}
func (o *SCT_Type) GetOUTPUTDIRCTRL_SETCLR12() uint32 {
	return (volatile.LoadUint32(&o.OUTPUTDIRCTRL.Reg) & 0x3000000) >> 24
}
func (o *SCT_Type) SetOUTPUTDIRCTRL_SETCLR13(value uint32) {
	volatile.StoreUint32(&o.OUTPUTDIRCTRL.Reg, volatile.LoadUint32(&o.OUTPUTDIRCTRL.Reg)&^(0xc000000)|value<<26)
}
func (o *SCT_Type) GetOUTPUTDIRCTRL_SETCLR13() uint32 {
	return (volatile.LoadUint32(&o.OUTPUTDIRCTRL.Reg) & 0xc000000) >> 26
}
func (o *SCT_Type) SetOUTPUTDIRCTRL_SETCLR14(value uint32) {
	volatile.StoreUint32(&o.OUTPUTDIRCTRL.Reg, volatile.LoadUint32(&o.OUTPUTDIRCTRL.Reg)&^(0x30000000)|value<<28)
}
func (o *SCT_Type) GetOUTPUTDIRCTRL_SETCLR14() uint32 {
	return (volatile.LoadUint32(&o.OUTPUTDIRCTRL.Reg) & 0x30000000) >> 28
}
func (o *SCT_Type) SetOUTPUTDIRCTRL_SETCLR15(value uint32) {
	volatile.StoreUint32(&o.OUTPUTDIRCTRL.Reg, volatile.LoadUint32(&o.OUTPUTDIRCTRL.Reg)&^(0xc0000000)|value<<30)
}
func (o *SCT_Type) GetOUTPUTDIRCTRL_SETCLR15() uint32 {
	return (volatile.LoadUint32(&o.OUTPUTDIRCTRL.Reg) & 0xc0000000) >> 30
}

// SCT.RES: SCT conflict resolution register
func (o *SCT_Type) SetRES_O0RES(value uint32) {
	volatile.StoreUint32(&o.RES.Reg, volatile.LoadUint32(&o.RES.Reg)&^(0x3)|value)
}
func (o *SCT_Type) GetRES_O0RES() uint32 {
	return volatile.LoadUint32(&o.RES.Reg) & 0x3
}
func (o *SCT_Type) SetRES_O1RES(value uint32) {
	volatile.StoreUint32(&o.RES.Reg, volatile.LoadUint32(&o.RES.Reg)&^(0xc)|value<<2)
}
func (o *SCT_Type) GetRES_O1RES() uint32 {
	return (volatile.LoadUint32(&o.RES.Reg) & 0xc) >> 2
}
func (o *SCT_Type) SetRES_O2RES(value uint32) {
	volatile.StoreUint32(&o.RES.Reg, volatile.LoadUint32(&o.RES.Reg)&^(0x30)|value<<4)
}
func (o *SCT_Type) GetRES_O2RES() uint32 {
	return (volatile.LoadUint32(&o.RES.Reg) & 0x30) >> 4
}
func (o *SCT_Type) SetRES_O3RES(value uint32) {
	volatile.StoreUint32(&o.RES.Reg, volatile.LoadUint32(&o.RES.Reg)&^(0xc0)|value<<6)
}
func (o *SCT_Type) GetRES_O3RES() uint32 {
	return (volatile.LoadUint32(&o.RES.Reg) & 0xc0) >> 6
}
func (o *SCT_Type) SetRES_O4RES(value uint32) {
	volatile.StoreUint32(&o.RES.Reg, volatile.LoadUint32(&o.RES.Reg)&^(0x300)|value<<8)
}
func (o *SCT_Type) GetRES_O4RES() uint32 {
	return (volatile.LoadUint32(&o.RES.Reg) & 0x300) >> 8
}
func (o *SCT_Type) SetRES_O5RES(value uint32) {
	volatile.StoreUint32(&o.RES.Reg, volatile.LoadUint32(&o.RES.Reg)&^(0xc00)|value<<10)
}
func (o *SCT_Type) GetRES_O5RES() uint32 {
	return (volatile.LoadUint32(&o.RES.Reg) & 0xc00) >> 10
}
func (o *SCT_Type) SetRES_O6RES(value uint32) {
	volatile.StoreUint32(&o.RES.Reg, volatile.LoadUint32(&o.RES.Reg)&^(0x3000)|value<<12)
}
func (o *SCT_Type) GetRES_O6RES() uint32 {
	return (volatile.LoadUint32(&o.RES.Reg) & 0x3000) >> 12
}
func (o *SCT_Type) SetRES_O7RES(value uint32) {
	volatile.StoreUint32(&o.RES.Reg, volatile.LoadUint32(&o.RES.Reg)&^(0xc000)|value<<14)
}
func (o *SCT_Type) GetRES_O7RES() uint32 {
	return (volatile.LoadUint32(&o.RES.Reg) & 0xc000) >> 14
}
func (o *SCT_Type) SetRES_O8RES(value uint32) {
	volatile.StoreUint32(&o.RES.Reg, volatile.LoadUint32(&o.RES.Reg)&^(0x30000)|value<<16)
}
func (o *SCT_Type) GetRES_O8RES() uint32 {
	return (volatile.LoadUint32(&o.RES.Reg) & 0x30000) >> 16
}
func (o *SCT_Type) SetRES_O9RES(value uint32) {
	volatile.StoreUint32(&o.RES.Reg, volatile.LoadUint32(&o.RES.Reg)&^(0xc0000)|value<<18)
}
func (o *SCT_Type) GetRES_O9RES() uint32 {
	return (volatile.LoadUint32(&o.RES.Reg) & 0xc0000) >> 18
}
func (o *SCT_Type) SetRES_O10RES(value uint32) {
	volatile.StoreUint32(&o.RES.Reg, volatile.LoadUint32(&o.RES.Reg)&^(0x300000)|value<<20)
}
func (o *SCT_Type) GetRES_O10RES() uint32 {
	return (volatile.LoadUint32(&o.RES.Reg) & 0x300000) >> 20
}
func (o *SCT_Type) SetRES_O11RES(value uint32) {
	volatile.StoreUint32(&o.RES.Reg, volatile.LoadUint32(&o.RES.Reg)&^(0xc00000)|value<<22)
}
func (o *SCT_Type) GetRES_O11RES() uint32 {
	return (volatile.LoadUint32(&o.RES.Reg) & 0xc00000) >> 22
}
func (o *SCT_Type) SetRES_O12RES(value uint32) {
	volatile.StoreUint32(&o.RES.Reg, volatile.LoadUint32(&o.RES.Reg)&^(0x3000000)|value<<24)
}
func (o *SCT_Type) GetRES_O12RES() uint32 {
	return (volatile.LoadUint32(&o.RES.Reg) & 0x3000000) >> 24
}
func (o *SCT_Type) SetRES_O13RES(value uint32) {
	volatile.StoreUint32(&o.RES.Reg, volatile.LoadUint32(&o.RES.Reg)&^(0xc000000)|value<<26)
}
func (o *SCT_Type) GetRES_O13RES() uint32 {
	return (volatile.LoadUint32(&o.RES.Reg) & 0xc000000) >> 26
}
func (o *SCT_Type) SetRES_O14RES(value uint32) {
	volatile.StoreUint32(&o.RES.Reg, volatile.LoadUint32(&o.RES.Reg)&^(0x30000000)|value<<28)
}
func (o *SCT_Type) GetRES_O14RES() uint32 {
	return (volatile.LoadUint32(&o.RES.Reg) & 0x30000000) >> 28
}
func (o *SCT_Type) SetRES_O15RES(value uint32) {
	volatile.StoreUint32(&o.RES.Reg, volatile.LoadUint32(&o.RES.Reg)&^(0xc0000000)|value<<30)
}
func (o *SCT_Type) GetRES_O15RES() uint32 {
	return (volatile.LoadUint32(&o.RES.Reg) & 0xc0000000) >> 30
}

// SCT.DMA0REQUEST: SCT DMA request 0 register
func (o *SCT_Type) SetDMA0REQUEST_DEV_0(value uint32) {
	volatile.StoreUint32(&o.DMA0REQUEST.Reg, volatile.LoadUint32(&o.DMA0REQUEST.Reg)&^(0xffff)|value)
}
func (o *SCT_Type) GetDMA0REQUEST_DEV_0() uint32 {
	return volatile.LoadUint32(&o.DMA0REQUEST.Reg) & 0xffff
}
func (o *SCT_Type) SetDMA0REQUEST_DRL0(value uint32) {
	volatile.StoreUint32(&o.DMA0REQUEST.Reg, volatile.LoadUint32(&o.DMA0REQUEST.Reg)&^(0x40000000)|value<<30)
}
func (o *SCT_Type) GetDMA0REQUEST_DRL0() uint32 {
	return (volatile.LoadUint32(&o.DMA0REQUEST.Reg) & 0x40000000) >> 30
}
func (o *SCT_Type) SetDMA0REQUEST_DRQ0(value uint32) {
	volatile.StoreUint32(&o.DMA0REQUEST.Reg, volatile.LoadUint32(&o.DMA0REQUEST.Reg)&^(0x80000000)|value<<31)
}
func (o *SCT_Type) GetDMA0REQUEST_DRQ0() uint32 {
	return (volatile.LoadUint32(&o.DMA0REQUEST.Reg) & 0x80000000) >> 31
}

// SCT.DMA1REQUEST: SCT DMA request 1 register
func (o *SCT_Type) SetDMA1REQUEST_DEV_1(value uint32) {
	volatile.StoreUint32(&o.DMA1REQUEST.Reg, volatile.LoadUint32(&o.DMA1REQUEST.Reg)&^(0xffff)|value)
}
func (o *SCT_Type) GetDMA1REQUEST_DEV_1() uint32 {
	return volatile.LoadUint32(&o.DMA1REQUEST.Reg) & 0xffff
}
func (o *SCT_Type) SetDMA1REQUEST_DRL1(value uint32) {
	volatile.StoreUint32(&o.DMA1REQUEST.Reg, volatile.LoadUint32(&o.DMA1REQUEST.Reg)&^(0x40000000)|value<<30)
}
func (o *SCT_Type) GetDMA1REQUEST_DRL1() uint32 {
	return (volatile.LoadUint32(&o.DMA1REQUEST.Reg) & 0x40000000) >> 30
}
func (o *SCT_Type) SetDMA1REQUEST_DRQ1(value uint32) {
	volatile.StoreUint32(&o.DMA1REQUEST.Reg, volatile.LoadUint32(&o.DMA1REQUEST.Reg)&^(0x80000000)|value<<31)
}
func (o *SCT_Type) GetDMA1REQUEST_DRQ1() uint32 {
	return (volatile.LoadUint32(&o.DMA1REQUEST.Reg) & 0x80000000) >> 31
}

// SCT.EVEN: SCT event interrupt enable register
func (o *SCT_Type) SetEVEN_IEN(value uint32) {
	volatile.StoreUint32(&o.EVEN.Reg, volatile.LoadUint32(&o.EVEN.Reg)&^(0xffff)|value)
}
func (o *SCT_Type) GetEVEN_IEN() uint32 {
	return volatile.LoadUint32(&o.EVEN.Reg) & 0xffff
}

// SCT.EVFLAG: SCT event flag register
func (o *SCT_Type) SetEVFLAG_FLAG(value uint32) {
	volatile.StoreUint32(&o.EVFLAG.Reg, volatile.LoadUint32(&o.EVFLAG.Reg)&^(0xffff)|value)
}
func (o *SCT_Type) GetEVFLAG_FLAG() uint32 {
	return volatile.LoadUint32(&o.EVFLAG.Reg) & 0xffff
}

// SCT.CONEN: SCT conflict interrupt enable register
func (o *SCT_Type) SetCONEN_NCEN(value uint32) {
	volatile.StoreUint32(&o.CONEN.Reg, volatile.LoadUint32(&o.CONEN.Reg)&^(0xffff)|value)
}
func (o *SCT_Type) GetCONEN_NCEN() uint32 {
	return volatile.LoadUint32(&o.CONEN.Reg) & 0xffff
}

// SCT.CONFLAG: SCT conflict flag register
func (o *SCT_Type) SetCONFLAG_NCFLAG(value uint32) {
	volatile.StoreUint32(&o.CONFLAG.Reg, volatile.LoadUint32(&o.CONFLAG.Reg)&^(0xffff)|value)
}
func (o *SCT_Type) GetCONFLAG_NCFLAG() uint32 {
	return volatile.LoadUint32(&o.CONFLAG.Reg) & 0xffff
}
func (o *SCT_Type) SetCONFLAG_BUSERRL(value uint32) {
	volatile.StoreUint32(&o.CONFLAG.Reg, volatile.LoadUint32(&o.CONFLAG.Reg)&^(0x40000000)|value<<30)
}
func (o *SCT_Type) GetCONFLAG_BUSERRL() uint32 {
	return (volatile.LoadUint32(&o.CONFLAG.Reg) & 0x40000000) >> 30
}
func (o *SCT_Type) SetCONFLAG_BUSERRH(value uint32) {
	volatile.StoreUint32(&o.CONFLAG.Reg, volatile.LoadUint32(&o.CONFLAG.Reg)&^(0x80000000)|value<<31)
}
func (o *SCT_Type) GetCONFLAG_BUSERRH() uint32 {
	return (volatile.LoadUint32(&o.CONFLAG.Reg) & 0x80000000) >> 31
}

// SCT.SCTCAP: SCT capture register of capture channel
func (o *SCT_Type) SetSCTCAP_CAPn_L(idx int, value uint32) {
	volatile.StoreUint32(&o.SCTCAP[idx].Reg, volatile.LoadUint32(&o.SCTCAP[idx].Reg)&^(0xffff)|value)
}
func (o *SCT_Type) GetSCTCAP_CAPn_L(idx int) uint32 {
	return volatile.LoadUint32(&o.SCTCAP[idx].Reg) & 0xffff
}
func (o *SCT_Type) SetSCTCAP_CAPn_H(idx int, value uint32) {
	volatile.StoreUint32(&o.SCTCAP[idx].Reg, volatile.LoadUint32(&o.SCTCAP[idx].Reg)&^(0xffff0000)|value<<16)
}
func (o *SCT_Type) GetSCTCAP_CAPn_H(idx int) uint32 {
	return (volatile.LoadUint32(&o.SCTCAP[idx].Reg) & 0xffff0000) >> 16
}

// SCT.SCTCAPCTRL: SCT capture control register
func (o *SCT_Type) SetSCTCAPCTRL_CAPCONn_L(idx int, value uint32) {
	volatile.StoreUint32(&o.SCTCAPCTRL[idx].Reg, volatile.LoadUint32(&o.SCTCAPCTRL[idx].Reg)&^(0xffff)|value)
}
func (o *SCT_Type) GetSCTCAPCTRL_CAPCONn_L(idx int) uint32 {
	return volatile.LoadUint32(&o.SCTCAPCTRL[idx].Reg) & 0xffff
}
func (o *SCT_Type) SetSCTCAPCTRL_CAPCONn_H(idx int, value uint32) {
	volatile.StoreUint32(&o.SCTCAPCTRL[idx].Reg, volatile.LoadUint32(&o.SCTCAPCTRL[idx].Reg)&^(0xffff0000)|value<<16)
}
func (o *SCT_Type) GetSCTCAPCTRL_CAPCONn_H(idx int) uint32 {
	return (volatile.LoadUint32(&o.SCTCAPCTRL[idx].Reg) & 0xffff0000) >> 16
}

// no description available
type SCT_EVENT_Type struct {
	STATE volatile.Register32 // 0x300
	CTRL  volatile.Register32 // 0x304
}

// SCT_EVENT.STATE: SCT event state register 0
func (o *SCT_EVENT_Type) SetSTATE_STATEMSKn(value uint32) {
	volatile.StoreUint32(&o.STATE.Reg, volatile.LoadUint32(&o.STATE.Reg)&^(0xffff)|value)
}
func (o *SCT_EVENT_Type) GetSTATE_STATEMSKn() uint32 {
	return volatile.LoadUint32(&o.STATE.Reg) & 0xffff
}

// SCT_EVENT.CTRL: SCT event control register 0
func (o *SCT_EVENT_Type) SetCTRL_MATCHSEL(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0xf)|value)
}
func (o *SCT_EVENT_Type) GetCTRL_MATCHSEL() uint32 {
	return volatile.LoadUint32(&o.CTRL.Reg) & 0xf
}
func (o *SCT_EVENT_Type) SetCTRL_HEVENT(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x10)|value<<4)
}
func (o *SCT_EVENT_Type) GetCTRL_HEVENT() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x10) >> 4
}
func (o *SCT_EVENT_Type) SetCTRL_OUTSEL(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x20)|value<<5)
}
func (o *SCT_EVENT_Type) GetCTRL_OUTSEL() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x20) >> 5
}
func (o *SCT_EVENT_Type) SetCTRL_IOSEL(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x3c0)|value<<6)
}
func (o *SCT_EVENT_Type) GetCTRL_IOSEL() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x3c0) >> 6
}
func (o *SCT_EVENT_Type) SetCTRL_IOCOND(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0xc00)|value<<10)
}
func (o *SCT_EVENT_Type) GetCTRL_IOCOND() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0xc00) >> 10
}
func (o *SCT_EVENT_Type) SetCTRL_COMBMODE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x3000)|value<<12)
}
func (o *SCT_EVENT_Type) GetCTRL_COMBMODE() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x3000) >> 12
}
func (o *SCT_EVENT_Type) SetCTRL_STATELD(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x4000)|value<<14)
}
func (o *SCT_EVENT_Type) GetCTRL_STATELD() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x4000) >> 14
}
func (o *SCT_EVENT_Type) SetCTRL_STATEV(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0xf8000)|value<<15)
}
func (o *SCT_EVENT_Type) GetCTRL_STATEV() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0xf8000) >> 15
}
func (o *SCT_EVENT_Type) SetCTRL_MATCHMEM(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x100000)|value<<20)
}
func (o *SCT_EVENT_Type) GetCTRL_MATCHMEM() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x100000) >> 20
}
func (o *SCT_EVENT_Type) SetCTRL_DIRECTION(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x600000)|value<<21)
}
func (o *SCT_EVENT_Type) GetCTRL_DIRECTION() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x600000) >> 21
}

// no description available
type SCT_OUT_Type struct {
	SET volatile.Register32 // 0x500
	CLR volatile.Register32 // 0x504
}

// SCT_OUT.SET: SCT output 0 set register
func (o *SCT_OUT_Type) SetSET(value uint32) {
	volatile.StoreUint32(&o.SET.Reg, volatile.LoadUint32(&o.SET.Reg)&^(0xffff)|value)
}
func (o *SCT_OUT_Type) GetSET() uint32 {
	return volatile.LoadUint32(&o.SET.Reg) & 0xffff
}

// SCT_OUT.CLR: SCT output 0 clear register
func (o *SCT_OUT_Type) SetCLR(value uint32) {
	volatile.StoreUint32(&o.CLR.Reg, volatile.LoadUint32(&o.CLR.Reg)&^(0xffff)|value)
}
func (o *SCT_OUT_Type) GetCLR() uint32 {
	return volatile.LoadUint32(&o.CLR.Reg) & 0xffff
}

// i2c
type I2C_Type struct {
	_        [2048]byte
	CFG      volatile.Register32 // 0x800
	STAT     volatile.Register32 // 0x804
	INTENSET volatile.Register32 // 0x808
	INTENCLR volatile.Register32 // 0x80C
	TIMEOUT  volatile.Register32 // 0x810
	CLKDIV   volatile.Register32 // 0x814
	INTSTAT  volatile.Register32 // 0x818
	_        [4]byte
	MSTCTL   volatile.Register32 // 0x820
	MSTTIME  volatile.Register32 // 0x824
	MSTDAT   volatile.Register32 // 0x828
	_        [20]byte
	SLVCTL   volatile.Register32    // 0x840
	SLVDAT   volatile.Register32    // 0x844
	SLVADR   [4]volatile.Register32 // 0x848
	SLVQUAL0 volatile.Register32    // 0x858
	_        [36]byte
	MONRXDAT volatile.Register32 // 0x880
	_        [1912]byte
	ID       volatile.Register32 // 0xFFC
}

// I2C.CFG: Configuration for shared functions.
func (o *I2C_Type) SetCFG_MSTEN(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0x1)|value)
}
func (o *I2C_Type) GetCFG_MSTEN() uint32 {
	return volatile.LoadUint32(&o.CFG.Reg) & 0x1
}
func (o *I2C_Type) SetCFG_SLVEN(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0x2)|value<<1)
}
func (o *I2C_Type) GetCFG_SLVEN() uint32 {
	return (volatile.LoadUint32(&o.CFG.Reg) & 0x2) >> 1
}
func (o *I2C_Type) SetCFG_MONEN(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0x4)|value<<2)
}
func (o *I2C_Type) GetCFG_MONEN() uint32 {
	return (volatile.LoadUint32(&o.CFG.Reg) & 0x4) >> 2
}
func (o *I2C_Type) SetCFG_TIMEOUTEN(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0x8)|value<<3)
}
func (o *I2C_Type) GetCFG_TIMEOUTEN() uint32 {
	return (volatile.LoadUint32(&o.CFG.Reg) & 0x8) >> 3
}
func (o *I2C_Type) SetCFG_MONCLKSTR(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0x10)|value<<4)
}
func (o *I2C_Type) GetCFG_MONCLKSTR() uint32 {
	return (volatile.LoadUint32(&o.CFG.Reg) & 0x10) >> 4
}

// I2C.STAT: Status register for Master, Slave, and Monitor functions.
func (o *I2C_Type) SetSTAT_MSTPENDING(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x1)|value)
}
func (o *I2C_Type) GetSTAT_MSTPENDING() uint32 {
	return volatile.LoadUint32(&o.STAT.Reg) & 0x1
}
func (o *I2C_Type) SetSTAT_MSTSTATE(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0xe)|value<<1)
}
func (o *I2C_Type) GetSTAT_MSTSTATE() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0xe) >> 1
}
func (o *I2C_Type) SetSTAT_MSTARBLOSS(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x10)|value<<4)
}
func (o *I2C_Type) GetSTAT_MSTARBLOSS() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x10) >> 4
}
func (o *I2C_Type) SetSTAT_MSTSTSTPERR(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x40)|value<<6)
}
func (o *I2C_Type) GetSTAT_MSTSTSTPERR() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x40) >> 6
}
func (o *I2C_Type) SetSTAT_SLVPENDING(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x100)|value<<8)
}
func (o *I2C_Type) GetSTAT_SLVPENDING() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x100) >> 8
}
func (o *I2C_Type) SetSTAT_SLVSTATE(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x600)|value<<9)
}
func (o *I2C_Type) GetSTAT_SLVSTATE() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x600) >> 9
}
func (o *I2C_Type) SetSTAT_SLVNOTSTR(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x800)|value<<11)
}
func (o *I2C_Type) GetSTAT_SLVNOTSTR() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x800) >> 11
}
func (o *I2C_Type) SetSTAT_SLVIDX(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x3000)|value<<12)
}
func (o *I2C_Type) GetSTAT_SLVIDX() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x3000) >> 12
}
func (o *I2C_Type) SetSTAT_SLVSEL(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x4000)|value<<14)
}
func (o *I2C_Type) GetSTAT_SLVSEL() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x4000) >> 14
}
func (o *I2C_Type) SetSTAT_SLVDESEL(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x8000)|value<<15)
}
func (o *I2C_Type) GetSTAT_SLVDESEL() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x8000) >> 15
}
func (o *I2C_Type) SetSTAT_MONRDY(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x10000)|value<<16)
}
func (o *I2C_Type) GetSTAT_MONRDY() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x10000) >> 16
}
func (o *I2C_Type) SetSTAT_MONOV(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x20000)|value<<17)
}
func (o *I2C_Type) GetSTAT_MONOV() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x20000) >> 17
}
func (o *I2C_Type) SetSTAT_MONACTIVE(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x40000)|value<<18)
}
func (o *I2C_Type) GetSTAT_MONACTIVE() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x40000) >> 18
}
func (o *I2C_Type) SetSTAT_MONIDLE(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x80000)|value<<19)
}
func (o *I2C_Type) GetSTAT_MONIDLE() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x80000) >> 19
}
func (o *I2C_Type) SetSTAT_EVENTTIMEOUT(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x1000000)|value<<24)
}
func (o *I2C_Type) GetSTAT_EVENTTIMEOUT() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x1000000) >> 24
}
func (o *I2C_Type) SetSTAT_SCLTIMEOUT(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x2000000)|value<<25)
}
func (o *I2C_Type) GetSTAT_SCLTIMEOUT() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x2000000) >> 25
}

// I2C.INTENSET: Interrupt Enable Set and read register.
func (o *I2C_Type) SetINTENSET_MSTPENDINGEN(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *I2C_Type) GetINTENSET_MSTPENDINGEN() uint32 {
	return volatile.LoadUint32(&o.INTENSET.Reg) & 0x1
}
func (o *I2C_Type) SetINTENSET_MSTARBLOSSEN(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x10)|value<<4)
}
func (o *I2C_Type) GetINTENSET_MSTARBLOSSEN() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x10) >> 4
}
func (o *I2C_Type) SetINTENSET_MSTSTSTPERREN(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x40)|value<<6)
}
func (o *I2C_Type) GetINTENSET_MSTSTSTPERREN() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x40) >> 6
}
func (o *I2C_Type) SetINTENSET_SLVPENDINGEN(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x100)|value<<8)
}
func (o *I2C_Type) GetINTENSET_SLVPENDINGEN() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x100) >> 8
}
func (o *I2C_Type) SetINTENSET_SLVNOTSTREN(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x800)|value<<11)
}
func (o *I2C_Type) GetINTENSET_SLVNOTSTREN() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x800) >> 11
}
func (o *I2C_Type) SetINTENSET_SLVDESELEN(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x8000)|value<<15)
}
func (o *I2C_Type) GetINTENSET_SLVDESELEN() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x8000) >> 15
}
func (o *I2C_Type) SetINTENSET_MONRDYEN(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x10000)|value<<16)
}
func (o *I2C_Type) GetINTENSET_MONRDYEN() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x10000) >> 16
}
func (o *I2C_Type) SetINTENSET_MONOVEN(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x20000)|value<<17)
}
func (o *I2C_Type) GetINTENSET_MONOVEN() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x20000) >> 17
}
func (o *I2C_Type) SetINTENSET_MONIDLEEN(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x80000)|value<<19)
}
func (o *I2C_Type) GetINTENSET_MONIDLEEN() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x80000) >> 19
}
func (o *I2C_Type) SetINTENSET_EVENTTIMEOUTEN(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1000000)|value<<24)
}
func (o *I2C_Type) GetINTENSET_EVENTTIMEOUTEN() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x1000000) >> 24
}
func (o *I2C_Type) SetINTENSET_SCLTIMEOUTEN(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2000000)|value<<25)
}
func (o *I2C_Type) GetINTENSET_SCLTIMEOUTEN() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2000000) >> 25
}

// I2C.INTENCLR: Interrupt Enable Clear register.
func (o *I2C_Type) SetINTENCLR_MSTPENDINGCLR(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *I2C_Type) GetINTENCLR_MSTPENDINGCLR() uint32 {
	return volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1
}
func (o *I2C_Type) SetINTENCLR_MSTARBLOSSCLR(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x10)|value<<4)
}
func (o *I2C_Type) GetINTENCLR_MSTARBLOSSCLR() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x10) >> 4
}
func (o *I2C_Type) SetINTENCLR_MSTSTSTPERRCLR(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x40)|value<<6)
}
func (o *I2C_Type) GetINTENCLR_MSTSTSTPERRCLR() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x40) >> 6
}
func (o *I2C_Type) SetINTENCLR_SLVPENDINGCLR(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x100)|value<<8)
}
func (o *I2C_Type) GetINTENCLR_SLVPENDINGCLR() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x100) >> 8
}
func (o *I2C_Type) SetINTENCLR_SLVNOTSTRCLR(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x800)|value<<11)
}
func (o *I2C_Type) GetINTENCLR_SLVNOTSTRCLR() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x800) >> 11
}
func (o *I2C_Type) SetINTENCLR_SLVDESELCLR(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x8000)|value<<15)
}
func (o *I2C_Type) GetINTENCLR_SLVDESELCLR() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x8000) >> 15
}
func (o *I2C_Type) SetINTENCLR_MONRDYCLR(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x10000)|value<<16)
}
func (o *I2C_Type) GetINTENCLR_MONRDYCLR() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x10000) >> 16
}
func (o *I2C_Type) SetINTENCLR_MONOVCLR(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x20000)|value<<17)
}
func (o *I2C_Type) GetINTENCLR_MONOVCLR() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x20000) >> 17
}
func (o *I2C_Type) SetINTENCLR_MONIDLECLR(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x80000)|value<<19)
}
func (o *I2C_Type) GetINTENCLR_MONIDLECLR() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x80000) >> 19
}
func (o *I2C_Type) SetINTENCLR_EVENTTIMEOUTCLR(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1000000)|value<<24)
}
func (o *I2C_Type) GetINTENCLR_EVENTTIMEOUTCLR() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1000000) >> 24
}
func (o *I2C_Type) SetINTENCLR_SCLTIMEOUTCLR(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2000000)|value<<25)
}
func (o *I2C_Type) GetINTENCLR_SCLTIMEOUTCLR() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2000000) >> 25
}

// I2C.TIMEOUT: Time-out value register.
func (o *I2C_Type) SetTIMEOUT_TOMIN(value uint32) {
	volatile.StoreUint32(&o.TIMEOUT.Reg, volatile.LoadUint32(&o.TIMEOUT.Reg)&^(0xf)|value)
}
func (o *I2C_Type) GetTIMEOUT_TOMIN() uint32 {
	return volatile.LoadUint32(&o.TIMEOUT.Reg) & 0xf
}
func (o *I2C_Type) SetTIMEOUT_TO(value uint32) {
	volatile.StoreUint32(&o.TIMEOUT.Reg, volatile.LoadUint32(&o.TIMEOUT.Reg)&^(0xfff0)|value<<4)
}
func (o *I2C_Type) GetTIMEOUT_TO() uint32 {
	return (volatile.LoadUint32(&o.TIMEOUT.Reg) & 0xfff0) >> 4
}

// I2C.CLKDIV: Clock pre-divider for the entire I2C interface. This determines what time increments are used for the MSTTIME register, and controls some timing of the Slave function.
func (o *I2C_Type) SetCLKDIV_DIVVAL(value uint32) {
	volatile.StoreUint32(&o.CLKDIV.Reg, volatile.LoadUint32(&o.CLKDIV.Reg)&^(0xffff)|value)
}
func (o *I2C_Type) GetCLKDIV_DIVVAL() uint32 {
	return volatile.LoadUint32(&o.CLKDIV.Reg) & 0xffff
}

// I2C.INTSTAT: Interrupt Status register for Master, Slave, and Monitor functions.
func (o *I2C_Type) SetINTSTAT_MSTPENDING(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x1)|value)
}
func (o *I2C_Type) GetINTSTAT_MSTPENDING() uint32 {
	return volatile.LoadUint32(&o.INTSTAT.Reg) & 0x1
}
func (o *I2C_Type) SetINTSTAT_MSTARBLOSS(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x10)|value<<4)
}
func (o *I2C_Type) GetINTSTAT_MSTARBLOSS() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x10) >> 4
}
func (o *I2C_Type) SetINTSTAT_MSTSTSTPERR(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x40)|value<<6)
}
func (o *I2C_Type) GetINTSTAT_MSTSTSTPERR() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x40) >> 6
}
func (o *I2C_Type) SetINTSTAT_SLVPENDING(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x100)|value<<8)
}
func (o *I2C_Type) GetINTSTAT_SLVPENDING() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x100) >> 8
}
func (o *I2C_Type) SetINTSTAT_SLVNOTSTR(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x800)|value<<11)
}
func (o *I2C_Type) GetINTSTAT_SLVNOTSTR() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x800) >> 11
}
func (o *I2C_Type) SetINTSTAT_SLVDESEL(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x8000)|value<<15)
}
func (o *I2C_Type) GetINTSTAT_SLVDESEL() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x8000) >> 15
}
func (o *I2C_Type) SetINTSTAT_MONRDY(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x10000)|value<<16)
}
func (o *I2C_Type) GetINTSTAT_MONRDY() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x10000) >> 16
}
func (o *I2C_Type) SetINTSTAT_MONOV(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x20000)|value<<17)
}
func (o *I2C_Type) GetINTSTAT_MONOV() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x20000) >> 17
}
func (o *I2C_Type) SetINTSTAT_MONIDLE(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x80000)|value<<19)
}
func (o *I2C_Type) GetINTSTAT_MONIDLE() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x80000) >> 19
}
func (o *I2C_Type) SetINTSTAT_EVENTTIMEOUT(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x1000000)|value<<24)
}
func (o *I2C_Type) GetINTSTAT_EVENTTIMEOUT() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x1000000) >> 24
}
func (o *I2C_Type) SetINTSTAT_SCLTIMEOUT(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x2000000)|value<<25)
}
func (o *I2C_Type) GetINTSTAT_SCLTIMEOUT() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x2000000) >> 25
}

// I2C.MSTCTL: Master control register.
func (o *I2C_Type) SetMSTCTL_MSTCONTINUE(value uint32) {
	volatile.StoreUint32(&o.MSTCTL.Reg, volatile.LoadUint32(&o.MSTCTL.Reg)&^(0x1)|value)
}
func (o *I2C_Type) GetMSTCTL_MSTCONTINUE() uint32 {
	return volatile.LoadUint32(&o.MSTCTL.Reg) & 0x1
}
func (o *I2C_Type) SetMSTCTL_MSTSTART(value uint32) {
	volatile.StoreUint32(&o.MSTCTL.Reg, volatile.LoadUint32(&o.MSTCTL.Reg)&^(0x2)|value<<1)
}
func (o *I2C_Type) GetMSTCTL_MSTSTART() uint32 {
	return (volatile.LoadUint32(&o.MSTCTL.Reg) & 0x2) >> 1
}
func (o *I2C_Type) SetMSTCTL_MSTSTOP(value uint32) {
	volatile.StoreUint32(&o.MSTCTL.Reg, volatile.LoadUint32(&o.MSTCTL.Reg)&^(0x4)|value<<2)
}
func (o *I2C_Type) GetMSTCTL_MSTSTOP() uint32 {
	return (volatile.LoadUint32(&o.MSTCTL.Reg) & 0x4) >> 2
}
func (o *I2C_Type) SetMSTCTL_MSTDMA(value uint32) {
	volatile.StoreUint32(&o.MSTCTL.Reg, volatile.LoadUint32(&o.MSTCTL.Reg)&^(0x8)|value<<3)
}
func (o *I2C_Type) GetMSTCTL_MSTDMA() uint32 {
	return (volatile.LoadUint32(&o.MSTCTL.Reg) & 0x8) >> 3
}

// I2C.MSTTIME: Master timing configuration.
func (o *I2C_Type) SetMSTTIME_MSTSCLLOW(value uint32) {
	volatile.StoreUint32(&o.MSTTIME.Reg, volatile.LoadUint32(&o.MSTTIME.Reg)&^(0x7)|value)
}
func (o *I2C_Type) GetMSTTIME_MSTSCLLOW() uint32 {
	return volatile.LoadUint32(&o.MSTTIME.Reg) & 0x7
}
func (o *I2C_Type) SetMSTTIME_MSTSCLHIGH(value uint32) {
	volatile.StoreUint32(&o.MSTTIME.Reg, volatile.LoadUint32(&o.MSTTIME.Reg)&^(0x70)|value<<4)
}
func (o *I2C_Type) GetMSTTIME_MSTSCLHIGH() uint32 {
	return (volatile.LoadUint32(&o.MSTTIME.Reg) & 0x70) >> 4
}

// I2C.MSTDAT: Combined Master receiver and transmitter data register.
func (o *I2C_Type) SetMSTDAT_DATA(value uint32) {
	volatile.StoreUint32(&o.MSTDAT.Reg, volatile.LoadUint32(&o.MSTDAT.Reg)&^(0xff)|value)
}
func (o *I2C_Type) GetMSTDAT_DATA() uint32 {
	return volatile.LoadUint32(&o.MSTDAT.Reg) & 0xff
}

// I2C.SLVCTL: Slave control register.
func (o *I2C_Type) SetSLVCTL_SLVCONTINUE(value uint32) {
	volatile.StoreUint32(&o.SLVCTL.Reg, volatile.LoadUint32(&o.SLVCTL.Reg)&^(0x1)|value)
}
func (o *I2C_Type) GetSLVCTL_SLVCONTINUE() uint32 {
	return volatile.LoadUint32(&o.SLVCTL.Reg) & 0x1
}
func (o *I2C_Type) SetSLVCTL_SLVNACK(value uint32) {
	volatile.StoreUint32(&o.SLVCTL.Reg, volatile.LoadUint32(&o.SLVCTL.Reg)&^(0x2)|value<<1)
}
func (o *I2C_Type) GetSLVCTL_SLVNACK() uint32 {
	return (volatile.LoadUint32(&o.SLVCTL.Reg) & 0x2) >> 1
}
func (o *I2C_Type) SetSLVCTL_SLVDMA(value uint32) {
	volatile.StoreUint32(&o.SLVCTL.Reg, volatile.LoadUint32(&o.SLVCTL.Reg)&^(0x8)|value<<3)
}
func (o *I2C_Type) GetSLVCTL_SLVDMA() uint32 {
	return (volatile.LoadUint32(&o.SLVCTL.Reg) & 0x8) >> 3
}
func (o *I2C_Type) SetSLVCTL_AUTOACK(value uint32) {
	volatile.StoreUint32(&o.SLVCTL.Reg, volatile.LoadUint32(&o.SLVCTL.Reg)&^(0x100)|value<<8)
}
func (o *I2C_Type) GetSLVCTL_AUTOACK() uint32 {
	return (volatile.LoadUint32(&o.SLVCTL.Reg) & 0x100) >> 8
}
func (o *I2C_Type) SetSLVCTL_AUTOMATCHREAD(value uint32) {
	volatile.StoreUint32(&o.SLVCTL.Reg, volatile.LoadUint32(&o.SLVCTL.Reg)&^(0x200)|value<<9)
}
func (o *I2C_Type) GetSLVCTL_AUTOMATCHREAD() uint32 {
	return (volatile.LoadUint32(&o.SLVCTL.Reg) & 0x200) >> 9
}

// I2C.SLVDAT: Combined Slave receiver and transmitter data register.
func (o *I2C_Type) SetSLVDAT_DATA(value uint32) {
	volatile.StoreUint32(&o.SLVDAT.Reg, volatile.LoadUint32(&o.SLVDAT.Reg)&^(0xff)|value)
}
func (o *I2C_Type) GetSLVDAT_DATA() uint32 {
	return volatile.LoadUint32(&o.SLVDAT.Reg) & 0xff
}

// I2C.SLVADR: Slave address register.
func (o *I2C_Type) SetSLVADR_SADISABLE(idx int, value uint32) {
	volatile.StoreUint32(&o.SLVADR[idx].Reg, volatile.LoadUint32(&o.SLVADR[idx].Reg)&^(0x1)|value)
}
func (o *I2C_Type) GetSLVADR_SADISABLE(idx int) uint32 {
	return volatile.LoadUint32(&o.SLVADR[idx].Reg) & 0x1
}
func (o *I2C_Type) SetSLVADR(idx int, value uint32) {
	volatile.StoreUint32(&o.SLVADR[idx].Reg, volatile.LoadUint32(&o.SLVADR[idx].Reg)&^(0xfe)|value<<1)
}
func (o *I2C_Type) GetSLVADR(idx int) uint32 {
	return (volatile.LoadUint32(&o.SLVADR[idx].Reg) & 0xfe) >> 1
}
func (o *I2C_Type) SetSLVADR_AUTONACK(idx int, value uint32) {
	volatile.StoreUint32(&o.SLVADR[idx].Reg, volatile.LoadUint32(&o.SLVADR[idx].Reg)&^(0x8000)|value<<15)
}
func (o *I2C_Type) GetSLVADR_AUTONACK(idx int) uint32 {
	return (volatile.LoadUint32(&o.SLVADR[idx].Reg) & 0x8000) >> 15
}

// I2C.SLVQUAL0: Slave Qualification for address 0.
func (o *I2C_Type) SetSLVQUAL0_QUALMODE0(value uint32) {
	volatile.StoreUint32(&o.SLVQUAL0.Reg, volatile.LoadUint32(&o.SLVQUAL0.Reg)&^(0x1)|value)
}
func (o *I2C_Type) GetSLVQUAL0_QUALMODE0() uint32 {
	return volatile.LoadUint32(&o.SLVQUAL0.Reg) & 0x1
}
func (o *I2C_Type) SetSLVQUAL0(value uint32) {
	volatile.StoreUint32(&o.SLVQUAL0.Reg, volatile.LoadUint32(&o.SLVQUAL0.Reg)&^(0xfe)|value<<1)
}
func (o *I2C_Type) GetSLVQUAL0() uint32 {
	return (volatile.LoadUint32(&o.SLVQUAL0.Reg) & 0xfe) >> 1
}

// I2C.MONRXDAT: Monitor receiver data register.
func (o *I2C_Type) SetMONRXDAT(value uint32) {
	volatile.StoreUint32(&o.MONRXDAT.Reg, volatile.LoadUint32(&o.MONRXDAT.Reg)&^(0xff)|value)
}
func (o *I2C_Type) GetMONRXDAT() uint32 {
	return volatile.LoadUint32(&o.MONRXDAT.Reg) & 0xff
}
func (o *I2C_Type) SetMONRXDAT_MONSTART(value uint32) {
	volatile.StoreUint32(&o.MONRXDAT.Reg, volatile.LoadUint32(&o.MONRXDAT.Reg)&^(0x100)|value<<8)
}
func (o *I2C_Type) GetMONRXDAT_MONSTART() uint32 {
	return (volatile.LoadUint32(&o.MONRXDAT.Reg) & 0x100) >> 8
}
func (o *I2C_Type) SetMONRXDAT_MONRESTART(value uint32) {
	volatile.StoreUint32(&o.MONRXDAT.Reg, volatile.LoadUint32(&o.MONRXDAT.Reg)&^(0x200)|value<<9)
}
func (o *I2C_Type) GetMONRXDAT_MONRESTART() uint32 {
	return (volatile.LoadUint32(&o.MONRXDAT.Reg) & 0x200) >> 9
}
func (o *I2C_Type) SetMONRXDAT_MONNACK(value uint32) {
	volatile.StoreUint32(&o.MONRXDAT.Reg, volatile.LoadUint32(&o.MONRXDAT.Reg)&^(0x400)|value<<10)
}
func (o *I2C_Type) GetMONRXDAT_MONNACK() uint32 {
	return (volatile.LoadUint32(&o.MONRXDAT.Reg) & 0x400) >> 10
}

// I2C.ID: I2C module Identification. This value appears in the shared Flexcomm peripheral ID register when I2C is selected.
func (o *I2C_Type) SetID_APERTURE(value uint32) {
	volatile.StoreUint32(&o.ID.Reg, volatile.LoadUint32(&o.ID.Reg)&^(0xff)|value)
}
func (o *I2C_Type) GetID_APERTURE() uint32 {
	return volatile.LoadUint32(&o.ID.Reg) & 0xff
}
func (o *I2C_Type) SetID_MINOR_REV(value uint32) {
	volatile.StoreUint32(&o.ID.Reg, volatile.LoadUint32(&o.ID.Reg)&^(0xf00)|value<<8)
}
func (o *I2C_Type) GetID_MINOR_REV() uint32 {
	return (volatile.LoadUint32(&o.ID.Reg) & 0xf00) >> 8
}
func (o *I2C_Type) SetID_MAJOR_REV(value uint32) {
	volatile.StoreUint32(&o.ID.Reg, volatile.LoadUint32(&o.ID.Reg)&^(0xf000)|value<<12)
}
func (o *I2C_Type) GetID_MAJOR_REV() uint32 {
	return (volatile.LoadUint32(&o.ID.Reg) & 0xf000) >> 12
}
func (o *I2C_Type) SetID(value uint32) {
	volatile.StoreUint32(&o.ID.Reg, volatile.LoadUint32(&o.ID.Reg)&^(0xffff0000)|value<<16)
}
func (o *I2C_Type) GetID() uint32 {
	return (volatile.LoadUint32(&o.ID.Reg) & 0xffff0000) >> 16
}

// spi
type SPI_Type struct {
	_            [1024]byte
	CFG          volatile.Register32 // 0x400
	DLY          volatile.Register32 // 0x404
	STAT         volatile.Register32 // 0x408
	INTENSET     volatile.Register32 // 0x40C
	INTENCLR     volatile.Register32 // 0x410
	_            [16]byte
	DIV          volatile.Register32 // 0x424
	INTSTAT      volatile.Register32 // 0x428
	_            [2516]byte
	FIFOCFG      volatile.Register32 // 0xE00
	FIFOSTAT     volatile.Register32 // 0xE04
	FIFOTRIG     volatile.Register32 // 0xE08
	_            [4]byte
	FIFOINTENSET volatile.Register32 // 0xE10
	FIFOINTENCLR volatile.Register32 // 0xE14
	FIFOINTSTAT  volatile.Register32 // 0xE18
	_            [4]byte
	FIFOWR       volatile.Register32 // 0xE20
	_            [12]byte
	FIFORD       volatile.Register32 // 0xE30
	_            [12]byte
	FIFORDNOPOP  volatile.Register32 // 0xE40
	_            [440]byte
	ID           volatile.Register32 // 0xFFC
}

// SPI.CFG: SPI Configuration register
func (o *SPI_Type) SetCFG_ENABLE(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0x1)|value)
}
func (o *SPI_Type) GetCFG_ENABLE() uint32 {
	return volatile.LoadUint32(&o.CFG.Reg) & 0x1
}
func (o *SPI_Type) SetCFG_MASTER(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0x4)|value<<2)
}
func (o *SPI_Type) GetCFG_MASTER() uint32 {
	return (volatile.LoadUint32(&o.CFG.Reg) & 0x4) >> 2
}
func (o *SPI_Type) SetCFG_LSBF(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0x8)|value<<3)
}
func (o *SPI_Type) GetCFG_LSBF() uint32 {
	return (volatile.LoadUint32(&o.CFG.Reg) & 0x8) >> 3
}
func (o *SPI_Type) SetCFG_CPHA(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0x10)|value<<4)
}
func (o *SPI_Type) GetCFG_CPHA() uint32 {
	return (volatile.LoadUint32(&o.CFG.Reg) & 0x10) >> 4
}
func (o *SPI_Type) SetCFG_CPOL(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0x20)|value<<5)
}
func (o *SPI_Type) GetCFG_CPOL() uint32 {
	return (volatile.LoadUint32(&o.CFG.Reg) & 0x20) >> 5
}
func (o *SPI_Type) SetCFG_LOOP(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0x80)|value<<7)
}
func (o *SPI_Type) GetCFG_LOOP() uint32 {
	return (volatile.LoadUint32(&o.CFG.Reg) & 0x80) >> 7
}
func (o *SPI_Type) SetCFG_SPOL0(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0x100)|value<<8)
}
func (o *SPI_Type) GetCFG_SPOL0() uint32 {
	return (volatile.LoadUint32(&o.CFG.Reg) & 0x100) >> 8
}
func (o *SPI_Type) SetCFG_SPOL1(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0x200)|value<<9)
}
func (o *SPI_Type) GetCFG_SPOL1() uint32 {
	return (volatile.LoadUint32(&o.CFG.Reg) & 0x200) >> 9
}
func (o *SPI_Type) SetCFG_SPOL2(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0x400)|value<<10)
}
func (o *SPI_Type) GetCFG_SPOL2() uint32 {
	return (volatile.LoadUint32(&o.CFG.Reg) & 0x400) >> 10
}
func (o *SPI_Type) SetCFG_SPOL3(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0x800)|value<<11)
}
func (o *SPI_Type) GetCFG_SPOL3() uint32 {
	return (volatile.LoadUint32(&o.CFG.Reg) & 0x800) >> 11
}

// SPI.DLY: SPI Delay register
func (o *SPI_Type) SetDLY_PRE_DELAY(value uint32) {
	volatile.StoreUint32(&o.DLY.Reg, volatile.LoadUint32(&o.DLY.Reg)&^(0xf)|value)
}
func (o *SPI_Type) GetDLY_PRE_DELAY() uint32 {
	return volatile.LoadUint32(&o.DLY.Reg) & 0xf
}
func (o *SPI_Type) SetDLY_POST_DELAY(value uint32) {
	volatile.StoreUint32(&o.DLY.Reg, volatile.LoadUint32(&o.DLY.Reg)&^(0xf0)|value<<4)
}
func (o *SPI_Type) GetDLY_POST_DELAY() uint32 {
	return (volatile.LoadUint32(&o.DLY.Reg) & 0xf0) >> 4
}
func (o *SPI_Type) SetDLY_FRAME_DELAY(value uint32) {
	volatile.StoreUint32(&o.DLY.Reg, volatile.LoadUint32(&o.DLY.Reg)&^(0xf00)|value<<8)
}
func (o *SPI_Type) GetDLY_FRAME_DELAY() uint32 {
	return (volatile.LoadUint32(&o.DLY.Reg) & 0xf00) >> 8
}
func (o *SPI_Type) SetDLY_TRANSFER_DELAY(value uint32) {
	volatile.StoreUint32(&o.DLY.Reg, volatile.LoadUint32(&o.DLY.Reg)&^(0xf000)|value<<12)
}
func (o *SPI_Type) GetDLY_TRANSFER_DELAY() uint32 {
	return (volatile.LoadUint32(&o.DLY.Reg) & 0xf000) >> 12
}

// SPI.STAT: SPI Status. Some status flags can be cleared by writing a 1 to that bit position.
func (o *SPI_Type) SetSTAT_SSA(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x10)|value<<4)
}
func (o *SPI_Type) GetSTAT_SSA() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x10) >> 4
}
func (o *SPI_Type) SetSTAT_SSD(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x20)|value<<5)
}
func (o *SPI_Type) GetSTAT_SSD() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x20) >> 5
}
func (o *SPI_Type) SetSTAT_STALLED(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x40)|value<<6)
}
func (o *SPI_Type) GetSTAT_STALLED() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x40) >> 6
}
func (o *SPI_Type) SetSTAT_ENDTRANSFER(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x80)|value<<7)
}
func (o *SPI_Type) GetSTAT_ENDTRANSFER() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x80) >> 7
}
func (o *SPI_Type) SetSTAT_MSTIDLE(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x100)|value<<8)
}
func (o *SPI_Type) GetSTAT_MSTIDLE() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x100) >> 8
}

// SPI.INTENSET: SPI Interrupt Enable read and Set. A complete value may be read from this register. Writing a 1 to any implemented bit position causes that bit to be set.
func (o *SPI_Type) SetINTENSET_SSAEN(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x10)|value<<4)
}
func (o *SPI_Type) GetINTENSET_SSAEN() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x10) >> 4
}
func (o *SPI_Type) SetINTENSET_SSDEN(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x20)|value<<5)
}
func (o *SPI_Type) GetINTENSET_SSDEN() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x20) >> 5
}
func (o *SPI_Type) SetINTENSET_MSTIDLEEN(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x100)|value<<8)
}
func (o *SPI_Type) GetINTENSET_MSTIDLEEN() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x100) >> 8
}

// SPI.INTENCLR: SPI Interrupt Enable Clear. Writing a 1 to any implemented bit position causes the corresponding bit in INTENSET to be cleared.
func (o *SPI_Type) SetINTENCLR_SSAEN(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x10)|value<<4)
}
func (o *SPI_Type) GetINTENCLR_SSAEN() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x10) >> 4
}
func (o *SPI_Type) SetINTENCLR_SSDEN(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x20)|value<<5)
}
func (o *SPI_Type) GetINTENCLR_SSDEN() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x20) >> 5
}
func (o *SPI_Type) SetINTENCLR_MSTIDLE(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x100)|value<<8)
}
func (o *SPI_Type) GetINTENCLR_MSTIDLE() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x100) >> 8
}

// SPI.DIV: SPI clock Divider
func (o *SPI_Type) SetDIV_DIVVAL(value uint32) {
	volatile.StoreUint32(&o.DIV.Reg, volatile.LoadUint32(&o.DIV.Reg)&^(0xffff)|value)
}
func (o *SPI_Type) GetDIV_DIVVAL() uint32 {
	return volatile.LoadUint32(&o.DIV.Reg) & 0xffff
}

// SPI.INTSTAT: SPI Interrupt Status
func (o *SPI_Type) SetINTSTAT_SSA(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x10)|value<<4)
}
func (o *SPI_Type) GetINTSTAT_SSA() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x10) >> 4
}
func (o *SPI_Type) SetINTSTAT_SSD(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x20)|value<<5)
}
func (o *SPI_Type) GetINTSTAT_SSD() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x20) >> 5
}
func (o *SPI_Type) SetINTSTAT_MSTIDLE(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x100)|value<<8)
}
func (o *SPI_Type) GetINTSTAT_MSTIDLE() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x100) >> 8
}

// SPI.FIFOCFG: FIFO configuration and enable register.
func (o *SPI_Type) SetFIFOCFG_ENABLETX(value uint32) {
	volatile.StoreUint32(&o.FIFOCFG.Reg, volatile.LoadUint32(&o.FIFOCFG.Reg)&^(0x1)|value)
}
func (o *SPI_Type) GetFIFOCFG_ENABLETX() uint32 {
	return volatile.LoadUint32(&o.FIFOCFG.Reg) & 0x1
}
func (o *SPI_Type) SetFIFOCFG_ENABLERX(value uint32) {
	volatile.StoreUint32(&o.FIFOCFG.Reg, volatile.LoadUint32(&o.FIFOCFG.Reg)&^(0x2)|value<<1)
}
func (o *SPI_Type) GetFIFOCFG_ENABLERX() uint32 {
	return (volatile.LoadUint32(&o.FIFOCFG.Reg) & 0x2) >> 1
}
func (o *SPI_Type) SetFIFOCFG_SIZE(value uint32) {
	volatile.StoreUint32(&o.FIFOCFG.Reg, volatile.LoadUint32(&o.FIFOCFG.Reg)&^(0x30)|value<<4)
}
func (o *SPI_Type) GetFIFOCFG_SIZE() uint32 {
	return (volatile.LoadUint32(&o.FIFOCFG.Reg) & 0x30) >> 4
}
func (o *SPI_Type) SetFIFOCFG_DMATX(value uint32) {
	volatile.StoreUint32(&o.FIFOCFG.Reg, volatile.LoadUint32(&o.FIFOCFG.Reg)&^(0x1000)|value<<12)
}
func (o *SPI_Type) GetFIFOCFG_DMATX() uint32 {
	return (volatile.LoadUint32(&o.FIFOCFG.Reg) & 0x1000) >> 12
}
func (o *SPI_Type) SetFIFOCFG_DMARX(value uint32) {
	volatile.StoreUint32(&o.FIFOCFG.Reg, volatile.LoadUint32(&o.FIFOCFG.Reg)&^(0x2000)|value<<13)
}
func (o *SPI_Type) GetFIFOCFG_DMARX() uint32 {
	return (volatile.LoadUint32(&o.FIFOCFG.Reg) & 0x2000) >> 13
}
func (o *SPI_Type) SetFIFOCFG_EMPTYTX(value uint32) {
	volatile.StoreUint32(&o.FIFOCFG.Reg, volatile.LoadUint32(&o.FIFOCFG.Reg)&^(0x10000)|value<<16)
}
func (o *SPI_Type) GetFIFOCFG_EMPTYTX() uint32 {
	return (volatile.LoadUint32(&o.FIFOCFG.Reg) & 0x10000) >> 16
}
func (o *SPI_Type) SetFIFOCFG_EMPTYRX(value uint32) {
	volatile.StoreUint32(&o.FIFOCFG.Reg, volatile.LoadUint32(&o.FIFOCFG.Reg)&^(0x20000)|value<<17)
}
func (o *SPI_Type) GetFIFOCFG_EMPTYRX() uint32 {
	return (volatile.LoadUint32(&o.FIFOCFG.Reg) & 0x20000) >> 17
}

// SPI.FIFOSTAT: FIFO status register.
func (o *SPI_Type) SetFIFOSTAT_TXERR(value uint32) {
	volatile.StoreUint32(&o.FIFOSTAT.Reg, volatile.LoadUint32(&o.FIFOSTAT.Reg)&^(0x1)|value)
}
func (o *SPI_Type) GetFIFOSTAT_TXERR() uint32 {
	return volatile.LoadUint32(&o.FIFOSTAT.Reg) & 0x1
}
func (o *SPI_Type) SetFIFOSTAT_RXERR(value uint32) {
	volatile.StoreUint32(&o.FIFOSTAT.Reg, volatile.LoadUint32(&o.FIFOSTAT.Reg)&^(0x2)|value<<1)
}
func (o *SPI_Type) GetFIFOSTAT_RXERR() uint32 {
	return (volatile.LoadUint32(&o.FIFOSTAT.Reg) & 0x2) >> 1
}
func (o *SPI_Type) SetFIFOSTAT_PERINT(value uint32) {
	volatile.StoreUint32(&o.FIFOSTAT.Reg, volatile.LoadUint32(&o.FIFOSTAT.Reg)&^(0x8)|value<<3)
}
func (o *SPI_Type) GetFIFOSTAT_PERINT() uint32 {
	return (volatile.LoadUint32(&o.FIFOSTAT.Reg) & 0x8) >> 3
}
func (o *SPI_Type) SetFIFOSTAT_TXEMPTY(value uint32) {
	volatile.StoreUint32(&o.FIFOSTAT.Reg, volatile.LoadUint32(&o.FIFOSTAT.Reg)&^(0x10)|value<<4)
}
func (o *SPI_Type) GetFIFOSTAT_TXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.FIFOSTAT.Reg) & 0x10) >> 4
}
func (o *SPI_Type) SetFIFOSTAT_TXNOTFULL(value uint32) {
	volatile.StoreUint32(&o.FIFOSTAT.Reg, volatile.LoadUint32(&o.FIFOSTAT.Reg)&^(0x20)|value<<5)
}
func (o *SPI_Type) GetFIFOSTAT_TXNOTFULL() uint32 {
	return (volatile.LoadUint32(&o.FIFOSTAT.Reg) & 0x20) >> 5
}
func (o *SPI_Type) SetFIFOSTAT_RXNOTEMPTY(value uint32) {
	volatile.StoreUint32(&o.FIFOSTAT.Reg, volatile.LoadUint32(&o.FIFOSTAT.Reg)&^(0x40)|value<<6)
}
func (o *SPI_Type) GetFIFOSTAT_RXNOTEMPTY() uint32 {
	return (volatile.LoadUint32(&o.FIFOSTAT.Reg) & 0x40) >> 6
}
func (o *SPI_Type) SetFIFOSTAT_RXFULL(value uint32) {
	volatile.StoreUint32(&o.FIFOSTAT.Reg, volatile.LoadUint32(&o.FIFOSTAT.Reg)&^(0x80)|value<<7)
}
func (o *SPI_Type) GetFIFOSTAT_RXFULL() uint32 {
	return (volatile.LoadUint32(&o.FIFOSTAT.Reg) & 0x80) >> 7
}
func (o *SPI_Type) SetFIFOSTAT_TXLVL(value uint32) {
	volatile.StoreUint32(&o.FIFOSTAT.Reg, volatile.LoadUint32(&o.FIFOSTAT.Reg)&^(0x1f00)|value<<8)
}
func (o *SPI_Type) GetFIFOSTAT_TXLVL() uint32 {
	return (volatile.LoadUint32(&o.FIFOSTAT.Reg) & 0x1f00) >> 8
}
func (o *SPI_Type) SetFIFOSTAT_RXLVL(value uint32) {
	volatile.StoreUint32(&o.FIFOSTAT.Reg, volatile.LoadUint32(&o.FIFOSTAT.Reg)&^(0x1f0000)|value<<16)
}
func (o *SPI_Type) GetFIFOSTAT_RXLVL() uint32 {
	return (volatile.LoadUint32(&o.FIFOSTAT.Reg) & 0x1f0000) >> 16
}

// SPI.FIFOTRIG: FIFO trigger settings for interrupt and DMA request.
func (o *SPI_Type) SetFIFOTRIG_TXLVLENA(value uint32) {
	volatile.StoreUint32(&o.FIFOTRIG.Reg, volatile.LoadUint32(&o.FIFOTRIG.Reg)&^(0x1)|value)
}
func (o *SPI_Type) GetFIFOTRIG_TXLVLENA() uint32 {
	return volatile.LoadUint32(&o.FIFOTRIG.Reg) & 0x1
}
func (o *SPI_Type) SetFIFOTRIG_RXLVLENA(value uint32) {
	volatile.StoreUint32(&o.FIFOTRIG.Reg, volatile.LoadUint32(&o.FIFOTRIG.Reg)&^(0x2)|value<<1)
}
func (o *SPI_Type) GetFIFOTRIG_RXLVLENA() uint32 {
	return (volatile.LoadUint32(&o.FIFOTRIG.Reg) & 0x2) >> 1
}
func (o *SPI_Type) SetFIFOTRIG_TXLVL(value uint32) {
	volatile.StoreUint32(&o.FIFOTRIG.Reg, volatile.LoadUint32(&o.FIFOTRIG.Reg)&^(0xf00)|value<<8)
}
func (o *SPI_Type) GetFIFOTRIG_TXLVL() uint32 {
	return (volatile.LoadUint32(&o.FIFOTRIG.Reg) & 0xf00) >> 8
}
func (o *SPI_Type) SetFIFOTRIG_RXLVL(value uint32) {
	volatile.StoreUint32(&o.FIFOTRIG.Reg, volatile.LoadUint32(&o.FIFOTRIG.Reg)&^(0xf0000)|value<<16)
}
func (o *SPI_Type) GetFIFOTRIG_RXLVL() uint32 {
	return (volatile.LoadUint32(&o.FIFOTRIG.Reg) & 0xf0000) >> 16
}

// SPI.FIFOINTENSET: FIFO interrupt enable set (enable) and read register.
func (o *SPI_Type) SetFIFOINTENSET_TXERR(value uint32) {
	volatile.StoreUint32(&o.FIFOINTENSET.Reg, volatile.LoadUint32(&o.FIFOINTENSET.Reg)&^(0x1)|value)
}
func (o *SPI_Type) GetFIFOINTENSET_TXERR() uint32 {
	return volatile.LoadUint32(&o.FIFOINTENSET.Reg) & 0x1
}
func (o *SPI_Type) SetFIFOINTENSET_RXERR(value uint32) {
	volatile.StoreUint32(&o.FIFOINTENSET.Reg, volatile.LoadUint32(&o.FIFOINTENSET.Reg)&^(0x2)|value<<1)
}
func (o *SPI_Type) GetFIFOINTENSET_RXERR() uint32 {
	return (volatile.LoadUint32(&o.FIFOINTENSET.Reg) & 0x2) >> 1
}
func (o *SPI_Type) SetFIFOINTENSET_TXLVL(value uint32) {
	volatile.StoreUint32(&o.FIFOINTENSET.Reg, volatile.LoadUint32(&o.FIFOINTENSET.Reg)&^(0x4)|value<<2)
}
func (o *SPI_Type) GetFIFOINTENSET_TXLVL() uint32 {
	return (volatile.LoadUint32(&o.FIFOINTENSET.Reg) & 0x4) >> 2
}
func (o *SPI_Type) SetFIFOINTENSET_RXLVL(value uint32) {
	volatile.StoreUint32(&o.FIFOINTENSET.Reg, volatile.LoadUint32(&o.FIFOINTENSET.Reg)&^(0x8)|value<<3)
}
func (o *SPI_Type) GetFIFOINTENSET_RXLVL() uint32 {
	return (volatile.LoadUint32(&o.FIFOINTENSET.Reg) & 0x8) >> 3
}

// SPI.FIFOINTENCLR: FIFO interrupt enable clear (disable) and read register.
func (o *SPI_Type) SetFIFOINTENCLR_TXERR(value uint32) {
	volatile.StoreUint32(&o.FIFOINTENCLR.Reg, volatile.LoadUint32(&o.FIFOINTENCLR.Reg)&^(0x1)|value)
}
func (o *SPI_Type) GetFIFOINTENCLR_TXERR() uint32 {
	return volatile.LoadUint32(&o.FIFOINTENCLR.Reg) & 0x1
}
func (o *SPI_Type) SetFIFOINTENCLR_RXERR(value uint32) {
	volatile.StoreUint32(&o.FIFOINTENCLR.Reg, volatile.LoadUint32(&o.FIFOINTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *SPI_Type) GetFIFOINTENCLR_RXERR() uint32 {
	return (volatile.LoadUint32(&o.FIFOINTENCLR.Reg) & 0x2) >> 1
}
func (o *SPI_Type) SetFIFOINTENCLR_TXLVL(value uint32) {
	volatile.StoreUint32(&o.FIFOINTENCLR.Reg, volatile.LoadUint32(&o.FIFOINTENCLR.Reg)&^(0x4)|value<<2)
}
func (o *SPI_Type) GetFIFOINTENCLR_TXLVL() uint32 {
	return (volatile.LoadUint32(&o.FIFOINTENCLR.Reg) & 0x4) >> 2
}
func (o *SPI_Type) SetFIFOINTENCLR_RXLVL(value uint32) {
	volatile.StoreUint32(&o.FIFOINTENCLR.Reg, volatile.LoadUint32(&o.FIFOINTENCLR.Reg)&^(0x8)|value<<3)
}
func (o *SPI_Type) GetFIFOINTENCLR_RXLVL() uint32 {
	return (volatile.LoadUint32(&o.FIFOINTENCLR.Reg) & 0x8) >> 3
}

// SPI.FIFOINTSTAT: FIFO interrupt status register.
func (o *SPI_Type) SetFIFOINTSTAT_TXERR(value uint32) {
	volatile.StoreUint32(&o.FIFOINTSTAT.Reg, volatile.LoadUint32(&o.FIFOINTSTAT.Reg)&^(0x1)|value)
}
func (o *SPI_Type) GetFIFOINTSTAT_TXERR() uint32 {
	return volatile.LoadUint32(&o.FIFOINTSTAT.Reg) & 0x1
}
func (o *SPI_Type) SetFIFOINTSTAT_RXERR(value uint32) {
	volatile.StoreUint32(&o.FIFOINTSTAT.Reg, volatile.LoadUint32(&o.FIFOINTSTAT.Reg)&^(0x2)|value<<1)
}
func (o *SPI_Type) GetFIFOINTSTAT_RXERR() uint32 {
	return (volatile.LoadUint32(&o.FIFOINTSTAT.Reg) & 0x2) >> 1
}
func (o *SPI_Type) SetFIFOINTSTAT_TXLVL(value uint32) {
	volatile.StoreUint32(&o.FIFOINTSTAT.Reg, volatile.LoadUint32(&o.FIFOINTSTAT.Reg)&^(0x4)|value<<2)
}
func (o *SPI_Type) GetFIFOINTSTAT_TXLVL() uint32 {
	return (volatile.LoadUint32(&o.FIFOINTSTAT.Reg) & 0x4) >> 2
}
func (o *SPI_Type) SetFIFOINTSTAT_RXLVL(value uint32) {
	volatile.StoreUint32(&o.FIFOINTSTAT.Reg, volatile.LoadUint32(&o.FIFOINTSTAT.Reg)&^(0x8)|value<<3)
}
func (o *SPI_Type) GetFIFOINTSTAT_RXLVL() uint32 {
	return (volatile.LoadUint32(&o.FIFOINTSTAT.Reg) & 0x8) >> 3
}
func (o *SPI_Type) SetFIFOINTSTAT_PERINT(value uint32) {
	volatile.StoreUint32(&o.FIFOINTSTAT.Reg, volatile.LoadUint32(&o.FIFOINTSTAT.Reg)&^(0x10)|value<<4)
}
func (o *SPI_Type) GetFIFOINTSTAT_PERINT() uint32 {
	return (volatile.LoadUint32(&o.FIFOINTSTAT.Reg) & 0x10) >> 4
}

// SPI.FIFOWR: FIFO write data.
func (o *SPI_Type) SetFIFOWR_TXDATA(value uint32) {
	volatile.StoreUint32(&o.FIFOWR.Reg, volatile.LoadUint32(&o.FIFOWR.Reg)&^(0xffff)|value)
}
func (o *SPI_Type) GetFIFOWR_TXDATA() uint32 {
	return volatile.LoadUint32(&o.FIFOWR.Reg) & 0xffff
}
func (o *SPI_Type) SetFIFOWR_TXSSEL0_N(value uint32) {
	volatile.StoreUint32(&o.FIFOWR.Reg, volatile.LoadUint32(&o.FIFOWR.Reg)&^(0x10000)|value<<16)
}
func (o *SPI_Type) GetFIFOWR_TXSSEL0_N() uint32 {
	return (volatile.LoadUint32(&o.FIFOWR.Reg) & 0x10000) >> 16
}
func (o *SPI_Type) SetFIFOWR_TXSSEL1_N(value uint32) {
	volatile.StoreUint32(&o.FIFOWR.Reg, volatile.LoadUint32(&o.FIFOWR.Reg)&^(0x20000)|value<<17)
}
func (o *SPI_Type) GetFIFOWR_TXSSEL1_N() uint32 {
	return (volatile.LoadUint32(&o.FIFOWR.Reg) & 0x20000) >> 17
}
func (o *SPI_Type) SetFIFOWR_TXSSEL2_N(value uint32) {
	volatile.StoreUint32(&o.FIFOWR.Reg, volatile.LoadUint32(&o.FIFOWR.Reg)&^(0x40000)|value<<18)
}
func (o *SPI_Type) GetFIFOWR_TXSSEL2_N() uint32 {
	return (volatile.LoadUint32(&o.FIFOWR.Reg) & 0x40000) >> 18
}
func (o *SPI_Type) SetFIFOWR_TXSSEL3_N(value uint32) {
	volatile.StoreUint32(&o.FIFOWR.Reg, volatile.LoadUint32(&o.FIFOWR.Reg)&^(0x80000)|value<<19)
}
func (o *SPI_Type) GetFIFOWR_TXSSEL3_N() uint32 {
	return (volatile.LoadUint32(&o.FIFOWR.Reg) & 0x80000) >> 19
}
func (o *SPI_Type) SetFIFOWR_EOT(value uint32) {
	volatile.StoreUint32(&o.FIFOWR.Reg, volatile.LoadUint32(&o.FIFOWR.Reg)&^(0x100000)|value<<20)
}
func (o *SPI_Type) GetFIFOWR_EOT() uint32 {
	return (volatile.LoadUint32(&o.FIFOWR.Reg) & 0x100000) >> 20
}
func (o *SPI_Type) SetFIFOWR_EOF(value uint32) {
	volatile.StoreUint32(&o.FIFOWR.Reg, volatile.LoadUint32(&o.FIFOWR.Reg)&^(0x200000)|value<<21)
}
func (o *SPI_Type) GetFIFOWR_EOF() uint32 {
	return (volatile.LoadUint32(&o.FIFOWR.Reg) & 0x200000) >> 21
}
func (o *SPI_Type) SetFIFOWR_RXIGNORE(value uint32) {
	volatile.StoreUint32(&o.FIFOWR.Reg, volatile.LoadUint32(&o.FIFOWR.Reg)&^(0x400000)|value<<22)
}
func (o *SPI_Type) GetFIFOWR_RXIGNORE() uint32 {
	return (volatile.LoadUint32(&o.FIFOWR.Reg) & 0x400000) >> 22
}
func (o *SPI_Type) SetFIFOWR_LEN(value uint32) {
	volatile.StoreUint32(&o.FIFOWR.Reg, volatile.LoadUint32(&o.FIFOWR.Reg)&^(0xf000000)|value<<24)
}
func (o *SPI_Type) GetFIFOWR_LEN() uint32 {
	return (volatile.LoadUint32(&o.FIFOWR.Reg) & 0xf000000) >> 24
}

// SPI.FIFORD: FIFO read data.
func (o *SPI_Type) SetFIFORD_RXDATA(value uint32) {
	volatile.StoreUint32(&o.FIFORD.Reg, volatile.LoadUint32(&o.FIFORD.Reg)&^(0xffff)|value)
}
func (o *SPI_Type) GetFIFORD_RXDATA() uint32 {
	return volatile.LoadUint32(&o.FIFORD.Reg) & 0xffff
}
func (o *SPI_Type) SetFIFORD_RXSSEL0_N(value uint32) {
	volatile.StoreUint32(&o.FIFORD.Reg, volatile.LoadUint32(&o.FIFORD.Reg)&^(0x10000)|value<<16)
}
func (o *SPI_Type) GetFIFORD_RXSSEL0_N() uint32 {
	return (volatile.LoadUint32(&o.FIFORD.Reg) & 0x10000) >> 16
}
func (o *SPI_Type) SetFIFORD_RXSSEL1_N(value uint32) {
	volatile.StoreUint32(&o.FIFORD.Reg, volatile.LoadUint32(&o.FIFORD.Reg)&^(0x20000)|value<<17)
}
func (o *SPI_Type) GetFIFORD_RXSSEL1_N() uint32 {
	return (volatile.LoadUint32(&o.FIFORD.Reg) & 0x20000) >> 17
}
func (o *SPI_Type) SetFIFORD_RXSSEL2_N(value uint32) {
	volatile.StoreUint32(&o.FIFORD.Reg, volatile.LoadUint32(&o.FIFORD.Reg)&^(0x40000)|value<<18)
}
func (o *SPI_Type) GetFIFORD_RXSSEL2_N() uint32 {
	return (volatile.LoadUint32(&o.FIFORD.Reg) & 0x40000) >> 18
}
func (o *SPI_Type) SetFIFORD_RXSSEL3_N(value uint32) {
	volatile.StoreUint32(&o.FIFORD.Reg, volatile.LoadUint32(&o.FIFORD.Reg)&^(0x80000)|value<<19)
}
func (o *SPI_Type) GetFIFORD_RXSSEL3_N() uint32 {
	return (volatile.LoadUint32(&o.FIFORD.Reg) & 0x80000) >> 19
}
func (o *SPI_Type) SetFIFORD_SOT(value uint32) {
	volatile.StoreUint32(&o.FIFORD.Reg, volatile.LoadUint32(&o.FIFORD.Reg)&^(0x100000)|value<<20)
}
func (o *SPI_Type) GetFIFORD_SOT() uint32 {
	return (volatile.LoadUint32(&o.FIFORD.Reg) & 0x100000) >> 20
}

// SPI.FIFORDNOPOP: FIFO data read with no FIFO pop.
func (o *SPI_Type) SetFIFORDNOPOP_RXDATA(value uint32) {
	volatile.StoreUint32(&o.FIFORDNOPOP.Reg, volatile.LoadUint32(&o.FIFORDNOPOP.Reg)&^(0xffff)|value)
}
func (o *SPI_Type) GetFIFORDNOPOP_RXDATA() uint32 {
	return volatile.LoadUint32(&o.FIFORDNOPOP.Reg) & 0xffff
}
func (o *SPI_Type) SetFIFORDNOPOP_RXSSEL0_N(value uint32) {
	volatile.StoreUint32(&o.FIFORDNOPOP.Reg, volatile.LoadUint32(&o.FIFORDNOPOP.Reg)&^(0x10000)|value<<16)
}
func (o *SPI_Type) GetFIFORDNOPOP_RXSSEL0_N() uint32 {
	return (volatile.LoadUint32(&o.FIFORDNOPOP.Reg) & 0x10000) >> 16
}
func (o *SPI_Type) SetFIFORDNOPOP_RXSSEL1_N(value uint32) {
	volatile.StoreUint32(&o.FIFORDNOPOP.Reg, volatile.LoadUint32(&o.FIFORDNOPOP.Reg)&^(0x20000)|value<<17)
}
func (o *SPI_Type) GetFIFORDNOPOP_RXSSEL1_N() uint32 {
	return (volatile.LoadUint32(&o.FIFORDNOPOP.Reg) & 0x20000) >> 17
}
func (o *SPI_Type) SetFIFORDNOPOP_RXSSEL2_N(value uint32) {
	volatile.StoreUint32(&o.FIFORDNOPOP.Reg, volatile.LoadUint32(&o.FIFORDNOPOP.Reg)&^(0x40000)|value<<18)
}
func (o *SPI_Type) GetFIFORDNOPOP_RXSSEL2_N() uint32 {
	return (volatile.LoadUint32(&o.FIFORDNOPOP.Reg) & 0x40000) >> 18
}
func (o *SPI_Type) SetFIFORDNOPOP_RXSSEL3_N(value uint32) {
	volatile.StoreUint32(&o.FIFORDNOPOP.Reg, volatile.LoadUint32(&o.FIFORDNOPOP.Reg)&^(0x80000)|value<<19)
}
func (o *SPI_Type) GetFIFORDNOPOP_RXSSEL3_N() uint32 {
	return (volatile.LoadUint32(&o.FIFORDNOPOP.Reg) & 0x80000) >> 19
}
func (o *SPI_Type) SetFIFORDNOPOP_SOT(value uint32) {
	volatile.StoreUint32(&o.FIFORDNOPOP.Reg, volatile.LoadUint32(&o.FIFORDNOPOP.Reg)&^(0x100000)|value<<20)
}
func (o *SPI_Type) GetFIFORDNOPOP_SOT() uint32 {
	return (volatile.LoadUint32(&o.FIFORDNOPOP.Reg) & 0x100000) >> 20
}

// SPI.ID: SPI module Identification. This value appears in the shared Flexcomm peripheral ID register when SPI is selected.
func (o *SPI_Type) SetID_APERTURE(value uint32) {
	volatile.StoreUint32(&o.ID.Reg, volatile.LoadUint32(&o.ID.Reg)&^(0xff)|value)
}
func (o *SPI_Type) GetID_APERTURE() uint32 {
	return volatile.LoadUint32(&o.ID.Reg) & 0xff
}
func (o *SPI_Type) SetID_MINOR_REV(value uint32) {
	volatile.StoreUint32(&o.ID.Reg, volatile.LoadUint32(&o.ID.Reg)&^(0xf00)|value<<8)
}
func (o *SPI_Type) GetID_MINOR_REV() uint32 {
	return (volatile.LoadUint32(&o.ID.Reg) & 0xf00) >> 8
}
func (o *SPI_Type) SetID_MAJOR_REV(value uint32) {
	volatile.StoreUint32(&o.ID.Reg, volatile.LoadUint32(&o.ID.Reg)&^(0xf000)|value<<12)
}
func (o *SPI_Type) GetID_MAJOR_REV() uint32 {
	return (volatile.LoadUint32(&o.ID.Reg) & 0xf000) >> 12
}
func (o *SPI_Type) SetID(value uint32) {
	volatile.StoreUint32(&o.ID.Reg, volatile.LoadUint32(&o.ID.Reg)&^(0xffff0000)|value<<16)
}
func (o *SPI_Type) GetID() uint32 {
	return (volatile.LoadUint32(&o.ID.Reg) & 0xffff0000) >> 16
}

// fsp
type FSP_Type struct {
	SYS_CTRL         volatile.Register32 // 0x0
	STATUS           volatile.Register32 // 0x4
	INT              volatile.Register32 // 0x8
	INTEN            volatile.Register32 // 0xC
	_                [16]byte
	TE_CTRL          volatile.Register32 // 0x20
	TE_SRC_BASE      volatile.Register32 // 0x24
	TE_DST_BASE      volatile.Register32 // 0x28
	_                [20]byte
	MOU_CTRL         volatile.Register32 // 0x40
	MA_SRC_BASE      volatile.Register32 // 0x44
	MB_SRC_BASE      volatile.Register32 // 0x48
	MO_DST_BASE      volatile.Register32 // 0x4C
	MOU_SCALEA       volatile.Register32 // 0x50
	MOU_SCALEB       volatile.Register32 // 0x54
	_                [8]byte
	SE_CTRL          volatile.Register32 // 0x60
	SE_SRC_BASE      volatile.Register32 // 0x64
	SE_IDX           volatile.Register32 // 0x68
	SE_SUM           volatile.Register32 // 0x6C
	SE_PWR           volatile.Register32 // 0x70
	_                [12]byte
	COR_CTRL         volatile.Register32 // 0x80
	CX_SRC_BASE      volatile.Register32 // 0x84
	CY_SRC_BASE      volatile.Register32 // 0x88
	CO_DST_BASE      volatile.Register32 // 0x8C
	COR_OFFSET       volatile.Register32 // 0x90
	_                [12]byte
	FIR_CFG_CH0      volatile.Register32 // 0xA0
	FIR_CFG_CH1      volatile.Register32 // 0xA4
	FIR_CFG_CH2      volatile.Register32 // 0xA8
	FIR_CFG_CH3      volatile.Register32 // 0xAC
	FIR_CFG_CH4      volatile.Register32 // 0xB0
	FIR_CFG_CH5      volatile.Register32 // 0xB4
	FIR_CFG_CH6      volatile.Register32 // 0xB8
	FIR_CFG_CH7      volatile.Register32 // 0xBC
	FIR_CFG_CH8      volatile.Register32 // 0xC0
	_                [12]byte
	FIR_DAT0_FX      volatile.Register32 // 0xD0
	FIR_DAT1_FX      volatile.Register32 // 0xD4
	FIR_DAT2_FX      volatile.Register32 // 0xD8
	FIR_DAT3_FX      volatile.Register32 // 0xDC
	FIR_DAT4_FX      volatile.Register32 // 0xE0
	FIR_DAT5_FX      volatile.Register32 // 0xE4
	FIR_DAT6_FX      volatile.Register32 // 0xE8
	FIR_DAT7_FX      volatile.Register32 // 0xEC
	FIR_DAT8_FX      volatile.Register32 // 0xF0
	_                [12]byte
	FIR_DAT0_FL      volatile.Register32 // 0x100
	FIR_DAT1_FL      volatile.Register32 // 0x104
	FIR_DAT2_FL      volatile.Register32 // 0x108
	FIR_DAT3_FL      volatile.Register32 // 0x10C
	FIR_DAT4_FL      volatile.Register32 // 0x110
	FIR_DAT5_FL      volatile.Register32 // 0x114
	FIR_DAT6_FL      volatile.Register32 // 0x118
	FIR_DAT7_FL      volatile.Register32 // 0x11C
	FIR_DAT8_FL      volatile.Register32 // 0x120
	_                [28]byte
	SIN_COS_IXOX     volatile.Register32 // 0x140
	SIN_COS_IXOL     volatile.Register32 // 0x144
	SIN_COS_ILOX     volatile.Register32 // 0x148
	SIN_COS_ILOL     volatile.Register32 // 0x14C
	LN_SQRT_IXOX     volatile.Register32 // 0x150
	LN_SQRT_IXOL     volatile.Register32 // 0x154
	LN_SQRT_ILOX     volatile.Register32 // 0x158
	LN_SQRT_ILOL     volatile.Register32 // 0x15C
	CORDIC_T0UP_IXOX volatile.Register32 // 0x160
	CORDIC_T0UP_IXOL volatile.Register32 // 0x164
	CORDIC_T0UP_ILOX volatile.Register32 // 0x168
	CORDIC_T0UP_ILOL volatile.Register32 // 0x16C
	CORDIC_T0UN_IXOX volatile.Register32 // 0x170
	CORDIC_T0UN_IXOL volatile.Register32 // 0x174
	CORDIC_T0UN_ILOX volatile.Register32 // 0x178
	CORDIC_T0UN_ILOL volatile.Register32 // 0x17C
	CORDIC_T1UP_IXOX volatile.Register32 // 0x180
	CORDIC_T1UP_IXOL volatile.Register32 // 0x184
	CORDIC_T1UP_ILOX volatile.Register32 // 0x188
	CORDIC_T1UP_ILOL volatile.Register32 // 0x18C
	CORDIC_T1UN_IXOX volatile.Register32 // 0x190
	CORDIC_T1UN_IXOL volatile.Register32 // 0x194
	CORDIC_T1UN_ILOX volatile.Register32 // 0x198
	CORDIC_T1UN_ILOL volatile.Register32 // 0x19C
}

// FSP.SYS_CTRL: FSP system control register
func (o *FSP_Type) SetSYS_CTRL_TE_ABORT(value uint32) {
	volatile.StoreUint32(&o.SYS_CTRL.Reg, volatile.LoadUint32(&o.SYS_CTRL.Reg)&^(0x1)|value)
}
func (o *FSP_Type) GetSYS_CTRL_TE_ABORT() uint32 {
	return volatile.LoadUint32(&o.SYS_CTRL.Reg) & 0x1
}
func (o *FSP_Type) SetSYS_CTRL_MOU_ABORT(value uint32) {
	volatile.StoreUint32(&o.SYS_CTRL.Reg, volatile.LoadUint32(&o.SYS_CTRL.Reg)&^(0x2)|value<<1)
}
func (o *FSP_Type) GetSYS_CTRL_MOU_ABORT() uint32 {
	return (volatile.LoadUint32(&o.SYS_CTRL.Reg) & 0x2) >> 1
}
func (o *FSP_Type) SetSYS_CTRL_SCF_ABORT(value uint32) {
	volatile.StoreUint32(&o.SYS_CTRL.Reg, volatile.LoadUint32(&o.SYS_CTRL.Reg)&^(0x4)|value<<2)
}
func (o *FSP_Type) GetSYS_CTRL_SCF_ABORT() uint32 {
	return (volatile.LoadUint32(&o.SYS_CTRL.Reg) & 0x4) >> 2
}

// FSP.STATUS: FSP status register
func (o *FSP_Type) SetSTATUS_FPU0_BUSY(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x1)|value)
}
func (o *FSP_Type) GetSTATUS_FPU0_BUSY() uint32 {
	return volatile.LoadUint32(&o.STATUS.Reg) & 0x1
}
func (o *FSP_Type) SetSTATUS_FPU1_BUSY(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x2)|value<<1)
}
func (o *FSP_Type) GetSTATUS_FPU1_BUSY() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x2) >> 1
}
func (o *FSP_Type) SetSTATUS_FIR_READY(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x4)|value<<2)
}
func (o *FSP_Type) GetSTATUS_FIR_READY() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x4) >> 2
}

// FSP.INT: FSP interrupt register
func (o *FSP_Type) SetINT_TE_DONE_INT(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x1)|value)
}
func (o *FSP_Type) GetINT_TE_DONE_INT() uint32 {
	return volatile.LoadUint32(&o.INT.Reg) & 0x1
}
func (o *FSP_Type) SetINT_MOU_DONE_INT(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x2)|value<<1)
}
func (o *FSP_Type) GetINT_MOU_DONE_INT() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x2) >> 1
}
func (o *FSP_Type) SetINT_SE_DONE_INT(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x4)|value<<2)
}
func (o *FSP_Type) GetINT_SE_DONE_INT() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x4) >> 2
}
func (o *FSP_Type) SetINT_COR_DONE_INT(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x8)|value<<3)
}
func (o *FSP_Type) GetINT_COR_DONE_INT() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x8) >> 3
}
func (o *FSP_Type) SetINT_FPU0_CALC_IN_ERR_INT(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x100)|value<<8)
}
func (o *FSP_Type) GetINT_FPU0_CALC_IN_ERR_INT() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x100) >> 8
}
func (o *FSP_Type) SetINT_FPU0_CALC_OUT_ERR_INT(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x200)|value<<9)
}
func (o *FSP_Type) GetINT_FPU0_CALC_OUT_ERR_INT() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x200) >> 9
}
func (o *FSP_Type) SetINT_FPU0_DIN_OV_INT(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x400)|value<<10)
}
func (o *FSP_Type) GetINT_FPU0_DIN_OV_INT() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x400) >> 10
}
func (o *FSP_Type) SetINT_FPU0_DOUT_OV_INT(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x800)|value<<11)
}
func (o *FSP_Type) GetINT_FPU0_DOUT_OV_INT() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x800) >> 11
}
func (o *FSP_Type) SetINT_SINGULAR_INT(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x1000)|value<<12)
}
func (o *FSP_Type) GetINT_SINGULAR_INT() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x1000) >> 12
}
func (o *FSP_Type) SetINT_FPU1_CALC_IN_ERR_INT(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x10000)|value<<16)
}
func (o *FSP_Type) GetINT_FPU1_CALC_IN_ERR_INT() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x10000) >> 16
}
func (o *FSP_Type) SetINT_FPU1_CALC_OUT_ERR_INT(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x20000)|value<<17)
}
func (o *FSP_Type) GetINT_FPU1_CALC_OUT_ERR_INT() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x20000) >> 17
}
func (o *FSP_Type) SetINT_FPU1_DIN_OV_INT(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x40000)|value<<18)
}
func (o *FSP_Type) GetINT_FPU1_DIN_OV_INT() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x40000) >> 18
}
func (o *FSP_Type) SetINT_FPU1_DOUT_OV_INT(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x80000)|value<<19)
}
func (o *FSP_Type) GetINT_FPU1_DOUT_OV_INT() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x80000) >> 19
}
func (o *FSP_Type) SetINT_FINV_DIN_ERR_INT(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x100000)|value<<20)
}
func (o *FSP_Type) GetINT_FINV_DIN_ERR_INT() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x100000) >> 20
}
func (o *FSP_Type) SetINT_FINV_DOUT_OV_INT(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x200000)|value<<21)
}
func (o *FSP_Type) GetINT_FINV_DOUT_OV_INT() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x200000) >> 21
}
func (o *FSP_Type) SetINT_FINV_ZERO_INT(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x400000)|value<<22)
}
func (o *FSP_Type) GetINT_FINV_ZERO_INT() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x400000) >> 22
}
func (o *FSP_Type) SetINT_CORDIC_DIN_ERR(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x1000000)|value<<24)
}
func (o *FSP_Type) GetINT_CORDIC_DIN_ERR() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x1000000) >> 24
}
func (o *FSP_Type) SetINT_CORDIC_DOUT_ERR_INT(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x2000000)|value<<25)
}
func (o *FSP_Type) GetINT_CORDIC_DOUT_ERR_INT() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x2000000) >> 25
}
func (o *FSP_Type) SetINT_CORDIC_CALC_ERR_INT(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x4000000)|value<<26)
}
func (o *FSP_Type) GetINT_CORDIC_CALC_ERR_INT() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x4000000) >> 26
}
func (o *FSP_Type) SetINT_FSP_INT(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x80000000)|value<<31)
}
func (o *FSP_Type) GetINT_FSP_INT() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x80000000) >> 31
}

// FSP.INTEN: FSP interrupt enable register
func (o *FSP_Type) SetINTEN_TE_DONE_INTEN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x1)|value)
}
func (o *FSP_Type) GetINTEN_TE_DONE_INTEN() uint32 {
	return volatile.LoadUint32(&o.INTEN.Reg) & 0x1
}
func (o *FSP_Type) SetINTEN_MOU_DONE_INTEN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x2)|value<<1)
}
func (o *FSP_Type) GetINTEN_MOU_DONE_INTEN() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x2) >> 1
}
func (o *FSP_Type) SetINTEN_SE_DONE_INTEN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x4)|value<<2)
}
func (o *FSP_Type) GetINTEN_SE_DONE_INTEN() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x4) >> 2
}
func (o *FSP_Type) SetINTEN_COR_DONE_INTEN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x8)|value<<3)
}
func (o *FSP_Type) GetINTEN_COR_DONE_INTEN() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x8) >> 3
}
func (o *FSP_Type) SetINTEN_FPU0_CALC_IN_ERR_INTEN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x100)|value<<8)
}
func (o *FSP_Type) GetINTEN_FPU0_CALC_IN_ERR_INTEN() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x100) >> 8
}
func (o *FSP_Type) SetINTEN_FPU0_CALC_OUT_ERR_INTEN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x200)|value<<9)
}
func (o *FSP_Type) GetINTEN_FPU0_CALC_OUT_ERR_INTEN() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x200) >> 9
}
func (o *FSP_Type) SetINTEN_FPU0_DIN_OV_INTEN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x400)|value<<10)
}
func (o *FSP_Type) GetINTEN_FPU0_DIN_OV_INTEN() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x400) >> 10
}
func (o *FSP_Type) SetINTEN_FPU0_DOUT_OV_INTEN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x800)|value<<11)
}
func (o *FSP_Type) GetINTEN_FPU0_DOUT_OV_INTEN() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x800) >> 11
}
func (o *FSP_Type) SetINTEN_SINGULAR_INTEN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x1000)|value<<12)
}
func (o *FSP_Type) GetINTEN_SINGULAR_INTEN() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x1000) >> 12
}
func (o *FSP_Type) SetINTEN_FPU1_CALC_IN_ERR_INTEN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x10000)|value<<16)
}
func (o *FSP_Type) GetINTEN_FPU1_CALC_IN_ERR_INTEN() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x10000) >> 16
}
func (o *FSP_Type) SetINTEN_FPU1_CALC_OUT_ERR_INTEN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x20000)|value<<17)
}
func (o *FSP_Type) GetINTEN_FPU1_CALC_OUT_ERR_INTEN() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x20000) >> 17
}
func (o *FSP_Type) SetINTEN_FPU1_DIN_OV_INTEN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x40000)|value<<18)
}
func (o *FSP_Type) GetINTEN_FPU1_DIN_OV_INTEN() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x40000) >> 18
}
func (o *FSP_Type) SetINTEN_FPU1_DOUT_OV_INTEN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x80000)|value<<19)
}
func (o *FSP_Type) GetINTEN_FPU1_DOUT_OV_INTEN() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x80000) >> 19
}
func (o *FSP_Type) SetINTEN_FINV_DIN_ERR_INTEN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x100000)|value<<20)
}
func (o *FSP_Type) GetINTEN_FINV_DIN_ERR_INTEN() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x100000) >> 20
}
func (o *FSP_Type) SetINTEN_FINV_DOUT_OV_INTEN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x200000)|value<<21)
}
func (o *FSP_Type) GetINTEN_FINV_DOUT_OV_INTEN() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x200000) >> 21
}
func (o *FSP_Type) SetINTEN_FINV_ZERO_INTEN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x400000)|value<<22)
}
func (o *FSP_Type) GetINTEN_FINV_ZERO_INTEN() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x400000) >> 22
}
func (o *FSP_Type) SetINTEN_CORDIC_DIN_ERR_INTEN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x1000000)|value<<24)
}
func (o *FSP_Type) GetINTEN_CORDIC_DIN_ERR_INTEN() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x1000000) >> 24
}
func (o *FSP_Type) SetINTEN_CORDIC_DOUT_ERR_INTEN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x2000000)|value<<25)
}
func (o *FSP_Type) GetINTEN_CORDIC_DOUT_ERR_INTEN() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x2000000) >> 25
}
func (o *FSP_Type) SetINTEN_CORDIC_CALC_ERR_INTEN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x4000000)|value<<26)
}
func (o *FSP_Type) GetINTEN_CORDIC_CALC_ERR_INTEN() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x4000000) >> 26
}
func (o *FSP_Type) SetINTEN_FSP_INTEN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x80000000)|value<<31)
}
func (o *FSP_Type) GetINTEN_FSP_INTEN() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x80000000) >> 31
}

// FSP.TE_CTRL: transmit engine control register
func (o *FSP_Type) SetTE_CTRL_TE_MODE(value uint32) {
	volatile.StoreUint32(&o.TE_CTRL.Reg, volatile.LoadUint32(&o.TE_CTRL.Reg)&^(0x3)|value)
}
func (o *FSP_Type) GetTE_CTRL_TE_MODE() uint32 {
	return volatile.LoadUint32(&o.TE_CTRL.Reg) & 0x3
}
func (o *FSP_Type) SetTE_CTRL_TE_IO_MODE(value uint32) {
	volatile.StoreUint32(&o.TE_CTRL.Reg, volatile.LoadUint32(&o.TE_CTRL.Reg)&^(0xc)|value<<2)
}
func (o *FSP_Type) GetTE_CTRL_TE_IO_MODE() uint32 {
	return (volatile.LoadUint32(&o.TE_CTRL.Reg) & 0xc) >> 2
}
func (o *FSP_Type) SetTE_CTRL_TE_PTS(value uint32) {
	volatile.StoreUint32(&o.TE_CTRL.Reg, volatile.LoadUint32(&o.TE_CTRL.Reg)&^(0x30)|value<<4)
}
func (o *FSP_Type) GetTE_CTRL_TE_PTS() uint32 {
	return (volatile.LoadUint32(&o.TE_CTRL.Reg) & 0x30) >> 4
}
func (o *FSP_Type) SetTE_CTRL_TE_DIN_FP_SEL(value uint32) {
	volatile.StoreUint32(&o.TE_CTRL.Reg, volatile.LoadUint32(&o.TE_CTRL.Reg)&^(0x40)|value<<6)
}
func (o *FSP_Type) GetTE_CTRL_TE_DIN_FP_SEL() uint32 {
	return (volatile.LoadUint32(&o.TE_CTRL.Reg) & 0x40) >> 6
}
func (o *FSP_Type) SetTE_CTRL_TE_DOUT_FP_SEL(value uint32) {
	volatile.StoreUint32(&o.TE_CTRL.Reg, volatile.LoadUint32(&o.TE_CTRL.Reg)&^(0x80)|value<<7)
}
func (o *FSP_Type) GetTE_CTRL_TE_DOUT_FP_SEL() uint32 {
	return (volatile.LoadUint32(&o.TE_CTRL.Reg) & 0x80) >> 7
}
func (o *FSP_Type) SetTE_CTRL_TE_SCALE(value uint32) {
	volatile.StoreUint32(&o.TE_CTRL.Reg, volatile.LoadUint32(&o.TE_CTRL.Reg)&^(0xff00)|value<<8)
}
func (o *FSP_Type) GetTE_CTRL_TE_SCALE() uint32 {
	return (volatile.LoadUint32(&o.TE_CTRL.Reg) & 0xff00) >> 8
}
func (o *FSP_Type) SetTE_CTRL_TE_PAUSE_LVL(value uint32) {
	volatile.StoreUint32(&o.TE_CTRL.Reg, volatile.LoadUint32(&o.TE_CTRL.Reg)&^(0x7000000)|value<<24)
}
func (o *FSP_Type) GetTE_CTRL_TE_PAUSE_LVL() uint32 {
	return (volatile.LoadUint32(&o.TE_CTRL.Reg) & 0x7000000) >> 24
}

// FSP.TE_SRC_BASE: transfer engine source data memory base register
func (o *FSP_Type) SetTE_SRC_BASE(value uint32) {
	volatile.StoreUint32(&o.TE_SRC_BASE.Reg, volatile.LoadUint32(&o.TE_SRC_BASE.Reg)&^(0x1ffff)|value)
}
func (o *FSP_Type) GetTE_SRC_BASE() uint32 {
	return volatile.LoadUint32(&o.TE_SRC_BASE.Reg) & 0x1ffff
}

// FSP.TE_DST_BASE: transfer engine destination data memory base register
func (o *FSP_Type) SetTE_DST_BASE(value uint32) {
	volatile.StoreUint32(&o.TE_DST_BASE.Reg, volatile.LoadUint32(&o.TE_DST_BASE.Reg)&^(0x1ffff)|value)
}
func (o *FSP_Type) GetTE_DST_BASE() uint32 {
	return volatile.LoadUint32(&o.TE_DST_BASE.Reg) & 0x1ffff
}

// FSP.MOU_CTRL: matrix operation unit control register
func (o *FSP_Type) SetMOU_CTRL_OP_MODE(value uint32) {
	volatile.StoreUint32(&o.MOU_CTRL.Reg, volatile.LoadUint32(&o.MOU_CTRL.Reg)&^(0xf)|value)
}
func (o *FSP_Type) GetMOU_CTRL_OP_MODE() uint32 {
	return volatile.LoadUint32(&o.MOU_CTRL.Reg) & 0xf
}
func (o *FSP_Type) SetMOU_CTRL_MOU_DIN_FP_SEL(value uint32) {
	volatile.StoreUint32(&o.MOU_CTRL.Reg, volatile.LoadUint32(&o.MOU_CTRL.Reg)&^(0x100)|value<<8)
}
func (o *FSP_Type) GetMOU_CTRL_MOU_DIN_FP_SEL() uint32 {
	return (volatile.LoadUint32(&o.MOU_CTRL.Reg) & 0x100) >> 8
}
func (o *FSP_Type) SetMOU_CTRL_MOU_DOUT_FP_SEL(value uint32) {
	volatile.StoreUint32(&o.MOU_CTRL.Reg, volatile.LoadUint32(&o.MOU_CTRL.Reg)&^(0x200)|value<<9)
}
func (o *FSP_Type) GetMOU_CTRL_MOU_DOUT_FP_SEL() uint32 {
	return (volatile.LoadUint32(&o.MOU_CTRL.Reg) & 0x200) >> 9
}
func (o *FSP_Type) SetMOU_CTRL_MAT_M(value uint32) {
	volatile.StoreUint32(&o.MOU_CTRL.Reg, volatile.LoadUint32(&o.MOU_CTRL.Reg)&^(0xf0000)|value<<16)
}
func (o *FSP_Type) GetMOU_CTRL_MAT_M() uint32 {
	return (volatile.LoadUint32(&o.MOU_CTRL.Reg) & 0xf0000) >> 16
}
func (o *FSP_Type) SetMOU_CTRL_MAT_N(value uint32) {
	volatile.StoreUint32(&o.MOU_CTRL.Reg, volatile.LoadUint32(&o.MOU_CTRL.Reg)&^(0xf00000)|value<<20)
}
func (o *FSP_Type) GetMOU_CTRL_MAT_N() uint32 {
	return (volatile.LoadUint32(&o.MOU_CTRL.Reg) & 0xf00000) >> 20
}
func (o *FSP_Type) SetMOU_CTRL_MAT_K(value uint32) {
	volatile.StoreUint32(&o.MOU_CTRL.Reg, volatile.LoadUint32(&o.MOU_CTRL.Reg)&^(0xf000000)|value<<24)
}
func (o *FSP_Type) GetMOU_CTRL_MAT_K() uint32 {
	return (volatile.LoadUint32(&o.MOU_CTRL.Reg) & 0xf000000) >> 24
}
func (o *FSP_Type) SetMOU_CTRL_DIV_EPSILON(value uint32) {
	volatile.StoreUint32(&o.MOU_CTRL.Reg, volatile.LoadUint32(&o.MOU_CTRL.Reg)&^(0x30000000)|value<<28)
}
func (o *FSP_Type) GetMOU_CTRL_DIV_EPSILON() uint32 {
	return (volatile.LoadUint32(&o.MOU_CTRL.Reg) & 0x30000000) >> 28
}
func (o *FSP_Type) SetMOU_CTRL_LU_STOP(value uint32) {
	volatile.StoreUint32(&o.MOU_CTRL.Reg, volatile.LoadUint32(&o.MOU_CTRL.Reg)&^(0x40000000)|value<<30)
}
func (o *FSP_Type) GetMOU_CTRL_LU_STOP() uint32 {
	return (volatile.LoadUint32(&o.MOU_CTRL.Reg) & 0x40000000) >> 30
}
func (o *FSP_Type) SetMOU_CTRL_UINV_STOP(value uint32) {
	volatile.StoreUint32(&o.MOU_CTRL.Reg, volatile.LoadUint32(&o.MOU_CTRL.Reg)&^(0x80000000)|value<<31)
}
func (o *FSP_Type) GetMOU_CTRL_UINV_STOP() uint32 {
	return (volatile.LoadUint32(&o.MOU_CTRL.Reg) & 0x80000000) >> 31
}

// FSP.MA_SRC_BASE: matrix A source data memory base register
func (o *FSP_Type) SetMA_SRC_BASE(value uint32) {
	volatile.StoreUint32(&o.MA_SRC_BASE.Reg, volatile.LoadUint32(&o.MA_SRC_BASE.Reg)&^(0x1ffff)|value)
}
func (o *FSP_Type) GetMA_SRC_BASE() uint32 {
	return volatile.LoadUint32(&o.MA_SRC_BASE.Reg) & 0x1ffff
}

// FSP.MB_SRC_BASE: matrix B source data memory base register
func (o *FSP_Type) SetMB_SRC_BASE(value uint32) {
	volatile.StoreUint32(&o.MB_SRC_BASE.Reg, volatile.LoadUint32(&o.MB_SRC_BASE.Reg)&^(0x1ffff)|value)
}
func (o *FSP_Type) GetMB_SRC_BASE() uint32 {
	return volatile.LoadUint32(&o.MB_SRC_BASE.Reg) & 0x1ffff
}

// FSP.MO_DST_BASE: matrix output data memory base register
func (o *FSP_Type) SetMO_DST_BASE(value uint32) {
	volatile.StoreUint32(&o.MO_DST_BASE.Reg, volatile.LoadUint32(&o.MO_DST_BASE.Reg)&^(0x1ffff)|value)
}
func (o *FSP_Type) GetMO_DST_BASE() uint32 {
	return volatile.LoadUint32(&o.MO_DST_BASE.Reg) & 0x1ffff
}

// FSP.MOU_SCALEA: scale coefficient A register
func (o *FSP_Type) SetMOU_SCALEA(value uint32) {
	volatile.StoreUint32(&o.MOU_SCALEA.Reg, value)
}
func (o *FSP_Type) GetMOU_SCALEA() uint32 {
	return volatile.LoadUint32(&o.MOU_SCALEA.Reg)
}

// FSP.MOU_SCALEB: scale coefficient B register
func (o *FSP_Type) SetMOU_SCALEB(value uint32) {
	volatile.StoreUint32(&o.MOU_SCALEB.Reg, value)
}
func (o *FSP_Type) GetMOU_SCALEB() uint32 {
	return volatile.LoadUint32(&o.MOU_SCALEB.Reg)
}

// FSP.SE_CTRL: stastic engine control register
func (o *FSP_Type) SetSE_CTRL_MIN_SEL(value uint32) {
	volatile.StoreUint32(&o.SE_CTRL.Reg, volatile.LoadUint32(&o.SE_CTRL.Reg)&^(0x1)|value)
}
func (o *FSP_Type) GetSE_CTRL_MIN_SEL() uint32 {
	return volatile.LoadUint32(&o.SE_CTRL.Reg) & 0x1
}
func (o *FSP_Type) SetSE_CTRL_MAX_SEL(value uint32) {
	volatile.StoreUint32(&o.SE_CTRL.Reg, volatile.LoadUint32(&o.SE_CTRL.Reg)&^(0x2)|value<<1)
}
func (o *FSP_Type) GetSE_CTRL_MAX_SEL() uint32 {
	return (volatile.LoadUint32(&o.SE_CTRL.Reg) & 0x2) >> 1
}
func (o *FSP_Type) SetSE_CTRL_MIN_IDX_EN(value uint32) {
	volatile.StoreUint32(&o.SE_CTRL.Reg, volatile.LoadUint32(&o.SE_CTRL.Reg)&^(0x4)|value<<2)
}
func (o *FSP_Type) GetSE_CTRL_MIN_IDX_EN() uint32 {
	return (volatile.LoadUint32(&o.SE_CTRL.Reg) & 0x4) >> 2
}
func (o *FSP_Type) SetSE_CTRL_MAX_IDX_EN(value uint32) {
	volatile.StoreUint32(&o.SE_CTRL.Reg, volatile.LoadUint32(&o.SE_CTRL.Reg)&^(0x8)|value<<3)
}
func (o *FSP_Type) GetSE_CTRL_MAX_IDX_EN() uint32 {
	return (volatile.LoadUint32(&o.SE_CTRL.Reg) & 0x8) >> 3
}
func (o *FSP_Type) SetSE_CTRL_SUM_EN(value uint32) {
	volatile.StoreUint32(&o.SE_CTRL.Reg, volatile.LoadUint32(&o.SE_CTRL.Reg)&^(0x10)|value<<4)
}
func (o *FSP_Type) GetSE_CTRL_SUM_EN() uint32 {
	return (volatile.LoadUint32(&o.SE_CTRL.Reg) & 0x10) >> 4
}
func (o *FSP_Type) SetSE_CTRL_PWR_EN(value uint32) {
	volatile.StoreUint32(&o.SE_CTRL.Reg, volatile.LoadUint32(&o.SE_CTRL.Reg)&^(0x20)|value<<5)
}
func (o *FSP_Type) GetSE_CTRL_PWR_EN() uint32 {
	return (volatile.LoadUint32(&o.SE_CTRL.Reg) & 0x20) >> 5
}
func (o *FSP_Type) SetSE_CTRL_SE_DIN_FP_SEL(value uint32) {
	volatile.StoreUint32(&o.SE_CTRL.Reg, volatile.LoadUint32(&o.SE_CTRL.Reg)&^(0x40)|value<<6)
}
func (o *FSP_Type) GetSE_CTRL_SE_DIN_FP_SEL() uint32 {
	return (volatile.LoadUint32(&o.SE_CTRL.Reg) & 0x40) >> 6
}
func (o *FSP_Type) SetSE_CTRL_SE_DOUT_FP_SEL(value uint32) {
	volatile.StoreUint32(&o.SE_CTRL.Reg, volatile.LoadUint32(&o.SE_CTRL.Reg)&^(0x80)|value<<7)
}
func (o *FSP_Type) GetSE_CTRL_SE_DOUT_FP_SEL() uint32 {
	return (volatile.LoadUint32(&o.SE_CTRL.Reg) & 0x80) >> 7
}
func (o *FSP_Type) SetSE_CTRL_SE_LEN(value uint32) {
	volatile.StoreUint32(&o.SE_CTRL.Reg, volatile.LoadUint32(&o.SE_CTRL.Reg)&^(0xff0000)|value<<16)
}
func (o *FSP_Type) GetSE_CTRL_SE_LEN() uint32 {
	return (volatile.LoadUint32(&o.SE_CTRL.Reg) & 0xff0000) >> 16
}

// FSP.SE_SRC_BASE: statistic engine source data base register
func (o *FSP_Type) SetSE_SRC_BASE(value uint32) {
	volatile.StoreUint32(&o.SE_SRC_BASE.Reg, volatile.LoadUint32(&o.SE_SRC_BASE.Reg)&^(0x1ffff)|value)
}
func (o *FSP_Type) GetSE_SRC_BASE() uint32 {
	return volatile.LoadUint32(&o.SE_SRC_BASE.Reg) & 0x1ffff
}

// FSP.SE_IDX: max or min data index register
func (o *FSP_Type) SetSE_IDX_SE_MIN_IDX(value uint32) {
	volatile.StoreUint32(&o.SE_IDX.Reg, volatile.LoadUint32(&o.SE_IDX.Reg)&^(0xff)|value)
}
func (o *FSP_Type) GetSE_IDX_SE_MIN_IDX() uint32 {
	return volatile.LoadUint32(&o.SE_IDX.Reg) & 0xff
}
func (o *FSP_Type) SetSE_IDX_SE_MAX_IDX(value uint32) {
	volatile.StoreUint32(&o.SE_IDX.Reg, volatile.LoadUint32(&o.SE_IDX.Reg)&^(0xff0000)|value<<16)
}
func (o *FSP_Type) GetSE_IDX_SE_MAX_IDX() uint32 {
	return (volatile.LoadUint32(&o.SE_IDX.Reg) & 0xff0000) >> 16
}

// FSP.SE_SUM: array summary result register
func (o *FSP_Type) SetSE_SUM(value uint32) {
	volatile.StoreUint32(&o.SE_SUM.Reg, value)
}
func (o *FSP_Type) GetSE_SUM() uint32 {
	return volatile.LoadUint32(&o.SE_SUM.Reg)
}

// FSP.SE_PWR: array power result register
func (o *FSP_Type) SetSE_PWR(value uint32) {
	volatile.StoreUint32(&o.SE_PWR.Reg, value)
}
func (o *FSP_Type) GetSE_PWR() uint32 {
	return volatile.LoadUint32(&o.SE_PWR.Reg)
}

// FSP.COR_CTRL: correlation control register
func (o *FSP_Type) SetCOR_CTRL_COR_DIN_FP_SEL(value uint32) {
	volatile.StoreUint32(&o.COR_CTRL.Reg, volatile.LoadUint32(&o.COR_CTRL.Reg)&^(0x100)|value<<8)
}
func (o *FSP_Type) GetCOR_CTRL_COR_DIN_FP_SEL() uint32 {
	return (volatile.LoadUint32(&o.COR_CTRL.Reg) & 0x100) >> 8
}
func (o *FSP_Type) SetCOR_CTRL_COR_DOUT_FP_SEL(value uint32) {
	volatile.StoreUint32(&o.COR_CTRL.Reg, volatile.LoadUint32(&o.COR_CTRL.Reg)&^(0x200)|value<<9)
}
func (o *FSP_Type) GetCOR_CTRL_COR_DOUT_FP_SEL() uint32 {
	return (volatile.LoadUint32(&o.COR_CTRL.Reg) & 0x200) >> 9
}
func (o *FSP_Type) SetCOR_CTRL_COR_X_LEN(value uint32) {
	volatile.StoreUint32(&o.COR_CTRL.Reg, volatile.LoadUint32(&o.COR_CTRL.Reg)&^(0xff0000)|value<<16)
}
func (o *FSP_Type) GetCOR_CTRL_COR_X_LEN() uint32 {
	return (volatile.LoadUint32(&o.COR_CTRL.Reg) & 0xff0000) >> 16
}
func (o *FSP_Type) SetCOR_CTRL_COR_Y_LEN(value uint32) {
	volatile.StoreUint32(&o.COR_CTRL.Reg, volatile.LoadUint32(&o.COR_CTRL.Reg)&^(0xff000000)|value<<24)
}
func (o *FSP_Type) GetCOR_CTRL_COR_Y_LEN() uint32 {
	return (volatile.LoadUint32(&o.COR_CTRL.Reg) & 0xff000000) >> 24
}

// FSP.CX_SRC_BASE: correlation x sequence base register
func (o *FSP_Type) SetCX_SRC_BASE_COR_X_ADDR(value uint32) {
	volatile.StoreUint32(&o.CX_SRC_BASE.Reg, volatile.LoadUint32(&o.CX_SRC_BASE.Reg)&^(0x1ffff)|value)
}
func (o *FSP_Type) GetCX_SRC_BASE_COR_X_ADDR() uint32 {
	return volatile.LoadUint32(&o.CX_SRC_BASE.Reg) & 0x1ffff
}

// FSP.CY_SRC_BASE: correlation y sequence base register
func (o *FSP_Type) SetCY_SRC_BASE_COR_Y_ADDR(value uint32) {
	volatile.StoreUint32(&o.CY_SRC_BASE.Reg, volatile.LoadUint32(&o.CY_SRC_BASE.Reg)&^(0x1ffff)|value)
}
func (o *FSP_Type) GetCY_SRC_BASE_COR_Y_ADDR() uint32 {
	return volatile.LoadUint32(&o.CY_SRC_BASE.Reg) & 0x1ffff
}

// FSP.CO_DST_BASE: correlation output sequence base register
func (o *FSP_Type) SetCO_DST_BASE_COR_DST_BASE(value uint32) {
	volatile.StoreUint32(&o.CO_DST_BASE.Reg, volatile.LoadUint32(&o.CO_DST_BASE.Reg)&^(0x1ffff)|value)
}
func (o *FSP_Type) GetCO_DST_BASE_COR_DST_BASE() uint32 {
	return volatile.LoadUint32(&o.CO_DST_BASE.Reg) & 0x1ffff
}

// FSP.COR_OFFSET: correlation offset register
func (o *FSP_Type) SetCOR_OFFSET_COR_X_OFFSET(value uint32) {
	volatile.StoreUint32(&o.COR_OFFSET.Reg, volatile.LoadUint32(&o.COR_OFFSET.Reg)&^(0xff)|value)
}
func (o *FSP_Type) GetCOR_OFFSET_COR_X_OFFSET() uint32 {
	return volatile.LoadUint32(&o.COR_OFFSET.Reg) & 0xff
}
func (o *FSP_Type) SetCOR_OFFSET_COR_Y_OFFSET(value uint32) {
	volatile.StoreUint32(&o.COR_OFFSET.Reg, volatile.LoadUint32(&o.COR_OFFSET.Reg)&^(0xff00)|value<<8)
}
func (o *FSP_Type) GetCOR_OFFSET_COR_Y_OFFSET() uint32 {
	return (volatile.LoadUint32(&o.COR_OFFSET.Reg) & 0xff00) >> 8
}

// FSP.FIR_CFG_CH0: FIR channel 0 configuration register
func (o *FSP_Type) SetFIR_CFG_CH0_FIR_CH0_COEF_BASE(value uint32) {
	volatile.StoreUint32(&o.FIR_CFG_CH0.Reg, volatile.LoadUint32(&o.FIR_CFG_CH0.Reg)&^(0xffff)|value)
}
func (o *FSP_Type) GetFIR_CFG_CH0_FIR_CH0_COEF_BASE() uint32 {
	return volatile.LoadUint32(&o.FIR_CFG_CH0.Reg) & 0xffff
}
func (o *FSP_Type) SetFIR_CFG_CH0_FIR_CH0_TAP_LEN(value uint32) {
	volatile.StoreUint32(&o.FIR_CFG_CH0.Reg, volatile.LoadUint32(&o.FIR_CFG_CH0.Reg)&^(0xf0000)|value<<16)
}
func (o *FSP_Type) GetFIR_CFG_CH0_FIR_CH0_TAP_LEN() uint32 {
	return (volatile.LoadUint32(&o.FIR_CFG_CH0.Reg) & 0xf0000) >> 16
}
func (o *FSP_Type) SetFIR_CFG_CH0_FIR_BUF_CLR_ALL(value uint32) {
	volatile.StoreUint32(&o.FIR_CFG_CH0.Reg, volatile.LoadUint32(&o.FIR_CFG_CH0.Reg)&^(0x40000000)|value<<30)
}
func (o *FSP_Type) GetFIR_CFG_CH0_FIR_BUF_CLR_ALL() uint32 {
	return (volatile.LoadUint32(&o.FIR_CFG_CH0.Reg) & 0x40000000) >> 30
}
func (o *FSP_Type) SetFIR_CFG_CH0_FIR_CH0_BUF_CLR(value uint32) {
	volatile.StoreUint32(&o.FIR_CFG_CH0.Reg, volatile.LoadUint32(&o.FIR_CFG_CH0.Reg)&^(0x80000000)|value<<31)
}
func (o *FSP_Type) GetFIR_CFG_CH0_FIR_CH0_BUF_CLR() uint32 {
	return (volatile.LoadUint32(&o.FIR_CFG_CH0.Reg) & 0x80000000) >> 31
}

// FSP.FIR_CFG_CH1: FIR channel 1 configuration register
func (o *FSP_Type) SetFIR_CFG_CH1_FIR_CH1_COEF_BASE(value uint32) {
	volatile.StoreUint32(&o.FIR_CFG_CH1.Reg, volatile.LoadUint32(&o.FIR_CFG_CH1.Reg)&^(0xffff)|value)
}
func (o *FSP_Type) GetFIR_CFG_CH1_FIR_CH1_COEF_BASE() uint32 {
	return volatile.LoadUint32(&o.FIR_CFG_CH1.Reg) & 0xffff
}
func (o *FSP_Type) SetFIR_CFG_CH1_FIR_CH1_TAP_LEN(value uint32) {
	volatile.StoreUint32(&o.FIR_CFG_CH1.Reg, volatile.LoadUint32(&o.FIR_CFG_CH1.Reg)&^(0xf0000)|value<<16)
}
func (o *FSP_Type) GetFIR_CFG_CH1_FIR_CH1_TAP_LEN() uint32 {
	return (volatile.LoadUint32(&o.FIR_CFG_CH1.Reg) & 0xf0000) >> 16
}
func (o *FSP_Type) SetFIR_CFG_CH1_FIR_CH1_BUF_CLR(value uint32) {
	volatile.StoreUint32(&o.FIR_CFG_CH1.Reg, volatile.LoadUint32(&o.FIR_CFG_CH1.Reg)&^(0x80000000)|value<<31)
}
func (o *FSP_Type) GetFIR_CFG_CH1_FIR_CH1_BUF_CLR() uint32 {
	return (volatile.LoadUint32(&o.FIR_CFG_CH1.Reg) & 0x80000000) >> 31
}

// FSP.FIR_CFG_CH2: FIR channel 2 configuration register
func (o *FSP_Type) SetFIR_CFG_CH2_FIR_CH2_COEF_BASE(value uint32) {
	volatile.StoreUint32(&o.FIR_CFG_CH2.Reg, volatile.LoadUint32(&o.FIR_CFG_CH2.Reg)&^(0xffff)|value)
}
func (o *FSP_Type) GetFIR_CFG_CH2_FIR_CH2_COEF_BASE() uint32 {
	return volatile.LoadUint32(&o.FIR_CFG_CH2.Reg) & 0xffff
}
func (o *FSP_Type) SetFIR_CFG_CH2_FIR_CH2_TAP_LEN(value uint32) {
	volatile.StoreUint32(&o.FIR_CFG_CH2.Reg, volatile.LoadUint32(&o.FIR_CFG_CH2.Reg)&^(0xf0000)|value<<16)
}
func (o *FSP_Type) GetFIR_CFG_CH2_FIR_CH2_TAP_LEN() uint32 {
	return (volatile.LoadUint32(&o.FIR_CFG_CH2.Reg) & 0xf0000) >> 16
}
func (o *FSP_Type) SetFIR_CFG_CH2_FIR_CH2_BUF_CLR(value uint32) {
	volatile.StoreUint32(&o.FIR_CFG_CH2.Reg, volatile.LoadUint32(&o.FIR_CFG_CH2.Reg)&^(0x80000000)|value<<31)
}
func (o *FSP_Type) GetFIR_CFG_CH2_FIR_CH2_BUF_CLR() uint32 {
	return (volatile.LoadUint32(&o.FIR_CFG_CH2.Reg) & 0x80000000) >> 31
}

// FSP.FIR_CFG_CH3: FIR channel 3 configuration register
func (o *FSP_Type) SetFIR_CFG_CH3_FIR_CH3_COEF_BASE(value uint32) {
	volatile.StoreUint32(&o.FIR_CFG_CH3.Reg, volatile.LoadUint32(&o.FIR_CFG_CH3.Reg)&^(0xffff)|value)
}
func (o *FSP_Type) GetFIR_CFG_CH3_FIR_CH3_COEF_BASE() uint32 {
	return volatile.LoadUint32(&o.FIR_CFG_CH3.Reg) & 0xffff
}
func (o *FSP_Type) SetFIR_CFG_CH3_FIR_CH3_TAP_LEN(value uint32) {
	volatile.StoreUint32(&o.FIR_CFG_CH3.Reg, volatile.LoadUint32(&o.FIR_CFG_CH3.Reg)&^(0xf0000)|value<<16)
}
func (o *FSP_Type) GetFIR_CFG_CH3_FIR_CH3_TAP_LEN() uint32 {
	return (volatile.LoadUint32(&o.FIR_CFG_CH3.Reg) & 0xf0000) >> 16
}
func (o *FSP_Type) SetFIR_CFG_CH3_FIR_CH3_BUF_CLR(value uint32) {
	volatile.StoreUint32(&o.FIR_CFG_CH3.Reg, volatile.LoadUint32(&o.FIR_CFG_CH3.Reg)&^(0x80000000)|value<<31)
}
func (o *FSP_Type) GetFIR_CFG_CH3_FIR_CH3_BUF_CLR() uint32 {
	return (volatile.LoadUint32(&o.FIR_CFG_CH3.Reg) & 0x80000000) >> 31
}

// FSP.FIR_CFG_CH4: FIR channel 4 configuration register
func (o *FSP_Type) SetFIR_CFG_CH4_FIR_CH4_COEF_BASE(value uint32) {
	volatile.StoreUint32(&o.FIR_CFG_CH4.Reg, volatile.LoadUint32(&o.FIR_CFG_CH4.Reg)&^(0xffff)|value)
}
func (o *FSP_Type) GetFIR_CFG_CH4_FIR_CH4_COEF_BASE() uint32 {
	return volatile.LoadUint32(&o.FIR_CFG_CH4.Reg) & 0xffff
}
func (o *FSP_Type) SetFIR_CFG_CH4_FIR_CH4_TAP_LEN(value uint32) {
	volatile.StoreUint32(&o.FIR_CFG_CH4.Reg, volatile.LoadUint32(&o.FIR_CFG_CH4.Reg)&^(0xf0000)|value<<16)
}
func (o *FSP_Type) GetFIR_CFG_CH4_FIR_CH4_TAP_LEN() uint32 {
	return (volatile.LoadUint32(&o.FIR_CFG_CH4.Reg) & 0xf0000) >> 16
}
func (o *FSP_Type) SetFIR_CFG_CH4_FIR_CH4_BUF_CLR(value uint32) {
	volatile.StoreUint32(&o.FIR_CFG_CH4.Reg, volatile.LoadUint32(&o.FIR_CFG_CH4.Reg)&^(0x80000000)|value<<31)
}
func (o *FSP_Type) GetFIR_CFG_CH4_FIR_CH4_BUF_CLR() uint32 {
	return (volatile.LoadUint32(&o.FIR_CFG_CH4.Reg) & 0x80000000) >> 31
}

// FSP.FIR_CFG_CH5: FIR channel 5 configuration register
func (o *FSP_Type) SetFIR_CFG_CH5_FIR_CH5_COEF_BASE(value uint32) {
	volatile.StoreUint32(&o.FIR_CFG_CH5.Reg, volatile.LoadUint32(&o.FIR_CFG_CH5.Reg)&^(0xffff)|value)
}
func (o *FSP_Type) GetFIR_CFG_CH5_FIR_CH5_COEF_BASE() uint32 {
	return volatile.LoadUint32(&o.FIR_CFG_CH5.Reg) & 0xffff
}
func (o *FSP_Type) SetFIR_CFG_CH5_FIR_CH5_TAP_LEN(value uint32) {
	volatile.StoreUint32(&o.FIR_CFG_CH5.Reg, volatile.LoadUint32(&o.FIR_CFG_CH5.Reg)&^(0xf0000)|value<<16)
}
func (o *FSP_Type) GetFIR_CFG_CH5_FIR_CH5_TAP_LEN() uint32 {
	return (volatile.LoadUint32(&o.FIR_CFG_CH5.Reg) & 0xf0000) >> 16
}
func (o *FSP_Type) SetFIR_CFG_CH5_FIR_CH5_BUF_CLR(value uint32) {
	volatile.StoreUint32(&o.FIR_CFG_CH5.Reg, volatile.LoadUint32(&o.FIR_CFG_CH5.Reg)&^(0x80000000)|value<<31)
}
func (o *FSP_Type) GetFIR_CFG_CH5_FIR_CH5_BUF_CLR() uint32 {
	return (volatile.LoadUint32(&o.FIR_CFG_CH5.Reg) & 0x80000000) >> 31
}

// FSP.FIR_CFG_CH6: FIR channel 6 configuration register
func (o *FSP_Type) SetFIR_CFG_CH6_FIR_CH6_COEF_BASE(value uint32) {
	volatile.StoreUint32(&o.FIR_CFG_CH6.Reg, volatile.LoadUint32(&o.FIR_CFG_CH6.Reg)&^(0xffff)|value)
}
func (o *FSP_Type) GetFIR_CFG_CH6_FIR_CH6_COEF_BASE() uint32 {
	return volatile.LoadUint32(&o.FIR_CFG_CH6.Reg) & 0xffff
}
func (o *FSP_Type) SetFIR_CFG_CH6_FIR_CH6_TAP_LEN(value uint32) {
	volatile.StoreUint32(&o.FIR_CFG_CH6.Reg, volatile.LoadUint32(&o.FIR_CFG_CH6.Reg)&^(0xf0000)|value<<16)
}
func (o *FSP_Type) GetFIR_CFG_CH6_FIR_CH6_TAP_LEN() uint32 {
	return (volatile.LoadUint32(&o.FIR_CFG_CH6.Reg) & 0xf0000) >> 16
}
func (o *FSP_Type) SetFIR_CFG_CH6_FIR_CH6_BUF_CLR(value uint32) {
	volatile.StoreUint32(&o.FIR_CFG_CH6.Reg, volatile.LoadUint32(&o.FIR_CFG_CH6.Reg)&^(0x80000000)|value<<31)
}
func (o *FSP_Type) GetFIR_CFG_CH6_FIR_CH6_BUF_CLR() uint32 {
	return (volatile.LoadUint32(&o.FIR_CFG_CH6.Reg) & 0x80000000) >> 31
}

// FSP.FIR_CFG_CH7: FIR channel 7 configuration register
func (o *FSP_Type) SetFIR_CFG_CH7_FIR_CH7_COEF_BASE(value uint32) {
	volatile.StoreUint32(&o.FIR_CFG_CH7.Reg, volatile.LoadUint32(&o.FIR_CFG_CH7.Reg)&^(0xffff)|value)
}
func (o *FSP_Type) GetFIR_CFG_CH7_FIR_CH7_COEF_BASE() uint32 {
	return volatile.LoadUint32(&o.FIR_CFG_CH7.Reg) & 0xffff
}
func (o *FSP_Type) SetFIR_CFG_CH7_FIR_CH7_TAP_LEN(value uint32) {
	volatile.StoreUint32(&o.FIR_CFG_CH7.Reg, volatile.LoadUint32(&o.FIR_CFG_CH7.Reg)&^(0xf0000)|value<<16)
}
func (o *FSP_Type) GetFIR_CFG_CH7_FIR_CH7_TAP_LEN() uint32 {
	return (volatile.LoadUint32(&o.FIR_CFG_CH7.Reg) & 0xf0000) >> 16
}
func (o *FSP_Type) SetFIR_CFG_CH7_FIR_CH7_BUF_CLR(value uint32) {
	volatile.StoreUint32(&o.FIR_CFG_CH7.Reg, volatile.LoadUint32(&o.FIR_CFG_CH7.Reg)&^(0x80000000)|value<<31)
}
func (o *FSP_Type) GetFIR_CFG_CH7_FIR_CH7_BUF_CLR() uint32 {
	return (volatile.LoadUint32(&o.FIR_CFG_CH7.Reg) & 0x80000000) >> 31
}

// FSP.FIR_CFG_CH8: FIR channel 8 configuration register
func (o *FSP_Type) SetFIR_CFG_CH8_FIR_CH8_COEF_BASE(value uint32) {
	volatile.StoreUint32(&o.FIR_CFG_CH8.Reg, volatile.LoadUint32(&o.FIR_CFG_CH8.Reg)&^(0xffff)|value)
}
func (o *FSP_Type) GetFIR_CFG_CH8_FIR_CH8_COEF_BASE() uint32 {
	return volatile.LoadUint32(&o.FIR_CFG_CH8.Reg) & 0xffff
}
func (o *FSP_Type) SetFIR_CFG_CH8_FIR_CH8_TAP_LEN(value uint32) {
	volatile.StoreUint32(&o.FIR_CFG_CH8.Reg, volatile.LoadUint32(&o.FIR_CFG_CH8.Reg)&^(0xf0000)|value<<16)
}
func (o *FSP_Type) GetFIR_CFG_CH8_FIR_CH8_TAP_LEN() uint32 {
	return (volatile.LoadUint32(&o.FIR_CFG_CH8.Reg) & 0xf0000) >> 16
}
func (o *FSP_Type) SetFIR_CFG_CH8_FIR_CH8_BUF_CLR(value uint32) {
	volatile.StoreUint32(&o.FIR_CFG_CH8.Reg, volatile.LoadUint32(&o.FIR_CFG_CH8.Reg)&^(0x80000000)|value<<31)
}
func (o *FSP_Type) GetFIR_CFG_CH8_FIR_CH8_BUF_CLR() uint32 {
	return (volatile.LoadUint32(&o.FIR_CFG_CH8.Reg) & 0x80000000) >> 31
}

// FSP.FIR_DAT0_FX: FIR channel 0 fix point data input &amp; output register
func (o *FSP_Type) SetFIR_DAT0_FX(value uint32) {
	volatile.StoreUint32(&o.FIR_DAT0_FX.Reg, value)
}
func (o *FSP_Type) GetFIR_DAT0_FX() uint32 {
	return volatile.LoadUint32(&o.FIR_DAT0_FX.Reg)
}

// FSP.FIR_DAT1_FX: FIR channel 1 fix point data input &amp; output register
func (o *FSP_Type) SetFIR_DAT1_FX(value uint32) {
	volatile.StoreUint32(&o.FIR_DAT1_FX.Reg, value)
}
func (o *FSP_Type) GetFIR_DAT1_FX() uint32 {
	return volatile.LoadUint32(&o.FIR_DAT1_FX.Reg)
}

// FSP.FIR_DAT2_FX: FIR channel 2 fix point data input &amp; output register
func (o *FSP_Type) SetFIR_DAT2_FX(value uint32) {
	volatile.StoreUint32(&o.FIR_DAT2_FX.Reg, value)
}
func (o *FSP_Type) GetFIR_DAT2_FX() uint32 {
	return volatile.LoadUint32(&o.FIR_DAT2_FX.Reg)
}

// FSP.FIR_DAT3_FX: FIR channel 3 fix point data input &amp; output register
func (o *FSP_Type) SetFIR_DAT3_FX(value uint32) {
	volatile.StoreUint32(&o.FIR_DAT3_FX.Reg, value)
}
func (o *FSP_Type) GetFIR_DAT3_FX() uint32 {
	return volatile.LoadUint32(&o.FIR_DAT3_FX.Reg)
}

// FSP.FIR_DAT4_FX: FIR channel 4 fix point data input &amp; output register
func (o *FSP_Type) SetFIR_DAT4_FX(value uint32) {
	volatile.StoreUint32(&o.FIR_DAT4_FX.Reg, value)
}
func (o *FSP_Type) GetFIR_DAT4_FX() uint32 {
	return volatile.LoadUint32(&o.FIR_DAT4_FX.Reg)
}

// FSP.FIR_DAT5_FX: FIR channel 5 fix point data input &amp; output register
func (o *FSP_Type) SetFIR_DAT5_FX(value uint32) {
	volatile.StoreUint32(&o.FIR_DAT5_FX.Reg, value)
}
func (o *FSP_Type) GetFIR_DAT5_FX() uint32 {
	return volatile.LoadUint32(&o.FIR_DAT5_FX.Reg)
}

// FSP.FIR_DAT6_FX: FIR channel 6 fix point data input &amp; output register
func (o *FSP_Type) SetFIR_DAT6_FX(value uint32) {
	volatile.StoreUint32(&o.FIR_DAT6_FX.Reg, value)
}
func (o *FSP_Type) GetFIR_DAT6_FX() uint32 {
	return volatile.LoadUint32(&o.FIR_DAT6_FX.Reg)
}

// FSP.FIR_DAT7_FX: FIR channel 7 fix point data input &amp; output register
func (o *FSP_Type) SetFIR_DAT7_FX(value uint32) {
	volatile.StoreUint32(&o.FIR_DAT7_FX.Reg, value)
}
func (o *FSP_Type) GetFIR_DAT7_FX() uint32 {
	return volatile.LoadUint32(&o.FIR_DAT7_FX.Reg)
}

// FSP.FIR_DAT8_FX: FIR channel 8 fix point data input &amp; output register
func (o *FSP_Type) SetFIR_DAT8_FX(value uint32) {
	volatile.StoreUint32(&o.FIR_DAT8_FX.Reg, value)
}
func (o *FSP_Type) GetFIR_DAT8_FX() uint32 {
	return volatile.LoadUint32(&o.FIR_DAT8_FX.Reg)
}

// FSP.FIR_DAT0_FL: FIR channel 0 float point data input &amp; output register
func (o *FSP_Type) SetFIR_DAT0_FL(value uint32) {
	volatile.StoreUint32(&o.FIR_DAT0_FL.Reg, value)
}
func (o *FSP_Type) GetFIR_DAT0_FL() uint32 {
	return volatile.LoadUint32(&o.FIR_DAT0_FL.Reg)
}

// FSP.FIR_DAT1_FL: FIR channel 1 float point data input &amp; output register
func (o *FSP_Type) SetFIR_DAT1_FL(value uint32) {
	volatile.StoreUint32(&o.FIR_DAT1_FL.Reg, value)
}
func (o *FSP_Type) GetFIR_DAT1_FL() uint32 {
	return volatile.LoadUint32(&o.FIR_DAT1_FL.Reg)
}

// FSP.FIR_DAT2_FL: FIR channel 2 float point data input &amp; output register
func (o *FSP_Type) SetFIR_DAT2_FL(value uint32) {
	volatile.StoreUint32(&o.FIR_DAT2_FL.Reg, value)
}
func (o *FSP_Type) GetFIR_DAT2_FL() uint32 {
	return volatile.LoadUint32(&o.FIR_DAT2_FL.Reg)
}

// FSP.FIR_DAT3_FL: FIR channel 3 float point data input &amp; output register
func (o *FSP_Type) SetFIR_DAT3_FL(value uint32) {
	volatile.StoreUint32(&o.FIR_DAT3_FL.Reg, value)
}
func (o *FSP_Type) GetFIR_DAT3_FL() uint32 {
	return volatile.LoadUint32(&o.FIR_DAT3_FL.Reg)
}

// FSP.FIR_DAT4_FL: FIR channel 4 float point data input &amp; output register
func (o *FSP_Type) SetFIR_DAT4_FL(value uint32) {
	volatile.StoreUint32(&o.FIR_DAT4_FL.Reg, value)
}
func (o *FSP_Type) GetFIR_DAT4_FL() uint32 {
	return volatile.LoadUint32(&o.FIR_DAT4_FL.Reg)
}

// FSP.FIR_DAT5_FL: FIR channel 5 float point data input &amp; output register
func (o *FSP_Type) SetFIR_DAT5_FL(value uint32) {
	volatile.StoreUint32(&o.FIR_DAT5_FL.Reg, value)
}
func (o *FSP_Type) GetFIR_DAT5_FL() uint32 {
	return volatile.LoadUint32(&o.FIR_DAT5_FL.Reg)
}

// FSP.FIR_DAT6_FL: FIR channel 6 float point data input &amp; output register
func (o *FSP_Type) SetFIR_DAT6_FL(value uint32) {
	volatile.StoreUint32(&o.FIR_DAT6_FL.Reg, value)
}
func (o *FSP_Type) GetFIR_DAT6_FL() uint32 {
	return volatile.LoadUint32(&o.FIR_DAT6_FL.Reg)
}

// FSP.FIR_DAT7_FL: FIR channel 7 float point data input &amp; output register
func (o *FSP_Type) SetFIR_DAT7_FL(value uint32) {
	volatile.StoreUint32(&o.FIR_DAT7_FL.Reg, value)
}
func (o *FSP_Type) GetFIR_DAT7_FL() uint32 {
	return volatile.LoadUint32(&o.FIR_DAT7_FL.Reg)
}

// FSP.FIR_DAT8_FL: FIR channel 8 float point data input &amp; output register
func (o *FSP_Type) SetFIR_DAT8_FL(value uint32) {
	volatile.StoreUint32(&o.FIR_DAT8_FL.Reg, value)
}
func (o *FSP_Type) GetFIR_DAT8_FL() uint32 {
	return volatile.LoadUint32(&o.FIR_DAT8_FL.Reg)
}

// FSP.SIN_COS_IXOX: sin &amp; cos input fix output fix mode data address register
func (o *FSP_Type) SetSIN_COS_IXOX_SIN_COS_IXOX_SRC(value uint32) {
	volatile.StoreUint32(&o.SIN_COS_IXOX.Reg, volatile.LoadUint32(&o.SIN_COS_IXOX.Reg)&^(0xffff)|value)
}
func (o *FSP_Type) GetSIN_COS_IXOX_SIN_COS_IXOX_SRC() uint32 {
	return volatile.LoadUint32(&o.SIN_COS_IXOX.Reg) & 0xffff
}
func (o *FSP_Type) SetSIN_COS_IXOX_SIN_COS_IXOX_DST(value uint32) {
	volatile.StoreUint32(&o.SIN_COS_IXOX.Reg, volatile.LoadUint32(&o.SIN_COS_IXOX.Reg)&^(0xffff0000)|value<<16)
}
func (o *FSP_Type) GetSIN_COS_IXOX_SIN_COS_IXOX_DST() uint32 {
	return (volatile.LoadUint32(&o.SIN_COS_IXOX.Reg) & 0xffff0000) >> 16
}

// FSP.SIN_COS_IXOL: sin &amp; cos input fix output float mode data address register
func (o *FSP_Type) SetSIN_COS_IXOL_SIN_COS_IXOL_SRC(value uint32) {
	volatile.StoreUint32(&o.SIN_COS_IXOL.Reg, volatile.LoadUint32(&o.SIN_COS_IXOL.Reg)&^(0xffff)|value)
}
func (o *FSP_Type) GetSIN_COS_IXOL_SIN_COS_IXOL_SRC() uint32 {
	return volatile.LoadUint32(&o.SIN_COS_IXOL.Reg) & 0xffff
}
func (o *FSP_Type) SetSIN_COS_IXOL_SIN_COS_IXOL_DST(value uint32) {
	volatile.StoreUint32(&o.SIN_COS_IXOL.Reg, volatile.LoadUint32(&o.SIN_COS_IXOL.Reg)&^(0xffff0000)|value<<16)
}
func (o *FSP_Type) GetSIN_COS_IXOL_SIN_COS_IXOL_DST() uint32 {
	return (volatile.LoadUint32(&o.SIN_COS_IXOL.Reg) & 0xffff0000) >> 16
}

// FSP.SIN_COS_ILOX: sin &amp; cos input float output fix mode data address register
func (o *FSP_Type) SetSIN_COS_ILOX_SIN_COS_ILOX_SRC(value uint32) {
	volatile.StoreUint32(&o.SIN_COS_ILOX.Reg, volatile.LoadUint32(&o.SIN_COS_ILOX.Reg)&^(0xffff)|value)
}
func (o *FSP_Type) GetSIN_COS_ILOX_SIN_COS_ILOX_SRC() uint32 {
	return volatile.LoadUint32(&o.SIN_COS_ILOX.Reg) & 0xffff
}
func (o *FSP_Type) SetSIN_COS_ILOX_SIN_COS_ILOX_DST(value uint32) {
	volatile.StoreUint32(&o.SIN_COS_ILOX.Reg, volatile.LoadUint32(&o.SIN_COS_ILOX.Reg)&^(0xffff0000)|value<<16)
}
func (o *FSP_Type) GetSIN_COS_ILOX_SIN_COS_ILOX_DST() uint32 {
	return (volatile.LoadUint32(&o.SIN_COS_ILOX.Reg) & 0xffff0000) >> 16
}

// FSP.SIN_COS_ILOL: sin &amp; cos input float output float mode data address register
func (o *FSP_Type) SetSIN_COS_ILOL_SIN_COS_ILOL_SRC(value uint32) {
	volatile.StoreUint32(&o.SIN_COS_ILOL.Reg, volatile.LoadUint32(&o.SIN_COS_ILOL.Reg)&^(0xffff)|value)
}
func (o *FSP_Type) GetSIN_COS_ILOL_SIN_COS_ILOL_SRC() uint32 {
	return volatile.LoadUint32(&o.SIN_COS_ILOL.Reg) & 0xffff
}
func (o *FSP_Type) SetSIN_COS_ILOL_SIN_COS_ILOL_DST(value uint32) {
	volatile.StoreUint32(&o.SIN_COS_ILOL.Reg, volatile.LoadUint32(&o.SIN_COS_ILOL.Reg)&^(0xffff0000)|value<<16)
}
func (o *FSP_Type) GetSIN_COS_ILOL_SIN_COS_ILOL_DST() uint32 {
	return (volatile.LoadUint32(&o.SIN_COS_ILOL.Reg) & 0xffff0000) >> 16
}

// FSP.LN_SQRT_IXOX: LN &amp; sqrt input fix output fix mode data address register
func (o *FSP_Type) SetLN_SQRT_IXOX_LN_SQRT_IXOX_SRC(value uint32) {
	volatile.StoreUint32(&o.LN_SQRT_IXOX.Reg, volatile.LoadUint32(&o.LN_SQRT_IXOX.Reg)&^(0xffff)|value)
}
func (o *FSP_Type) GetLN_SQRT_IXOX_LN_SQRT_IXOX_SRC() uint32 {
	return volatile.LoadUint32(&o.LN_SQRT_IXOX.Reg) & 0xffff
}
func (o *FSP_Type) SetLN_SQRT_IXOX_LN_SQRT_IXOX_DST(value uint32) {
	volatile.StoreUint32(&o.LN_SQRT_IXOX.Reg, volatile.LoadUint32(&o.LN_SQRT_IXOX.Reg)&^(0xffff0000)|value<<16)
}
func (o *FSP_Type) GetLN_SQRT_IXOX_LN_SQRT_IXOX_DST() uint32 {
	return (volatile.LoadUint32(&o.LN_SQRT_IXOX.Reg) & 0xffff0000) >> 16
}

// FSP.LN_SQRT_IXOL: LN &amp; sqrt input fix output float mode data address register
func (o *FSP_Type) SetLN_SQRT_IXOL_LN_SQRT_IXOL_SRC(value uint32) {
	volatile.StoreUint32(&o.LN_SQRT_IXOL.Reg, volatile.LoadUint32(&o.LN_SQRT_IXOL.Reg)&^(0xffff)|value)
}
func (o *FSP_Type) GetLN_SQRT_IXOL_LN_SQRT_IXOL_SRC() uint32 {
	return volatile.LoadUint32(&o.LN_SQRT_IXOL.Reg) & 0xffff
}
func (o *FSP_Type) SetLN_SQRT_IXOL_LN_SQRT_IXOL_DST(value uint32) {
	volatile.StoreUint32(&o.LN_SQRT_IXOL.Reg, volatile.LoadUint32(&o.LN_SQRT_IXOL.Reg)&^(0xffff0000)|value<<16)
}
func (o *FSP_Type) GetLN_SQRT_IXOL_LN_SQRT_IXOL_DST() uint32 {
	return (volatile.LoadUint32(&o.LN_SQRT_IXOL.Reg) & 0xffff0000) >> 16
}

// FSP.LN_SQRT_ILOX: LN &amp; sqrt input float output fix mode data address register
func (o *FSP_Type) SetLN_SQRT_ILOX_LN_SQRT_ILOX_SRC(value uint32) {
	volatile.StoreUint32(&o.LN_SQRT_ILOX.Reg, volatile.LoadUint32(&o.LN_SQRT_ILOX.Reg)&^(0xffff)|value)
}
func (o *FSP_Type) GetLN_SQRT_ILOX_LN_SQRT_ILOX_SRC() uint32 {
	return volatile.LoadUint32(&o.LN_SQRT_ILOX.Reg) & 0xffff
}
func (o *FSP_Type) SetLN_SQRT_ILOX_LN_SQRT_ILOX_DST(value uint32) {
	volatile.StoreUint32(&o.LN_SQRT_ILOX.Reg, volatile.LoadUint32(&o.LN_SQRT_ILOX.Reg)&^(0xffff0000)|value<<16)
}
func (o *FSP_Type) GetLN_SQRT_ILOX_LN_SQRT_ILOX_DST() uint32 {
	return (volatile.LoadUint32(&o.LN_SQRT_ILOX.Reg) & 0xffff0000) >> 16
}

// FSP.LN_SQRT_ILOL: LN &amp; sqrt input float output float mode data address register
func (o *FSP_Type) SetLN_SQRT_ILOL_LN_SQRT_ILOL_SRC(value uint32) {
	volatile.StoreUint32(&o.LN_SQRT_ILOL.Reg, volatile.LoadUint32(&o.LN_SQRT_ILOL.Reg)&^(0xffff)|value)
}
func (o *FSP_Type) GetLN_SQRT_ILOL_LN_SQRT_ILOL_SRC() uint32 {
	return volatile.LoadUint32(&o.LN_SQRT_ILOL.Reg) & 0xffff
}
func (o *FSP_Type) SetLN_SQRT_ILOL_LN_SQRT_ILOL_DST(value uint32) {
	volatile.StoreUint32(&o.LN_SQRT_ILOL.Reg, volatile.LoadUint32(&o.LN_SQRT_ILOL.Reg)&^(0xffff0000)|value<<16)
}
func (o *FSP_Type) GetLN_SQRT_ILOL_LN_SQRT_ILOL_DST() uint32 {
	return (volatile.LoadUint32(&o.LN_SQRT_ILOL.Reg) & 0xffff0000) >> 16
}

// FSP.CORDIC_T0UP_IXOX: native cordic input fix output fix, t=0, u=1 mode data address register
func (o *FSP_Type) SetCORDIC_T0UP_IXOX_CORDIC_T0UP_IXOX_SRC(value uint32) {
	volatile.StoreUint32(&o.CORDIC_T0UP_IXOX.Reg, volatile.LoadUint32(&o.CORDIC_T0UP_IXOX.Reg)&^(0xffff)|value)
}
func (o *FSP_Type) GetCORDIC_T0UP_IXOX_CORDIC_T0UP_IXOX_SRC() uint32 {
	return volatile.LoadUint32(&o.CORDIC_T0UP_IXOX.Reg) & 0xffff
}
func (o *FSP_Type) SetCORDIC_T0UP_IXOX_CORDIC_T0UP_IXOX_DST(value uint32) {
	volatile.StoreUint32(&o.CORDIC_T0UP_IXOX.Reg, volatile.LoadUint32(&o.CORDIC_T0UP_IXOX.Reg)&^(0xffff0000)|value<<16)
}
func (o *FSP_Type) GetCORDIC_T0UP_IXOX_CORDIC_T0UP_IXOX_DST() uint32 {
	return (volatile.LoadUint32(&o.CORDIC_T0UP_IXOX.Reg) & 0xffff0000) >> 16
}

// FSP.CORDIC_T0UP_IXOL: native cordic input fix output float, t=0, u=1 mode data address register
func (o *FSP_Type) SetCORDIC_T0UP_IXOL_CORDIC_T0UP_IXOL_SRC(value uint32) {
	volatile.StoreUint32(&o.CORDIC_T0UP_IXOL.Reg, volatile.LoadUint32(&o.CORDIC_T0UP_IXOL.Reg)&^(0xffff)|value)
}
func (o *FSP_Type) GetCORDIC_T0UP_IXOL_CORDIC_T0UP_IXOL_SRC() uint32 {
	return volatile.LoadUint32(&o.CORDIC_T0UP_IXOL.Reg) & 0xffff
}
func (o *FSP_Type) SetCORDIC_T0UP_IXOL_CORDIC_T0UP_IXOL_DST(value uint32) {
	volatile.StoreUint32(&o.CORDIC_T0UP_IXOL.Reg, volatile.LoadUint32(&o.CORDIC_T0UP_IXOL.Reg)&^(0xffff0000)|value<<16)
}
func (o *FSP_Type) GetCORDIC_T0UP_IXOL_CORDIC_T0UP_IXOL_DST() uint32 {
	return (volatile.LoadUint32(&o.CORDIC_T0UP_IXOL.Reg) & 0xffff0000) >> 16
}

// FSP.CORDIC_T0UP_ILOX: native cordic input float output fix, t=0, u=1 mode data address register
func (o *FSP_Type) SetCORDIC_T0UP_ILOX_CORDIC_T0UP_ILOX_SRC(value uint32) {
	volatile.StoreUint32(&o.CORDIC_T0UP_ILOX.Reg, volatile.LoadUint32(&o.CORDIC_T0UP_ILOX.Reg)&^(0xffff)|value)
}
func (o *FSP_Type) GetCORDIC_T0UP_ILOX_CORDIC_T0UP_ILOX_SRC() uint32 {
	return volatile.LoadUint32(&o.CORDIC_T0UP_ILOX.Reg) & 0xffff
}
func (o *FSP_Type) SetCORDIC_T0UP_ILOX_CORDIC_T0UP_ILOX_DST(value uint32) {
	volatile.StoreUint32(&o.CORDIC_T0UP_ILOX.Reg, volatile.LoadUint32(&o.CORDIC_T0UP_ILOX.Reg)&^(0xffff0000)|value<<16)
}
func (o *FSP_Type) GetCORDIC_T0UP_ILOX_CORDIC_T0UP_ILOX_DST() uint32 {
	return (volatile.LoadUint32(&o.CORDIC_T0UP_ILOX.Reg) & 0xffff0000) >> 16
}

// FSP.CORDIC_T0UP_ILOL: native cordic input float output float, t=0, u=1 mode data address register
func (o *FSP_Type) SetCORDIC_T0UP_ILOL_CORDIC_T0UP_ILOL_SRC(value uint32) {
	volatile.StoreUint32(&o.CORDIC_T0UP_ILOL.Reg, volatile.LoadUint32(&o.CORDIC_T0UP_ILOL.Reg)&^(0xffff)|value)
}
func (o *FSP_Type) GetCORDIC_T0UP_ILOL_CORDIC_T0UP_ILOL_SRC() uint32 {
	return volatile.LoadUint32(&o.CORDIC_T0UP_ILOL.Reg) & 0xffff
}
func (o *FSP_Type) SetCORDIC_T0UP_ILOL_CORDIC_T0UP_ILOL_DST(value uint32) {
	volatile.StoreUint32(&o.CORDIC_T0UP_ILOL.Reg, volatile.LoadUint32(&o.CORDIC_T0UP_ILOL.Reg)&^(0xffff0000)|value<<16)
}
func (o *FSP_Type) GetCORDIC_T0UP_ILOL_CORDIC_T0UP_ILOL_DST() uint32 {
	return (volatile.LoadUint32(&o.CORDIC_T0UP_ILOL.Reg) & 0xffff0000) >> 16
}

// FSP.CORDIC_T0UN_IXOX: native cordic input fix output fix, t=0, u=-1 mode data address register
func (o *FSP_Type) SetCORDIC_T0UN_IXOX_CORDIC_T0UN_IXOX_SRC(value uint32) {
	volatile.StoreUint32(&o.CORDIC_T0UN_IXOX.Reg, volatile.LoadUint32(&o.CORDIC_T0UN_IXOX.Reg)&^(0xffff)|value)
}
func (o *FSP_Type) GetCORDIC_T0UN_IXOX_CORDIC_T0UN_IXOX_SRC() uint32 {
	return volatile.LoadUint32(&o.CORDIC_T0UN_IXOX.Reg) & 0xffff
}
func (o *FSP_Type) SetCORDIC_T0UN_IXOX_CORDIC_T0UN_IXOX_DST(value uint32) {
	volatile.StoreUint32(&o.CORDIC_T0UN_IXOX.Reg, volatile.LoadUint32(&o.CORDIC_T0UN_IXOX.Reg)&^(0xffff0000)|value<<16)
}
func (o *FSP_Type) GetCORDIC_T0UN_IXOX_CORDIC_T0UN_IXOX_DST() uint32 {
	return (volatile.LoadUint32(&o.CORDIC_T0UN_IXOX.Reg) & 0xffff0000) >> 16
}

// FSP.CORDIC_T0UN_IXOL: native cordic input fix output float, t=0, u=-1 mode data address register
func (o *FSP_Type) SetCORDIC_T0UN_IXOL_CORDIC_T0UN_IXOL_SRC(value uint32) {
	volatile.StoreUint32(&o.CORDIC_T0UN_IXOL.Reg, volatile.LoadUint32(&o.CORDIC_T0UN_IXOL.Reg)&^(0xffff)|value)
}
func (o *FSP_Type) GetCORDIC_T0UN_IXOL_CORDIC_T0UN_IXOL_SRC() uint32 {
	return volatile.LoadUint32(&o.CORDIC_T0UN_IXOL.Reg) & 0xffff
}
func (o *FSP_Type) SetCORDIC_T0UN_IXOL_CORDIC_T0UN_IXOL_DST(value uint32) {
	volatile.StoreUint32(&o.CORDIC_T0UN_IXOL.Reg, volatile.LoadUint32(&o.CORDIC_T0UN_IXOL.Reg)&^(0xffff0000)|value<<16)
}
func (o *FSP_Type) GetCORDIC_T0UN_IXOL_CORDIC_T0UN_IXOL_DST() uint32 {
	return (volatile.LoadUint32(&o.CORDIC_T0UN_IXOL.Reg) & 0xffff0000) >> 16
}

// FSP.CORDIC_T0UN_ILOX: native cordic input float output fix, t=0, u=-1 mode data address register
func (o *FSP_Type) SetCORDIC_T0UN_ILOX_CORDIC_T0UN_ILOX_SRC(value uint32) {
	volatile.StoreUint32(&o.CORDIC_T0UN_ILOX.Reg, volatile.LoadUint32(&o.CORDIC_T0UN_ILOX.Reg)&^(0xffff)|value)
}
func (o *FSP_Type) GetCORDIC_T0UN_ILOX_CORDIC_T0UN_ILOX_SRC() uint32 {
	return volatile.LoadUint32(&o.CORDIC_T0UN_ILOX.Reg) & 0xffff
}
func (o *FSP_Type) SetCORDIC_T0UN_ILOX_CORDIC_T0UN_ILOX_DST(value uint32) {
	volatile.StoreUint32(&o.CORDIC_T0UN_ILOX.Reg, volatile.LoadUint32(&o.CORDIC_T0UN_ILOX.Reg)&^(0xffff0000)|value<<16)
}
func (o *FSP_Type) GetCORDIC_T0UN_ILOX_CORDIC_T0UN_ILOX_DST() uint32 {
	return (volatile.LoadUint32(&o.CORDIC_T0UN_ILOX.Reg) & 0xffff0000) >> 16
}

// FSP.CORDIC_T0UN_ILOL: native cordic input float output float, t=0, u=-1 mode data address register
func (o *FSP_Type) SetCORDIC_T0UN_ILOL_CORDIC_T0UN_ILOL_SRC(value uint32) {
	volatile.StoreUint32(&o.CORDIC_T0UN_ILOL.Reg, volatile.LoadUint32(&o.CORDIC_T0UN_ILOL.Reg)&^(0xffff)|value)
}
func (o *FSP_Type) GetCORDIC_T0UN_ILOL_CORDIC_T0UN_ILOL_SRC() uint32 {
	return volatile.LoadUint32(&o.CORDIC_T0UN_ILOL.Reg) & 0xffff
}
func (o *FSP_Type) SetCORDIC_T0UN_ILOL_CORDIC_T0UN_ILOL_DST(value uint32) {
	volatile.StoreUint32(&o.CORDIC_T0UN_ILOL.Reg, volatile.LoadUint32(&o.CORDIC_T0UN_ILOL.Reg)&^(0xffff0000)|value<<16)
}
func (o *FSP_Type) GetCORDIC_T0UN_ILOL_CORDIC_T0UN_ILOL_DST() uint32 {
	return (volatile.LoadUint32(&o.CORDIC_T0UN_ILOL.Reg) & 0xffff0000) >> 16
}

// FSP.CORDIC_T1UP_IXOX: native cordic input fix output fix, t=1, u=1 mode data address register
func (o *FSP_Type) SetCORDIC_T1UP_IXOX_CORDIC_T1UP_IXOX_SRC(value uint32) {
	volatile.StoreUint32(&o.CORDIC_T1UP_IXOX.Reg, volatile.LoadUint32(&o.CORDIC_T1UP_IXOX.Reg)&^(0xffff)|value)
}
func (o *FSP_Type) GetCORDIC_T1UP_IXOX_CORDIC_T1UP_IXOX_SRC() uint32 {
	return volatile.LoadUint32(&o.CORDIC_T1UP_IXOX.Reg) & 0xffff
}
func (o *FSP_Type) SetCORDIC_T1UP_IXOX_CORDIC_T1UP_IXOX_DST(value uint32) {
	volatile.StoreUint32(&o.CORDIC_T1UP_IXOX.Reg, volatile.LoadUint32(&o.CORDIC_T1UP_IXOX.Reg)&^(0xffff0000)|value<<16)
}
func (o *FSP_Type) GetCORDIC_T1UP_IXOX_CORDIC_T1UP_IXOX_DST() uint32 {
	return (volatile.LoadUint32(&o.CORDIC_T1UP_IXOX.Reg) & 0xffff0000) >> 16
}

// FSP.CORDIC_T1UP_IXOL: native cordic input fix output float, t=1, u=1 mode data address register
func (o *FSP_Type) SetCORDIC_T1UP_IXOL_CORDIC_T1UP_IXOL_SRC(value uint32) {
	volatile.StoreUint32(&o.CORDIC_T1UP_IXOL.Reg, volatile.LoadUint32(&o.CORDIC_T1UP_IXOL.Reg)&^(0xffff)|value)
}
func (o *FSP_Type) GetCORDIC_T1UP_IXOL_CORDIC_T1UP_IXOL_SRC() uint32 {
	return volatile.LoadUint32(&o.CORDIC_T1UP_IXOL.Reg) & 0xffff
}
func (o *FSP_Type) SetCORDIC_T1UP_IXOL_CORDIC_T1UP_IXOL_DST(value uint32) {
	volatile.StoreUint32(&o.CORDIC_T1UP_IXOL.Reg, volatile.LoadUint32(&o.CORDIC_T1UP_IXOL.Reg)&^(0xffff0000)|value<<16)
}
func (o *FSP_Type) GetCORDIC_T1UP_IXOL_CORDIC_T1UP_IXOL_DST() uint32 {
	return (volatile.LoadUint32(&o.CORDIC_T1UP_IXOL.Reg) & 0xffff0000) >> 16
}

// FSP.CORDIC_T1UP_ILOX: native cordic input float output fix, t=1, u=1 mode data address register
func (o *FSP_Type) SetCORDIC_T1UP_ILOX_CORDIC_T1UP_ILOX_SRC(value uint32) {
	volatile.StoreUint32(&o.CORDIC_T1UP_ILOX.Reg, volatile.LoadUint32(&o.CORDIC_T1UP_ILOX.Reg)&^(0xffff)|value)
}
func (o *FSP_Type) GetCORDIC_T1UP_ILOX_CORDIC_T1UP_ILOX_SRC() uint32 {
	return volatile.LoadUint32(&o.CORDIC_T1UP_ILOX.Reg) & 0xffff
}
func (o *FSP_Type) SetCORDIC_T1UP_ILOX_CORDIC_T1UP_ILOX_DST(value uint32) {
	volatile.StoreUint32(&o.CORDIC_T1UP_ILOX.Reg, volatile.LoadUint32(&o.CORDIC_T1UP_ILOX.Reg)&^(0xffff0000)|value<<16)
}
func (o *FSP_Type) GetCORDIC_T1UP_ILOX_CORDIC_T1UP_ILOX_DST() uint32 {
	return (volatile.LoadUint32(&o.CORDIC_T1UP_ILOX.Reg) & 0xffff0000) >> 16
}

// FSP.CORDIC_T1UP_ILOL: native cordic input float output float, t=1, u=1 mode data address register
func (o *FSP_Type) SetCORDIC_T1UP_ILOL_CORDIC_T1UP_ILOL_SRC(value uint32) {
	volatile.StoreUint32(&o.CORDIC_T1UP_ILOL.Reg, volatile.LoadUint32(&o.CORDIC_T1UP_ILOL.Reg)&^(0xffff)|value)
}
func (o *FSP_Type) GetCORDIC_T1UP_ILOL_CORDIC_T1UP_ILOL_SRC() uint32 {
	return volatile.LoadUint32(&o.CORDIC_T1UP_ILOL.Reg) & 0xffff
}
func (o *FSP_Type) SetCORDIC_T1UP_ILOL_CORDIC_T1UP_ILOL_DST(value uint32) {
	volatile.StoreUint32(&o.CORDIC_T1UP_ILOL.Reg, volatile.LoadUint32(&o.CORDIC_T1UP_ILOL.Reg)&^(0xffff0000)|value<<16)
}
func (o *FSP_Type) GetCORDIC_T1UP_ILOL_CORDIC_T1UP_ILOL_DST() uint32 {
	return (volatile.LoadUint32(&o.CORDIC_T1UP_ILOL.Reg) & 0xffff0000) >> 16
}

// FSP.CORDIC_T1UN_IXOX: native cordic input fix output fix, t=1, u=-1 mode data address register
func (o *FSP_Type) SetCORDIC_T1UN_IXOX_CORDIC_T1UN_IXOX_SRC(value uint32) {
	volatile.StoreUint32(&o.CORDIC_T1UN_IXOX.Reg, volatile.LoadUint32(&o.CORDIC_T1UN_IXOX.Reg)&^(0xffff)|value)
}
func (o *FSP_Type) GetCORDIC_T1UN_IXOX_CORDIC_T1UN_IXOX_SRC() uint32 {
	return volatile.LoadUint32(&o.CORDIC_T1UN_IXOX.Reg) & 0xffff
}
func (o *FSP_Type) SetCORDIC_T1UN_IXOX_CORDIC_T1UN_IXOX_DST(value uint32) {
	volatile.StoreUint32(&o.CORDIC_T1UN_IXOX.Reg, volatile.LoadUint32(&o.CORDIC_T1UN_IXOX.Reg)&^(0xffff0000)|value<<16)
}
func (o *FSP_Type) GetCORDIC_T1UN_IXOX_CORDIC_T1UN_IXOX_DST() uint32 {
	return (volatile.LoadUint32(&o.CORDIC_T1UN_IXOX.Reg) & 0xffff0000) >> 16
}

// FSP.CORDIC_T1UN_IXOL: native cordic input fix output float, t=1, u=-1 mode data address register
func (o *FSP_Type) SetCORDIC_T1UN_IXOL_CORDIC_T1UN_IXOL_SRC(value uint32) {
	volatile.StoreUint32(&o.CORDIC_T1UN_IXOL.Reg, volatile.LoadUint32(&o.CORDIC_T1UN_IXOL.Reg)&^(0xffff)|value)
}
func (o *FSP_Type) GetCORDIC_T1UN_IXOL_CORDIC_T1UN_IXOL_SRC() uint32 {
	return volatile.LoadUint32(&o.CORDIC_T1UN_IXOL.Reg) & 0xffff
}
func (o *FSP_Type) SetCORDIC_T1UN_IXOL_CORDIC_T1UN_IXOL_DST(value uint32) {
	volatile.StoreUint32(&o.CORDIC_T1UN_IXOL.Reg, volatile.LoadUint32(&o.CORDIC_T1UN_IXOL.Reg)&^(0xffff0000)|value<<16)
}
func (o *FSP_Type) GetCORDIC_T1UN_IXOL_CORDIC_T1UN_IXOL_DST() uint32 {
	return (volatile.LoadUint32(&o.CORDIC_T1UN_IXOL.Reg) & 0xffff0000) >> 16
}

// FSP.CORDIC_T1UN_ILOX: native cordic input float output fix, t=1, u=-1 mode data address register
func (o *FSP_Type) SetCORDIC_T1UN_ILOX_CORDIC_T1UN_ILOX_SRC(value uint32) {
	volatile.StoreUint32(&o.CORDIC_T1UN_ILOX.Reg, volatile.LoadUint32(&o.CORDIC_T1UN_ILOX.Reg)&^(0xffff)|value)
}
func (o *FSP_Type) GetCORDIC_T1UN_ILOX_CORDIC_T1UN_ILOX_SRC() uint32 {
	return volatile.LoadUint32(&o.CORDIC_T1UN_ILOX.Reg) & 0xffff
}
func (o *FSP_Type) SetCORDIC_T1UN_ILOX_CORDIC_T1UN_ILOX_DST(value uint32) {
	volatile.StoreUint32(&o.CORDIC_T1UN_ILOX.Reg, volatile.LoadUint32(&o.CORDIC_T1UN_ILOX.Reg)&^(0xffff0000)|value<<16)
}
func (o *FSP_Type) GetCORDIC_T1UN_ILOX_CORDIC_T1UN_ILOX_DST() uint32 {
	return (volatile.LoadUint32(&o.CORDIC_T1UN_ILOX.Reg) & 0xffff0000) >> 16
}

// FSP.CORDIC_T1UN_ILOL: native cordic input float output float, t=1, u=-1 mode data address register
func (o *FSP_Type) SetCORDIC_T1UN_ILOL_CORDIC_T1UN_ILOL_SRC(value uint32) {
	volatile.StoreUint32(&o.CORDIC_T1UN_ILOL.Reg, volatile.LoadUint32(&o.CORDIC_T1UN_ILOL.Reg)&^(0xffff)|value)
}
func (o *FSP_Type) GetCORDIC_T1UN_ILOL_CORDIC_T1UN_ILOL_SRC() uint32 {
	return volatile.LoadUint32(&o.CORDIC_T1UN_ILOL.Reg) & 0xffff
}
func (o *FSP_Type) SetCORDIC_T1UN_ILOL_CORDIC_T1UN_ILOL_DST(value uint32) {
	volatile.StoreUint32(&o.CORDIC_T1UN_ILOL.Reg, volatile.LoadUint32(&o.CORDIC_T1UN_ILOL.Reg)&^(0xffff0000)|value<<16)
}
func (o *FSP_Type) GetCORDIC_T1UN_ILOL_CORDIC_T1UN_ILOL_DST() uint32 {
	return (volatile.LoadUint32(&o.CORDIC_T1UN_ILOL.Reg) & 0xffff0000) >> 16
}

// gpio
type GPIO_Type struct {
	DATA       volatile.Register32 // 0x0
	DATAOUT    volatile.Register32 // 0x4
	_          [8]byte
	OUTENSET   volatile.Register32 // 0x10
	OUTENCLR   volatile.Register32 // 0x14
	_          [8]byte
	INTENSET   volatile.Register32 // 0x20
	INTENCLR   volatile.Register32 // 0x24
	INTTYPESET volatile.Register32 // 0x28
	INTTYPECLR volatile.Register32 // 0x2C
	INTPOLSET  volatile.Register32 // 0x30
	INTPOLCLR  volatile.Register32 // 0x34
	INTSTATUS  volatile.Register32 // 0x38
}

// GPIO.DATA: GPIO value register
func (o *GPIO_Type) SetDATA(value uint32) {
	volatile.StoreUint32(&o.DATA.Reg, value)
}
func (o *GPIO_Type) GetDATA() uint32 {
	return volatile.LoadUint32(&o.DATA.Reg)
}

// GPIO.DATAOUT: GPIO output status register
func (o *GPIO_Type) SetDATAOUT(value uint32) {
	volatile.StoreUint32(&o.DATAOUT.Reg, value)
}
func (o *GPIO_Type) GetDATAOUT() uint32 {
	return volatile.LoadUint32(&o.DATAOUT.Reg)
}

// GPIO.OUTENSET: GPIO output enable set register
func (o *GPIO_Type) SetOUTENSET(value uint32) {
	volatile.StoreUint32(&o.OUTENSET.Reg, value)
}
func (o *GPIO_Type) GetOUTENSET() uint32 {
	return volatile.LoadUint32(&o.OUTENSET.Reg)
}

// GPIO.OUTENCLR: GPIO output clear register
func (o *GPIO_Type) SetOUTENCLR(value uint32) {
	volatile.StoreUint32(&o.OUTENCLR.Reg, value)
}
func (o *GPIO_Type) GetOUTENCLR() uint32 {
	return volatile.LoadUint32(&o.OUTENCLR.Reg)
}

// GPIO.INTENSET: GPIO interrupt enable set register
func (o *GPIO_Type) SetINTENSET(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, value)
}
func (o *GPIO_Type) GetINTENSET() uint32 {
	return volatile.LoadUint32(&o.INTENSET.Reg)
}

// GPIO.INTENCLR: GPIO interrupt enable clear register
func (o *GPIO_Type) SetINTENCLR(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, value)
}
func (o *GPIO_Type) GetINTENCLR() uint32 {
	return volatile.LoadUint32(&o.INTENCLR.Reg)
}

// GPIO.INTTYPESET: GPIO interrupt type set register
func (o *GPIO_Type) SetINTTYPESET(value uint32) {
	volatile.StoreUint32(&o.INTTYPESET.Reg, value)
}
func (o *GPIO_Type) GetINTTYPESET() uint32 {
	return volatile.LoadUint32(&o.INTTYPESET.Reg)
}

// GPIO.INTTYPECLR: GPIO interrupt type set register
func (o *GPIO_Type) SetINTTYPECLR(value uint32) {
	volatile.StoreUint32(&o.INTTYPECLR.Reg, value)
}
func (o *GPIO_Type) GetINTTYPECLR() uint32 {
	return volatile.LoadUint32(&o.INTTYPECLR.Reg)
}

// GPIO.INTPOLSET: GPIO interrupt polarity set register
func (o *GPIO_Type) SetINTPOLSET(value uint32) {
	volatile.StoreUint32(&o.INTPOLSET.Reg, value)
}
func (o *GPIO_Type) GetINTPOLSET() uint32 {
	return volatile.LoadUint32(&o.INTPOLSET.Reg)
}

// GPIO.INTPOLCLR: GPIO interrupt polarity clear register
func (o *GPIO_Type) SetINTPOLCLR(value uint32) {
	volatile.StoreUint32(&o.INTPOLCLR.Reg, value)
}
func (o *GPIO_Type) GetINTPOLCLR() uint32 {
	return volatile.LoadUint32(&o.INTPOLCLR.Reg)
}

// GPIO.INTSTATUS: GPIO interrupt status register
func (o *GPIO_Type) SetINTSTATUS(value uint32) {
	volatile.StoreUint32(&o.INTSTATUS.Reg, value)
}
func (o *GPIO_Type) GetINTSTATUS() uint32 {
	return volatile.LoadUint32(&o.INTSTATUS.Reg)
}

// crc
type CRC_Type struct {
	MODE volatile.Register32 // 0x0
	SEED volatile.Register32 // 0x4
	SUM  volatile.Register32 // 0x8
}

// CRC.MODE: CRC mode register
func (o *CRC_Type) SetMODE_CRC_POLY(value uint32) {
	volatile.StoreUint32(&o.MODE.Reg, volatile.LoadUint32(&o.MODE.Reg)&^(0x3)|value)
}
func (o *CRC_Type) GetMODE_CRC_POLY() uint32 {
	return volatile.LoadUint32(&o.MODE.Reg) & 0x3
}
func (o *CRC_Type) SetMODE_BIT_RVS_WR(value uint32) {
	volatile.StoreUint32(&o.MODE.Reg, volatile.LoadUint32(&o.MODE.Reg)&^(0x4)|value<<2)
}
func (o *CRC_Type) GetMODE_BIT_RVS_WR() uint32 {
	return (volatile.LoadUint32(&o.MODE.Reg) & 0x4) >> 2
}
func (o *CRC_Type) SetMODE_CMPL_WR(value uint32) {
	volatile.StoreUint32(&o.MODE.Reg, volatile.LoadUint32(&o.MODE.Reg)&^(0x8)|value<<3)
}
func (o *CRC_Type) GetMODE_CMPL_WR() uint32 {
	return (volatile.LoadUint32(&o.MODE.Reg) & 0x8) >> 3
}
func (o *CRC_Type) SetMODE_BIT_RVS_SUM(value uint32) {
	volatile.StoreUint32(&o.MODE.Reg, volatile.LoadUint32(&o.MODE.Reg)&^(0x10)|value<<4)
}
func (o *CRC_Type) GetMODE_BIT_RVS_SUM() uint32 {
	return (volatile.LoadUint32(&o.MODE.Reg) & 0x10) >> 4
}
func (o *CRC_Type) SetMODE_CMPL_SUM(value uint32) {
	volatile.StoreUint32(&o.MODE.Reg, volatile.LoadUint32(&o.MODE.Reg)&^(0x20)|value<<5)
}
func (o *CRC_Type) GetMODE_CMPL_SUM() uint32 {
	return (volatile.LoadUint32(&o.MODE.Reg) & 0x20) >> 5
}

// CRC.SEED: CRC seed register
func (o *CRC_Type) SetSEED(value uint32) {
	volatile.StoreUint32(&o.SEED.Reg, value)
}
func (o *CRC_Type) GetSEED() uint32 {
	return volatile.LoadUint32(&o.SEED.Reg)
}

// CRC.SUM: CRC checksum register
func (o *CRC_Type) SetSUM(value uint32) {
	volatile.StoreUint32(&o.SUM.Reg, value)
}
func (o *CRC_Type) GetSUM() uint32 {
	return volatile.LoadUint32(&o.SUM.Reg)
}

// Constants for SYSCON: syscon
const (
	// RST_SW_SET: block software reset set register
	// Position of SET_FC0_RST field.
	SYSCON_RST_SW_SET_SET_FC0_RST_Pos = 0x0
	// Bit mask of SET_FC0_RST field.
	SYSCON_RST_SW_SET_SET_FC0_RST_Msk = 0x1
	// Bit SET_FC0_RST.
	SYSCON_RST_SW_SET_SET_FC0_RST = 0x1
	// Position of SET_FC1_RST field.
	SYSCON_RST_SW_SET_SET_FC1_RST_Pos = 0x1
	// Bit mask of SET_FC1_RST field.
	SYSCON_RST_SW_SET_SET_FC1_RST_Msk = 0x2
	// Bit SET_FC1_RST.
	SYSCON_RST_SW_SET_SET_FC1_RST = 0x2
	// Position of SET_FC2_RST field.
	SYSCON_RST_SW_SET_SET_FC2_RST_Pos = 0x2
	// Bit mask of SET_FC2_RST field.
	SYSCON_RST_SW_SET_SET_FC2_RST_Msk = 0x4
	// Bit SET_FC2_RST.
	SYSCON_RST_SW_SET_SET_FC2_RST = 0x4
	// Position of SET_FC3_RST field.
	SYSCON_RST_SW_SET_SET_FC3_RST_Pos = 0x3
	// Bit mask of SET_FC3_RST field.
	SYSCON_RST_SW_SET_SET_FC3_RST_Msk = 0x8
	// Bit SET_FC3_RST.
	SYSCON_RST_SW_SET_SET_FC3_RST = 0x8
	// Position of SET_TIM0_RST field.
	SYSCON_RST_SW_SET_SET_TIM0_RST_Pos = 0x4
	// Bit mask of SET_TIM0_RST field.
	SYSCON_RST_SW_SET_SET_TIM0_RST_Msk = 0x10
	// Bit SET_TIM0_RST.
	SYSCON_RST_SW_SET_SET_TIM0_RST = 0x10
	// Position of SET_TIM1_RST field.
	SYSCON_RST_SW_SET_SET_TIM1_RST_Pos = 0x5
	// Bit mask of SET_TIM1_RST field.
	SYSCON_RST_SW_SET_SET_TIM1_RST_Msk = 0x20
	// Bit SET_TIM1_RST.
	SYSCON_RST_SW_SET_SET_TIM1_RST = 0x20
	// Position of SET_TIM2_RST field.
	SYSCON_RST_SW_SET_SET_TIM2_RST_Pos = 0x6
	// Bit mask of SET_TIM2_RST field.
	SYSCON_RST_SW_SET_SET_TIM2_RST_Msk = 0x40
	// Bit SET_TIM2_RST.
	SYSCON_RST_SW_SET_SET_TIM2_RST = 0x40
	// Position of SET_TIM3_RST field.
	SYSCON_RST_SW_SET_SET_TIM3_RST_Pos = 0x7
	// Bit mask of SET_TIM3_RST field.
	SYSCON_RST_SW_SET_SET_TIM3_RST_Msk = 0x80
	// Bit SET_TIM3_RST.
	SYSCON_RST_SW_SET_SET_TIM3_RST = 0x80
	// Position of SET_SCT_RST field.
	SYSCON_RST_SW_SET_SET_SCT_RST_Pos = 0x8
	// Bit mask of SET_SCT_RST field.
	SYSCON_RST_SW_SET_SET_SCT_RST_Msk = 0x100
	// Bit SET_SCT_RST.
	SYSCON_RST_SW_SET_SET_SCT_RST = 0x100
	// Position of SET_WDT_RST field.
	SYSCON_RST_SW_SET_SET_WDT_RST_Pos = 0x9
	// Bit mask of SET_WDT_RST field.
	SYSCON_RST_SW_SET_SET_WDT_RST_Msk = 0x200
	// Bit SET_WDT_RST.
	SYSCON_RST_SW_SET_SET_WDT_RST = 0x200
	// Position of SET_USB_RST field.
	SYSCON_RST_SW_SET_SET_USB_RST_Pos = 0xa
	// Bit mask of SET_USB_RST field.
	SYSCON_RST_SW_SET_SET_USB_RST_Msk = 0x400
	// Bit SET_USB_RST.
	SYSCON_RST_SW_SET_SET_USB_RST = 0x400
	// Position of SET_GPIO_RST field.
	SYSCON_RST_SW_SET_SET_GPIO_RST_Pos = 0xb
	// Bit mask of SET_GPIO_RST field.
	SYSCON_RST_SW_SET_SET_GPIO_RST_Msk = 0x800
	// Bit SET_GPIO_RST.
	SYSCON_RST_SW_SET_SET_GPIO_RST = 0x800
	// Position of SET_RTC_RST field.
	SYSCON_RST_SW_SET_SET_RTC_RST_Pos = 0xc
	// Bit mask of SET_RTC_RST field.
	SYSCON_RST_SW_SET_SET_RTC_RST_Msk = 0x1000
	// Bit SET_RTC_RST.
	SYSCON_RST_SW_SET_SET_RTC_RST = 0x1000
	// Position of SET_ADC_RST field.
	SYSCON_RST_SW_SET_SET_ADC_RST_Pos = 0xd
	// Bit mask of SET_ADC_RST field.
	SYSCON_RST_SW_SET_SET_ADC_RST_Msk = 0x2000
	// Bit SET_ADC_RST.
	SYSCON_RST_SW_SET_SET_ADC_RST = 0x2000
	// Position of SET_DAC_RST field.
	SYSCON_RST_SW_SET_SET_DAC_RST_Pos = 0xe
	// Bit mask of SET_DAC_RST field.
	SYSCON_RST_SW_SET_SET_DAC_RST_Msk = 0x4000
	// Bit SET_DAC_RST.
	SYSCON_RST_SW_SET_SET_DAC_RST = 0x4000
	// Position of SET_CS_RST field.
	SYSCON_RST_SW_SET_SET_CS_RST_Pos = 0xf
	// Bit mask of SET_CS_RST field.
	SYSCON_RST_SW_SET_SET_CS_RST_Msk = 0x8000
	// Bit SET_CS_RST.
	SYSCON_RST_SW_SET_SET_CS_RST = 0x8000
	// Position of SET_FSP_RST field.
	SYSCON_RST_SW_SET_SET_FSP_RST_Pos = 0x10
	// Bit mask of SET_FSP_RST field.
	SYSCON_RST_SW_SET_SET_FSP_RST_Msk = 0x10000
	// Bit SET_FSP_RST.
	SYSCON_RST_SW_SET_SET_FSP_RST = 0x10000
	// Position of SET_DMA_RST field.
	SYSCON_RST_SW_SET_SET_DMA_RST_Pos = 0x11
	// Bit mask of SET_DMA_RST field.
	SYSCON_RST_SW_SET_SET_DMA_RST_Msk = 0x20000
	// Bit SET_DMA_RST.
	SYSCON_RST_SW_SET_SET_DMA_RST = 0x20000
	// Position of SET_QDEC0_RST field.
	SYSCON_RST_SW_SET_SET_QDEC0_RST_Pos = 0x13
	// Bit mask of SET_QDEC0_RST field.
	SYSCON_RST_SW_SET_SET_QDEC0_RST_Msk = 0x80000
	// Bit SET_QDEC0_RST.
	SYSCON_RST_SW_SET_SET_QDEC0_RST = 0x80000
	// Position of SET_QDEC1_RST field.
	SYSCON_RST_SW_SET_SET_QDEC1_RST_Pos = 0x14
	// Bit mask of SET_QDEC1_RST field.
	SYSCON_RST_SW_SET_SET_QDEC1_RST_Msk = 0x100000
	// Bit SET_QDEC1_RST.
	SYSCON_RST_SW_SET_SET_QDEC1_RST = 0x100000
	// Position of SET_SPIFI_RST field.
	SYSCON_RST_SW_SET_SET_SPIFI_RST_Pos = 0x16
	// Bit mask of SET_SPIFI_RST field.
	SYSCON_RST_SW_SET_SET_SPIFI_RST_Msk = 0x400000
	// Bit SET_SPIFI_RST.
	SYSCON_RST_SW_SET_SET_SPIFI_RST = 0x400000
	// Position of SET_CPU_RST field.
	SYSCON_RST_SW_SET_SET_CPU_RST_Pos = 0x1a
	// Bit mask of SET_CPU_RST field.
	SYSCON_RST_SW_SET_SET_CPU_RST_Msk = 0x4000000
	// Bit SET_CPU_RST.
	SYSCON_RST_SW_SET_SET_CPU_RST = 0x4000000
	// Position of SET_BLE_RST field.
	SYSCON_RST_SW_SET_SET_BLE_RST_Pos = 0x1b
	// Bit mask of SET_BLE_RST field.
	SYSCON_RST_SW_SET_SET_BLE_RST_Msk = 0x8000000
	// Bit SET_BLE_RST.
	SYSCON_RST_SW_SET_SET_BLE_RST = 0x8000000
	// Position of SET_FLASH_RST field.
	SYSCON_RST_SW_SET_SET_FLASH_RST_Pos = 0x1c
	// Bit mask of SET_FLASH_RST field.
	SYSCON_RST_SW_SET_SET_FLASH_RST_Msk = 0x10000000
	// Bit SET_FLASH_RST.
	SYSCON_RST_SW_SET_SET_FLASH_RST = 0x10000000
	// Position of SET_DP_RST field.
	SYSCON_RST_SW_SET_SET_DP_RST_Pos = 0x1d
	// Bit mask of SET_DP_RST field.
	SYSCON_RST_SW_SET_SET_DP_RST_Msk = 0x20000000
	// Bit SET_DP_RST.
	SYSCON_RST_SW_SET_SET_DP_RST = 0x20000000
	// Position of SET_REG_RST field.
	SYSCON_RST_SW_SET_SET_REG_RST_Pos = 0x1e
	// Bit mask of SET_REG_RST field.
	SYSCON_RST_SW_SET_SET_REG_RST_Msk = 0x40000000
	// Bit SET_REG_RST.
	SYSCON_RST_SW_SET_SET_REG_RST = 0x40000000
	// Position of SET_REBOOT field.
	SYSCON_RST_SW_SET_SET_REBOOT_Pos = 0x1f
	// Bit mask of SET_REBOOT field.
	SYSCON_RST_SW_SET_SET_REBOOT_Msk = 0x80000000
	// Bit SET_REBOOT.
	SYSCON_RST_SW_SET_SET_REBOOT = 0x80000000

	// RST_SW_CLR: block software reset clear register
	// Position of CLR_FC0_RST field.
	SYSCON_RST_SW_CLR_CLR_FC0_RST_Pos = 0x0
	// Bit mask of CLR_FC0_RST field.
	SYSCON_RST_SW_CLR_CLR_FC0_RST_Msk = 0x1
	// Bit CLR_FC0_RST.
	SYSCON_RST_SW_CLR_CLR_FC0_RST = 0x1
	// Position of CLR_FC1_RST field.
	SYSCON_RST_SW_CLR_CLR_FC1_RST_Pos = 0x1
	// Bit mask of CLR_FC1_RST field.
	SYSCON_RST_SW_CLR_CLR_FC1_RST_Msk = 0x2
	// Bit CLR_FC1_RST.
	SYSCON_RST_SW_CLR_CLR_FC1_RST = 0x2
	// Position of CLR_FC2_RST field.
	SYSCON_RST_SW_CLR_CLR_FC2_RST_Pos = 0x2
	// Bit mask of CLR_FC2_RST field.
	SYSCON_RST_SW_CLR_CLR_FC2_RST_Msk = 0x4
	// Bit CLR_FC2_RST.
	SYSCON_RST_SW_CLR_CLR_FC2_RST = 0x4
	// Position of CLR_FC3_RST field.
	SYSCON_RST_SW_CLR_CLR_FC3_RST_Pos = 0x3
	// Bit mask of CLR_FC3_RST field.
	SYSCON_RST_SW_CLR_CLR_FC3_RST_Msk = 0x8
	// Bit CLR_FC3_RST.
	SYSCON_RST_SW_CLR_CLR_FC3_RST = 0x8
	// Position of CLR_TIM0_RST field.
	SYSCON_RST_SW_CLR_CLR_TIM0_RST_Pos = 0x4
	// Bit mask of CLR_TIM0_RST field.
	SYSCON_RST_SW_CLR_CLR_TIM0_RST_Msk = 0x10
	// Bit CLR_TIM0_RST.
	SYSCON_RST_SW_CLR_CLR_TIM0_RST = 0x10
	// Position of CLR_TIM1_RST field.
	SYSCON_RST_SW_CLR_CLR_TIM1_RST_Pos = 0x5
	// Bit mask of CLR_TIM1_RST field.
	SYSCON_RST_SW_CLR_CLR_TIM1_RST_Msk = 0x20
	// Bit CLR_TIM1_RST.
	SYSCON_RST_SW_CLR_CLR_TIM1_RST = 0x20
	// Position of CLR_TIM2_RST field.
	SYSCON_RST_SW_CLR_CLR_TIM2_RST_Pos = 0x6
	// Bit mask of CLR_TIM2_RST field.
	SYSCON_RST_SW_CLR_CLR_TIM2_RST_Msk = 0x40
	// Bit CLR_TIM2_RST.
	SYSCON_RST_SW_CLR_CLR_TIM2_RST = 0x40
	// Position of CLR_TIM3_RST field.
	SYSCON_RST_SW_CLR_CLR_TIM3_RST_Pos = 0x7
	// Bit mask of CLR_TIM3_RST field.
	SYSCON_RST_SW_CLR_CLR_TIM3_RST_Msk = 0x80
	// Bit CLR_TIM3_RST.
	SYSCON_RST_SW_CLR_CLR_TIM3_RST = 0x80
	// Position of CLR_SCT_RST field.
	SYSCON_RST_SW_CLR_CLR_SCT_RST_Pos = 0x8
	// Bit mask of CLR_SCT_RST field.
	SYSCON_RST_SW_CLR_CLR_SCT_RST_Msk = 0x100
	// Bit CLR_SCT_RST.
	SYSCON_RST_SW_CLR_CLR_SCT_RST = 0x100
	// Position of CLR_WDT_RST field.
	SYSCON_RST_SW_CLR_CLR_WDT_RST_Pos = 0x9
	// Bit mask of CLR_WDT_RST field.
	SYSCON_RST_SW_CLR_CLR_WDT_RST_Msk = 0x200
	// Bit CLR_WDT_RST.
	SYSCON_RST_SW_CLR_CLR_WDT_RST = 0x200
	// Position of CLR_USB_RST field.
	SYSCON_RST_SW_CLR_CLR_USB_RST_Pos = 0xa
	// Bit mask of CLR_USB_RST field.
	SYSCON_RST_SW_CLR_CLR_USB_RST_Msk = 0x400
	// Bit CLR_USB_RST.
	SYSCON_RST_SW_CLR_CLR_USB_RST = 0x400
	// Position of CLR_GPIO_RST field.
	SYSCON_RST_SW_CLR_CLR_GPIO_RST_Pos = 0xb
	// Bit mask of CLR_GPIO_RST field.
	SYSCON_RST_SW_CLR_CLR_GPIO_RST_Msk = 0x800
	// Bit CLR_GPIO_RST.
	SYSCON_RST_SW_CLR_CLR_GPIO_RST = 0x800
	// Position of CLR_RTC_RST field.
	SYSCON_RST_SW_CLR_CLR_RTC_RST_Pos = 0xc
	// Bit mask of CLR_RTC_RST field.
	SYSCON_RST_SW_CLR_CLR_RTC_RST_Msk = 0x1000
	// Bit CLR_RTC_RST.
	SYSCON_RST_SW_CLR_CLR_RTC_RST = 0x1000
	// Position of CLR_ADC_RST field.
	SYSCON_RST_SW_CLR_CLR_ADC_RST_Pos = 0xd
	// Bit mask of CLR_ADC_RST field.
	SYSCON_RST_SW_CLR_CLR_ADC_RST_Msk = 0x2000
	// Bit CLR_ADC_RST.
	SYSCON_RST_SW_CLR_CLR_ADC_RST = 0x2000
	// Position of CLR_DAC_RST field.
	SYSCON_RST_SW_CLR_CLR_DAC_RST_Pos = 0xe
	// Bit mask of CLR_DAC_RST field.
	SYSCON_RST_SW_CLR_CLR_DAC_RST_Msk = 0x4000
	// Bit CLR_DAC_RST.
	SYSCON_RST_SW_CLR_CLR_DAC_RST = 0x4000
	// Position of CLR_CS_RST field.
	SYSCON_RST_SW_CLR_CLR_CS_RST_Pos = 0xf
	// Bit mask of CLR_CS_RST field.
	SYSCON_RST_SW_CLR_CLR_CS_RST_Msk = 0x8000
	// Bit CLR_CS_RST.
	SYSCON_RST_SW_CLR_CLR_CS_RST = 0x8000
	// Position of CLR_FSP_RST field.
	SYSCON_RST_SW_CLR_CLR_FSP_RST_Pos = 0x10
	// Bit mask of CLR_FSP_RST field.
	SYSCON_RST_SW_CLR_CLR_FSP_RST_Msk = 0x10000
	// Bit CLR_FSP_RST.
	SYSCON_RST_SW_CLR_CLR_FSP_RST = 0x10000
	// Position of CLR_DMA_RST field.
	SYSCON_RST_SW_CLR_CLR_DMA_RST_Pos = 0x11
	// Bit mask of CLR_DMA_RST field.
	SYSCON_RST_SW_CLR_CLR_DMA_RST_Msk = 0x20000
	// Bit CLR_DMA_RST.
	SYSCON_RST_SW_CLR_CLR_DMA_RST = 0x20000
	// Position of CLR_QDEC0_RST field.
	SYSCON_RST_SW_CLR_CLR_QDEC0_RST_Pos = 0x13
	// Bit mask of CLR_QDEC0_RST field.
	SYSCON_RST_SW_CLR_CLR_QDEC0_RST_Msk = 0x80000
	// Bit CLR_QDEC0_RST.
	SYSCON_RST_SW_CLR_CLR_QDEC0_RST = 0x80000
	// Position of CLR_QDEC1_RST field.
	SYSCON_RST_SW_CLR_CLR_QDEC1_RST_Pos = 0x14
	// Bit mask of CLR_QDEC1_RST field.
	SYSCON_RST_SW_CLR_CLR_QDEC1_RST_Msk = 0x100000
	// Bit CLR_QDEC1_RST.
	SYSCON_RST_SW_CLR_CLR_QDEC1_RST = 0x100000
	// Position of CLR_SPIFI_RST field.
	SYSCON_RST_SW_CLR_CLR_SPIFI_RST_Pos = 0x16
	// Bit mask of CLR_SPIFI_RST field.
	SYSCON_RST_SW_CLR_CLR_SPIFI_RST_Msk = 0x400000
	// Bit CLR_SPIFI_RST.
	SYSCON_RST_SW_CLR_CLR_SPIFI_RST = 0x400000
	// Position of CLR_CPU_RST field.
	SYSCON_RST_SW_CLR_CLR_CPU_RST_Pos = 0x1a
	// Bit mask of CLR_CPU_RST field.
	SYSCON_RST_SW_CLR_CLR_CPU_RST_Msk = 0x4000000
	// Bit CLR_CPU_RST.
	SYSCON_RST_SW_CLR_CLR_CPU_RST = 0x4000000
	// Position of CLR_BLE_RST field.
	SYSCON_RST_SW_CLR_CLR_BLE_RST_Pos = 0x1b
	// Bit mask of CLR_BLE_RST field.
	SYSCON_RST_SW_CLR_CLR_BLE_RST_Msk = 0x8000000
	// Bit CLR_BLE_RST.
	SYSCON_RST_SW_CLR_CLR_BLE_RST = 0x8000000
	// Position of CLR_FLASH_RST field.
	SYSCON_RST_SW_CLR_CLR_FLASH_RST_Pos = 0x1c
	// Bit mask of CLR_FLASH_RST field.
	SYSCON_RST_SW_CLR_CLR_FLASH_RST_Msk = 0x10000000
	// Bit CLR_FLASH_RST.
	SYSCON_RST_SW_CLR_CLR_FLASH_RST = 0x10000000
	// Position of CLR_DP_RST field.
	SYSCON_RST_SW_CLR_CLR_DP_RST_Pos = 0x1d
	// Bit mask of CLR_DP_RST field.
	SYSCON_RST_SW_CLR_CLR_DP_RST_Msk = 0x20000000
	// Bit CLR_DP_RST.
	SYSCON_RST_SW_CLR_CLR_DP_RST = 0x20000000
	// Position of CLR_REG_RST field.
	SYSCON_RST_SW_CLR_CLR_REG_RST_Pos = 0x1e
	// Bit mask of CLR_REG_RST field.
	SYSCON_RST_SW_CLR_CLR_REG_RST_Msk = 0x40000000
	// Bit CLR_REG_RST.
	SYSCON_RST_SW_CLR_CLR_REG_RST = 0x40000000

	// CLK_DIS: clock disable register
	// Position of CLK_FC0_DIS field.
	SYSCON_CLK_DIS_CLK_FC0_DIS_Pos = 0x0
	// Bit mask of CLK_FC0_DIS field.
	SYSCON_CLK_DIS_CLK_FC0_DIS_Msk = 0x1
	// Bit CLK_FC0_DIS.
	SYSCON_CLK_DIS_CLK_FC0_DIS = 0x1
	// Position of CLK_FC1_DIS field.
	SYSCON_CLK_DIS_CLK_FC1_DIS_Pos = 0x1
	// Bit mask of CLK_FC1_DIS field.
	SYSCON_CLK_DIS_CLK_FC1_DIS_Msk = 0x2
	// Bit CLK_FC1_DIS.
	SYSCON_CLK_DIS_CLK_FC1_DIS = 0x2
	// Position of CLK_FC2_DIS field.
	SYSCON_CLK_DIS_CLK_FC2_DIS_Pos = 0x2
	// Bit mask of CLK_FC2_DIS field.
	SYSCON_CLK_DIS_CLK_FC2_DIS_Msk = 0x4
	// Bit CLK_FC2_DIS.
	SYSCON_CLK_DIS_CLK_FC2_DIS = 0x4
	// Position of CLK_FC3_DIS field.
	SYSCON_CLK_DIS_CLK_FC3_DIS_Pos = 0x3
	// Bit mask of CLK_FC3_DIS field.
	SYSCON_CLK_DIS_CLK_FC3_DIS_Msk = 0x8
	// Bit CLK_FC3_DIS.
	SYSCON_CLK_DIS_CLK_FC3_DIS = 0x8
	// Position of CLK_TIM0_DIS field.
	SYSCON_CLK_DIS_CLK_TIM0_DIS_Pos = 0x4
	// Bit mask of CLK_TIM0_DIS field.
	SYSCON_CLK_DIS_CLK_TIM0_DIS_Msk = 0x10
	// Bit CLK_TIM0_DIS.
	SYSCON_CLK_DIS_CLK_TIM0_DIS = 0x10
	// Position of CLK_TIM1_DIS field.
	SYSCON_CLK_DIS_CLK_TIM1_DIS_Pos = 0x5
	// Bit mask of CLK_TIM1_DIS field.
	SYSCON_CLK_DIS_CLK_TIM1_DIS_Msk = 0x20
	// Bit CLK_TIM1_DIS.
	SYSCON_CLK_DIS_CLK_TIM1_DIS = 0x20
	// Position of CLK_TIM2_DIS field.
	SYSCON_CLK_DIS_CLK_TIM2_DIS_Pos = 0x6
	// Bit mask of CLK_TIM2_DIS field.
	SYSCON_CLK_DIS_CLK_TIM2_DIS_Msk = 0x40
	// Bit CLK_TIM2_DIS.
	SYSCON_CLK_DIS_CLK_TIM2_DIS = 0x40
	// Position of CLK_TIM3_DIS field.
	SYSCON_CLK_DIS_CLK_TIM3_DIS_Pos = 0x7
	// Bit mask of CLK_TIM3_DIS field.
	SYSCON_CLK_DIS_CLK_TIM3_DIS_Msk = 0x80
	// Bit CLK_TIM3_DIS.
	SYSCON_CLK_DIS_CLK_TIM3_DIS = 0x80
	// Position of CLK_SCT_DIS field.
	SYSCON_CLK_DIS_CLK_SCT_DIS_Pos = 0x8
	// Bit mask of CLK_SCT_DIS field.
	SYSCON_CLK_DIS_CLK_SCT_DIS_Msk = 0x100
	// Bit CLK_SCT_DIS.
	SYSCON_CLK_DIS_CLK_SCT_DIS = 0x100
	// Position of CLK_WDT_DIS field.
	SYSCON_CLK_DIS_CLK_WDT_DIS_Pos = 0x9
	// Bit mask of CLK_WDT_DIS field.
	SYSCON_CLK_DIS_CLK_WDT_DIS_Msk = 0x200
	// Bit CLK_WDT_DIS.
	SYSCON_CLK_DIS_CLK_WDT_DIS = 0x200
	// Position of CLK_USB_DIS field.
	SYSCON_CLK_DIS_CLK_USB_DIS_Pos = 0xa
	// Bit mask of CLK_USB_DIS field.
	SYSCON_CLK_DIS_CLK_USB_DIS_Msk = 0x400
	// Bit CLK_USB_DIS.
	SYSCON_CLK_DIS_CLK_USB_DIS = 0x400
	// Position of CLK_GPIO_DIS field.
	SYSCON_CLK_DIS_CLK_GPIO_DIS_Pos = 0xb
	// Bit mask of CLK_GPIO_DIS field.
	SYSCON_CLK_DIS_CLK_GPIO_DIS_Msk = 0x800
	// Bit CLK_GPIO_DIS.
	SYSCON_CLK_DIS_CLK_GPIO_DIS = 0x800
	// Position of CLK_BIV_DIS field.
	SYSCON_CLK_DIS_CLK_BIV_DIS_Pos = 0xc
	// Bit mask of CLK_BIV_DIS field.
	SYSCON_CLK_DIS_CLK_BIV_DIS_Msk = 0x1000
	// Bit CLK_BIV_DIS.
	SYSCON_CLK_DIS_CLK_BIV_DIS = 0x1000
	// Position of CLK_ADC_DIS field.
	SYSCON_CLK_DIS_CLK_ADC_DIS_Pos = 0xd
	// Bit mask of CLK_ADC_DIS field.
	SYSCON_CLK_DIS_CLK_ADC_DIS_Msk = 0x2000
	// Bit CLK_ADC_DIS.
	SYSCON_CLK_DIS_CLK_ADC_DIS = 0x2000
	// Position of CLK_DAC_DIS field.
	SYSCON_CLK_DIS_CLK_DAC_DIS_Pos = 0xe
	// Bit mask of CLK_DAC_DIS field.
	SYSCON_CLK_DIS_CLK_DAC_DIS_Msk = 0x4000
	// Bit CLK_DAC_DIS.
	SYSCON_CLK_DIS_CLK_DAC_DIS = 0x4000
	// Position of CLK_CS_DIS field.
	SYSCON_CLK_DIS_CLK_CS_DIS_Pos = 0xf
	// Bit mask of CLK_CS_DIS field.
	SYSCON_CLK_DIS_CLK_CS_DIS_Msk = 0x8000
	// Bit CLK_CS_DIS.
	SYSCON_CLK_DIS_CLK_CS_DIS = 0x8000
	// Position of CLK_FSP_DIS field.
	SYSCON_CLK_DIS_CLK_FSP_DIS_Pos = 0x10
	// Bit mask of CLK_FSP_DIS field.
	SYSCON_CLK_DIS_CLK_FSP_DIS_Msk = 0x10000
	// Bit CLK_FSP_DIS.
	SYSCON_CLK_DIS_CLK_FSP_DIS = 0x10000
	// Position of CLK_DMA_DIS field.
	SYSCON_CLK_DIS_CLK_DMA_DIS_Pos = 0x11
	// Bit mask of CLK_DMA_DIS field.
	SYSCON_CLK_DIS_CLK_DMA_DIS_Msk = 0x20000
	// Bit CLK_DMA_DIS.
	SYSCON_CLK_DIS_CLK_DMA_DIS = 0x20000
	// Position of CLK_QDEC0_DIS field.
	SYSCON_CLK_DIS_CLK_QDEC0_DIS_Pos = 0x13
	// Bit mask of CLK_QDEC0_DIS field.
	SYSCON_CLK_DIS_CLK_QDEC0_DIS_Msk = 0x80000
	// Bit CLK_QDEC0_DIS.
	SYSCON_CLK_DIS_CLK_QDEC0_DIS = 0x80000
	// Position of CLK_QDEC1_DIS field.
	SYSCON_CLK_DIS_CLK_QDEC1_DIS_Pos = 0x14
	// Bit mask of CLK_QDEC1_DIS field.
	SYSCON_CLK_DIS_CLK_QDEC1_DIS_Msk = 0x100000
	// Bit CLK_QDEC1_DIS.
	SYSCON_CLK_DIS_CLK_QDEC1_DIS = 0x100000
	// Position of CLK_DP_DIS field.
	SYSCON_CLK_DIS_CLK_DP_DIS_Pos = 0x15
	// Bit mask of CLK_DP_DIS field.
	SYSCON_CLK_DIS_CLK_DP_DIS_Msk = 0x200000
	// Bit CLK_DP_DIS.
	SYSCON_CLK_DIS_CLK_DP_DIS = 0x200000
	// Position of CLK_SPIFI_DIS field.
	SYSCON_CLK_DIS_CLK_SPIFI_DIS_Pos = 0x16
	// Bit mask of CLK_SPIFI_DIS field.
	SYSCON_CLK_DIS_CLK_SPIFI_DIS_Msk = 0x400000
	// Bit CLK_SPIFI_DIS.
	SYSCON_CLK_DIS_CLK_SPIFI_DIS = 0x400000
	// Position of CLK_CAL_DIS field.
	SYSCON_CLK_DIS_CLK_CAL_DIS_Pos = 0x19
	// Bit mask of CLK_CAL_DIS field.
	SYSCON_CLK_DIS_CLK_CAL_DIS_Msk = 0x2000000
	// Bit CLK_CAL_DIS.
	SYSCON_CLK_DIS_CLK_CAL_DIS = 0x2000000
	// Position of CLK_BLE_DIS field.
	SYSCON_CLK_DIS_CLK_BLE_DIS_Pos = 0x1b
	// Bit mask of CLK_BLE_DIS field.
	SYSCON_CLK_DIS_CLK_BLE_DIS_Msk = 0x8000000
	// Bit CLK_BLE_DIS.
	SYSCON_CLK_DIS_CLK_BLE_DIS = 0x8000000
	// Position of PCLK_DIS field.
	SYSCON_CLK_DIS_PCLK_DIS_Pos = 0x1e
	// Bit mask of PCLK_DIS field.
	SYSCON_CLK_DIS_PCLK_DIS_Msk = 0x40000000
	// Bit PCLK_DIS.
	SYSCON_CLK_DIS_PCLK_DIS = 0x40000000
	// Position of FCLK_DIS field.
	SYSCON_CLK_DIS_FCLK_DIS_Pos = 0x1f
	// Bit mask of FCLK_DIS field.
	SYSCON_CLK_DIS_FCLK_DIS_Msk = 0x80000000
	// Bit FCLK_DIS.
	SYSCON_CLK_DIS_FCLK_DIS = 0x80000000

	// CLK_EN: clock enable register
	// Position of CLK_FC0_EN field.
	SYSCON_CLK_EN_CLK_FC0_EN_Pos = 0x0
	// Bit mask of CLK_FC0_EN field.
	SYSCON_CLK_EN_CLK_FC0_EN_Msk = 0x1
	// Bit CLK_FC0_EN.
	SYSCON_CLK_EN_CLK_FC0_EN = 0x1
	// Position of CLK_FC1_EN field.
	SYSCON_CLK_EN_CLK_FC1_EN_Pos = 0x1
	// Bit mask of CLK_FC1_EN field.
	SYSCON_CLK_EN_CLK_FC1_EN_Msk = 0x2
	// Bit CLK_FC1_EN.
	SYSCON_CLK_EN_CLK_FC1_EN = 0x2
	// Position of CLK_FC2_EN field.
	SYSCON_CLK_EN_CLK_FC2_EN_Pos = 0x2
	// Bit mask of CLK_FC2_EN field.
	SYSCON_CLK_EN_CLK_FC2_EN_Msk = 0x4
	// Bit CLK_FC2_EN.
	SYSCON_CLK_EN_CLK_FC2_EN = 0x4
	// Position of CLK_FC3_EN field.
	SYSCON_CLK_EN_CLK_FC3_EN_Pos = 0x3
	// Bit mask of CLK_FC3_EN field.
	SYSCON_CLK_EN_CLK_FC3_EN_Msk = 0x8
	// Bit CLK_FC3_EN.
	SYSCON_CLK_EN_CLK_FC3_EN = 0x8
	// Position of CLK_TIM0_EN field.
	SYSCON_CLK_EN_CLK_TIM0_EN_Pos = 0x4
	// Bit mask of CLK_TIM0_EN field.
	SYSCON_CLK_EN_CLK_TIM0_EN_Msk = 0x10
	// Bit CLK_TIM0_EN.
	SYSCON_CLK_EN_CLK_TIM0_EN = 0x10
	// Position of CLK_TIM1_EN field.
	SYSCON_CLK_EN_CLK_TIM1_EN_Pos = 0x5
	// Bit mask of CLK_TIM1_EN field.
	SYSCON_CLK_EN_CLK_TIM1_EN_Msk = 0x20
	// Bit CLK_TIM1_EN.
	SYSCON_CLK_EN_CLK_TIM1_EN = 0x20
	// Position of CLK_TIM2_EN field.
	SYSCON_CLK_EN_CLK_TIM2_EN_Pos = 0x6
	// Bit mask of CLK_TIM2_EN field.
	SYSCON_CLK_EN_CLK_TIM2_EN_Msk = 0x40
	// Bit CLK_TIM2_EN.
	SYSCON_CLK_EN_CLK_TIM2_EN = 0x40
	// Position of CLK_TIM3_EN field.
	SYSCON_CLK_EN_CLK_TIM3_EN_Pos = 0x7
	// Bit mask of CLK_TIM3_EN field.
	SYSCON_CLK_EN_CLK_TIM3_EN_Msk = 0x80
	// Bit CLK_TIM3_EN.
	SYSCON_CLK_EN_CLK_TIM3_EN = 0x80
	// Position of CLK_SCT_EN field.
	SYSCON_CLK_EN_CLK_SCT_EN_Pos = 0x8
	// Bit mask of CLK_SCT_EN field.
	SYSCON_CLK_EN_CLK_SCT_EN_Msk = 0x100
	// Bit CLK_SCT_EN.
	SYSCON_CLK_EN_CLK_SCT_EN = 0x100
	// Position of CLK_WDT_EN field.
	SYSCON_CLK_EN_CLK_WDT_EN_Pos = 0x9
	// Bit mask of CLK_WDT_EN field.
	SYSCON_CLK_EN_CLK_WDT_EN_Msk = 0x200
	// Bit CLK_WDT_EN.
	SYSCON_CLK_EN_CLK_WDT_EN = 0x200
	// Position of CLK_USB_EN field.
	SYSCON_CLK_EN_CLK_USB_EN_Pos = 0xa
	// Bit mask of CLK_USB_EN field.
	SYSCON_CLK_EN_CLK_USB_EN_Msk = 0x400
	// Bit CLK_USB_EN.
	SYSCON_CLK_EN_CLK_USB_EN = 0x400
	// Position of CLK_GPIO_EN field.
	SYSCON_CLK_EN_CLK_GPIO_EN_Pos = 0xb
	// Bit mask of CLK_GPIO_EN field.
	SYSCON_CLK_EN_CLK_GPIO_EN_Msk = 0x800
	// Bit CLK_GPIO_EN.
	SYSCON_CLK_EN_CLK_GPIO_EN = 0x800
	// Position of CLK_BIV_EN field.
	SYSCON_CLK_EN_CLK_BIV_EN_Pos = 0xc
	// Bit mask of CLK_BIV_EN field.
	SYSCON_CLK_EN_CLK_BIV_EN_Msk = 0x1000
	// Bit CLK_BIV_EN.
	SYSCON_CLK_EN_CLK_BIV_EN = 0x1000
	// Position of CLK_ADC_EN field.
	SYSCON_CLK_EN_CLK_ADC_EN_Pos = 0xd
	// Bit mask of CLK_ADC_EN field.
	SYSCON_CLK_EN_CLK_ADC_EN_Msk = 0x2000
	// Bit CLK_ADC_EN.
	SYSCON_CLK_EN_CLK_ADC_EN = 0x2000
	// Position of CLK_DAC_EN field.
	SYSCON_CLK_EN_CLK_DAC_EN_Pos = 0xe
	// Bit mask of CLK_DAC_EN field.
	SYSCON_CLK_EN_CLK_DAC_EN_Msk = 0x4000
	// Bit CLK_DAC_EN.
	SYSCON_CLK_EN_CLK_DAC_EN = 0x4000
	// Position of CLK_CS_EN field.
	SYSCON_CLK_EN_CLK_CS_EN_Pos = 0xf
	// Bit mask of CLK_CS_EN field.
	SYSCON_CLK_EN_CLK_CS_EN_Msk = 0x8000
	// Bit CLK_CS_EN.
	SYSCON_CLK_EN_CLK_CS_EN = 0x8000
	// Position of CLK_FSP_EN field.
	SYSCON_CLK_EN_CLK_FSP_EN_Pos = 0x10
	// Bit mask of CLK_FSP_EN field.
	SYSCON_CLK_EN_CLK_FSP_EN_Msk = 0x10000
	// Bit CLK_FSP_EN.
	SYSCON_CLK_EN_CLK_FSP_EN = 0x10000
	// Position of CLK_DMA_EN field.
	SYSCON_CLK_EN_CLK_DMA_EN_Pos = 0x11
	// Bit mask of CLK_DMA_EN field.
	SYSCON_CLK_EN_CLK_DMA_EN_Msk = 0x20000
	// Bit CLK_DMA_EN.
	SYSCON_CLK_EN_CLK_DMA_EN = 0x20000
	// Position of CLK_QDEC0_EN field.
	SYSCON_CLK_EN_CLK_QDEC0_EN_Pos = 0x13
	// Bit mask of CLK_QDEC0_EN field.
	SYSCON_CLK_EN_CLK_QDEC0_EN_Msk = 0x80000
	// Bit CLK_QDEC0_EN.
	SYSCON_CLK_EN_CLK_QDEC0_EN = 0x80000
	// Position of CLK_QDEC1_EN field.
	SYSCON_CLK_EN_CLK_QDEC1_EN_Pos = 0x14
	// Bit mask of CLK_QDEC1_EN field.
	SYSCON_CLK_EN_CLK_QDEC1_EN_Msk = 0x100000
	// Bit CLK_QDEC1_EN.
	SYSCON_CLK_EN_CLK_QDEC1_EN = 0x100000
	// Position of CLK_DP_EN field.
	SYSCON_CLK_EN_CLK_DP_EN_Pos = 0x15
	// Bit mask of CLK_DP_EN field.
	SYSCON_CLK_EN_CLK_DP_EN_Msk = 0x200000
	// Bit CLK_DP_EN.
	SYSCON_CLK_EN_CLK_DP_EN = 0x200000
	// Position of CLK_SPIFI_EN field.
	SYSCON_CLK_EN_CLK_SPIFI_EN_Pos = 0x16
	// Bit mask of CLK_SPIFI_EN field.
	SYSCON_CLK_EN_CLK_SPIFI_EN_Msk = 0x400000
	// Bit CLK_SPIFI_EN.
	SYSCON_CLK_EN_CLK_SPIFI_EN = 0x400000
	// Position of CLK_CAL_EN field.
	SYSCON_CLK_EN_CLK_CAL_EN_Pos = 0x19
	// Bit mask of CLK_CAL_EN field.
	SYSCON_CLK_EN_CLK_CAL_EN_Msk = 0x2000000
	// Bit CLK_CAL_EN.
	SYSCON_CLK_EN_CLK_CAL_EN = 0x2000000
	// Position of CLK_BLE_EN field.
	SYSCON_CLK_EN_CLK_BLE_EN_Pos = 0x1b
	// Bit mask of CLK_BLE_EN field.
	SYSCON_CLK_EN_CLK_BLE_EN_Msk = 0x8000000
	// Bit CLK_BLE_EN.
	SYSCON_CLK_EN_CLK_BLE_EN = 0x8000000

	// CLK_CTRL: system clock source and divider register
	// Position of APB_DIV field.
	SYSCON_CLK_CTRL_APB_DIV_Pos = 0x0
	// Bit mask of APB_DIV field.
	SYSCON_CLK_CTRL_APB_DIV_Msk = 0xf
	// Position of AHB_DIV field.
	SYSCON_CLK_CTRL_AHB_DIV_Pos = 0x4
	// Bit mask of AHB_DIV field.
	SYSCON_CLK_CTRL_AHB_DIV_Msk = 0x1fff0
	// Position of CLK_BLE_SEL field.
	SYSCON_CLK_CTRL_CLK_BLE_SEL_Pos = 0x11
	// Bit mask of CLK_BLE_SEL field.
	SYSCON_CLK_CTRL_CLK_BLE_SEL_Msk = 0x20000
	// Bit CLK_BLE_SEL.
	SYSCON_CLK_CTRL_CLK_BLE_SEL = 0x20000
	// BLE run at 8M
	SYSCON_CLK_CTRL_CLK_BLE_SEL_CLK_BLE_SEL_8M = 0x0
	// BLE run at 16M
	SYSCON_CLK_CTRL_CLK_BLE_SEL_CLK_BLE_SEL_16M = 0x1
	// Position of CLK_WDT_SEL field.
	SYSCON_CLK_CTRL_CLK_WDT_SEL_Pos = 0x12
	// Bit mask of CLK_WDT_SEL field.
	SYSCON_CLK_CTRL_CLK_WDT_SEL_Msk = 0x40000
	// Bit CLK_WDT_SEL.
	SYSCON_CLK_CTRL_CLK_WDT_SEL = 0x40000
	// watch dog run at 32K
	SYSCON_CLK_CTRL_CLK_WDT_SEL_CLK_WDT_SEL_32K = 0x0
	// watch dog run at APB clock
	SYSCON_CLK_CTRL_CLK_WDT_SEL_APB = 0x1
	// Position of CLK_XTAL_SEL field.
	SYSCON_CLK_CTRL_CLK_XTAL_SEL_Pos = 0x13
	// Bit mask of CLK_XTAL_SEL field.
	SYSCON_CLK_CTRL_CLK_XTAL_SEL_Msk = 0x80000
	// Bit CLK_XTAL_SEL.
	SYSCON_CLK_CTRL_CLK_XTAL_SEL = 0x80000
	// external crystal is 16M
	SYSCON_CLK_CTRL_CLK_XTAL_SEL_XTAL16M = 0x0
	// external crystal is 32M
	SYSCON_CLK_CTRL_CLK_XTAL_SEL_XTAL32M = 0x1
	// Position of CLK_OSC32M_DIV field.
	SYSCON_CLK_CTRL_CLK_OSC32M_DIV_Pos = 0x14
	// Bit mask of CLK_OSC32M_DIV field.
	SYSCON_CLK_CTRL_CLK_OSC32M_DIV_Msk = 0x100000
	// Bit CLK_OSC32M_DIV.
	SYSCON_CLK_CTRL_CLK_OSC32M_DIV = 0x100000
	// use original 32M RCO clock
	SYSCON_CLK_CTRL_CLK_OSC32M_DIV_BY1 = 0x0
	// divide 32M OSC clock into 16M
	SYSCON_CLK_CTRL_CLK_OSC32M_DIV_BY2 = 0x1
	// Position of CLK_32K_SEL field.
	SYSCON_CLK_CTRL_CLK_32K_SEL_Pos = 0x15
	// Bit mask of CLK_32K_SEL field.
	SYSCON_CLK_CTRL_CLK_32K_SEL_Msk = 0x200000
	// Bit CLK_32K_SEL.
	SYSCON_CLK_CTRL_CLK_32K_SEL = 0x200000
	// digital 32K clock source is external 32K crystal
	SYSCON_CLK_CTRL_CLK_32K_SEL_XTAL32K = 0x0
	// digital 32K clock source is internal 32K RCO
	SYSCON_CLK_CTRL_CLK_32K_SEL_RCO32K = 0x1
	// Position of CLK_XTAL_OE field.
	SYSCON_CLK_CTRL_CLK_XTAL_OE_Pos = 0x16
	// Bit mask of CLK_XTAL_OE field.
	SYSCON_CLK_CTRL_CLK_XTAL_OE_Msk = 0x400000
	// Bit CLK_XTAL_OE.
	SYSCON_CLK_CTRL_CLK_XTAL_OE = 0x400000
	// Position of CLK_32K_OE field.
	SYSCON_CLK_CTRL_CLK_32K_OE_Pos = 0x17
	// Bit mask of CLK_32K_OE field.
	SYSCON_CLK_CTRL_CLK_32K_OE_Msk = 0x800000
	// Bit CLK_32K_OE.
	SYSCON_CLK_CTRL_CLK_32K_OE = 0x800000
	// Position of XTAL_OUT_DIV field.
	SYSCON_CLK_CTRL_XTAL_OUT_DIV_Pos = 0x18
	// Bit mask of XTAL_OUT_DIV field.
	SYSCON_CLK_CTRL_XTAL_OUT_DIV_Msk = 0xf000000
	// Position of CGBYPASS field.
	SYSCON_CLK_CTRL_CGBYPASS_Pos = 0x1c
	// Bit mask of CGBYPASS field.
	SYSCON_CLK_CTRL_CGBYPASS_Msk = 0x10000000
	// Bit CGBYPASS.
	SYSCON_CLK_CTRL_CGBYPASS = 0x10000000
	// Position of SYS_CLK_SEL field.
	SYSCON_CLK_CTRL_SYS_CLK_SEL_Pos = 0x1e
	// Bit mask of SYS_CLK_SEL field.
	SYSCON_CLK_CTRL_SYS_CLK_SEL_Msk = 0xc0000000
	// 32M internal clock
	SYSCON_CLK_CTRL_SYS_CLK_SEL_CLK_OSC = 0x0
	// external crystal clock
	SYSCON_CLK_CTRL_SYS_CLK_SEL_CLK_XTAL = 0x1
	// 32K clock
	SYSCON_CLK_CTRL_SYS_CLK_SEL_CLK_32K = 0x2

	// SYS_MODE_CTRL: system mode and address remap register
	// Position of REMAP field.
	SYSCON_SYS_MODE_CTRL_REMAP_Pos = 0x0
	// Bit mask of REMAP field.
	SYSCON_SYS_MODE_CTRL_REMAP_Msk = 0x3
	// address 0 is mapped to ROM
	SYSCON_SYS_MODE_CTRL_REMAP_ROM = 0x0
	// address 0 is mapped to FLASH
	SYSCON_SYS_MODE_CTRL_REMAP_FLASH = 0x1
	// address 0 is mapped to RAM
	SYSCON_SYS_MODE_CTRL_REMAP_RAM = 0x2
	// Position of LOCKUP_EN field.
	SYSCON_SYS_MODE_CTRL_LOCKUP_EN_Pos = 0x2
	// Bit mask of LOCKUP_EN field.
	SYSCON_SYS_MODE_CTRL_LOCKUP_EN_Msk = 0x4
	// Bit LOCKUP_EN.
	SYSCON_SYS_MODE_CTRL_LOCKUP_EN = 0x4
	// Position of XTAL_RDY field.
	SYSCON_SYS_MODE_CTRL_XTAL_RDY_Pos = 0x19
	// Bit mask of XTAL_RDY field.
	SYSCON_SYS_MODE_CTRL_XTAL_RDY_Msk = 0x2000000
	// Bit XTAL_RDY.
	SYSCON_SYS_MODE_CTRL_XTAL_RDY = 0x2000000
	// Position of XTAL32K_RDY field.
	SYSCON_SYS_MODE_CTRL_XTAL32K_RDY_Pos = 0x1a
	// Bit mask of XTAL32K_RDY field.
	SYSCON_SYS_MODE_CTRL_XTAL32K_RDY_Msk = 0x4000000
	// Bit XTAL32K_RDY.
	SYSCON_SYS_MODE_CTRL_XTAL32K_RDY = 0x4000000
	// Position of PLL48M_RDY field.
	SYSCON_SYS_MODE_CTRL_PLL48M_RDY_Pos = 0x1b
	// Bit mask of PLL48M_RDY field.
	SYSCON_SYS_MODE_CTRL_PLL48M_RDY_Msk = 0x8000000
	// Bit PLL48M_RDY.
	SYSCON_SYS_MODE_CTRL_PLL48M_RDY = 0x8000000
	// Position of OSC32M_RDY field.
	SYSCON_SYS_MODE_CTRL_OSC32M_RDY_Pos = 0x1c
	// Bit mask of OSC32M_RDY field.
	SYSCON_SYS_MODE_CTRL_OSC32M_RDY_Msk = 0x10000000
	// Bit OSC32M_RDY.
	SYSCON_SYS_MODE_CTRL_OSC32M_RDY = 0x10000000
	// Position of BG_RDY field.
	SYSCON_SYS_MODE_CTRL_BG_RDY_Pos = 0x1d
	// Bit mask of BG_RDY field.
	SYSCON_SYS_MODE_CTRL_BG_RDY_Msk = 0x20000000
	// Bit BG_RDY.
	SYSCON_SYS_MODE_CTRL_BG_RDY = 0x20000000
	// Position of BOOT_MODE field.
	SYSCON_SYS_MODE_CTRL_BOOT_MODE_Pos = 0x1f
	// Bit mask of BOOT_MODE field.
	SYSCON_SYS_MODE_CTRL_BOOT_MODE_Msk = 0x80000000
	// Bit BOOT_MODE.
	SYSCON_SYS_MODE_CTRL_BOOT_MODE = 0x80000000
	// when BOOT_MODE pin is 0, bootloader enter ISP
	SYSCON_SYS_MODE_CTRL_BOOT_MODE_ISP = 0x0
	// when BOOT_MODE pin is 1, bootloader jump to flash without ISP
	SYSCON_SYS_MODE_CTRL_BOOT_MODE_NORMAL = 0x1

	// SYS_STAT: system status register
	// Position of FREQ_WORD field.
	SYSCON_SYS_STAT_FREQ_WORD_Pos = 0x0
	// Bit mask of FREQ_WORD field.
	SYSCON_SYS_STAT_FREQ_WORD_Msk = 0xff
	// Position of BLE_FREQ_HOP field.
	SYSCON_SYS_STAT_BLE_FREQ_HOP_Pos = 0x8
	// Bit mask of BLE_FREQ_HOP field.
	SYSCON_SYS_STAT_BLE_FREQ_HOP_Msk = 0x100
	// Bit BLE_FREQ_HOP.
	SYSCON_SYS_STAT_BLE_FREQ_HOP = 0x100
	// Position of EVENT_IN_PROCESS field.
	SYSCON_SYS_STAT_EVENT_IN_PROCESS_Pos = 0x9
	// Bit mask of EVENT_IN_PROCESS field.
	SYSCON_SYS_STAT_EVENT_IN_PROCESS_Msk = 0x200
	// Bit EVENT_IN_PROCESS.
	SYSCON_SYS_STAT_EVENT_IN_PROCESS = 0x200
	// BLE is not in event process
	SYSCON_SYS_STAT_EVENT_IN_PROCESS_BLE_NONE_ENV = 0x0
	// BLE is in event process
	SYSCON_SYS_STAT_EVENT_IN_PROCESS_BLE_IN_ENV = 0x1
	// Position of RX_EN field.
	SYSCON_SYS_STAT_RX_EN_Pos = 0xa
	// Bit mask of RX_EN field.
	SYSCON_SYS_STAT_RX_EN_Msk = 0x400
	// Bit RX_EN.
	SYSCON_SYS_STAT_RX_EN = 0x400
	// Position of TX_EN field.
	SYSCON_SYS_STAT_TX_EN_Pos = 0xb
	// Bit mask of TX_EN field.
	SYSCON_SYS_STAT_TX_EN_Msk = 0x800
	// Bit TX_EN.
	SYSCON_SYS_STAT_TX_EN = 0x800
	// Position of OSC_EN field.
	SYSCON_SYS_STAT_OSC_EN_Pos = 0xc
	// Bit mask of OSC_EN field.
	SYSCON_SYS_STAT_OSC_EN_Msk = 0x1000
	// Bit OSC_EN.
	SYSCON_SYS_STAT_OSC_EN = 0x1000
	// Position of RADIO_EN field.
	SYSCON_SYS_STAT_RADIO_EN_Pos = 0xd
	// Bit mask of RADIO_EN field.
	SYSCON_SYS_STAT_RADIO_EN_Msk = 0x2000
	// Bit RADIO_EN.
	SYSCON_SYS_STAT_RADIO_EN = 0x2000
	// Position of CLK_STATUS field.
	SYSCON_SYS_STAT_CLK_STATUS_Pos = 0xe
	// Bit mask of CLK_STATUS field.
	SYSCON_SYS_STAT_CLK_STATUS_Msk = 0x4000
	// Bit CLK_STATUS.
	SYSCON_SYS_STAT_CLK_STATUS = 0x4000
	// BLE is active
	SYSCON_SYS_STAT_CLK_STATUS_BLE_IP_ACT = 0x0
	// BLE is in sleep mode
	SYSCON_SYS_STAT_CLK_STATUS_BLE_IP_SLP = 0x1

	// SYS_TICK: systick timer control register
	// Position of TENMS field.
	SYSCON_SYS_TICK_TENMS_Pos = 0x0
	// Bit mask of TENMS field.
	SYSCON_SYS_TICK_TENMS_Msk = 0xffffff
	// Position of SKEW field.
	SYSCON_SYS_TICK_SKEW_Pos = 0x18
	// Bit mask of SKEW field.
	SYSCON_SYS_TICK_SKEW_Msk = 0x1000000
	// Bit SKEW.
	SYSCON_SYS_TICK_SKEW = 0x1000000
	// TENMS is considered to be precise
	SYSCON_SYS_TICK_SKEW_PRECISE = 0x0
	// TENMS is not considered to be precise
	SYSCON_SYS_TICK_SKEW_NOT_PRECISE = 0x1
	// Position of NOREF field.
	SYSCON_SYS_TICK_NOREF_Pos = 0x19
	// Bit mask of NOREF field.
	SYSCON_SYS_TICK_NOREF_Msk = 0x2000000
	// Bit NOREF.
	SYSCON_SYS_TICK_NOREF = 0x2000000
	// external reference clock is available
	SYSCON_SYS_TICK_NOREF_AVAILABLE = 0x0
	// external reference clock is not available
	SYSCON_SYS_TICK_NOREF_NOT_AVAILABLE = 0x1
	// Position of EN_STCLKEN field.
	SYSCON_SYS_TICK_EN_STCLKEN_Pos = 0x1f
	// Bit mask of EN_STCLKEN field.
	SYSCON_SYS_TICK_EN_STCLKEN_Msk = 0x80000000
	// Bit EN_STCLKEN.
	SYSCON_SYS_TICK_EN_STCLKEN = 0x80000000

	// SRAM_CTRL: Exchange memory base address register
	// Position of EM_BASE_ADDR field.
	SYSCON_SRAM_CTRL_EM_BASE_ADDR_Pos = 0x0
	// Bit mask of EM_BASE_ADDR field.
	SYSCON_SRAM_CTRL_EM_BASE_ADDR_Msk = 0x7fff

	// CHIP_ID: chip id register
	// Position of CID0 field.
	SYSCON_CHIP_ID_CID0_Pos = 0x0
	// Bit mask of CID0 field.
	SYSCON_CHIP_ID_CID0_Msk = 0x7
	// Position of CID1 field.
	SYSCON_CHIP_ID_CID1_Pos = 0x3
	// Bit mask of CID1 field.
	SYSCON_CHIP_ID_CID1_Msk = 0x38
	// Position of CID2 field.
	SYSCON_CHIP_ID_CID2_Pos = 0x6
	// Bit mask of CID2 field.
	SYSCON_CHIP_ID_CID2_Msk = 0xc0
	// Position of CID3 field.
	SYSCON_CHIP_ID_CID3_Pos = 0x8
	// Bit mask of CID3 field.
	SYSCON_CHIP_ID_CID3_Msk = 0x3f00
	// QN9020
	SYSCON_CHIP_ID_CID3_QN9020 = 0x0
	// QN9030
	SYSCON_CHIP_ID_CID3_QN9030 = 0x1
	// QN9080
	SYSCON_CHIP_ID_CID3_QN9080 = 0x2
	// Position of CID4 field.
	SYSCON_CHIP_ID_CID4_Pos = 0xe
	// Bit mask of CID4 field.
	SYSCON_CHIP_ID_CID4_Msk = 0xc000
	// revision A
	SYSCON_CHIP_ID_CID4_A = 0x0
	// revision B
	SYSCON_CHIP_ID_CID4_B = 0x1
	// revision C
	SYSCON_CHIP_ID_CID4_C = 0x2
	// revision D
	SYSCON_CHIP_ID_CID4_D = 0x3
	// Position of MEM_OPTION field.
	SYSCON_CHIP_ID_MEM_OPTION_Pos = 0x1a
	// Bit mask of MEM_OPTION field.
	SYSCON_CHIP_ID_MEM_OPTION_Msk = 0x4000000
	// Bit MEM_OPTION.
	SYSCON_CHIP_ID_MEM_OPTION = 0x4000000
	// chip memory size is 64K
	SYSCON_CHIP_ID_MEM_OPTION_MEM_OPTION_64K = 0x0
	// chip memory size is 128K
	SYSCON_CHIP_ID_MEM_OPTION_MEM_OPTION_128K = 0x1
	// Position of ADC_OPTION field.
	SYSCON_CHIP_ID_ADC_OPTION_Pos = 0x1b
	// Bit mask of ADC_OPTION field.
	SYSCON_CHIP_ID_ADC_OPTION_Msk = 0x8000000
	// Bit ADC_OPTION.
	SYSCON_CHIP_ID_ADC_OPTION = 0x8000000
	// adc low resolution
	SYSCON_CHIP_ID_ADC_OPTION_LOW = 0x0
	// adc high resolution
	SYSCON_CHIP_ID_ADC_OPTION_HIGH = 0x1
	// Position of FLASH_OPTION field.
	SYSCON_CHIP_ID_FLASH_OPTION_Pos = 0x1c
	// Bit mask of FLASH_OPTION field.
	SYSCON_CHIP_ID_FLASH_OPTION_Msk = 0x10000000
	// Bit FLASH_OPTION.
	SYSCON_CHIP_ID_FLASH_OPTION = 0x10000000
	// chip flash size is 256K
	SYSCON_CHIP_ID_FLASH_OPTION_FLASH_OPTION_256K = 0x0
	// chip flash size is 512K
	SYSCON_CHIP_ID_FLASH_OPTION_FLASH_OPTION_512K = 0x1
	// Position of FPU_OPTION field.
	SYSCON_CHIP_ID_FPU_OPTION_Pos = 0x1d
	// Bit mask of FPU_OPTION field.
	SYSCON_CHIP_ID_FPU_OPTION_Msk = 0x20000000
	// Bit FPU_OPTION.
	SYSCON_CHIP_ID_FPU_OPTION = 0x20000000
	// fpu is not exist
	SYSCON_CHIP_ID_FPU_OPTION_NONE = 0x0
	// fpu is exist
	SYSCON_CHIP_ID_FPU_OPTION_EXIST = 0x1
	// Position of USB_OPTION field.
	SYSCON_CHIP_ID_USB_OPTION_Pos = 0x1e
	// Bit mask of USB_OPTION field.
	SYSCON_CHIP_ID_USB_OPTION_Msk = 0x40000000
	// Bit USB_OPTION.
	SYSCON_CHIP_ID_USB_OPTION = 0x40000000
	// chip doesnot have USB
	SYSCON_CHIP_ID_USB_OPTION_NONE = 0x0
	// chip has USB
	SYSCON_CHIP_ID_USB_OPTION_EXIST = 0x1
	// Position of FSP_OPTION field.
	SYSCON_CHIP_ID_FSP_OPTION_Pos = 0x1f
	// Bit mask of FSP_OPTION field.
	SYSCON_CHIP_ID_FSP_OPTION_Msk = 0x80000000
	// Bit FSP_OPTION.
	SYSCON_CHIP_ID_FSP_OPTION = 0x80000000
	// chip doesnot have FSP
	SYSCON_CHIP_ID_FSP_OPTION_NONE = 0x0
	// chip has FSP
	SYSCON_CHIP_ID_FSP_OPTION_EXIST = 0x1

	// ANA_CTRL0: crystal and PA register
	// Position of PA_POWER field.
	SYSCON_ANA_CTRL0_PA_POWER_Pos = 0x0
	// Bit mask of PA_POWER field.
	SYSCON_ANA_CTRL0_PA_POWER_Msk = 0xff
	// 20dBm
	SYSCON_ANA_CTRL0_PA_POWER_PA_POWER_20DBM = 0x10
	// 18dBm
	SYSCON_ANA_CTRL0_PA_POWER_PA_POWER_18DBM = 0x12
	// 16dBm
	SYSCON_ANA_CTRL0_PA_POWER_PA_POWER_16DBM = 0x14
	// 14dBm
	SYSCON_ANA_CTRL0_PA_POWER_PA_POWER_14DBM = 0x19
	// 12dBm
	SYSCON_ANA_CTRL0_PA_POWER_PA_POWER_12DBM = 0x20
	// 10dBm
	SYSCON_ANA_CTRL0_PA_POWER_PA_POWER_10DBM = 0x28
	// 8dBm
	SYSCON_ANA_CTRL0_PA_POWER_PA_POWER_8DBM = 0x32
	// 6dBm
	SYSCON_ANA_CTRL0_PA_POWER_PA_POWER_6DBM = 0x40
	// 4dBm
	SYSCON_ANA_CTRL0_PA_POWER_PA_POWER_4DBM = 0x50
	// 2dBm
	SYSCON_ANA_CTRL0_PA_POWER_PA_POWER_2DBM = 0x65
	// 0dBm
	SYSCON_ANA_CTRL0_PA_POWER_PA_POWER_0DBM = 0x7f
	// Position of XTAL_AMP field.
	SYSCON_ANA_CTRL0_XTAL_AMP_Pos = 0x14
	// Bit mask of XTAL_AMP field.
	SYSCON_ANA_CTRL0_XTAL_AMP_Msk = 0x300000
	// Position of XTAL_LOAD_CAP field.
	SYSCON_ANA_CTRL0_XTAL_LOAD_CAP_Pos = 0x16
	// Bit mask of XTAL_LOAD_CAP field.
	SYSCON_ANA_CTRL0_XTAL_LOAD_CAP_Msk = 0xfc00000
	// Position of XTAL_EXTRA_CAP field.
	SYSCON_ANA_CTRL0_XTAL_EXTRA_CAP_Pos = 0x1c
	// Bit mask of XTAL_EXTRA_CAP field.
	SYSCON_ANA_CTRL0_XTAL_EXTRA_CAP_Msk = 0x10000000
	// Bit XTAL_EXTRA_CAP.
	SYSCON_ANA_CTRL0_XTAL_EXTRA_CAP = 0x10000000
	// Position of XTAL_MODE field.
	SYSCON_ANA_CTRL0_XTAL_MODE_Pos = 0x1e
	// Bit mask of XTAL_MODE field.
	SYSCON_ANA_CTRL0_XTAL_MODE_Msk = 0xc0000000
	// High frequency crystal oscillator
	SYSCON_ANA_CTRL0_XTAL_MODE_XTAL = 0x0
	// Inject digital clock
	SYSCON_ANA_CTRL0_XTAL_MODE_DIG = 0x1
	// Inject single-end sine-wave signal
	SYSCON_ANA_CTRL0_XTAL_MODE_SINGLE = 0x2
	// inject differential sine-wave signal
	SYSCON_ANA_CTRL0_XTAL_MODE_DIFF = 0x3

	// XTAL_CTRL: crystal control register
	// Position of XTAL_XCUR_BOOST_REG field.
	SYSCON_XTAL_CTRL_XTAL_XCUR_BOOST_REG_Pos = 0x5
	// Bit mask of XTAL_XCUR_BOOST_REG field.
	SYSCON_XTAL_CTRL_XTAL_XCUR_BOOST_REG_Msk = 0x20
	// Bit XTAL_XCUR_BOOST_REG.
	SYSCON_XTAL_CTRL_XTAL_XCUR_BOOST_REG = 0x20
	// Position of XTAL_BPXDLY field.
	SYSCON_XTAL_CTRL_XTAL_BPXDLY_Pos = 0x6
	// Bit mask of XTAL_BPXDLY field.
	SYSCON_XTAL_CTRL_XTAL_BPXDLY_Msk = 0x40
	// Bit XTAL_BPXDLY.
	SYSCON_XTAL_CTRL_XTAL_BPXDLY = 0x40
	// Position of XTAL_BP_HYSRES_REG field.
	SYSCON_XTAL_CTRL_XTAL_BP_HYSRES_REG_Pos = 0x7
	// Bit mask of XTAL_BP_HYSRES_REG field.
	SYSCON_XTAL_CTRL_XTAL_BP_HYSRES_REG_Msk = 0x80
	// Bit XTAL_BP_HYSRES_REG.
	SYSCON_XTAL_CTRL_XTAL_BP_HYSRES_REG = 0x80
	// Position of XTAL_XSMT_EN_REG field.
	SYSCON_XTAL_CTRL_XTAL_XSMT_EN_REG_Pos = 0x8
	// Bit mask of XTAL_XSMT_EN_REG field.
	SYSCON_XTAL_CTRL_XTAL_XSMT_EN_REG_Msk = 0x100
	// Bit XTAL_XSMT_EN_REG.
	SYSCON_XTAL_CTRL_XTAL_XSMT_EN_REG = 0x100
	// Position of XTAL_XRDY_REG field.
	SYSCON_XTAL_CTRL_XTAL_XRDY_REG_Pos = 0x9
	// Bit mask of XTAL_XRDY_REG field.
	SYSCON_XTAL_CTRL_XTAL_XRDY_REG_Msk = 0x200
	// Bit XTAL_XRDY_REG.
	SYSCON_XTAL_CTRL_XTAL_XRDY_REG = 0x200
	// Position of XTAL_XOUT_DIS_REG field.
	SYSCON_XTAL_CTRL_XTAL_XOUT_DIS_REG_Pos = 0xa
	// Bit mask of XTAL_XOUT_DIS_REG field.
	SYSCON_XTAL_CTRL_XTAL_XOUT_DIS_REG_Msk = 0x400
	// Bit XTAL_XOUT_DIS_REG.
	SYSCON_XTAL_CTRL_XTAL_XOUT_DIS_REG = 0x400
	// Position of DIV_DIFF_CLK_DIG_DIS field.
	SYSCON_XTAL_CTRL_DIV_DIFF_CLK_DIG_DIS_Pos = 0xb
	// Bit mask of DIV_DIFF_CLK_DIG_DIS field.
	SYSCON_XTAL_CTRL_DIV_DIFF_CLK_DIG_DIS_Msk = 0x800
	// Bit DIV_DIFF_CLK_DIG_DIS.
	SYSCON_XTAL_CTRL_DIV_DIFF_CLK_DIG_DIS = 0x800
	// Position of XTAL_SU_CB_REG field.
	SYSCON_XTAL_CTRL_XTAL_SU_CB_REG_Pos = 0x10
	// Bit mask of XTAL_SU_CB_REG field.
	SYSCON_XTAL_CTRL_XTAL_SU_CB_REG_Msk = 0x3f0000
	// Position of XTAL_SU_CA_REG field.
	SYSCON_XTAL_CTRL_XTAL_SU_CA_REG_Pos = 0x18
	// Bit mask of XTAL_SU_CA_REG field.
	SYSCON_XTAL_CTRL_XTAL_SU_CA_REG_Msk = 0x3f000000
	// Position of XTAL_INV field.
	SYSCON_XTAL_CTRL_XTAL_INV_Pos = 0x1e
	// Bit mask of XTAL_INV field.
	SYSCON_XTAL_CTRL_XTAL_INV_Msk = 0x40000000
	// Bit XTAL_INV.
	SYSCON_XTAL_CTRL_XTAL_INV = 0x40000000
	// Position of XTAL_DIV field.
	SYSCON_XTAL_CTRL_XTAL_DIV_Pos = 0x1f
	// Bit mask of XTAL_DIV field.
	SYSCON_XTAL_CTRL_XTAL_DIV_Msk = 0x80000000
	// Bit XTAL_DIV.
	SYSCON_XTAL_CTRL_XTAL_DIV = 0x80000000

	// BUCK: buck control register
	// Position of BUCK_DRIVER_PART_EN field.
	SYSCON_BUCK_BUCK_DRIVER_PART_EN_Pos = 0x0
	// Bit mask of BUCK_DRIVER_PART_EN field.
	SYSCON_BUCK_BUCK_DRIVER_PART_EN_Msk = 0x1
	// Bit BUCK_DRIVER_PART_EN.
	SYSCON_BUCK_BUCK_DRIVER_PART_EN = 0x1
	// Position of BUCK_IND_USE_EN field.
	SYSCON_BUCK_BUCK_IND_USE_EN_Pos = 0x1
	// Bit mask of BUCK_IND_USE_EN field.
	SYSCON_BUCK_BUCK_IND_USE_EN_Msk = 0x2
	// Bit BUCK_IND_USE_EN.
	SYSCON_BUCK_BUCK_IND_USE_EN = 0x2
	// Position of BUCK_ISEL field.
	SYSCON_BUCK_BUCK_ISEL_Pos = 0x8
	// Bit mask of BUCK_ISEL field.
	SYSCON_BUCK_BUCK_ISEL_Msk = 0x300
	// Position of BUCK_VREF_SEL field.
	SYSCON_BUCK_BUCK_VREF_SEL_Pos = 0xa
	// Bit mask of BUCK_VREF_SEL field.
	SYSCON_BUCK_BUCK_VREF_SEL_Msk = 0xc00
	// Position of BUCK_VBG_SEL field.
	SYSCON_BUCK_BUCK_VBG_SEL_Pos = 0xc
	// Bit mask of BUCK_VBG_SEL field.
	SYSCON_BUCK_BUCK_VBG_SEL_Msk = 0x3000
	// Position of BUCK_TMOS field.
	SYSCON_BUCK_BUCK_TMOS_Pos = 0x10
	// Bit mask of BUCK_TMOS field.
	SYSCON_BUCK_BUCK_TMOS_Msk = 0x1f0000
	// Position of BUCK_IC field.
	SYSCON_BUCK_BUCK_IC_Pos = 0x15
	// Bit mask of BUCK_IC field.
	SYSCON_BUCK_BUCK_IC_Msk = 0x200000
	// Bit BUCK_IC.
	SYSCON_BUCK_BUCK_IC = 0x200000

	// FC_FRG: flexcomm 0 and 1 clock divider register
	// Position of FRG_DIV0 field.
	SYSCON_FC_FRG_FRG_DIV0_Pos = 0x0
	// Bit mask of FRG_DIV0 field.
	SYSCON_FC_FRG_FRG_DIV0_Msk = 0xff
	// Position of FRG_MULT0 field.
	SYSCON_FC_FRG_FRG_MULT0_Pos = 0x8
	// Bit mask of FRG_MULT0 field.
	SYSCON_FC_FRG_FRG_MULT0_Msk = 0xff00
	// Position of FRG_DIV1 field.
	SYSCON_FC_FRG_FRG_DIV1_Pos = 0x10
	// Bit mask of FRG_DIV1 field.
	SYSCON_FC_FRG_FRG_DIV1_Msk = 0xff0000
	// Position of FRG_MULT1 field.
	SYSCON_FC_FRG_FRG_MULT1_Pos = 0x18
	// Bit mask of FRG_MULT1 field.
	SYSCON_FC_FRG_FRG_MULT1_Msk = 0xff000000

	// PIO_PULL_CFG0: pad pull control register 0
	// Position of PA00_PULL field.
	SYSCON_PIO_PULL_CFG0_PA00_PULL_Pos = 0x0
	// Bit mask of PA00_PULL field.
	SYSCON_PIO_PULL_CFG0_PA00_PULL_Msk = 0x3
	// Position of PA01_PULL field.
	SYSCON_PIO_PULL_CFG0_PA01_PULL_Pos = 0x2
	// Bit mask of PA01_PULL field.
	SYSCON_PIO_PULL_CFG0_PA01_PULL_Msk = 0xc
	// Position of PA02_PULL field.
	SYSCON_PIO_PULL_CFG0_PA02_PULL_Pos = 0x4
	// Bit mask of PA02_PULL field.
	SYSCON_PIO_PULL_CFG0_PA02_PULL_Msk = 0x30
	// Position of PA03_PULL field.
	SYSCON_PIO_PULL_CFG0_PA03_PULL_Pos = 0x6
	// Bit mask of PA03_PULL field.
	SYSCON_PIO_PULL_CFG0_PA03_PULL_Msk = 0xc0
	// Position of PA04_PULL field.
	SYSCON_PIO_PULL_CFG0_PA04_PULL_Pos = 0x8
	// Bit mask of PA04_PULL field.
	SYSCON_PIO_PULL_CFG0_PA04_PULL_Msk = 0x300
	// Position of PA05_PULL field.
	SYSCON_PIO_PULL_CFG0_PA05_PULL_Pos = 0xa
	// Bit mask of PA05_PULL field.
	SYSCON_PIO_PULL_CFG0_PA05_PULL_Msk = 0xc00
	// Position of PA06_PULL field.
	SYSCON_PIO_PULL_CFG0_PA06_PULL_Pos = 0xc
	// Bit mask of PA06_PULL field.
	SYSCON_PIO_PULL_CFG0_PA06_PULL_Msk = 0x3000
	// Position of PA07_PULL field.
	SYSCON_PIO_PULL_CFG0_PA07_PULL_Pos = 0xe
	// Bit mask of PA07_PULL field.
	SYSCON_PIO_PULL_CFG0_PA07_PULL_Msk = 0xc000
	// Position of PA08_PULL field.
	SYSCON_PIO_PULL_CFG0_PA08_PULL_Pos = 0x10
	// Bit mask of PA08_PULL field.
	SYSCON_PIO_PULL_CFG0_PA08_PULL_Msk = 0x30000
	// Position of PA09_PULL field.
	SYSCON_PIO_PULL_CFG0_PA09_PULL_Pos = 0x12
	// Bit mask of PA09_PULL field.
	SYSCON_PIO_PULL_CFG0_PA09_PULL_Msk = 0xc0000
	// Position of PA10_PULL field.
	SYSCON_PIO_PULL_CFG0_PA10_PULL_Pos = 0x14
	// Bit mask of PA10_PULL field.
	SYSCON_PIO_PULL_CFG0_PA10_PULL_Msk = 0x300000
	// Position of PA11_PULL field.
	SYSCON_PIO_PULL_CFG0_PA11_PULL_Pos = 0x16
	// Bit mask of PA11_PULL field.
	SYSCON_PIO_PULL_CFG0_PA11_PULL_Msk = 0xc00000
	// Position of PA12_PULL field.
	SYSCON_PIO_PULL_CFG0_PA12_PULL_Pos = 0x18
	// Bit mask of PA12_PULL field.
	SYSCON_PIO_PULL_CFG0_PA12_PULL_Msk = 0x3000000
	// Position of PA13_PULL field.
	SYSCON_PIO_PULL_CFG0_PA13_PULL_Pos = 0x1a
	// Bit mask of PA13_PULL field.
	SYSCON_PIO_PULL_CFG0_PA13_PULL_Msk = 0xc000000
	// Position of PA14_PULL field.
	SYSCON_PIO_PULL_CFG0_PA14_PULL_Pos = 0x1c
	// Bit mask of PA14_PULL field.
	SYSCON_PIO_PULL_CFG0_PA14_PULL_Msk = 0x30000000
	// Position of PA15_PULL field.
	SYSCON_PIO_PULL_CFG0_PA15_PULL_Pos = 0x1e
	// Bit mask of PA15_PULL field.
	SYSCON_PIO_PULL_CFG0_PA15_PULL_Msk = 0xc0000000

	// PIO_PULL_CFG1: pad pull control register 1
	// Position of PA16_PULL field.
	SYSCON_PIO_PULL_CFG1_PA16_PULL_Pos = 0x0
	// Bit mask of PA16_PULL field.
	SYSCON_PIO_PULL_CFG1_PA16_PULL_Msk = 0x3
	// Position of PA17_PULL field.
	SYSCON_PIO_PULL_CFG1_PA17_PULL_Pos = 0x2
	// Bit mask of PA17_PULL field.
	SYSCON_PIO_PULL_CFG1_PA17_PULL_Msk = 0xc
	// Position of PA18_PULL field.
	SYSCON_PIO_PULL_CFG1_PA18_PULL_Pos = 0x4
	// Bit mask of PA18_PULL field.
	SYSCON_PIO_PULL_CFG1_PA18_PULL_Msk = 0x30
	// Position of PA19_PULL field.
	SYSCON_PIO_PULL_CFG1_PA19_PULL_Pos = 0x6
	// Bit mask of PA19_PULL field.
	SYSCON_PIO_PULL_CFG1_PA19_PULL_Msk = 0xc0
	// Position of PA20_PULL field.
	SYSCON_PIO_PULL_CFG1_PA20_PULL_Pos = 0x8
	// Bit mask of PA20_PULL field.
	SYSCON_PIO_PULL_CFG1_PA20_PULL_Msk = 0x300
	// Position of PA21_PULL field.
	SYSCON_PIO_PULL_CFG1_PA21_PULL_Pos = 0xa
	// Bit mask of PA21_PULL field.
	SYSCON_PIO_PULL_CFG1_PA21_PULL_Msk = 0xc00
	// Position of PA22_PULL field.
	SYSCON_PIO_PULL_CFG1_PA22_PULL_Pos = 0xc
	// Bit mask of PA22_PULL field.
	SYSCON_PIO_PULL_CFG1_PA22_PULL_Msk = 0x3000
	// Position of PA23_PULL field.
	SYSCON_PIO_PULL_CFG1_PA23_PULL_Pos = 0xe
	// Bit mask of PA23_PULL field.
	SYSCON_PIO_PULL_CFG1_PA23_PULL_Msk = 0xc000
	// Position of PA24_PULL field.
	SYSCON_PIO_PULL_CFG1_PA24_PULL_Pos = 0x10
	// Bit mask of PA24_PULL field.
	SYSCON_PIO_PULL_CFG1_PA24_PULL_Msk = 0x30000
	// Position of PA25_PULL field.
	SYSCON_PIO_PULL_CFG1_PA25_PULL_Pos = 0x12
	// Bit mask of PA25_PULL field.
	SYSCON_PIO_PULL_CFG1_PA25_PULL_Msk = 0xc0000
	// Position of PA26_PULL field.
	SYSCON_PIO_PULL_CFG1_PA26_PULL_Pos = 0x14
	// Bit mask of PA26_PULL field.
	SYSCON_PIO_PULL_CFG1_PA26_PULL_Msk = 0x300000
	// Position of PA27_PULL field.
	SYSCON_PIO_PULL_CFG1_PA27_PULL_Pos = 0x16
	// Bit mask of PA27_PULL field.
	SYSCON_PIO_PULL_CFG1_PA27_PULL_Msk = 0xc00000
	// Position of PA28_PULL field.
	SYSCON_PIO_PULL_CFG1_PA28_PULL_Pos = 0x18
	// Bit mask of PA28_PULL field.
	SYSCON_PIO_PULL_CFG1_PA28_PULL_Msk = 0x3000000
	// Position of PA29_PULL field.
	SYSCON_PIO_PULL_CFG1_PA29_PULL_Pos = 0x1a
	// Bit mask of PA29_PULL field.
	SYSCON_PIO_PULL_CFG1_PA29_PULL_Msk = 0xc000000
	// Position of PA30_PULL field.
	SYSCON_PIO_PULL_CFG1_PA30_PULL_Pos = 0x1c
	// Bit mask of PA30_PULL field.
	SYSCON_PIO_PULL_CFG1_PA30_PULL_Msk = 0x30000000
	// Position of PA31_PULL field.
	SYSCON_PIO_PULL_CFG1_PA31_PULL_Pos = 0x1e
	// Bit mask of PA31_PULL field.
	SYSCON_PIO_PULL_CFG1_PA31_PULL_Msk = 0xc0000000

	// PIO_PULL_CFG2: pad pull control register 2
	// Position of PB00_PULL field.
	SYSCON_PIO_PULL_CFG2_PB00_PULL_Pos = 0x0
	// Bit mask of PB00_PULL field.
	SYSCON_PIO_PULL_CFG2_PB00_PULL_Msk = 0x3
	// Position of PB01_PULL field.
	SYSCON_PIO_PULL_CFG2_PB01_PULL_Pos = 0x2
	// Bit mask of PB01_PULL field.
	SYSCON_PIO_PULL_CFG2_PB01_PULL_Msk = 0xc
	// Position of PB02_PULL field.
	SYSCON_PIO_PULL_CFG2_PB02_PULL_Pos = 0x4
	// Bit mask of PB02_PULL field.
	SYSCON_PIO_PULL_CFG2_PB02_PULL_Msk = 0x30

	// IO_CAP: io status capture register
	// Position of PIN_RETENTION field.
	SYSCON_IO_CAP_PIN_RETENTION_Pos = 0x0
	// Bit mask of PIN_RETENTION field.
	SYSCON_IO_CAP_PIN_RETENTION_Msk = 0x1
	// Bit PIN_RETENTION.
	SYSCON_IO_CAP_PIN_RETENTION = 0x1

	// PIO_DRV_CFG0: pad drive strength register 0
	// Position of PA00_DRV field.
	SYSCON_PIO_DRV_CFG0_PA00_DRV_Pos = 0x0
	// Bit mask of PA00_DRV field.
	SYSCON_PIO_DRV_CFG0_PA00_DRV_Msk = 0x1
	// Bit PA00_DRV.
	SYSCON_PIO_DRV_CFG0_PA00_DRV = 0x1
	// Position of PA01_DRV field.
	SYSCON_PIO_DRV_CFG0_PA01_DRV_Pos = 0x1
	// Bit mask of PA01_DRV field.
	SYSCON_PIO_DRV_CFG0_PA01_DRV_Msk = 0x2
	// Bit PA01_DRV.
	SYSCON_PIO_DRV_CFG0_PA01_DRV = 0x2
	// Position of PA02_DRV field.
	SYSCON_PIO_DRV_CFG0_PA02_DRV_Pos = 0x2
	// Bit mask of PA02_DRV field.
	SYSCON_PIO_DRV_CFG0_PA02_DRV_Msk = 0x4
	// Bit PA02_DRV.
	SYSCON_PIO_DRV_CFG0_PA02_DRV = 0x4
	// Position of PA03_DRV field.
	SYSCON_PIO_DRV_CFG0_PA03_DRV_Pos = 0x3
	// Bit mask of PA03_DRV field.
	SYSCON_PIO_DRV_CFG0_PA03_DRV_Msk = 0x8
	// Bit PA03_DRV.
	SYSCON_PIO_DRV_CFG0_PA03_DRV = 0x8
	// Position of PA04_DRV field.
	SYSCON_PIO_DRV_CFG0_PA04_DRV_Pos = 0x4
	// Bit mask of PA04_DRV field.
	SYSCON_PIO_DRV_CFG0_PA04_DRV_Msk = 0x10
	// Bit PA04_DRV.
	SYSCON_PIO_DRV_CFG0_PA04_DRV = 0x10
	// Position of PA05_DRV field.
	SYSCON_PIO_DRV_CFG0_PA05_DRV_Pos = 0x5
	// Bit mask of PA05_DRV field.
	SYSCON_PIO_DRV_CFG0_PA05_DRV_Msk = 0x20
	// Bit PA05_DRV.
	SYSCON_PIO_DRV_CFG0_PA05_DRV = 0x20
	// Position of PA06_DRV field.
	SYSCON_PIO_DRV_CFG0_PA06_DRV_Pos = 0x6
	// Bit mask of PA06_DRV field.
	SYSCON_PIO_DRV_CFG0_PA06_DRV_Msk = 0x40
	// Bit PA06_DRV.
	SYSCON_PIO_DRV_CFG0_PA06_DRV = 0x40
	// Position of PA07_DRV field.
	SYSCON_PIO_DRV_CFG0_PA07_DRV_Pos = 0x7
	// Bit mask of PA07_DRV field.
	SYSCON_PIO_DRV_CFG0_PA07_DRV_Msk = 0x80
	// Bit PA07_DRV.
	SYSCON_PIO_DRV_CFG0_PA07_DRV = 0x80
	// Position of PA08_DRV field.
	SYSCON_PIO_DRV_CFG0_PA08_DRV_Pos = 0x8
	// Bit mask of PA08_DRV field.
	SYSCON_PIO_DRV_CFG0_PA08_DRV_Msk = 0x100
	// Bit PA08_DRV.
	SYSCON_PIO_DRV_CFG0_PA08_DRV = 0x100
	// Position of PA09_DRV field.
	SYSCON_PIO_DRV_CFG0_PA09_DRV_Pos = 0x9
	// Bit mask of PA09_DRV field.
	SYSCON_PIO_DRV_CFG0_PA09_DRV_Msk = 0x200
	// Bit PA09_DRV.
	SYSCON_PIO_DRV_CFG0_PA09_DRV = 0x200
	// Position of PA10_DRV field.
	SYSCON_PIO_DRV_CFG0_PA10_DRV_Pos = 0xa
	// Bit mask of PA10_DRV field.
	SYSCON_PIO_DRV_CFG0_PA10_DRV_Msk = 0x400
	// Bit PA10_DRV.
	SYSCON_PIO_DRV_CFG0_PA10_DRV = 0x400
	// Position of PA11_DRV field.
	SYSCON_PIO_DRV_CFG0_PA11_DRV_Pos = 0xb
	// Bit mask of PA11_DRV field.
	SYSCON_PIO_DRV_CFG0_PA11_DRV_Msk = 0x800
	// Bit PA11_DRV.
	SYSCON_PIO_DRV_CFG0_PA11_DRV = 0x800
	// Position of PA12_DRV field.
	SYSCON_PIO_DRV_CFG0_PA12_DRV_Pos = 0xc
	// Bit mask of PA12_DRV field.
	SYSCON_PIO_DRV_CFG0_PA12_DRV_Msk = 0x1000
	// Bit PA12_DRV.
	SYSCON_PIO_DRV_CFG0_PA12_DRV = 0x1000
	// Position of PA13_DRV field.
	SYSCON_PIO_DRV_CFG0_PA13_DRV_Pos = 0xd
	// Bit mask of PA13_DRV field.
	SYSCON_PIO_DRV_CFG0_PA13_DRV_Msk = 0x2000
	// Bit PA13_DRV.
	SYSCON_PIO_DRV_CFG0_PA13_DRV = 0x2000
	// Position of PA14_DRV field.
	SYSCON_PIO_DRV_CFG0_PA14_DRV_Pos = 0xe
	// Bit mask of PA14_DRV field.
	SYSCON_PIO_DRV_CFG0_PA14_DRV_Msk = 0x4000
	// Bit PA14_DRV.
	SYSCON_PIO_DRV_CFG0_PA14_DRV = 0x4000
	// Position of PA15_DRV field.
	SYSCON_PIO_DRV_CFG0_PA15_DRV_Pos = 0xf
	// Bit mask of PA15_DRV field.
	SYSCON_PIO_DRV_CFG0_PA15_DRV_Msk = 0x8000
	// Bit PA15_DRV.
	SYSCON_PIO_DRV_CFG0_PA15_DRV = 0x8000
	// Position of PA16_DRV field.
	SYSCON_PIO_DRV_CFG0_PA16_DRV_Pos = 0x10
	// Bit mask of PA16_DRV field.
	SYSCON_PIO_DRV_CFG0_PA16_DRV_Msk = 0x10000
	// Bit PA16_DRV.
	SYSCON_PIO_DRV_CFG0_PA16_DRV = 0x10000
	// Position of PA17_DRV field.
	SYSCON_PIO_DRV_CFG0_PA17_DRV_Pos = 0x11
	// Bit mask of PA17_DRV field.
	SYSCON_PIO_DRV_CFG0_PA17_DRV_Msk = 0x20000
	// Bit PA17_DRV.
	SYSCON_PIO_DRV_CFG0_PA17_DRV = 0x20000
	// Position of PA18_DRV field.
	SYSCON_PIO_DRV_CFG0_PA18_DRV_Pos = 0x12
	// Bit mask of PA18_DRV field.
	SYSCON_PIO_DRV_CFG0_PA18_DRV_Msk = 0x40000
	// Bit PA18_DRV.
	SYSCON_PIO_DRV_CFG0_PA18_DRV = 0x40000
	// Position of PA19_DRV field.
	SYSCON_PIO_DRV_CFG0_PA19_DRV_Pos = 0x13
	// Bit mask of PA19_DRV field.
	SYSCON_PIO_DRV_CFG0_PA19_DRV_Msk = 0x80000
	// Bit PA19_DRV.
	SYSCON_PIO_DRV_CFG0_PA19_DRV = 0x80000
	// Position of PA20_DRV field.
	SYSCON_PIO_DRV_CFG0_PA20_DRV_Pos = 0x14
	// Bit mask of PA20_DRV field.
	SYSCON_PIO_DRV_CFG0_PA20_DRV_Msk = 0x100000
	// Bit PA20_DRV.
	SYSCON_PIO_DRV_CFG0_PA20_DRV = 0x100000
	// Position of PA21_DRV field.
	SYSCON_PIO_DRV_CFG0_PA21_DRV_Pos = 0x15
	// Bit mask of PA21_DRV field.
	SYSCON_PIO_DRV_CFG0_PA21_DRV_Msk = 0x200000
	// Bit PA21_DRV.
	SYSCON_PIO_DRV_CFG0_PA21_DRV = 0x200000
	// Position of PA22_DRV field.
	SYSCON_PIO_DRV_CFG0_PA22_DRV_Pos = 0x16
	// Bit mask of PA22_DRV field.
	SYSCON_PIO_DRV_CFG0_PA22_DRV_Msk = 0x400000
	// Bit PA22_DRV.
	SYSCON_PIO_DRV_CFG0_PA22_DRV = 0x400000
	// Position of PA23_DRV field.
	SYSCON_PIO_DRV_CFG0_PA23_DRV_Pos = 0x17
	// Bit mask of PA23_DRV field.
	SYSCON_PIO_DRV_CFG0_PA23_DRV_Msk = 0x800000
	// Bit PA23_DRV.
	SYSCON_PIO_DRV_CFG0_PA23_DRV = 0x800000
	// Position of PA24_DRV field.
	SYSCON_PIO_DRV_CFG0_PA24_DRV_Pos = 0x18
	// Bit mask of PA24_DRV field.
	SYSCON_PIO_DRV_CFG0_PA24_DRV_Msk = 0x1000000
	// Bit PA24_DRV.
	SYSCON_PIO_DRV_CFG0_PA24_DRV = 0x1000000
	// Position of PA25_DRV field.
	SYSCON_PIO_DRV_CFG0_PA25_DRV_Pos = 0x19
	// Bit mask of PA25_DRV field.
	SYSCON_PIO_DRV_CFG0_PA25_DRV_Msk = 0x2000000
	// Bit PA25_DRV.
	SYSCON_PIO_DRV_CFG0_PA25_DRV = 0x2000000
	// Position of PA26_DRV field.
	SYSCON_PIO_DRV_CFG0_PA26_DRV_Pos = 0x1a
	// Bit mask of PA26_DRV field.
	SYSCON_PIO_DRV_CFG0_PA26_DRV_Msk = 0x4000000
	// Bit PA26_DRV.
	SYSCON_PIO_DRV_CFG0_PA26_DRV = 0x4000000
	// Position of PA27_DRV field.
	SYSCON_PIO_DRV_CFG0_PA27_DRV_Pos = 0x1b
	// Bit mask of PA27_DRV field.
	SYSCON_PIO_DRV_CFG0_PA27_DRV_Msk = 0x8000000
	// Bit PA27_DRV.
	SYSCON_PIO_DRV_CFG0_PA27_DRV = 0x8000000
	// Position of PA28_DRV field.
	SYSCON_PIO_DRV_CFG0_PA28_DRV_Pos = 0x1c
	// Bit mask of PA28_DRV field.
	SYSCON_PIO_DRV_CFG0_PA28_DRV_Msk = 0x10000000
	// Bit PA28_DRV.
	SYSCON_PIO_DRV_CFG0_PA28_DRV = 0x10000000
	// Position of PA29_DRV field.
	SYSCON_PIO_DRV_CFG0_PA29_DRV_Pos = 0x1d
	// Bit mask of PA29_DRV field.
	SYSCON_PIO_DRV_CFG0_PA29_DRV_Msk = 0x20000000
	// Bit PA29_DRV.
	SYSCON_PIO_DRV_CFG0_PA29_DRV = 0x20000000
	// Position of PA30_DRV field.
	SYSCON_PIO_DRV_CFG0_PA30_DRV_Pos = 0x1e
	// Bit mask of PA30_DRV field.
	SYSCON_PIO_DRV_CFG0_PA30_DRV_Msk = 0x40000000
	// Bit PA30_DRV.
	SYSCON_PIO_DRV_CFG0_PA30_DRV = 0x40000000
	// Position of PA31_DRV field.
	SYSCON_PIO_DRV_CFG0_PA31_DRV_Pos = 0x1f
	// Bit mask of PA31_DRV field.
	SYSCON_PIO_DRV_CFG0_PA31_DRV_Msk = 0x80000000
	// Bit PA31_DRV.
	SYSCON_PIO_DRV_CFG0_PA31_DRV = 0x80000000

	// PIO_DRV_CFG1: pad drive strength register 1
	// Position of PB00_DRV field.
	SYSCON_PIO_DRV_CFG1_PB00_DRV_Pos = 0x0
	// Bit mask of PB00_DRV field.
	SYSCON_PIO_DRV_CFG1_PB00_DRV_Msk = 0x1
	// Bit PB00_DRV.
	SYSCON_PIO_DRV_CFG1_PB00_DRV = 0x1
	// Position of PB01_DRV field.
	SYSCON_PIO_DRV_CFG1_PB01_DRV_Pos = 0x1
	// Bit mask of PB01_DRV field.
	SYSCON_PIO_DRV_CFG1_PB01_DRV_Msk = 0x2
	// Bit PB01_DRV.
	SYSCON_PIO_DRV_CFG1_PB01_DRV = 0x2
	// Position of PB02_DRV field.
	SYSCON_PIO_DRV_CFG1_PB02_DRV_Pos = 0x2
	// Bit mask of PB02_DRV field.
	SYSCON_PIO_DRV_CFG1_PB02_DRV_Msk = 0x4
	// Bit PB02_DRV.
	SYSCON_PIO_DRV_CFG1_PB02_DRV = 0x4

	// PIO_DRV_CFG2: pad drive extra register
	// Position of PA06_DRV_EXTRA field.
	SYSCON_PIO_DRV_CFG2_PA06_DRV_EXTRA_Pos = 0x6
	// Bit mask of PA06_DRV_EXTRA field.
	SYSCON_PIO_DRV_CFG2_PA06_DRV_EXTRA_Msk = 0x40
	// Bit PA06_DRV_EXTRA.
	SYSCON_PIO_DRV_CFG2_PA06_DRV_EXTRA = 0x40
	// Position of PA11_DRV_EXTRA field.
	SYSCON_PIO_DRV_CFG2_PA11_DRV_EXTRA_Pos = 0xb
	// Bit mask of PA11_DRV_EXTRA field.
	SYSCON_PIO_DRV_CFG2_PA11_DRV_EXTRA_Msk = 0x800
	// Bit PA11_DRV_EXTRA.
	SYSCON_PIO_DRV_CFG2_PA11_DRV_EXTRA = 0x800
	// Position of PA19_DRV_EXTRA field.
	SYSCON_PIO_DRV_CFG2_PA19_DRV_EXTRA_Pos = 0x13
	// Bit mask of PA19_DRV_EXTRA field.
	SYSCON_PIO_DRV_CFG2_PA19_DRV_EXTRA_Msk = 0x80000
	// Bit PA19_DRV_EXTRA.
	SYSCON_PIO_DRV_CFG2_PA19_DRV_EXTRA = 0x80000
	// Position of PA26_DRV_EXTRA field.
	SYSCON_PIO_DRV_CFG2_PA26_DRV_EXTRA_Pos = 0x1a
	// Bit mask of PA26_DRV_EXTRA field.
	SYSCON_PIO_DRV_CFG2_PA26_DRV_EXTRA_Msk = 0x4000000
	// Bit PA26_DRV_EXTRA.
	SYSCON_PIO_DRV_CFG2_PA26_DRV_EXTRA = 0x4000000
	// Position of PA27_DRV_EXTRA field.
	SYSCON_PIO_DRV_CFG2_PA27_DRV_EXTRA_Pos = 0x1b
	// Bit mask of PA27_DRV_EXTRA field.
	SYSCON_PIO_DRV_CFG2_PA27_DRV_EXTRA_Msk = 0x8000000
	// Bit PA27_DRV_EXTRA.
	SYSCON_PIO_DRV_CFG2_PA27_DRV_EXTRA = 0x8000000

	// PIO_CFG_MISC: pin misc control register
	// Position of PB00_AE field.
	SYSCON_PIO_CFG_MISC_PB00_AE_Pos = 0x0
	// Bit mask of PB00_AE field.
	SYSCON_PIO_CFG_MISC_PB00_AE_Msk = 0x1
	// Bit PB00_AE.
	SYSCON_PIO_CFG_MISC_PB00_AE = 0x1
	// Position of PB01_AE field.
	SYSCON_PIO_CFG_MISC_PB01_AE_Pos = 0x1
	// Bit mask of PB01_AE field.
	SYSCON_PIO_CFG_MISC_PB01_AE_Msk = 0x2
	// Bit PB01_AE.
	SYSCON_PIO_CFG_MISC_PB01_AE = 0x2
	// Position of PSYNC field.
	SYSCON_PIO_CFG_MISC_PSYNC_Pos = 0xf
	// Bit mask of PSYNC field.
	SYSCON_PIO_CFG_MISC_PSYNC_Msk = 0x8000
	// Bit PSYNC.
	SYSCON_PIO_CFG_MISC_PSYNC = 0x8000
	// Position of PB02_MODE field.
	SYSCON_PIO_CFG_MISC_PB02_MODE_Pos = 0x10
	// Bit mask of PB02_MODE field.
	SYSCON_PIO_CFG_MISC_PB02_MODE_Msk = 0x10000
	// Bit PB02_MODE.
	SYSCON_PIO_CFG_MISC_PB02_MODE = 0x10000
	// PB02 is used as chip mode input
	SYSCON_PIO_CFG_MISC_PB02_MODE_BOOT_MODE = 0x0
	// PB02 is used as antena output
	SYSCON_PIO_CFG_MISC_PB02_MODE_ANTENNA = 0x1
	// Position of TRX_EN_INV field.
	SYSCON_PIO_CFG_MISC_TRX_EN_INV_Pos = 0x12
	// Bit mask of TRX_EN_INV field.
	SYSCON_PIO_CFG_MISC_TRX_EN_INV_Msk = 0x40000
	// Bit TRX_EN_INV.
	SYSCON_PIO_CFG_MISC_TRX_EN_INV = 0x40000
	// inverse TX_EN &amp; RX_EN pin mux output polarity
	SYSCON_PIO_CFG_MISC_TRX_EN_INV_TRX_EN_POL = 0x0
	// Position of RFE_INV field.
	SYSCON_PIO_CFG_MISC_RFE_INV_Pos = 0x13
	// Bit mask of RFE_INV field.
	SYSCON_PIO_CFG_MISC_RFE_INV_Msk = 0x80000
	// Bit RFE_INV.
	SYSCON_PIO_CFG_MISC_RFE_INV = 0x80000
	// Inverse RFE polarity
	SYSCON_PIO_CFG_MISC_RFE_INV_RFE_POL = 0x0

	// PIO_WAKEUP_LVL0: pin wakeup polarity register 0
	// Position of PA00_WAKEUP_LVL field.
	SYSCON_PIO_WAKEUP_LVL0_PA00_WAKEUP_LVL_Pos = 0x0
	// Bit mask of PA00_WAKEUP_LVL field.
	SYSCON_PIO_WAKEUP_LVL0_PA00_WAKEUP_LVL_Msk = 0x1
	// Bit PA00_WAKEUP_LVL.
	SYSCON_PIO_WAKEUP_LVL0_PA00_WAKEUP_LVL = 0x1
	// Position of PA01_WAKEUP_LVL field.
	SYSCON_PIO_WAKEUP_LVL0_PA01_WAKEUP_LVL_Pos = 0x1
	// Bit mask of PA01_WAKEUP_LVL field.
	SYSCON_PIO_WAKEUP_LVL0_PA01_WAKEUP_LVL_Msk = 0x2
	// Bit PA01_WAKEUP_LVL.
	SYSCON_PIO_WAKEUP_LVL0_PA01_WAKEUP_LVL = 0x2
	// Position of PA02_WAKEUP_LVL field.
	SYSCON_PIO_WAKEUP_LVL0_PA02_WAKEUP_LVL_Pos = 0x2
	// Bit mask of PA02_WAKEUP_LVL field.
	SYSCON_PIO_WAKEUP_LVL0_PA02_WAKEUP_LVL_Msk = 0x4
	// Bit PA02_WAKEUP_LVL.
	SYSCON_PIO_WAKEUP_LVL0_PA02_WAKEUP_LVL = 0x4
	// Position of PA03_WAKEUP_LVL field.
	SYSCON_PIO_WAKEUP_LVL0_PA03_WAKEUP_LVL_Pos = 0x3
	// Bit mask of PA03_WAKEUP_LVL field.
	SYSCON_PIO_WAKEUP_LVL0_PA03_WAKEUP_LVL_Msk = 0x8
	// Bit PA03_WAKEUP_LVL.
	SYSCON_PIO_WAKEUP_LVL0_PA03_WAKEUP_LVL = 0x8
	// Position of PA04_WAKEUP_LVL field.
	SYSCON_PIO_WAKEUP_LVL0_PA04_WAKEUP_LVL_Pos = 0x4
	// Bit mask of PA04_WAKEUP_LVL field.
	SYSCON_PIO_WAKEUP_LVL0_PA04_WAKEUP_LVL_Msk = 0x10
	// Bit PA04_WAKEUP_LVL.
	SYSCON_PIO_WAKEUP_LVL0_PA04_WAKEUP_LVL = 0x10
	// Position of PA05_WAKEUP_LVL field.
	SYSCON_PIO_WAKEUP_LVL0_PA05_WAKEUP_LVL_Pos = 0x5
	// Bit mask of PA05_WAKEUP_LVL field.
	SYSCON_PIO_WAKEUP_LVL0_PA05_WAKEUP_LVL_Msk = 0x20
	// Bit PA05_WAKEUP_LVL.
	SYSCON_PIO_WAKEUP_LVL0_PA05_WAKEUP_LVL = 0x20
	// Position of PA06_WAKEUP_LVL field.
	SYSCON_PIO_WAKEUP_LVL0_PA06_WAKEUP_LVL_Pos = 0x6
	// Bit mask of PA06_WAKEUP_LVL field.
	SYSCON_PIO_WAKEUP_LVL0_PA06_WAKEUP_LVL_Msk = 0x40
	// Bit PA06_WAKEUP_LVL.
	SYSCON_PIO_WAKEUP_LVL0_PA06_WAKEUP_LVL = 0x40
	// Position of PA07_WAKEUP_LVL field.
	SYSCON_PIO_WAKEUP_LVL0_PA07_WAKEUP_LVL_Pos = 0x7
	// Bit mask of PA07_WAKEUP_LVL field.
	SYSCON_PIO_WAKEUP_LVL0_PA07_WAKEUP_LVL_Msk = 0x80
	// Bit PA07_WAKEUP_LVL.
	SYSCON_PIO_WAKEUP_LVL0_PA07_WAKEUP_LVL = 0x80
	// Position of PA08_WAKEUP_LVL field.
	SYSCON_PIO_WAKEUP_LVL0_PA08_WAKEUP_LVL_Pos = 0x8
	// Bit mask of PA08_WAKEUP_LVL field.
	SYSCON_PIO_WAKEUP_LVL0_PA08_WAKEUP_LVL_Msk = 0x100
	// Bit PA08_WAKEUP_LVL.
	SYSCON_PIO_WAKEUP_LVL0_PA08_WAKEUP_LVL = 0x100
	// Position of PA09_WAKEUP_LVL field.
	SYSCON_PIO_WAKEUP_LVL0_PA09_WAKEUP_LVL_Pos = 0x9
	// Bit mask of PA09_WAKEUP_LVL field.
	SYSCON_PIO_WAKEUP_LVL0_PA09_WAKEUP_LVL_Msk = 0x200
	// Bit PA09_WAKEUP_LVL.
	SYSCON_PIO_WAKEUP_LVL0_PA09_WAKEUP_LVL = 0x200
	// Position of PA10_WAKEUP_LVL field.
	SYSCON_PIO_WAKEUP_LVL0_PA10_WAKEUP_LVL_Pos = 0xa
	// Bit mask of PA10_WAKEUP_LVL field.
	SYSCON_PIO_WAKEUP_LVL0_PA10_WAKEUP_LVL_Msk = 0x400
	// Bit PA10_WAKEUP_LVL.
	SYSCON_PIO_WAKEUP_LVL0_PA10_WAKEUP_LVL = 0x400
	// Position of PA11_WAKEUP_LVL field.
	SYSCON_PIO_WAKEUP_LVL0_PA11_WAKEUP_LVL_Pos = 0xb
	// Bit mask of PA11_WAKEUP_LVL field.
	SYSCON_PIO_WAKEUP_LVL0_PA11_WAKEUP_LVL_Msk = 0x800
	// Bit PA11_WAKEUP_LVL.
	SYSCON_PIO_WAKEUP_LVL0_PA11_WAKEUP_LVL = 0x800
	// Position of PA12_WAKEUP_LVL field.
	SYSCON_PIO_WAKEUP_LVL0_PA12_WAKEUP_LVL_Pos = 0xc
	// Bit mask of PA12_WAKEUP_LVL field.
	SYSCON_PIO_WAKEUP_LVL0_PA12_WAKEUP_LVL_Msk = 0x1000
	// Bit PA12_WAKEUP_LVL.
	SYSCON_PIO_WAKEUP_LVL0_PA12_WAKEUP_LVL = 0x1000
	// Position of PA13_WAKEUP_LVL field.
	SYSCON_PIO_WAKEUP_LVL0_PA13_WAKEUP_LVL_Pos = 0xd
	// Bit mask of PA13_WAKEUP_LVL field.
	SYSCON_PIO_WAKEUP_LVL0_PA13_WAKEUP_LVL_Msk = 0x2000
	// Bit PA13_WAKEUP_LVL.
	SYSCON_PIO_WAKEUP_LVL0_PA13_WAKEUP_LVL = 0x2000
	// Position of PA14_WAKEUP_LVL field.
	SYSCON_PIO_WAKEUP_LVL0_PA14_WAKEUP_LVL_Pos = 0xe
	// Bit mask of PA14_WAKEUP_LVL field.
	SYSCON_PIO_WAKEUP_LVL0_PA14_WAKEUP_LVL_Msk = 0x4000
	// Bit PA14_WAKEUP_LVL.
	SYSCON_PIO_WAKEUP_LVL0_PA14_WAKEUP_LVL = 0x4000
	// Position of PA15_WAKEUP_LVL field.
	SYSCON_PIO_WAKEUP_LVL0_PA15_WAKEUP_LVL_Pos = 0xf
	// Bit mask of PA15_WAKEUP_LVL field.
	SYSCON_PIO_WAKEUP_LVL0_PA15_WAKEUP_LVL_Msk = 0x8000
	// Bit PA15_WAKEUP_LVL.
	SYSCON_PIO_WAKEUP_LVL0_PA15_WAKEUP_LVL = 0x8000
	// Position of PA16_WAKEUP_LVL field.
	SYSCON_PIO_WAKEUP_LVL0_PA16_WAKEUP_LVL_Pos = 0x10
	// Bit mask of PA16_WAKEUP_LVL field.
	SYSCON_PIO_WAKEUP_LVL0_PA16_WAKEUP_LVL_Msk = 0x10000
	// Bit PA16_WAKEUP_LVL.
	SYSCON_PIO_WAKEUP_LVL0_PA16_WAKEUP_LVL = 0x10000
	// Position of PA17_WAKEUP_LVL field.
	SYSCON_PIO_WAKEUP_LVL0_PA17_WAKEUP_LVL_Pos = 0x11
	// Bit mask of PA17_WAKEUP_LVL field.
	SYSCON_PIO_WAKEUP_LVL0_PA17_WAKEUP_LVL_Msk = 0x20000
	// Bit PA17_WAKEUP_LVL.
	SYSCON_PIO_WAKEUP_LVL0_PA17_WAKEUP_LVL = 0x20000
	// Position of PA18_WAKEUP_LVL field.
	SYSCON_PIO_WAKEUP_LVL0_PA18_WAKEUP_LVL_Pos = 0x12
	// Bit mask of PA18_WAKEUP_LVL field.
	SYSCON_PIO_WAKEUP_LVL0_PA18_WAKEUP_LVL_Msk = 0x40000
	// Bit PA18_WAKEUP_LVL.
	SYSCON_PIO_WAKEUP_LVL0_PA18_WAKEUP_LVL = 0x40000
	// Position of PA19_WAKEUP_LVL field.
	SYSCON_PIO_WAKEUP_LVL0_PA19_WAKEUP_LVL_Pos = 0x13
	// Bit mask of PA19_WAKEUP_LVL field.
	SYSCON_PIO_WAKEUP_LVL0_PA19_WAKEUP_LVL_Msk = 0x80000
	// Bit PA19_WAKEUP_LVL.
	SYSCON_PIO_WAKEUP_LVL0_PA19_WAKEUP_LVL = 0x80000
	// Position of PA20_WAKEUP_LVL field.
	SYSCON_PIO_WAKEUP_LVL0_PA20_WAKEUP_LVL_Pos = 0x14
	// Bit mask of PA20_WAKEUP_LVL field.
	SYSCON_PIO_WAKEUP_LVL0_PA20_WAKEUP_LVL_Msk = 0x100000
	// Bit PA20_WAKEUP_LVL.
	SYSCON_PIO_WAKEUP_LVL0_PA20_WAKEUP_LVL = 0x100000
	// Position of PA21_WAKEUP_LVL field.
	SYSCON_PIO_WAKEUP_LVL0_PA21_WAKEUP_LVL_Pos = 0x15
	// Bit mask of PA21_WAKEUP_LVL field.
	SYSCON_PIO_WAKEUP_LVL0_PA21_WAKEUP_LVL_Msk = 0x200000
	// Bit PA21_WAKEUP_LVL.
	SYSCON_PIO_WAKEUP_LVL0_PA21_WAKEUP_LVL = 0x200000
	// Position of PA22_WAKEUP_LVL field.
	SYSCON_PIO_WAKEUP_LVL0_PA22_WAKEUP_LVL_Pos = 0x16
	// Bit mask of PA22_WAKEUP_LVL field.
	SYSCON_PIO_WAKEUP_LVL0_PA22_WAKEUP_LVL_Msk = 0x400000
	// Bit PA22_WAKEUP_LVL.
	SYSCON_PIO_WAKEUP_LVL0_PA22_WAKEUP_LVL = 0x400000
	// Position of PA23_WAKEUP_LVL field.
	SYSCON_PIO_WAKEUP_LVL0_PA23_WAKEUP_LVL_Pos = 0x17
	// Bit mask of PA23_WAKEUP_LVL field.
	SYSCON_PIO_WAKEUP_LVL0_PA23_WAKEUP_LVL_Msk = 0x800000
	// Bit PA23_WAKEUP_LVL.
	SYSCON_PIO_WAKEUP_LVL0_PA23_WAKEUP_LVL = 0x800000
	// Position of PA24_WAKEUP_LVL field.
	SYSCON_PIO_WAKEUP_LVL0_PA24_WAKEUP_LVL_Pos = 0x18
	// Bit mask of PA24_WAKEUP_LVL field.
	SYSCON_PIO_WAKEUP_LVL0_PA24_WAKEUP_LVL_Msk = 0x1000000
	// Bit PA24_WAKEUP_LVL.
	SYSCON_PIO_WAKEUP_LVL0_PA24_WAKEUP_LVL = 0x1000000
	// Position of PA25_WAKEUP_LVL field.
	SYSCON_PIO_WAKEUP_LVL0_PA25_WAKEUP_LVL_Pos = 0x19
	// Bit mask of PA25_WAKEUP_LVL field.
	SYSCON_PIO_WAKEUP_LVL0_PA25_WAKEUP_LVL_Msk = 0x2000000
	// Bit PA25_WAKEUP_LVL.
	SYSCON_PIO_WAKEUP_LVL0_PA25_WAKEUP_LVL = 0x2000000
	// Position of PA26_WAKEUP_LVL field.
	SYSCON_PIO_WAKEUP_LVL0_PA26_WAKEUP_LVL_Pos = 0x1a
	// Bit mask of PA26_WAKEUP_LVL field.
	SYSCON_PIO_WAKEUP_LVL0_PA26_WAKEUP_LVL_Msk = 0x4000000
	// Bit PA26_WAKEUP_LVL.
	SYSCON_PIO_WAKEUP_LVL0_PA26_WAKEUP_LVL = 0x4000000
	// Position of PA27_WAKEUP_LVL field.
	SYSCON_PIO_WAKEUP_LVL0_PA27_WAKEUP_LVL_Pos = 0x1b
	// Bit mask of PA27_WAKEUP_LVL field.
	SYSCON_PIO_WAKEUP_LVL0_PA27_WAKEUP_LVL_Msk = 0x8000000
	// Bit PA27_WAKEUP_LVL.
	SYSCON_PIO_WAKEUP_LVL0_PA27_WAKEUP_LVL = 0x8000000
	// Position of PA28_WAKEUP_LVL field.
	SYSCON_PIO_WAKEUP_LVL0_PA28_WAKEUP_LVL_Pos = 0x1c
	// Bit mask of PA28_WAKEUP_LVL field.
	SYSCON_PIO_WAKEUP_LVL0_PA28_WAKEUP_LVL_Msk = 0x10000000
	// Bit PA28_WAKEUP_LVL.
	SYSCON_PIO_WAKEUP_LVL0_PA28_WAKEUP_LVL = 0x10000000
	// Position of PA29_WAKEUP_LVL field.
	SYSCON_PIO_WAKEUP_LVL0_PA29_WAKEUP_LVL_Pos = 0x1d
	// Bit mask of PA29_WAKEUP_LVL field.
	SYSCON_PIO_WAKEUP_LVL0_PA29_WAKEUP_LVL_Msk = 0x20000000
	// Bit PA29_WAKEUP_LVL.
	SYSCON_PIO_WAKEUP_LVL0_PA29_WAKEUP_LVL = 0x20000000
	// Position of PA30_WAKEUP_LVL field.
	SYSCON_PIO_WAKEUP_LVL0_PA30_WAKEUP_LVL_Pos = 0x1e
	// Bit mask of PA30_WAKEUP_LVL field.
	SYSCON_PIO_WAKEUP_LVL0_PA30_WAKEUP_LVL_Msk = 0x40000000
	// Bit PA30_WAKEUP_LVL.
	SYSCON_PIO_WAKEUP_LVL0_PA30_WAKEUP_LVL = 0x40000000
	// Position of PA31_WAKEUP_LVL field.
	SYSCON_PIO_WAKEUP_LVL0_PA31_WAKEUP_LVL_Pos = 0x1f
	// Bit mask of PA31_WAKEUP_LVL field.
	SYSCON_PIO_WAKEUP_LVL0_PA31_WAKEUP_LVL_Msk = 0x80000000
	// Bit PA31_WAKEUP_LVL.
	SYSCON_PIO_WAKEUP_LVL0_PA31_WAKEUP_LVL = 0x80000000

	// PIO_WAKEUP_LVL1: pin wakeup polarity register 1
	// Position of PB00_WAKEUP_LVL field.
	SYSCON_PIO_WAKEUP_LVL1_PB00_WAKEUP_LVL_Pos = 0x0
	// Bit mask of PB00_WAKEUP_LVL field.
	SYSCON_PIO_WAKEUP_LVL1_PB00_WAKEUP_LVL_Msk = 0x1
	// Bit PB00_WAKEUP_LVL.
	SYSCON_PIO_WAKEUP_LVL1_PB00_WAKEUP_LVL = 0x1
	// Position of PB01_WAKEUP_LVL field.
	SYSCON_PIO_WAKEUP_LVL1_PB01_WAKEUP_LVL_Pos = 0x1
	// Bit mask of PB01_WAKEUP_LVL field.
	SYSCON_PIO_WAKEUP_LVL1_PB01_WAKEUP_LVL_Msk = 0x2
	// Bit PB01_WAKEUP_LVL.
	SYSCON_PIO_WAKEUP_LVL1_PB01_WAKEUP_LVL = 0x2
	// Position of PB02_WAKEUP_LVL field.
	SYSCON_PIO_WAKEUP_LVL1_PB02_WAKEUP_LVL_Pos = 0x2
	// Bit mask of PB02_WAKEUP_LVL field.
	SYSCON_PIO_WAKEUP_LVL1_PB02_WAKEUP_LVL_Msk = 0x4
	// Bit PB02_WAKEUP_LVL.
	SYSCON_PIO_WAKEUP_LVL1_PB02_WAKEUP_LVL = 0x4

	// PIO_IE_CFG0: pad input enable register 0
	// Position of PA00_IE field.
	SYSCON_PIO_IE_CFG0_PA00_IE_Pos = 0x0
	// Bit mask of PA00_IE field.
	SYSCON_PIO_IE_CFG0_PA00_IE_Msk = 0x1
	// Bit PA00_IE.
	SYSCON_PIO_IE_CFG0_PA00_IE = 0x1
	// Position of PA01_IE field.
	SYSCON_PIO_IE_CFG0_PA01_IE_Pos = 0x1
	// Bit mask of PA01_IE field.
	SYSCON_PIO_IE_CFG0_PA01_IE_Msk = 0x2
	// Bit PA01_IE.
	SYSCON_PIO_IE_CFG0_PA01_IE = 0x2
	// Position of PA02_IE field.
	SYSCON_PIO_IE_CFG0_PA02_IE_Pos = 0x2
	// Bit mask of PA02_IE field.
	SYSCON_PIO_IE_CFG0_PA02_IE_Msk = 0x4
	// Bit PA02_IE.
	SYSCON_PIO_IE_CFG0_PA02_IE = 0x4
	// Position of PA03_IE field.
	SYSCON_PIO_IE_CFG0_PA03_IE_Pos = 0x3
	// Bit mask of PA03_IE field.
	SYSCON_PIO_IE_CFG0_PA03_IE_Msk = 0x8
	// Bit PA03_IE.
	SYSCON_PIO_IE_CFG0_PA03_IE = 0x8
	// Position of PA04_IE field.
	SYSCON_PIO_IE_CFG0_PA04_IE_Pos = 0x4
	// Bit mask of PA04_IE field.
	SYSCON_PIO_IE_CFG0_PA04_IE_Msk = 0x10
	// Bit PA04_IE.
	SYSCON_PIO_IE_CFG0_PA04_IE = 0x10
	// Position of PA05_IE field.
	SYSCON_PIO_IE_CFG0_PA05_IE_Pos = 0x5
	// Bit mask of PA05_IE field.
	SYSCON_PIO_IE_CFG0_PA05_IE_Msk = 0x20
	// Bit PA05_IE.
	SYSCON_PIO_IE_CFG0_PA05_IE = 0x20
	// Position of PA06_IE field.
	SYSCON_PIO_IE_CFG0_PA06_IE_Pos = 0x6
	// Bit mask of PA06_IE field.
	SYSCON_PIO_IE_CFG0_PA06_IE_Msk = 0x40
	// Bit PA06_IE.
	SYSCON_PIO_IE_CFG0_PA06_IE = 0x40
	// Position of PA07_IE field.
	SYSCON_PIO_IE_CFG0_PA07_IE_Pos = 0x7
	// Bit mask of PA07_IE field.
	SYSCON_PIO_IE_CFG0_PA07_IE_Msk = 0x80
	// Bit PA07_IE.
	SYSCON_PIO_IE_CFG0_PA07_IE = 0x80
	// Position of PA08_IE field.
	SYSCON_PIO_IE_CFG0_PA08_IE_Pos = 0x8
	// Bit mask of PA08_IE field.
	SYSCON_PIO_IE_CFG0_PA08_IE_Msk = 0x100
	// Bit PA08_IE.
	SYSCON_PIO_IE_CFG0_PA08_IE = 0x100
	// Position of PA09_IE field.
	SYSCON_PIO_IE_CFG0_PA09_IE_Pos = 0x9
	// Bit mask of PA09_IE field.
	SYSCON_PIO_IE_CFG0_PA09_IE_Msk = 0x200
	// Bit PA09_IE.
	SYSCON_PIO_IE_CFG0_PA09_IE = 0x200
	// Position of PA10_IE field.
	SYSCON_PIO_IE_CFG0_PA10_IE_Pos = 0xa
	// Bit mask of PA10_IE field.
	SYSCON_PIO_IE_CFG0_PA10_IE_Msk = 0x400
	// Bit PA10_IE.
	SYSCON_PIO_IE_CFG0_PA10_IE = 0x400
	// Position of PA11_IE field.
	SYSCON_PIO_IE_CFG0_PA11_IE_Pos = 0xb
	// Bit mask of PA11_IE field.
	SYSCON_PIO_IE_CFG0_PA11_IE_Msk = 0x800
	// Bit PA11_IE.
	SYSCON_PIO_IE_CFG0_PA11_IE = 0x800
	// Position of PA12_IE field.
	SYSCON_PIO_IE_CFG0_PA12_IE_Pos = 0xc
	// Bit mask of PA12_IE field.
	SYSCON_PIO_IE_CFG0_PA12_IE_Msk = 0x1000
	// Bit PA12_IE.
	SYSCON_PIO_IE_CFG0_PA12_IE = 0x1000
	// Position of PA13_IE field.
	SYSCON_PIO_IE_CFG0_PA13_IE_Pos = 0xd
	// Bit mask of PA13_IE field.
	SYSCON_PIO_IE_CFG0_PA13_IE_Msk = 0x2000
	// Bit PA13_IE.
	SYSCON_PIO_IE_CFG0_PA13_IE = 0x2000
	// Position of PA14_IE field.
	SYSCON_PIO_IE_CFG0_PA14_IE_Pos = 0xe
	// Bit mask of PA14_IE field.
	SYSCON_PIO_IE_CFG0_PA14_IE_Msk = 0x4000
	// Bit PA14_IE.
	SYSCON_PIO_IE_CFG0_PA14_IE = 0x4000
	// Position of PA15_IE field.
	SYSCON_PIO_IE_CFG0_PA15_IE_Pos = 0xf
	// Bit mask of PA15_IE field.
	SYSCON_PIO_IE_CFG0_PA15_IE_Msk = 0x8000
	// Bit PA15_IE.
	SYSCON_PIO_IE_CFG0_PA15_IE = 0x8000
	// Position of PA16_IE field.
	SYSCON_PIO_IE_CFG0_PA16_IE_Pos = 0x10
	// Bit mask of PA16_IE field.
	SYSCON_PIO_IE_CFG0_PA16_IE_Msk = 0x10000
	// Bit PA16_IE.
	SYSCON_PIO_IE_CFG0_PA16_IE = 0x10000
	// Position of PA17_IE field.
	SYSCON_PIO_IE_CFG0_PA17_IE_Pos = 0x11
	// Bit mask of PA17_IE field.
	SYSCON_PIO_IE_CFG0_PA17_IE_Msk = 0x20000
	// Bit PA17_IE.
	SYSCON_PIO_IE_CFG0_PA17_IE = 0x20000
	// Position of PA18_IE field.
	SYSCON_PIO_IE_CFG0_PA18_IE_Pos = 0x12
	// Bit mask of PA18_IE field.
	SYSCON_PIO_IE_CFG0_PA18_IE_Msk = 0x40000
	// Bit PA18_IE.
	SYSCON_PIO_IE_CFG0_PA18_IE = 0x40000
	// Position of PA19_IE field.
	SYSCON_PIO_IE_CFG0_PA19_IE_Pos = 0x13
	// Bit mask of PA19_IE field.
	SYSCON_PIO_IE_CFG0_PA19_IE_Msk = 0x80000
	// Bit PA19_IE.
	SYSCON_PIO_IE_CFG0_PA19_IE = 0x80000
	// Position of PA20_IE field.
	SYSCON_PIO_IE_CFG0_PA20_IE_Pos = 0x14
	// Bit mask of PA20_IE field.
	SYSCON_PIO_IE_CFG0_PA20_IE_Msk = 0x100000
	// Bit PA20_IE.
	SYSCON_PIO_IE_CFG0_PA20_IE = 0x100000
	// Position of PA21_IE field.
	SYSCON_PIO_IE_CFG0_PA21_IE_Pos = 0x15
	// Bit mask of PA21_IE field.
	SYSCON_PIO_IE_CFG0_PA21_IE_Msk = 0x200000
	// Bit PA21_IE.
	SYSCON_PIO_IE_CFG0_PA21_IE = 0x200000
	// Position of PA22_IE field.
	SYSCON_PIO_IE_CFG0_PA22_IE_Pos = 0x16
	// Bit mask of PA22_IE field.
	SYSCON_PIO_IE_CFG0_PA22_IE_Msk = 0x400000
	// Bit PA22_IE.
	SYSCON_PIO_IE_CFG0_PA22_IE = 0x400000
	// Position of PA23_IE field.
	SYSCON_PIO_IE_CFG0_PA23_IE_Pos = 0x17
	// Bit mask of PA23_IE field.
	SYSCON_PIO_IE_CFG0_PA23_IE_Msk = 0x800000
	// Bit PA23_IE.
	SYSCON_PIO_IE_CFG0_PA23_IE = 0x800000
	// Position of PA24_IE field.
	SYSCON_PIO_IE_CFG0_PA24_IE_Pos = 0x18
	// Bit mask of PA24_IE field.
	SYSCON_PIO_IE_CFG0_PA24_IE_Msk = 0x1000000
	// Bit PA24_IE.
	SYSCON_PIO_IE_CFG0_PA24_IE = 0x1000000
	// Position of PA25_IE field.
	SYSCON_PIO_IE_CFG0_PA25_IE_Pos = 0x19
	// Bit mask of PA25_IE field.
	SYSCON_PIO_IE_CFG0_PA25_IE_Msk = 0x2000000
	// Bit PA25_IE.
	SYSCON_PIO_IE_CFG0_PA25_IE = 0x2000000
	// Position of PA26_IE field.
	SYSCON_PIO_IE_CFG0_PA26_IE_Pos = 0x1a
	// Bit mask of PA26_IE field.
	SYSCON_PIO_IE_CFG0_PA26_IE_Msk = 0x4000000
	// Bit PA26_IE.
	SYSCON_PIO_IE_CFG0_PA26_IE = 0x4000000
	// Position of PA27_IE field.
	SYSCON_PIO_IE_CFG0_PA27_IE_Pos = 0x1b
	// Bit mask of PA27_IE field.
	SYSCON_PIO_IE_CFG0_PA27_IE_Msk = 0x8000000
	// Bit PA27_IE.
	SYSCON_PIO_IE_CFG0_PA27_IE = 0x8000000
	// Position of PA28_IE field.
	SYSCON_PIO_IE_CFG0_PA28_IE_Pos = 0x1c
	// Bit mask of PA28_IE field.
	SYSCON_PIO_IE_CFG0_PA28_IE_Msk = 0x10000000
	// Bit PA28_IE.
	SYSCON_PIO_IE_CFG0_PA28_IE = 0x10000000
	// Position of PA29_IE field.
	SYSCON_PIO_IE_CFG0_PA29_IE_Pos = 0x1d
	// Bit mask of PA29_IE field.
	SYSCON_PIO_IE_CFG0_PA29_IE_Msk = 0x20000000
	// Bit PA29_IE.
	SYSCON_PIO_IE_CFG0_PA29_IE = 0x20000000
	// Position of PA30_IE field.
	SYSCON_PIO_IE_CFG0_PA30_IE_Pos = 0x1e
	// Bit mask of PA30_IE field.
	SYSCON_PIO_IE_CFG0_PA30_IE_Msk = 0x40000000
	// Bit PA30_IE.
	SYSCON_PIO_IE_CFG0_PA30_IE = 0x40000000
	// Position of PA31_IE field.
	SYSCON_PIO_IE_CFG0_PA31_IE_Pos = 0x1f
	// Bit mask of PA31_IE field.
	SYSCON_PIO_IE_CFG0_PA31_IE_Msk = 0x80000000
	// Bit PA31_IE.
	SYSCON_PIO_IE_CFG0_PA31_IE = 0x80000000

	// PIO_IE_CFG1: pad input enable register 1
	// Position of PB00_IE field.
	SYSCON_PIO_IE_CFG1_PB00_IE_Pos = 0x0
	// Bit mask of PB00_IE field.
	SYSCON_PIO_IE_CFG1_PB00_IE_Msk = 0x1
	// Bit PB00_IE.
	SYSCON_PIO_IE_CFG1_PB00_IE = 0x1
	// Position of PB01_IE field.
	SYSCON_PIO_IE_CFG1_PB01_IE_Pos = 0x1
	// Bit mask of PB01_IE field.
	SYSCON_PIO_IE_CFG1_PB01_IE_Msk = 0x2
	// Bit PB01_IE.
	SYSCON_PIO_IE_CFG1_PB01_IE = 0x2
	// Position of BOOT_MODE_IE field.
	SYSCON_PIO_IE_CFG1_BOOT_MODE_IE_Pos = 0x2
	// Bit mask of BOOT_MODE_IE field.
	SYSCON_PIO_IE_CFG1_BOOT_MODE_IE_Msk = 0x4
	// Bit BOOT_MODE_IE.
	SYSCON_PIO_IE_CFG1_BOOT_MODE_IE = 0x4

	// PIO_FUNC_CFG0: pin mux control register 0
	// Position of PA00_FUNC field.
	SYSCON_PIO_FUNC_CFG0_PA00_FUNC_Pos = 0x0
	// Bit mask of PA00_FUNC field.
	SYSCON_PIO_FUNC_CFG0_PA00_FUNC_Msk = 0x7
	// Position of PA01_FUNC field.
	SYSCON_PIO_FUNC_CFG0_PA01_FUNC_Pos = 0x4
	// Bit mask of PA01_FUNC field.
	SYSCON_PIO_FUNC_CFG0_PA01_FUNC_Msk = 0x70
	// Position of PA02_FUNC field.
	SYSCON_PIO_FUNC_CFG0_PA02_FUNC_Pos = 0x8
	// Bit mask of PA02_FUNC field.
	SYSCON_PIO_FUNC_CFG0_PA02_FUNC_Msk = 0x700
	// Position of PA03_FUNC field.
	SYSCON_PIO_FUNC_CFG0_PA03_FUNC_Pos = 0xc
	// Bit mask of PA03_FUNC field.
	SYSCON_PIO_FUNC_CFG0_PA03_FUNC_Msk = 0x7000
	// Position of PA04_FUNC field.
	SYSCON_PIO_FUNC_CFG0_PA04_FUNC_Pos = 0x10
	// Bit mask of PA04_FUNC field.
	SYSCON_PIO_FUNC_CFG0_PA04_FUNC_Msk = 0x70000
	// Position of PA05_FUNC field.
	SYSCON_PIO_FUNC_CFG0_PA05_FUNC_Pos = 0x14
	// Bit mask of PA05_FUNC field.
	SYSCON_PIO_FUNC_CFG0_PA05_FUNC_Msk = 0x700000
	// Position of PA06_FUNC field.
	SYSCON_PIO_FUNC_CFG0_PA06_FUNC_Pos = 0x18
	// Bit mask of PA06_FUNC field.
	SYSCON_PIO_FUNC_CFG0_PA06_FUNC_Msk = 0x7000000
	// Position of PA07_FUNC field.
	SYSCON_PIO_FUNC_CFG0_PA07_FUNC_Pos = 0x1c
	// Bit mask of PA07_FUNC field.
	SYSCON_PIO_FUNC_CFG0_PA07_FUNC_Msk = 0x70000000

	// PIO_FUNC_CFG1: pin mux control register 1
	// Position of PA08_FUNC field.
	SYSCON_PIO_FUNC_CFG1_PA08_FUNC_Pos = 0x0
	// Bit mask of PA08_FUNC field.
	SYSCON_PIO_FUNC_CFG1_PA08_FUNC_Msk = 0x7
	// Position of PA09_FUNC field.
	SYSCON_PIO_FUNC_CFG1_PA09_FUNC_Pos = 0x4
	// Bit mask of PA09_FUNC field.
	SYSCON_PIO_FUNC_CFG1_PA09_FUNC_Msk = 0x70
	// Position of PA10_FUNC field.
	SYSCON_PIO_FUNC_CFG1_PA10_FUNC_Pos = 0x8
	// Bit mask of PA10_FUNC field.
	SYSCON_PIO_FUNC_CFG1_PA10_FUNC_Msk = 0x700
	// Position of PA11_FUNC field.
	SYSCON_PIO_FUNC_CFG1_PA11_FUNC_Pos = 0xc
	// Bit mask of PA11_FUNC field.
	SYSCON_PIO_FUNC_CFG1_PA11_FUNC_Msk = 0x7000
	// Position of PA12_FUNC field.
	SYSCON_PIO_FUNC_CFG1_PA12_FUNC_Pos = 0x10
	// Bit mask of PA12_FUNC field.
	SYSCON_PIO_FUNC_CFG1_PA12_FUNC_Msk = 0x70000
	// Position of PA13_FUNC field.
	SYSCON_PIO_FUNC_CFG1_PA13_FUNC_Pos = 0x14
	// Bit mask of PA13_FUNC field.
	SYSCON_PIO_FUNC_CFG1_PA13_FUNC_Msk = 0x700000
	// Position of PA14_FUNC field.
	SYSCON_PIO_FUNC_CFG1_PA14_FUNC_Pos = 0x18
	// Bit mask of PA14_FUNC field.
	SYSCON_PIO_FUNC_CFG1_PA14_FUNC_Msk = 0x7000000
	// Position of PA15_FUNC field.
	SYSCON_PIO_FUNC_CFG1_PA15_FUNC_Pos = 0x1c
	// Bit mask of PA15_FUNC field.
	SYSCON_PIO_FUNC_CFG1_PA15_FUNC_Msk = 0x70000000

	// PIO_FUNC_CFG2: pin mux control register 2
	// Position of PA16_FUNC field.
	SYSCON_PIO_FUNC_CFG2_PA16_FUNC_Pos = 0x0
	// Bit mask of PA16_FUNC field.
	SYSCON_PIO_FUNC_CFG2_PA16_FUNC_Msk = 0x7
	// Position of PA17_FUNC field.
	SYSCON_PIO_FUNC_CFG2_PA17_FUNC_Pos = 0x4
	// Bit mask of PA17_FUNC field.
	SYSCON_PIO_FUNC_CFG2_PA17_FUNC_Msk = 0x70
	// Position of PA18_FUNC field.
	SYSCON_PIO_FUNC_CFG2_PA18_FUNC_Pos = 0x8
	// Bit mask of PA18_FUNC field.
	SYSCON_PIO_FUNC_CFG2_PA18_FUNC_Msk = 0x700
	// Position of PA19_FUNC field.
	SYSCON_PIO_FUNC_CFG2_PA19_FUNC_Pos = 0xc
	// Bit mask of PA19_FUNC field.
	SYSCON_PIO_FUNC_CFG2_PA19_FUNC_Msk = 0x7000
	// Position of PA20_FUNC field.
	SYSCON_PIO_FUNC_CFG2_PA20_FUNC_Pos = 0x10
	// Bit mask of PA20_FUNC field.
	SYSCON_PIO_FUNC_CFG2_PA20_FUNC_Msk = 0x70000
	// Position of PA21_FUNC field.
	SYSCON_PIO_FUNC_CFG2_PA21_FUNC_Pos = 0x14
	// Bit mask of PA21_FUNC field.
	SYSCON_PIO_FUNC_CFG2_PA21_FUNC_Msk = 0x700000
	// Position of PA22_FUNC field.
	SYSCON_PIO_FUNC_CFG2_PA22_FUNC_Pos = 0x18
	// Bit mask of PA22_FUNC field.
	SYSCON_PIO_FUNC_CFG2_PA22_FUNC_Msk = 0x7000000
	// Position of PA23_FUNC field.
	SYSCON_PIO_FUNC_CFG2_PA23_FUNC_Pos = 0x1c
	// Bit mask of PA23_FUNC field.
	SYSCON_PIO_FUNC_CFG2_PA23_FUNC_Msk = 0x70000000

	// PIO_FUNC_CFG3: pin mux control register 3
	// Position of PA24_FUNC field.
	SYSCON_PIO_FUNC_CFG3_PA24_FUNC_Pos = 0x0
	// Bit mask of PA24_FUNC field.
	SYSCON_PIO_FUNC_CFG3_PA24_FUNC_Msk = 0x7
	// Position of PA25_FUNC field.
	SYSCON_PIO_FUNC_CFG3_PA25_FUNC_Pos = 0x4
	// Bit mask of PA25_FUNC field.
	SYSCON_PIO_FUNC_CFG3_PA25_FUNC_Msk = 0x70
	// Position of PA26_FUNC field.
	SYSCON_PIO_FUNC_CFG3_PA26_FUNC_Pos = 0x8
	// Bit mask of PA26_FUNC field.
	SYSCON_PIO_FUNC_CFG3_PA26_FUNC_Msk = 0x700
	// Position of PA27_FUNC field.
	SYSCON_PIO_FUNC_CFG3_PA27_FUNC_Pos = 0xc
	// Bit mask of PA27_FUNC field.
	SYSCON_PIO_FUNC_CFG3_PA27_FUNC_Msk = 0x7000
	// Position of PA28_FUNC field.
	SYSCON_PIO_FUNC_CFG3_PA28_FUNC_Pos = 0x10
	// Bit mask of PA28_FUNC field.
	SYSCON_PIO_FUNC_CFG3_PA28_FUNC_Msk = 0x70000
	// Position of PA29_FUNC field.
	SYSCON_PIO_FUNC_CFG3_PA29_FUNC_Pos = 0x14
	// Bit mask of PA29_FUNC field.
	SYSCON_PIO_FUNC_CFG3_PA29_FUNC_Msk = 0x700000
	// Position of PA30_FUNC field.
	SYSCON_PIO_FUNC_CFG3_PA30_FUNC_Pos = 0x18
	// Bit mask of PA30_FUNC field.
	SYSCON_PIO_FUNC_CFG3_PA30_FUNC_Msk = 0x7000000
	// Position of PA31_FUNC field.
	SYSCON_PIO_FUNC_CFG3_PA31_FUNC_Pos = 0x1c
	// Bit mask of PA31_FUNC field.
	SYSCON_PIO_FUNC_CFG3_PA31_FUNC_Msk = 0x70000000

	// PIO_WAKEUP_EN0: pin function selection in power down mode register 0
	// Position of PA00_WAKEUP_EN field.
	SYSCON_PIO_WAKEUP_EN0_PA00_WAKEUP_EN_Pos = 0x0
	// Bit mask of PA00_WAKEUP_EN field.
	SYSCON_PIO_WAKEUP_EN0_PA00_WAKEUP_EN_Msk = 0x1
	// Bit PA00_WAKEUP_EN.
	SYSCON_PIO_WAKEUP_EN0_PA00_WAKEUP_EN = 0x1
	// Position of PA01_WAKEUP_EN field.
	SYSCON_PIO_WAKEUP_EN0_PA01_WAKEUP_EN_Pos = 0x1
	// Bit mask of PA01_WAKEUP_EN field.
	SYSCON_PIO_WAKEUP_EN0_PA01_WAKEUP_EN_Msk = 0x2
	// Bit PA01_WAKEUP_EN.
	SYSCON_PIO_WAKEUP_EN0_PA01_WAKEUP_EN = 0x2
	// Position of PA02_WAKEUP_EN field.
	SYSCON_PIO_WAKEUP_EN0_PA02_WAKEUP_EN_Pos = 0x2
	// Bit mask of PA02_WAKEUP_EN field.
	SYSCON_PIO_WAKEUP_EN0_PA02_WAKEUP_EN_Msk = 0x4
	// Bit PA02_WAKEUP_EN.
	SYSCON_PIO_WAKEUP_EN0_PA02_WAKEUP_EN = 0x4
	// Position of PA03_WAKEUP_EN field.
	SYSCON_PIO_WAKEUP_EN0_PA03_WAKEUP_EN_Pos = 0x3
	// Bit mask of PA03_WAKEUP_EN field.
	SYSCON_PIO_WAKEUP_EN0_PA03_WAKEUP_EN_Msk = 0x8
	// Bit PA03_WAKEUP_EN.
	SYSCON_PIO_WAKEUP_EN0_PA03_WAKEUP_EN = 0x8
	// Position of PA04_WAKEUP_EN field.
	SYSCON_PIO_WAKEUP_EN0_PA04_WAKEUP_EN_Pos = 0x4
	// Bit mask of PA04_WAKEUP_EN field.
	SYSCON_PIO_WAKEUP_EN0_PA04_WAKEUP_EN_Msk = 0x10
	// Bit PA04_WAKEUP_EN.
	SYSCON_PIO_WAKEUP_EN0_PA04_WAKEUP_EN = 0x10
	// Position of PA05_WAKEUP_EN field.
	SYSCON_PIO_WAKEUP_EN0_PA05_WAKEUP_EN_Pos = 0x5
	// Bit mask of PA05_WAKEUP_EN field.
	SYSCON_PIO_WAKEUP_EN0_PA05_WAKEUP_EN_Msk = 0x20
	// Bit PA05_WAKEUP_EN.
	SYSCON_PIO_WAKEUP_EN0_PA05_WAKEUP_EN = 0x20
	// Position of PA06_WAKEUP_EN field.
	SYSCON_PIO_WAKEUP_EN0_PA06_WAKEUP_EN_Pos = 0x6
	// Bit mask of PA06_WAKEUP_EN field.
	SYSCON_PIO_WAKEUP_EN0_PA06_WAKEUP_EN_Msk = 0x40
	// Bit PA06_WAKEUP_EN.
	SYSCON_PIO_WAKEUP_EN0_PA06_WAKEUP_EN = 0x40
	// Position of PA07_WAKEUP_EN field.
	SYSCON_PIO_WAKEUP_EN0_PA07_WAKEUP_EN_Pos = 0x7
	// Bit mask of PA07_WAKEUP_EN field.
	SYSCON_PIO_WAKEUP_EN0_PA07_WAKEUP_EN_Msk = 0x80
	// Bit PA07_WAKEUP_EN.
	SYSCON_PIO_WAKEUP_EN0_PA07_WAKEUP_EN = 0x80
	// Position of PA08_WAKEUP_EN field.
	SYSCON_PIO_WAKEUP_EN0_PA08_WAKEUP_EN_Pos = 0x8
	// Bit mask of PA08_WAKEUP_EN field.
	SYSCON_PIO_WAKEUP_EN0_PA08_WAKEUP_EN_Msk = 0x100
	// Bit PA08_WAKEUP_EN.
	SYSCON_PIO_WAKEUP_EN0_PA08_WAKEUP_EN = 0x100
	// Position of PA09_WAKEUP_EN field.
	SYSCON_PIO_WAKEUP_EN0_PA09_WAKEUP_EN_Pos = 0x9
	// Bit mask of PA09_WAKEUP_EN field.
	SYSCON_PIO_WAKEUP_EN0_PA09_WAKEUP_EN_Msk = 0x200
	// Bit PA09_WAKEUP_EN.
	SYSCON_PIO_WAKEUP_EN0_PA09_WAKEUP_EN = 0x200
	// Position of PA10_WAKEUP_EN field.
	SYSCON_PIO_WAKEUP_EN0_PA10_WAKEUP_EN_Pos = 0xa
	// Bit mask of PA10_WAKEUP_EN field.
	SYSCON_PIO_WAKEUP_EN0_PA10_WAKEUP_EN_Msk = 0x400
	// Bit PA10_WAKEUP_EN.
	SYSCON_PIO_WAKEUP_EN0_PA10_WAKEUP_EN = 0x400
	// Position of PA11_WAKEUP_EN field.
	SYSCON_PIO_WAKEUP_EN0_PA11_WAKEUP_EN_Pos = 0xb
	// Bit mask of PA11_WAKEUP_EN field.
	SYSCON_PIO_WAKEUP_EN0_PA11_WAKEUP_EN_Msk = 0x800
	// Bit PA11_WAKEUP_EN.
	SYSCON_PIO_WAKEUP_EN0_PA11_WAKEUP_EN = 0x800
	// Position of PA12_WAKEUP_EN field.
	SYSCON_PIO_WAKEUP_EN0_PA12_WAKEUP_EN_Pos = 0xc
	// Bit mask of PA12_WAKEUP_EN field.
	SYSCON_PIO_WAKEUP_EN0_PA12_WAKEUP_EN_Msk = 0x1000
	// Bit PA12_WAKEUP_EN.
	SYSCON_PIO_WAKEUP_EN0_PA12_WAKEUP_EN = 0x1000
	// Position of PA13_WAKEUP_EN field.
	SYSCON_PIO_WAKEUP_EN0_PA13_WAKEUP_EN_Pos = 0xd
	// Bit mask of PA13_WAKEUP_EN field.
	SYSCON_PIO_WAKEUP_EN0_PA13_WAKEUP_EN_Msk = 0x2000
	// Bit PA13_WAKEUP_EN.
	SYSCON_PIO_WAKEUP_EN0_PA13_WAKEUP_EN = 0x2000
	// Position of PA14_WAKEUP_EN field.
	SYSCON_PIO_WAKEUP_EN0_PA14_WAKEUP_EN_Pos = 0xe
	// Bit mask of PA14_WAKEUP_EN field.
	SYSCON_PIO_WAKEUP_EN0_PA14_WAKEUP_EN_Msk = 0x4000
	// Bit PA14_WAKEUP_EN.
	SYSCON_PIO_WAKEUP_EN0_PA14_WAKEUP_EN = 0x4000
	// Position of PA15_WAKEUP_EN field.
	SYSCON_PIO_WAKEUP_EN0_PA15_WAKEUP_EN_Pos = 0xf
	// Bit mask of PA15_WAKEUP_EN field.
	SYSCON_PIO_WAKEUP_EN0_PA15_WAKEUP_EN_Msk = 0x8000
	// Bit PA15_WAKEUP_EN.
	SYSCON_PIO_WAKEUP_EN0_PA15_WAKEUP_EN = 0x8000
	// Position of PA16_WAKEUP_EN field.
	SYSCON_PIO_WAKEUP_EN0_PA16_WAKEUP_EN_Pos = 0x10
	// Bit mask of PA16_WAKEUP_EN field.
	SYSCON_PIO_WAKEUP_EN0_PA16_WAKEUP_EN_Msk = 0x10000
	// Bit PA16_WAKEUP_EN.
	SYSCON_PIO_WAKEUP_EN0_PA16_WAKEUP_EN = 0x10000
	// Position of PA17_WAKEUP_EN field.
	SYSCON_PIO_WAKEUP_EN0_PA17_WAKEUP_EN_Pos = 0x11
	// Bit mask of PA17_WAKEUP_EN field.
	SYSCON_PIO_WAKEUP_EN0_PA17_WAKEUP_EN_Msk = 0x20000
	// Bit PA17_WAKEUP_EN.
	SYSCON_PIO_WAKEUP_EN0_PA17_WAKEUP_EN = 0x20000
	// Position of PA18_WAKEUP_EN field.
	SYSCON_PIO_WAKEUP_EN0_PA18_WAKEUP_EN_Pos = 0x12
	// Bit mask of PA18_WAKEUP_EN field.
	SYSCON_PIO_WAKEUP_EN0_PA18_WAKEUP_EN_Msk = 0x40000
	// Bit PA18_WAKEUP_EN.
	SYSCON_PIO_WAKEUP_EN0_PA18_WAKEUP_EN = 0x40000
	// Position of PA19_WAKEUP_EN field.
	SYSCON_PIO_WAKEUP_EN0_PA19_WAKEUP_EN_Pos = 0x13
	// Bit mask of PA19_WAKEUP_EN field.
	SYSCON_PIO_WAKEUP_EN0_PA19_WAKEUP_EN_Msk = 0x80000
	// Bit PA19_WAKEUP_EN.
	SYSCON_PIO_WAKEUP_EN0_PA19_WAKEUP_EN = 0x80000
	// Position of PA20_WAKEUP_EN field.
	SYSCON_PIO_WAKEUP_EN0_PA20_WAKEUP_EN_Pos = 0x14
	// Bit mask of PA20_WAKEUP_EN field.
	SYSCON_PIO_WAKEUP_EN0_PA20_WAKEUP_EN_Msk = 0x100000
	// Bit PA20_WAKEUP_EN.
	SYSCON_PIO_WAKEUP_EN0_PA20_WAKEUP_EN = 0x100000
	// Position of PA21_WAKEUP_EN field.
	SYSCON_PIO_WAKEUP_EN0_PA21_WAKEUP_EN_Pos = 0x15
	// Bit mask of PA21_WAKEUP_EN field.
	SYSCON_PIO_WAKEUP_EN0_PA21_WAKEUP_EN_Msk = 0x200000
	// Bit PA21_WAKEUP_EN.
	SYSCON_PIO_WAKEUP_EN0_PA21_WAKEUP_EN = 0x200000
	// Position of PA22_WAKEUP_EN field.
	SYSCON_PIO_WAKEUP_EN0_PA22_WAKEUP_EN_Pos = 0x16
	// Bit mask of PA22_WAKEUP_EN field.
	SYSCON_PIO_WAKEUP_EN0_PA22_WAKEUP_EN_Msk = 0x400000
	// Bit PA22_WAKEUP_EN.
	SYSCON_PIO_WAKEUP_EN0_PA22_WAKEUP_EN = 0x400000
	// Position of PA23_WAKEUP_EN field.
	SYSCON_PIO_WAKEUP_EN0_PA23_WAKEUP_EN_Pos = 0x17
	// Bit mask of PA23_WAKEUP_EN field.
	SYSCON_PIO_WAKEUP_EN0_PA23_WAKEUP_EN_Msk = 0x800000
	// Bit PA23_WAKEUP_EN.
	SYSCON_PIO_WAKEUP_EN0_PA23_WAKEUP_EN = 0x800000
	// Position of PA24_WAKEUP_EN field.
	SYSCON_PIO_WAKEUP_EN0_PA24_WAKEUP_EN_Pos = 0x18
	// Bit mask of PA24_WAKEUP_EN field.
	SYSCON_PIO_WAKEUP_EN0_PA24_WAKEUP_EN_Msk = 0x1000000
	// Bit PA24_WAKEUP_EN.
	SYSCON_PIO_WAKEUP_EN0_PA24_WAKEUP_EN = 0x1000000
	// Position of PA25_WAKEUP_EN field.
	SYSCON_PIO_WAKEUP_EN0_PA25_WAKEUP_EN_Pos = 0x19
	// Bit mask of PA25_WAKEUP_EN field.
	SYSCON_PIO_WAKEUP_EN0_PA25_WAKEUP_EN_Msk = 0x2000000
	// Bit PA25_WAKEUP_EN.
	SYSCON_PIO_WAKEUP_EN0_PA25_WAKEUP_EN = 0x2000000
	// Position of PA26_WAKEUP_EN field.
	SYSCON_PIO_WAKEUP_EN0_PA26_WAKEUP_EN_Pos = 0x1a
	// Bit mask of PA26_WAKEUP_EN field.
	SYSCON_PIO_WAKEUP_EN0_PA26_WAKEUP_EN_Msk = 0x4000000
	// Bit PA26_WAKEUP_EN.
	SYSCON_PIO_WAKEUP_EN0_PA26_WAKEUP_EN = 0x4000000
	// Position of PA27_WAKEUP_EN field.
	SYSCON_PIO_WAKEUP_EN0_PA27_WAKEUP_EN_Pos = 0x1b
	// Bit mask of PA27_WAKEUP_EN field.
	SYSCON_PIO_WAKEUP_EN0_PA27_WAKEUP_EN_Msk = 0x8000000
	// Bit PA27_WAKEUP_EN.
	SYSCON_PIO_WAKEUP_EN0_PA27_WAKEUP_EN = 0x8000000
	// Position of PA28_WAKEUP_EN field.
	SYSCON_PIO_WAKEUP_EN0_PA28_WAKEUP_EN_Pos = 0x1c
	// Bit mask of PA28_WAKEUP_EN field.
	SYSCON_PIO_WAKEUP_EN0_PA28_WAKEUP_EN_Msk = 0x10000000
	// Bit PA28_WAKEUP_EN.
	SYSCON_PIO_WAKEUP_EN0_PA28_WAKEUP_EN = 0x10000000
	// Position of PA29_WAKEUP_EN field.
	SYSCON_PIO_WAKEUP_EN0_PA29_WAKEUP_EN_Pos = 0x1d
	// Bit mask of PA29_WAKEUP_EN field.
	SYSCON_PIO_WAKEUP_EN0_PA29_WAKEUP_EN_Msk = 0x20000000
	// Bit PA29_WAKEUP_EN.
	SYSCON_PIO_WAKEUP_EN0_PA29_WAKEUP_EN = 0x20000000
	// Position of PA30_WAKEUP_EN field.
	SYSCON_PIO_WAKEUP_EN0_PA30_WAKEUP_EN_Pos = 0x1e
	// Bit mask of PA30_WAKEUP_EN field.
	SYSCON_PIO_WAKEUP_EN0_PA30_WAKEUP_EN_Msk = 0x40000000
	// Bit PA30_WAKEUP_EN.
	SYSCON_PIO_WAKEUP_EN0_PA30_WAKEUP_EN = 0x40000000
	// Position of PA31_WAKEUP_EN field.
	SYSCON_PIO_WAKEUP_EN0_PA31_WAKEUP_EN_Pos = 0x1f
	// Bit mask of PA31_WAKEUP_EN field.
	SYSCON_PIO_WAKEUP_EN0_PA31_WAKEUP_EN_Msk = 0x80000000
	// Bit PA31_WAKEUP_EN.
	SYSCON_PIO_WAKEUP_EN0_PA31_WAKEUP_EN = 0x80000000

	// PIO_WAKEUP_EN1: pin function selection in power down mode register 1
	// Position of PB00_WAKEUP_EN field.
	SYSCON_PIO_WAKEUP_EN1_PB00_WAKEUP_EN_Pos = 0x0
	// Bit mask of PB00_WAKEUP_EN field.
	SYSCON_PIO_WAKEUP_EN1_PB00_WAKEUP_EN_Msk = 0x1
	// Bit PB00_WAKEUP_EN.
	SYSCON_PIO_WAKEUP_EN1_PB00_WAKEUP_EN = 0x1
	// Position of PB01_WAKEUP_EN field.
	SYSCON_PIO_WAKEUP_EN1_PB01_WAKEUP_EN_Pos = 0x1
	// Bit mask of PB01_WAKEUP_EN field.
	SYSCON_PIO_WAKEUP_EN1_PB01_WAKEUP_EN_Msk = 0x2
	// Bit PB01_WAKEUP_EN.
	SYSCON_PIO_WAKEUP_EN1_PB01_WAKEUP_EN = 0x2
	// Position of PB02_WAKEUP_EN field.
	SYSCON_PIO_WAKEUP_EN1_PB02_WAKEUP_EN_Pos = 0x2
	// Bit mask of PB02_WAKEUP_EN field.
	SYSCON_PIO_WAKEUP_EN1_PB02_WAKEUP_EN_Msk = 0x4
	// Bit PB02_WAKEUP_EN.
	SYSCON_PIO_WAKEUP_EN1_PB02_WAKEUP_EN = 0x4
	// Position of PA04_32K_OE field.
	SYSCON_PIO_WAKEUP_EN1_PA04_32K_OE_Pos = 0x4
	// Bit mask of PA04_32K_OE field.
	SYSCON_PIO_WAKEUP_EN1_PA04_32K_OE_Msk = 0x10
	// Bit PA04_32K_OE.
	SYSCON_PIO_WAKEUP_EN1_PA04_32K_OE = 0x10
	// Position of PA05_XTAL_OE field.
	SYSCON_PIO_WAKEUP_EN1_PA05_XTAL_OE_Pos = 0x5
	// Bit mask of PA05_XTAL_OE field.
	SYSCON_PIO_WAKEUP_EN1_PA05_XTAL_OE_Msk = 0x20
	// Bit PA05_XTAL_OE.
	SYSCON_PIO_WAKEUP_EN1_PA05_XTAL_OE = 0x20
	// Position of PA10_32K_OE field.
	SYSCON_PIO_WAKEUP_EN1_PA10_32K_OE_Pos = 0xa
	// Bit mask of PA10_32K_OE field.
	SYSCON_PIO_WAKEUP_EN1_PA10_32K_OE_Msk = 0x400
	// Bit PA10_32K_OE.
	SYSCON_PIO_WAKEUP_EN1_PA10_32K_OE = 0x400
	// Position of PA11_XTAL_OE field.
	SYSCON_PIO_WAKEUP_EN1_PA11_XTAL_OE_Pos = 0xb
	// Bit mask of PA11_XTAL_OE field.
	SYSCON_PIO_WAKEUP_EN1_PA11_XTAL_OE_Msk = 0x800
	// Bit PA11_XTAL_OE.
	SYSCON_PIO_WAKEUP_EN1_PA11_XTAL_OE = 0x800
	// Position of PA18_32K_OE field.
	SYSCON_PIO_WAKEUP_EN1_PA18_32K_OE_Pos = 0x12
	// Bit mask of PA18_32K_OE field.
	SYSCON_PIO_WAKEUP_EN1_PA18_32K_OE_Msk = 0x40000
	// Bit PA18_32K_OE.
	SYSCON_PIO_WAKEUP_EN1_PA18_32K_OE = 0x40000
	// Position of PA19_XTAL_OE field.
	SYSCON_PIO_WAKEUP_EN1_PA19_XTAL_OE_Pos = 0x13
	// Bit mask of PA19_XTAL_OE field.
	SYSCON_PIO_WAKEUP_EN1_PA19_XTAL_OE_Msk = 0x80000
	// Bit PA19_XTAL_OE.
	SYSCON_PIO_WAKEUP_EN1_PA19_XTAL_OE = 0x80000
	// Position of PA24_32K_OE field.
	SYSCON_PIO_WAKEUP_EN1_PA24_32K_OE_Pos = 0x18
	// Bit mask of PA24_32K_OE field.
	SYSCON_PIO_WAKEUP_EN1_PA24_32K_OE_Msk = 0x1000000
	// Bit PA24_32K_OE.
	SYSCON_PIO_WAKEUP_EN1_PA24_32K_OE = 0x1000000
	// Position of PA25_XTAL_OE field.
	SYSCON_PIO_WAKEUP_EN1_PA25_XTAL_OE_Pos = 0x19
	// Bit mask of PA25_XTAL_OE field.
	SYSCON_PIO_WAKEUP_EN1_PA25_XTAL_OE_Msk = 0x2000000
	// Bit PA25_XTAL_OE.
	SYSCON_PIO_WAKEUP_EN1_PA25_XTAL_OE = 0x2000000
	// Position of PDM_IO_SEL field.
	SYSCON_PIO_WAKEUP_EN1_PDM_IO_SEL_Pos = 0x1f
	// Bit mask of PDM_IO_SEL field.
	SYSCON_PIO_WAKEUP_EN1_PDM_IO_SEL_Msk = 0x80000000
	// Bit PDM_IO_SEL.
	SYSCON_PIO_WAKEUP_EN1_PDM_IO_SEL = 0x80000000

	// PIO_CAP_OE0: pin output enable status register 0 while captured by writing 1 to IO_CAP
	// Position of PA00_CAP_OE field.
	SYSCON_PIO_CAP_OE0_PA00_CAP_OE_Pos = 0x0
	// Bit mask of PA00_CAP_OE field.
	SYSCON_PIO_CAP_OE0_PA00_CAP_OE_Msk = 0x1
	// Bit PA00_CAP_OE.
	SYSCON_PIO_CAP_OE0_PA00_CAP_OE = 0x1
	// Position of PA01_CAP_OE field.
	SYSCON_PIO_CAP_OE0_PA01_CAP_OE_Pos = 0x1
	// Bit mask of PA01_CAP_OE field.
	SYSCON_PIO_CAP_OE0_PA01_CAP_OE_Msk = 0x2
	// Bit PA01_CAP_OE.
	SYSCON_PIO_CAP_OE0_PA01_CAP_OE = 0x2
	// Position of PA02_CAP_OE field.
	SYSCON_PIO_CAP_OE0_PA02_CAP_OE_Pos = 0x2
	// Bit mask of PA02_CAP_OE field.
	SYSCON_PIO_CAP_OE0_PA02_CAP_OE_Msk = 0x4
	// Bit PA02_CAP_OE.
	SYSCON_PIO_CAP_OE0_PA02_CAP_OE = 0x4
	// Position of PA03_CAP_OE field.
	SYSCON_PIO_CAP_OE0_PA03_CAP_OE_Pos = 0x3
	// Bit mask of PA03_CAP_OE field.
	SYSCON_PIO_CAP_OE0_PA03_CAP_OE_Msk = 0x8
	// Bit PA03_CAP_OE.
	SYSCON_PIO_CAP_OE0_PA03_CAP_OE = 0x8
	// Position of PA04_CAP_OE field.
	SYSCON_PIO_CAP_OE0_PA04_CAP_OE_Pos = 0x4
	// Bit mask of PA04_CAP_OE field.
	SYSCON_PIO_CAP_OE0_PA04_CAP_OE_Msk = 0x10
	// Bit PA04_CAP_OE.
	SYSCON_PIO_CAP_OE0_PA04_CAP_OE = 0x10
	// Position of PA05_CAP_OE field.
	SYSCON_PIO_CAP_OE0_PA05_CAP_OE_Pos = 0x5
	// Bit mask of PA05_CAP_OE field.
	SYSCON_PIO_CAP_OE0_PA05_CAP_OE_Msk = 0x20
	// Bit PA05_CAP_OE.
	SYSCON_PIO_CAP_OE0_PA05_CAP_OE = 0x20
	// Position of PA06_CAP_OE field.
	SYSCON_PIO_CAP_OE0_PA06_CAP_OE_Pos = 0x6
	// Bit mask of PA06_CAP_OE field.
	SYSCON_PIO_CAP_OE0_PA06_CAP_OE_Msk = 0x40
	// Bit PA06_CAP_OE.
	SYSCON_PIO_CAP_OE0_PA06_CAP_OE = 0x40
	// Position of PA07_CAP_OE field.
	SYSCON_PIO_CAP_OE0_PA07_CAP_OE_Pos = 0x7
	// Bit mask of PA07_CAP_OE field.
	SYSCON_PIO_CAP_OE0_PA07_CAP_OE_Msk = 0x80
	// Bit PA07_CAP_OE.
	SYSCON_PIO_CAP_OE0_PA07_CAP_OE = 0x80
	// Position of PA08_CAP_OE field.
	SYSCON_PIO_CAP_OE0_PA08_CAP_OE_Pos = 0x8
	// Bit mask of PA08_CAP_OE field.
	SYSCON_PIO_CAP_OE0_PA08_CAP_OE_Msk = 0x100
	// Bit PA08_CAP_OE.
	SYSCON_PIO_CAP_OE0_PA08_CAP_OE = 0x100
	// Position of PA09_CAP_OE field.
	SYSCON_PIO_CAP_OE0_PA09_CAP_OE_Pos = 0x9
	// Bit mask of PA09_CAP_OE field.
	SYSCON_PIO_CAP_OE0_PA09_CAP_OE_Msk = 0x200
	// Bit PA09_CAP_OE.
	SYSCON_PIO_CAP_OE0_PA09_CAP_OE = 0x200
	// Position of PA10_CAP_OE field.
	SYSCON_PIO_CAP_OE0_PA10_CAP_OE_Pos = 0xa
	// Bit mask of PA10_CAP_OE field.
	SYSCON_PIO_CAP_OE0_PA10_CAP_OE_Msk = 0x400
	// Bit PA10_CAP_OE.
	SYSCON_PIO_CAP_OE0_PA10_CAP_OE = 0x400
	// Position of PA11_CAP_OE field.
	SYSCON_PIO_CAP_OE0_PA11_CAP_OE_Pos = 0xb
	// Bit mask of PA11_CAP_OE field.
	SYSCON_PIO_CAP_OE0_PA11_CAP_OE_Msk = 0x800
	// Bit PA11_CAP_OE.
	SYSCON_PIO_CAP_OE0_PA11_CAP_OE = 0x800
	// Position of PA12_CAP_OE field.
	SYSCON_PIO_CAP_OE0_PA12_CAP_OE_Pos = 0xc
	// Bit mask of PA12_CAP_OE field.
	SYSCON_PIO_CAP_OE0_PA12_CAP_OE_Msk = 0x1000
	// Bit PA12_CAP_OE.
	SYSCON_PIO_CAP_OE0_PA12_CAP_OE = 0x1000
	// Position of PA13_CAP_OE field.
	SYSCON_PIO_CAP_OE0_PA13_CAP_OE_Pos = 0xd
	// Bit mask of PA13_CAP_OE field.
	SYSCON_PIO_CAP_OE0_PA13_CAP_OE_Msk = 0x2000
	// Bit PA13_CAP_OE.
	SYSCON_PIO_CAP_OE0_PA13_CAP_OE = 0x2000
	// Position of PA14_CAP_OE field.
	SYSCON_PIO_CAP_OE0_PA14_CAP_OE_Pos = 0xe
	// Bit mask of PA14_CAP_OE field.
	SYSCON_PIO_CAP_OE0_PA14_CAP_OE_Msk = 0x4000
	// Bit PA14_CAP_OE.
	SYSCON_PIO_CAP_OE0_PA14_CAP_OE = 0x4000
	// Position of PA15_CAP_OE field.
	SYSCON_PIO_CAP_OE0_PA15_CAP_OE_Pos = 0xf
	// Bit mask of PA15_CAP_OE field.
	SYSCON_PIO_CAP_OE0_PA15_CAP_OE_Msk = 0x8000
	// Bit PA15_CAP_OE.
	SYSCON_PIO_CAP_OE0_PA15_CAP_OE = 0x8000
	// Position of PA16_CAP_OE field.
	SYSCON_PIO_CAP_OE0_PA16_CAP_OE_Pos = 0x10
	// Bit mask of PA16_CAP_OE field.
	SYSCON_PIO_CAP_OE0_PA16_CAP_OE_Msk = 0x10000
	// Bit PA16_CAP_OE.
	SYSCON_PIO_CAP_OE0_PA16_CAP_OE = 0x10000
	// Position of PA17_CAP_OE field.
	SYSCON_PIO_CAP_OE0_PA17_CAP_OE_Pos = 0x11
	// Bit mask of PA17_CAP_OE field.
	SYSCON_PIO_CAP_OE0_PA17_CAP_OE_Msk = 0x20000
	// Bit PA17_CAP_OE.
	SYSCON_PIO_CAP_OE0_PA17_CAP_OE = 0x20000
	// Position of PA18_CAP_OE field.
	SYSCON_PIO_CAP_OE0_PA18_CAP_OE_Pos = 0x12
	// Bit mask of PA18_CAP_OE field.
	SYSCON_PIO_CAP_OE0_PA18_CAP_OE_Msk = 0x40000
	// Bit PA18_CAP_OE.
	SYSCON_PIO_CAP_OE0_PA18_CAP_OE = 0x40000
	// Position of PA19_CAP_OE field.
	SYSCON_PIO_CAP_OE0_PA19_CAP_OE_Pos = 0x13
	// Bit mask of PA19_CAP_OE field.
	SYSCON_PIO_CAP_OE0_PA19_CAP_OE_Msk = 0x80000
	// Bit PA19_CAP_OE.
	SYSCON_PIO_CAP_OE0_PA19_CAP_OE = 0x80000
	// Position of PA20_CAP_OE field.
	SYSCON_PIO_CAP_OE0_PA20_CAP_OE_Pos = 0x14
	// Bit mask of PA20_CAP_OE field.
	SYSCON_PIO_CAP_OE0_PA20_CAP_OE_Msk = 0x100000
	// Bit PA20_CAP_OE.
	SYSCON_PIO_CAP_OE0_PA20_CAP_OE = 0x100000
	// Position of PA21_CAP_OE field.
	SYSCON_PIO_CAP_OE0_PA21_CAP_OE_Pos = 0x15
	// Bit mask of PA21_CAP_OE field.
	SYSCON_PIO_CAP_OE0_PA21_CAP_OE_Msk = 0x200000
	// Bit PA21_CAP_OE.
	SYSCON_PIO_CAP_OE0_PA21_CAP_OE = 0x200000
	// Position of PA22_CAP_OE field.
	SYSCON_PIO_CAP_OE0_PA22_CAP_OE_Pos = 0x16
	// Bit mask of PA22_CAP_OE field.
	SYSCON_PIO_CAP_OE0_PA22_CAP_OE_Msk = 0x400000
	// Bit PA22_CAP_OE.
	SYSCON_PIO_CAP_OE0_PA22_CAP_OE = 0x400000
	// Position of PA23_CAP_OE field.
	SYSCON_PIO_CAP_OE0_PA23_CAP_OE_Pos = 0x17
	// Bit mask of PA23_CAP_OE field.
	SYSCON_PIO_CAP_OE0_PA23_CAP_OE_Msk = 0x800000
	// Bit PA23_CAP_OE.
	SYSCON_PIO_CAP_OE0_PA23_CAP_OE = 0x800000
	// Position of PA24_CAP_OE field.
	SYSCON_PIO_CAP_OE0_PA24_CAP_OE_Pos = 0x18
	// Bit mask of PA24_CAP_OE field.
	SYSCON_PIO_CAP_OE0_PA24_CAP_OE_Msk = 0x1000000
	// Bit PA24_CAP_OE.
	SYSCON_PIO_CAP_OE0_PA24_CAP_OE = 0x1000000
	// Position of PA25_CAP_OE field.
	SYSCON_PIO_CAP_OE0_PA25_CAP_OE_Pos = 0x19
	// Bit mask of PA25_CAP_OE field.
	SYSCON_PIO_CAP_OE0_PA25_CAP_OE_Msk = 0x2000000
	// Bit PA25_CAP_OE.
	SYSCON_PIO_CAP_OE0_PA25_CAP_OE = 0x2000000
	// Position of PA26_CAP_OE field.
	SYSCON_PIO_CAP_OE0_PA26_CAP_OE_Pos = 0x1a
	// Bit mask of PA26_CAP_OE field.
	SYSCON_PIO_CAP_OE0_PA26_CAP_OE_Msk = 0x4000000
	// Bit PA26_CAP_OE.
	SYSCON_PIO_CAP_OE0_PA26_CAP_OE = 0x4000000
	// Position of PA27_CAP_OE field.
	SYSCON_PIO_CAP_OE0_PA27_CAP_OE_Pos = 0x1b
	// Bit mask of PA27_CAP_OE field.
	SYSCON_PIO_CAP_OE0_PA27_CAP_OE_Msk = 0x8000000
	// Bit PA27_CAP_OE.
	SYSCON_PIO_CAP_OE0_PA27_CAP_OE = 0x8000000
	// Position of PA28_CAP_OE field.
	SYSCON_PIO_CAP_OE0_PA28_CAP_OE_Pos = 0x1c
	// Bit mask of PA28_CAP_OE field.
	SYSCON_PIO_CAP_OE0_PA28_CAP_OE_Msk = 0x10000000
	// Bit PA28_CAP_OE.
	SYSCON_PIO_CAP_OE0_PA28_CAP_OE = 0x10000000
	// Position of PA29_CAP_OE field.
	SYSCON_PIO_CAP_OE0_PA29_CAP_OE_Pos = 0x1d
	// Bit mask of PA29_CAP_OE field.
	SYSCON_PIO_CAP_OE0_PA29_CAP_OE_Msk = 0x20000000
	// Bit PA29_CAP_OE.
	SYSCON_PIO_CAP_OE0_PA29_CAP_OE = 0x20000000
	// Position of PA30_CAP_OE field.
	SYSCON_PIO_CAP_OE0_PA30_CAP_OE_Pos = 0x1e
	// Bit mask of PA30_CAP_OE field.
	SYSCON_PIO_CAP_OE0_PA30_CAP_OE_Msk = 0x40000000
	// Bit PA30_CAP_OE.
	SYSCON_PIO_CAP_OE0_PA30_CAP_OE = 0x40000000
	// Position of PA31_CAP_OE field.
	SYSCON_PIO_CAP_OE0_PA31_CAP_OE_Pos = 0x1f
	// Bit mask of PA31_CAP_OE field.
	SYSCON_PIO_CAP_OE0_PA31_CAP_OE_Msk = 0x80000000
	// Bit PA31_CAP_OE.
	SYSCON_PIO_CAP_OE0_PA31_CAP_OE = 0x80000000

	// PIO_CAP_OE1: pin output enable status register 1 while captured by writing 1 to IO_CAP
	// Position of PB00_CAP_OE field.
	SYSCON_PIO_CAP_OE1_PB00_CAP_OE_Pos = 0x0
	// Bit mask of PB00_CAP_OE field.
	SYSCON_PIO_CAP_OE1_PB00_CAP_OE_Msk = 0x1
	// Bit PB00_CAP_OE.
	SYSCON_PIO_CAP_OE1_PB00_CAP_OE = 0x1
	// Position of PB01_CAP_OE field.
	SYSCON_PIO_CAP_OE1_PB01_CAP_OE_Pos = 0x1
	// Bit mask of PB01_CAP_OE field.
	SYSCON_PIO_CAP_OE1_PB01_CAP_OE_Msk = 0x2
	// Bit PB01_CAP_OE.
	SYSCON_PIO_CAP_OE1_PB01_CAP_OE = 0x2
	// Position of PB02_CAP_OE field.
	SYSCON_PIO_CAP_OE1_PB02_CAP_OE_Pos = 0x2
	// Bit mask of PB02_CAP_OE field.
	SYSCON_PIO_CAP_OE1_PB02_CAP_OE_Msk = 0x4
	// Bit PB02_CAP_OE.
	SYSCON_PIO_CAP_OE1_PB02_CAP_OE = 0x4

	// PIO_CAP_OUT0: pin output status register 0 while captured by writing 1 to IO_CAP
	// Position of PA00_CAP_OUT field.
	SYSCON_PIO_CAP_OUT0_PA00_CAP_OUT_Pos = 0x0
	// Bit mask of PA00_CAP_OUT field.
	SYSCON_PIO_CAP_OUT0_PA00_CAP_OUT_Msk = 0x1
	// Bit PA00_CAP_OUT.
	SYSCON_PIO_CAP_OUT0_PA00_CAP_OUT = 0x1
	// Position of PA01_CAP_OUT field.
	SYSCON_PIO_CAP_OUT0_PA01_CAP_OUT_Pos = 0x1
	// Bit mask of PA01_CAP_OUT field.
	SYSCON_PIO_CAP_OUT0_PA01_CAP_OUT_Msk = 0x2
	// Bit PA01_CAP_OUT.
	SYSCON_PIO_CAP_OUT0_PA01_CAP_OUT = 0x2
	// Position of PA02_CAP_OUT field.
	SYSCON_PIO_CAP_OUT0_PA02_CAP_OUT_Pos = 0x2
	// Bit mask of PA02_CAP_OUT field.
	SYSCON_PIO_CAP_OUT0_PA02_CAP_OUT_Msk = 0x4
	// Bit PA02_CAP_OUT.
	SYSCON_PIO_CAP_OUT0_PA02_CAP_OUT = 0x4
	// Position of PA03_CAP_OUT field.
	SYSCON_PIO_CAP_OUT0_PA03_CAP_OUT_Pos = 0x3
	// Bit mask of PA03_CAP_OUT field.
	SYSCON_PIO_CAP_OUT0_PA03_CAP_OUT_Msk = 0x8
	// Bit PA03_CAP_OUT.
	SYSCON_PIO_CAP_OUT0_PA03_CAP_OUT = 0x8
	// Position of PA04_CAP_OUT field.
	SYSCON_PIO_CAP_OUT0_PA04_CAP_OUT_Pos = 0x4
	// Bit mask of PA04_CAP_OUT field.
	SYSCON_PIO_CAP_OUT0_PA04_CAP_OUT_Msk = 0x10
	// Bit PA04_CAP_OUT.
	SYSCON_PIO_CAP_OUT0_PA04_CAP_OUT = 0x10
	// Position of PA05_CAP_OUT field.
	SYSCON_PIO_CAP_OUT0_PA05_CAP_OUT_Pos = 0x5
	// Bit mask of PA05_CAP_OUT field.
	SYSCON_PIO_CAP_OUT0_PA05_CAP_OUT_Msk = 0x20
	// Bit PA05_CAP_OUT.
	SYSCON_PIO_CAP_OUT0_PA05_CAP_OUT = 0x20
	// Position of PA06_CAP_OUT field.
	SYSCON_PIO_CAP_OUT0_PA06_CAP_OUT_Pos = 0x6
	// Bit mask of PA06_CAP_OUT field.
	SYSCON_PIO_CAP_OUT0_PA06_CAP_OUT_Msk = 0x40
	// Bit PA06_CAP_OUT.
	SYSCON_PIO_CAP_OUT0_PA06_CAP_OUT = 0x40
	// Position of PA07_CAP_OUT field.
	SYSCON_PIO_CAP_OUT0_PA07_CAP_OUT_Pos = 0x7
	// Bit mask of PA07_CAP_OUT field.
	SYSCON_PIO_CAP_OUT0_PA07_CAP_OUT_Msk = 0x80
	// Bit PA07_CAP_OUT.
	SYSCON_PIO_CAP_OUT0_PA07_CAP_OUT = 0x80
	// Position of PA08_CAP_OUT field.
	SYSCON_PIO_CAP_OUT0_PA08_CAP_OUT_Pos = 0x8
	// Bit mask of PA08_CAP_OUT field.
	SYSCON_PIO_CAP_OUT0_PA08_CAP_OUT_Msk = 0x100
	// Bit PA08_CAP_OUT.
	SYSCON_PIO_CAP_OUT0_PA08_CAP_OUT = 0x100
	// Position of PA09_CAP_OUT field.
	SYSCON_PIO_CAP_OUT0_PA09_CAP_OUT_Pos = 0x9
	// Bit mask of PA09_CAP_OUT field.
	SYSCON_PIO_CAP_OUT0_PA09_CAP_OUT_Msk = 0x200
	// Bit PA09_CAP_OUT.
	SYSCON_PIO_CAP_OUT0_PA09_CAP_OUT = 0x200
	// Position of PA10_CAP_OUT field.
	SYSCON_PIO_CAP_OUT0_PA10_CAP_OUT_Pos = 0xa
	// Bit mask of PA10_CAP_OUT field.
	SYSCON_PIO_CAP_OUT0_PA10_CAP_OUT_Msk = 0x400
	// Bit PA10_CAP_OUT.
	SYSCON_PIO_CAP_OUT0_PA10_CAP_OUT = 0x400
	// Position of PA11_CAP_OUT field.
	SYSCON_PIO_CAP_OUT0_PA11_CAP_OUT_Pos = 0xb
	// Bit mask of PA11_CAP_OUT field.
	SYSCON_PIO_CAP_OUT0_PA11_CAP_OUT_Msk = 0x800
	// Bit PA11_CAP_OUT.
	SYSCON_PIO_CAP_OUT0_PA11_CAP_OUT = 0x800
	// Position of PA12_CAP_OUT field.
	SYSCON_PIO_CAP_OUT0_PA12_CAP_OUT_Pos = 0xc
	// Bit mask of PA12_CAP_OUT field.
	SYSCON_PIO_CAP_OUT0_PA12_CAP_OUT_Msk = 0x1000
	// Bit PA12_CAP_OUT.
	SYSCON_PIO_CAP_OUT0_PA12_CAP_OUT = 0x1000
	// Position of PA13_CAP_OUT field.
	SYSCON_PIO_CAP_OUT0_PA13_CAP_OUT_Pos = 0xd
	// Bit mask of PA13_CAP_OUT field.
	SYSCON_PIO_CAP_OUT0_PA13_CAP_OUT_Msk = 0x2000
	// Bit PA13_CAP_OUT.
	SYSCON_PIO_CAP_OUT0_PA13_CAP_OUT = 0x2000
	// Position of PA14_CAP_OUT field.
	SYSCON_PIO_CAP_OUT0_PA14_CAP_OUT_Pos = 0xe
	// Bit mask of PA14_CAP_OUT field.
	SYSCON_PIO_CAP_OUT0_PA14_CAP_OUT_Msk = 0x4000
	// Bit PA14_CAP_OUT.
	SYSCON_PIO_CAP_OUT0_PA14_CAP_OUT = 0x4000
	// Position of PA15_CAP_OUT field.
	SYSCON_PIO_CAP_OUT0_PA15_CAP_OUT_Pos = 0xf
	// Bit mask of PA15_CAP_OUT field.
	SYSCON_PIO_CAP_OUT0_PA15_CAP_OUT_Msk = 0x8000
	// Bit PA15_CAP_OUT.
	SYSCON_PIO_CAP_OUT0_PA15_CAP_OUT = 0x8000
	// Position of PA16_CAP_OUT field.
	SYSCON_PIO_CAP_OUT0_PA16_CAP_OUT_Pos = 0x10
	// Bit mask of PA16_CAP_OUT field.
	SYSCON_PIO_CAP_OUT0_PA16_CAP_OUT_Msk = 0x10000
	// Bit PA16_CAP_OUT.
	SYSCON_PIO_CAP_OUT0_PA16_CAP_OUT = 0x10000
	// Position of PA17_CAP_OUT field.
	SYSCON_PIO_CAP_OUT0_PA17_CAP_OUT_Pos = 0x11
	// Bit mask of PA17_CAP_OUT field.
	SYSCON_PIO_CAP_OUT0_PA17_CAP_OUT_Msk = 0x20000
	// Bit PA17_CAP_OUT.
	SYSCON_PIO_CAP_OUT0_PA17_CAP_OUT = 0x20000
	// Position of PA18_CAP_OUT field.
	SYSCON_PIO_CAP_OUT0_PA18_CAP_OUT_Pos = 0x12
	// Bit mask of PA18_CAP_OUT field.
	SYSCON_PIO_CAP_OUT0_PA18_CAP_OUT_Msk = 0x40000
	// Bit PA18_CAP_OUT.
	SYSCON_PIO_CAP_OUT0_PA18_CAP_OUT = 0x40000
	// Position of PA19_CAP_OUT field.
	SYSCON_PIO_CAP_OUT0_PA19_CAP_OUT_Pos = 0x13
	// Bit mask of PA19_CAP_OUT field.
	SYSCON_PIO_CAP_OUT0_PA19_CAP_OUT_Msk = 0x80000
	// Bit PA19_CAP_OUT.
	SYSCON_PIO_CAP_OUT0_PA19_CAP_OUT = 0x80000
	// Position of PA20_CAP_OUT field.
	SYSCON_PIO_CAP_OUT0_PA20_CAP_OUT_Pos = 0x14
	// Bit mask of PA20_CAP_OUT field.
	SYSCON_PIO_CAP_OUT0_PA20_CAP_OUT_Msk = 0x100000
	// Bit PA20_CAP_OUT.
	SYSCON_PIO_CAP_OUT0_PA20_CAP_OUT = 0x100000
	// Position of PA21_CAP_OUT field.
	SYSCON_PIO_CAP_OUT0_PA21_CAP_OUT_Pos = 0x15
	// Bit mask of PA21_CAP_OUT field.
	SYSCON_PIO_CAP_OUT0_PA21_CAP_OUT_Msk = 0x200000
	// Bit PA21_CAP_OUT.
	SYSCON_PIO_CAP_OUT0_PA21_CAP_OUT = 0x200000
	// Position of PA22_CAP_OUT field.
	SYSCON_PIO_CAP_OUT0_PA22_CAP_OUT_Pos = 0x16
	// Bit mask of PA22_CAP_OUT field.
	SYSCON_PIO_CAP_OUT0_PA22_CAP_OUT_Msk = 0x400000
	// Bit PA22_CAP_OUT.
	SYSCON_PIO_CAP_OUT0_PA22_CAP_OUT = 0x400000
	// Position of PA23_CAP_OUT field.
	SYSCON_PIO_CAP_OUT0_PA23_CAP_OUT_Pos = 0x17
	// Bit mask of PA23_CAP_OUT field.
	SYSCON_PIO_CAP_OUT0_PA23_CAP_OUT_Msk = 0x800000
	// Bit PA23_CAP_OUT.
	SYSCON_PIO_CAP_OUT0_PA23_CAP_OUT = 0x800000
	// Position of PA24_CAP_OUT field.
	SYSCON_PIO_CAP_OUT0_PA24_CAP_OUT_Pos = 0x18
	// Bit mask of PA24_CAP_OUT field.
	SYSCON_PIO_CAP_OUT0_PA24_CAP_OUT_Msk = 0x1000000
	// Bit PA24_CAP_OUT.
	SYSCON_PIO_CAP_OUT0_PA24_CAP_OUT = 0x1000000
	// Position of PA25_CAP_OUT field.
	SYSCON_PIO_CAP_OUT0_PA25_CAP_OUT_Pos = 0x19
	// Bit mask of PA25_CAP_OUT field.
	SYSCON_PIO_CAP_OUT0_PA25_CAP_OUT_Msk = 0x2000000
	// Bit PA25_CAP_OUT.
	SYSCON_PIO_CAP_OUT0_PA25_CAP_OUT = 0x2000000
	// Position of PA26_CAP_OUT field.
	SYSCON_PIO_CAP_OUT0_PA26_CAP_OUT_Pos = 0x1a
	// Bit mask of PA26_CAP_OUT field.
	SYSCON_PIO_CAP_OUT0_PA26_CAP_OUT_Msk = 0x4000000
	// Bit PA26_CAP_OUT.
	SYSCON_PIO_CAP_OUT0_PA26_CAP_OUT = 0x4000000
	// Position of PA27_CAP_OUT field.
	SYSCON_PIO_CAP_OUT0_PA27_CAP_OUT_Pos = 0x1b
	// Bit mask of PA27_CAP_OUT field.
	SYSCON_PIO_CAP_OUT0_PA27_CAP_OUT_Msk = 0x8000000
	// Bit PA27_CAP_OUT.
	SYSCON_PIO_CAP_OUT0_PA27_CAP_OUT = 0x8000000
	// Position of PA28_CAP_OUT field.
	SYSCON_PIO_CAP_OUT0_PA28_CAP_OUT_Pos = 0x1c
	// Bit mask of PA28_CAP_OUT field.
	SYSCON_PIO_CAP_OUT0_PA28_CAP_OUT_Msk = 0x10000000
	// Bit PA28_CAP_OUT.
	SYSCON_PIO_CAP_OUT0_PA28_CAP_OUT = 0x10000000
	// Position of PA29_CAP_OUT field.
	SYSCON_PIO_CAP_OUT0_PA29_CAP_OUT_Pos = 0x1d
	// Bit mask of PA29_CAP_OUT field.
	SYSCON_PIO_CAP_OUT0_PA29_CAP_OUT_Msk = 0x20000000
	// Bit PA29_CAP_OUT.
	SYSCON_PIO_CAP_OUT0_PA29_CAP_OUT = 0x20000000
	// Position of PA30_CAP_OUT field.
	SYSCON_PIO_CAP_OUT0_PA30_CAP_OUT_Pos = 0x1e
	// Bit mask of PA30_CAP_OUT field.
	SYSCON_PIO_CAP_OUT0_PA30_CAP_OUT_Msk = 0x40000000
	// Bit PA30_CAP_OUT.
	SYSCON_PIO_CAP_OUT0_PA30_CAP_OUT = 0x40000000
	// Position of PA31_CAP_OUT field.
	SYSCON_PIO_CAP_OUT0_PA31_CAP_OUT_Pos = 0x1f
	// Bit mask of PA31_CAP_OUT field.
	SYSCON_PIO_CAP_OUT0_PA31_CAP_OUT_Msk = 0x80000000
	// Bit PA31_CAP_OUT.
	SYSCON_PIO_CAP_OUT0_PA31_CAP_OUT = 0x80000000

	// PIO_CAP_OUT1: pin output status register 0 while captured by writing 1 to IO_CAP
	// Position of PB00_CAP_OUT field.
	SYSCON_PIO_CAP_OUT1_PB00_CAP_OUT_Pos = 0x0
	// Bit mask of PB00_CAP_OUT field.
	SYSCON_PIO_CAP_OUT1_PB00_CAP_OUT_Msk = 0x1
	// Bit PB00_CAP_OUT.
	SYSCON_PIO_CAP_OUT1_PB00_CAP_OUT = 0x1
	// Position of PB01_CAP_OUT field.
	SYSCON_PIO_CAP_OUT1_PB01_CAP_OUT_Pos = 0x1
	// Bit mask of PB01_CAP_OUT field.
	SYSCON_PIO_CAP_OUT1_PB01_CAP_OUT_Msk = 0x2
	// Bit PB01_CAP_OUT.
	SYSCON_PIO_CAP_OUT1_PB01_CAP_OUT = 0x2
	// Position of PB02_CAP_OUT field.
	SYSCON_PIO_CAP_OUT1_PB02_CAP_OUT_Pos = 0x2
	// Bit mask of PB02_CAP_OUT field.
	SYSCON_PIO_CAP_OUT1_PB02_CAP_OUT_Msk = 0x4
	// Bit PB02_CAP_OUT.
	SYSCON_PIO_CAP_OUT1_PB02_CAP_OUT = 0x4

	// RST_CAUSE_SRC: reset source status register
	// Position of RESET_CAUSE field.
	SYSCON_RST_CAUSE_SRC_RESET_CAUSE_Pos = 0x0
	// Bit mask of RESET_CAUSE field.
	SYSCON_RST_CAUSE_SRC_RESET_CAUSE_Msk = 0x1ff
	// Position of RST_CAUSE_CLR field.
	SYSCON_RST_CAUSE_SRC_RST_CAUSE_CLR_Pos = 0x1f
	// Bit mask of RST_CAUSE_CLR field.
	SYSCON_RST_CAUSE_SRC_RST_CAUSE_CLR_Msk = 0x80000000
	// Bit RST_CAUSE_CLR.
	SYSCON_RST_CAUSE_SRC_RST_CAUSE_CLR = 0x80000000

	// PMU_CTRL0: power management uinit control register 0
	// Position of MEM0_DIS field.
	SYSCON_PMU_CTRL0_MEM0_DIS_Pos = 0x0
	// Bit mask of MEM0_DIS field.
	SYSCON_PMU_CTRL0_MEM0_DIS_Msk = 0x1
	// Bit MEM0_DIS.
	SYSCON_PMU_CTRL0_MEM0_DIS = 0x1
	// Position of MEM1_DIS field.
	SYSCON_PMU_CTRL0_MEM1_DIS_Pos = 0x1
	// Bit mask of MEM1_DIS field.
	SYSCON_PMU_CTRL0_MEM1_DIS_Msk = 0x2
	// Bit MEM1_DIS.
	SYSCON_PMU_CTRL0_MEM1_DIS = 0x2
	// Position of MEM2_DIS field.
	SYSCON_PMU_CTRL0_MEM2_DIS_Pos = 0x2
	// Bit mask of MEM2_DIS field.
	SYSCON_PMU_CTRL0_MEM2_DIS_Msk = 0x4
	// Bit MEM2_DIS.
	SYSCON_PMU_CTRL0_MEM2_DIS = 0x4
	// Position of MEM3_DIS field.
	SYSCON_PMU_CTRL0_MEM3_DIS_Pos = 0x3
	// Bit mask of MEM3_DIS field.
	SYSCON_PMU_CTRL0_MEM3_DIS_Msk = 0x8
	// Bit MEM3_DIS.
	SYSCON_PMU_CTRL0_MEM3_DIS = 0x8
	// Position of MEM4_DIS field.
	SYSCON_PMU_CTRL0_MEM4_DIS_Pos = 0x4
	// Bit mask of MEM4_DIS field.
	SYSCON_PMU_CTRL0_MEM4_DIS_Msk = 0x10
	// Bit MEM4_DIS.
	SYSCON_PMU_CTRL0_MEM4_DIS = 0x10
	// Position of MEM5_DIS field.
	SYSCON_PMU_CTRL0_MEM5_DIS_Pos = 0x5
	// Bit mask of MEM5_DIS field.
	SYSCON_PMU_CTRL0_MEM5_DIS_Msk = 0x20
	// Bit MEM5_DIS.
	SYSCON_PMU_CTRL0_MEM5_DIS = 0x20
	// Position of MEM6_DIS field.
	SYSCON_PMU_CTRL0_MEM6_DIS_Pos = 0x6
	// Bit mask of MEM6_DIS field.
	SYSCON_PMU_CTRL0_MEM6_DIS_Msk = 0x40
	// Bit MEM6_DIS.
	SYSCON_PMU_CTRL0_MEM6_DIS = 0x40
	// Position of MEM7_DIS field.
	SYSCON_PMU_CTRL0_MEM7_DIS_Pos = 0x7
	// Bit mask of MEM7_DIS field.
	SYSCON_PMU_CTRL0_MEM7_DIS_Msk = 0x80
	// Bit MEM7_DIS.
	SYSCON_PMU_CTRL0_MEM7_DIS = 0x80
	// Position of MEM8_DIS field.
	SYSCON_PMU_CTRL0_MEM8_DIS_Pos = 0x8
	// Bit mask of MEM8_DIS field.
	SYSCON_PMU_CTRL0_MEM8_DIS_Msk = 0x100
	// Bit MEM8_DIS.
	SYSCON_PMU_CTRL0_MEM8_DIS = 0x100
	// Position of MEM9_DIS field.
	SYSCON_PMU_CTRL0_MEM9_DIS_Pos = 0x9
	// Bit mask of MEM9_DIS field.
	SYSCON_PMU_CTRL0_MEM9_DIS_Msk = 0x200
	// Bit MEM9_DIS.
	SYSCON_PMU_CTRL0_MEM9_DIS = 0x200
	// Position of BLE_DIS field.
	SYSCON_PMU_CTRL0_BLE_DIS_Pos = 0x10
	// Bit mask of BLE_DIS field.
	SYSCON_PMU_CTRL0_BLE_DIS_Msk = 0x10000
	// Bit BLE_DIS.
	SYSCON_PMU_CTRL0_BLE_DIS = 0x10000
	// Position of FIR_DIS field.
	SYSCON_PMU_CTRL0_FIR_DIS_Pos = 0x11
	// Bit mask of FIR_DIS field.
	SYSCON_PMU_CTRL0_FIR_DIS_Msk = 0x20000
	// Bit FIR_DIS.
	SYSCON_PMU_CTRL0_FIR_DIS = 0x20000
	// Position of FSP_DIS field.
	SYSCON_PMU_CTRL0_FSP_DIS_Pos = 0x12
	// Bit mask of FSP_DIS field.
	SYSCON_PMU_CTRL0_FSP_DIS_Msk = 0x40000
	// Bit FSP_DIS.
	SYSCON_PMU_CTRL0_FSP_DIS = 0x40000
	// Position of MCU_MODE field.
	SYSCON_PMU_CTRL0_MCU_MODE_Pos = 0x14
	// Bit mask of MCU_MODE field.
	SYSCON_PMU_CTRL0_MCU_MODE_Msk = 0x100000
	// Bit MCU_MODE.
	SYSCON_PMU_CTRL0_MCU_MODE = 0x100000
	// power on BG, V2I, VREG_A, VREG_D
	SYSCON_PMU_CTRL0_MCU_MODE_ANA_PWRON = 0x0
	// power off BG, V2I, VREG_A, VREG_D
	SYSCON_PMU_CTRL0_MCU_MODE_ANA_PWROFF = 0x1
	// Position of OSC_INT_EN field.
	SYSCON_PMU_CTRL0_OSC_INT_EN_Pos = 0x1a
	// Bit mask of OSC_INT_EN field.
	SYSCON_PMU_CTRL0_OSC_INT_EN_Msk = 0x4000000
	// Bit OSC_INT_EN.
	SYSCON_PMU_CTRL0_OSC_INT_EN = 0x4000000
	// Position of RTC_SEC_WAKEUP_EN field.
	SYSCON_PMU_CTRL0_RTC_SEC_WAKEUP_EN_Pos = 0x1b
	// Bit mask of RTC_SEC_WAKEUP_EN field.
	SYSCON_PMU_CTRL0_RTC_SEC_WAKEUP_EN_Msk = 0x8000000
	// Bit RTC_SEC_WAKEUP_EN.
	SYSCON_PMU_CTRL0_RTC_SEC_WAKEUP_EN = 0x8000000
	// Position of WAKEUP_EN field.
	SYSCON_PMU_CTRL0_WAKEUP_EN_Pos = 0x1c
	// Bit mask of WAKEUP_EN field.
	SYSCON_PMU_CTRL0_WAKEUP_EN_Msk = 0x10000000
	// Bit WAKEUP_EN.
	SYSCON_PMU_CTRL0_WAKEUP_EN = 0x10000000
	// Position of PMU_EN field.
	SYSCON_PMU_CTRL0_PMU_EN_Pos = 0x1d
	// Bit mask of PMU_EN field.
	SYSCON_PMU_CTRL0_PMU_EN_Msk = 0x20000000
	// Bit PMU_EN.
	SYSCON_PMU_CTRL0_PMU_EN = 0x20000000
	// Position of RETENTION_EN field.
	SYSCON_PMU_CTRL0_RETENTION_EN_Pos = 0x1e
	// Bit mask of RETENTION_EN field.
	SYSCON_PMU_CTRL0_RETENTION_EN_Msk = 0x40000000
	// Bit RETENTION_EN.
	SYSCON_PMU_CTRL0_RETENTION_EN = 0x40000000
	// Position of BOND_EN field.
	SYSCON_PMU_CTRL0_BOND_EN_Pos = 0x1f
	// Bit mask of BOND_EN field.
	SYSCON_PMU_CTRL0_BOND_EN_Msk = 0x80000000
	// Bit BOND_EN.
	SYSCON_PMU_CTRL0_BOND_EN = 0x80000000

	// PMU_CTRL1: power management uinit control register 1
	// Position of RCO32K_DIS field.
	SYSCON_PMU_CTRL1_RCO32K_DIS_Pos = 0x0
	// Bit mask of RCO32K_DIS field.
	SYSCON_PMU_CTRL1_RCO32K_DIS_Msk = 0x1
	// Bit RCO32K_DIS.
	SYSCON_PMU_CTRL1_RCO32K_DIS = 0x1
	// Position of XTAL32K_DIS field.
	SYSCON_PMU_CTRL1_XTAL32K_DIS_Pos = 0x1
	// Bit mask of XTAL32K_DIS field.
	SYSCON_PMU_CTRL1_XTAL32K_DIS_Msk = 0x2
	// Bit XTAL32K_DIS.
	SYSCON_PMU_CTRL1_XTAL32K_DIS = 0x2
	// Position of XTAL_DIS field.
	SYSCON_PMU_CTRL1_XTAL_DIS_Pos = 0x2
	// Bit mask of XTAL_DIS field.
	SYSCON_PMU_CTRL1_XTAL_DIS_Msk = 0x4
	// Bit XTAL_DIS.
	SYSCON_PMU_CTRL1_XTAL_DIS = 0x4
	// Position of OSC32M_DIS field.
	SYSCON_PMU_CTRL1_OSC32M_DIS_Pos = 0x3
	// Bit mask of OSC32M_DIS field.
	SYSCON_PMU_CTRL1_OSC32M_DIS_Msk = 0x8
	// Bit OSC32M_DIS.
	SYSCON_PMU_CTRL1_OSC32M_DIS = 0x8
	// Position of USBPLL_DIS field.
	SYSCON_PMU_CTRL1_USBPLL_DIS_Pos = 0x4
	// Bit mask of USBPLL_DIS field.
	SYSCON_PMU_CTRL1_USBPLL_DIS_Msk = 0x10
	// Bit USBPLL_DIS.
	SYSCON_PMU_CTRL1_USBPLL_DIS = 0x10
	// Position of ADC_BUF_DIS field.
	SYSCON_PMU_CTRL1_ADC_BUF_DIS_Pos = 0x5
	// Bit mask of ADC_BUF_DIS field.
	SYSCON_PMU_CTRL1_ADC_BUF_DIS_Msk = 0x20
	// Bit ADC_BUF_DIS.
	SYSCON_PMU_CTRL1_ADC_BUF_DIS = 0x20
	// Position of ADC_BG_DIS field.
	SYSCON_PMU_CTRL1_ADC_BG_DIS_Pos = 0x6
	// Bit mask of ADC_BG_DIS field.
	SYSCON_PMU_CTRL1_ADC_BG_DIS_Msk = 0x40
	// Bit ADC_BG_DIS.
	SYSCON_PMU_CTRL1_ADC_BG_DIS = 0x40
	// Position of ADC_DIS field.
	SYSCON_PMU_CTRL1_ADC_DIS_Pos = 0x7
	// Bit mask of ADC_DIS field.
	SYSCON_PMU_CTRL1_ADC_DIS_Msk = 0x80
	// Bit ADC_DIS.
	SYSCON_PMU_CTRL1_ADC_DIS = 0x80
	// Position of ADC_VCM_DIS field.
	SYSCON_PMU_CTRL1_ADC_VCM_DIS_Pos = 0x8
	// Bit mask of ADC_VCM_DIS field.
	SYSCON_PMU_CTRL1_ADC_VCM_DIS_Msk = 0x100
	// Bit ADC_VCM_DIS.
	SYSCON_PMU_CTRL1_ADC_VCM_DIS = 0x100
	// Position of ADC_VREF_DIS field.
	SYSCON_PMU_CTRL1_ADC_VREF_DIS_Pos = 0x9
	// Bit mask of ADC_VREF_DIS field.
	SYSCON_PMU_CTRL1_ADC_VREF_DIS_Msk = 0x200
	// Bit ADC_VREF_DIS.
	SYSCON_PMU_CTRL1_ADC_VREF_DIS = 0x200
	// Position of DAC_DIS field.
	SYSCON_PMU_CTRL1_DAC_DIS_Pos = 0xa
	// Bit mask of DAC_DIS field.
	SYSCON_PMU_CTRL1_DAC_DIS_Msk = 0x400
	// Bit DAC_DIS.
	SYSCON_PMU_CTRL1_DAC_DIS = 0x400
	// Position of CAP_SEN_DIS field.
	SYSCON_PMU_CTRL1_CAP_SEN_DIS_Pos = 0xb
	// Bit mask of CAP_SEN_DIS field.
	SYSCON_PMU_CTRL1_CAP_SEN_DIS_Msk = 0x800
	// Bit CAP_SEN_DIS.
	SYSCON_PMU_CTRL1_CAP_SEN_DIS = 0x800
	// Position of BUCK_CTRL field.
	SYSCON_PMU_CTRL1_BUCK_CTRL_Pos = 0x10
	// Bit mask of BUCK_CTRL field.
	SYSCON_PMU_CTRL1_BUCK_CTRL_Msk = 0xf0000
	// Position of RCO32K_PDM_DIS field.
	SYSCON_PMU_CTRL1_RCO32K_PDM_DIS_Pos = 0x1e
	// Bit mask of RCO32K_PDM_DIS field.
	SYSCON_PMU_CTRL1_RCO32K_PDM_DIS_Msk = 0x40000000
	// Bit RCO32K_PDM_DIS.
	SYSCON_PMU_CTRL1_RCO32K_PDM_DIS = 0x40000000
	// Position of XTAL32K_PDM_DIS field.
	SYSCON_PMU_CTRL1_XTAL32K_PDM_DIS_Pos = 0x1f
	// Bit mask of XTAL32K_PDM_DIS field.
	SYSCON_PMU_CTRL1_XTAL32K_PDM_DIS_Msk = 0x80000000
	// Bit XTAL32K_PDM_DIS.
	SYSCON_PMU_CTRL1_XTAL32K_PDM_DIS = 0x80000000

	// ANA_EN: analog setting register
	// Position of BOD_AMP_EN field.
	SYSCON_ANA_EN_BOD_AMP_EN_Pos = 0x0
	// Bit mask of BOD_AMP_EN field.
	SYSCON_ANA_EN_BOD_AMP_EN_Msk = 0x1
	// Bit BOD_AMP_EN.
	SYSCON_ANA_EN_BOD_AMP_EN = 0x1
	// Position of BOD_EN field.
	SYSCON_ANA_EN_BOD_EN_Pos = 0x1
	// Bit mask of BOD_EN field.
	SYSCON_ANA_EN_BOD_EN_Msk = 0x2
	// Bit BOD_EN.
	SYSCON_ANA_EN_BOD_EN = 0x2
	// Position of BAT_MON_EN field.
	SYSCON_ANA_EN_BAT_MON_EN_Pos = 0x2
	// Bit mask of BAT_MON_EN field.
	SYSCON_ANA_EN_BAT_MON_EN_Msk = 0x4
	// Bit BAT_MON_EN.
	SYSCON_ANA_EN_BAT_MON_EN = 0x4
	// Position of ACMP0_EN field.
	SYSCON_ANA_EN_ACMP0_EN_Pos = 0x3
	// Bit mask of ACMP0_EN field.
	SYSCON_ANA_EN_ACMP0_EN_Msk = 0x8
	// Bit ACMP0_EN.
	SYSCON_ANA_EN_ACMP0_EN = 0x8
	// Position of ACMP1_EN field.
	SYSCON_ANA_EN_ACMP1_EN_Pos = 0x4
	// Bit mask of ACMP1_EN field.
	SYSCON_ANA_EN_ACMP1_EN_Msk = 0x10
	// Bit ACMP1_EN.
	SYSCON_ANA_EN_ACMP1_EN = 0x10
	// Position of BOR_AMP_EN field.
	SYSCON_ANA_EN_BOR_AMP_EN_Pos = 0x5
	// Bit mask of BOR_AMP_EN field.
	SYSCON_ANA_EN_BOR_AMP_EN_Msk = 0x20
	// Bit BOR_AMP_EN.
	SYSCON_ANA_EN_BOR_AMP_EN = 0x20
	// Position of BOR_EN field.
	SYSCON_ANA_EN_BOR_EN_Pos = 0x6
	// Bit mask of BOR_EN field.
	SYSCON_ANA_EN_BOR_EN_Msk = 0x40
	// Bit BOR_EN.
	SYSCON_ANA_EN_BOR_EN = 0x40
	// Position of ACMP0_REF field.
	SYSCON_ANA_EN_ACMP0_REF_Pos = 0x8
	// Bit mask of ACMP0_REF field.
	SYSCON_ANA_EN_ACMP0_REF_Msk = 0xf00
	// Position of ACMP1_REF field.
	SYSCON_ANA_EN_ACMP1_REF_Pos = 0xc
	// Bit mask of ACMP1_REF field.
	SYSCON_ANA_EN_ACMP1_REF_Msk = 0xf000
	// Position of ACMP0_HYST_EN field.
	SYSCON_ANA_EN_ACMP0_HYST_EN_Pos = 0x10
	// Bit mask of ACMP0_HYST_EN field.
	SYSCON_ANA_EN_ACMP0_HYST_EN_Msk = 0x10000
	// Bit ACMP0_HYST_EN.
	SYSCON_ANA_EN_ACMP0_HYST_EN = 0x10000
	// Position of ACMP1_HYST_EN field.
	SYSCON_ANA_EN_ACMP1_HYST_EN_Pos = 0x11
	// Bit mask of ACMP1_HYST_EN field.
	SYSCON_ANA_EN_ACMP1_HYST_EN_Msk = 0x20000
	// Bit ACMP1_HYST_EN.
	SYSCON_ANA_EN_ACMP1_HYST_EN = 0x20000
	// Position of ACMP_VREF_SEL field.
	SYSCON_ANA_EN_ACMP_VREF_SEL_Pos = 0x12
	// Bit mask of ACMP_VREF_SEL field.
	SYSCON_ANA_EN_ACMP_VREF_SEL_Msk = 0x40000
	// Bit ACMP_VREF_SEL.
	SYSCON_ANA_EN_ACMP_VREF_SEL = 0x40000
	// Position of BOD_THR field.
	SYSCON_ANA_EN_BOD_THR_Pos = 0x13
	// Bit mask of BOD_THR field.
	SYSCON_ANA_EN_BOD_THR_Msk = 0x180000
	// trigger at 2.06V, with 295mV hysteresis
	SYSCON_ANA_EN_BOD_THR_BOD_THR0 = 0x0
	// trigger at 2.45V, with 350mV hysteresis
	SYSCON_ANA_EN_BOD_THR_BOD_THR1 = 0x1
	// trigger at 2.72V, with 388mV hysteresis
	SYSCON_ANA_EN_BOD_THR_BOD_THR2 = 0x2
	// trigger at 3.04V, with 435mV hysteresis
	SYSCON_ANA_EN_BOD_THR_BOD_THR3 = 0x3
	// Position of BOR_THR field.
	SYSCON_ANA_EN_BOR_THR_Pos = 0x15
	// Bit mask of BOR_THR field.
	SYSCON_ANA_EN_BOR_THR_Msk = 0x600000
	// trigger at 1.5V
	SYSCON_ANA_EN_BOR_THR_BOR_THR0 = 0x0
	// trigger at 1.85V
	SYSCON_ANA_EN_BOR_THR_BOR_THR1 = 0x1
	// trigger at 2V
	SYSCON_ANA_EN_BOR_THR_BOR_THR2 = 0x2
	// trigger at 2.3V
	SYSCON_ANA_EN_BOR_THR_BOR_THR3 = 0x3
	// Position of ACMP0_OUT field.
	SYSCON_ANA_EN_ACMP0_OUT_Pos = 0x18
	// Bit mask of ACMP0_OUT field.
	SYSCON_ANA_EN_ACMP0_OUT_Msk = 0x1000000
	// Bit ACMP0_OUT.
	SYSCON_ANA_EN_ACMP0_OUT = 0x1000000
	// Position of ACMP1_OUT field.
	SYSCON_ANA_EN_ACMP1_OUT_Pos = 0x19
	// Bit mask of ACMP1_OUT field.
	SYSCON_ANA_EN_ACMP1_OUT_Msk = 0x2000000
	// Bit ACMP1_OUT.
	SYSCON_ANA_EN_ACMP1_OUT = 0x2000000
	// Position of ACMP0_EDGE_SEL field.
	SYSCON_ANA_EN_ACMP0_EDGE_SEL_Pos = 0x1a
	// Bit mask of ACMP0_EDGE_SEL field.
	SYSCON_ANA_EN_ACMP0_EDGE_SEL_Msk = 0xc000000
	// posedge
	SYSCON_ANA_EN_ACMP0_EDGE_SEL_POSEDGE = 0x0
	// negedge
	SYSCON_ANA_EN_ACMP0_EDGE_SEL_NEGEDGE = 0x1
	// both edge
	SYSCON_ANA_EN_ACMP0_EDGE_SEL_BOTHEDGE = 0x2
	// Position of ACMP1_EDGE_SEL field.
	SYSCON_ANA_EN_ACMP1_EDGE_SEL_Pos = 0x1c
	// Bit mask of ACMP1_EDGE_SEL field.
	SYSCON_ANA_EN_ACMP1_EDGE_SEL_Msk = 0x30000000
	// Position of ACMP0_INTEN field.
	SYSCON_ANA_EN_ACMP0_INTEN_Pos = 0x1e
	// Bit mask of ACMP0_INTEN field.
	SYSCON_ANA_EN_ACMP0_INTEN_Msk = 0x40000000
	// Bit ACMP0_INTEN.
	SYSCON_ANA_EN_ACMP0_INTEN = 0x40000000
	// Position of ACMP1_INTEN field.
	SYSCON_ANA_EN_ACMP1_INTEN_Pos = 0x1f
	// Bit mask of ACMP1_INTEN field.
	SYSCON_ANA_EN_ACMP1_INTEN_Msk = 0x80000000
	// Bit ACMP1_INTEN.
	SYSCON_ANA_EN_ACMP1_INTEN = 0x80000000

	// XTAL32K_CTRL: crystal 32K control register
	// Position of XTAL32K_ICTRL field.
	SYSCON_XTAL32K_CTRL_XTAL32K_ICTRL_Pos = 0x0
	// Bit mask of XTAL32K_ICTRL field.
	SYSCON_XTAL32K_CTRL_XTAL32K_ICTRL_Msk = 0x3f
	// Position of XTAL32K_INJ field.
	SYSCON_XTAL32K_CTRL_XTAL32K_INJ_Pos = 0x6
	// Bit mask of XTAL32K_INJ field.
	SYSCON_XTAL32K_CTRL_XTAL32K_INJ_Msk = 0xc0
	// on-chip oscillator
	SYSCON_XTAL32K_CTRL_XTAL32K_INJ_ONCHIP_OSC = 0x0
	// external digital clock
	SYSCON_XTAL32K_CTRL_XTAL32K_INJ_EXT_DIG_CLK = 0x1
	// Position of XTAL32K_LOAD_CAP field.
	SYSCON_XTAL32K_CTRL_XTAL32K_LOAD_CAP_Pos = 0x8
	// Bit mask of XTAL32K_LOAD_CAP field.
	SYSCON_XTAL32K_CTRL_XTAL32K_LOAD_CAP_Msk = 0x3f00
	// Position of XTAL32K_EXTRA_CAP field.
	SYSCON_XTAL32K_CTRL_XTAL32K_EXTRA_CAP_Pos = 0xe
	// Bit mask of XTAL32K_EXTRA_CAP field.
	SYSCON_XTAL32K_CTRL_XTAL32K_EXTRA_CAP_Msk = 0x4000
	// Bit XTAL32K_EXTRA_CAP.
	SYSCON_XTAL32K_CTRL_XTAL32K_EXTRA_CAP = 0x4000

	// USB_CFG: USB configuration register
	// Position of DPPUEN_B_PHY_POL field.
	SYSCON_USB_CFG_DPPUEN_B_PHY_POL_Pos = 0x0
	// Bit mask of DPPUEN_B_PHY_POL field.
	SYSCON_USB_CFG_DPPUEN_B_PHY_POL_Msk = 0x1
	// Bit DPPUEN_B_PHY_POL.
	SYSCON_USB_CFG_DPPUEN_B_PHY_POL = 0x1
	// Position of DPPUEN_B_PHY_SEL field.
	SYSCON_USB_CFG_DPPUEN_B_PHY_SEL_Pos = 0x1
	// Bit mask of DPPUEN_B_PHY_SEL field.
	SYSCON_USB_CFG_DPPUEN_B_PHY_SEL_Msk = 0x2
	// Bit DPPUEN_B_PHY_SEL.
	SYSCON_USB_CFG_DPPUEN_B_PHY_SEL = 0x2
	// connection controlled by register
	SYSCON_USB_CFG_DPPUEN_B_PHY_SEL_BY_REG = 0x0
	// connection controlled by USB controller
	SYSCON_USB_CFG_DPPUEN_B_PHY_SEL_BY_USBCTRL = 0x1
	// Position of USB_VBUS field.
	SYSCON_USB_CFG_USB_VBUS_Pos = 0x3
	// Bit mask of USB_VBUS field.
	SYSCON_USB_CFG_USB_VBUS_Msk = 0x8
	// Bit USB_VBUS.
	SYSCON_USB_CFG_USB_VBUS = 0x8
	// Position of USB_PHYSTDBY field.
	SYSCON_USB_CFG_USB_PHYSTDBY_Pos = 0x4
	// Bit mask of USB_PHYSTDBY field.
	SYSCON_USB_CFG_USB_PHYSTDBY_Msk = 0x10
	// Bit USB_PHYSTDBY.
	SYSCON_USB_CFG_USB_PHYSTDBY = 0x10
	// USB PHY power is on
	SYSCON_USB_CFG_USB_PHYSTDBY_ON = 0x0
	// USB PHY power is off
	SYSCON_USB_CFG_USB_PHYSTDBY_OFF = 0x1
	// Position of USB_PHYSTDBY_WEN field.
	SYSCON_USB_CFG_USB_PHYSTDBY_WEN_Pos = 0x5
	// Bit mask of USB_PHYSTDBY_WEN field.
	SYSCON_USB_CFG_USB_PHYSTDBY_WEN_Msk = 0x20
	// Bit USB_PHYSTDBY_WEN.
	SYSCON_USB_CFG_USB_PHYSTDBY_WEN = 0x20

	// PMU_CTRL2: power management uinit control register 2
	// Position of BG_PDM_DIS field.
	SYSCON_PMU_CTRL2_BG_PDM_DIS_Pos = 0x0
	// Bit mask of BG_PDM_DIS field.
	SYSCON_PMU_CTRL2_BG_PDM_DIS_Msk = 0x1
	// Bit BG_PDM_DIS.
	SYSCON_PMU_CTRL2_BG_PDM_DIS = 0x1
	// Position of V2I_PDM_DIS field.
	SYSCON_PMU_CTRL2_V2I_PDM_DIS_Pos = 0x1
	// Bit mask of V2I_PDM_DIS field.
	SYSCON_PMU_CTRL2_V2I_PDM_DIS_Msk = 0x2
	// Bit V2I_PDM_DIS.
	SYSCON_PMU_CTRL2_V2I_PDM_DIS = 0x2
	// Position of VREG_A_PDM_DIS field.
	SYSCON_PMU_CTRL2_VREG_A_PDM_DIS_Pos = 0x2
	// Bit mask of VREG_A_PDM_DIS field.
	SYSCON_PMU_CTRL2_VREG_A_PDM_DIS_Msk = 0x4
	// Bit VREG_A_PDM_DIS.
	SYSCON_PMU_CTRL2_VREG_A_PDM_DIS = 0x4
	// Position of VREG_D_PDM_DIS field.
	SYSCON_PMU_CTRL2_VREG_D_PDM_DIS_Pos = 0x3
	// Bit mask of VREG_D_PDM_DIS field.
	SYSCON_PMU_CTRL2_VREG_D_PDM_DIS_Msk = 0x8
	// Bit VREG_D_PDM_DIS.
	SYSCON_PMU_CTRL2_VREG_D_PDM_DIS = 0x8
	// Position of XTAL_PDM_DIS field.
	SYSCON_PMU_CTRL2_XTAL_PDM_DIS_Pos = 0x4
	// Bit mask of XTAL_PDM_DIS field.
	SYSCON_PMU_CTRL2_XTAL_PDM_DIS_Msk = 0x10
	// Bit XTAL_PDM_DIS.
	SYSCON_PMU_CTRL2_XTAL_PDM_DIS = 0x10
	// Position of OSC32M_PDM_DIS field.
	SYSCON_PMU_CTRL2_OSC32M_PDM_DIS_Pos = 0x5
	// Bit mask of OSC32M_PDM_DIS field.
	SYSCON_PMU_CTRL2_OSC32M_PDM_DIS_Msk = 0x20
	// Bit OSC32M_PDM_DIS.
	SYSCON_PMU_CTRL2_OSC32M_PDM_DIS = 0x20
	// Position of RFAGC_ON field.
	SYSCON_PMU_CTRL2_RFAGC_ON_Pos = 0x6
	// Bit mask of RFAGC_ON field.
	SYSCON_PMU_CTRL2_RFAGC_ON_Msk = 0x40
	// Bit RFAGC_ON.
	SYSCON_PMU_CTRL2_RFAGC_ON = 0x40
	// Position of RX_EN_SEL field.
	SYSCON_PMU_CTRL2_RX_EN_SEL_Pos = 0x7
	// Bit mask of RX_EN_SEL field.
	SYSCON_PMU_CTRL2_RX_EN_SEL_Msk = 0x80
	// Bit RX_EN_SEL.
	SYSCON_PMU_CTRL2_RX_EN_SEL = 0x80
	// exclude noise phase
	SYSCON_PMU_CTRL2_RX_EN_SEL_EX_NOISE = 0x0
	// include noise phase
	SYSCON_PMU_CTRL2_RX_EN_SEL_IN_NOISE = 0x1
	// Position of BG_DIS field.
	SYSCON_PMU_CTRL2_BG_DIS_Pos = 0x8
	// Bit mask of BG_DIS field.
	SYSCON_PMU_CTRL2_BG_DIS_Msk = 0x100
	// Bit BG_DIS.
	SYSCON_PMU_CTRL2_BG_DIS = 0x100
	// Position of V2I_DIS field.
	SYSCON_PMU_CTRL2_V2I_DIS_Pos = 0x9
	// Bit mask of V2I_DIS field.
	SYSCON_PMU_CTRL2_V2I_DIS_Msk = 0x200
	// Bit V2I_DIS.
	SYSCON_PMU_CTRL2_V2I_DIS = 0x200
	// Position of VREG_A_DIS field.
	SYSCON_PMU_CTRL2_VREG_A_DIS_Pos = 0xa
	// Bit mask of VREG_A_DIS field.
	SYSCON_PMU_CTRL2_VREG_A_DIS_Msk = 0x400
	// Bit VREG_A_DIS.
	SYSCON_PMU_CTRL2_VREG_A_DIS = 0x400
	// Position of VREG_D_DIS field.
	SYSCON_PMU_CTRL2_VREG_D_DIS_Pos = 0xb
	// Bit mask of VREG_D_DIS field.
	SYSCON_PMU_CTRL2_VREG_D_DIS_Msk = 0x800
	// Bit VREG_D_DIS.
	SYSCON_PMU_CTRL2_VREG_D_DIS = 0x800
	// Position of LO_DIS field.
	SYSCON_PMU_CTRL2_LO_DIS_Pos = 0xc
	// Bit mask of LO_DIS field.
	SYSCON_PMU_CTRL2_LO_DIS_Msk = 0x1000
	// Bit LO_DIS.
	SYSCON_PMU_CTRL2_LO_DIS = 0x1000
	// Position of VCO_DIS field.
	SYSCON_PMU_CTRL2_VCO_DIS_Pos = 0xd
	// Bit mask of VCO_DIS field.
	SYSCON_PMU_CTRL2_VCO_DIS_Msk = 0x2000
	// Bit VCO_DIS.
	SYSCON_PMU_CTRL2_VCO_DIS = 0x2000
	// Position of PA_PK_DIS field.
	SYSCON_PMU_CTRL2_PA_PK_DIS_Pos = 0xe
	// Bit mask of PA_PK_DIS field.
	SYSCON_PMU_CTRL2_PA_PK_DIS_Msk = 0x4000
	// Bit PA_PK_DIS.
	SYSCON_PMU_CTRL2_PA_PK_DIS = 0x4000
	// Position of PA_DIS field.
	SYSCON_PMU_CTRL2_PA_DIS_Pos = 0xf
	// Bit mask of PA_DIS field.
	SYSCON_PMU_CTRL2_PA_DIS_Msk = 0x8000
	// Bit PA_DIS.
	SYSCON_PMU_CTRL2_PA_DIS = 0x8000
	// Position of LNA_DIS field.
	SYSCON_PMU_CTRL2_LNA_DIS_Pos = 0x10
	// Bit mask of LNA_DIS field.
	SYSCON_PMU_CTRL2_LNA_DIS_Msk = 0x10000
	// Bit LNA_DIS.
	SYSCON_PMU_CTRL2_LNA_DIS = 0x10000
	// Position of MIXER_DIS field.
	SYSCON_PMU_CTRL2_MIXER_DIS_Pos = 0x11
	// Bit mask of MIXER_DIS field.
	SYSCON_PMU_CTRL2_MIXER_DIS_Msk = 0x20000
	// Bit MIXER_DIS.
	SYSCON_PMU_CTRL2_MIXER_DIS = 0x20000
	// Position of PKDET_DIS field.
	SYSCON_PMU_CTRL2_PKDET_DIS_Pos = 0x12
	// Bit mask of PKDET_DIS field.
	SYSCON_PMU_CTRL2_PKDET_DIS_Msk = 0x40000
	// Bit PKDET_DIS.
	SYSCON_PMU_CTRL2_PKDET_DIS = 0x40000
	// Position of PPF_DIS field.
	SYSCON_PMU_CTRL2_PPF_DIS_Pos = 0x13
	// Bit mask of PPF_DIS field.
	SYSCON_PMU_CTRL2_PPF_DIS_Msk = 0x80000
	// Bit PPF_DIS.
	SYSCON_PMU_CTRL2_PPF_DIS = 0x80000
	// Position of SAR_DIS field.
	SYSCON_PMU_CTRL2_SAR_DIS_Pos = 0x14
	// Bit mask of SAR_DIS field.
	SYSCON_PMU_CTRL2_SAR_DIS_Msk = 0x100000
	// Bit SAR_DIS.
	SYSCON_PMU_CTRL2_SAR_DIS = 0x100000
	// Position of RC_CAL_DIS field.
	SYSCON_PMU_CTRL2_RC_CAL_DIS_Pos = 0x15
	// Bit mask of RC_CAL_DIS field.
	SYSCON_PMU_CTRL2_RC_CAL_DIS_Msk = 0x200000
	// Bit RC_CAL_DIS.
	SYSCON_PMU_CTRL2_RC_CAL_DIS = 0x200000
	// Position of FLSH_DIS field.
	SYSCON_PMU_CTRL2_FLSH_DIS_Pos = 0x1d
	// Bit mask of FLSH_DIS field.
	SYSCON_PMU_CTRL2_FLSH_DIS_Msk = 0x20000000
	// Bit FLSH_DIS.
	SYSCON_PMU_CTRL2_FLSH_DIS = 0x20000000
	// Position of FLSH_PDM_DIS field.
	SYSCON_PMU_CTRL2_FLSH_PDM_DIS_Pos = 0x1e
	// Bit mask of FLSH_PDM_DIS field.
	SYSCON_PMU_CTRL2_FLSH_PDM_DIS_Msk = 0x40000000
	// Bit FLSH_PDM_DIS.
	SYSCON_PMU_CTRL2_FLSH_PDM_DIS = 0x40000000
	// Position of SEL_PD field.
	SYSCON_PMU_CTRL2_SEL_PD_Pos = 0x1f
	// Bit mask of SEL_PD field.
	SYSCON_PMU_CTRL2_SEL_PD_Msk = 0x80000000
	// Bit SEL_PD.
	SYSCON_PMU_CTRL2_SEL_PD = 0x80000000
	// hardware control power
	SYSCON_PMU_CTRL2_SEL_PD_HW_PWR = 0x0
	// software control power
	SYSCON_PMU_CTRL2_SEL_PD_SW_PWR = 0x1

	// ANA_CTRL1: IVREF and DVREG setting register
	// Position of VDD_PMU_SET_PDM field.
	SYSCON_ANA_CTRL1_VDD_PMU_SET_PDM_Pos = 0x0
	// Bit mask of VDD_PMU_SET_PDM field.
	SYSCON_ANA_CTRL1_VDD_PMU_SET_PDM_Msk = 0x3
	// Position of VDD_PMU_SET field.
	SYSCON_ANA_CTRL1_VDD_PMU_SET_Pos = 0x2
	// Bit mask of VDD_PMU_SET field.
	SYSCON_ANA_CTRL1_VDD_PMU_SET_Msk = 0xc
	// Position of VDD_MEM_SET_PDM field.
	SYSCON_ANA_CTRL1_VDD_MEM_SET_PDM_Pos = 0x4
	// Bit mask of VDD_MEM_SET_PDM field.
	SYSCON_ANA_CTRL1_VDD_MEM_SET_PDM_Msk = 0x30
	// Position of VDD_MEM_SET field.
	SYSCON_ANA_CTRL1_VDD_MEM_SET_Pos = 0x6
	// Bit mask of VDD_MEM_SET field.
	SYSCON_ANA_CTRL1_VDD_MEM_SET_Msk = 0xc0
	// Position of VDD_PMU_SET_EXTRA field.
	SYSCON_ANA_CTRL1_VDD_PMU_SET_EXTRA_Pos = 0x8
	// Bit mask of VDD_PMU_SET_EXTRA field.
	SYSCON_ANA_CTRL1_VDD_PMU_SET_EXTRA_Msk = 0x100
	// Bit VDD_PMU_SET_EXTRA.
	SYSCON_ANA_CTRL1_VDD_PMU_SET_EXTRA = 0x100
	// Position of VDD_MEM_SET_EXTRA field.
	SYSCON_ANA_CTRL1_VDD_MEM_SET_EXTRA_Pos = 0x9
	// Bit mask of VDD_MEM_SET_EXTRA field.
	SYSCON_ANA_CTRL1_VDD_MEM_SET_EXTRA_Msk = 0x200
	// Bit VDD_MEM_SET_EXTRA.
	SYSCON_ANA_CTRL1_VDD_MEM_SET_EXTRA = 0x200
	// Position of VDD_PMU_SET_ULTRA_LOW field.
	SYSCON_ANA_CTRL1_VDD_PMU_SET_ULTRA_LOW_Pos = 0xa
	// Bit mask of VDD_PMU_SET_ULTRA_LOW field.
	SYSCON_ANA_CTRL1_VDD_PMU_SET_ULTRA_LOW_Msk = 0x400
	// Bit VDD_PMU_SET_ULTRA_LOW.
	SYSCON_ANA_CTRL1_VDD_PMU_SET_ULTRA_LOW = 0x400
	// Position of VDD_PMU_MEM_SW field.
	SYSCON_ANA_CTRL1_VDD_PMU_MEM_SW_Pos = 0xb
	// Bit mask of VDD_PMU_MEM_SW field.
	SYSCON_ANA_CTRL1_VDD_PMU_MEM_SW_Msk = 0x800
	// Bit VDD_PMU_MEM_SW.
	SYSCON_ANA_CTRL1_VDD_PMU_MEM_SW = 0x800
	// Position of IV_BG_SEL field.
	SYSCON_ANA_CTRL1_IV_BG_SEL_Pos = 0xc
	// Bit mask of IV_BG_SEL field.
	SYSCON_ANA_CTRL1_IV_BG_SEL_Msk = 0xf000
	// Position of PDM_DIS_BUCK field.
	SYSCON_ANA_CTRL1_PDM_DIS_BUCK_Pos = 0x10
	// Bit mask of PDM_DIS_BUCK field.
	SYSCON_ANA_CTRL1_PDM_DIS_BUCK_Msk = 0x10000
	// Bit PDM_DIS_BUCK.
	SYSCON_ANA_CTRL1_PDM_DIS_BUCK = 0x10000
	// Position of BUCK_PD_CCM field.
	SYSCON_ANA_CTRL1_BUCK_PD_CCM_Pos = 0x11
	// Bit mask of BUCK_PD_CCM field.
	SYSCON_ANA_CTRL1_BUCK_PD_CCM_Msk = 0x20000
	// Bit BUCK_PD_CCM.
	SYSCON_ANA_CTRL1_BUCK_PD_CCM = 0x20000
	// Position of BUCK_PD_DCM field.
	SYSCON_ANA_CTRL1_BUCK_PD_DCM_Pos = 0x12
	// Bit mask of BUCK_PD_DCM field.
	SYSCON_ANA_CTRL1_BUCK_PD_DCM_Msk = 0x40000
	// Bit BUCK_PD_DCM.
	SYSCON_ANA_CTRL1_BUCK_PD_DCM = 0x40000
	// Position of IV_IREF_SEL field.
	SYSCON_ANA_CTRL1_IV_IREF_SEL_Pos = 0x13
	// Bit mask of IV_IREF_SEL field.
	SYSCON_ANA_CTRL1_IV_IREF_SEL_Msk = 0x180000
	// Position of IV_VREG11_SET field.
	SYSCON_ANA_CTRL1_IV_VREG11_SET_Pos = 0x15
	// Bit mask of IV_VREG11_SET field.
	SYSCON_ANA_CTRL1_IV_VREG11_SET_Msk = 0xe00000
	// Position of XTAL32K_FORCE_RDY field.
	SYSCON_ANA_CTRL1_XTAL32K_FORCE_RDY_Pos = 0x18
	// Bit mask of XTAL32K_FORCE_RDY field.
	SYSCON_ANA_CTRL1_XTAL32K_FORCE_RDY_Msk = 0x1000000
	// Bit XTAL32K_FORCE_RDY.
	SYSCON_ANA_CTRL1_XTAL32K_FORCE_RDY = 0x1000000
	// Position of X32_SMT_EN field.
	SYSCON_ANA_CTRL1_X32_SMT_EN_Pos = 0x19
	// Bit mask of X32_SMT_EN field.
	SYSCON_ANA_CTRL1_X32_SMT_EN_Msk = 0x2000000
	// Bit X32_SMT_EN.
	SYSCON_ANA_CTRL1_X32_SMT_EN = 0x2000000
	// Position of BM_X32BUF field.
	SYSCON_ANA_CTRL1_BM_X32BUF_Pos = 0x1a
	// Bit mask of BM_X32BUF field.
	SYSCON_ANA_CTRL1_BM_X32BUF_Msk = 0xc000000
	// Position of DVREG11_SET_DIG field.
	SYSCON_ANA_CTRL1_DVREG11_SET_DIG_Pos = 0x1c
	// Bit mask of DVREG11_SET_DIG field.
	SYSCON_ANA_CTRL1_DVREG11_SET_DIG_Msk = 0x70000000
	// Position of BUCK_DPD field.
	SYSCON_ANA_CTRL1_BUCK_DPD_Pos = 0x1f
	// Bit mask of BUCK_DPD field.
	SYSCON_ANA_CTRL1_BUCK_DPD_Msk = 0x80000000
	// Bit BUCK_DPD.
	SYSCON_ANA_CTRL1_BUCK_DPD = 0x80000000

	// MISC: MISC register
	// Position of RCO_PWR_MODE field.
	SYSCON_MISC_RCO_PWR_MODE_Pos = 0x0
	// Bit mask of RCO_PWR_MODE field.
	SYSCON_MISC_RCO_PWR_MODE_Msk = 0x3
	// The highest RCO VDD setting, RCO current 630nA
	SYSCON_MISC_RCO_PWR_MODE_RCO_PWR_HIGH = 0x0
	// The middle RCO VDD setting, RCO current 350nA
	SYSCON_MISC_RCO_PWR_MODE_RCO_PWR_MIDDLE = 0x2
	// The lowest RCO VDD setting, RCO current 200nA
	SYSCON_MISC_RCO_PWR_MODE_RCO_PWR_LOW = 0x3
	// Position of EN_SWD field.
	SYSCON_MISC_EN_SWD_Pos = 0x10
	// Bit mask of EN_SWD field.
	SYSCON_MISC_EN_SWD_Msk = 0x10000
	// Bit EN_SWD.
	SYSCON_MISC_EN_SWD = 0x10000
	// disable SWD
	SYSCON_MISC_EN_SWD_DISABLE = 0x0
	// enable SWD
	SYSCON_MISC_EN_SWD_ENABLE = 0x1
	// Position of DIS_FLSH_POWER field.
	SYSCON_MISC_DIS_FLSH_POWER_Pos = 0x11
	// Bit mask of DIS_FLSH_POWER field.
	SYSCON_MISC_DIS_FLSH_POWER_Msk = 0x20000
	// Bit DIS_FLSH_POWER.
	SYSCON_MISC_DIS_FLSH_POWER = 0x20000
	// flash power is depend on the value DIS_FLSH of PMU_CTRL2
	SYSCON_MISC_DIS_FLSH_POWER_ENABLE = 0x0
	// flash power is off
	SYSCON_MISC_DIS_FLSH_POWER_DISABLE = 0x1
	// Position of DIS_USB_PULLUP field.
	SYSCON_MISC_DIS_USB_PULLUP_Pos = 0x12
	// Bit mask of DIS_USB_PULLUP field.
	SYSCON_MISC_DIS_USB_PULLUP_Msk = 0x40000
	// Bit DIS_USB_PULLUP.
	SYSCON_MISC_DIS_USB_PULLUP = 0x40000
	// USB pull up resistor state depend on other 3 USB control register
	SYSCON_MISC_DIS_USB_PULLUP_CONNECT = 0x0
	// USB pull up resister is disconnected
	SYSCON_MISC_DIS_USB_PULLUP_DISCONNECT = 0x1
	// Position of DPPU_OPT_SEL field.
	SYSCON_MISC_DPPU_OPT_SEL_Pos = 0x18
	// Bit mask of DPPU_OPT_SEL field.
	SYSCON_MISC_DPPU_OPT_SEL_Msk = 0x1000000
	// Bit DPPU_OPT_SEL.
	SYSCON_MISC_DPPU_OPT_SEL = 0x1000000
	// 1.2kohm
	SYSCON_MISC_DPPU_OPT_SEL_RES1P2K = 0x0
	// 2.3kohm
	SYSCON_MISC_DPPU_OPT_SEL_RES2P3K = 0x1
	// Position of DPPU_OPT_POL field.
	SYSCON_MISC_DPPU_OPT_POL_Pos = 0x19
	// Bit mask of DPPU_OPT_POL field.
	SYSCON_MISC_DPPU_OPT_POL_Msk = 0x2000000
	// Bit DPPU_OPT_POL.
	SYSCON_MISC_DPPU_OPT_POL = 0x2000000
)

// Constants for WDT: wdog
const (
	// LOAD: watch dog counter start value register
	// Position of LOAD field.
	WDT_LOAD_LOAD_Pos = 0x0
	// Bit mask of LOAD field.
	WDT_LOAD_LOAD_Msk = 0xffffffff

	// VALUE: watch dog counter value register
	// Position of VALUE field.
	WDT_VALUE_VALUE_Pos = 0x0
	// Bit mask of VALUE field.
	WDT_VALUE_VALUE_Msk = 0xffffffff

	// CTRL: watch dog control register
	// Position of INTEN field.
	WDT_CTRL_INTEN_Pos = 0x0
	// Bit mask of INTEN field.
	WDT_CTRL_INTEN_Msk = 0x1
	// Bit INTEN.
	WDT_CTRL_INTEN = 0x1
	// Position of RESEN field.
	WDT_CTRL_RESEN_Pos = 0x1
	// Bit mask of RESEN field.
	WDT_CTRL_RESEN_Msk = 0x2
	// Bit RESEN.
	WDT_CTRL_RESEN = 0x2

	// INT_CLR: interrupt clear register
	// Position of INTCLR field.
	WDT_INT_CLR_INTCLR_Pos = 0x0
	// Bit mask of INTCLR field.
	WDT_INT_CLR_INTCLR_Msk = 0x1
	// Bit INTCLR.
	WDT_INT_CLR_INTCLR = 0x1

	// INT_RAW: raw interrupt status register
	// Position of RAWINTSTAT field.
	WDT_INT_RAW_RAWINTSTAT_Pos = 0x0
	// Bit mask of RAWINTSTAT field.
	WDT_INT_RAW_RAWINTSTAT_Msk = 0x1
	// Bit RAWINTSTAT.
	WDT_INT_RAW_RAWINTSTAT = 0x1

	// MIS: interrupt mask register
	// Position of MASKINTSTAT field.
	WDT_MIS_MASKINTSTAT_Pos = 0x0
	// Bit mask of MASKINTSTAT field.
	WDT_MIS_MASKINTSTAT_Msk = 0x1
	// Bit MASKINTSTAT.
	WDT_MIS_MASKINTSTAT = 0x1

	// LOCK: watch dog lock register
	// Position of LOCK_31_0 field.
	WDT_LOCK_LOCK_31_0_Pos = 0x0
	// Bit mask of LOCK_31_0 field.
	WDT_LOCK_LOCK_31_0_Msk = 0xffffffff
)

// Constants for CTIMER0: timer
const (
	// IR: Interrupt Register. The IR can be written to clear interrupts. The IR can be read to identify which of eight possible interrupt sources are pending.
	// Position of MR0INT field.
	CTIMER_IR_MR0INT_Pos = 0x0
	// Bit mask of MR0INT field.
	CTIMER_IR_MR0INT_Msk = 0x1
	// Bit MR0INT.
	CTIMER_IR_MR0INT = 0x1
	// Position of MR1INT field.
	CTIMER_IR_MR1INT_Pos = 0x1
	// Bit mask of MR1INT field.
	CTIMER_IR_MR1INT_Msk = 0x2
	// Bit MR1INT.
	CTIMER_IR_MR1INT = 0x2
	// Position of MR2INT field.
	CTIMER_IR_MR2INT_Pos = 0x2
	// Bit mask of MR2INT field.
	CTIMER_IR_MR2INT_Msk = 0x4
	// Bit MR2INT.
	CTIMER_IR_MR2INT = 0x4
	// Position of MR3INT field.
	CTIMER_IR_MR3INT_Pos = 0x3
	// Bit mask of MR3INT field.
	CTIMER_IR_MR3INT_Msk = 0x8
	// Bit MR3INT.
	CTIMER_IR_MR3INT = 0x8
	// Position of CR0INT field.
	CTIMER_IR_CR0INT_Pos = 0x4
	// Bit mask of CR0INT field.
	CTIMER_IR_CR0INT_Msk = 0x10
	// Bit CR0INT.
	CTIMER_IR_CR0INT = 0x10
	// Position of CR1INT field.
	CTIMER_IR_CR1INT_Pos = 0x5
	// Bit mask of CR1INT field.
	CTIMER_IR_CR1INT_Msk = 0x20
	// Bit CR1INT.
	CTIMER_IR_CR1INT = 0x20
	// Position of CR2INT field.
	CTIMER_IR_CR2INT_Pos = 0x6
	// Bit mask of CR2INT field.
	CTIMER_IR_CR2INT_Msk = 0x40
	// Bit CR2INT.
	CTIMER_IR_CR2INT = 0x40

	// TCR: Timer Control Register. The TCR is used to control the Timer Counter functions. The Timer Counter can be disabled or reset through the TCR.
	// Position of CEN field.
	CTIMER_TCR_CEN_Pos = 0x0
	// Bit mask of CEN field.
	CTIMER_TCR_CEN_Msk = 0x1
	// Bit CEN.
	CTIMER_TCR_CEN = 0x1
	// Disabled.The counters are disabled.
	CTIMER_TCR_CEN_DISABLED = 0x0
	// Enabled. The Timer Counter and Prescale Counter are enabled.
	CTIMER_TCR_CEN_ENABLED = 0x1
	// Position of CRST field.
	CTIMER_TCR_CRST_Pos = 0x1
	// Bit mask of CRST field.
	CTIMER_TCR_CRST_Msk = 0x2
	// Bit CRST.
	CTIMER_TCR_CRST = 0x2
	// Disabled. Do nothing.
	CTIMER_TCR_CRST_DISABLED = 0x0
	// Enabled. The Timer Counter and the Prescale Counter are synchronously reset on the next positive edge of the APB bus clock. The counters remain reset until TCR[1] is returned to zero.
	CTIMER_TCR_CRST_ENABLED = 0x1

	// TC: Timer Counter. The 32 bit TC is incremented every PR+1 cycles of the APB bus clock. The TC is controlled through the TCR.
	// Position of TCVAL field.
	CTIMER_TC_TCVAL_Pos = 0x0
	// Bit mask of TCVAL field.
	CTIMER_TC_TCVAL_Msk = 0xffffffff

	// PR: Prescale Register. When the Prescale Counter (PC) is equal to this value, the next clock increments the TC and clears the PC.
	// Position of PRVAL field.
	CTIMER_PR_PRVAL_Pos = 0x0
	// Bit mask of PRVAL field.
	CTIMER_PR_PRVAL_Msk = 0xffffffff

	// PC: Prescale Counter. The 32 bit PC is a counter which is incremented to the value stored in PR. When the value in PR is reached, the TC is incremented and the PC is cleared. The PC is observable and controllable through the bus interface.
	// Position of PCVAL field.
	CTIMER_PC_PCVAL_Pos = 0x0
	// Bit mask of PCVAL field.
	CTIMER_PC_PCVAL_Msk = 0xffffffff

	// MCR: Match Control Register. The MCR is used to control if an interrupt is generated and if the TC is reset when a Match occurs.
	// Position of MR0I field.
	CTIMER_MCR_MR0I_Pos = 0x0
	// Bit mask of MR0I field.
	CTIMER_MCR_MR0I_Msk = 0x1
	// Bit MR0I.
	CTIMER_MCR_MR0I = 0x1
	// Position of MR0R field.
	CTIMER_MCR_MR0R_Pos = 0x1
	// Bit mask of MR0R field.
	CTIMER_MCR_MR0R_Msk = 0x2
	// Bit MR0R.
	CTIMER_MCR_MR0R = 0x2
	// Position of MR0S field.
	CTIMER_MCR_MR0S_Pos = 0x2
	// Bit mask of MR0S field.
	CTIMER_MCR_MR0S_Msk = 0x4
	// Bit MR0S.
	CTIMER_MCR_MR0S = 0x4
	// Position of MR1I field.
	CTIMER_MCR_MR1I_Pos = 0x3
	// Bit mask of MR1I field.
	CTIMER_MCR_MR1I_Msk = 0x8
	// Bit MR1I.
	CTIMER_MCR_MR1I = 0x8
	// Position of MR1R field.
	CTIMER_MCR_MR1R_Pos = 0x4
	// Bit mask of MR1R field.
	CTIMER_MCR_MR1R_Msk = 0x10
	// Bit MR1R.
	CTIMER_MCR_MR1R = 0x10
	// Position of MR1S field.
	CTIMER_MCR_MR1S_Pos = 0x5
	// Bit mask of MR1S field.
	CTIMER_MCR_MR1S_Msk = 0x20
	// Bit MR1S.
	CTIMER_MCR_MR1S = 0x20
	// Position of MR2I field.
	CTIMER_MCR_MR2I_Pos = 0x6
	// Bit mask of MR2I field.
	CTIMER_MCR_MR2I_Msk = 0x40
	// Bit MR2I.
	CTIMER_MCR_MR2I = 0x40
	// Position of MR2R field.
	CTIMER_MCR_MR2R_Pos = 0x7
	// Bit mask of MR2R field.
	CTIMER_MCR_MR2R_Msk = 0x80
	// Bit MR2R.
	CTIMER_MCR_MR2R = 0x80
	// Position of MR2S field.
	CTIMER_MCR_MR2S_Pos = 0x8
	// Bit mask of MR2S field.
	CTIMER_MCR_MR2S_Msk = 0x100
	// Bit MR2S.
	CTIMER_MCR_MR2S = 0x100
	// Position of MR3I field.
	CTIMER_MCR_MR3I_Pos = 0x9
	// Bit mask of MR3I field.
	CTIMER_MCR_MR3I_Msk = 0x200
	// Bit MR3I.
	CTIMER_MCR_MR3I = 0x200
	// Position of MR3R field.
	CTIMER_MCR_MR3R_Pos = 0xa
	// Bit mask of MR3R field.
	CTIMER_MCR_MR3R_Msk = 0x400
	// Bit MR3R.
	CTIMER_MCR_MR3R = 0x400
	// Position of MR3S field.
	CTIMER_MCR_MR3S_Pos = 0xb
	// Bit mask of MR3S field.
	CTIMER_MCR_MR3S_Msk = 0x800
	// Bit MR3S.
	CTIMER_MCR_MR3S = 0x800

	// MR: Match Register . MR can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR matches the TC.
	// Position of MATCH field.
	CTIMER_MR_MATCH_Pos = 0x0
	// Bit mask of MATCH field.
	CTIMER_MR_MATCH_Msk = 0xffffffff

	// CCR: Capture Control Register. The CCR controls which edges of the capture inputs are used to load the Capture Registers and whether or not an interrupt is generated when a capture takes place.
	// Position of CAP0RE field.
	CTIMER_CCR_CAP0RE_Pos = 0x0
	// Bit mask of CAP0RE field.
	CTIMER_CCR_CAP0RE_Msk = 0x1
	// Bit CAP0RE.
	CTIMER_CCR_CAP0RE = 0x1
	// Position of CAP0FE field.
	CTIMER_CCR_CAP0FE_Pos = 0x1
	// Bit mask of CAP0FE field.
	CTIMER_CCR_CAP0FE_Msk = 0x2
	// Bit CAP0FE.
	CTIMER_CCR_CAP0FE = 0x2
	// Position of CAP0I field.
	CTIMER_CCR_CAP0I_Pos = 0x2
	// Bit mask of CAP0I field.
	CTIMER_CCR_CAP0I_Msk = 0x4
	// Bit CAP0I.
	CTIMER_CCR_CAP0I = 0x4
	// Position of CAP1RE field.
	CTIMER_CCR_CAP1RE_Pos = 0x3
	// Bit mask of CAP1RE field.
	CTIMER_CCR_CAP1RE_Msk = 0x8
	// Bit CAP1RE.
	CTIMER_CCR_CAP1RE = 0x8
	// Position of CAP1FE field.
	CTIMER_CCR_CAP1FE_Pos = 0x4
	// Bit mask of CAP1FE field.
	CTIMER_CCR_CAP1FE_Msk = 0x10
	// Bit CAP1FE.
	CTIMER_CCR_CAP1FE = 0x10
	// Position of CAP1I field.
	CTIMER_CCR_CAP1I_Pos = 0x5
	// Bit mask of CAP1I field.
	CTIMER_CCR_CAP1I_Msk = 0x20
	// Bit CAP1I.
	CTIMER_CCR_CAP1I = 0x20
	// Position of CAP2RE field.
	CTIMER_CCR_CAP2RE_Pos = 0x6
	// Bit mask of CAP2RE field.
	CTIMER_CCR_CAP2RE_Msk = 0x40
	// Bit CAP2RE.
	CTIMER_CCR_CAP2RE = 0x40
	// Position of CAP2FE field.
	CTIMER_CCR_CAP2FE_Pos = 0x7
	// Bit mask of CAP2FE field.
	CTIMER_CCR_CAP2FE_Msk = 0x80
	// Bit CAP2FE.
	CTIMER_CCR_CAP2FE = 0x80
	// Position of CAP2I field.
	CTIMER_CCR_CAP2I_Pos = 0x8
	// Bit mask of CAP2I field.
	CTIMER_CCR_CAP2I_Msk = 0x100
	// Bit CAP2I.
	CTIMER_CCR_CAP2I = 0x100

	// CR: Capture Register . CR is loaded with the value of TC when there is an event on the CAPn. input.
	// Position of CAP field.
	CTIMER_CR_CAP_Pos = 0x0
	// Bit mask of CAP field.
	CTIMER_CR_CAP_Msk = 0xffffffff

	// EMR: External Match Register. The EMR controls the match function and the external match pins.
	// Position of EM0 field.
	CTIMER_EMR_EM0_Pos = 0x0
	// Bit mask of EM0 field.
	CTIMER_EMR_EM0_Msk = 0x1
	// Bit EM0.
	CTIMER_EMR_EM0 = 0x1
	// Position of EM1 field.
	CTIMER_EMR_EM1_Pos = 0x1
	// Bit mask of EM1 field.
	CTIMER_EMR_EM1_Msk = 0x2
	// Bit EM1.
	CTIMER_EMR_EM1 = 0x2
	// Position of EM2 field.
	CTIMER_EMR_EM2_Pos = 0x2
	// Bit mask of EM2 field.
	CTIMER_EMR_EM2_Msk = 0x4
	// Bit EM2.
	CTIMER_EMR_EM2 = 0x4
	// Position of EM3 field.
	CTIMER_EMR_EM3_Pos = 0x3
	// Bit mask of EM3 field.
	CTIMER_EMR_EM3_Msk = 0x8
	// Bit EM3.
	CTIMER_EMR_EM3 = 0x8
	// Position of EMC0 field.
	CTIMER_EMR_EMC0_Pos = 0x4
	// Bit mask of EMC0 field.
	CTIMER_EMR_EMC0_Msk = 0x30
	// Do Nothing.
	CTIMER_EMR_EMC0_DO_NOTHING = 0x0
	// Clear. Clear the corresponding External Match bit/output to 0 (MAT0 pin is LOW if pinned out).
	CTIMER_EMR_EMC0_CLEAR = 0x1
	// Set. Set the corresponding External Match bit/output to 1 (MAT0 pin is HIGH if pinned out).
	CTIMER_EMR_EMC0_SET = 0x2
	// Toggle. Toggle the corresponding External Match bit/output.
	CTIMER_EMR_EMC0_TOGGLE = 0x3
	// Position of EMC1 field.
	CTIMER_EMR_EMC1_Pos = 0x6
	// Bit mask of EMC1 field.
	CTIMER_EMR_EMC1_Msk = 0xc0
	// Do Nothing.
	CTIMER_EMR_EMC1_DO_NOTHING = 0x0
	// Clear. Clear the corresponding External Match bit/output to 0 (MAT1 pin is LOW if pinned out).
	CTIMER_EMR_EMC1_CLEAR = 0x1
	// Set. Set the corresponding External Match bit/output to 1 (MAT1 pin is HIGH if pinned out).
	CTIMER_EMR_EMC1_SET = 0x2
	// Toggle. Toggle the corresponding External Match bit/output.
	CTIMER_EMR_EMC1_TOGGLE = 0x3
	// Position of EMC2 field.
	CTIMER_EMR_EMC2_Pos = 0x8
	// Bit mask of EMC2 field.
	CTIMER_EMR_EMC2_Msk = 0x300
	// Do Nothing.
	CTIMER_EMR_EMC2_DO_NOTHING = 0x0
	// Clear. Clear the corresponding External Match bit/output to 0 (MAT2 pin is LOW if pinned out).
	CTIMER_EMR_EMC2_CLEAR = 0x1
	// Set. Set the corresponding External Match bit/output to 1 (MAT2 pin is HIGH if pinned out).
	CTIMER_EMR_EMC2_SET = 0x2
	// Toggle. Toggle the corresponding External Match bit/output.
	CTIMER_EMR_EMC2_TOGGLE = 0x3
	// Position of EMC3 field.
	CTIMER_EMR_EMC3_Pos = 0xa
	// Bit mask of EMC3 field.
	CTIMER_EMR_EMC3_Msk = 0xc00
	// Do Nothing.
	CTIMER_EMR_EMC3_DO_NOTHING = 0x0
	// Clear. Clear the corresponding External Match bit/output to 0 (MAT3 pin is LOW if pinned out).
	CTIMER_EMR_EMC3_CLEAR = 0x1
	// Set. Set the corresponding External Match bit/output to 1 (MAT3 pin is HIGH if pinned out).
	CTIMER_EMR_EMC3_SET = 0x2
	// Toggle. Toggle the corresponding External Match bit/output.
	CTIMER_EMR_EMC3_TOGGLE = 0x3

	// CTCR: Count Control Register. The CTCR selects between Timer and Counter mode, and in Counter mode selects the signal and edge(s) for counting.
	// Position of CTMODE field.
	CTIMER_CTCR_CTMODE_Pos = 0x0
	// Bit mask of CTMODE field.
	CTIMER_CTCR_CTMODE_Msk = 0x3
	// Timer Mode. Incremented every rising APB bus clock edge.
	CTIMER_CTCR_CTMODE_TIMER = 0x0
	// Counter Mode rising edge. TC is incremented on rising edges on the CAP input selected by bits 3:2.
	CTIMER_CTCR_CTMODE_COUNTER_RISING_EDGE = 0x1
	// Counter Mode falling edge. TC is incremented on falling edges on the CAP input selected by bits 3:2.
	CTIMER_CTCR_CTMODE_COUNTER_FALLING_EDGE = 0x2
	// Counter Mode dual edge. TC is incremented on both edges on the CAP input selected by bits 3:2.
	CTIMER_CTCR_CTMODE_COUNTER_DUAL_EDGE = 0x3
	// Position of CINSEL field.
	CTIMER_CTCR_CINSEL_Pos = 0x2
	// Bit mask of CINSEL field.
	CTIMER_CTCR_CINSEL_Msk = 0xc
	// Channel 0. CAPn.0 for CT32Bn
	CTIMER_CTCR_CINSEL_CHANNEL_0 = 0x0
	// Channel 1. CAPn.1 for CT32Bn
	CTIMER_CTCR_CINSEL_CHANNEL_1 = 0x1
	// Channel 2. CAPn.2 for CT32Bn
	CTIMER_CTCR_CINSEL_CHANNEL_2 = 0x2
	// Position of ENCC field.
	CTIMER_CTCR_ENCC_Pos = 0x4
	// Bit mask of ENCC field.
	CTIMER_CTCR_ENCC_Msk = 0x10
	// Bit ENCC.
	CTIMER_CTCR_ENCC = 0x10
	// Position of SELCC field.
	CTIMER_CTCR_SELCC_Pos = 0x5
	// Bit mask of SELCC field.
	CTIMER_CTCR_SELCC_Msk = 0xe0
	// Channel 0 Rising Edge. Rising edge of the signal on capture channel 0 clears the timer (if bit 4 is set).
	CTIMER_CTCR_SELCC_CHANNEL_0_RISING = 0x0
	// Channel 0 Falling Edge. Falling edge of the signal on capture channel 0 clears the timer (if bit 4 is set).
	CTIMER_CTCR_SELCC_CHANNEL_0_FALLING = 0x1
	// Channel 1 Rising Edge. Rising edge of the signal on capture channel 1 clears the timer (if bit 4 is set).
	CTIMER_CTCR_SELCC_CHANNEL_1_RISING = 0x2
	// Channel 1 Falling Edge. Falling edge of the signal on capture channel 1 clears the timer (if bit 4 is set).
	CTIMER_CTCR_SELCC_CHANNEL_1_FALLING = 0x3
	// Channel 2 Rising Edge. Rising edge of the signal on capture channel 2 clears the timer (if bit 4 is set).
	CTIMER_CTCR_SELCC_CHANNEL_2_RISING = 0x4
	// Channel 2 Falling Edge. Falling edge of the signal on capture channel 2 clears the timer (if bit 4 is set).
	CTIMER_CTCR_SELCC_CHANNEL_2_FALLING = 0x5

	// PWMC: PWM Control Register. The PWMCON enables PWM mode for the external match pins.
	// Position of PWMEN0 field.
	CTIMER_PWMC_PWMEN0_Pos = 0x0
	// Bit mask of PWMEN0 field.
	CTIMER_PWMC_PWMEN0_Msk = 0x1
	// Bit PWMEN0.
	CTIMER_PWMC_PWMEN0 = 0x1
	// Match. CT32Bn_MAT0 is controlled by EM0.
	CTIMER_PWMC_PWMEN0_MATCH = 0x0
	// PWM. PWM mode is enabled for CT32Bn_MAT0.
	CTIMER_PWMC_PWMEN0_PWM = 0x1
	// Position of PWMEN1 field.
	CTIMER_PWMC_PWMEN1_Pos = 0x1
	// Bit mask of PWMEN1 field.
	CTIMER_PWMC_PWMEN1_Msk = 0x2
	// Bit PWMEN1.
	CTIMER_PWMC_PWMEN1 = 0x2
	// Match. CT32Bn_MAT01 is controlled by EM1.
	CTIMER_PWMC_PWMEN1_MATCH = 0x0
	// PWM. PWM mode is enabled for CT32Bn_MAT1.
	CTIMER_PWMC_PWMEN1_PWM = 0x1
	// Position of PWMEN2 field.
	CTIMER_PWMC_PWMEN2_Pos = 0x2
	// Bit mask of PWMEN2 field.
	CTIMER_PWMC_PWMEN2_Msk = 0x4
	// Bit PWMEN2.
	CTIMER_PWMC_PWMEN2 = 0x4
	// Match. CT32Bn_MAT2 is controlled by EM2.
	CTIMER_PWMC_PWMEN2_MATCH = 0x0
	// PWM. PWM mode is enabled for CT32Bn_MAT2.
	CTIMER_PWMC_PWMEN2_PWM = 0x1
	// Position of PWMEN3 field.
	CTIMER_PWMC_PWMEN3_Pos = 0x3
	// Bit mask of PWMEN3 field.
	CTIMER_PWMC_PWMEN3_Msk = 0x8
	// Bit PWMEN3.
	CTIMER_PWMC_PWMEN3 = 0x8
	// Match. CT32Bn_MAT3 is controlled by EM3.
	CTIMER_PWMC_PWMEN3_MATCH = 0x0
	// PWM. PWM mode is enabled for CT132Bn_MAT3.
	CTIMER_PWMC_PWMEN3_PWM = 0x1
)

// Constants for PINT: QN908X Pin interrupt and pattern match (PINT)
const (
	// ISEL: Pin Interrupt Mode register
	// Position of PMODE field.
	PINT_ISEL_PMODE_Pos = 0x0
	// Bit mask of PMODE field.
	PINT_ISEL_PMODE_Msk = 0xf

	// IENR: Pin interrupt level or rising edge interrupt enable register
	// Position of ENRL field.
	PINT_IENR_ENRL_Pos = 0x0
	// Bit mask of ENRL field.
	PINT_IENR_ENRL_Msk = 0xf

	// SIENR: Pin interrupt level or rising edge interrupt set register
	// Position of SETENRL field.
	PINT_SIENR_SETENRL_Pos = 0x0
	// Bit mask of SETENRL field.
	PINT_SIENR_SETENRL_Msk = 0xf

	// CIENR: Pin interrupt level (rising edge interrupt) clear register
	// Position of CENRL field.
	PINT_CIENR_CENRL_Pos = 0x0
	// Bit mask of CENRL field.
	PINT_CIENR_CENRL_Msk = 0xf

	// IENF: Pin interrupt active level or falling edge interrupt enable register
	// Position of ENAF field.
	PINT_IENF_ENAF_Pos = 0x0
	// Bit mask of ENAF field.
	PINT_IENF_ENAF_Msk = 0xf

	// SIENF: Pin interrupt active level or falling edge interrupt set register
	// Position of SETENAF field.
	PINT_SIENF_SETENAF_Pos = 0x0
	// Bit mask of SETENAF field.
	PINT_SIENF_SETENAF_Msk = 0xf

	// CIENF: Pin interrupt active level or falling edge interrupt clear register
	// Position of CENAF field.
	PINT_CIENF_CENAF_Pos = 0x0
	// Bit mask of CENAF field.
	PINT_CIENF_CENAF_Msk = 0xf

	// RISE: Pin interrupt rising edge register
	// Position of RDET field.
	PINT_RISE_RDET_Pos = 0x0
	// Bit mask of RDET field.
	PINT_RISE_RDET_Msk = 0xf

	// FALL: Pin interrupt falling edge register
	// Position of FDET field.
	PINT_FALL_FDET_Pos = 0x0
	// Bit mask of FDET field.
	PINT_FALL_FDET_Msk = 0xf

	// IST: Pin interrupt status register
	// Position of PSTAT field.
	PINT_IST_PSTAT_Pos = 0x0
	// Bit mask of PSTAT field.
	PINT_IST_PSTAT_Msk = 0xf

	// PMCTRL: Pattern match interrupt control register
	// Position of SEL_PMATCH field.
	PINT_PMCTRL_SEL_PMATCH_Pos = 0x0
	// Bit mask of SEL_PMATCH field.
	PINT_PMCTRL_SEL_PMATCH_Msk = 0x1
	// Bit SEL_PMATCH.
	PINT_PMCTRL_SEL_PMATCH = 0x1
	// Pin interrupt. Interrupts are driven in response to the standard pin interrupt function.
	PINT_PMCTRL_SEL_PMATCH_PIN_INTERRUPT = 0x0
	// Pattern match. Interrupts are driven in response to pattern matches.
	PINT_PMCTRL_SEL_PMATCH_PATTERN_MATCH = 0x1
	// Position of ENA_RXEV field.
	PINT_PMCTRL_ENA_RXEV_Pos = 0x1
	// Bit mask of ENA_RXEV field.
	PINT_PMCTRL_ENA_RXEV_Msk = 0x2
	// Bit ENA_RXEV.
	PINT_PMCTRL_ENA_RXEV = 0x2
	// Disabled. RXEV output to the CPU is disabled.
	PINT_PMCTRL_ENA_RXEV_DISABLED = 0x0
	// Enabled. RXEV output to the CPU is enabled.
	PINT_PMCTRL_ENA_RXEV_ENABLED = 0x1
	// Position of PMAT field.
	PINT_PMCTRL_PMAT_Pos = 0x18
	// Bit mask of PMAT field.
	PINT_PMCTRL_PMAT_Msk = 0xff000000

	// PMSRC: Pattern match interrupt bit-slice source register
	// Position of SRC0 field.
	PINT_PMSRC_SRC0_Pos = 0x8
	// Bit mask of SRC0 field.
	PINT_PMSRC_SRC0_Msk = 0x700
	// Input 0. Selects the pin selected in the PINTSEL0 register as the source to bit slice 0.
	PINT_PMSRC_SRC0_INPUT0 = 0x0
	// Input 1. Selects the pin selected in the PINTSEL1 register as the source to bit slice 0.
	PINT_PMSRC_SRC0_INPUT1 = 0x1
	// Input 2. Selects the pin selected in the PINTSEL2 register as the source to bit slice 0.
	PINT_PMSRC_SRC0_INPUT2 = 0x2
	// Input 3. Selects the pin selected in the PINTSEL3 register as the source to bit slice 0.
	PINT_PMSRC_SRC0_INPUT3 = 0x3
	// Input 4. Selects the pin selected in the PINTSEL4 register as the source to bit slice 0.
	PINT_PMSRC_SRC0_INPUT4 = 0x4
	// Input 5. Selects the pin selected in the PINTSEL5 register as the source to bit slice 0.
	PINT_PMSRC_SRC0_INPUT5 = 0x5
	// Input 6. Selects the pin selected in the PINTSEL6 register as the source to bit slice 0.
	PINT_PMSRC_SRC0_INPUT6 = 0x6
	// Input 7. Selects the pin selected in the PINTSEL7 register as the source to bit slice 0.
	PINT_PMSRC_SRC0_INPUT7 = 0x7
	// Position of SRC1 field.
	PINT_PMSRC_SRC1_Pos = 0xb
	// Bit mask of SRC1 field.
	PINT_PMSRC_SRC1_Msk = 0x3800
	// Input 0. Selects the pin selected in the PINTSEL0 register as the source to bit slice 1.
	PINT_PMSRC_SRC1_INPUT0 = 0x0
	// Input 1. Selects the pin selected in the PINTSEL1 register as the source to bit slice 1.
	PINT_PMSRC_SRC1_INPUT1 = 0x1
	// Input 2. Selects the pin selected in the PINTSEL2 register as the source to bit slice 1.
	PINT_PMSRC_SRC1_INPUT2 = 0x2
	// Input 3. Selects the pin selected in the PINTSEL3 register as the source to bit slice 1.
	PINT_PMSRC_SRC1_INPUT3 = 0x3
	// Input 4. Selects the pin selected in the PINTSEL4 register as the source to bit slice 1.
	PINT_PMSRC_SRC1_INPUT4 = 0x4
	// Input 5. Selects the pin selected in the PINTSEL5 register as the source to bit slice 1.
	PINT_PMSRC_SRC1_INPUT5 = 0x5
	// Input 6. Selects the pin selected in the PINTSEL6 register as the source to bit slice 1.
	PINT_PMSRC_SRC1_INPUT6 = 0x6
	// Input 7. Selects the pin selected in the PINTSEL7 register as the source to bit slice 1.
	PINT_PMSRC_SRC1_INPUT7 = 0x7
	// Position of SRC2 field.
	PINT_PMSRC_SRC2_Pos = 0xe
	// Bit mask of SRC2 field.
	PINT_PMSRC_SRC2_Msk = 0x1c000
	// Input 0. Selects the pin selected in the PINTSEL0 register as the source to bit slice 2.
	PINT_PMSRC_SRC2_INPUT0 = 0x0
	// Input 1. Selects the pin selected in the PINTSEL1 register as the source to bit slice 2.
	PINT_PMSRC_SRC2_INPUT1 = 0x1
	// Input 2. Selects the pin selected in the PINTSEL2 register as the source to bit slice 2.
	PINT_PMSRC_SRC2_INPUT2 = 0x2
	// Input 3. Selects the pin selected in the PINTSEL3 register as the source to bit slice 2.
	PINT_PMSRC_SRC2_INPUT3 = 0x3
	// Input 4. Selects the pin selected in the PINTSEL4 register as the source to bit slice 2.
	PINT_PMSRC_SRC2_INPUT4 = 0x4
	// Input 5. Selects the pin selected in the PINTSEL5 register as the source to bit slice 2.
	PINT_PMSRC_SRC2_INPUT5 = 0x5
	// Input 6. Selects the pin selected in the PINTSEL6 register as the source to bit slice 2.
	PINT_PMSRC_SRC2_INPUT6 = 0x6
	// Input 7. Selects the pin selected in the PINTSEL7 register as the source to bit slice 2.
	PINT_PMSRC_SRC2_INPUT7 = 0x7
	// Position of SRC3 field.
	PINT_PMSRC_SRC3_Pos = 0x11
	// Bit mask of SRC3 field.
	PINT_PMSRC_SRC3_Msk = 0xe0000
	// Input 0. Selects the pin selected in the PINTSEL0 register as the source to bit slice 3.
	PINT_PMSRC_SRC3_INPUT0 = 0x0
	// Input 1. Selects the pin selected in the PINTSEL1 register as the source to bit slice 3.
	PINT_PMSRC_SRC3_INPUT1 = 0x1
	// Input 2. Selects the pin selected in the PINTSEL2 register as the source to bit slice 3.
	PINT_PMSRC_SRC3_INPUT2 = 0x2
	// Input 3. Selects the pin selected in the PINTSEL3 register as the source to bit slice 3.
	PINT_PMSRC_SRC3_INPUT3 = 0x3
	// Input 4. Selects the pin selected in the PINTSEL4 register as the source to bit slice 3.
	PINT_PMSRC_SRC3_INPUT4 = 0x4
	// Input 5. Selects the pin selected in the PINTSEL5 register as the source to bit slice 3.
	PINT_PMSRC_SRC3_INPUT5 = 0x5
	// Input 6. Selects the pin selected in the PINTSEL6 register as the source to bit slice 3.
	PINT_PMSRC_SRC3_INPUT6 = 0x6
	// Input 7. Selects the pin selected in the PINTSEL7 register as the source to bit slice 3.
	PINT_PMSRC_SRC3_INPUT7 = 0x7
	// Position of SRC4 field.
	PINT_PMSRC_SRC4_Pos = 0x14
	// Bit mask of SRC4 field.
	PINT_PMSRC_SRC4_Msk = 0x700000
	// Input 0. Selects the pin selected in the PINTSEL0 register as the source to bit slice 4.
	PINT_PMSRC_SRC4_INPUT0 = 0x0
	// Input 1. Selects the pin selected in the PINTSEL1 register as the source to bit slice 4.
	PINT_PMSRC_SRC4_INPUT1 = 0x1
	// Input 2. Selects the pin selected in the PINTSEL2 register as the source to bit slice 4.
	PINT_PMSRC_SRC4_INPUT2 = 0x2
	// Input 3. Selects the pin selected in the PINTSEL3 register as the source to bit slice 4.
	PINT_PMSRC_SRC4_INPUT3 = 0x3
	// Input 4. Selects the pin selected in the PINTSEL4 register as the source to bit slice 4.
	PINT_PMSRC_SRC4_INPUT4 = 0x4
	// Input 5. Selects the pin selected in the PINTSEL5 register as the source to bit slice 4.
	PINT_PMSRC_SRC4_INPUT5 = 0x5
	// Input 6. Selects the pin selected in the PINTSEL6 register as the source to bit slice 4.
	PINT_PMSRC_SRC4_INPUT6 = 0x6
	// Input 7. Selects the pin selected in the PINTSEL7 register as the source to bit slice 4.
	PINT_PMSRC_SRC4_INPUT7 = 0x7
	// Position of SRC5 field.
	PINT_PMSRC_SRC5_Pos = 0x17
	// Bit mask of SRC5 field.
	PINT_PMSRC_SRC5_Msk = 0x3800000
	// Input 0. Selects the pin selected in the PINTSEL0 register as the source to bit slice 5.
	PINT_PMSRC_SRC5_INPUT0 = 0x0
	// Input 1. Selects the pin selected in the PINTSEL1 register as the source to bit slice 5.
	PINT_PMSRC_SRC5_INPUT1 = 0x1
	// Input 2. Selects the pin selected in the PINTSEL2 register as the source to bit slice 5.
	PINT_PMSRC_SRC5_INPUT2 = 0x2
	// Input 3. Selects the pin selected in the PINTSEL3 register as the source to bit slice 5.
	PINT_PMSRC_SRC5_INPUT3 = 0x3
	// Input 4. Selects the pin selected in the PINTSEL4 register as the source to bit slice 5.
	PINT_PMSRC_SRC5_INPUT4 = 0x4
	// Input 5. Selects the pin selected in the PINTSEL5 register as the source to bit slice 5.
	PINT_PMSRC_SRC5_INPUT5 = 0x5
	// Input 6. Selects the pin selected in the PINTSEL6 register as the source to bit slice 5.
	PINT_PMSRC_SRC5_INPUT6 = 0x6
	// Input 7. Selects the pin selected in the PINTSEL7 register as the source to bit slice 5.
	PINT_PMSRC_SRC5_INPUT7 = 0x7
	// Position of SRC6 field.
	PINT_PMSRC_SRC6_Pos = 0x1a
	// Bit mask of SRC6 field.
	PINT_PMSRC_SRC6_Msk = 0x1c000000
	// Input 0. Selects the pin selected in the PINTSEL0 register as the source to bit slice 6.
	PINT_PMSRC_SRC6_INPUT0 = 0x0
	// Input 1. Selects the pin selected in the PINTSEL1 register as the source to bit slice 6.
	PINT_PMSRC_SRC6_INPUT1 = 0x1
	// Input 2. Selects the pin selected in the PINTSEL2 register as the source to bit slice 6.
	PINT_PMSRC_SRC6_INPUT2 = 0x2
	// Input 3. Selects the pin selected in the PINTSEL3 register as the source to bit slice 6.
	PINT_PMSRC_SRC6_INPUT3 = 0x3
	// Input 4. Selects the pin selected in the PINTSEL4 register as the source to bit slice 6.
	PINT_PMSRC_SRC6_INPUT4 = 0x4
	// Input 5. Selects the pin selected in the PINTSEL5 register as the source to bit slice 6.
	PINT_PMSRC_SRC6_INPUT5 = 0x5
	// Input 6. Selects the pin selected in the PINTSEL6 register as the source to bit slice 6.
	PINT_PMSRC_SRC6_INPUT6 = 0x6
	// Input 7. Selects the pin selected in the PINTSEL7 register as the source to bit slice 6.
	PINT_PMSRC_SRC6_INPUT7 = 0x7
	// Position of SRC7 field.
	PINT_PMSRC_SRC7_Pos = 0x1d
	// Bit mask of SRC7 field.
	PINT_PMSRC_SRC7_Msk = 0xe0000000
	// Input 0. Selects the pin selected in the PINTSEL0 register as the source to bit slice 7.
	PINT_PMSRC_SRC7_INPUT0 = 0x0
	// Input 1. Selects the pin selected in the PINTSEL1 register as the source to bit slice 7.
	PINT_PMSRC_SRC7_INPUT1 = 0x1
	// Input 2. Selects the pin selected in the PINTSEL2 register as the source to bit slice 7.
	PINT_PMSRC_SRC7_INPUT2 = 0x2
	// Input 3. Selects the pin selected in the PINTSEL3 register as the source to bit slice 7.
	PINT_PMSRC_SRC7_INPUT3 = 0x3
	// Input 4. Selects the pin selected in the PINTSEL4 register as the source to bit slice 7.
	PINT_PMSRC_SRC7_INPUT4 = 0x4
	// Input 5. Selects the pin selected in the PINTSEL5 register as the source to bit slice 7.
	PINT_PMSRC_SRC7_INPUT5 = 0x5
	// Input 6. Selects the pin selected in the PINTSEL6 register as the source to bit slice 7.
	PINT_PMSRC_SRC7_INPUT6 = 0x6
	// Input 7. Selects the pin selected in the PINTSEL7 register as the source to bit slice 7.
	PINT_PMSRC_SRC7_INPUT7 = 0x7

	// PMCFG: Pattern match interrupt bit slice configuration register
	// Position of PROD_ENDPTS0 field.
	PINT_PMCFG_PROD_ENDPTS0_Pos = 0x0
	// Bit mask of PROD_ENDPTS0 field.
	PINT_PMCFG_PROD_ENDPTS0_Msk = 0x1
	// Bit PROD_ENDPTS0.
	PINT_PMCFG_PROD_ENDPTS0 = 0x1
	// No effect. Slice 0 is not an endpoint.
	PINT_PMCFG_PROD_ENDPTS0_NO_EFFECT = 0x0
	// endpoint. Slice 0 is the endpoint of a product term (minterm). Pin interrupt 0 in the NVIC is raised if the minterm evaluates as true.
	PINT_PMCFG_PROD_ENDPTS0_ENDPOINT = 0x1
	// Position of PROD_ENDPTS1 field.
	PINT_PMCFG_PROD_ENDPTS1_Pos = 0x1
	// Bit mask of PROD_ENDPTS1 field.
	PINT_PMCFG_PROD_ENDPTS1_Msk = 0x2
	// Bit PROD_ENDPTS1.
	PINT_PMCFG_PROD_ENDPTS1 = 0x2
	// No effect. Slice 1 is not an endpoint.
	PINT_PMCFG_PROD_ENDPTS1_NO_EFFECT = 0x0
	// endpoint. Slice 1 is the endpoint of a product term (minterm). Pin interrupt 1 in the NVIC is raised if the minterm evaluates as true.
	PINT_PMCFG_PROD_ENDPTS1_ENDPOINT = 0x1
	// Position of PROD_ENDPTS2 field.
	PINT_PMCFG_PROD_ENDPTS2_Pos = 0x2
	// Bit mask of PROD_ENDPTS2 field.
	PINT_PMCFG_PROD_ENDPTS2_Msk = 0x4
	// Bit PROD_ENDPTS2.
	PINT_PMCFG_PROD_ENDPTS2 = 0x4
	// No effect. Slice 2 is not an endpoint.
	PINT_PMCFG_PROD_ENDPTS2_NO_EFFECT = 0x0
	// endpoint. Slice 2 is the endpoint of a product term (minterm). Pin interrupt 2 in the NVIC is raised if the minterm evaluates as true.
	PINT_PMCFG_PROD_ENDPTS2_ENDPOINT = 0x1
	// Position of PROD_ENDPTS3 field.
	PINT_PMCFG_PROD_ENDPTS3_Pos = 0x3
	// Bit mask of PROD_ENDPTS3 field.
	PINT_PMCFG_PROD_ENDPTS3_Msk = 0x8
	// Bit PROD_ENDPTS3.
	PINT_PMCFG_PROD_ENDPTS3 = 0x8
	// No effect. Slice 3 is not an endpoint.
	PINT_PMCFG_PROD_ENDPTS3_NO_EFFECT = 0x0
	// endpoint. Slice 3 is the endpoint of a product term (minterm). Pin interrupt 3 in the NVIC is raised if the minterm evaluates as true.
	PINT_PMCFG_PROD_ENDPTS3_ENDPOINT = 0x1
	// Position of PROD_ENDPTS4 field.
	PINT_PMCFG_PROD_ENDPTS4_Pos = 0x4
	// Bit mask of PROD_ENDPTS4 field.
	PINT_PMCFG_PROD_ENDPTS4_Msk = 0x10
	// Bit PROD_ENDPTS4.
	PINT_PMCFG_PROD_ENDPTS4 = 0x10
	// No effect. Slice 4 is not an endpoint.
	PINT_PMCFG_PROD_ENDPTS4_NO_EFFECT = 0x0
	// endpoint. Slice 4 is the endpoint of a product term (minterm). Pin interrupt 4 in the NVIC is raised if the minterm evaluates as true.
	PINT_PMCFG_PROD_ENDPTS4_ENDPOINT = 0x1
	// Position of PROD_ENDPTS5 field.
	PINT_PMCFG_PROD_ENDPTS5_Pos = 0x5
	// Bit mask of PROD_ENDPTS5 field.
	PINT_PMCFG_PROD_ENDPTS5_Msk = 0x20
	// Bit PROD_ENDPTS5.
	PINT_PMCFG_PROD_ENDPTS5 = 0x20
	// No effect. Slice 5 is not an endpoint.
	PINT_PMCFG_PROD_ENDPTS5_NO_EFFECT = 0x0
	// endpoint. Slice 5 is the endpoint of a product term (minterm). Pin interrupt 5 in the NVIC is raised if the minterm evaluates as true.
	PINT_PMCFG_PROD_ENDPTS5_ENDPOINT = 0x1
	// Position of PROD_ENDPTS6 field.
	PINT_PMCFG_PROD_ENDPTS6_Pos = 0x6
	// Bit mask of PROD_ENDPTS6 field.
	PINT_PMCFG_PROD_ENDPTS6_Msk = 0x40
	// Bit PROD_ENDPTS6.
	PINT_PMCFG_PROD_ENDPTS6 = 0x40
	// No effect. Slice 6 is not an endpoint.
	PINT_PMCFG_PROD_ENDPTS6_NO_EFFECT = 0x0
	// endpoint. Slice 6 is the endpoint of a product term (minterm). Pin interrupt 6 in the NVIC is raised if the minterm evaluates as true.
	PINT_PMCFG_PROD_ENDPTS6_ENDPOINT = 0x1
	// Position of CFG0 field.
	PINT_PMCFG_CFG0_Pos = 0x8
	// Bit mask of CFG0 field.
	PINT_PMCFG_CFG0_Msk = 0x700
	// Constant HIGH. This bit slice always contributes to a product term match.
	PINT_PMCFG_CFG0_CONSTANT_HIGH = 0x0
	// Sticky rising edge. Match occurs if a rising edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared. This bit is only cleared when the PMCFG or the PMSRC registers are written to.
	PINT_PMCFG_CFG0_STICKY_RISING_EDGE = 0x1
	// Sticky falling edge. Match occurs if a falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared. This bit is only cleared when the PMCFG or the PMSRC registers are written to.
	PINT_PMCFG_CFG0_STICKY_FALLING_EDGE = 0x2
	// Sticky rising or falling edge. Match occurs if either a rising or falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared. This bit is only cleared when the PMCFG or the PMSRC registers are written to.
	PINT_PMCFG_CFG0_STICKY_RISING_FALLING_EDGE = 0x3
	// High level. Match (for this bit slice) occurs when there is a high level on the input specified for this bit slice in the PMSRC register.
	PINT_PMCFG_CFG0_HIGH_LEVEL = 0x4
	// Low level. Match occurs when there is a low level on the specified input.
	PINT_PMCFG_CFG0_LOW_LEVEL = 0x5
	// Constant 0. This bit slice never contributes to a match (should be used to disable any unused bit slices).
	PINT_PMCFG_CFG0_CONSTANT_ZERO = 0x6
	// Event. Non-sticky rising or falling edge. Match occurs on an event - i.e. when either a rising or falling edge is first detected on the specified input (this is a non-sticky version of value 0x3) . This bit is cleared after one clock cycle.
	PINT_PMCFG_CFG0_EVENT = 0x7
	// Position of CFG1 field.
	PINT_PMCFG_CFG1_Pos = 0xb
	// Bit mask of CFG1 field.
	PINT_PMCFG_CFG1_Msk = 0x3800
	// Constant HIGH. This bit slice always contributes to a product term match.
	PINT_PMCFG_CFG1_CONSTANT_HIGH = 0x0
	// Sticky rising edge. Match occurs if a rising edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared. This bit is only cleared when the PMCFG or the PMSRC registers are written to.
	PINT_PMCFG_CFG1_STICKY_RISING_EDGE = 0x1
	// Sticky falling edge. Match occurs if a falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared. This bit is only cleared when the PMCFG or the PMSRC registers are written to.
	PINT_PMCFG_CFG1_STICKY_FALLING_EDGE = 0x2
	// Sticky rising or falling edge. Match occurs if either a rising or falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared. This bit is only cleared when the PMCFG or the PMSRC registers are written to.
	PINT_PMCFG_CFG1_STICKY_RISING_FALLING_EDGE = 0x3
	// High level. Match (for this bit slice) occurs when there is a high level on the input specified for this bit slice in the PMSRC register.
	PINT_PMCFG_CFG1_HIGH_LEVEL = 0x4
	// Low level. Match occurs when there is a low level on the specified input.
	PINT_PMCFG_CFG1_LOW_LEVEL = 0x5
	// Constant 0. This bit slice never contributes to a match (should be used to disable any unused bit slices).
	PINT_PMCFG_CFG1_CONSTANT_ZERO = 0x6
	// Event. Non-sticky rising or falling edge. Match occurs on an event - i.e. when either a rising or falling edge is first detected on the specified input (this is a non-sticky version of value 0x3) . This bit is cleared after one clock cycle.
	PINT_PMCFG_CFG1_EVENT = 0x7
	// Position of CFG2 field.
	PINT_PMCFG_CFG2_Pos = 0xe
	// Bit mask of CFG2 field.
	PINT_PMCFG_CFG2_Msk = 0x1c000
	// Constant HIGH. This bit slice always contributes to a product term match.
	PINT_PMCFG_CFG2_CONSTANT_HIGH = 0x0
	// Sticky rising edge. Match occurs if a rising edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared. This bit is only cleared when the PMCFG or the PMSRC registers are written to.
	PINT_PMCFG_CFG2_STICKY_RISING_EDGE = 0x1
	// Sticky falling edge. Match occurs if a falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared. This bit is only cleared when the PMCFG or the PMSRC registers are written to.
	PINT_PMCFG_CFG2_STICKY_FALLING_EDGE = 0x2
	// Sticky rising or falling edge. Match occurs if either a rising or falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared. This bit is only cleared when the PMCFG or the PMSRC registers are written to.
	PINT_PMCFG_CFG2_STICKY_RISING_FALLING_EDGE = 0x3
	// High level. Match (for this bit slice) occurs when there is a high level on the input specified for this bit slice in the PMSRC register.
	PINT_PMCFG_CFG2_HIGH_LEVEL = 0x4
	// Low level. Match occurs when there is a low level on the specified input.
	PINT_PMCFG_CFG2_LOW_LEVEL = 0x5
	// Constant 0. This bit slice never contributes to a match (should be used to disable any unused bit slices).
	PINT_PMCFG_CFG2_CONSTANT_ZERO = 0x6
	// Event. Non-sticky rising or falling edge. Match occurs on an event - i.e. when either a rising or falling edge is first detected on the specified input (this is a non-sticky version of value 0x3) . This bit is cleared after one clock cycle.
	PINT_PMCFG_CFG2_EVENT = 0x7
	// Position of CFG3 field.
	PINT_PMCFG_CFG3_Pos = 0x11
	// Bit mask of CFG3 field.
	PINT_PMCFG_CFG3_Msk = 0xe0000
	// Constant HIGH. This bit slice always contributes to a product term match.
	PINT_PMCFG_CFG3_CONSTANT_HIGH = 0x0
	// Sticky rising edge. Match occurs if a rising edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared. This bit is only cleared when the PMCFG or the PMSRC registers are written to.
	PINT_PMCFG_CFG3_STICKY_RISING_EDGE = 0x1
	// Sticky falling edge. Match occurs if a falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared. This bit is only cleared when the PMCFG or the PMSRC registers are written to.
	PINT_PMCFG_CFG3_STICKY_FALLING_EDGE = 0x2
	// Sticky rising or falling edge. Match occurs if either a rising or falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared. This bit is only cleared when the PMCFG or the PMSRC registers are written to.
	PINT_PMCFG_CFG3_STICKY_RISING_FALLING_EDGE = 0x3
	// High level. Match (for this bit slice) occurs when there is a high level on the input specified for this bit slice in the PMSRC register.
	PINT_PMCFG_CFG3_HIGH_LEVEL = 0x4
	// Low level. Match occurs when there is a low level on the specified input.
	PINT_PMCFG_CFG3_LOW_LEVEL = 0x5
	// Constant 0. This bit slice never contributes to a match (should be used to disable any unused bit slices).
	PINT_PMCFG_CFG3_CONSTANT_ZERO = 0x6
	// Event. Non-sticky rising or falling edge. Match occurs on an event - i.e. when either a rising or falling edge is first detected on the specified input (this is a non-sticky version of value 0x3) . This bit is cleared after one clock cycle.
	PINT_PMCFG_CFG3_EVENT = 0x7
	// Position of CFG4 field.
	PINT_PMCFG_CFG4_Pos = 0x14
	// Bit mask of CFG4 field.
	PINT_PMCFG_CFG4_Msk = 0x700000
	// Constant HIGH. This bit slice always contributes to a product term match.
	PINT_PMCFG_CFG4_CONSTANT_HIGH = 0x0
	// Sticky rising edge. Match occurs if a rising edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared. This bit is only cleared when the PMCFG or the PMSRC registers are written to.
	PINT_PMCFG_CFG4_STICKY_RISING_EDGE = 0x1
	// Sticky falling edge. Match occurs if a falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared. This bit is only cleared when the PMCFG or the PMSRC registers are written to.
	PINT_PMCFG_CFG4_STICKY_FALLING_EDGE = 0x2
	// Sticky rising or falling edge. Match occurs if either a rising or falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared. This bit is only cleared when the PMCFG or the PMSRC registers are written to.
	PINT_PMCFG_CFG4_STICKY_RISING_FALLING_EDGE = 0x3
	// High level. Match (for this bit slice) occurs when there is a high level on the input specified for this bit slice in the PMSRC register.
	PINT_PMCFG_CFG4_HIGH_LEVEL = 0x4
	// Low level. Match occurs when there is a low level on the specified input.
	PINT_PMCFG_CFG4_LOW_LEVEL = 0x5
	// Constant 0. This bit slice never contributes to a match (should be used to disable any unused bit slices).
	PINT_PMCFG_CFG4_CONSTANT_ZERO = 0x6
	// Event. Non-sticky rising or falling edge. Match occurs on an event - i.e. when either a rising or falling edge is first detected on the specified input (this is a non-sticky version of value 0x3) . This bit is cleared after one clock cycle.
	PINT_PMCFG_CFG4_EVENT = 0x7
	// Position of CFG5 field.
	PINT_PMCFG_CFG5_Pos = 0x17
	// Bit mask of CFG5 field.
	PINT_PMCFG_CFG5_Msk = 0x3800000
	// Constant HIGH. This bit slice always contributes to a product term match.
	PINT_PMCFG_CFG5_CONSTANT_HIGH = 0x0
	// Sticky rising edge. Match occurs if a rising edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared. This bit is only cleared when the PMCFG or the PMSRC registers are written to.
	PINT_PMCFG_CFG5_STICKY_RISING_EDGE = 0x1
	// Sticky falling edge. Match occurs if a falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared. This bit is only cleared when the PMCFG or the PMSRC registers are written to.
	PINT_PMCFG_CFG5_STICKY_FALLING_EDGE = 0x2
	// Sticky rising or falling edge. Match occurs if either a rising or falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared. This bit is only cleared when the PMCFG or the PMSRC registers are written to.
	PINT_PMCFG_CFG5_STICKY_RISING_FALLING_EDGE = 0x3
	// High level. Match (for this bit slice) occurs when there is a high level on the input specified for this bit slice in the PMSRC register.
	PINT_PMCFG_CFG5_HIGH_LEVEL = 0x4
	// Low level. Match occurs when there is a low level on the specified input.
	PINT_PMCFG_CFG5_LOW_LEVEL = 0x5
	// Constant 0. This bit slice never contributes to a match (should be used to disable any unused bit slices).
	PINT_PMCFG_CFG5_CONSTANT_ZERO = 0x6
	// Event. Non-sticky rising or falling edge. Match occurs on an event - i.e. when either a rising or falling edge is first detected on the specified input (this is a non-sticky version of value 0x3) . This bit is cleared after one clock cycle.
	PINT_PMCFG_CFG5_EVENT = 0x7
	// Position of CFG6 field.
	PINT_PMCFG_CFG6_Pos = 0x1a
	// Bit mask of CFG6 field.
	PINT_PMCFG_CFG6_Msk = 0x1c000000
	// Constant HIGH. This bit slice always contributes to a product term match.
	PINT_PMCFG_CFG6_CONSTANT_HIGH = 0x0
	// Sticky rising edge. Match occurs if a rising edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared. This bit is only cleared when the PMCFG or the PMSRC registers are written to.
	PINT_PMCFG_CFG6_STICKY_RISING_EDGE = 0x1
	// Sticky falling edge. Match occurs if a falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared. This bit is only cleared when the PMCFG or the PMSRC registers are written to.
	PINT_PMCFG_CFG6_STICKY_FALLING_EDGE = 0x2
	// Sticky rising or falling edge. Match occurs if either a rising or falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared. This bit is only cleared when the PMCFG or the PMSRC registers are written to.
	PINT_PMCFG_CFG6_STICKY_RISING_FALLING_EDGE = 0x3
	// High level. Match (for this bit slice) occurs when there is a high level on the input specified for this bit slice in the PMSRC register.
	PINT_PMCFG_CFG6_HIGH_LEVEL = 0x4
	// Low level. Match occurs when there is a low level on the specified input.
	PINT_PMCFG_CFG6_LOW_LEVEL = 0x5
	// Constant 0. This bit slice never contributes to a match (should be used to disable any unused bit slices).
	PINT_PMCFG_CFG6_CONSTANT_ZERO = 0x6
	// Event. Non-sticky rising or falling edge. Match occurs on an event - i.e. when either a rising or falling edge is first detected on the specified input (this is a non-sticky version of value 0x3) . This bit is cleared after one clock cycle.
	PINT_PMCFG_CFG6_EVENT = 0x7
	// Position of CFG7 field.
	PINT_PMCFG_CFG7_Pos = 0x1d
	// Bit mask of CFG7 field.
	PINT_PMCFG_CFG7_Msk = 0xe0000000
	// Constant HIGH. This bit slice always contributes to a product term match.
	PINT_PMCFG_CFG7_CONSTANT_HIGH = 0x0
	// Sticky rising edge. Match occurs if a rising edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared. This bit is only cleared when the PMCFG or the PMSRC registers are written to.
	PINT_PMCFG_CFG7_STICKY_RISING_EDGE = 0x1
	// Sticky falling edge. Match occurs if a falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared. This bit is only cleared when the PMCFG or the PMSRC registers are written to.
	PINT_PMCFG_CFG7_STICKY_FALLING_EDGE = 0x2
	// Sticky rising or falling edge. Match occurs if either a rising or falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared. This bit is only cleared when the PMCFG or the PMSRC registers are written to.
	PINT_PMCFG_CFG7_STICKY_RISING_FALLING_EDGE = 0x3
	// High level. Match (for this bit slice) occurs when there is a high level on the input specified for this bit slice in the PMSRC register.
	PINT_PMCFG_CFG7_HIGH_LEVEL = 0x4
	// Low level. Match occurs when there is a low level on the specified input.
	PINT_PMCFG_CFG7_LOW_LEVEL = 0x5
	// Constant 0. This bit slice never contributes to a match (should be used to disable any unused bit slices).
	PINT_PMCFG_CFG7_CONSTANT_ZERO = 0x6
	// Event. Non-sticky rising or falling edge. Match occurs on an event - i.e. when either a rising or falling edge is first detected on the specified input (this is a non-sticky version of value 0x3) . This bit is cleared after one clock cycle.
	PINT_PMCFG_CFG7_EVENT = 0x7
)

// Constants for INPUTMUX: dmamux
const (
	// PINTSEL: Pin interrupt select register
	// Position of INTPIN field.
	INPUTMUX_PINTSEL_INTPIN_Pos = 0x0
	// Bit mask of INTPIN field.
	INPUTMUX_PINTSEL_INTPIN_Msk = 0x1f

	// DMA_ITRIG_INMUX: Trigger select register for DMA channel
	// Position of INP field.
	INPUTMUX_DMA_ITRIG_INMUX_INP_Pos = 0x0
	// Bit mask of INP field.
	INPUTMUX_DMA_ITRIG_INMUX_INP_Msk = 0x1f

	// DMA_OTRIG_INMUX: DMA output trigger selection to become DMA trigger
	// Position of INP field.
	INPUTMUX_DMA_OTRIG_INMUX_INP_Pos = 0x0
	// Bit mask of INP field.
	INPUTMUX_DMA_OTRIG_INMUX_INP_Msk = 0x1f
)

// Constants for ADC: adc
const (
	// CTRL: ADC control register
	// Position of ENABLE field.
	ADC_CTRL_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	ADC_CTRL_ENABLE_Msk = 0x1
	// Bit ENABLE.
	ADC_CTRL_ENABLE = 0x1
	// Position of CONV_MODE field.
	ADC_CTRL_CONV_MODE_Pos = 0x1
	// Bit mask of CONV_MODE field.
	ADC_CTRL_CONV_MODE_Msk = 0x2
	// Bit CONV_MODE.
	ADC_CTRL_CONV_MODE = 0x2
	// burst conversion
	ADC_CTRL_CONV_MODE_BURST = 0x0
	// single conversion
	ADC_CTRL_CONV_MODE_SINGLE = 0x1
	// Position of SCAN_EN field.
	ADC_CTRL_SCAN_EN_Pos = 0x2
	// Bit mask of SCAN_EN field.
	ADC_CTRL_SCAN_EN_Msk = 0x4
	// Bit SCAN_EN.
	ADC_CTRL_SCAN_EN = 0x4
	// Position of WCMP_EN field.
	ADC_CTRL_WCMP_EN_Pos = 0x3
	// Bit mask of WCMP_EN field.
	ADC_CTRL_WCMP_EN_Msk = 0x8
	// Bit WCMP_EN.
	ADC_CTRL_WCMP_EN = 0x8
	// Position of SW_START field.
	ADC_CTRL_SW_START_Pos = 0x7
	// Bit mask of SW_START field.
	ADC_CTRL_SW_START_Msk = 0x80
	// Bit SW_START.
	ADC_CTRL_SW_START = 0x80
	// Position of CLKSEL field.
	ADC_CTRL_CLKSEL_Pos = 0x8
	// Bit mask of CLKSEL field.
	ADC_CTRL_CLKSEL_Msk = 0x1f00
	// 31P25K
	ADC_CTRL_CLKSEL_CLKSEL_31P25K = 0x0
	// 62P5K
	ADC_CTRL_CLKSEL_CLKSEL_62P5K = 0x4
	// 125K
	ADC_CTRL_CLKSEL_CLKSEL_125K = 0x8
	// 250K
	ADC_CTRL_CLKSEL_CLKSEL_250K = 0xc
	// 500K
	ADC_CTRL_CLKSEL_CLKSEL_500K = 0x10
	// 1M
	ADC_CTRL_CLKSEL_CLKSEL_1M = 0x14
	// 2M
	ADC_CTRL_CLKSEL_CLKSEL_2M = 0x18
	// 32K
	ADC_CTRL_CLKSEL_CLKSEL_32K = 0x1d
	// Position of SIG_INV_EN field.
	ADC_CTRL_SIG_INV_EN_Pos = 0xd
	// Bit mask of SIG_INV_EN field.
	ADC_CTRL_SIG_INV_EN_Msk = 0x2000
	// Bit SIG_INV_EN.
	ADC_CTRL_SIG_INV_EN = 0x2000
	// Position of VREF_SEL field.
	ADC_CTRL_VREF_SEL_Pos = 0xe
	// Bit mask of VREF_SEL field.
	ADC_CTRL_VREF_SEL_Msk = 0xc000
	// Internal vref 1.2V
	ADC_CTRL_VREF_SEL_INT_1P2V = 0x0
	// External VREF
	ADC_CTRL_VREF_SEL_EXT_DRV = 0x1
	// Vext without driver
	ADC_CTRL_VREF_SEL_EXT_NO_DRV = 0x2
	// VCC
	ADC_CTRL_VREF_SEL_VCC = 0x3
	// Position of CH_IDX_EN field.
	ADC_CTRL_CH_IDX_EN_Pos = 0x12
	// Bit mask of CH_IDX_EN field.
	ADC_CTRL_CH_IDX_EN_Msk = 0x40000
	// Bit CH_IDX_EN.
	ADC_CTRL_CH_IDX_EN = 0x40000
	// Position of DATA_FORMAT field.
	ADC_CTRL_DATA_FORMAT_Pos = 0x13
	// Bit mask of DATA_FORMAT field.
	ADC_CTRL_DATA_FORMAT_Msk = 0x80000
	// Bit DATA_FORMAT.
	ADC_CTRL_DATA_FORMAT = 0x80000
	// Position of VREFO_EN field.
	ADC_CTRL_VREFO_EN_Pos = 0x14
	// Bit mask of VREFO_EN field.
	ADC_CTRL_VREFO_EN_Msk = 0x100000
	// Bit VREFO_EN.
	ADC_CTRL_VREFO_EN = 0x100000
	// Position of SRST_DIS field.
	ADC_CTRL_SRST_DIS_Pos = 0x15
	// Bit mask of SRST_DIS field.
	ADC_CTRL_SRST_DIS_Msk = 0x200000
	// Bit SRST_DIS.
	ADC_CTRL_SRST_DIS = 0x200000
	// Position of TRIGGER field.
	ADC_CTRL_TRIGGER_Pos = 0x17
	// Bit mask of TRIGGER field.
	ADC_CTRL_TRIGGER_Msk = 0x1f800000

	// CH_SEL: ADC channel selection register
	// Position of CH_SEL field.
	ADC_CH_SEL_CH_SEL_Pos = 0x0
	// Bit mask of CH_SEL field.
	ADC_CH_SEL_CH_SEL_Msk = 0xffffffff

	// CH_CFG: ADC channel configuration register
	// Position of CH_CFG field.
	ADC_CH_CFG_CH_CFG_Pos = 0x0
	// Bit mask of CH_CFG field.
	ADC_CH_CFG_CH_CFG_Msk = 0xffffffff

	// WCMP_THR: Window compare threshold register
	// Position of WCMP_THR_LOW field.
	ADC_WCMP_THR_WCMP_THR_LOW_Pos = 0x0
	// Bit mask of WCMP_THR_LOW field.
	ADC_WCMP_THR_WCMP_THR_LOW_Msk = 0xffff
	// Position of WCMP_THR_HIGH field.
	ADC_WCMP_THR_WCMP_THR_HIGH_Pos = 0x10
	// Bit mask of WCMP_THR_HIGH field.
	ADC_WCMP_THR_WCMP_THR_HIGH_Msk = 0xffff0000

	// INTEN: ADC interrupt enable register
	// Position of DAT_RDY_INTEN field.
	ADC_INTEN_DAT_RDY_INTEN_Pos = 0x0
	// Bit mask of DAT_RDY_INTEN field.
	ADC_INTEN_DAT_RDY_INTEN_Msk = 0x1
	// Bit DAT_RDY_INTEN.
	ADC_INTEN_DAT_RDY_INTEN = 0x1
	// Position of WCMP_INTEN field.
	ADC_INTEN_WCMP_INTEN_Pos = 0x1
	// Bit mask of WCMP_INTEN field.
	ADC_INTEN_WCMP_INTEN_Msk = 0x2
	// Bit WCMP_INTEN.
	ADC_INTEN_WCMP_INTEN = 0x2
	// Position of FIFO_OF_INTEN field.
	ADC_INTEN_FIFO_OF_INTEN_Pos = 0x2
	// Bit mask of FIFO_OF_INTEN field.
	ADC_INTEN_FIFO_OF_INTEN_Msk = 0x4
	// Bit FIFO_OF_INTEN.
	ADC_INTEN_FIFO_OF_INTEN = 0x4
	// Position of ADC_INTEN field.
	ADC_INTEN_ADC_INTEN_Pos = 0x1f
	// Bit mask of ADC_INTEN field.
	ADC_INTEN_ADC_INTEN_Msk = 0x80000000
	// Bit ADC_INTEN.
	ADC_INTEN_ADC_INTEN = 0x80000000

	// INT: ADC interrupt status register
	// Position of DAT_RDY_INT field.
	ADC_INT_DAT_RDY_INT_Pos = 0x0
	// Bit mask of DAT_RDY_INT field.
	ADC_INT_DAT_RDY_INT_Msk = 0x1
	// Bit DAT_RDY_INT.
	ADC_INT_DAT_RDY_INT = 0x1
	// Position of WCMP_INT field.
	ADC_INT_WCMP_INT_Pos = 0x1
	// Bit mask of WCMP_INT field.
	ADC_INT_WCMP_INT_Msk = 0x2
	// Bit WCMP_INT.
	ADC_INT_WCMP_INT = 0x2
	// Position of FIFO_OF_INT field.
	ADC_INT_FIFO_OF_INT_Pos = 0x2
	// Bit mask of FIFO_OF_INT field.
	ADC_INT_FIFO_OF_INT_Msk = 0x4
	// Bit FIFO_OF_INT.
	ADC_INT_FIFO_OF_INT = 0x4
	// Position of ADC_INT field.
	ADC_INT_ADC_INT_Pos = 0x1f
	// Bit mask of ADC_INT field.
	ADC_INT_ADC_INT_Msk = 0x80000000
	// Bit ADC_INT.
	ADC_INT_ADC_INT = 0x80000000

	// DATA: ADC converted data output
	// Position of DATA field.
	ADC_DATA_DATA_Pos = 0x0
	// Bit mask of DATA field.
	ADC_DATA_DATA_Msk = 0xffffffff

	// CFG: ADC configuration register
	// Position of PGA_GAIN field.
	ADC_CFG_PGA_GAIN_Pos = 0x0
	// Bit mask of PGA_GAIN field.
	ADC_CFG_PGA_GAIN_Msk = 0x7
	// Position of PGA_BP field.
	ADC_CFG_PGA_BP_Pos = 0x3
	// Bit mask of PGA_BP field.
	ADC_CFG_PGA_BP_Msk = 0x8
	// Bit PGA_BP.
	ADC_CFG_PGA_BP = 0x8
	// Position of PGA_VINN field.
	ADC_CFG_PGA_VINN_Pos = 0x4
	// Bit mask of PGA_VINN field.
	ADC_CFG_PGA_VINN_Msk = 0x30
	// VREF
	ADC_CFG_PGA_VINN_VREF = 0x0
	// 3/4 VREF
	ADC_CFG_PGA_VINN_VREF_0P75 = 0x1
	// 1/2 VREF
	ADC_CFG_PGA_VINN_VREF_0P5 = 0x2
	// AVSS
	ADC_CFG_PGA_VINN_AVSS = 0x3
	// Position of ADC_GAIN field.
	ADC_CFG_ADC_GAIN_Pos = 0x6
	// Bit mask of ADC_GAIN field.
	ADC_CFG_ADC_GAIN_Msk = 0xc0
	// 0.5x
	ADC_CFG_ADC_GAIN_ADC_GAIN_0P5X = 0x0
	// 1x
	ADC_CFG_ADC_GAIN_ADC_GAIN_1X = 0x1
	// 1.5x
	ADC_CFG_ADC_GAIN_ADC_GAIN_1P5X = 0x2
	// 2x
	ADC_CFG_ADC_GAIN_ADC_GAIN_2X = 0x3
	// Position of VREF_GAIN field.
	ADC_CFG_VREF_GAIN_Pos = 0x8
	// Bit mask of VREF_GAIN field.
	ADC_CFG_VREF_GAIN_Msk = 0x100
	// Bit VREF_GAIN.
	ADC_CFG_VREF_GAIN = 0x100
	// 1x
	ADC_CFG_VREF_GAIN_VREF_GAIN_1X = 0x0
	// 1.5x
	ADC_CFG_VREF_GAIN_VREF_GAIN_1P5X = 0x1
	// Position of ADC_VCM field.
	ADC_CFG_ADC_VCM_Pos = 0x9
	// Bit mask of ADC_VCM field.
	ADC_CFG_ADC_VCM_Msk = 0xe00
	// 1/16 VCC
	ADC_CFG_ADC_VCM_ADC_VCM_1D16 = 0x0
	// 1/8 VCC
	ADC_CFG_ADC_VCM_ADC_VCM_1D8 = 0x1
	// 2/8 VCC
	ADC_CFG_ADC_VCM_ADC_VCM_2D8 = 0x2
	// 3/8 VCC
	ADC_CFG_ADC_VCM_ADC_VCM_3D8 = 0x3
	// 4/8 VCC
	ADC_CFG_ADC_VCM_ADC_VCM_4D8 = 0x4
	// 5/8 VCC
	ADC_CFG_ADC_VCM_ADC_VCM_5D8 = 0x5
	// 6/8 VCC
	ADC_CFG_ADC_VCM_ADC_VCM_6D8 = 0x6
	// 7/8 VCC
	ADC_CFG_ADC_VCM_ADC_VCM_7D8 = 0x7
	// Position of PGA_VCM_EN field.
	ADC_CFG_PGA_VCM_EN_Pos = 0xc
	// Bit mask of PGA_VCM_EN field.
	ADC_CFG_PGA_VCM_EN_Msk = 0x1000
	// Bit PGA_VCM_EN.
	ADC_CFG_PGA_VCM_EN = 0x1000
	// Position of PGA_VCM_DIR field.
	ADC_CFG_PGA_VCM_DIR_Pos = 0xd
	// Bit mask of PGA_VCM_DIR field.
	ADC_CFG_PGA_VCM_DIR_Msk = 0x2000
	// Bit PGA_VCM_DIR.
	ADC_CFG_PGA_VCM_DIR = 0x2000
	// down
	ADC_CFG_PGA_VCM_DIR_DOWN = 0x0
	// up
	ADC_CFG_PGA_VCM_DIR_UP = 0x1
	// Position of PGA_VCM field.
	ADC_CFG_PGA_VCM_Pos = 0xe
	// Bit mask of PGA_VCM field.
	ADC_CFG_PGA_VCM_Msk = 0xfc000
	// Position of DOWN_SAMPLE_RATE field.
	ADC_CFG_DOWN_SAMPLE_RATE_Pos = 0x14
	// Bit mask of DOWN_SAMPLE_RATE field.
	ADC_CFG_DOWN_SAMPLE_RATE_Msk = 0x700000
	// down sample 32
	ADC_CFG_DOWN_SAMPLE_RATE_DOWN_SAMPLE_32 = 0x1
	// down sample 64
	ADC_CFG_DOWN_SAMPLE_RATE_DOWN_SAMPLE_64 = 0x3
	// down sample 256
	ADC_CFG_DOWN_SAMPLE_RATE_DOWN_SAMPLE_256 = 0x4
	// down sample 128
	ADC_CFG_DOWN_SAMPLE_RATE_DOWN_SAMPLE_128 = 0x5
	// Position of DS_DATA_STABLE field.
	ADC_CFG_DS_DATA_STABLE_Pos = 0x17
	// Bit mask of DS_DATA_STABLE field.
	ADC_CFG_DS_DATA_STABLE_Msk = 0x1f800000
	// Position of SCAN_INTV field.
	ADC_CFG_SCAN_INTV_Pos = 0x1d
	// Bit mask of SCAN_INTV field.
	ADC_CFG_SCAN_INTV_Msk = 0xe0000000
	// 2 clock cycle
	ADC_CFG_SCAN_INTV_SCAN_INTV_2CLK = 0x0
	// 4 clock cycle
	ADC_CFG_SCAN_INTV_SCAN_INTV_4CLK = 0x1
	// 8 clock cycle
	ADC_CFG_SCAN_INTV_SCAN_INTV_8CLK = 0x2
	// 16 clock cycle
	ADC_CFG_SCAN_INTV_SCAN_INTV_16CLK = 0x3
	// 32 clock cycle
	ADC_CFG_SCAN_INTV_SCAN_INTV_32CLK = 0x4
	// 64 clock cycle
	ADC_CFG_SCAN_INTV_SCAN_INTV_64CLK = 0x5
	// 128 clock cycle
	ADC_CFG_SCAN_INTV_SCAN_INTV_128CLK = 0x6
	// 256 clock cycle
	ADC_CFG_SCAN_INTV_SCAN_INTV_256CLK = 0x7

	// BG_BF: ADC bandcap and buffer setting register
	// Position of PGA_BM field.
	ADC_BG_BF_PGA_BM_Pos = 0x0
	// Bit mask of PGA_BM field.
	ADC_BG_BF_PGA_BM_Msk = 0x7
	// 50%
	ADC_BG_BF_PGA_BM_PGA_BM_50PCNT = 0x0
	// 75%
	ADC_BG_BF_PGA_BM_PGA_BM_75PCNT = 0x1
	// 100%
	ADC_BG_BF_PGA_BM_PGA_BM_100PCNT = 0x2
	// 150%
	ADC_BG_BF_PGA_BM_PGA_BM_150PCNT = 0x3
	// 200%
	ADC_BG_BF_PGA_BM_PGA_BM_200PCNT = 0x4
	// 300%
	ADC_BG_BF_PGA_BM_PGA_BM_300PCNT = 0x5
	// Position of BG_SEL field.
	ADC_BG_BF_BG_SEL_Pos = 0x4
	// Bit mask of BG_SEL field.
	ADC_BG_BF_BG_SEL_Msk = 0xf0
	// Position of TEMP_EN field.
	ADC_BG_BF_TEMP_EN_Pos = 0xc
	// Bit mask of TEMP_EN field.
	ADC_BG_BF_TEMP_EN_Msk = 0x1000
	// Bit TEMP_EN.
	ADC_BG_BF_TEMP_EN = 0x1000
	// Position of PGA_CHOP_EN field.
	ADC_BG_BF_PGA_CHOP_EN_Pos = 0xd
	// Bit mask of PGA_CHOP_EN field.
	ADC_BG_BF_PGA_CHOP_EN_Msk = 0x2000
	// Bit PGA_CHOP_EN.
	ADC_BG_BF_PGA_CHOP_EN = 0x2000
	// Position of PGA_BM_DIV2 field.
	ADC_BG_BF_PGA_BM_DIV2_Pos = 0xe
	// Bit mask of PGA_BM_DIV2 field.
	ADC_BG_BF_PGA_BM_DIV2_Msk = 0x4000
	// Bit PGA_BM_DIV2.
	ADC_BG_BF_PGA_BM_DIV2 = 0x4000

	// ANA_CTRL: ADC core and reference setting regsiter
	// Position of ADC_BM field.
	ADC_ANA_CTRL_ADC_BM_Pos = 0x0
	// Bit mask of ADC_BM field.
	ADC_ANA_CTRL_ADC_BM_Msk = 0x7
	// 50%
	ADC_ANA_CTRL_ADC_BM_ADC_BM_50PCNT = 0x0
	// 75%
	ADC_ANA_CTRL_ADC_BM_ADC_BM_75PCNT = 0x1
	// 100%
	ADC_ANA_CTRL_ADC_BM_ADC_BM_100PCNT = 0x2
	// 150%
	ADC_ANA_CTRL_ADC_BM_ADC_BM_150PCNT = 0x3
	// 200%
	ADC_ANA_CTRL_ADC_BM_ADC_BM_200PCNT = 0x4
	// 300%
	ADC_ANA_CTRL_ADC_BM_ADC_BM_300PCNT = 0x5
	// Position of ADC_ORDER field.
	ADC_ANA_CTRL_ADC_ORDER_Pos = 0x4
	// Bit mask of ADC_ORDER field.
	ADC_ANA_CTRL_ADC_ORDER_Msk = 0x10
	// Bit ADC_ORDER.
	ADC_ANA_CTRL_ADC_ORDER = 0x10
	// 3 order
	ADC_ANA_CTRL_ADC_ORDER_ADC_ORDER_3ORDER = 0x0
	// 2 order
	ADC_ANA_CTRL_ADC_ORDER_ADC_ORDER_2ORDER = 0x1
	// Position of DITHER_EN field.
	ADC_ANA_CTRL_DITHER_EN_Pos = 0x5
	// Bit mask of DITHER_EN field.
	ADC_ANA_CTRL_DITHER_EN_Msk = 0x20
	// Bit DITHER_EN.
	ADC_ANA_CTRL_DITHER_EN = 0x20
	// Position of CHOP_EN field.
	ADC_ANA_CTRL_CHOP_EN_Pos = 0x6
	// Bit mask of CHOP_EN field.
	ADC_ANA_CTRL_CHOP_EN_Msk = 0x40
	// Bit CHOP_EN.
	ADC_ANA_CTRL_CHOP_EN = 0x40
	// Position of INV_CLK field.
	ADC_ANA_CTRL_INV_CLK_Pos = 0x7
	// Bit mask of INV_CLK field.
	ADC_ANA_CTRL_INV_CLK_Msk = 0x80
	// Bit INV_CLK.
	ADC_ANA_CTRL_INV_CLK = 0x80
	// Position of VREF_BM field.
	ADC_ANA_CTRL_VREF_BM_Pos = 0x8
	// Bit mask of VREF_BM field.
	ADC_ANA_CTRL_VREF_BM_Msk = 0x700
	// 50%
	ADC_ANA_CTRL_VREF_BM_VREF_BM_50PCNT = 0x0
	// 75%
	ADC_ANA_CTRL_VREF_BM_VREF_BM_75PCNT = 0x1
	// 100%
	ADC_ANA_CTRL_VREF_BM_VREF_BM_100PCNT = 0x2
	// 150%
	ADC_ANA_CTRL_VREF_BM_VREF_BM_150PCNT = 0x3
	// 200%
	ADC_ANA_CTRL_VREF_BM_VREF_BM_200PCNT = 0x4
	// 300%
	ADC_ANA_CTRL_VREF_BM_VREF_BM_300PCNT = 0x5
	// Position of VREF_BM_X3 field.
	ADC_ANA_CTRL_VREF_BM_X3_Pos = 0xb
	// Bit mask of VREF_BM_X3 field.
	ADC_ANA_CTRL_VREF_BM_X3_Msk = 0x800
	// Bit VREF_BM_X3.
	ADC_ANA_CTRL_VREF_BM_X3 = 0x800
	// Position of VINN_IN_BM field.
	ADC_ANA_CTRL_VINN_IN_BM_Pos = 0xc
	// Bit mask of VINN_IN_BM field.
	ADC_ANA_CTRL_VINN_IN_BM_Msk = 0x7000
	// 50%
	ADC_ANA_CTRL_VINN_IN_BM_VINN_IN_BM_50PCNT = 0x0
	// 75%
	ADC_ANA_CTRL_VINN_IN_BM_VINN_IN_BM_75PCNT = 0x1
	// 100%
	ADC_ANA_CTRL_VINN_IN_BM_VINN_IN_BM_100PCNT = 0x2
	// 150%
	ADC_ANA_CTRL_VINN_IN_BM_VINN_IN_BM_150PCNT = 0x3
	// 200%
	ADC_ANA_CTRL_VINN_IN_BM_VINN_IN_BM_200PCNT = 0x4
	// 300%
	ADC_ANA_CTRL_VINN_IN_BM_VINN_IN_BM_300PCNT = 0x5
	// Position of VINN_OUT_BM field.
	ADC_ANA_CTRL_VINN_OUT_BM_Pos = 0x10
	// Bit mask of VINN_OUT_BM field.
	ADC_ANA_CTRL_VINN_OUT_BM_Msk = 0x70000
	// 50%
	ADC_ANA_CTRL_VINN_OUT_BM_VINN_OUT_BM_50PCNT = 0x0
	// 75%
	ADC_ANA_CTRL_VINN_OUT_BM_VINN_OUT_BM_75PCNT = 0x1
	// 100%
	ADC_ANA_CTRL_VINN_OUT_BM_VINN_OUT_BM_100PCNT = 0x2
	// 150%
	ADC_ANA_CTRL_VINN_OUT_BM_VINN_OUT_BM_150PCNT = 0x3
	// 200%
	ADC_ANA_CTRL_VINN_OUT_BM_VINN_OUT_BM_200PCNT = 0x4
	// 300%
	ADC_ANA_CTRL_VINN_OUT_BM_VINN_OUT_BM_300PCNT = 0x5
	// Position of VINN_OUT_BM_X3 field.
	ADC_ANA_CTRL_VINN_OUT_BM_X3_Pos = 0x13
	// Bit mask of VINN_OUT_BM_X3 field.
	ADC_ANA_CTRL_VINN_OUT_BM_X3_Msk = 0x80000
	// Bit VINN_OUT_BM_X3.
	ADC_ANA_CTRL_VINN_OUT_BM_X3 = 0x80000
	// Position of ADC_BM_DIV2 field.
	ADC_ANA_CTRL_ADC_BM_DIV2_Pos = 0x14
	// Bit mask of ADC_BM_DIV2 field.
	ADC_ANA_CTRL_ADC_BM_DIV2_Msk = 0x100000
	// Bit ADC_BM_DIV2.
	ADC_ANA_CTRL_ADC_BM_DIV2 = 0x100000
)

// Constants for DAC: dac
const (
	// ANA_CFG: reserved
	// Position of FILTER_BM field.
	DAC_ANA_CFG_FILTER_BM_Pos = 0x0
	// Bit mask of FILTER_BM field.
	DAC_ANA_CFG_FILTER_BM_Msk = 0x7
	// Position of DAC_AMP field.
	DAC_ANA_CFG_DAC_AMP_Pos = 0x4
	// Bit mask of DAC_AMP field.
	DAC_ANA_CFG_DAC_AMP_Msk = 0x70
	// Position of FILTER_BW field.
	DAC_ANA_CFG_FILTER_BW_Pos = 0x8
	// Bit mask of FILTER_BW field.
	DAC_ANA_CFG_FILTER_BW_Msk = 0x300
	// Position of FILTER_150K_EN field.
	DAC_ANA_CFG_FILTER_150K_EN_Pos = 0xc
	// Bit mask of FILTER_150K_EN field.
	DAC_ANA_CFG_FILTER_150K_EN_Msk = 0x1000
	// Bit FILTER_150K_EN.
	DAC_ANA_CFG_FILTER_150K_EN = 0x1000
	// Position of VCM field.
	DAC_ANA_CFG_VCM_Pos = 0x10
	// Bit mask of VCM field.
	DAC_ANA_CFG_VCM_Msk = 0xf0000

	// CTRL: DAC clock invert
	// Position of ENABLE field.
	DAC_CTRL_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	DAC_CTRL_ENABLE_Msk = 0x1
	// Bit ENABLE.
	DAC_CTRL_ENABLE = 0x1
	// Position of SIN_EN field.
	DAC_CTRL_SIN_EN_Pos = 0x1
	// Bit mask of SIN_EN field.
	DAC_CTRL_SIN_EN_Msk = 0x2
	// Bit SIN_EN.
	DAC_CTRL_SIN_EN = 0x2
	// Position of MOD_EN field.
	DAC_CTRL_MOD_EN_Pos = 0x2
	// Bit mask of MOD_EN field.
	DAC_CTRL_MOD_EN_Msk = 0x4
	// Bit MOD_EN.
	DAC_CTRL_MOD_EN = 0x4
	// Position of MOD_WD field.
	DAC_CTRL_MOD_WD_Pos = 0x3
	// Bit mask of MOD_WD field.
	DAC_CTRL_MOD_WD_Msk = 0x8
	// Bit MOD_WD.
	DAC_CTRL_MOD_WD = 0x8
	// Position of SMPL_RATE field.
	DAC_CTRL_SMPL_RATE_Pos = 0x4
	// Bit mask of SMPL_RATE field.
	DAC_CTRL_SMPL_RATE_Msk = 0x70
	// Position of SGN_INV field.
	DAC_CTRL_SGN_INV_Pos = 0x7
	// Bit mask of SGN_INV field.
	DAC_CTRL_SGN_INV_Msk = 0x80
	// Bit SGN_INV.
	DAC_CTRL_SGN_INV = 0x80
	// Position of BUF_IN_ALGN field.
	DAC_CTRL_BUF_IN_ALGN_Pos = 0x8
	// Bit mask of BUF_IN_ALGN field.
	DAC_CTRL_BUF_IN_ALGN_Msk = 0x100
	// Bit BUF_IN_ALGN.
	DAC_CTRL_BUF_IN_ALGN = 0x100
	// Position of BUF_OUT_ALGN field.
	DAC_CTRL_BUF_OUT_ALGN_Pos = 0x9
	// Bit mask of BUF_OUT_ALGN field.
	DAC_CTRL_BUF_OUT_ALGN_Msk = 0x200
	// Bit BUF_OUT_ALGN.
	DAC_CTRL_BUF_OUT_ALGN = 0x200
	// Position of TRG_MODE field.
	DAC_CTRL_TRG_MODE_Pos = 0xa
	// Bit mask of TRG_MODE field.
	DAC_CTRL_TRG_MODE_Msk = 0x400
	// Bit TRG_MODE.
	DAC_CTRL_TRG_MODE = 0x400
	// Position of TRG_EDGE field.
	DAC_CTRL_TRG_EDGE_Pos = 0xb
	// Bit mask of TRG_EDGE field.
	DAC_CTRL_TRG_EDGE_Msk = 0x1800
	// Position of TRG_SEL field.
	DAC_CTRL_TRG_SEL_Pos = 0x10
	// Bit mask of TRG_SEL field.
	DAC_CTRL_TRG_SEL_Msk = 0x3f0000
	// Position of CLK_DIV field.
	DAC_CTRL_CLK_DIV_Pos = 0x18
	// Bit mask of CLK_DIV field.
	DAC_CTRL_CLK_DIV_Msk = 0x7f000000
	// Position of CLK_INV field.
	DAC_CTRL_CLK_INV_Pos = 0x1f
	// Bit mask of CLK_INV field.
	DAC_CTRL_CLK_INV_Msk = 0x80000000
	// Bit CLK_INV.
	DAC_CTRL_CLK_INV = 0x80000000

	// SIN_CFG0: sin amplitude
	// Position of SIN_FREQ field.
	DAC_SIN_CFG0_SIN_FREQ_Pos = 0x0
	// Bit mask of SIN_FREQ field.
	DAC_SIN_CFG0_SIN_FREQ_Msk = 0xffff
	// Position of SIN_AMP field.
	DAC_SIN_CFG0_SIN_AMP_Pos = 0x10
	// Bit mask of SIN_AMP field.
	DAC_SIN_CFG0_SIN_AMP_Msk = 0xffff0000

	// SIN_CFG1: reserved
	// Position of SIN_DC field.
	DAC_SIN_CFG1_SIN_DC_Pos = 0x0
	// Bit mask of SIN_DC field.
	DAC_SIN_CFG1_SIN_DC_Msk = 0xfffff

	// GAIN_CTRL: reserved
	// Position of GAIN_CTRL field.
	DAC_GAIN_CTRL_GAIN_CTRL_Pos = 0x0
	// Bit mask of GAIN_CTRL field.
	DAC_GAIN_CTRL_GAIN_CTRL_Msk = 0xff

	// CLR_TRG: Reserved
	// Position of BUF_CLR field.
	DAC_CLR_TRG_BUF_CLR_Pos = 0x0
	// Bit mask of BUF_CLR field.
	DAC_CLR_TRG_BUF_CLR_Msk = 0x1
	// Bit BUF_CLR.
	DAC_CLR_TRG_BUF_CLR = 0x1
	// Position of SW_TRG field.
	DAC_CLR_TRG_SW_TRG_Pos = 0x1
	// Bit mask of SW_TRG field.
	DAC_CLR_TRG_SW_TRG_Msk = 0x2
	// Bit SW_TRG.
	DAC_CLR_TRG_SW_TRG = 0x2

	// DIN: DAC data input
	// Position of DIN field.
	DAC_DIN_DIN_Pos = 0x0
	// Bit mask of DIN field.
	DAC_DIN_DIN_Msk = 0xffffffff

	// INT: Reserved
	// Position of BUF_NFUL_INT field.
	DAC_INT_BUF_NFUL_INT_Pos = 0x0
	// Bit mask of BUF_NFUL_INT field.
	DAC_INT_BUF_NFUL_INT_Msk = 0x1
	// Bit BUF_NFUL_INT.
	DAC_INT_BUF_NFUL_INT = 0x1
	// Position of BUF_FUL_INT field.
	DAC_INT_BUF_FUL_INT_Pos = 0x1
	// Bit mask of BUF_FUL_INT field.
	DAC_INT_BUF_FUL_INT_Msk = 0x2
	// Bit BUF_FUL_INT.
	DAC_INT_BUF_FUL_INT = 0x2
	// Position of BUF_EMT_INT field.
	DAC_INT_BUF_EMT_INT_Pos = 0x2
	// Bit mask of BUF_EMT_INT field.
	DAC_INT_BUF_EMT_INT_Msk = 0x4
	// Bit BUF_EMT_INT.
	DAC_INT_BUF_EMT_INT = 0x4
	// Position of BUF_HEMT_INT field.
	DAC_INT_BUF_HEMT_INT_Pos = 0x3
	// Bit mask of BUF_HEMT_INT field.
	DAC_INT_BUF_HEMT_INT_Msk = 0x8
	// Bit BUF_HEMT_INT.
	DAC_INT_BUF_HEMT_INT = 0x8
	// Position of BUF_OV_INT field.
	DAC_INT_BUF_OV_INT_Pos = 0x4
	// Bit mask of BUF_OV_INT field.
	DAC_INT_BUF_OV_INT_Msk = 0x10
	// Bit BUF_OV_INT.
	DAC_INT_BUF_OV_INT = 0x10
	// Position of BUF_UD_INT field.
	DAC_INT_BUF_UD_INT_Pos = 0x5
	// Bit mask of BUF_UD_INT field.
	DAC_INT_BUF_UD_INT_Msk = 0x20
	// Bit BUF_UD_INT.
	DAC_INT_BUF_UD_INT = 0x20
	// Position of BUF_HFUL_INT field.
	DAC_INT_BUF_HFUL_INT_Pos = 0x6
	// Bit mask of BUF_HFUL_INT field.
	DAC_INT_BUF_HFUL_INT_Msk = 0x40
	// Bit BUF_HFUL_INT.
	DAC_INT_BUF_HFUL_INT = 0x40

	// INTEN: Reserved
	// Position of BUF_NFUL_INTEN field.
	DAC_INTEN_BUF_NFUL_INTEN_Pos = 0x0
	// Bit mask of BUF_NFUL_INTEN field.
	DAC_INTEN_BUF_NFUL_INTEN_Msk = 0x1
	// Bit BUF_NFUL_INTEN.
	DAC_INTEN_BUF_NFUL_INTEN = 0x1
	// Position of BUF_FUL_INTEN field.
	DAC_INTEN_BUF_FUL_INTEN_Pos = 0x1
	// Bit mask of BUF_FUL_INTEN field.
	DAC_INTEN_BUF_FUL_INTEN_Msk = 0x2
	// Bit BUF_FUL_INTEN.
	DAC_INTEN_BUF_FUL_INTEN = 0x2
	// Position of BUF_EMT_INTEN field.
	DAC_INTEN_BUF_EMT_INTEN_Pos = 0x2
	// Bit mask of BUF_EMT_INTEN field.
	DAC_INTEN_BUF_EMT_INTEN_Msk = 0x4
	// Bit BUF_EMT_INTEN.
	DAC_INTEN_BUF_EMT_INTEN = 0x4
	// Position of BUF_HEMT_INTEN field.
	DAC_INTEN_BUF_HEMT_INTEN_Pos = 0x3
	// Bit mask of BUF_HEMT_INTEN field.
	DAC_INTEN_BUF_HEMT_INTEN_Msk = 0x8
	// Bit BUF_HEMT_INTEN.
	DAC_INTEN_BUF_HEMT_INTEN = 0x8
	// Position of BUF_OV_INTEN field.
	DAC_INTEN_BUF_OV_INTEN_Pos = 0x4
	// Bit mask of BUF_OV_INTEN field.
	DAC_INTEN_BUF_OV_INTEN_Msk = 0x10
	// Bit BUF_OV_INTEN.
	DAC_INTEN_BUF_OV_INTEN = 0x10
	// Position of BUF_UD_INTEN field.
	DAC_INTEN_BUF_UD_INTEN_Pos = 0x5
	// Bit mask of BUF_UD_INTEN field.
	DAC_INTEN_BUF_UD_INTEN_Msk = 0x20
	// Bit BUF_UD_INTEN.
	DAC_INTEN_BUF_UD_INTEN = 0x20
	// Position of BUF_HFUL_INTEN field.
	DAC_INTEN_BUF_HFUL_INTEN_Pos = 0x6
	// Bit mask of BUF_HFUL_INTEN field.
	DAC_INTEN_BUF_HFUL_INTEN_Msk = 0x40
	// Bit BUF_HFUL_INTEN.
	DAC_INTEN_BUF_HFUL_INTEN = 0x40

	// INT_STAT: Reserved
	// Position of BUF_NFUL_INT_STAT field.
	DAC_INT_STAT_BUF_NFUL_INT_STAT_Pos = 0x0
	// Bit mask of BUF_NFUL_INT_STAT field.
	DAC_INT_STAT_BUF_NFUL_INT_STAT_Msk = 0x1
	// Bit BUF_NFUL_INT_STAT.
	DAC_INT_STAT_BUF_NFUL_INT_STAT = 0x1
	// Position of BUF_FUL_INT_STAT field.
	DAC_INT_STAT_BUF_FUL_INT_STAT_Pos = 0x1
	// Bit mask of BUF_FUL_INT_STAT field.
	DAC_INT_STAT_BUF_FUL_INT_STAT_Msk = 0x2
	// Bit BUF_FUL_INT_STAT.
	DAC_INT_STAT_BUF_FUL_INT_STAT = 0x2
	// Position of BUF_EMT_INT_STAT field.
	DAC_INT_STAT_BUF_EMT_INT_STAT_Pos = 0x2
	// Bit mask of BUF_EMT_INT_STAT field.
	DAC_INT_STAT_BUF_EMT_INT_STAT_Msk = 0x4
	// Bit BUF_EMT_INT_STAT.
	DAC_INT_STAT_BUF_EMT_INT_STAT = 0x4
	// Position of BUF_HEMT_INT_STAT field.
	DAC_INT_STAT_BUF_HEMT_INT_STAT_Pos = 0x3
	// Bit mask of BUF_HEMT_INT_STAT field.
	DAC_INT_STAT_BUF_HEMT_INT_STAT_Msk = 0x8
	// Bit BUF_HEMT_INT_STAT.
	DAC_INT_STAT_BUF_HEMT_INT_STAT = 0x8
	// Position of BUF_OV_INT_STAT field.
	DAC_INT_STAT_BUF_OV_INT_STAT_Pos = 0x4
	// Bit mask of BUF_OV_INT_STAT field.
	DAC_INT_STAT_BUF_OV_INT_STAT_Msk = 0x10
	// Bit BUF_OV_INT_STAT.
	DAC_INT_STAT_BUF_OV_INT_STAT = 0x10
	// Position of BUF_UD_INT_STAT field.
	DAC_INT_STAT_BUF_UD_INT_STAT_Pos = 0x5
	// Bit mask of BUF_UD_INT_STAT field.
	DAC_INT_STAT_BUF_UD_INT_STAT_Msk = 0x20
	// Bit BUF_UD_INT_STAT.
	DAC_INT_STAT_BUF_UD_INT_STAT = 0x20
	// Position of BUF_HFUL_INT_STAT field.
	DAC_INT_STAT_BUF_HFUL_INT_STAT_Pos = 0x6
	// Bit mask of BUF_HFUL_INT_STAT field.
	DAC_INT_STAT_BUF_HFUL_INT_STAT_Msk = 0x40
	// Bit BUF_HFUL_INT_STAT.
	DAC_INT_STAT_BUF_HFUL_INT_STAT = 0x40
	// Position of DAC_INT_STAT field.
	DAC_INT_STAT_DAC_INT_STAT_Pos = 0x10
	// Bit mask of DAC_INT_STAT field.
	DAC_INT_STAT_DAC_INT_STAT_Msk = 0x10000
	// Bit DAC_INT_STAT.
	DAC_INT_STAT_DAC_INT_STAT = 0x10000

	// STATUS: Reserved
	// Position of BUSY field.
	DAC_STATUS_BUSY_Pos = 0x0
	// Bit mask of BUSY field.
	DAC_STATUS_BUSY_Msk = 0x1
	// Bit BUSY.
	DAC_STATUS_BUSY = 0x1
	// Position of BUF_WR_PTR field.
	DAC_STATUS_BUF_WR_PTR_Pos = 0x10
	// Bit mask of BUF_WR_PTR field.
	DAC_STATUS_BUF_WR_PTR_Msk = 0x70000
	// Position of BUF_RD_PTR field.
	DAC_STATUS_BUF_RD_PTR_Pos = 0x14
	// Bit mask of BUF_RD_PTR field.
	DAC_STATUS_BUF_RD_PTR_Msk = 0x700000
)

// Constants for CS: tsc
const (
	// CTRL0: CapSense control register 0
	// Position of ENABLE field.
	CS_CTRL0_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	CS_CTRL0_ENABLE_Msk = 0x1
	// Bit ENABLE.
	CS_CTRL0_ENABLE = 0x1
	// OSC work disable.
	CS_CTRL0_ENABLE_DISABLE = 0x0
	// OSC work enable.
	CS_CTRL0_ENABLE_ENABLE = 0x1
	// Position of SRST field.
	CS_CTRL0_SRST_Pos = 0x1
	// Bit mask of SRST field.
	CS_CTRL0_SRST_Msk = 0x2
	// Bit SRST.
	CS_CTRL0_SRST = 0x2
	// Position of OSC_FREQ field.
	CS_CTRL0_OSC_FREQ_Pos = 0x2
	// Bit mask of OSC_FREQ field.
	CS_CTRL0_OSC_FREQ_Msk = 0xfc
	// Position of CLK_DIV field.
	CS_CTRL0_CLK_DIV_Pos = 0x10
	// Bit mask of CLK_DIV field.
	CS_CTRL0_CLK_DIV_Msk = 0x1ff0000

	// CTRL1: CapSense control register 1
	// Position of PERIOD field.
	CS_CTRL1_PERIOD_Pos = 0x0
	// Bit mask of PERIOD field.
	CS_CTRL1_PERIOD_Msk = 0xffff
	// Position of CH field.
	CS_CTRL1_CH_Pos = 0x10
	// Bit mask of CH field.
	CS_CTRL1_CH_Msk = 0xff0000

	// INT: Interrupt status register
	// Position of FIFO_NOTEMPTY_INT field.
	CS_INT_FIFO_NOTEMPTY_INT_Pos = 0x0
	// Bit mask of FIFO_NOTEMPTY_INT field.
	CS_INT_FIFO_NOTEMPTY_INT_Msk = 0x1
	// Bit FIFO_NOTEMPTY_INT.
	CS_INT_FIFO_NOTEMPTY_INT = 0x1
	// Position of FIFO_HFULL_INT field.
	CS_INT_FIFO_HFULL_INT_Pos = 0x1
	// Bit mask of FIFO_HFULL_INT field.
	CS_INT_FIFO_HFULL_INT_Msk = 0x2
	// Bit FIFO_HFULL_INT.
	CS_INT_FIFO_HFULL_INT = 0x2
	// Position of FIFO_FULL_INT field.
	CS_INT_FIFO_FULL_INT_Pos = 0x2
	// Bit mask of FIFO_FULL_INT field.
	CS_INT_FIFO_FULL_INT_Msk = 0x4
	// Bit FIFO_FULL_INT.
	CS_INT_FIFO_FULL_INT = 0x4
	// Position of SCAN_INT field.
	CS_INT_SCAN_INT_Pos = 0x3
	// Bit mask of SCAN_INT field.
	CS_INT_SCAN_INT_Msk = 0x8
	// Bit SCAN_INT.
	CS_INT_SCAN_INT = 0x8

	// INTEN: Interrupt mask register
	// Position of FIFO_NOTEMPTY_INTEN field.
	CS_INTEN_FIFO_NOTEMPTY_INTEN_Pos = 0x0
	// Bit mask of FIFO_NOTEMPTY_INTEN field.
	CS_INTEN_FIFO_NOTEMPTY_INTEN_Msk = 0x1
	// Bit FIFO_NOTEMPTY_INTEN.
	CS_INTEN_FIFO_NOTEMPTY_INTEN = 0x1
	// Position of FIFO_HFULL_INTEN field.
	CS_INTEN_FIFO_HFULL_INTEN_Pos = 0x1
	// Bit mask of FIFO_HFULL_INTEN field.
	CS_INTEN_FIFO_HFULL_INTEN_Msk = 0x2
	// Bit FIFO_HFULL_INTEN.
	CS_INTEN_FIFO_HFULL_INTEN = 0x2
	// Position of FIFO_FULL_INTEN field.
	CS_INTEN_FIFO_FULL_INTEN_Pos = 0x2
	// Bit mask of FIFO_FULL_INTEN field.
	CS_INTEN_FIFO_FULL_INTEN_Msk = 0x4
	// Bit FIFO_FULL_INTEN.
	CS_INTEN_FIFO_FULL_INTEN = 0x4
	// Position of SCAN_INTEN field.
	CS_INTEN_SCAN_INTEN_Pos = 0x3
	// Bit mask of SCAN_INTEN field.
	CS_INTEN_SCAN_INTEN_Msk = 0x8
	// Bit SCAN_INTEN.
	CS_INTEN_SCAN_INTEN = 0x8

	// DATA: Output data register
	// Position of DATA field.
	CS_DATA_DATA_Pos = 0x0
	// Bit mask of DATA field.
	CS_DATA_DATA_Msk = 0x7ffff

	// LP_CTRL: Control register for low power mode
	// Position of DEBONCE_NUM field.
	CS_LP_CTRL_DEBONCE_NUM_Pos = 0x0
	// Bit mask of DEBONCE_NUM field.
	CS_LP_CTRL_DEBONCE_NUM_Msk = 0xf
	// Position of LP_EN field.
	CS_LP_CTRL_LP_EN_Pos = 0x4
	// Bit mask of LP_EN field.
	CS_LP_CTRL_LP_EN_Msk = 0x10
	// Bit LP_EN.
	CS_LP_CTRL_LP_EN = 0x10
	// Low power mode disable.
	CS_LP_CTRL_LP_EN_DISABLE = 0x0
	// Low power mode enable.
	CS_LP_CTRL_LP_EN_ENABLE = 0x1
	// Position of LP_CH field.
	CS_LP_CTRL_LP_CH_Pos = 0x5
	// Bit mask of LP_CH field.
	CS_LP_CTRL_LP_CH_Msk = 0xe0
	// Position of THR field.
	CS_LP_CTRL_THR_Pos = 0x10
	// Bit mask of THR field.
	CS_LP_CTRL_THR_Msk = 0xffff0000

	// LP_INT: Low power interrupt register
	// Position of LP_INT field.
	CS_LP_INT_LP_INT_Pos = 0x0
	// Bit mask of LP_INT field.
	CS_LP_INT_LP_INT_Msk = 0x1
	// Bit LP_INT.
	CS_LP_INT_LP_INT = 0x1

	// LP_INTEN: low power interrupt enable register
	// Position of LP_INTEN field.
	CS_LP_INTEN_LP_INTEN_Pos = 0x0
	// Bit mask of LP_INTEN field.
	CS_LP_INTEN_LP_INTEN_Msk = 0x1
	// Bit LP_INTEN.
	CS_LP_INTEN_LP_INTEN = 0x1

	// IDLE_PERIOD: Idle preiod number register
	// Position of IDLE_PERIOD field.
	CS_IDLE_PERIOD_IDLE_PERIOD_Pos = 0x0
	// Bit mask of IDLE_PERIOD field.
	CS_IDLE_PERIOD_IDLE_PERIOD_Msk = 0xffff
)

// Constants for RNG: rng
const (
	// CTRL: control register
	// Position of ENABLE field.
	RNG_CTRL_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	RNG_CTRL_ENABLE_Msk = 0x1
	// Bit ENABLE.
	RNG_CTRL_ENABLE = 0x1
	// Position of START field.
	RNG_CTRL_START_Pos = 0x1
	// Bit mask of START field.
	RNG_CTRL_START_Msk = 0x2
	// Bit START.
	RNG_CTRL_START = 0x2
	// Position of NUM field.
	RNG_CTRL_NUM_Pos = 0x4
	// Bit mask of NUM field.
	RNG_CTRL_NUM_Msk = 0x30

	// STAT: status register
	// Position of BUSY field.
	RNG_STAT_BUSY_Pos = 0x0
	// Bit mask of BUSY field.
	RNG_STAT_BUSY_Msk = 0x1
	// Bit BUSY.
	RNG_STAT_BUSY = 0x1

	// DATA: random data output register
	// Position of DATA field.
	RNG_DATA_DATA_Pos = 0x0
	// Bit mask of DATA field.
	RNG_DATA_DATA_Msk = 0xffffffff

	// INT: interrupt register
	// Position of DONE field.
	RNG_INT_DONE_Pos = 0x0
	// Bit mask of DONE field.
	RNG_INT_DONE_Msk = 0x1
	// Bit DONE.
	RNG_INT_DONE = 0x1

	// INTEN: interrupt mask register
	// Position of DONE_INTEN field.
	RNG_INTEN_DONE_INTEN_Pos = 0x0
	// Bit mask of DONE_INTEN field.
	RNG_INTEN_DONE_INTEN_Msk = 0x1
	// Bit DONE_INTEN.
	RNG_INTEN_DONE_INTEN = 0x1
)

// Constants for QDEC0: qdec
const (
	// CTRL: control register
	// Position of QDEC_EN field.
	QDEC_CTRL_QDEC_EN_Pos = 0x0
	// Bit mask of QDEC_EN field.
	QDEC_CTRL_QDEC_EN_Msk = 0x1
	// Bit QDEC_EN.
	QDEC_CTRL_QDEC_EN = 0x1
	// Position of START field.
	QDEC_CTRL_START_Pos = 0x1
	// Bit mask of START field.
	QDEC_CTRL_START_Msk = 0x2
	// Bit START.
	QDEC_CTRL_START = 0x2
	// Position of STOP field.
	QDEC_CTRL_STOP_Pos = 0x2
	// Bit mask of STOP field.
	QDEC_CTRL_STOP_Msk = 0x4
	// Bit STOP.
	QDEC_CTRL_STOP = 0x4
	// Position of SOFT_CLR field.
	QDEC_CTRL_SOFT_CLR_Pos = 0x3
	// Bit mask of SOFT_CLR field.
	QDEC_CTRL_SOFT_CLR_Msk = 0x8
	// Bit SOFT_CLR.
	QDEC_CTRL_SOFT_CLR = 0x8
	// Position of AUTO_CLR_EN field.
	QDEC_CTRL_AUTO_CLR_EN_Pos = 0x4
	// Bit mask of AUTO_CLR_EN field.
	QDEC_CTRL_AUTO_CLR_EN_Msk = 0x10
	// Bit AUTO_CLR_EN.
	QDEC_CTRL_AUTO_CLR_EN = 0x10
	// Position of SINGLE_SAMPLE_SRST_EN field.
	QDEC_CTRL_SINGLE_SAMPLE_SRST_EN_Pos = 0x5
	// Bit mask of SINGLE_SAMPLE_SRST_EN field.
	QDEC_CTRL_SINGLE_SAMPLE_SRST_EN_Msk = 0x20
	// Bit SINGLE_SAMPLE_SRST_EN.
	QDEC_CTRL_SINGLE_SAMPLE_SRST_EN = 0x20
	// Position of DB_FILTER_EN field.
	QDEC_CTRL_DB_FILTER_EN_Pos = 0x6
	// Bit mask of DB_FILTER_EN field.
	QDEC_CTRL_DB_FILTER_EN_Msk = 0x40
	// Bit DB_FILTER_EN.
	QDEC_CTRL_DB_FILTER_EN = 0x40

	// SAMP_CTRL: QDEC sample settting register
	// Position of DIVIDE field.
	QDEC_SAMP_CTRL_DIVIDE_Pos = 0x0
	// Bit mask of DIVIDE field.
	QDEC_SAMP_CTRL_DIVIDE_Msk = 0x1f
	// Position of PTS field.
	QDEC_SAMP_CTRL_PTS_Pos = 0x8
	// Bit mask of PTS field.
	QDEC_SAMP_CTRL_PTS_Msk = 0xf00
	// 5 points
	QDEC_SAMP_CTRL_PTS_PTS0 = 0x0
	// 10 points
	QDEC_SAMP_CTRL_PTS_PTS1 = 0x1
	// 40 points
	QDEC_SAMP_CTRL_PTS_PTS2 = 0x2
	// 80 points
	QDEC_SAMP_CTRL_PTS_PTS3 = 0x3
	// 120 points
	QDEC_SAMP_CTRL_PTS_PTS4 = 0x4
	// 160 points
	QDEC_SAMP_CTRL_PTS_PTS5 = 0x5
	// 200 points
	QDEC_SAMP_CTRL_PTS_PTS6 = 0x6
	// 240 points
	QDEC_SAMP_CTRL_PTS_PTS7 = 0x7
	// 280 points
	QDEC_SAMP_CTRL_PTS_PTS8 = 0x8
	// 320 points
	QDEC_SAMP_CTRL_PTS_PTS9 = 0x9
	// 360 points
	QDEC_SAMP_CTRL_PTS_PTS10 = 0xa
	// 400 points
	QDEC_SAMP_CTRL_PTS_PTS11 = 0xb
	// Position of DB_SAMP_DIV field.
	QDEC_SAMP_CTRL_DB_SAMP_DIV_Pos = 0x10
	// Bit mask of DB_SAMP_DIV field.
	QDEC_SAMP_CTRL_DB_SAMP_DIV_Msk = 0xf0000

	// SAMPLE: QDEC sample result register
	// Position of SAMPLE field.
	QDEC_SAMPLE_SAMPLE_Pos = 0x0
	// Bit mask of SAMPLE field.
	QDEC_SAMPLE_SAMPLE_Msk = 0x3

	// ACC: QDEC accumulate register
	// Position of ACC field.
	QDEC_ACC_ACC_Pos = 0x0
	// Bit mask of ACC field.
	QDEC_ACC_ACC_Msk = 0x7ff

	// ACC_R: QDEC accumulate snapshot register
	// Position of ACC_R field.
	QDEC_ACC_R_ACC_R_Pos = 0x0
	// Bit mask of ACC_R field.
	QDEC_ACC_R_ACC_R_Msk = 0x7ff

	// DB: double sample register
	// Position of DB field.
	QDEC_DB_DB_Pos = 0x0
	// Bit mask of DB field.
	QDEC_DB_DB_Msk = 0xf

	// DB_R: DB snapshot register
	// Position of DB_R field.
	QDEC_DB_R_DB_R_Pos = 0x0
	// Bit mask of DB_R field.
	QDEC_DB_R_DB_R_Msk = 0xf

	// INT: interrupt register
	// Position of SINGLE_SAMPLE field.
	QDEC_INT_SINGLE_SAMPLE_Pos = 0x0
	// Bit mask of SINGLE_SAMPLE field.
	QDEC_INT_SINGLE_SAMPLE_Msk = 0x1
	// Bit SINGLE_SAMPLE.
	QDEC_INT_SINGLE_SAMPLE = 0x1
	// Position of SAMPLE_END field.
	QDEC_INT_SAMPLE_END_Pos = 0x1
	// Bit mask of SAMPLE_END field.
	QDEC_INT_SAMPLE_END_Msk = 0x2
	// Bit SAMPLE_END.
	QDEC_INT_SAMPLE_END = 0x2
	// Position of ACC_OF field.
	QDEC_INT_ACC_OF_Pos = 0x2
	// Bit mask of ACC_OF field.
	QDEC_INT_ACC_OF_Msk = 0x4
	// Bit ACC_OF.
	QDEC_INT_ACC_OF = 0x4
	// Position of DB_OF field.
	QDEC_INT_DB_OF_Pos = 0x3
	// Bit mask of DB_OF field.
	QDEC_INT_DB_OF_Msk = 0x8
	// Bit DB_OF.
	QDEC_INT_DB_OF = 0x8

	// INTEN: interrupt mask register
	// Position of SINGLE_SAMPLE_INTEN field.
	QDEC_INTEN_SINGLE_SAMPLE_INTEN_Pos = 0x0
	// Bit mask of SINGLE_SAMPLE_INTEN field.
	QDEC_INTEN_SINGLE_SAMPLE_INTEN_Msk = 0x1
	// Bit SINGLE_SAMPLE_INTEN.
	QDEC_INTEN_SINGLE_SAMPLE_INTEN = 0x1
	// Position of SAMPLE_END_INTEN field.
	QDEC_INTEN_SAMPLE_END_INTEN_Pos = 0x1
	// Bit mask of SAMPLE_END_INTEN field.
	QDEC_INTEN_SAMPLE_END_INTEN_Msk = 0x2
	// Bit SAMPLE_END_INTEN.
	QDEC_INTEN_SAMPLE_END_INTEN = 0x2
	// Position of ACC_OF_INTEN field.
	QDEC_INTEN_ACC_OF_INTEN_Pos = 0x2
	// Bit mask of ACC_OF_INTEN field.
	QDEC_INTEN_ACC_OF_INTEN_Msk = 0x4
	// Bit ACC_OF_INTEN.
	QDEC_INTEN_ACC_OF_INTEN = 0x4
	// Position of DB_OF_INTEN field.
	QDEC_INTEN_DB_OF_INTEN_Pos = 0x3
	// Bit mask of DB_OF_INTEN field.
	QDEC_INTEN_DB_OF_INTEN_Msk = 0x8
	// Bit DB_OF_INTEN.
	QDEC_INTEN_DB_OF_INTEN = 0x8

	// STAT: QDEC is running
	// Position of BUSY field.
	QDEC_STAT_BUSY_Pos = 0x0
	// Bit mask of BUSY field.
	QDEC_STAT_BUSY_Msk = 0x1
	// Bit BUSY.
	QDEC_STAT_BUSY = 0x1
)

// Constants for RTC: rtc
const (
	// CTRL: RTC control register
	// Position of SEC_INT_EN field.
	RTC_CTRL_SEC_INT_EN_Pos = 0x0
	// Bit mask of SEC_INT_EN field.
	RTC_CTRL_SEC_INT_EN_Msk = 0x1
	// Bit SEC_INT_EN.
	RTC_CTRL_SEC_INT_EN = 0x1
	// Position of CFG field.
	RTC_CTRL_CFG_Pos = 0x2
	// Bit mask of CFG field.
	RTC_CTRL_CFG_Msk = 0x4
	// Bit CFG.
	RTC_CTRL_CFG = 0x4
	// Position of CAL_EN field.
	RTC_CTRL_CAL_EN_Pos = 0x8
	// Bit mask of CAL_EN field.
	RTC_CTRL_CAL_EN_Msk = 0x100
	// Bit CAL_EN.
	RTC_CTRL_CAL_EN = 0x100

	// STATUS: RTC status register
	// Position of SEC_INT field.
	RTC_STATUS_SEC_INT_Pos = 0x0
	// Bit mask of SEC_INT field.
	RTC_STATUS_SEC_INT_Msk = 0x1
	// Bit SEC_INT.
	RTC_STATUS_SEC_INT = 0x1
	// Position of CTRL_SYNC field.
	RTC_STATUS_CTRL_SYNC_Pos = 0x8
	// Bit mask of CTRL_SYNC field.
	RTC_STATUS_CTRL_SYNC_Msk = 0x100
	// Bit CTRL_SYNC.
	RTC_STATUS_CTRL_SYNC = 0x100
	// Position of STATUS_SYNC field.
	RTC_STATUS_STATUS_SYNC_Pos = 0x9
	// Bit mask of STATUS_SYNC field.
	RTC_STATUS_STATUS_SYNC_Msk = 0x200
	// Bit STATUS_SYNC.
	RTC_STATUS_STATUS_SYNC = 0x200
	// Position of SEC_SYNC field.
	RTC_STATUS_SEC_SYNC_Pos = 0xa
	// Bit mask of SEC_SYNC field.
	RTC_STATUS_SEC_SYNC_Msk = 0x400
	// Bit SEC_SYNC.
	RTC_STATUS_SEC_SYNC = 0x400
	// Position of CALIB_SYNC field.
	RTC_STATUS_CALIB_SYNC_Pos = 0xc
	// Bit mask of CALIB_SYNC field.
	RTC_STATUS_CALIB_SYNC_Msk = 0x1000
	// Bit CALIB_SYNC.
	RTC_STATUS_CALIB_SYNC = 0x1000
	// Position of FREE_SYNC field.
	RTC_STATUS_FREE_SYNC_Pos = 0x10
	// Bit mask of FREE_SYNC field.
	RTC_STATUS_FREE_SYNC_Msk = 0x10000
	// Bit FREE_SYNC.
	RTC_STATUS_FREE_SYNC = 0x10000
	// Position of THR_INT_SYNC field.
	RTC_STATUS_THR_INT_SYNC_Pos = 0x11
	// Bit mask of THR_INT_SYNC field.
	RTC_STATUS_THR_INT_SYNC_Msk = 0x20000
	// Bit THR_INT_SYNC.
	RTC_STATUS_THR_INT_SYNC = 0x20000
	// Position of THR_RST_SYNC field.
	RTC_STATUS_THR_RST_SYNC_Pos = 0x12
	// Bit mask of THR_RST_SYNC field.
	RTC_STATUS_THR_RST_SYNC_Msk = 0x40000
	// Bit THR_RST_SYNC.
	RTC_STATUS_THR_RST_SYNC = 0x40000
	// Position of FREE_RUNNING_INT field.
	RTC_STATUS_FREE_RUNNING_INT_Pos = 0x1f
	// Bit mask of FREE_RUNNING_INT field.
	RTC_STATUS_FREE_RUNNING_INT_Msk = 0x80000000
	// Bit FREE_RUNNING_INT.
	RTC_STATUS_FREE_RUNNING_INT = 0x80000000

	// SEC: RTC second register
	// Position of SEC field.
	RTC_SEC_SEC_Pos = 0x0
	// Bit mask of SEC field.
	RTC_SEC_SEC_Msk = 0xffffffff

	// CAL: RTC calibration register
	// Position of PPM field.
	RTC_CAL_PPM_Pos = 0x0
	// Bit mask of PPM field.
	RTC_CAL_PPM_Msk = 0xffff
	// Position of DIR field.
	RTC_CAL_DIR_Pos = 0x10
	// Bit mask of DIR field.
	RTC_CAL_DIR_Msk = 0x10000
	// Bit DIR.
	RTC_CAL_DIR = 0x10000
	// forward calibrate
	RTC_CAL_DIR_FORWARD = 0x0
	// backward calibrate
	RTC_CAL_DIR_BACKWARD = 0x1

	// CNT_VAL: RTC count value register
	// Position of CNT field.
	RTC_CNT_VAL_CNT_Pos = 0x0
	// Bit mask of CNT field.
	RTC_CNT_VAL_CNT_Msk = 0x7fff

	// CNT2_CTRL: Free running control register
	// Position of CNT2_EN field.
	RTC_CNT2_CTRL_CNT2_EN_Pos = 0x0
	// Bit mask of CNT2_EN field.
	RTC_CNT2_CTRL_CNT2_EN_Msk = 0x1
	// Bit CNT2_EN.
	RTC_CNT2_CTRL_CNT2_EN = 0x1
	// Position of CNT2_INT_EN field.
	RTC_CNT2_CTRL_CNT2_INT_EN_Pos = 0x1
	// Bit mask of CNT2_INT_EN field.
	RTC_CNT2_CTRL_CNT2_INT_EN_Msk = 0x2
	// Bit CNT2_INT_EN.
	RTC_CNT2_CTRL_CNT2_INT_EN = 0x2
	// Position of CNT2_WAKEUP field.
	RTC_CNT2_CTRL_CNT2_WAKEUP_Pos = 0x2
	// Bit mask of CNT2_WAKEUP field.
	RTC_CNT2_CTRL_CNT2_WAKEUP_Msk = 0x4
	// Bit CNT2_WAKEUP.
	RTC_CNT2_CTRL_CNT2_WAKEUP = 0x4
	// Position of CNT2_RST field.
	RTC_CNT2_CTRL_CNT2_RST_Pos = 0x3
	// Bit mask of CNT2_RST field.
	RTC_CNT2_CTRL_CNT2_RST_Msk = 0x8
	// Bit CNT2_RST.
	RTC_CNT2_CTRL_CNT2_RST = 0x8

	// THR_INT: interrupt threshold of free running counter register
	// Position of THR_INT field.
	RTC_THR_INT_THR_INT_Pos = 0x0
	// Bit mask of THR_INT field.
	RTC_THR_INT_THR_INT_Msk = 0xffffffff

	// THR_RST: reset threshold of free running counter register
	// Position of THR_RST field.
	RTC_THR_RST_THR_RST_Pos = 0x0
	// Bit mask of THR_RST field.
	RTC_THR_RST_THR_RST_Msk = 0xffffffff

	// CNT2: free running count value
	// Position of CNT2 field.
	RTC_CNT2_CNT2_Pos = 0x0
	// Bit mask of CNT2 field.
	RTC_CNT2_CNT2_Msk = 0xffffffff
)

// Constants for AGC: agc
const (
	// CTRL0: AGC control register 0
	// Position of PPF_INTRPT_MOD field.
	AGC_CTRL0_PPF_INTRPT_MOD_Pos = 0x0
	// Bit mask of PPF_INTRPT_MOD field.
	AGC_CTRL0_PPF_INTRPT_MOD_Msk = 0x3
	// Position of FREZ_MOD field.
	AGC_CTRL0_FREZ_MOD_Pos = 0x2
	// Bit mask of FREZ_MOD field.
	AGC_CTRL0_FREZ_MOD_Msk = 0xc
	// Position of RRF_GAIN_SEL field.
	AGC_CTRL0_RRF_GAIN_SEL_Pos = 0x4
	// Bit mask of RRF_GAIN_SEL field.
	AGC_CTRL0_RRF_GAIN_SEL_Msk = 0x70
	// Position of RRF_WEN field.
	AGC_CTRL0_RRF_WEN_Pos = 0x7
	// Bit mask of RRF_WEN field.
	AGC_CTRL0_RRF_WEN_Msk = 0x80
	// Bit RRF_WEN.
	AGC_CTRL0_RRF_WEN = 0x80
	// Position of PPF_GAIN field.
	AGC_CTRL0_PPF_GAIN_Pos = 0x8
	// Bit mask of PPF_GAIN field.
	AGC_CTRL0_PPF_GAIN_Msk = 0xf00
	// Position of PPF_WEN field.
	AGC_CTRL0_PPF_WEN_Pos = 0xc
	// Bit mask of PPF_WEN field.
	AGC_CTRL0_PPF_WEN_Msk = 0x1000
	// Bit PPF_WEN.
	AGC_CTRL0_PPF_WEN = 0x1000
	// Position of PKWT_TH_DIG_1 field.
	AGC_CTRL0_PKWT_TH_DIG_1_Pos = 0xd
	// Bit mask of PKWT_TH_DIG_1 field.
	AGC_CTRL0_PKWT_TH_DIG_1_Msk = 0x3e000
	// Position of PD_CLR_EN field.
	AGC_CTRL0_PD_CLR_EN_Pos = 0x12
	// Bit mask of PD_CLR_EN field.
	AGC_CTRL0_PD_CLR_EN_Msk = 0x40000
	// Bit PD_CLR_EN.
	AGC_CTRL0_PD_CLR_EN = 0x40000
	// Position of PD_RST_LEN field.
	AGC_CTRL0_PD_RST_LEN_Pos = 0x13
	// Bit mask of PD_RST_LEN field.
	AGC_CTRL0_PD_RST_LEN_Msk = 0x380000
	// Position of RFAGC_FSYNC_DET_DIS field.
	AGC_CTRL0_RFAGC_FSYNC_DET_DIS_Pos = 0x16
	// Bit mask of RFAGC_FSYNC_DET_DIS field.
	AGC_CTRL0_RFAGC_FSYNC_DET_DIS_Msk = 0x400000
	// Bit RFAGC_FSYNC_DET_DIS.
	AGC_CTRL0_RFAGC_FSYNC_DET_DIS = 0x400000
	// Position of RFAGC_DIRECTION_FREEZE field.
	AGC_CTRL0_RFAGC_DIRECTION_FREEZE_Pos = 0x17
	// Bit mask of RFAGC_DIRECTION_FREEZE field.
	AGC_CTRL0_RFAGC_DIRECTION_FREEZE_Msk = 0x800000
	// Bit RFAGC_DIRECTION_FREEZE.
	AGC_CTRL0_RFAGC_DIRECTION_FREEZE = 0x800000
	// Position of DOWN_24_EN field.
	AGC_CTRL0_DOWN_24_EN_Pos = 0x18
	// Bit mask of DOWN_24_EN field.
	AGC_CTRL0_DOWN_24_EN_Msk = 0x1000000
	// Bit DOWN_24_EN.
	AGC_CTRL0_DOWN_24_EN = 0x1000000
	// Position of SWITCH_PD_RST_LEN field.
	AGC_CTRL0_SWITCH_PD_RST_LEN_Pos = 0x19
	// Bit mask of SWITCH_PD_RST_LEN field.
	AGC_CTRL0_SWITCH_PD_RST_LEN_Msk = 0x6000000
	// Position of GLNA_MAX_REDU field.
	AGC_CTRL0_GLNA_MAX_REDU_Pos = 0x1b
	// Bit mask of GLNA_MAX_REDU field.
	AGC_CTRL0_GLNA_MAX_REDU_Msk = 0x8000000
	// Bit GLNA_MAX_REDU.
	AGC_CTRL0_GLNA_MAX_REDU = 0x8000000

	// CTRL1: AGC control register 1
	// Position of PD3_TH_REG field.
	AGC_CTRL1_PD3_TH_REG_Pos = 0x0
	// Bit mask of PD3_TH_REG field.
	AGC_CTRL1_PD3_TH_REG_Msk = 0x7
	// Position of PD3_TH_HYST_REG field.
	AGC_CTRL1_PD3_TH_HYST_REG_Pos = 0x3
	// Bit mask of PD3_TH_HYST_REG field.
	AGC_CTRL1_PD3_TH_HYST_REG_Msk = 0x78
	// Position of PKWT_TH_ANA_1 field.
	AGC_CTRL1_PKWT_TH_ANA_1_Pos = 0x7
	// Bit mask of PKWT_TH_ANA_1 field.
	AGC_CTRL1_PKWT_TH_ANA_1_Msk = 0x1f80
	// Position of PKWT_TH_ANA_0 field.
	AGC_CTRL1_PKWT_TH_ANA_0_Pos = 0xd
	// Bit mask of PKWT_TH_ANA_0 field.
	AGC_CTRL1_PKWT_TH_ANA_0_Msk = 0x3e000
	// Position of PKWT_TH_DIG_0 field.
	AGC_CTRL1_PKWT_TH_DIG_0_Pos = 0x12
	// Bit mask of PKWT_TH_DIG_0 field.
	AGC_CTRL1_PKWT_TH_DIG_0_Msk = 0x7c0000
	// Position of SETL_TH_PPF_2 field.
	AGC_CTRL1_SETL_TH_PPF_2_Pos = 0x17
	// Bit mask of SETL_TH_PPF_2 field.
	AGC_CTRL1_SETL_TH_PPF_2_Msk = 0xf800000

	// CTRL2: AGC control register 2
	// Position of PPF_PDVTH_LOW field.
	AGC_CTRL2_PPF_PDVTH_LOW_Pos = 0x8
	// Bit mask of PPF_PDVTH_LOW field.
	AGC_CTRL2_PPF_PDVTH_LOW_Msk = 0x100
	// Bit PPF_PDVTH_LOW.
	AGC_CTRL2_PPF_PDVTH_LOW = 0x100
	// Position of RRF_MG_PK field.
	AGC_CTRL2_RRF_MG_PK_Pos = 0x9
	// Bit mask of RRF_MG_PK field.
	AGC_CTRL2_RRF_MG_PK_Msk = 0xe00
	// Position of RRF_HG_PK field.
	AGC_CTRL2_RRF_HG_PK_Pos = 0xc
	// Bit mask of RRF_HG_PK field.
	AGC_CTRL2_RRF_HG_PK_Msk = 0x7000

	// CTRL3: AGC control register 3
	// Position of GF2_PAR00 field.
	AGC_CTRL3_GF2_PAR00_Pos = 0x0
	// Bit mask of GF2_PAR00 field.
	AGC_CTRL3_GF2_PAR00_Msk = 0xf
	// Position of GF2_PAR01 field.
	AGC_CTRL3_GF2_PAR01_Pos = 0x4
	// Bit mask of GF2_PAR01 field.
	AGC_CTRL3_GF2_PAR01_Msk = 0xf0
	// Position of GF2_PAR10 field.
	AGC_CTRL3_GF2_PAR10_Pos = 0x8
	// Bit mask of GF2_PAR10 field.
	AGC_CTRL3_GF2_PAR10_Msk = 0xf00
	// Position of SETL_TH_OVSHT_DIG field.
	AGC_CTRL3_SETL_TH_OVSHT_DIG_Pos = 0xc
	// Bit mask of SETL_TH_OVSHT_DIG field.
	AGC_CTRL3_SETL_TH_OVSHT_DIG_Msk = 0x7000
	// Position of SETL_TH_OVSHT_INTRPT field.
	AGC_CTRL3_SETL_TH_OVSHT_INTRPT_Pos = 0xf
	// Bit mask of SETL_TH_OVSHT_INTRPT field.
	AGC_CTRL3_SETL_TH_OVSHT_INTRPT_Msk = 0x38000
	// Position of SETL_TH_OVSHT field.
	AGC_CTRL3_SETL_TH_OVSHT_Pos = 0x12
	// Bit mask of SETL_TH_OVSHT field.
	AGC_CTRL3_SETL_TH_OVSHT_Msk = 0x1c0000

	// CTRL4: AGC control register 4
	// Position of SETL_TH_PD1 field.
	AGC_CTRL4_SETL_TH_PD1_Pos = 0x0
	// Bit mask of SETL_TH_PD1 field.
	AGC_CTRL4_SETL_TH_PD1_Msk = 0xf
	// Position of SETL_TH_PD2 field.
	AGC_CTRL4_SETL_TH_PD2_Pos = 0x4
	// Bit mask of SETL_TH_PD2 field.
	AGC_CTRL4_SETL_TH_PD2_Msk = 0xf0
	// Position of SETL_TH_PD3_1 field.
	AGC_CTRL4_SETL_TH_PD3_1_Pos = 0x8
	// Bit mask of SETL_TH_PD3_1 field.
	AGC_CTRL4_SETL_TH_PD3_1_Msk = 0x3f00
	// Position of SETL_TH_PD3_2 field.
	AGC_CTRL4_SETL_TH_PD3_2_Pos = 0xe
	// Bit mask of SETL_TH_PD3_2 field.
	AGC_CTRL4_SETL_TH_PD3_2_Msk = 0xfc000
	// Position of GF2_STAT24_TH field.
	AGC_CTRL4_GF2_STAT24_TH_Pos = 0x14
	// Bit mask of GF2_STAT24_TH field.
	AGC_CTRL4_GF2_STAT24_TH_Msk = 0xf00000

	// CTRL5: AGC control register 5
	// Position of TEST_CTRL field.
	AGC_CTRL5_TEST_CTRL_Pos = 0x0
	// Bit mask of TEST_CTRL field.
	AGC_CTRL5_TEST_CTRL_Msk = 0xf

	// STAT: AGC status register
	// Position of GLNA_CODE_OUT field.
	AGC_STAT_GLNA_CODE_OUT_Pos = 0x0
	// Bit mask of GLNA_CODE_OUT field.
	AGC_STAT_GLNA_CODE_OUT_Msk = 0x7
	// Position of GF2_CODE_OUT field.
	AGC_STAT_GF2_CODE_OUT_Pos = 0x3
	// Bit mask of GF2_CODE_OUT field.
	AGC_STAT_GF2_CODE_OUT_Msk = 0x78
	// Position of RFAGC_TRIGGER_O field.
	AGC_STAT_RFAGC_TRIGGER_O_Pos = 0x7
	// Bit mask of RFAGC_TRIGGER_O field.
	AGC_STAT_RFAGC_TRIGGER_O_Msk = 0x80
	// Bit RFAGC_TRIGGER_O.
	AGC_STAT_RFAGC_TRIGGER_O = 0x80
	// Position of RF_GAIN field.
	AGC_STAT_RF_GAIN_Pos = 0x8
	// Bit mask of RF_GAIN field.
	AGC_STAT_RF_GAIN_Msk = 0x7f00
	// Position of NUM_GAIN_ADJ field.
	AGC_STAT_NUM_GAIN_ADJ_Pos = 0xf
	// Bit mask of NUM_GAIN_ADJ field.
	AGC_STAT_NUM_GAIN_ADJ_Msk = 0xf8000
	// Position of CUR_STAT field.
	AGC_STAT_CUR_STAT_Pos = 0x14
	// Bit mask of CUR_STAT field.
	AGC_STAT_CUR_STAT_Msk = 0x700000
)

// Constants for PROP: prop
const (
	// TX_BUF: transmit data buffer input port register
	// Position of TX_BUF field.
	PROP_TX_BUF_TX_BUF_Pos = 0x0
	// Bit mask of TX_BUF field.
	PROP_TX_BUF_TX_BUF_Msk = 0xff

	// RX_BUF: received data buffer output register
	// Position of RX_BUF field.
	PROP_RX_BUF_RX_BUF_Pos = 0x0
	// Bit mask of RX_BUF field.
	PROP_RX_BUF_RX_BUF_Msk = 0xff

	// STAT: status register
	// Position of BIT_ORDER field.
	PROP_STAT_BIT_ORDER_Pos = 0x0
	// Bit mask of BIT_ORDER field.
	PROP_STAT_BIT_ORDER_Msk = 0x1
	// Bit BIT_ORDER.
	PROP_STAT_BIT_ORDER = 0x1
	// Position of TX_INTEN field.
	PROP_STAT_TX_INTEN_Pos = 0x1
	// Bit mask of TX_INTEN field.
	PROP_STAT_TX_INTEN_Msk = 0x2
	// Bit TX_INTEN.
	PROP_STAT_TX_INTEN = 0x2
	// Position of RX_INTEN field.
	PROP_STAT_RX_INTEN_Pos = 0x2
	// Bit mask of RX_INTEN field.
	PROP_STAT_RX_INTEN_Msk = 0x4
	// Bit RX_INTEN.
	PROP_STAT_RX_INTEN = 0x4
	// Position of RX_INT field.
	PROP_STAT_RX_INT_Pos = 0x3
	// Bit mask of RX_INT field.
	PROP_STAT_RX_INT_Msk = 0x8
	// Bit RX_INT.
	PROP_STAT_RX_INT = 0x8
	// Position of TX_INT field.
	PROP_STAT_TX_INT_Pos = 0x4
	// Bit mask of TX_INT field.
	PROP_STAT_TX_INT_Msk = 0x10
	// Bit TX_INT.
	PROP_STAT_TX_INT = 0x10
	// Position of RX_BUSY field.
	PROP_STAT_RX_BUSY_Pos = 0x5
	// Bit mask of RX_BUSY field.
	PROP_STAT_RX_BUSY_Msk = 0x20
	// Bit RX_BUSY.
	PROP_STAT_RX_BUSY = 0x20
	// Position of TX_BUSY field.
	PROP_STAT_TX_BUSY_Pos = 0x6
	// Bit mask of TX_BUSY field.
	PROP_STAT_TX_BUSY_Msk = 0x40
	// Bit TX_BUSY.
	PROP_STAT_TX_BUSY = 0x40
	// Position of CLR field.
	PROP_STAT_CLR_Pos = 0x7
	// Bit mask of CLR field.
	PROP_STAT_CLR_Msk = 0x80
	// Bit CLR.
	PROP_STAT_CLR = 0x80
)

// Constants for BLEDP: bledp
const (
	// DP_TOP_SYSTEM_CTRL: datapath system control register
	// Position of RX_PDU_LEN_IN field.
	BLEDP_DP_TOP_SYSTEM_CTRL_RX_PDU_LEN_IN_Pos = 0x0
	// Bit mask of RX_PDU_LEN_IN field.
	BLEDP_DP_TOP_SYSTEM_CTRL_RX_PDU_LEN_IN_Msk = 0x3fff
	// Position of AA_SEL field.
	BLEDP_DP_TOP_SYSTEM_CTRL_AA_SEL_Pos = 0xe
	// Bit mask of AA_SEL field.
	BLEDP_DP_TOP_SYSTEM_CTRL_AA_SEL_Msk = 0x4000
	// Bit AA_SEL.
	BLEDP_DP_TOP_SYSTEM_CTRL_AA_SEL = 0x4000
	// Position of PDU_LEN_SEL field.
	BLEDP_DP_TOP_SYSTEM_CTRL_PDU_LEN_SEL_Pos = 0xf
	// Bit mask of PDU_LEN_SEL field.
	BLEDP_DP_TOP_SYSTEM_CTRL_PDU_LEN_SEL_Msk = 0x8000
	// Bit PDU_LEN_SEL.
	BLEDP_DP_TOP_SYSTEM_CTRL_PDU_LEN_SEL = 0x8000
	// Position of H_IDX field.
	BLEDP_DP_TOP_SYSTEM_CTRL_H_IDX_Pos = 0x10
	// Bit mask of H_IDX field.
	BLEDP_DP_TOP_SYSTEM_CTRL_H_IDX_Msk = 0xff0000
	// Position of RX_EN_SEL field.
	BLEDP_DP_TOP_SYSTEM_CTRL_RX_EN_SEL_Pos = 0x18
	// Bit mask of RX_EN_SEL field.
	BLEDP_DP_TOP_SYSTEM_CTRL_RX_EN_SEL_Msk = 0x1000000
	// Bit RX_EN_SEL.
	BLEDP_DP_TOP_SYSTEM_CTRL_RX_EN_SEL = 0x1000000
	// Position of TX_EN_SEL field.
	BLEDP_DP_TOP_SYSTEM_CTRL_TX_EN_SEL_Pos = 0x19
	// Bit mask of TX_EN_SEL field.
	BLEDP_DP_TOP_SYSTEM_CTRL_TX_EN_SEL_Msk = 0x2000000
	// Bit TX_EN_SEL.
	BLEDP_DP_TOP_SYSTEM_CTRL_TX_EN_SEL = 0x2000000
	// Position of RX_REQ field.
	BLEDP_DP_TOP_SYSTEM_CTRL_RX_REQ_Pos = 0x1a
	// Bit mask of RX_REQ field.
	BLEDP_DP_TOP_SYSTEM_CTRL_RX_REQ_Msk = 0x4000000
	// Bit RX_REQ.
	BLEDP_DP_TOP_SYSTEM_CTRL_RX_REQ = 0x4000000
	// Position of TX_REQ field.
	BLEDP_DP_TOP_SYSTEM_CTRL_TX_REQ_Pos = 0x1b
	// Bit mask of TX_REQ field.
	BLEDP_DP_TOP_SYSTEM_CTRL_TX_REQ_Msk = 0x8000000
	// Bit TX_REQ.
	BLEDP_DP_TOP_SYSTEM_CTRL_TX_REQ = 0x8000000
	// Position of RX_MODE field.
	BLEDP_DP_TOP_SYSTEM_CTRL_RX_MODE_Pos = 0x1c
	// Bit mask of RX_MODE field.
	BLEDP_DP_TOP_SYSTEM_CTRL_RX_MODE_Msk = 0x30000000
	// Position of ANT_DATA_START field.
	BLEDP_DP_TOP_SYSTEM_CTRL_ANT_DATA_START_Pos = 0x1e
	// Bit mask of ANT_DATA_START field.
	BLEDP_DP_TOP_SYSTEM_CTRL_ANT_DATA_START_Msk = 0x40000000
	// Bit ANT_DATA_START.
	BLEDP_DP_TOP_SYSTEM_CTRL_ANT_DATA_START = 0x40000000
	// Position of DET_MODE field.
	BLEDP_DP_TOP_SYSTEM_CTRL_DET_MODE_Pos = 0x1f
	// Bit mask of DET_MODE field.
	BLEDP_DP_TOP_SYSTEM_CTRL_DET_MODE_Msk = 0x80000000
	// Bit DET_MODE.
	BLEDP_DP_TOP_SYSTEM_CTRL_DET_MODE = 0x80000000

	// PROP_MODE_CTRL: properity mode control register
	// Position of PROP_AA_ADDR_IN field.
	BLEDP_PROP_MODE_CTRL_PROP_AA_ADDR_IN_Pos = 0x0
	// Bit mask of PROP_AA_ADDR_IN field.
	BLEDP_PROP_MODE_CTRL_PROP_AA_ADDR_IN_Msk = 0xff
	// Position of PROP_CRC_NUM field.
	BLEDP_PROP_MODE_CTRL_PROP_CRC_NUM_Pos = 0x8
	// Bit mask of PROP_CRC_NUM field.
	BLEDP_PROP_MODE_CTRL_PROP_CRC_NUM_Msk = 0x300
	// Position of PROP_AA_NUM field.
	BLEDP_PROP_MODE_CTRL_PROP_AA_NUM_Pos = 0xc
	// Bit mask of PROP_AA_NUM field.
	BLEDP_PROP_MODE_CTRL_PROP_AA_NUM_Msk = 0x3000
	// Position of PROP_PRE_NUM field.
	BLEDP_PROP_MODE_CTRL_PROP_PRE_NUM_Pos = 0x10
	// Bit mask of PROP_PRE_NUM field.
	BLEDP_PROP_MODE_CTRL_PROP_PRE_NUM_Msk = 0x70000
	// Position of PROP_DATA_RATE field.
	BLEDP_PROP_MODE_CTRL_PROP_DATA_RATE_Pos = 0x14
	// Bit mask of PROP_DATA_RATE field.
	BLEDP_PROP_MODE_CTRL_PROP_DATA_RATE_Msk = 0x300000
	// Position of PROP_DIRECTION_RATE field.
	BLEDP_PROP_MODE_CTRL_PROP_DIRECTION_RATE_Pos = 0x16
	// Bit mask of PROP_DIRECTION_RATE field.
	BLEDP_PROP_MODE_CTRL_PROP_DIRECTION_RATE_Msk = 0xc00000
	// Position of PROP_DIRECTION_MODE field.
	BLEDP_PROP_MODE_CTRL_PROP_DIRECTION_MODE_Pos = 0x18
	// Bit mask of PROP_DIRECTION_MODE field.
	BLEDP_PROP_MODE_CTRL_PROP_DIRECTION_MODE_Msk = 0x1000000
	// Bit PROP_DIRECTION_MODE.
	BLEDP_PROP_MODE_CTRL_PROP_DIRECTION_MODE = 0x1000000
	// Position of RX_ALWAYS_ON field.
	BLEDP_PROP_MODE_CTRL_RX_ALWAYS_ON_Pos = 0x19
	// Bit mask of RX_ALWAYS_ON field.
	BLEDP_PROP_MODE_CTRL_RX_ALWAYS_ON_Msk = 0x2000000
	// Bit RX_ALWAYS_ON.
	BLEDP_PROP_MODE_CTRL_RX_ALWAYS_ON = 0x2000000
	// Position of TX_ALWAYS_ON field.
	BLEDP_PROP_MODE_CTRL_TX_ALWAYS_ON_Pos = 0x1a
	// Bit mask of TX_ALWAYS_ON field.
	BLEDP_PROP_MODE_CTRL_TX_ALWAYS_ON_Msk = 0x4000000
	// Bit TX_ALWAYS_ON.
	BLEDP_PROP_MODE_CTRL_TX_ALWAYS_ON = 0x4000000
	// Position of TX_POWER_DONE_TIME field.
	BLEDP_PROP_MODE_CTRL_TX_POWER_DONE_TIME_Pos = 0x1b
	// Bit mask of TX_POWER_DONE_TIME field.
	BLEDP_PROP_MODE_CTRL_TX_POWER_DONE_TIME_Msk = 0xf8000000

	// ACCESS_ADDRESS: access address register
	// Position of AA_ADDR_IN field.
	BLEDP_ACCESS_ADDRESS_AA_ADDR_IN_Pos = 0x0
	// Bit mask of AA_ADDR_IN field.
	BLEDP_ACCESS_ADDRESS_AA_ADDR_IN_Msk = 0xffffffff

	// ANT_PDU_DATA0: pdu data 0 to 1 byte, and preamble register
	// Position of PDU_DATA0 field.
	BLEDP_ANT_PDU_DATA0_PDU_DATA0_Pos = 0x0
	// Bit mask of PDU_DATA0 field.
	BLEDP_ANT_PDU_DATA0_PDU_DATA0_Msk = 0xffff
	// Position of PATTERN_SEL field.
	BLEDP_ANT_PDU_DATA0_PATTERN_SEL_Pos = 0x10
	// Bit mask of PATTERN_SEL field.
	BLEDP_ANT_PDU_DATA0_PATTERN_SEL_Msk = 0xf0000
	// Position of TEST_PATTERN_EN field.
	BLEDP_ANT_PDU_DATA0_TEST_PATTERN_EN_Pos = 0x14
	// Bit mask of TEST_PATTERN_EN field.
	BLEDP_ANT_PDU_DATA0_TEST_PATTERN_EN_Msk = 0x100000
	// Bit TEST_PATTERN_EN.
	BLEDP_ANT_PDU_DATA0_TEST_PATTERN_EN = 0x100000
	// Position of PROP_PREAMBLE_WEN field.
	BLEDP_ANT_PDU_DATA0_PROP_PREAMBLE_WEN_Pos = 0x17
	// Bit mask of PROP_PREAMBLE_WEN field.
	BLEDP_ANT_PDU_DATA0_PROP_PREAMBLE_WEN_Msk = 0x800000
	// Bit PROP_PREAMBLE_WEN.
	BLEDP_ANT_PDU_DATA0_PROP_PREAMBLE_WEN = 0x800000
	// Position of PROP_PREAMBLE field.
	BLEDP_ANT_PDU_DATA0_PROP_PREAMBLE_Pos = 0x18
	// Bit mask of PROP_PREAMBLE field.
	BLEDP_ANT_PDU_DATA0_PROP_PREAMBLE_Msk = 0xff000000

	// ANT_PDU_DATA1: pdu data 2 to 5 byte
	// Position of PDU_DATA1 field.
	BLEDP_ANT_PDU_DATA1_PDU_DATA1_Pos = 0x0
	// Bit mask of PDU_DATA1 field.
	BLEDP_ANT_PDU_DATA1_PDU_DATA1_Msk = 0xffffffff

	// ANT_PDU_DATA2: pdu data 6 to 9 byte
	// Position of PDU_DATA2 field.
	BLEDP_ANT_PDU_DATA2_PDU_DATA2_Pos = 0x0
	// Bit mask of PDU_DATA2 field.
	BLEDP_ANT_PDU_DATA2_PDU_DATA2_Msk = 0xffffffff

	// ANT_PDU_DATA3: pdu data 10 to 13 byte
	// Position of PDU_DATA3 field.
	BLEDP_ANT_PDU_DATA3_PDU_DATA3_Pos = 0x0
	// Bit mask of PDU_DATA3 field.
	BLEDP_ANT_PDU_DATA3_PDU_DATA3_Msk = 0xffffffff

	// ANT_PDU_DATA4: pdu data 14 to 17 byte
	// Position of PDU_DATA4 field.
	BLEDP_ANT_PDU_DATA4_PDU_DATA4_Pos = 0x0
	// Bit mask of PDU_DATA4 field.
	BLEDP_ANT_PDU_DATA4_PDU_DATA4_Msk = 0xffffffff

	// ANT_PDU_DATA5: pdu data 18 to 21 byte
	// Position of PDU_DATA5 field.
	BLEDP_ANT_PDU_DATA5_PDU_DATA5_Pos = 0x0
	// Bit mask of PDU_DATA5 field.
	BLEDP_ANT_PDU_DATA5_PDU_DATA5_Msk = 0xffffffff

	// ANT_PDU_DATA6: pdu data 22 to 25 byte
	// Position of PDU_DATA6 field.
	BLEDP_ANT_PDU_DATA6_PDU_DATA6_Pos = 0x0
	// Bit mask of PDU_DATA6 field.
	BLEDP_ANT_PDU_DATA6_PDU_DATA6_Msk = 0xffffffff

	// ANT_PDU_DATA7: pdu data 26 to 29 byte
	// Position of PDU_DATA7 field.
	BLEDP_ANT_PDU_DATA7_PDU_DATA7_Pos = 0x0
	// Bit mask of PDU_DATA7 field.
	BLEDP_ANT_PDU_DATA7_PDU_DATA7_Msk = 0xffffffff

	// CRCSEED: crc seed
	// Position of CRC_SEED_IN field.
	BLEDP_CRCSEED_CRC_SEED_IN_Pos = 0x0
	// Bit mask of CRC_SEED_IN field.
	BLEDP_CRCSEED_CRC_SEED_IN_Msk = 0xffffff
	// Position of CRC_SEED_WEN field.
	BLEDP_CRCSEED_CRC_SEED_WEN_Pos = 0x18
	// Bit mask of CRC_SEED_WEN field.
	BLEDP_CRCSEED_CRC_SEED_WEN_Msk = 0x1000000
	// Bit CRC_SEED_WEN.
	BLEDP_CRCSEED_CRC_SEED_WEN = 0x1000000

	// DP_FUNCTION_CTRL: datapath function control register
	// Position of DP_STATISTICS_SEL field.
	BLEDP_DP_FUNCTION_CTRL_DP_STATISTICS_SEL_Pos = 0x0
	// Bit mask of DP_STATISTICS_SEL field.
	BLEDP_DP_FUNCTION_CTRL_DP_STATISTICS_SEL_Msk = 0x7
	// Position of CHF_COEF_WEN field.
	BLEDP_DP_FUNCTION_CTRL_CHF_COEF_WEN_Pos = 0x3
	// Bit mask of CHF_COEF_WEN field.
	BLEDP_DP_FUNCTION_CTRL_CHF_COEF_WEN_Msk = 0x8
	// Bit CHF_COEF_WEN.
	BLEDP_DP_FUNCTION_CTRL_CHF_COEF_WEN = 0x8
	// Position of CHF_COEF_IDX field.
	BLEDP_DP_FUNCTION_CTRL_CHF_COEF_IDX_Pos = 0x4
	// Bit mask of CHF_COEF_IDX field.
	BLEDP_DP_FUNCTION_CTRL_CHF_COEF_IDX_Msk = 0x30
	// Position of LP_SNR_LEN_AUTO field.
	BLEDP_DP_FUNCTION_CTRL_LP_SNR_LEN_AUTO_Pos = 0x6
	// Bit mask of LP_SNR_LEN_AUTO field.
	BLEDP_DP_FUNCTION_CTRL_LP_SNR_LEN_AUTO_Msk = 0x40
	// Bit LP_SNR_LEN_AUTO.
	BLEDP_DP_FUNCTION_CTRL_LP_SNR_LEN_AUTO = 0x40
	// Position of DOUT_ADJ_DIS field.
	BLEDP_DP_FUNCTION_CTRL_DOUT_ADJ_DIS_Pos = 0x7
	// Bit mask of DOUT_ADJ_DIS field.
	BLEDP_DP_FUNCTION_CTRL_DOUT_ADJ_DIS_Msk = 0x80
	// Bit DOUT_ADJ_DIS.
	BLEDP_DP_FUNCTION_CTRL_DOUT_ADJ_DIS = 0x80
	// Position of LP_ADJ_MODE field.
	BLEDP_DP_FUNCTION_CTRL_LP_ADJ_MODE_Pos = 0x8
	// Bit mask of LP_ADJ_MODE field.
	BLEDP_DP_FUNCTION_CTRL_LP_ADJ_MODE_Msk = 0x100
	// Bit LP_ADJ_MODE.
	BLEDP_DP_FUNCTION_CTRL_LP_ADJ_MODE = 0x100
	// Position of FR_OFFSET_EN field.
	BLEDP_DP_FUNCTION_CTRL_FR_OFFSET_EN_Pos = 0x9
	// Bit mask of FR_OFFSET_EN field.
	BLEDP_DP_FUNCTION_CTRL_FR_OFFSET_EN_Msk = 0x200
	// Bit FR_OFFSET_EN.
	BLEDP_DP_FUNCTION_CTRL_FR_OFFSET_EN = 0x200
	// Position of DC_AVE_EN field.
	BLEDP_DP_FUNCTION_CTRL_DC_AVE_EN_Pos = 0xa
	// Bit mask of DC_AVE_EN field.
	BLEDP_DP_FUNCTION_CTRL_DC_AVE_EN_Msk = 0x400
	// Bit DC_AVE_EN.
	BLEDP_DP_FUNCTION_CTRL_DC_AVE_EN = 0x400
	// Position of FIX_DELAY_EN field.
	BLEDP_DP_FUNCTION_CTRL_FIX_DELAY_EN_Pos = 0xb
	// Bit mask of FIX_DELAY_EN field.
	BLEDP_DP_FUNCTION_CTRL_FIX_DELAY_EN_Msk = 0x800
	// Bit FIX_DELAY_EN.
	BLEDP_DP_FUNCTION_CTRL_FIX_DELAY_EN = 0x800
	// Position of TRACK_LEN field.
	BLEDP_DP_FUNCTION_CTRL_TRACK_LEN_Pos = 0xc
	// Bit mask of TRACK_LEN field.
	BLEDP_DP_FUNCTION_CTRL_TRACK_LEN_Msk = 0x3000
	// Position of TRACK_LEN_WEN field.
	BLEDP_DP_FUNCTION_CTRL_TRACK_LEN_WEN_Pos = 0xe
	// Bit mask of TRACK_LEN_WEN field.
	BLEDP_DP_FUNCTION_CTRL_TRACK_LEN_WEN_Msk = 0x4000
	// Bit TRACK_LEN_WEN.
	BLEDP_DP_FUNCTION_CTRL_TRACK_LEN_WEN = 0x4000
	// Position of XCORR_FILT_EN field.
	BLEDP_DP_FUNCTION_CTRL_XCORR_FILT_EN_Pos = 0x10
	// Bit mask of XCORR_FILT_EN field.
	BLEDP_DP_FUNCTION_CTRL_XCORR_FILT_EN_Msk = 0x10000
	// Bit XCORR_FILT_EN.
	BLEDP_DP_FUNCTION_CTRL_XCORR_FILT_EN = 0x10000
	// Position of XCORR_FULLWIN_EN field.
	BLEDP_DP_FUNCTION_CTRL_XCORR_FULLWIN_EN_Pos = 0x11
	// Bit mask of XCORR_FULLWIN_EN field.
	BLEDP_DP_FUNCTION_CTRL_XCORR_FULLWIN_EN_Msk = 0x20000
	// Bit XCORR_FULLWIN_EN.
	BLEDP_DP_FUNCTION_CTRL_XCORR_FULLWIN_EN = 0x20000
	// Position of XCORR_AA_LEN field.
	BLEDP_DP_FUNCTION_CTRL_XCORR_AA_LEN_Pos = 0x12
	// Bit mask of XCORR_AA_LEN field.
	BLEDP_DP_FUNCTION_CTRL_XCORR_AA_LEN_Msk = 0x40000
	// Bit XCORR_AA_LEN.
	BLEDP_DP_FUNCTION_CTRL_XCORR_AA_LEN = 0x40000
	// Position of XCORR_AA_LEN_WEN field.
	BLEDP_DP_FUNCTION_CTRL_XCORR_AA_LEN_WEN_Pos = 0x13
	// Bit mask of XCORR_AA_LEN_WEN field.
	BLEDP_DP_FUNCTION_CTRL_XCORR_AA_LEN_WEN_Msk = 0x80000
	// Bit XCORR_AA_LEN_WEN.
	BLEDP_DP_FUNCTION_CTRL_XCORR_AA_LEN_WEN = 0x80000
	// Position of XCORR_WIN_AUTO_EN field.
	BLEDP_DP_FUNCTION_CTRL_XCORR_WIN_AUTO_EN_Pos = 0x14
	// Bit mask of XCORR_WIN_AUTO_EN field.
	BLEDP_DP_FUNCTION_CTRL_XCORR_WIN_AUTO_EN_Msk = 0x100000
	// Bit XCORR_WIN_AUTO_EN.
	BLEDP_DP_FUNCTION_CTRL_XCORR_WIN_AUTO_EN = 0x100000
	// Position of RESAMPLER_TAP field.
	BLEDP_DP_FUNCTION_CTRL_RESAMPLER_TAP_Pos = 0x15
	// Bit mask of RESAMPLER_TAP field.
	BLEDP_DP_FUNCTION_CTRL_RESAMPLER_TAP_Msk = 0x200000
	// Bit RESAMPLER_TAP.
	BLEDP_DP_FUNCTION_CTRL_RESAMPLER_TAP = 0x200000
	// Position of RESAMPLER_TAP_WEN field.
	BLEDP_DP_FUNCTION_CTRL_RESAMPLER_TAP_WEN_Pos = 0x16
	// Bit mask of RESAMPLER_TAP_WEN field.
	BLEDP_DP_FUNCTION_CTRL_RESAMPLER_TAP_WEN_Msk = 0x400000
	// Bit RESAMPLER_TAP_WEN.
	BLEDP_DP_FUNCTION_CTRL_RESAMPLER_TAP_WEN = 0x400000
	// Position of RESAMPLER_BP field.
	BLEDP_DP_FUNCTION_CTRL_RESAMPLER_BP_Pos = 0x17
	// Bit mask of RESAMPLER_BP field.
	BLEDP_DP_FUNCTION_CTRL_RESAMPLER_BP_Msk = 0x800000
	// Bit RESAMPLER_BP.
	BLEDP_DP_FUNCTION_CTRL_RESAMPLER_BP = 0x800000
	// Position of FAGC_WIN_LEN field.
	BLEDP_DP_FUNCTION_CTRL_FAGC_WIN_LEN_Pos = 0x18
	// Bit mask of FAGC_WIN_LEN field.
	BLEDP_DP_FUNCTION_CTRL_FAGC_WIN_LEN_Msk = 0x1000000
	// Bit FAGC_WIN_LEN.
	BLEDP_DP_FUNCTION_CTRL_FAGC_WIN_LEN = 0x1000000
	// Position of FAGC_WEN field.
	BLEDP_DP_FUNCTION_CTRL_FAGC_WEN_Pos = 0x19
	// Bit mask of FAGC_WEN field.
	BLEDP_DP_FUNCTION_CTRL_FAGC_WEN_Msk = 0x2000000
	// Bit FAGC_WEN.
	BLEDP_DP_FUNCTION_CTRL_FAGC_WEN = 0x2000000
	// Position of HP_CFO_EN field.
	BLEDP_DP_FUNCTION_CTRL_HP_CFO_EN_Pos = 0x1a
	// Bit mask of HP_CFO_EN field.
	BLEDP_DP_FUNCTION_CTRL_HP_CFO_EN_Msk = 0x4000000
	// Bit HP_CFO_EN.
	BLEDP_DP_FUNCTION_CTRL_HP_CFO_EN = 0x4000000
	// Position of CFO_TRACK_EN field.
	BLEDP_DP_FUNCTION_CTRL_CFO_TRACK_EN_Pos = 0x1b
	// Bit mask of CFO_TRACK_EN field.
	BLEDP_DP_FUNCTION_CTRL_CFO_TRACK_EN_Msk = 0x8000000
	// Bit CFO_TRACK_EN.
	BLEDP_DP_FUNCTION_CTRL_CFO_TRACK_EN = 0x8000000
	// Position of CFO_INI_EN field.
	BLEDP_DP_FUNCTION_CTRL_CFO_INI_EN_Pos = 0x1c
	// Bit mask of CFO_INI_EN field.
	BLEDP_DP_FUNCTION_CTRL_CFO_INI_EN_Msk = 0x10000000
	// Bit CFO_INI_EN.
	BLEDP_DP_FUNCTION_CTRL_CFO_INI_EN = 0x10000000
	// Position of ADC_IN_FLIP field.
	BLEDP_DP_FUNCTION_CTRL_ADC_IN_FLIP_Pos = 0x1d
	// Bit mask of ADC_IN_FLIP field.
	BLEDP_DP_FUNCTION_CTRL_ADC_IN_FLIP_Msk = 0x20000000
	// Bit ADC_IN_FLIP.
	BLEDP_DP_FUNCTION_CTRL_ADC_IN_FLIP = 0x20000000
	// Position of TX_EN_MODE field.
	BLEDP_DP_FUNCTION_CTRL_TX_EN_MODE_Pos = 0x1e
	// Bit mask of TX_EN_MODE field.
	BLEDP_DP_FUNCTION_CTRL_TX_EN_MODE_Msk = 0x40000000
	// Bit TX_EN_MODE.
	BLEDP_DP_FUNCTION_CTRL_TX_EN_MODE = 0x40000000
	// Position of RX_EN_MODE field.
	BLEDP_DP_FUNCTION_CTRL_RX_EN_MODE_Pos = 0x1f
	// Bit mask of RX_EN_MODE field.
	BLEDP_DP_FUNCTION_CTRL_RX_EN_MODE_Msk = 0x80000000
	// Bit RX_EN_MODE.
	BLEDP_DP_FUNCTION_CTRL_RX_EN_MODE = 0x80000000

	// DP_TEST_CTRL: datapath test iinterface register
	// Position of TIF_SEL field.
	BLEDP_DP_TEST_CTRL_TIF_SEL_Pos = 0x0
	// Bit mask of TIF_SEL field.
	BLEDP_DP_TEST_CTRL_TIF_SEL_Msk = 0xff
	// Position of TIF_CLK_SEL field.
	BLEDP_DP_TEST_CTRL_TIF_CLK_SEL_Pos = 0x8
	// Bit mask of TIF_CLK_SEL field.
	BLEDP_DP_TEST_CTRL_TIF_CLK_SEL_Msk = 0x300
	// Position of CORDIC_DAC_OUT field.
	BLEDP_DP_TEST_CTRL_CORDIC_DAC_OUT_Pos = 0xb
	// Bit mask of CORDIC_DAC_OUT field.
	BLEDP_DP_TEST_CTRL_CORDIC_DAC_OUT_Msk = 0x800
	// Bit CORDIC_DAC_OUT.
	BLEDP_DP_TEST_CTRL_CORDIC_DAC_OUT = 0x800
	// Position of TIF_EN field.
	BLEDP_DP_TEST_CTRL_TIF_EN_Pos = 0xc
	// Bit mask of TIF_EN field.
	BLEDP_DP_TEST_CTRL_TIF_EN_Msk = 0x1000
	// Bit TIF_EN.
	BLEDP_DP_TEST_CTRL_TIF_EN = 0x1000
	// Position of IMR_INV field.
	BLEDP_DP_TEST_CTRL_IMR_INV_Pos = 0xd
	// Bit mask of IMR_INV field.
	BLEDP_DP_TEST_CTRL_IMR_INV_Msk = 0x2000
	// Bit IMR_INV.
	BLEDP_DP_TEST_CTRL_IMR_INV = 0x2000
	// Position of CLK_TX_GATE_DIS field.
	BLEDP_DP_TEST_CTRL_CLK_TX_GATE_DIS_Pos = 0xe
	// Bit mask of CLK_TX_GATE_DIS field.
	BLEDP_DP_TEST_CTRL_CLK_TX_GATE_DIS_Msk = 0x4000
	// Bit CLK_TX_GATE_DIS.
	BLEDP_DP_TEST_CTRL_CLK_TX_GATE_DIS = 0x4000
	// Position of BUF_FULL_OFFRF_DIS field.
	BLEDP_DP_TEST_CTRL_BUF_FULL_OFFRF_DIS_Pos = 0xf
	// Bit mask of BUF_FULL_OFFRF_DIS field.
	BLEDP_DP_TEST_CTRL_BUF_FULL_OFFRF_DIS_Msk = 0x8000
	// Bit BUF_FULL_OFFRF_DIS.
	BLEDP_DP_TEST_CTRL_BUF_FULL_OFFRF_DIS = 0x8000
	// Position of CLK_BUST_GATE_DIS field.
	BLEDP_DP_TEST_CTRL_CLK_BUST_GATE_DIS_Pos = 0x10
	// Bit mask of CLK_BUST_GATE_DIS field.
	BLEDP_DP_TEST_CTRL_CLK_BUST_GATE_DIS_Msk = 0x10000
	// Bit CLK_BUST_GATE_DIS.
	BLEDP_DP_TEST_CTRL_CLK_BUST_GATE_DIS = 0x10000
	// Position of CLK_RX_GATE_DIS field.
	BLEDP_DP_TEST_CTRL_CLK_RX_GATE_DIS_Pos = 0x11
	// Bit mask of CLK_RX_GATE_DIS field.
	BLEDP_DP_TEST_CTRL_CLK_RX_GATE_DIS_Msk = 0x20000
	// Bit CLK_RX_GATE_DIS.
	BLEDP_DP_TEST_CTRL_CLK_RX_GATE_DIS = 0x20000
	// Position of CLK_LPDET_GATE_DIS field.
	BLEDP_DP_TEST_CTRL_CLK_LPDET_GATE_DIS_Pos = 0x12
	// Bit mask of CLK_LPDET_GATE_DIS field.
	BLEDP_DP_TEST_CTRL_CLK_LPDET_GATE_DIS_Msk = 0x40000
	// Bit CLK_LPDET_GATE_DIS.
	BLEDP_DP_TEST_CTRL_CLK_LPDET_GATE_DIS = 0x40000
	// Position of CLK_HPDET_GATE_DIS field.
	BLEDP_DP_TEST_CTRL_CLK_HPDET_GATE_DIS_Pos = 0x13
	// Bit mask of CLK_HPDET_GATE_DIS field.
	BLEDP_DP_TEST_CTRL_CLK_HPDET_GATE_DIS_Msk = 0x80000
	// Bit CLK_HPDET_GATE_DIS.
	BLEDP_DP_TEST_CTRL_CLK_HPDET_GATE_DIS = 0x80000
	// Position of CLK_RFE_GATE_DIS field.
	BLEDP_DP_TEST_CTRL_CLK_RFE_GATE_DIS_Pos = 0x14
	// Bit mask of CLK_RFE_GATE_DIS field.
	BLEDP_DP_TEST_CTRL_CLK_RFE_GATE_DIS_Msk = 0x100000
	// Bit CLK_RFE_GATE_DIS.
	BLEDP_DP_TEST_CTRL_CLK_RFE_GATE_DIS = 0x100000
	// Position of IQSWAP_XOR field.
	BLEDP_DP_TEST_CTRL_IQSWAP_XOR_Pos = 0x15
	// Bit mask of IQSWAP_XOR field.
	BLEDP_DP_TEST_CTRL_IQSWAP_XOR_Msk = 0x200000
	// Bit IQSWAP_XOR.
	BLEDP_DP_TEST_CTRL_IQSWAP_XOR = 0x200000
	// Position of DAC_TEST_EN field.
	BLEDP_DP_TEST_CTRL_DAC_TEST_EN_Pos = 0x17
	// Bit mask of DAC_TEST_EN field.
	BLEDP_DP_TEST_CTRL_DAC_TEST_EN_Msk = 0x800000
	// Bit DAC_TEST_EN.
	BLEDP_DP_TEST_CTRL_DAC_TEST_EN = 0x800000
	// Position of DAC_TEST field.
	BLEDP_DP_TEST_CTRL_DAC_TEST_Pos = 0x18
	// Bit mask of DAC_TEST field.
	BLEDP_DP_TEST_CTRL_DAC_TEST_Msk = 0xff000000

	// BLE_DP_STATUS1: datapath status register 1
	// Position of SNR_EST field.
	BLEDP_BLE_DP_STATUS1_SNR_EST_Pos = 0x0
	// Bit mask of SNR_EST field.
	BLEDP_BLE_DP_STATUS1_SNR_EST_Msk = 0xff
	// Position of CNR_EST field.
	BLEDP_BLE_DP_STATUS1_CNR_EST_Pos = 0x8
	// Bit mask of CNR_EST field.
	BLEDP_BLE_DP_STATUS1_CNR_EST_Msk = 0x3f00
	// Position of AGC_RSSI field.
	BLEDP_BLE_DP_STATUS1_AGC_RSSI_Pos = 0x10
	// Bit mask of AGC_RSSI field.
	BLEDP_BLE_DP_STATUS1_AGC_RSSI_Msk = 0xff0000
	// Position of AGC_RSSI_READY field.
	BLEDP_BLE_DP_STATUS1_AGC_RSSI_READY_Pos = 0x18
	// Bit mask of AGC_RSSI_READY field.
	BLEDP_BLE_DP_STATUS1_AGC_RSSI_READY_Msk = 0x1000000
	// Bit AGC_RSSI_READY.
	BLEDP_BLE_DP_STATUS1_AGC_RSSI_READY = 0x1000000
	// Position of SNR_VLD field.
	BLEDP_BLE_DP_STATUS1_SNR_VLD_Pos = 0x19
	// Bit mask of SNR_VLD field.
	BLEDP_BLE_DP_STATUS1_SNR_VLD_Msk = 0x2000000
	// Bit SNR_VLD.
	BLEDP_BLE_DP_STATUS1_SNR_VLD = 0x2000000
	// Position of CNR_VLD field.
	BLEDP_BLE_DP_STATUS1_CNR_VLD_Pos = 0x1a
	// Bit mask of CNR_VLD field.
	BLEDP_BLE_DP_STATUS1_CNR_VLD_Msk = 0x4000000
	// Bit CNR_VLD.
	BLEDP_BLE_DP_STATUS1_CNR_VLD = 0x4000000
	// Position of TX_BUSY field.
	BLEDP_BLE_DP_STATUS1_TX_BUSY_Pos = 0x1b
	// Bit mask of TX_BUSY field.
	BLEDP_BLE_DP_STATUS1_TX_BUSY_Msk = 0x8000000
	// Bit TX_BUSY.
	BLEDP_BLE_DP_STATUS1_TX_BUSY = 0x8000000

	// BLE_DP_STATUS2: datapath status register 2
	// Position of VALID_PCK_NUM field.
	BLEDP_BLE_DP_STATUS2_VALID_PCK_NUM_Pos = 0x0
	// Bit mask of VALID_PCK_NUM field.
	BLEDP_BLE_DP_STATUS2_VALID_PCK_NUM_Msk = 0xffff
	// Position of AA_ERR_NUM field.
	BLEDP_BLE_DP_STATUS2_AA_ERR_NUM_Pos = 0x10
	// Bit mask of AA_ERR_NUM field.
	BLEDP_BLE_DP_STATUS2_AA_ERR_NUM_Msk = 0x3f0000
	// Position of CRC_ERROR field.
	BLEDP_BLE_DP_STATUS2_CRC_ERROR_Pos = 0x1d
	// Bit mask of CRC_ERROR field.
	BLEDP_BLE_DP_STATUS2_CRC_ERROR_Msk = 0x20000000
	// Bit CRC_ERROR.
	BLEDP_BLE_DP_STATUS2_CRC_ERROR = 0x20000000
	// Position of BURST_DET field.
	BLEDP_BLE_DP_STATUS2_BURST_DET_Pos = 0x1e
	// Bit mask of BURST_DET field.
	BLEDP_BLE_DP_STATUS2_BURST_DET_Msk = 0x40000000
	// Bit BURST_DET.
	BLEDP_BLE_DP_STATUS2_BURST_DET = 0x40000000
	// Position of DP_STATUS_VLD_0 field.
	BLEDP_BLE_DP_STATUS2_DP_STATUS_VLD_0_Pos = 0x1f
	// Bit mask of DP_STATUS_VLD_0 field.
	BLEDP_BLE_DP_STATUS2_DP_STATUS_VLD_0_Msk = 0x80000000
	// Bit DP_STATUS_VLD_0.
	BLEDP_BLE_DP_STATUS2_DP_STATUS_VLD_0 = 0x80000000

	// BLE_DP_STATUS3: datapath status register 3
	// Position of FD_CFO_TRACK field.
	BLEDP_BLE_DP_STATUS3_FD_CFO_TRACK_Pos = 0x0
	// Bit mask of FD_CFO_TRACK field.
	BLEDP_BLE_DP_STATUS3_FD_CFO_TRACK_Msk = 0x7ff
	// Position of CFO_EST_FD field.
	BLEDP_BLE_DP_STATUS3_CFO_EST_FD_Pos = 0x10
	// Bit mask of CFO_EST_FD field.
	BLEDP_BLE_DP_STATUS3_CFO_EST_FD_Msk = 0x7ff0000

	// BLE_DP_STATUS4: datapath status register 4
	// Position of RESAMPLER_PH field.
	BLEDP_BLE_DP_STATUS4_RESAMPLER_PH_Pos = 0x0
	// Bit mask of RESAMPLER_PH field.
	BLEDP_BLE_DP_STATUS4_RESAMPLER_PH_Msk = 0x3ff
	// Position of HP_CFO field.
	BLEDP_BLE_DP_STATUS4_HP_CFO_Pos = 0x10
	// Bit mask of HP_CFO field.
	BLEDP_BLE_DP_STATUS4_HP_CFO_Msk = 0xfff0000
	// Position of HP_CFO_VLD field.
	BLEDP_BLE_DP_STATUS4_HP_CFO_VLD_Pos = 0x1f
	// Bit mask of HP_CFO_VLD field.
	BLEDP_BLE_DP_STATUS4_HP_CFO_VLD_Msk = 0x80000000
	// Bit HP_CFO_VLD.
	BLEDP_BLE_DP_STATUS4_HP_CFO_VLD = 0x80000000

	// RX_FRONT_END_CTRL1: rx front end control register 1
	// Position of CFO_COMP field.
	BLEDP_RX_FRONT_END_CTRL1_CFO_COMP_Pos = 0x0
	// Bit mask of CFO_COMP field.
	BLEDP_RX_FRONT_END_CTRL1_CFO_COMP_Msk = 0x7fff
	// Position of DCNOTCH_GIN field.
	BLEDP_RX_FRONT_END_CTRL1_DCNOTCH_GIN_Pos = 0x10
	// Bit mask of DCNOTCH_GIN field.
	BLEDP_RX_FRONT_END_CTRL1_DCNOTCH_GIN_Msk = 0x30000

	// RX_FRONT_END_CTRL2: rx front end control register 2
	// Position of FAGC_GAIN field.
	BLEDP_RX_FRONT_END_CTRL2_FAGC_GAIN_Pos = 0x0
	// Bit mask of FAGC_GAIN field.
	BLEDP_RX_FRONT_END_CTRL2_FAGC_GAIN_Msk = 0x7ff
	// Position of FAGC_INI_VAL field.
	BLEDP_RX_FRONT_END_CTRL2_FAGC_INI_VAL_Pos = 0xb
	// Bit mask of FAGC_INI_VAL field.
	BLEDP_RX_FRONT_END_CTRL2_FAGC_INI_VAL_Msk = 0x800
	// Bit FAGC_INI_VAL.
	BLEDP_RX_FRONT_END_CTRL2_FAGC_INI_VAL = 0x800
	// Position of CNR_IDX_DELTA field.
	BLEDP_RX_FRONT_END_CTRL2_CNR_IDX_DELTA_Pos = 0xc
	// Bit mask of CNR_IDX_DELTA field.
	BLEDP_RX_FRONT_END_CTRL2_CNR_IDX_DELTA_Msk = 0xf000
	// Position of FAGC_REF field.
	BLEDP_RX_FRONT_END_CTRL2_FAGC_REF_Pos = 0x10
	// Bit mask of FAGC_REF field.
	BLEDP_RX_FRONT_END_CTRL2_FAGC_REF_Msk = 0xff0000
	// Position of CORDIC_MIN_VIN_TH field.
	BLEDP_RX_FRONT_END_CTRL2_CORDIC_MIN_VIN_TH_Pos = 0x18
	// Bit mask of CORDIC_MIN_VIN_TH field.
	BLEDP_RX_FRONT_END_CTRL2_CORDIC_MIN_VIN_TH_Msk = 0xf000000
	// Position of FREQ_TRADE_EN field.
	BLEDP_RX_FRONT_END_CTRL2_FREQ_TRADE_EN_Pos = 0x1c
	// Bit mask of FREQ_TRADE_EN field.
	BLEDP_RX_FRONT_END_CTRL2_FREQ_TRADE_EN_Msk = 0x10000000
	// Bit FREQ_TRADE_EN.
	BLEDP_RX_FRONT_END_CTRL2_FREQ_TRADE_EN = 0x10000000
	// Position of CHN_SHIFT field.
	BLEDP_RX_FRONT_END_CTRL2_CHN_SHIFT_Pos = 0x1d
	// Bit mask of CHN_SHIFT field.
	BLEDP_RX_FRONT_END_CTRL2_CHN_SHIFT_Msk = 0xe0000000

	// FREQ_DOMAIN_CTRL1: frequency domain control register 1
	// Position of SYNC_WORD_IN0 field.
	BLEDP_FREQ_DOMAIN_CTRL1_SYNC_WORD_IN0_Pos = 0x0
	// Bit mask of SYNC_WORD_IN0 field.
	BLEDP_FREQ_DOMAIN_CTRL1_SYNC_WORD_IN0_Msk = 0xff
	// Position of SYNC_WORD_WEN field.
	BLEDP_FREQ_DOMAIN_CTRL1_SYNC_WORD_WEN_Pos = 0x8
	// Bit mask of SYNC_WORD_WEN field.
	BLEDP_FREQ_DOMAIN_CTRL1_SYNC_WORD_WEN_Msk = 0x100
	// Bit SYNC_WORD_WEN.
	BLEDP_FREQ_DOMAIN_CTRL1_SYNC_WORD_WEN = 0x100
	// Position of SYNC_P_SEL field.
	BLEDP_FREQ_DOMAIN_CTRL1_SYNC_P_SEL_Pos = 0xf
	// Bit mask of SYNC_P_SEL field.
	BLEDP_FREQ_DOMAIN_CTRL1_SYNC_P_SEL_Msk = 0x8000
	// Bit SYNC_P_SEL.
	BLEDP_FREQ_DOMAIN_CTRL1_SYNC_P_SEL = 0x8000
	// Position of RD_EXBIT_EN field.
	BLEDP_FREQ_DOMAIN_CTRL1_RD_EXBIT_EN_Pos = 0x10
	// Bit mask of RD_EXBIT_EN field.
	BLEDP_FREQ_DOMAIN_CTRL1_RD_EXBIT_EN_Msk = 0x10000
	// Bit RD_EXBIT_EN.
	BLEDP_FREQ_DOMAIN_CTRL1_RD_EXBIT_EN = 0x10000
	// Position of RFAGC_TRACK_DLY field.
	BLEDP_FREQ_DOMAIN_CTRL1_RFAGC_TRACK_DLY_Pos = 0x11
	// Bit mask of RFAGC_TRACK_DLY field.
	BLEDP_FREQ_DOMAIN_CTRL1_RFAGC_TRACK_DLY_Msk = 0xe0000
	// Position of PROP_DF_16US field.
	BLEDP_FREQ_DOMAIN_CTRL1_PROP_DF_16US_Pos = 0x18
	// Bit mask of PROP_DF_16US field.
	BLEDP_FREQ_DOMAIN_CTRL1_PROP_DF_16US_Msk = 0xff000000

	// FREQ_DOMAIN_CTRL2: frequency domain control register 2
	// Position of SYNC_WORD_IN1 field.
	BLEDP_FREQ_DOMAIN_CTRL2_SYNC_WORD_IN1_Pos = 0x0
	// Bit mask of SYNC_WORD_IN1 field.
	BLEDP_FREQ_DOMAIN_CTRL2_SYNC_WORD_IN1_Msk = 0xffffffff

	// FREQ_DOMAIN_CTRL3: frequency domain control register 3
	// Position of XCORR_PAR_TH3 field.
	BLEDP_FREQ_DOMAIN_CTRL3_XCORR_PAR_TH3_Pos = 0x0
	// Bit mask of XCORR_PAR_TH3 field.
	BLEDP_FREQ_DOMAIN_CTRL3_XCORR_PAR_TH3_Msk = 0x3f
	// Position of XCORR_PAR_TH2 field.
	BLEDP_FREQ_DOMAIN_CTRL3_XCORR_PAR_TH2_Pos = 0x8
	// Bit mask of XCORR_PAR_TH2 field.
	BLEDP_FREQ_DOMAIN_CTRL3_XCORR_PAR_TH2_Msk = 0x3f00
	// Position of XCORR_PAR_TH1 field.
	BLEDP_FREQ_DOMAIN_CTRL3_XCORR_PAR_TH1_Pos = 0x10
	// Bit mask of XCORR_PAR_TH1 field.
	BLEDP_FREQ_DOMAIN_CTRL3_XCORR_PAR_TH1_Msk = 0x3f0000
	// Position of XCORR_PAR_TH0 field.
	BLEDP_FREQ_DOMAIN_CTRL3_XCORR_PAR_TH0_Pos = 0x18
	// Bit mask of XCORR_PAR_TH0 field.
	BLEDP_FREQ_DOMAIN_CTRL3_XCORR_PAR_TH0_Msk = 0x3f000000

	// FREQ_DOMAIN_CTRL4: frequency domain control register 4
	// Position of XCORR_POW_TH3 field.
	BLEDP_FREQ_DOMAIN_CTRL4_XCORR_POW_TH3_Pos = 0x0
	// Bit mask of XCORR_POW_TH3 field.
	BLEDP_FREQ_DOMAIN_CTRL4_XCORR_POW_TH3_Msk = 0x3f
	// Position of XCORR_POW_TH2 field.
	BLEDP_FREQ_DOMAIN_CTRL4_XCORR_POW_TH2_Pos = 0x8
	// Bit mask of XCORR_POW_TH2 field.
	BLEDP_FREQ_DOMAIN_CTRL4_XCORR_POW_TH2_Msk = 0x3f00
	// Position of XCORR_POW_TH1 field.
	BLEDP_FREQ_DOMAIN_CTRL4_XCORR_POW_TH1_Pos = 0x10
	// Bit mask of XCORR_POW_TH1 field.
	BLEDP_FREQ_DOMAIN_CTRL4_XCORR_POW_TH1_Msk = 0x3f0000
	// Position of XCORR_POW_TH0 field.
	BLEDP_FREQ_DOMAIN_CTRL4_XCORR_POW_TH0_Pos = 0x18
	// Bit mask of XCORR_POW_TH0 field.
	BLEDP_FREQ_DOMAIN_CTRL4_XCORR_POW_TH0_Msk = 0x3f000000

	// FREQ_DOMAIN_CTRL5: frequency domain control register 5
	// Position of GAIN_TED field.
	BLEDP_FREQ_DOMAIN_CTRL5_GAIN_TED_Pos = 0x0
	// Bit mask of GAIN_TED field.
	BLEDP_FREQ_DOMAIN_CTRL5_GAIN_TED_Msk = 0x3
	// Position of SYNC_DIN_SAT_VALUE field.
	BLEDP_FREQ_DOMAIN_CTRL5_SYNC_DIN_SAT_VALUE_Pos = 0x4
	// Bit mask of SYNC_DIN_SAT_VALUE field.
	BLEDP_FREQ_DOMAIN_CTRL5_SYNC_DIN_SAT_VALUE_Msk = 0x70
	// Position of SYNC_DIN_SAT_EN field.
	BLEDP_FREQ_DOMAIN_CTRL5_SYNC_DIN_SAT_EN_Pos = 0x7
	// Bit mask of SYNC_DIN_SAT_EN field.
	BLEDP_FREQ_DOMAIN_CTRL5_SYNC_DIN_SAT_EN_Msk = 0x80
	// Bit SYNC_DIN_SAT_EN.
	BLEDP_FREQ_DOMAIN_CTRL5_SYNC_DIN_SAT_EN = 0x80
	// Position of CNT_SETTLE_IDX field.
	BLEDP_FREQ_DOMAIN_CTRL5_CNT_SETTLE_IDX_Pos = 0x8
	// Bit mask of CNT_SETTLE_IDX field.
	BLEDP_FREQ_DOMAIN_CTRL5_CNT_SETTLE_IDX_Msk = 0x700
	// Position of TRIG_XCORR_CNT field.
	BLEDP_FREQ_DOMAIN_CTRL5_TRIG_XCORR_CNT_Pos = 0xc
	// Bit mask of TRIG_XCORR_CNT field.
	BLEDP_FREQ_DOMAIN_CTRL5_TRIG_XCORR_CNT_Msk = 0xf000
	// Position of XCORR_RSSI_TH3 field.
	BLEDP_FREQ_DOMAIN_CTRL5_XCORR_RSSI_TH3_Pos = 0x10
	// Bit mask of XCORR_RSSI_TH3 field.
	BLEDP_FREQ_DOMAIN_CTRL5_XCORR_RSSI_TH3_Msk = 0xf0000
	// Position of XCORR_RSSI_TH2 field.
	BLEDP_FREQ_DOMAIN_CTRL5_XCORR_RSSI_TH2_Pos = 0x14
	// Bit mask of XCORR_RSSI_TH2 field.
	BLEDP_FREQ_DOMAIN_CTRL5_XCORR_RSSI_TH2_Msk = 0xf00000
	// Position of XCORR_RSSI_TH1 field.
	BLEDP_FREQ_DOMAIN_CTRL5_XCORR_RSSI_TH1_Pos = 0x18
	// Bit mask of XCORR_RSSI_TH1 field.
	BLEDP_FREQ_DOMAIN_CTRL5_XCORR_RSSI_TH1_Msk = 0xf000000
	// Position of XCORR_RSSI_TH0 field.
	BLEDP_FREQ_DOMAIN_CTRL5_XCORR_RSSI_TH0_Pos = 0x1c
	// Bit mask of XCORR_RSSI_TH0 field.
	BLEDP_FREQ_DOMAIN_CTRL5_XCORR_RSSI_TH0_Msk = 0xf0000000

	// FREQ_DOMAIN_CTRL6: frequency domain control register 5
	// Position of HP_TRAIN_SIZ field.
	BLEDP_FREQ_DOMAIN_CTRL6_HP_TRAIN_SIZ_Pos = 0x0
	// Bit mask of HP_TRAIN_SIZ field.
	BLEDP_FREQ_DOMAIN_CTRL6_HP_TRAIN_SIZ_Msk = 0x1f
	// Position of HP_HIDX_GAIN field.
	BLEDP_FREQ_DOMAIN_CTRL6_HP_HIDX_GAIN_Pos = 0x8
	// Bit mask of HP_HIDX_GAIN field.
	BLEDP_FREQ_DOMAIN_CTRL6_HP_HIDX_GAIN_Msk = 0xff00
	// Position of H_REF_GAIN field.
	BLEDP_FREQ_DOMAIN_CTRL6_H_REF_GAIN_Pos = 0x10
	// Bit mask of H_REF_GAIN field.
	BLEDP_FREQ_DOMAIN_CTRL6_H_REF_GAIN_Msk = 0x3f0000
	// Position of DET_FR_IDX field.
	BLEDP_FREQ_DOMAIN_CTRL6_DET_FR_IDX_Pos = 0x18
	// Bit mask of DET_FR_IDX field.
	BLEDP_FREQ_DOMAIN_CTRL6_DET_FR_IDX_Msk = 0x3000000
	// Position of CFO_FR_IDX field.
	BLEDP_FREQ_DOMAIN_CTRL6_CFO_FR_IDX_Pos = 0x1c
	// Bit mask of CFO_FR_IDX field.
	BLEDP_FREQ_DOMAIN_CTRL6_CFO_FR_IDX_Msk = 0x30000000

	// HP_MODE_CTRL1: when high hp mode training size same as cfo tracking.
	// Position of HP_BMC_P_TRACK field.
	BLEDP_HP_MODE_CTRL1_HP_BMC_P_TRACK_Pos = 0x0
	// Bit mask of HP_BMC_P_TRACK field.
	BLEDP_HP_MODE_CTRL1_HP_BMC_P_TRACK_Msk = 0x3f
	// Position of HP_BMC_P_TRAIN field.
	BLEDP_HP_MODE_CTRL1_HP_BMC_P_TRAIN_Pos = 0x8
	// Bit mask of HP_BMC_P_TRAIN field.
	BLEDP_HP_MODE_CTRL1_HP_BMC_P_TRAIN_Msk = 0x3f00
	// Position of HP_BMC_CZ1 field.
	BLEDP_HP_MODE_CTRL1_HP_BMC_CZ1_Pos = 0x10
	// Bit mask of HP_BMC_CZ1 field.
	BLEDP_HP_MODE_CTRL1_HP_BMC_CZ1_Msk = 0x3f0000
	// Position of BUF_IDX_DELTA field.
	BLEDP_HP_MODE_CTRL1_BUF_IDX_DELTA_Pos = 0x18
	// Bit mask of BUF_IDX_DELTA field.
	BLEDP_HP_MODE_CTRL1_BUF_IDX_DELTA_Msk = 0xf000000
	// Position of WMF2_DSAMP_IDX field.
	BLEDP_HP_MODE_CTRL1_WMF2_DSAMP_IDX_Pos = 0x1c
	// Bit mask of WMF2_DSAMP_IDX field.
	BLEDP_HP_MODE_CTRL1_WMF2_DSAMP_IDX_Msk = 0x70000000
	// Position of HP_TRAIN_SIZ_FIX field.
	BLEDP_HP_MODE_CTRL1_HP_TRAIN_SIZ_FIX_Pos = 0x1f
	// Bit mask of HP_TRAIN_SIZ_FIX field.
	BLEDP_HP_MODE_CTRL1_HP_TRAIN_SIZ_FIX_Msk = 0x80000000
	// Bit HP_TRAIN_SIZ_FIX.
	BLEDP_HP_MODE_CTRL1_HP_TRAIN_SIZ_FIX = 0x80000000

	// HP_MODE_CTRL2: q paramter in training period of phase offset iir of bmc
	// Position of SNR_EST_REF field.
	BLEDP_HP_MODE_CTRL2_SNR_EST_REF_Pos = 0x0
	// Bit mask of SNR_EST_REF field.
	BLEDP_HP_MODE_CTRL2_SNR_EST_REF_Msk = 0xff
	// Position of SNR_EST_LEN field.
	BLEDP_HP_MODE_CTRL2_SNR_EST_LEN_Pos = 0x8
	// Bit mask of SNR_EST_LEN field.
	BLEDP_HP_MODE_CTRL2_SNR_EST_LEN_Msk = 0x300
	// Position of SNR_EST_EN field.
	BLEDP_HP_MODE_CTRL2_SNR_EST_EN_Pos = 0xc
	// Bit mask of SNR_EST_EN field.
	BLEDP_HP_MODE_CTRL2_SNR_EST_EN_Msk = 0x1000
	// Bit SNR_EST_EN.
	BLEDP_HP_MODE_CTRL2_SNR_EST_EN = 0x1000
	// Position of HP_BMC_Q_TRACK field.
	BLEDP_HP_MODE_CTRL2_HP_BMC_Q_TRACK_Pos = 0x10
	// Bit mask of HP_BMC_Q_TRACK field.
	BLEDP_HP_MODE_CTRL2_HP_BMC_Q_TRACK_Msk = 0xff0000
	// Position of HP_BMC_Q_TRAIN field.
	BLEDP_HP_MODE_CTRL2_HP_BMC_Q_TRAIN_Pos = 0x18
	// Bit mask of HP_BMC_Q_TRAIN field.
	BLEDP_HP_MODE_CTRL2_HP_BMC_Q_TRAIN_Msk = 0xff000000

	// FREQ_DOMAIN_STATUS1: frequency domain status register 1
	// Position of MAX_XCORR field.
	BLEDP_FREQ_DOMAIN_STATUS1_MAX_XCORR_Pos = 0x0
	// Bit mask of MAX_XCORR field.
	BLEDP_FREQ_DOMAIN_STATUS1_MAX_XCORR_Msk = 0x3ff
	// Position of PKT_OFFSET_COM field.
	BLEDP_FREQ_DOMAIN_STATUS1_PKT_OFFSET_COM_Pos = 0x10
	// Bit mask of PKT_OFFSET_COM field.
	BLEDP_FREQ_DOMAIN_STATUS1_PKT_OFFSET_COM_Msk = 0x1ff0000
	// Position of NIDX field.
	BLEDP_FREQ_DOMAIN_STATUS1_NIDX_Pos = 0x1c
	// Bit mask of NIDX field.
	BLEDP_FREQ_DOMAIN_STATUS1_NIDX_Msk = 0xf0000000

	// FREQ_DOMAIN_STATUS2: frequency domain status register 2
	// Position of MAX_PAR_SPWR field.
	BLEDP_FREQ_DOMAIN_STATUS2_MAX_PAR_SPWR_Pos = 0x0
	// Bit mask of MAX_PAR_SPWR field.
	BLEDP_FREQ_DOMAIN_STATUS2_MAX_PAR_SPWR_Msk = 0x3ff
	// Position of MAX_PAR_XCORR field.
	BLEDP_FREQ_DOMAIN_STATUS2_MAX_PAR_XCORR_Pos = 0x10
	// Bit mask of MAX_PAR_XCORR field.
	BLEDP_FREQ_DOMAIN_STATUS2_MAX_PAR_XCORR_Msk = 0x3ff0000

	// DP_AA_ERROR_CTRL: AA error control register
	// Position of IQSWAP_SEL field.
	BLEDP_DP_AA_ERROR_CTRL_IQSWAP_SEL_Pos = 0x0
	// Bit mask of IQSWAP_SEL field.
	BLEDP_DP_AA_ERROR_CTRL_IQSWAP_SEL_Msk = 0x1
	// Bit IQSWAP_SEL.
	BLEDP_DP_AA_ERROR_CTRL_IQSWAP_SEL = 0x1
	// Position of AA_ERROR_EN field.
	BLEDP_DP_AA_ERROR_CTRL_AA_ERROR_EN_Pos = 0x1
	// Bit mask of AA_ERROR_EN field.
	BLEDP_DP_AA_ERROR_CTRL_AA_ERROR_EN_Msk = 0x2
	// Bit AA_ERROR_EN.
	BLEDP_DP_AA_ERROR_CTRL_AA_ERROR_EN = 0x2
	// Position of AA_ERROR_CNR_EN field.
	BLEDP_DP_AA_ERROR_CTRL_AA_ERROR_CNR_EN_Pos = 0x2
	// Bit mask of AA_ERROR_CNR_EN field.
	BLEDP_DP_AA_ERROR_CTRL_AA_ERROR_CNR_EN_Msk = 0x4
	// Bit AA_ERROR_CNR_EN.
	BLEDP_DP_AA_ERROR_CTRL_AA_ERROR_CNR_EN = 0x4
	// Position of AA_ERROR_CNR_SEL field.
	BLEDP_DP_AA_ERROR_CTRL_AA_ERROR_CNR_SEL_Pos = 0x3
	// Bit mask of AA_ERROR_CNR_SEL field.
	BLEDP_DP_AA_ERROR_CTRL_AA_ERROR_CNR_SEL_Msk = 0x8
	// Bit AA_ERROR_CNR_SEL.
	BLEDP_DP_AA_ERROR_CTRL_AA_ERROR_CNR_SEL = 0x8

	// DP_INT: data path interrupt register
	// Position of DP_INTERRUPT0 field.
	BLEDP_DP_INT_DP_INTERRUPT0_Pos = 0x0
	// Bit mask of DP_INTERRUPT0 field.
	BLEDP_DP_INT_DP_INTERRUPT0_Msk = 0x1
	// Bit DP_INTERRUPT0.
	BLEDP_DP_INT_DP_INTERRUPT0 = 0x1
	// Position of DP_INTERRUPT1 field.
	BLEDP_DP_INT_DP_INTERRUPT1_Pos = 0x1
	// Bit mask of DP_INTERRUPT1 field.
	BLEDP_DP_INT_DP_INTERRUPT1_Msk = 0x2
	// Bit DP_INTERRUPT1.
	BLEDP_DP_INT_DP_INTERRUPT1 = 0x2
	// Position of DP_INTERRUPT2 field.
	BLEDP_DP_INT_DP_INTERRUPT2_Pos = 0x2
	// Bit mask of DP_INTERRUPT2 field.
	BLEDP_DP_INT_DP_INTERRUPT2_Msk = 0x4
	// Bit DP_INTERRUPT2.
	BLEDP_DP_INT_DP_INTERRUPT2 = 0x4
	// Position of DP_INTERRUPT field.
	BLEDP_DP_INT_DP_INTERRUPT_Pos = 0x3
	// Bit mask of DP_INTERRUPT field.
	BLEDP_DP_INT_DP_INTERRUPT_Msk = 0x8
	// Bit DP_INTERRUPT.
	BLEDP_DP_INT_DP_INTERRUPT = 0x8
	// Position of DP_INTERRUPT0_SEL field.
	BLEDP_DP_INT_DP_INTERRUPT0_SEL_Pos = 0x10
	// Bit mask of DP_INTERRUPT0_SEL field.
	BLEDP_DP_INT_DP_INTERRUPT0_SEL_Msk = 0xf0000
	// Position of DP_INTERRUPT1_SEL field.
	BLEDP_DP_INT_DP_INTERRUPT1_SEL_Pos = 0x14
	// Bit mask of DP_INTERRUPT1_SEL field.
	BLEDP_DP_INT_DP_INTERRUPT1_SEL_Msk = 0xf00000
	// Position of DP_INTERRUPT2_SEL field.
	BLEDP_DP_INT_DP_INTERRUPT2_SEL_Pos = 0x18
	// Bit mask of DP_INTERRUPT2_SEL field.
	BLEDP_DP_INT_DP_INTERRUPT2_SEL_Msk = 0xf000000
	// Position of DP_INTERRUPT0_MSK field.
	BLEDP_DP_INT_DP_INTERRUPT0_MSK_Pos = 0x1c
	// Bit mask of DP_INTERRUPT0_MSK field.
	BLEDP_DP_INT_DP_INTERRUPT0_MSK_Msk = 0x10000000
	// Bit DP_INTERRUPT0_MSK.
	BLEDP_DP_INT_DP_INTERRUPT0_MSK = 0x10000000
	// Position of DP_INTERRUPT1_MSK field.
	BLEDP_DP_INT_DP_INTERRUPT1_MSK_Pos = 0x1d
	// Bit mask of DP_INTERRUPT1_MSK field.
	BLEDP_DP_INT_DP_INTERRUPT1_MSK_Msk = 0x20000000
	// Bit DP_INTERRUPT1_MSK.
	BLEDP_DP_INT_DP_INTERRUPT1_MSK = 0x20000000
	// Position of DP_INTERRUPT2_MSK field.
	BLEDP_DP_INT_DP_INTERRUPT2_MSK_Pos = 0x1e
	// Bit mask of DP_INTERRUPT2_MSK field.
	BLEDP_DP_INT_DP_INTERRUPT2_MSK_Msk = 0x40000000
	// Bit DP_INTERRUPT2_MSK.
	BLEDP_DP_INT_DP_INTERRUPT2_MSK = 0x40000000
	// Position of DP_INTERRUPT_MSK field.
	BLEDP_DP_INT_DP_INTERRUPT_MSK_Pos = 0x1f
	// Bit mask of DP_INTERRUPT_MSK field.
	BLEDP_DP_INT_DP_INTERRUPT_MSK_Msk = 0x80000000
	// Bit DP_INTERRUPT_MSK.
	BLEDP_DP_INT_DP_INTERRUPT_MSK = 0x80000000

	// DP_AA_ERROR_TH: AA error threshold register
	// Position of HP_TRAIN_POSITION field.
	BLEDP_DP_AA_ERROR_TH_HP_TRAIN_POSITION_Pos = 0x0
	// Bit mask of HP_TRAIN_POSITION field.
	BLEDP_DP_AA_ERROR_TH_HP_TRAIN_POSITION_Msk = 0x1
	// Bit HP_TRAIN_POSITION.
	BLEDP_DP_AA_ERROR_TH_HP_TRAIN_POSITION = 0x1
	// Position of CORDIC_IN_SCALE field.
	BLEDP_DP_AA_ERROR_TH_CORDIC_IN_SCALE_Pos = 0x1
	// Bit mask of CORDIC_IN_SCALE field.
	BLEDP_DP_AA_ERROR_TH_CORDIC_IN_SCALE_Msk = 0x2
	// Bit CORDIC_IN_SCALE.
	BLEDP_DP_AA_ERROR_TH_CORDIC_IN_SCALE = 0x2
	// Position of PAR_AUTO_HIGHER_SEL field.
	BLEDP_DP_AA_ERROR_TH_PAR_AUTO_HIGHER_SEL_Pos = 0x2
	// Bit mask of PAR_AUTO_HIGHER_SEL field.
	BLEDP_DP_AA_ERROR_TH_PAR_AUTO_HIGHER_SEL_Msk = 0x4
	// Bit PAR_AUTO_HIGHER_SEL.
	BLEDP_DP_AA_ERROR_TH_PAR_AUTO_HIGHER_SEL = 0x4
	// Position of PAR_AUTO_HIGHER_EN field.
	BLEDP_DP_AA_ERROR_TH_PAR_AUTO_HIGHER_EN_Pos = 0x3
	// Bit mask of PAR_AUTO_HIGHER_EN field.
	BLEDP_DP_AA_ERROR_TH_PAR_AUTO_HIGHER_EN_Msk = 0x8
	// Bit PAR_AUTO_HIGHER_EN.
	BLEDP_DP_AA_ERROR_TH_PAR_AUTO_HIGHER_EN = 0x8
	// Position of SNR_GOOD_TH field.
	BLEDP_DP_AA_ERROR_TH_SNR_GOOD_TH_Pos = 0x4
	// Bit mask of SNR_GOOD_TH field.
	BLEDP_DP_AA_ERROR_TH_SNR_GOOD_TH_Msk = 0x70
	// Position of CNR_GOOD_TH field.
	BLEDP_DP_AA_ERROR_TH_CNR_GOOD_TH_Pos = 0x8
	// Bit mask of CNR_GOOD_TH field.
	BLEDP_DP_AA_ERROR_TH_CNR_GOOD_TH_Msk = 0x3f00
	// Position of RSSI_GOOD_TH field.
	BLEDP_DP_AA_ERROR_TH_RSSI_GOOD_TH_Pos = 0x10
	// Bit mask of RSSI_GOOD_TH field.
	BLEDP_DP_AA_ERROR_TH_RSSI_GOOD_TH_Msk = 0xff0000
	// Position of RSSI_GOOD_DBM field.
	BLEDP_DP_AA_ERROR_TH_RSSI_GOOD_DBM_Pos = 0x18
	// Bit mask of RSSI_GOOD_DBM field.
	BLEDP_DP_AA_ERROR_TH_RSSI_GOOD_DBM_Msk = 0xff000000

	// DF_ANTENNA_CTRL: antenna register
	// Position of SWITCH_MAP_SEL_8F field.
	BLEDP_DF_ANTENNA_CTRL_SWITCH_MAP_SEL_8F_Pos = 0x0
	// Bit mask of SWITCH_MAP_SEL_8F field.
	BLEDP_DF_ANTENNA_CTRL_SWITCH_MAP_SEL_8F_Msk = 0x3
	// Position of SWITCH_MAP_SEL_07 field.
	BLEDP_DF_ANTENNA_CTRL_SWITCH_MAP_SEL_07_Pos = 0x2
	// Bit mask of SWITCH_MAP_SEL_07 field.
	BLEDP_DF_ANTENNA_CTRL_SWITCH_MAP_SEL_07_Msk = 0xc
	// Position of EXT_ANTENNA_NUM field.
	BLEDP_DF_ANTENNA_CTRL_EXT_ANTENNA_NUM_Pos = 0x4
	// Bit mask of EXT_ANTENNA_NUM field.
	BLEDP_DF_ANTENNA_CTRL_EXT_ANTENNA_NUM_Msk = 0xf0
	// Position of EXT_ANTENNA_NUM_WEN field.
	BLEDP_DF_ANTENNA_CTRL_EXT_ANTENNA_NUM_WEN_Pos = 0x8
	// Bit mask of EXT_ANTENNA_NUM_WEN field.
	BLEDP_DF_ANTENNA_CTRL_EXT_ANTENNA_NUM_WEN_Msk = 0x100
	// Bit EXT_ANTENNA_NUM_WEN.
	BLEDP_DF_ANTENNA_CTRL_EXT_ANTENNA_NUM_WEN = 0x100
	// Position of BUFFER_BP field.
	BLEDP_DF_ANTENNA_CTRL_BUFFER_BP_Pos = 0x10
	// Bit mask of BUFFER_BP field.
	BLEDP_DF_ANTENNA_CTRL_BUFFER_BP_Msk = 0x10000
	// Bit BUFFER_BP.
	BLEDP_DF_ANTENNA_CTRL_BUFFER_BP = 0x10000
	// Position of TEST_TD_POWER field.
	BLEDP_DF_ANTENNA_CTRL_TEST_TD_POWER_Pos = 0x11
	// Bit mask of TEST_TD_POWER field.
	BLEDP_DF_ANTENNA_CTRL_TEST_TD_POWER_Msk = 0x20000
	// Bit TEST_TD_POWER.
	BLEDP_DF_ANTENNA_CTRL_TEST_TD_POWER = 0x20000
	// Position of TEST_FD_POWER field.
	BLEDP_DF_ANTENNA_CTRL_TEST_FD_POWER_Pos = 0x12
	// Bit mask of TEST_FD_POWER field.
	BLEDP_DF_ANTENNA_CTRL_TEST_FD_POWER_Msk = 0x40000
	// Bit TEST_FD_POWER.
	BLEDP_DF_ANTENNA_CTRL_TEST_FD_POWER = 0x40000
	// Position of TEST_SYNC_POWER field.
	BLEDP_DF_ANTENNA_CTRL_TEST_SYNC_POWER_Pos = 0x13
	// Bit mask of TEST_SYNC_POWER field.
	BLEDP_DF_ANTENNA_CTRL_TEST_SYNC_POWER_Msk = 0x80000
	// Bit TEST_SYNC_POWER.
	BLEDP_DF_ANTENNA_CTRL_TEST_SYNC_POWER = 0x80000
	// Position of TEST_RFE_CORDIC_POWER field.
	BLEDP_DF_ANTENNA_CTRL_TEST_RFE_CORDIC_POWER_Pos = 0x14
	// Bit mask of TEST_RFE_CORDIC_POWER field.
	BLEDP_DF_ANTENNA_CTRL_TEST_RFE_CORDIC_POWER_Msk = 0x100000
	// Bit TEST_RFE_CORDIC_POWER.
	BLEDP_DF_ANTENNA_CTRL_TEST_RFE_CORDIC_POWER = 0x100000
	// Position of TEST_RFE_POWER field.
	BLEDP_DF_ANTENNA_CTRL_TEST_RFE_POWER_Pos = 0x15
	// Bit mask of TEST_RFE_POWER field.
	BLEDP_DF_ANTENNA_CTRL_TEST_RFE_POWER_Msk = 0x200000
	// Bit TEST_RFE_POWER.
	BLEDP_DF_ANTENNA_CTRL_TEST_RFE_POWER = 0x200000
	// Position of ADC01_SAMPLE_TIME field.
	BLEDP_DF_ANTENNA_CTRL_ADC01_SAMPLE_TIME_Pos = 0x16
	// Bit mask of ADC01_SAMPLE_TIME field.
	BLEDP_DF_ANTENNA_CTRL_ADC01_SAMPLE_TIME_Msk = 0x400000
	// Bit ADC01_SAMPLE_TIME.
	BLEDP_DF_ANTENNA_CTRL_ADC01_SAMPLE_TIME = 0x400000
	// Position of PHY_RATE_MUX field.
	BLEDP_DF_ANTENNA_CTRL_PHY_RATE_MUX_Pos = 0x17
	// Bit mask of PHY_RATE_MUX field.
	BLEDP_DF_ANTENNA_CTRL_PHY_RATE_MUX_Msk = 0x800000
	// Bit PHY_RATE_MUX.
	BLEDP_DF_ANTENNA_CTRL_PHY_RATE_MUX = 0x800000
	// Position of PHY_RATE_REG field.
	BLEDP_DF_ANTENNA_CTRL_PHY_RATE_REG_Pos = 0x18
	// Bit mask of PHY_RATE_REG field.
	BLEDP_DF_ANTENNA_CTRL_PHY_RATE_REG_Msk = 0x1000000
	// Bit PHY_RATE_REG.
	BLEDP_DF_ANTENNA_CTRL_PHY_RATE_REG = 0x1000000
	// Position of PHY_RATE_WEN field.
	BLEDP_DF_ANTENNA_CTRL_PHY_RATE_WEN_Pos = 0x19
	// Bit mask of PHY_RATE_WEN field.
	BLEDP_DF_ANTENNA_CTRL_PHY_RATE_WEN_Msk = 0x2000000
	// Bit PHY_RATE_WEN.
	BLEDP_DF_ANTENNA_CTRL_PHY_RATE_WEN = 0x2000000
	// Position of PDU_RSSI_WAIT_TIME field.
	BLEDP_DF_ANTENNA_CTRL_PDU_RSSI_WAIT_TIME_Pos = 0x1a
	// Bit mask of PDU_RSSI_WAIT_TIME field.
	BLEDP_DF_ANTENNA_CTRL_PDU_RSSI_WAIT_TIME_Msk = 0x4000000
	// Bit PDU_RSSI_WAIT_TIME.
	BLEDP_DF_ANTENNA_CTRL_PDU_RSSI_WAIT_TIME = 0x4000000
	// Position of PDU_RSSI_WIN_LEN field.
	BLEDP_DF_ANTENNA_CTRL_PDU_RSSI_WIN_LEN_Pos = 0x1b
	// Bit mask of PDU_RSSI_WIN_LEN field.
	BLEDP_DF_ANTENNA_CTRL_PDU_RSSI_WIN_LEN_Msk = 0x8000000
	// Bit PDU_RSSI_WIN_LEN.
	BLEDP_DF_ANTENNA_CTRL_PDU_RSSI_WIN_LEN = 0x8000000
	// Position of CAL_PDU_RSSI_EN field.
	BLEDP_DF_ANTENNA_CTRL_CAL_PDU_RSSI_EN_Pos = 0x1c
	// Bit mask of CAL_PDU_RSSI_EN field.
	BLEDP_DF_ANTENNA_CTRL_CAL_PDU_RSSI_EN_Msk = 0x10000000
	// Bit CAL_PDU_RSSI_EN.
	BLEDP_DF_ANTENNA_CTRL_CAL_PDU_RSSI_EN = 0x10000000
	// Position of PROP_CRC_AA_DIS field.
	BLEDP_DF_ANTENNA_CTRL_PROP_CRC_AA_DIS_Pos = 0x1d
	// Bit mask of PROP_CRC_AA_DIS field.
	BLEDP_DF_ANTENNA_CTRL_PROP_CRC_AA_DIS_Msk = 0x20000000
	// Bit PROP_CRC_AA_DIS.
	BLEDP_DF_ANTENNA_CTRL_PROP_CRC_AA_DIS = 0x20000000
	// Position of PROP_AA_LSB_FIRST field.
	BLEDP_DF_ANTENNA_CTRL_PROP_AA_LSB_FIRST_Pos = 0x1e
	// Bit mask of PROP_AA_LSB_FIRST field.
	BLEDP_DF_ANTENNA_CTRL_PROP_AA_LSB_FIRST_Msk = 0x40000000
	// Bit PROP_AA_LSB_FIRST.
	BLEDP_DF_ANTENNA_CTRL_PROP_AA_LSB_FIRST = 0x40000000
	// Position of PRE_NUM_WEN field.
	BLEDP_DF_ANTENNA_CTRL_PRE_NUM_WEN_Pos = 0x1f
	// Bit mask of PRE_NUM_WEN field.
	BLEDP_DF_ANTENNA_CTRL_PRE_NUM_WEN_Msk = 0x80000000
	// Bit PRE_NUM_WEN.
	BLEDP_DF_ANTENNA_CTRL_PRE_NUM_WEN = 0x80000000

	// ANTENNA_MAP01: antenna switch map register 0
	// Position of SWITCH_MAP_1 field.
	BLEDP_ANTENNA_MAP01_SWITCH_MAP_1_Pos = 0x0
	// Bit mask of SWITCH_MAP_1 field.
	BLEDP_ANTENNA_MAP01_SWITCH_MAP_1_Msk = 0x3fff
	// Position of SWITCH_MAP_0 field.
	BLEDP_ANTENNA_MAP01_SWITCH_MAP_0_Pos = 0x10
	// Bit mask of SWITCH_MAP_0 field.
	BLEDP_ANTENNA_MAP01_SWITCH_MAP_0_Msk = 0x3fff0000

	// ANTENNA_MAP23: antenna switch map register 1
	// Position of SWITCH_MAP_3 field.
	BLEDP_ANTENNA_MAP23_SWITCH_MAP_3_Pos = 0x0
	// Bit mask of SWITCH_MAP_3 field.
	BLEDP_ANTENNA_MAP23_SWITCH_MAP_3_Msk = 0x3fff
	// Position of SWITCH_MAP_2 field.
	BLEDP_ANTENNA_MAP23_SWITCH_MAP_2_Pos = 0x10
	// Bit mask of SWITCH_MAP_2 field.
	BLEDP_ANTENNA_MAP23_SWITCH_MAP_2_Msk = 0x3fff0000

	// ANTENNA_MAP45: antenna switch map register 2
	// Position of SWITCH_MAP_5 field.
	BLEDP_ANTENNA_MAP45_SWITCH_MAP_5_Pos = 0x0
	// Bit mask of SWITCH_MAP_5 field.
	BLEDP_ANTENNA_MAP45_SWITCH_MAP_5_Msk = 0x3fff
	// Position of SWITCH_MAP_4 field.
	BLEDP_ANTENNA_MAP45_SWITCH_MAP_4_Pos = 0x10
	// Bit mask of SWITCH_MAP_4 field.
	BLEDP_ANTENNA_MAP45_SWITCH_MAP_4_Msk = 0x3fff0000

	// ANTENNA_MAP67: antenna switch map register 3
	// Position of SWITCH_MAP_7 field.
	BLEDP_ANTENNA_MAP67_SWITCH_MAP_7_Pos = 0x0
	// Bit mask of SWITCH_MAP_7 field.
	BLEDP_ANTENNA_MAP67_SWITCH_MAP_7_Msk = 0x3fff
	// Position of SWITCH_MAP_6 field.
	BLEDP_ANTENNA_MAP67_SWITCH_MAP_6_Pos = 0x10
	// Bit mask of SWITCH_MAP_6 field.
	BLEDP_ANTENNA_MAP67_SWITCH_MAP_6_Msk = 0x3fff0000
)

// Constants for CALIB: calib
const (
	// START: calibration start register
	// Position of PO_CLB_START field.
	CALIB_START_PO_CLB_START_Pos = 0x0
	// Bit mask of PO_CLB_START field.
	CALIB_START_PO_CLB_START_Msk = 0x1
	// Bit PO_CLB_START.
	CALIB_START_PO_CLB_START = 0x1
	// Position of HOP_CLB_START field.
	CALIB_START_HOP_CLB_START_Pos = 0x1
	// Bit mask of HOP_CLB_START field.
	CALIB_START_HOP_CLB_START_Msk = 0x2
	// Bit HOP_CLB_START.
	CALIB_START_HOP_CLB_START = 0x2
	// Position of OSC_CLB_START field.
	CALIB_START_OSC_CLB_START_Pos = 0x2
	// Bit mask of OSC_CLB_START field.
	CALIB_START_OSC_CLB_START_Msk = 0x4
	// Bit OSC_CLB_START.
	CALIB_START_OSC_CLB_START = 0x4
	// Position of REF_CLB_START field.
	CALIB_START_REF_CLB_START_Pos = 0x3
	// Bit mask of REF_CLB_START field.
	CALIB_START_REF_CLB_START_Msk = 0x8
	// Bit REF_CLB_START.
	CALIB_START_REF_CLB_START = 0x8
	// Position of RCO_CLB_START field.
	CALIB_START_RCO_CLB_START_Pos = 0x4
	// Bit mask of RCO_CLB_START field.
	CALIB_START_RCO_CLB_START_Msk = 0x10
	// Bit RCO_CLB_START.
	CALIB_START_RCO_CLB_START = 0x10
	// Position of XTL_CLB_START field.
	CALIB_START_XTL_CLB_START_Pos = 0x5
	// Bit mask of XTL_CLB_START field.
	CALIB_START_XTL_CLB_START_Msk = 0x20
	// Bit XTL_CLB_START.
	CALIB_START_XTL_CLB_START = 0x20

	// STATUS: calibration FSM status register
	// Position of TOP_FSM field.
	CALIB_STATUS_TOP_FSM_Pos = 0x0
	// Bit mask of TOP_FSM field.
	CALIB_STATUS_TOP_FSM_Msk = 0x1f
	// Position of DC_FSM field.
	CALIB_STATUS_DC_FSM_Pos = 0x5
	// Bit mask of DC_FSM field.
	CALIB_STATUS_DC_FSM_Msk = 0x1e0
	// Position of VCOA_FSM field.
	CALIB_STATUS_VCOA_FSM_Pos = 0x9
	// Bit mask of VCOA_FSM field.
	CALIB_STATUS_VCOA_FSM_Msk = 0xe00
	// Position of VCOF_FSM field.
	CALIB_STATUS_VCOF_FSM_Pos = 0xc
	// Bit mask of VCOF_FSM field.
	CALIB_STATUS_VCOF_FSM_Msk = 0x1f000
	// Position of KVCO_FSM field.
	CALIB_STATUS_KVCO_FSM_Pos = 0x11
	// Bit mask of KVCO_FSM field.
	CALIB_STATUS_KVCO_FSM_Msk = 0x1e0000
	// Position of RCO_FSM field.
	CALIB_STATUS_RCO_FSM_Pos = 0x15
	// Bit mask of RCO_FSM field.
	CALIB_STATUS_RCO_FSM_Msk = 0xe00000
	// Position of OSC_FSM field.
	CALIB_STATUS_OSC_FSM_Pos = 0x18
	// Bit mask of OSC_FSM field.
	CALIB_STATUS_OSC_FSM_Msk = 0x7000000
	// Position of REF_FSM field.
	CALIB_STATUS_REF_FSM_Pos = 0x1b
	// Bit mask of REF_FSM field.
	CALIB_STATUS_REF_FSM_Msk = 0x38000000

	// DC_CODE: DC code status register
	// Position of PPF_DCCAL2_I field.
	CALIB_DC_CODE_PPF_DCCAL2_I_Pos = 0x0
	// Bit mask of PPF_DCCAL2_I field.
	CALIB_DC_CODE_PPF_DCCAL2_I_Msk = 0xf
	// Position of PPF_DCCAL2_Q field.
	CALIB_DC_CODE_PPF_DCCAL2_Q_Pos = 0x4
	// Bit mask of PPF_DCCAL2_Q field.
	CALIB_DC_CODE_PPF_DCCAL2_Q_Msk = 0xf0
	// Position of PPF_DCCAL_I field.
	CALIB_DC_CODE_PPF_DCCAL_I_Pos = 0x10
	// Bit mask of PPF_DCCAL_I field.
	CALIB_DC_CODE_PPF_DCCAL_I_Msk = 0x3f0000
	// Position of PPF_DCCAL_Q field.
	CALIB_DC_CODE_PPF_DCCAL_Q_Pos = 0x18
	// Bit mask of PPF_DCCAL_Q field.
	CALIB_DC_CODE_PPF_DCCAL_Q_Msk = 0x3f000000

	// DC_CFG: DC code configured code register
	// Position of PPF_DCCAL2_CFG_I field.
	CALIB_DC_CFG_PPF_DCCAL2_CFG_I_Pos = 0x0
	// Bit mask of PPF_DCCAL2_CFG_I field.
	CALIB_DC_CFG_PPF_DCCAL2_CFG_I_Msk = 0xf
	// Position of PPF_DCCAL2_CFG_Q field.
	CALIB_DC_CFG_PPF_DCCAL2_CFG_Q_Pos = 0x4
	// Bit mask of PPF_DCCAL2_CFG_Q field.
	CALIB_DC_CFG_PPF_DCCAL2_CFG_Q_Msk = 0xf0
	// Position of DC_2NDCAL_DIS field.
	CALIB_DC_CFG_DC_2NDCAL_DIS_Pos = 0x8
	// Bit mask of DC_2NDCAL_DIS field.
	CALIB_DC_CFG_DC_2NDCAL_DIS_Msk = 0x100
	// Bit DC_2NDCAL_DIS.
	CALIB_DC_CFG_DC_2NDCAL_DIS = 0x100
	// Position of DC_2NDCAL_REQ field.
	CALIB_DC_CFG_DC_2NDCAL_REQ_Pos = 0x9
	// Bit mask of DC_2NDCAL_REQ field.
	CALIB_DC_CFG_DC_2NDCAL_REQ_Msk = 0x200
	// Bit DC_2NDCAL_REQ.
	CALIB_DC_CFG_DC_2NDCAL_REQ = 0x200
	// Position of PPF_DCCAL_CFG_I field.
	CALIB_DC_CFG_PPF_DCCAL_CFG_I_Pos = 0x10
	// Bit mask of PPF_DCCAL_CFG_I field.
	CALIB_DC_CFG_PPF_DCCAL_CFG_I_Msk = 0x3f0000
	// Position of DC_HOP_CAL_BP field.
	CALIB_DC_CFG_DC_HOP_CAL_BP_Pos = 0x16
	// Bit mask of DC_HOP_CAL_BP field.
	CALIB_DC_CFG_DC_HOP_CAL_BP_Msk = 0x400000
	// Bit DC_HOP_CAL_BP.
	CALIB_DC_CFG_DC_HOP_CAL_BP = 0x400000
	// Position of PPF_DCCAL_CFG_Q field.
	CALIB_DC_CFG_PPF_DCCAL_CFG_Q_Pos = 0x18
	// Bit mask of PPF_DCCAL_CFG_Q field.
	CALIB_DC_CFG_PPF_DCCAL_CFG_Q_Msk = 0x3f000000
	// Position of DC_1STCAL_DIS field.
	CALIB_DC_CFG_DC_1STCAL_DIS_Pos = 0x1e
	// Bit mask of DC_1STCAL_DIS field.
	CALIB_DC_CFG_DC_1STCAL_DIS_Msk = 0x40000000
	// Bit DC_1STCAL_DIS.
	CALIB_DC_CFG_DC_1STCAL_DIS = 0x40000000
	// Position of DC_1STCAL_REQ field.
	CALIB_DC_CFG_DC_1STCAL_REQ_Pos = 0x1f
	// Bit mask of DC_1STCAL_REQ field.
	CALIB_DC_CFG_DC_1STCAL_REQ_Msk = 0x80000000
	// Bit DC_1STCAL_REQ.
	CALIB_DC_CFG_DC_1STCAL_REQ = 0x80000000

	// RCO_RC_REF_OSC_CODE: RCO RC PLL48M OSC code status register
	// Position of CAU_RCO_CAP field.
	CALIB_RCO_RC_REF_OSC_CODE_CAU_RCO_CAP_Pos = 0x0
	// Bit mask of CAU_RCO_CAP field.
	CALIB_RCO_RC_REF_OSC_CODE_CAU_RCO_CAP_Msk = 0xf
	// Position of CAU_OSC_CUR field.
	CALIB_RCO_RC_REF_OSC_CODE_CAU_OSC_CUR_Pos = 0x8
	// Bit mask of CAU_OSC_CUR field.
	CALIB_RCO_RC_REF_OSC_CODE_CAU_OSC_CUR_Msk = 0x1f00
	// Position of CAU_RC_CAL_OUT2REG field.
	CALIB_RCO_RC_REF_OSC_CODE_CAU_RC_CAL_OUT2REG_Pos = 0x10
	// Bit mask of CAU_RC_CAL_OUT2REG field.
	CALIB_RCO_RC_REF_OSC_CODE_CAU_RC_CAL_OUT2REG_Msk = 0xf0000
	// Position of PLL48_ENREF field.
	CALIB_RCO_RC_REF_OSC_CODE_PLL48_ENREF_Pos = 0x18
	// Bit mask of PLL48_ENREF field.
	CALIB_RCO_RC_REF_OSC_CODE_PLL48_ENREF_Msk = 0xf000000

	// RCO_RC_REF_OSC_CFG: RCO RC PLL48M OSC configured code register
	// Position of CAU_RCO_CAP_CFG field.
	CALIB_RCO_RC_REF_OSC_CFG_CAU_RCO_CAP_CFG_Pos = 0x0
	// Bit mask of CAU_RCO_CAP_CFG field.
	CALIB_RCO_RC_REF_OSC_CFG_CAU_RCO_CAP_CFG_Msk = 0xf
	// Position of RCO_CAL_DIS field.
	CALIB_RCO_RC_REF_OSC_CFG_RCO_CAL_DIS_Pos = 0x4
	// Bit mask of RCO_CAL_DIS field.
	CALIB_RCO_RC_REF_OSC_CFG_RCO_CAL_DIS_Msk = 0x10
	// Bit RCO_CAL_DIS.
	CALIB_RCO_RC_REF_OSC_CFG_RCO_CAL_DIS = 0x10
	// Position of RCO_CAL_REQ field.
	CALIB_RCO_RC_REF_OSC_CFG_RCO_CAL_REQ_Pos = 0x5
	// Bit mask of RCO_CAL_REQ field.
	CALIB_RCO_RC_REF_OSC_CFG_RCO_CAL_REQ_Msk = 0x20
	// Bit RCO_CAL_REQ.
	CALIB_RCO_RC_REF_OSC_CFG_RCO_CAL_REQ = 0x20
	// Position of CAU_OSC_CUR_CFG field.
	CALIB_RCO_RC_REF_OSC_CFG_CAU_OSC_CUR_CFG_Pos = 0x8
	// Bit mask of CAU_OSC_CUR_CFG field.
	CALIB_RCO_RC_REF_OSC_CFG_CAU_OSC_CUR_CFG_Msk = 0x1f00
	// Position of OSC_CAL_DIS field.
	CALIB_RCO_RC_REF_OSC_CFG_OSC_CAL_DIS_Pos = 0xd
	// Bit mask of OSC_CAL_DIS field.
	CALIB_RCO_RC_REF_OSC_CFG_OSC_CAL_DIS_Msk = 0x2000
	// Bit OSC_CAL_DIS.
	CALIB_RCO_RC_REF_OSC_CFG_OSC_CAL_DIS = 0x2000
	// Position of OSC_CAL_REQ field.
	CALIB_RCO_RC_REF_OSC_CFG_OSC_CAL_REQ_Pos = 0xe
	// Bit mask of OSC_CAL_REQ field.
	CALIB_RCO_RC_REF_OSC_CFG_OSC_CAL_REQ_Msk = 0x4000
	// Bit OSC_CAL_REQ.
	CALIB_RCO_RC_REF_OSC_CFG_OSC_CAL_REQ = 0x4000
	// Position of CAU_RC_CAL_REG_IN field.
	CALIB_RCO_RC_REF_OSC_CFG_CAU_RC_CAL_REG_IN_Pos = 0x10
	// Bit mask of CAU_RC_CAL_REG_IN field.
	CALIB_RCO_RC_REF_OSC_CFG_CAU_RC_CAL_REG_IN_Msk = 0xf0000
	// Position of CAU_RC_CAL_DIS field.
	CALIB_RCO_RC_REF_OSC_CFG_CAU_RC_CAL_DIS_Pos = 0x14
	// Bit mask of CAU_RC_CAL_DIS field.
	CALIB_RCO_RC_REF_OSC_CFG_CAU_RC_CAL_DIS_Msk = 0x100000
	// Bit CAU_RC_CAL_DIS.
	CALIB_RCO_RC_REF_OSC_CFG_CAU_RC_CAL_DIS = 0x100000
	// Position of RC_CAL_REQ field.
	CALIB_RCO_RC_REF_OSC_CFG_RC_CAL_REQ_Pos = 0x15
	// Bit mask of RC_CAL_REQ field.
	CALIB_RCO_RC_REF_OSC_CFG_RC_CAL_REQ_Msk = 0x200000
	// Bit RC_CAL_REQ.
	CALIB_RCO_RC_REF_OSC_CFG_RC_CAL_REQ = 0x200000
	// Position of PLL48_ENREF_CFG field.
	CALIB_RCO_RC_REF_OSC_CFG_PLL48_ENREF_CFG_Pos = 0x18
	// Bit mask of PLL48_ENREF_CFG field.
	CALIB_RCO_RC_REF_OSC_CFG_PLL48_ENREF_CFG_Msk = 0xf000000
	// Position of REF_CAL_DIS field.
	CALIB_RCO_RC_REF_OSC_CFG_REF_CAL_DIS_Pos = 0x1c
	// Bit mask of REF_CAL_DIS field.
	CALIB_RCO_RC_REF_OSC_CFG_REF_CAL_DIS_Msk = 0x10000000
	// Bit REF_CAL_DIS.
	CALIB_RCO_RC_REF_OSC_CFG_REF_CAL_DIS = 0x10000000
	// Position of REF_CAL_REQ field.
	CALIB_RCO_RC_REF_OSC_CFG_REF_CAL_REQ_Pos = 0x1d
	// Bit mask of REF_CAL_REQ field.
	CALIB_RCO_RC_REF_OSC_CFG_REF_CAL_REQ_Msk = 0x20000000
	// Bit REF_CAL_REQ.
	CALIB_RCO_RC_REF_OSC_CFG_REF_CAL_REQ = 0x20000000

	// VCOA_KVCO2M_CODE: reserved
	// Position of KCALF2M_PO field.
	CALIB_VCOA_KVCO2M_CODE_KCALF2M_PO_Pos = 0x0
	// Bit mask of KCALF2M_PO field.
	CALIB_VCOA_KVCO2M_CODE_KCALF2M_PO_Msk = 0x7ff
	// Position of TX_VCO_AMP field.
	CALIB_VCOA_KVCO2M_CODE_TX_VCO_AMP_Pos = 0x10
	// Bit mask of TX_VCO_AMP field.
	CALIB_VCOA_KVCO2M_CODE_TX_VCO_AMP_Msk = 0x1f0000
	// Position of RX_VCO_AMP field.
	CALIB_VCOA_KVCO2M_CODE_RX_VCO_AMP_Pos = 0x18
	// Bit mask of RX_VCO_AMP field.
	CALIB_VCOA_KVCO2M_CODE_RX_VCO_AMP_Msk = 0x1f000000

	// VCOA_KVCO2M_CFG: reserved
	// Position of KCALF2M_CFG field.
	CALIB_VCOA_KVCO2M_CFG_KCALF2M_CFG_Pos = 0x0
	// Bit mask of KCALF2M_CFG field.
	CALIB_VCOA_KVCO2M_CFG_KCALF2M_CFG_Msk = 0x7ff
	// Position of KCALF2M_BP field.
	CALIB_VCOA_KVCO2M_CFG_KCALF2M_BP_Pos = 0xb
	// Bit mask of KCALF2M_BP field.
	CALIB_VCOA_KVCO2M_CFG_KCALF2M_BP_Msk = 0x800
	// Bit KCALF2M_BP.
	CALIB_VCOA_KVCO2M_CFG_KCALF2M_BP = 0x800
	// Position of KVCO_CAL_E field.
	CALIB_VCOA_KVCO2M_CFG_KVCO_CAL_E_Pos = 0xc
	// Bit mask of KVCO_CAL_E field.
	CALIB_VCOA_KVCO2M_CFG_KVCO_CAL_E_Msk = 0x7000
	// Position of TX_VCO_AMP_CFG field.
	CALIB_VCOA_KVCO2M_CFG_TX_VCO_AMP_CFG_Pos = 0x10
	// Bit mask of TX_VCO_AMP_CFG field.
	CALIB_VCOA_KVCO2M_CFG_TX_VCO_AMP_CFG_Msk = 0x1f0000
	// Position of VCOA_CAL_DIS field.
	CALIB_VCOA_KVCO2M_CFG_VCOA_CAL_DIS_Pos = 0x15
	// Bit mask of VCOA_CAL_DIS field.
	CALIB_VCOA_KVCO2M_CFG_VCOA_CAL_DIS_Msk = 0x200000
	// Bit VCOA_CAL_DIS.
	CALIB_VCOA_KVCO2M_CFG_VCOA_CAL_DIS = 0x200000
	// Position of VCOA_CAL_REQ field.
	CALIB_VCOA_KVCO2M_CFG_VCOA_CAL_REQ_Pos = 0x16
	// Bit mask of VCOA_CAL_REQ field.
	CALIB_VCOA_KVCO2M_CFG_VCOA_CAL_REQ_Msk = 0x400000
	// Bit VCOA_CAL_REQ.
	CALIB_VCOA_KVCO2M_CFG_VCOA_CAL_REQ = 0x400000
	// Position of RX_VCO_AMP_CFG field.
	CALIB_VCOA_KVCO2M_CFG_RX_VCO_AMP_CFG_Pos = 0x18
	// Bit mask of RX_VCO_AMP_CFG field.
	CALIB_VCOA_KVCO2M_CFG_RX_VCO_AMP_CFG_Msk = 0x1f000000

	// VCOF_KVCO_PO_CODE: reserved
	// Position of KCALF_PO field.
	CALIB_VCOF_KVCO_PO_CODE_KCALF_PO_Pos = 0x0
	// Bit mask of KCALF_PO field.
	CALIB_VCOF_KVCO_PO_CODE_KCALF_PO_Msk = 0x7ff
	// Position of TX_VCO_CBANK_PO field.
	CALIB_VCOF_KVCO_PO_CODE_TX_VCO_CBANK_PO_Pos = 0x10
	// Bit mask of TX_VCO_CBANK_PO field.
	CALIB_VCOF_KVCO_PO_CODE_TX_VCO_CBANK_PO_Msk = 0x3f0000
	// Position of RX_VCO_CBANK_PO field.
	CALIB_VCOF_KVCO_PO_CODE_RX_VCO_CBANK_PO_Pos = 0x18
	// Bit mask of RX_VCO_CBANK_PO field.
	CALIB_VCOF_KVCO_PO_CODE_RX_VCO_CBANK_PO_Msk = 0x3f000000

	// VCOF_KVCO_CFG: VCOF hop calibration bypass
	// Position of KCALF_CFG field.
	CALIB_VCOF_KVCO_CFG_KCALF_CFG_Pos = 0x0
	// Bit mask of KCALF_CFG field.
	CALIB_VCOF_KVCO_CFG_KCALF_CFG_Msk = 0x7ff
	// Position of KVCO_REQ field.
	CALIB_VCOF_KVCO_CFG_KVCO_REQ_Pos = 0xb
	// Bit mask of KVCO_REQ field.
	CALIB_VCOF_KVCO_CFG_KVCO_REQ_Msk = 0x800
	// Bit KVCO_REQ.
	CALIB_VCOF_KVCO_CFG_KVCO_REQ = 0x800
	// Position of KVCO_DIS field.
	CALIB_VCOF_KVCO_CFG_KVCO_DIS_Pos = 0xc
	// Bit mask of KVCO_DIS field.
	CALIB_VCOF_KVCO_CFG_KVCO_DIS_Msk = 0x1000
	// Bit KVCO_DIS.
	CALIB_VCOF_KVCO_CFG_KVCO_DIS = 0x1000
	// Position of KVCO_SKIP field.
	CALIB_VCOF_KVCO_CFG_KVCO_SKIP_Pos = 0xd
	// Bit mask of KVCO_SKIP field.
	CALIB_VCOF_KVCO_CFG_KVCO_SKIP_Msk = 0x2000
	// Bit KVCO_SKIP.
	CALIB_VCOF_KVCO_CFG_KVCO_SKIP = 0x2000
	// Position of TX_VCO_CBANK_CFG field.
	CALIB_VCOF_KVCO_CFG_TX_VCO_CBANK_CFG_Pos = 0x10
	// Bit mask of TX_VCO_CBANK_CFG field.
	CALIB_VCOF_KVCO_CFG_TX_VCO_CBANK_CFG_Msk = 0x3f0000
	// Position of VCOF_CAL_DIS field.
	CALIB_VCOF_KVCO_CFG_VCOF_CAL_DIS_Pos = 0x16
	// Bit mask of VCOF_CAL_DIS field.
	CALIB_VCOF_KVCO_CFG_VCOF_CAL_DIS_Msk = 0x400000
	// Bit VCOF_CAL_DIS.
	CALIB_VCOF_KVCO_CFG_VCOF_CAL_DIS = 0x400000
	// Position of VCOF_CAL_REQ field.
	CALIB_VCOF_KVCO_CFG_VCOF_CAL_REQ_Pos = 0x17
	// Bit mask of VCOF_CAL_REQ field.
	CALIB_VCOF_KVCO_CFG_VCOF_CAL_REQ_Msk = 0x800000
	// Bit VCOF_CAL_REQ.
	CALIB_VCOF_KVCO_CFG_VCOF_CAL_REQ = 0x800000
	// Position of RX_VCO_CBANK_CFG field.
	CALIB_VCOF_KVCO_CFG_RX_VCO_CBANK_CFG_Pos = 0x18
	// Bit mask of RX_VCO_CBANK_CFG field.
	CALIB_VCOF_KVCO_CFG_RX_VCO_CBANK_CFG_Msk = 0x3f000000
	// Position of VCOF_SKIP field.
	CALIB_VCOF_KVCO_CFG_VCOF_SKIP_Pos = 0x1e
	// Bit mask of VCOF_SKIP field.
	CALIB_VCOF_KVCO_CFG_VCOF_SKIP_Msk = 0x40000000
	// Bit VCOF_SKIP.
	CALIB_VCOF_KVCO_CFG_VCOF_SKIP = 0x40000000
	// Position of VCOF_HOP_BP field.
	CALIB_VCOF_KVCO_CFG_VCOF_HOP_BP_Pos = 0x1f
	// Bit mask of VCOF_HOP_BP field.
	CALIB_VCOF_KVCO_CFG_VCOF_HOP_BP_Msk = 0x80000000
	// Bit VCOF_HOP_BP.
	CALIB_VCOF_KVCO_CFG_VCOF_HOP_BP = 0x80000000

	// VCOF_KVCO_CODE: reserved
	// Position of KCALF field.
	CALIB_VCOF_KVCO_CODE_KCALF_Pos = 0x0
	// Bit mask of KCALF field.
	CALIB_VCOF_KVCO_CODE_KCALF_Msk = 0x7ff
	// Position of TX_VCO_CBANK field.
	CALIB_VCOF_KVCO_CODE_TX_VCO_CBANK_Pos = 0x10
	// Bit mask of TX_VCO_CBANK field.
	CALIB_VCOF_KVCO_CODE_TX_VCO_CBANK_Msk = 0x3f0000
	// Position of RX_VCO_CBANK field.
	CALIB_VCOF_KVCO_CODE_RX_VCO_CBANK_Pos = 0x18
	// Bit mask of RX_VCO_CBANK field.
	CALIB_VCOF_KVCO_CODE_RX_VCO_CBANK_Msk = 0x3f000000

	// KVCO_HOP_CODE: reserved
	// Position of KCALF1M field.
	CALIB_KVCO_HOP_CODE_KCALF1M_Pos = 0x0
	// Bit mask of KCALF1M field.
	CALIB_KVCO_HOP_CODE_KCALF1M_Msk = 0x7ff
	// Position of KCALF2M field.
	CALIB_KVCO_HOP_CODE_KCALF2M_Pos = 0x10
	// Bit mask of KCALF2M field.
	CALIB_KVCO_HOP_CODE_KCALF2M_Msk = 0x7ff0000

	// VCOF_CNT_SLOPE: reserved
	// Position of TX_VCOF_CNT field.
	CALIB_VCOF_CNT_SLOPE_TX_VCOF_CNT_Pos = 0x0
	// Bit mask of TX_VCOF_CNT field.
	CALIB_VCOF_CNT_SLOPE_TX_VCOF_CNT_Msk = 0xff
	// Position of TX_SLOPE field.
	CALIB_VCOF_CNT_SLOPE_TX_SLOPE_Pos = 0x8
	// Bit mask of TX_SLOPE field.
	CALIB_VCOF_CNT_SLOPE_TX_SLOPE_Msk = 0x3f00
	// Position of RX_VCOF_CNT field.
	CALIB_VCOF_CNT_SLOPE_RX_VCOF_CNT_Pos = 0x10
	// Bit mask of RX_VCOF_CNT field.
	CALIB_VCOF_CNT_SLOPE_RX_VCOF_CNT_Msk = 0xff0000
	// Position of RX_SLOPE field.
	CALIB_VCOF_CNT_SLOPE_RX_SLOPE_Pos = 0x18
	// Bit mask of RX_SLOPE field.
	CALIB_VCOF_CNT_SLOPE_RX_SLOPE_Msk = 0x3f000000

	// XTL_CODE: Reserved
	// Position of XTL_XICTRL_CODE field.
	CALIB_XTL_CODE_XTL_XICTRL_CODE_Pos = 0x0
	// Bit mask of XTL_XICTRL_CODE field.
	CALIB_XTL_CODE_XTL_XICTRL_CODE_Msk = 0x3f
	// Position of XTL_AMP_DET_OUT field.
	CALIB_XTL_CODE_XTL_AMP_DET_OUT_Pos = 0x8
	// Bit mask of XTL_AMP_DET_OUT field.
	CALIB_XTL_CODE_XTL_AMP_DET_OUT_Msk = 0x100
	// Bit XTL_AMP_DET_OUT.
	CALIB_XTL_CODE_XTL_AMP_DET_OUT = 0x100

	// XTL_CFG: Reserved
	// Position of XTL_XICTRL_CFG field.
	CALIB_XTL_CFG_XTL_XICTRL_CFG_Pos = 0x0
	// Bit mask of XTL_XICTRL_CFG field.
	CALIB_XTL_CFG_XTL_XICTRL_CFG_Msk = 0x3f
	// Position of XTL_CAL_DIS field.
	CALIB_XTL_CFG_XTL_CAL_DIS_Pos = 0x6
	// Bit mask of XTL_CAL_DIS field.
	CALIB_XTL_CFG_XTL_CAL_DIS_Msk = 0x40
	// Bit XTL_CAL_DIS.
	CALIB_XTL_CFG_XTL_CAL_DIS = 0x40
	// Position of XTL_CAL_REQ field.
	CALIB_XTL_CFG_XTL_CAL_REQ_Pos = 0x7
	// Bit mask of XTL_CAL_REQ field.
	CALIB_XTL_CFG_XTL_CAL_REQ_Msk = 0x80
	// Bit XTL_CAL_REQ.
	CALIB_XTL_CFG_XTL_CAL_REQ = 0x80

	// CAL_DLY: hop calibration delay bypass
	// Position of HOP_DLY field.
	CALIB_CAL_DLY_HOP_DLY_Pos = 0x0
	// Bit mask of HOP_DLY field.
	CALIB_CAL_DLY_HOP_DLY_Msk = 0x3f
	// Position of HOP_DLY_BP field.
	CALIB_CAL_DLY_HOP_DLY_BP_Pos = 0x7
	// Bit mask of HOP_DLY_BP field.
	CALIB_CAL_DLY_HOP_DLY_BP_Msk = 0x80
	// Bit HOP_DLY_BP.
	CALIB_CAL_DLY_HOP_DLY_BP = 0x80
	// Position of TX_DLY_DIG1M field.
	CALIB_CAL_DLY_TX_DLY_DIG1M_Pos = 0x8
	// Bit mask of TX_DLY_DIG1M field.
	CALIB_CAL_DLY_TX_DLY_DIG1M_Msk = 0x300
	// Position of TX_DLY_DIG2M field.
	CALIB_CAL_DLY_TX_DLY_DIG2M_Pos = 0xa
	// Bit mask of TX_DLY_DIG2M field.
	CALIB_CAL_DLY_TX_DLY_DIG2M_Msk = 0xc00
	// Position of TX_DLY_DAC_1M field.
	CALIB_CAL_DLY_TX_DLY_DAC_1M_Pos = 0xc
	// Bit mask of TX_DLY_DAC_1M field.
	CALIB_CAL_DLY_TX_DLY_DAC_1M_Msk = 0x3000
	// Position of TX_DLY_DAC_2M field.
	CALIB_CAL_DLY_TX_DLY_DAC_2M_Pos = 0xe
	// Bit mask of TX_DLY_DAC_2M field.
	CALIB_CAL_DLY_TX_DLY_DAC_2M_Msk = 0xc000
	// Position of RX_PWRUP_CNT_TH1M field.
	CALIB_CAL_DLY_RX_PWRUP_CNT_TH1M_Pos = 0x10
	// Bit mask of RX_PWRUP_CNT_TH1M field.
	CALIB_CAL_DLY_RX_PWRUP_CNT_TH1M_Msk = 0xff0000
	// Position of RX_PWRUP_CNT_TH2M field.
	CALIB_CAL_DLY_RX_PWRUP_CNT_TH2M_Pos = 0x18
	// Bit mask of RX_PWRUP_CNT_TH2M field.
	CALIB_CAL_DLY_RX_PWRUP_CNT_TH2M_Msk = 0xff000000

	// DONE: Reserved
	// Position of OSC_CAL_DONE field.
	CALIB_DONE_OSC_CAL_DONE_Pos = 0x2
	// Bit mask of OSC_CAL_DONE field.
	CALIB_DONE_OSC_CAL_DONE_Msk = 0x4
	// Bit OSC_CAL_DONE.
	CALIB_DONE_OSC_CAL_DONE = 0x4
	// Position of REF_CAL_DONE field.
	CALIB_DONE_REF_CAL_DONE_Pos = 0x3
	// Bit mask of REF_CAL_DONE field.
	CALIB_DONE_REF_CAL_DONE_Msk = 0x8
	// Bit REF_CAL_DONE.
	CALIB_DONE_REF_CAL_DONE = 0x8
	// Position of RCO_CAL_DONE field.
	CALIB_DONE_RCO_CAL_DONE_Pos = 0x4
	// Bit mask of RCO_CAL_DONE field.
	CALIB_DONE_RCO_CAL_DONE_Msk = 0x10
	// Bit RCO_CAL_DONE.
	CALIB_DONE_RCO_CAL_DONE = 0x10
	// Position of RC_CAL_DONE field.
	CALIB_DONE_RC_CAL_DONE_Pos = 0x5
	// Bit mask of RC_CAL_DONE field.
	CALIB_DONE_RC_CAL_DONE_Msk = 0x20
	// Bit RC_CAL_DONE.
	CALIB_DONE_RC_CAL_DONE = 0x20
	// Position of VCOF_CAL_DONE field.
	CALIB_DONE_VCOF_CAL_DONE_Pos = 0x6
	// Bit mask of VCOF_CAL_DONE field.
	CALIB_DONE_VCOF_CAL_DONE_Msk = 0x40
	// Bit VCOF_CAL_DONE.
	CALIB_DONE_VCOF_CAL_DONE = 0x40
	// Position of VCOA_CAL_DONE field.
	CALIB_DONE_VCOA_CAL_DONE_Pos = 0x7
	// Bit mask of VCOA_CAL_DONE field.
	CALIB_DONE_VCOA_CAL_DONE_Msk = 0x80
	// Bit VCOA_CAL_DONE.
	CALIB_DONE_VCOA_CAL_DONE = 0x80
	// Position of DC2ND_CAL_DONE field.
	CALIB_DONE_DC2ND_CAL_DONE_Pos = 0x8
	// Bit mask of DC2ND_CAL_DONE field.
	CALIB_DONE_DC2ND_CAL_DONE_Msk = 0x100
	// Bit DC2ND_CAL_DONE.
	CALIB_DONE_DC2ND_CAL_DONE = 0x100
	// Position of DC1ST_CAL_DONE field.
	CALIB_DONE_DC1ST_CAL_DONE_Pos = 0x9
	// Bit mask of DC1ST_CAL_DONE field.
	CALIB_DONE_DC1ST_CAL_DONE_Msk = 0x200
	// Bit DC1ST_CAL_DONE.
	CALIB_DONE_DC1ST_CAL_DONE = 0x200
	// Position of XTL_CAL_DONE field.
	CALIB_DONE_XTL_CAL_DONE_Pos = 0xa
	// Bit mask of XTL_CAL_DONE field.
	CALIB_DONE_XTL_CAL_DONE_Msk = 0x400
	// Bit XTL_CAL_DONE.
	CALIB_DONE_XTL_CAL_DONE = 0x400
	// Position of KVCO_CAL_DONE field.
	CALIB_DONE_KVCO_CAL_DONE_Pos = 0xb
	// Bit mask of KVCO_CAL_DONE field.
	CALIB_DONE_KVCO_CAL_DONE_Msk = 0x800
	// Bit KVCO_CAL_DONE.
	CALIB_DONE_KVCO_CAL_DONE = 0x800
	// Position of KVCO_HOP_DONE field.
	CALIB_DONE_KVCO_HOP_DONE_Pos = 0xc
	// Bit mask of KVCO_HOP_DONE field.
	CALIB_DONE_KVCO_HOP_DONE_Msk = 0x1000
	// Bit KVCO_HOP_DONE.
	CALIB_DONE_KVCO_HOP_DONE = 0x1000

	// RRF1: Amplitude of LO buffer for active mixer
	// Position of RRF_INCAP2 field.
	CALIB_RRF1_RRF_INCAP2_Pos = 0x0
	// Bit mask of RRF_INCAP2 field.
	CALIB_RRF1_RRF_INCAP2_Msk = 0x7
	// Position of RRF_LOAD_CAP field.
	CALIB_RRF1_RRF_LOAD_CAP_Pos = 0x3
	// Bit mask of RRF_LOAD_CAP field.
	CALIB_RRF1_RRF_LOAD_CAP_Msk = 0x78
	// Position of RRF_TX_INCAP1 field.
	CALIB_RRF1_RRF_TX_INCAP1_Pos = 0x7
	// Bit mask of RRF_TX_INCAP1 field.
	CALIB_RRF1_RRF_TX_INCAP1_Msk = 0x380
	// Position of RRF_RX_INCAP1 field.
	CALIB_RRF1_RRF_RX_INCAP1_Pos = 0xa
	// Bit mask of RRF_RX_INCAP1 field.
	CALIB_RRF1_RRF_RX_INCAP1_Msk = 0x1c00
	// Position of RRF_VGATE11_LNA field.
	CALIB_RRF1_RRF_VGATE11_LNA_Pos = 0xd
	// Bit mask of RRF_VGATE11_LNA field.
	CALIB_RRF1_RRF_VGATE11_LNA_Msk = 0xe000
	// Position of RRF_BM_GM field.
	CALIB_RRF1_RRF_BM_GM_Pos = 0x10
	// Bit mask of RRF_BM_GM field.
	CALIB_RRF1_RRF_BM_GM_Msk = 0x30000
	// Position of RRF_BM_LNA field.
	CALIB_RRF1_RRF_BM_LNA_Pos = 0x12
	// Bit mask of RRF_BM_LNA field.
	CALIB_RRF1_RRF_BM_LNA_Msk = 0xc0000
	// Position of RRF_BM_MIXER field.
	CALIB_RRF1_RRF_BM_MIXER_Pos = 0x14
	// Bit mask of RRF_BM_MIXER field.
	CALIB_RRF1_RRF_BM_MIXER_Msk = 0x300000
	// Position of PPF_DCCAL_RES field.
	CALIB_RRF1_PPF_DCCAL_RES_Pos = 0x16
	// Bit mask of PPF_DCCAL_RES field.
	CALIB_RRF1_PPF_DCCAL_RES_Msk = 0xc00000
	// Position of RRF_CAL_MIX_EN field.
	CALIB_RRF1_RRF_CAL_MIX_EN_Pos = 0x18
	// Bit mask of RRF_CAL_MIX_EN field.
	CALIB_RRF1_RRF_CAL_MIX_EN_Msk = 0x1000000
	// Bit RRF_CAL_MIX_EN.
	CALIB_RRF1_RRF_CAL_MIX_EN = 0x1000000
	// Position of RRF_CAL_MIX1_EN field.
	CALIB_RRF1_RRF_CAL_MIX1_EN_Pos = 0x19
	// Bit mask of RRF_CAL_MIX1_EN field.
	CALIB_RRF1_RRF_CAL_MIX1_EN_Msk = 0x2000000
	// Bit RRF_CAL_MIX1_EN.
	CALIB_RRF1_RRF_CAL_MIX1_EN = 0x2000000
	// Position of RRF_LO_SEL_P field.
	CALIB_RRF1_RRF_LO_SEL_P_Pos = 0x1a
	// Bit mask of RRF_LO_SEL_P field.
	CALIB_RRF1_RRF_LO_SEL_P_Msk = 0xc000000
	// Position of RRF_LO_SEL_N field.
	CALIB_RRF1_RRF_LO_SEL_N_Pos = 0x1c
	// Bit mask of RRF_LO_SEL_N field.
	CALIB_RRF1_RRF_LO_SEL_N_Msk = 0x30000000
	// Position of RRF_LO_AMP field.
	CALIB_RRF1_RRF_LO_AMP_Pos = 0x1e
	// Bit mask of RRF_LO_AMP field.
	CALIB_RRF1_RRF_LO_AMP_Msk = 0xc0000000

	// PLL48_PPF: reserved
	// Position of PPF_BM field.
	CALIB_PLL48_PPF_PPF_BM_Pos = 0x0
	// Bit mask of PPF_BM field.
	CALIB_PLL48_PPF_PPF_BM_Msk = 0x3
	// Position of PPF_IQSW field.
	CALIB_PLL48_PPF_PPF_IQSW_Pos = 0x2
	// Bit mask of PPF_IQSW field.
	CALIB_PLL48_PPF_PPF_IQSW_Msk = 0x4
	// Bit PPF_IQSW.
	CALIB_PLL48_PPF_PPF_IQSW = 0x4
	// Position of PLL48_DIFF_CLK_48M_DIS field.
	CALIB_PLL48_PPF_PLL48_DIFF_CLK_48M_DIS_Pos = 0x3
	// Bit mask of PLL48_DIFF_CLK_48M_DIS field.
	CALIB_PLL48_PPF_PLL48_DIFF_CLK_48M_DIS_Msk = 0x8
	// Bit PLL48_DIFF_CLK_48M_DIS.
	CALIB_PLL48_PPF_PLL48_DIFF_CLK_48M_DIS = 0x8
	// Position of PLL48_TST_CPREF field.
	CALIB_PLL48_PPF_PLL48_TST_CPREF_Pos = 0x4
	// Bit mask of PLL48_TST_CPREF field.
	CALIB_PLL48_PPF_PLL48_TST_CPREF_Msk = 0xf0

	// LO0: reserved
	// Position of VCO_DAC_IPTAT field.
	CALIB_LO0_VCO_DAC_IPTAT_Pos = 0x0
	// Bit mask of VCO_DAC_IPTAT field.
	CALIB_LO0_VCO_DAC_IPTAT_Msk = 0xf
	// Position of VCO_TST_CP field.
	CALIB_LO0_VCO_TST_CP_Pos = 0x4
	// Bit mask of VCO_TST_CP field.
	CALIB_LO0_VCO_TST_CP_Msk = 0xf0
	// Position of VCO_VTUN_SET field.
	CALIB_LO0_VCO_VTUN_SET_Pos = 0x8
	// Bit mask of VCO_VTUN_SET field.
	CALIB_LO0_VCO_VTUN_SET_Msk = 0x1f00
	// Position of VCO_ACAL_SET field.
	CALIB_LO0_VCO_ACAL_SET_Pos = 0xd
	// Bit mask of VCO_ACAL_SET field.
	CALIB_LO0_VCO_ACAL_SET_Msk = 0xe000
	// Position of VCO_BM_TXFIL field.
	CALIB_LO0_VCO_BM_TXFIL_Pos = 0x10
	// Bit mask of VCO_BM_TXFIL field.
	CALIB_LO0_VCO_BM_TXFIL_Msk = 0x30000
	// Position of VCO_BM_TXDAC field.
	CALIB_LO0_VCO_BM_TXDAC_Pos = 0x12
	// Bit mask of VCO_BM_TXDAC field.
	CALIB_LO0_VCO_BM_TXDAC_Msk = 0xc0000
	// Position of VCO_SAMP_EN field.
	CALIB_LO0_VCO_SAMP_EN_Pos = 0x17
	// Bit mask of VCO_SAMP_EN field.
	CALIB_LO0_VCO_SAMP_EN_Msk = 0x800000
	// Bit VCO_SAMP_EN.
	CALIB_LO0_VCO_SAMP_EN = 0x800000
	// Position of VCO_CAP_HALF_EN field.
	CALIB_LO0_VCO_CAP_HALF_EN_Pos = 0x18
	// Bit mask of VCO_CAP_HALF_EN field.
	CALIB_LO0_VCO_CAP_HALF_EN_Msk = 0x1000000
	// Bit VCO_CAP_HALF_EN.
	CALIB_LO0_VCO_CAP_HALF_EN = 0x1000000
	// Position of VCO_SET_VCO_VDD_LOW field.
	CALIB_LO0_VCO_SET_VCO_VDD_LOW_Pos = 0x19
	// Bit mask of VCO_SET_VCO_VDD_LOW field.
	CALIB_LO0_VCO_SET_VCO_VDD_LOW_Msk = 0x2000000
	// Bit VCO_SET_VCO_VDD_LOW.
	CALIB_LO0_VCO_SET_VCO_VDD_LOW = 0x2000000
	// Position of VCO_8OR16M_INV_EN field.
	CALIB_LO0_VCO_8OR16M_INV_EN_Pos = 0x1a
	// Bit mask of VCO_8OR16M_INV_EN field.
	CALIB_LO0_VCO_8OR16M_INV_EN_Msk = 0x4000000
	// Bit VCO_8OR16M_INV_EN.
	CALIB_LO0_VCO_8OR16M_INV_EN = 0x4000000
	// Position of VCO_DIV_PD_EN field.
	CALIB_LO0_VCO_DIV_PD_EN_Pos = 0x1b
	// Bit mask of VCO_DIV_PD_EN field.
	CALIB_LO0_VCO_DIV_PD_EN_Msk = 0x8000000
	// Bit VCO_DIV_PD_EN.
	CALIB_LO0_VCO_DIV_PD_EN = 0x8000000
	// Position of VCO_TXDLY1M field.
	CALIB_LO0_VCO_TXDLY1M_Pos = 0x1c
	// Bit mask of VCO_TXDLY1M field.
	CALIB_LO0_VCO_TXDLY1M_Msk = 0x10000000
	// Bit VCO_TXDLY1M.
	CALIB_LO0_VCO_TXDLY1M = 0x10000000
	// Position of VCO_TXDLY2M field.
	CALIB_LO0_VCO_TXDLY2M_Pos = 0x1d
	// Bit mask of VCO_TXDLY2M field.
	CALIB_LO0_VCO_TXDLY2M_Msk = 0x20000000
	// Bit VCO_TXDLY2M.
	CALIB_LO0_VCO_TXDLY2M = 0x20000000
	// Position of VCO_RX_CK_TST field.
	CALIB_LO0_VCO_RX_CK_TST_Pos = 0x1e
	// Bit mask of VCO_RX_CK_TST field.
	CALIB_LO0_VCO_RX_CK_TST_Msk = 0x40000000
	// Bit VCO_RX_CK_TST.
	CALIB_LO0_VCO_RX_CK_TST = 0x40000000
	// Position of VCO_DSM_INT_EN field.
	CALIB_LO0_VCO_DSM_INT_EN_Pos = 0x1f
	// Bit mask of VCO_DSM_INT_EN field.
	CALIB_LO0_VCO_DSM_INT_EN_Msk = 0x80000000
	// Bit VCO_DSM_INT_EN.
	CALIB_LO0_VCO_DSM_INT_EN = 0x80000000

	// LO1: Reserved
	// Position of SPEED_UP_TIME field.
	CALIB_LO1_SPEED_UP_TIME_Pos = 0x0
	// Bit mask of SPEED_UP_TIME field.
	CALIB_LO1_SPEED_UP_TIME_Msk = 0x1f
	// Position of SW_LO_SPEED_UP field.
	CALIB_LO1_SW_LO_SPEED_UP_Pos = 0x5
	// Bit mask of SW_LO_SPEED_UP field.
	CALIB_LO1_SW_LO_SPEED_UP_Msk = 0x20
	// Bit SW_LO_SPEED_UP.
	CALIB_LO1_SW_LO_SPEED_UP = 0x20
	// Position of RX_PLLPFD_EN field.
	CALIB_LO1_RX_PLLPFD_EN_Pos = 0x6
	// Bit mask of RX_PLLPFD_EN field.
	CALIB_LO1_RX_PLLPFD_EN_Msk = 0x40
	// Bit RX_PLLPFD_EN.
	CALIB_LO1_RX_PLLPFD_EN = 0x40
	// Position of TX_PLLPFD_EN field.
	CALIB_LO1_TX_PLLPFD_EN_Pos = 0x7
	// Bit mask of TX_PLLPFD_EN field.
	CALIB_LO1_TX_PLLPFD_EN_Msk = 0x80
	// Bit TX_PLLPFD_EN.
	CALIB_LO1_TX_PLLPFD_EN = 0x80
	// Position of LO_SET_TIME field.
	CALIB_LO1_LO_SET_TIME_Pos = 0x8
	// Bit mask of LO_SET_TIME field.
	CALIB_LO1_LO_SET_TIME_Msk = 0x3f00
	// Position of MOD_TEST field.
	CALIB_LO1_MOD_TEST_Pos = 0xe
	// Bit mask of MOD_TEST field.
	CALIB_LO1_MOD_TEST_Msk = 0x4000
	// Bit MOD_TEST.
	CALIB_LO1_MOD_TEST = 0x4000
	// Position of DIV_DIFF_CLK_LO_DIS field.
	CALIB_LO1_DIV_DIFF_CLK_LO_DIS_Pos = 0xf
	// Bit mask of DIV_DIFF_CLK_LO_DIS field.
	CALIB_LO1_DIV_DIFF_CLK_LO_DIS_Msk = 0x8000
	// Bit DIV_DIFF_CLK_LO_DIS.
	CALIB_LO1_DIV_DIFF_CLK_LO_DIS = 0x8000
	// Position of TX_VCO_FTC_SET field.
	CALIB_LO1_TX_VCO_FTC_SET_Pos = 0x10
	// Bit mask of TX_VCO_FTC_SET field.
	CALIB_LO1_TX_VCO_FTC_SET_Msk = 0x30000
	// Position of RX_VCO_FTC_SET field.
	CALIB_LO1_RX_VCO_FTC_SET_Pos = 0x12
	// Bit mask of RX_VCO_FTC_SET field.
	CALIB_LO1_RX_VCO_FTC_SET_Msk = 0xc0000

	// PA_CTRL: Reserved
	// Position of PA_ON_DLY field.
	CALIB_PA_CTRL_PA_ON_DLY_Pos = 0x0
	// Bit mask of PA_ON_DLY field.
	CALIB_PA_CTRL_PA_ON_DLY_Msk = 0x3f
	// Position of PA_OFF_DLY field.
	CALIB_PA_CTRL_PA_OFF_DLY_Pos = 0x8
	// Bit mask of PA_OFF_DLY field.
	CALIB_PA_CTRL_PA_OFF_DLY_Msk = 0xf00
	// Position of PA_INCREASE_SEL field.
	CALIB_PA_CTRL_PA_INCREASE_SEL_Pos = 0x10
	// Bit mask of PA_INCREASE_SEL field.
	CALIB_PA_CTRL_PA_INCREASE_SEL_Msk = 0x70000
	// Position of PA_SEL_BIAS field.
	CALIB_PA_CTRL_PA_SEL_BIAS_Pos = 0x13
	// Bit mask of PA_SEL_BIAS field.
	CALIB_PA_CTRL_PA_SEL_BIAS_Msk = 0x80000
	// Bit PA_SEL_BIAS.
	CALIB_PA_CTRL_PA_SEL_BIAS = 0x80000
	// Position of PA_BM_CUR field.
	CALIB_PA_CTRL_PA_BM_CUR_Pos = 0x14
	// Bit mask of PA_BM_CUR field.
	CALIB_PA_CTRL_PA_BM_CUR_Msk = 0x300000
	// Position of PA_VDUTY_CYCLE_SEL field.
	CALIB_PA_CTRL_PA_VDUTY_CYCLE_SEL_Pos = 0x16
	// Bit mask of PA_VDUTY_CYCLE_SEL field.
	CALIB_PA_CTRL_PA_VDUTY_CYCLE_SEL_Msk = 0xc00000
	// Position of PA_VCDCG field.
	CALIB_PA_CTRL_PA_VCDCG_Pos = 0x18
	// Bit mask of PA_VCDCG field.
	CALIB_PA_CTRL_PA_VCDCG_Msk = 0x1000000
	// Bit PA_VCDCG.
	CALIB_PA_CTRL_PA_VCDCG = 0x1000000

	// CTRL: Reserved
	// Position of RC_TIM field.
	CALIB_CTRL_RC_TIM_Pos = 0x0
	// Bit mask of RC_TIM field.
	CALIB_CTRL_RC_TIM_Msk = 0x3
	// Position of VCO_TEST_INT field.
	CALIB_CTRL_VCO_TEST_INT_Pos = 0x4
	// Bit mask of VCO_TEST_INT field.
	CALIB_CTRL_VCO_TEST_INT_Msk = 0x10
	// Bit VCO_TEST_INT.
	CALIB_CTRL_VCO_TEST_INT = 0x10
	// Position of HOP_CLB_SEL field.
	CALIB_CTRL_HOP_CLB_SEL_Pos = 0x8
	// Bit mask of HOP_CLB_SEL field.
	CALIB_CTRL_HOP_CLB_SEL_Msk = 0x100
	// Bit HOP_CLB_SEL.
	CALIB_CTRL_HOP_CLB_SEL = 0x100
	// Position of XTL_PO_TIM field.
	CALIB_CTRL_XTL_PO_TIM_Pos = 0x10
	// Bit mask of XTL_PO_TIM field.
	CALIB_CTRL_XTL_PO_TIM_Msk = 0x30000
	// Position of XTL_CAL_TIM field.
	CALIB_CTRL_XTL_CAL_TIM_Pos = 0x12
	// Bit mask of XTL_CAL_TIM field.
	CALIB_CTRL_XTL_CAL_TIM_Msk = 0xc0000
	// Position of XTL_AMP_DET_PWR_SEL field.
	CALIB_CTRL_XTL_AMP_DET_PWR_SEL_Pos = 0x14
	// Bit mask of XTL_AMP_DET_PWR_SEL field.
	CALIB_CTRL_XTL_AMP_DET_PWR_SEL_Msk = 0x300000
	// power on detector only 1ms each code
	CALIB_CTRL_XTL_AMP_DET_PWR_SEL_PO1MS = 0x0
	// power on detector during all calibration time
	CALIB_CTRL_XTL_AMP_DET_PWR_SEL_POCAL = 0x1
	// always power on detector
	CALIB_CTRL_XTL_AMP_DET_PWR_SEL_POALWAYS = 0x2
	// always power down detector
	CALIB_CTRL_XTL_AMP_DET_PWR_SEL_PDALWAYS = 0x3
	// Position of XTL_SWCAL_EN field.
	CALIB_CTRL_XTL_SWCAL_EN_Pos = 0x16
	// Bit mask of XTL_SWCAL_EN field.
	CALIB_CTRL_XTL_SWCAL_EN_Msk = 0x400000
	// Bit XTL_SWCAL_EN.
	CALIB_CTRL_XTL_SWCAL_EN = 0x400000

	// INT_RAW: Reserved
	// Position of PO_CAL_DONE_INT field.
	CALIB_INT_RAW_PO_CAL_DONE_INT_Pos = 0x0
	// Bit mask of PO_CAL_DONE_INT field.
	CALIB_INT_RAW_PO_CAL_DONE_INT_Msk = 0x1
	// Bit PO_CAL_DONE_INT.
	CALIB_INT_RAW_PO_CAL_DONE_INT = 0x1
	// Position of HOP_CAL_DONE_INT field.
	CALIB_INT_RAW_HOP_CAL_DONE_INT_Pos = 0x1
	// Bit mask of HOP_CAL_DONE_INT field.
	CALIB_INT_RAW_HOP_CAL_DONE_INT_Msk = 0x2
	// Bit HOP_CAL_DONE_INT.
	CALIB_INT_RAW_HOP_CAL_DONE_INT = 0x2
	// Position of OSC_CAL_DONE_INT field.
	CALIB_INT_RAW_OSC_CAL_DONE_INT_Pos = 0x2
	// Bit mask of OSC_CAL_DONE_INT field.
	CALIB_INT_RAW_OSC_CAL_DONE_INT_Msk = 0x4
	// Bit OSC_CAL_DONE_INT.
	CALIB_INT_RAW_OSC_CAL_DONE_INT = 0x4
	// Position of REF_CAL_DONE_INT field.
	CALIB_INT_RAW_REF_CAL_DONE_INT_Pos = 0x3
	// Bit mask of REF_CAL_DONE_INT field.
	CALIB_INT_RAW_REF_CAL_DONE_INT_Msk = 0x8
	// Bit REF_CAL_DONE_INT.
	CALIB_INT_RAW_REF_CAL_DONE_INT = 0x8
	// Position of RCO_CAL_DONE_INT field.
	CALIB_INT_RAW_RCO_CAL_DONE_INT_Pos = 0x4
	// Bit mask of RCO_CAL_DONE_INT field.
	CALIB_INT_RAW_RCO_CAL_DONE_INT_Msk = 0x10
	// Bit RCO_CAL_DONE_INT.
	CALIB_INT_RAW_RCO_CAL_DONE_INT = 0x10
	// Position of XTL_CAL_DONE_INT field.
	CALIB_INT_RAW_XTL_CAL_DONE_INT_Pos = 0x5
	// Bit mask of XTL_CAL_DONE_INT field.
	CALIB_INT_RAW_XTL_CAL_DONE_INT_Msk = 0x20
	// Bit XTL_CAL_DONE_INT.
	CALIB_INT_RAW_XTL_CAL_DONE_INT = 0x20
	// Position of PO_ALL_DONE_INT field.
	CALIB_INT_RAW_PO_ALL_DONE_INT_Pos = 0x8
	// Bit mask of PO_ALL_DONE_INT field.
	CALIB_INT_RAW_PO_ALL_DONE_INT_Msk = 0x100
	// Bit PO_ALL_DONE_INT.
	CALIB_INT_RAW_PO_ALL_DONE_INT = 0x100
	// Position of CAL_INT field.
	CALIB_INT_RAW_CAL_INT_Pos = 0x10
	// Bit mask of CAL_INT field.
	CALIB_INT_RAW_CAL_INT_Msk = 0x10000
	// Bit CAL_INT.
	CALIB_INT_RAW_CAL_INT = 0x10000

	// INTEN: Reserved
	// Position of PO_CAL_DONE_INTEN field.
	CALIB_INTEN_PO_CAL_DONE_INTEN_Pos = 0x0
	// Bit mask of PO_CAL_DONE_INTEN field.
	CALIB_INTEN_PO_CAL_DONE_INTEN_Msk = 0x1
	// Bit PO_CAL_DONE_INTEN.
	CALIB_INTEN_PO_CAL_DONE_INTEN = 0x1
	// Position of HOP_CAL_DONE_INTEN field.
	CALIB_INTEN_HOP_CAL_DONE_INTEN_Pos = 0x1
	// Bit mask of HOP_CAL_DONE_INTEN field.
	CALIB_INTEN_HOP_CAL_DONE_INTEN_Msk = 0x2
	// Bit HOP_CAL_DONE_INTEN.
	CALIB_INTEN_HOP_CAL_DONE_INTEN = 0x2
	// Position of OSC_CAL_DONE_INTEN field.
	CALIB_INTEN_OSC_CAL_DONE_INTEN_Pos = 0x2
	// Bit mask of OSC_CAL_DONE_INTEN field.
	CALIB_INTEN_OSC_CAL_DONE_INTEN_Msk = 0x4
	// Bit OSC_CAL_DONE_INTEN.
	CALIB_INTEN_OSC_CAL_DONE_INTEN = 0x4
	// Position of REF_CAL_DONE_INTEN field.
	CALIB_INTEN_REF_CAL_DONE_INTEN_Pos = 0x3
	// Bit mask of REF_CAL_DONE_INTEN field.
	CALIB_INTEN_REF_CAL_DONE_INTEN_Msk = 0x8
	// Bit REF_CAL_DONE_INTEN.
	CALIB_INTEN_REF_CAL_DONE_INTEN = 0x8
	// Position of RCO_CAL_DONE_INTEN field.
	CALIB_INTEN_RCO_CAL_DONE_INTEN_Pos = 0x4
	// Bit mask of RCO_CAL_DONE_INTEN field.
	CALIB_INTEN_RCO_CAL_DONE_INTEN_Msk = 0x10
	// Bit RCO_CAL_DONE_INTEN.
	CALIB_INTEN_RCO_CAL_DONE_INTEN = 0x10
	// Position of XTL_CAL_DONE_INTEN field.
	CALIB_INTEN_XTL_CAL_DONE_INTEN_Pos = 0x5
	// Bit mask of XTL_CAL_DONE_INTEN field.
	CALIB_INTEN_XTL_CAL_DONE_INTEN_Msk = 0x20
	// Bit XTL_CAL_DONE_INTEN.
	CALIB_INTEN_XTL_CAL_DONE_INTEN = 0x20
	// Position of PO_ALL_DONE_INTEN field.
	CALIB_INTEN_PO_ALL_DONE_INTEN_Pos = 0x8
	// Bit mask of PO_ALL_DONE_INTEN field.
	CALIB_INTEN_PO_ALL_DONE_INTEN_Msk = 0x100
	// Bit PO_ALL_DONE_INTEN.
	CALIB_INTEN_PO_ALL_DONE_INTEN = 0x100

	// INT_STAT: Reserved
	// Position of PO_CAL_DONE_INT_STAT field.
	CALIB_INT_STAT_PO_CAL_DONE_INT_STAT_Pos = 0x0
	// Bit mask of PO_CAL_DONE_INT_STAT field.
	CALIB_INT_STAT_PO_CAL_DONE_INT_STAT_Msk = 0x1
	// Bit PO_CAL_DONE_INT_STAT.
	CALIB_INT_STAT_PO_CAL_DONE_INT_STAT = 0x1
	// Position of HOP_CAL_DONE_INT_STAT field.
	CALIB_INT_STAT_HOP_CAL_DONE_INT_STAT_Pos = 0x1
	// Bit mask of HOP_CAL_DONE_INT_STAT field.
	CALIB_INT_STAT_HOP_CAL_DONE_INT_STAT_Msk = 0x2
	// Bit HOP_CAL_DONE_INT_STAT.
	CALIB_INT_STAT_HOP_CAL_DONE_INT_STAT = 0x2
	// Position of OSC_CAL_DONE_INT_STAT field.
	CALIB_INT_STAT_OSC_CAL_DONE_INT_STAT_Pos = 0x2
	// Bit mask of OSC_CAL_DONE_INT_STAT field.
	CALIB_INT_STAT_OSC_CAL_DONE_INT_STAT_Msk = 0x4
	// Bit OSC_CAL_DONE_INT_STAT.
	CALIB_INT_STAT_OSC_CAL_DONE_INT_STAT = 0x4
	// Position of REF_CAL_DONE_INT_STAT field.
	CALIB_INT_STAT_REF_CAL_DONE_INT_STAT_Pos = 0x3
	// Bit mask of REF_CAL_DONE_INT_STAT field.
	CALIB_INT_STAT_REF_CAL_DONE_INT_STAT_Msk = 0x8
	// Bit REF_CAL_DONE_INT_STAT.
	CALIB_INT_STAT_REF_CAL_DONE_INT_STAT = 0x8
	// Position of RCO_CAL_DONE_INT_STAT field.
	CALIB_INT_STAT_RCO_CAL_DONE_INT_STAT_Pos = 0x4
	// Bit mask of RCO_CAL_DONE_INT_STAT field.
	CALIB_INT_STAT_RCO_CAL_DONE_INT_STAT_Msk = 0x10
	// Bit RCO_CAL_DONE_INT_STAT.
	CALIB_INT_STAT_RCO_CAL_DONE_INT_STAT = 0x10
	// Position of XTL_CAL_DONE_INT_STAT field.
	CALIB_INT_STAT_XTL_CAL_DONE_INT_STAT_Pos = 0x5
	// Bit mask of XTL_CAL_DONE_INT_STAT field.
	CALIB_INT_STAT_XTL_CAL_DONE_INT_STAT_Msk = 0x20
	// Bit XTL_CAL_DONE_INT_STAT.
	CALIB_INT_STAT_XTL_CAL_DONE_INT_STAT = 0x20
	// Position of PO_ALL_DONE_INT_STAT field.
	CALIB_INT_STAT_PO_ALL_DONE_INT_STAT_Pos = 0x8
	// Bit mask of PO_ALL_DONE_INT_STAT field.
	CALIB_INT_STAT_PO_ALL_DONE_INT_STAT_Msk = 0x100
	// Bit PO_ALL_DONE_INT_STAT.
	CALIB_INT_STAT_PO_ALL_DONE_INT_STAT = 0x100
	// Position of CAL_INT_STAT field.
	CALIB_INT_STAT_CAL_INT_STAT_Pos = 0x10
	// Bit mask of CAL_INT_STAT field.
	CALIB_INT_STAT_CAL_INT_STAT_Msk = 0x10000
	// Bit CAL_INT_STAT.
	CALIB_INT_STAT_CAL_INT_STAT = 0x10000

	// TIF: reserved
	// Position of TEST_CTRL field.
	CALIB_TIF_TEST_CTRL_Pos = 0x0
	// Bit mask of TEST_CTRL field.
	CALIB_TIF_TEST_CTRL_Msk = 0xf

	// KVCO_MEAN: reserved
	// Position of KVCO_CNT_MEAN field.
	CALIB_KVCO_MEAN_KVCO_CNT_MEAN_Pos = 0x0
	// Bit mask of KVCO_CNT_MEAN field.
	CALIB_KVCO_MEAN_KVCO_CNT_MEAN_Msk = 0x1fffff

	// KVCO_DLT: reserved
	// Position of KVCO_CNT_DLT field.
	CALIB_KVCO_DLT_KVCO_CNT_DLT_Pos = 0x0
	// Bit mask of KVCO_CNT_DLT field.
	CALIB_KVCO_DLT_KVCO_CNT_DLT_Msk = 0x1ff

	// LO_CFG: no description available
	// Position of LO_INT_CFG field.
	CALIB_LO_CFG_LO_INT_CFG_Pos = 0x0
	// Bit mask of LO_INT_CFG field.
	CALIB_LO_CFG_LO_INT_CFG_Msk = 0x3f
	// Position of LO_FRAC_CFG field.
	CALIB_LO_CFG_LO_FRAC_CFG_Pos = 0x6
	// Bit mask of LO_FRAC_CFG field.
	CALIB_LO_CFG_LO_FRAC_CFG_Msk = 0xfffffc0
	// Position of LO_SEL field.
	CALIB_LO_CFG_LO_SEL_Pos = 0x1e
	// Bit mask of LO_SEL field.
	CALIB_LO_CFG_LO_SEL_Msk = 0x40000000
	// Bit LO_SEL.
	CALIB_LO_CFG_LO_SEL = 0x40000000
	// Position of LO_CHANGE field.
	CALIB_LO_CFG_LO_CHANGE_Pos = 0x1f
	// Bit mask of LO_CHANGE field.
	CALIB_LO_CFG_LO_CHANGE_Msk = 0x80000000
	// Bit LO_CHANGE.
	CALIB_LO_CFG_LO_CHANGE = 0x80000000

	// LO_TABLE: no description available
	// Position of LO_INT_TABLE field.
	CALIB_LO_TABLE_LO_INT_TABLE_Pos = 0x0
	// Bit mask of LO_INT_TABLE field.
	CALIB_LO_TABLE_LO_INT_TABLE_Msk = 0x3f
	// Position of LO_FRAC_TABLE field.
	CALIB_LO_TABLE_LO_FRAC_TABLE_Pos = 0x6
	// Bit mask of LO_FRAC_TABLE field.
	CALIB_LO_TABLE_LO_FRAC_TABLE_Msk = 0x3ffffc0

	// LO_RATIO: no description available
	// Position of LO_INT field.
	CALIB_LO_RATIO_LO_INT_Pos = 0x0
	// Bit mask of LO_INT field.
	CALIB_LO_RATIO_LO_INT_Msk = 0x3f
	// Position of LO_FRAC field.
	CALIB_LO_RATIO_LO_FRAC_Pos = 0x6
	// Bit mask of LO_FRAC field.
	CALIB_LO_RATIO_LO_FRAC_Msk = 0xfffffc0

	// VCO_MOD_CFG: TRX 2M mode selection signal
	// Position of VCO_MOD_TX_CFG field.
	CALIB_VCO_MOD_CFG_VCO_MOD_TX_CFG_Pos = 0x0
	// Bit mask of VCO_MOD_TX_CFG field.
	CALIB_VCO_MOD_CFG_VCO_MOD_TX_CFG_Msk = 0x1
	// Bit VCO_MOD_TX_CFG.
	CALIB_VCO_MOD_CFG_VCO_MOD_TX_CFG = 0x1
	// Position of VCO_MOD_TX_SEL field.
	CALIB_VCO_MOD_CFG_VCO_MOD_TX_SEL_Pos = 0x1
	// Bit mask of VCO_MOD_TX_SEL field.
	CALIB_VCO_MOD_CFG_VCO_MOD_TX_SEL_Msk = 0x2
	// Bit VCO_MOD_TX_SEL.
	CALIB_VCO_MOD_CFG_VCO_MOD_TX_SEL = 0x2
	// Position of TRX2M_MODE_CFG field.
	CALIB_VCO_MOD_CFG_TRX2M_MODE_CFG_Pos = 0x2
	// Bit mask of TRX2M_MODE_CFG field.
	CALIB_VCO_MOD_CFG_TRX2M_MODE_CFG_Msk = 0x4
	// Bit TRX2M_MODE_CFG.
	CALIB_VCO_MOD_CFG_TRX2M_MODE_CFG = 0x4
	// Position of TRX2M_MODE_SEL field.
	CALIB_VCO_MOD_CFG_TRX2M_MODE_SEL_Pos = 0x3
	// Bit mask of TRX2M_MODE_SEL field.
	CALIB_VCO_MOD_CFG_TRX2M_MODE_SEL_Msk = 0x8
	// Bit TRX2M_MODE_SEL.
	CALIB_VCO_MOD_CFG_TRX2M_MODE_SEL = 0x8
	// Position of IMR field.
	CALIB_VCO_MOD_CFG_IMR_Pos = 0x4
	// Bit mask of IMR field.
	CALIB_VCO_MOD_CFG_IMR_Msk = 0x10
	// Bit IMR.
	CALIB_VCO_MOD_CFG_IMR = 0x10

	// VCO_MOD_STAT: no description available
	// Position of VCO_MOD_TX field.
	CALIB_VCO_MOD_STAT_VCO_MOD_TX_Pos = 0x0
	// Bit mask of VCO_MOD_TX field.
	CALIB_VCO_MOD_STAT_VCO_MOD_TX_Msk = 0x1
	// Bit VCO_MOD_TX.
	CALIB_VCO_MOD_STAT_VCO_MOD_TX = 0x1
	// Position of TRX2M_MODE field.
	CALIB_VCO_MOD_STAT_TRX2M_MODE_Pos = 0x2
	// Bit mask of TRX2M_MODE field.
	CALIB_VCO_MOD_STAT_TRX2M_MODE_Msk = 0x4
	// Bit TRX2M_MODE.
	CALIB_VCO_MOD_STAT_TRX2M_MODE = 0x4

	// CH_IDX: no description available
	// Position of CH_IDX field.
	CALIB_CH_IDX_CH_IDX_Pos = 0x0
	// Bit mask of CH_IDX field.
	CALIB_CH_IDX_CH_IDX_Msk = 0xff

	// VCOF_CNT_UP: reserved
	// Position of TX_VCOF_CNT_UP field.
	CALIB_VCOF_CNT_UP_TX_VCOF_CNT_UP_Pos = 0x0
	// Bit mask of TX_VCOF_CNT_UP field.
	CALIB_VCOF_CNT_UP_TX_VCOF_CNT_UP_Msk = 0xff
	// Position of RX_VCOF_CNT_UP field.
	CALIB_VCOF_CNT_UP_RX_VCOF_CNT_UP_Pos = 0x10
	// Bit mask of RX_VCOF_CNT_UP field.
	CALIB_VCOF_CNT_UP_RX_VCOF_CNT_UP_Msk = 0xff0000

	// VCOF_CNT_DN: reserved
	// Position of TX_VCOF_CNT_DN field.
	CALIB_VCOF_CNT_DN_TX_VCOF_CNT_DN_Pos = 0x0
	// Bit mask of TX_VCOF_CNT_DN field.
	CALIB_VCOF_CNT_DN_TX_VCOF_CNT_DN_Msk = 0xff
	// Position of RX_VCOF_CNT_DN field.
	CALIB_VCOF_CNT_DN_RX_VCOF_CNT_DN_Pos = 0x10
	// Bit mask of RX_VCOF_CNT_DN field.
	CALIB_VCOF_CNT_DN_RX_VCOF_CNT_DN_Msk = 0xff0000
)

// Constants for SPIFI0: spifi
const (
	// CTRL: SPIFI control register
	// Position of TIMEOUT field.
	SPIFI_CTRL_TIMEOUT_Pos = 0x0
	// Bit mask of TIMEOUT field.
	SPIFI_CTRL_TIMEOUT_Msk = 0xffff
	// Position of CSHIGH field.
	SPIFI_CTRL_CSHIGH_Pos = 0x10
	// Bit mask of CSHIGH field.
	SPIFI_CTRL_CSHIGH_Msk = 0xf0000
	// Position of D_PRFTCH_DIS field.
	SPIFI_CTRL_D_PRFTCH_DIS_Pos = 0x15
	// Bit mask of D_PRFTCH_DIS field.
	SPIFI_CTRL_D_PRFTCH_DIS_Msk = 0x200000
	// Bit D_PRFTCH_DIS.
	SPIFI_CTRL_D_PRFTCH_DIS = 0x200000
	// Position of INTEN field.
	SPIFI_CTRL_INTEN_Pos = 0x16
	// Bit mask of INTEN field.
	SPIFI_CTRL_INTEN_Msk = 0x400000
	// Bit INTEN.
	SPIFI_CTRL_INTEN = 0x400000
	// Position of MODE3 field.
	SPIFI_CTRL_MODE3_Pos = 0x17
	// Bit mask of MODE3 field.
	SPIFI_CTRL_MODE3_Msk = 0x800000
	// Bit MODE3.
	SPIFI_CTRL_MODE3 = 0x800000
	// SCK LOW. The SPIFI drives SCK low after the rising edge at which the last bit of each command is captured, and keeps it low while CS is HIGH.
	SPIFI_CTRL_MODE3_SCK_LOW = 0x0
	// SCK HIGH. the SPIFI keeps SCK high after the rising edge for the last bit of each command and while CS is HIGH, and drives it low after it drives CS LOW. (Known serial flash devices can handle either mode, but some devices may require a particular mode for proper operation.) MODE3, RFCLK, and FBCLK should not all be 1, because in this case there is no final falling edge on SCK on which to sample the last data bit of the frame.
	SPIFI_CTRL_MODE3_SCK_HIGH = 0x1
	// Position of PRFTCH_DIS field.
	SPIFI_CTRL_PRFTCH_DIS_Pos = 0x1b
	// Bit mask of PRFTCH_DIS field.
	SPIFI_CTRL_PRFTCH_DIS_Msk = 0x8000000
	// Bit PRFTCH_DIS.
	SPIFI_CTRL_PRFTCH_DIS = 0x8000000
	// Enable. Cache prefetching enabled.
	SPIFI_CTRL_PRFTCH_DIS_ENABLE = 0x0
	// Disable. Disables prefetching of cache lines.
	SPIFI_CTRL_PRFTCH_DIS_DISABLE = 0x1
	// Position of DUAL field.
	SPIFI_CTRL_DUAL_Pos = 0x1c
	// Bit mask of DUAL field.
	SPIFI_CTRL_DUAL_Msk = 0x10000000
	// Bit DUAL.
	SPIFI_CTRL_DUAL = 0x10000000
	// Quad protocol. This protocol uses IO3:0.
	SPIFI_CTRL_DUAL_QUAD = 0x0
	// Dual protocol. This protocol uses IO1:0.
	SPIFI_CTRL_DUAL_DUAL = 0x1
	// Position of RFCLK field.
	SPIFI_CTRL_RFCLK_Pos = 0x1d
	// Bit mask of RFCLK field.
	SPIFI_CTRL_RFCLK_Msk = 0x20000000
	// Bit RFCLK.
	SPIFI_CTRL_RFCLK = 0x20000000
	// Rising edge. Read data is sampled on rising edges on the clock, as in classic SPI operation.
	SPIFI_CTRL_RFCLK_RISING_EDGE = 0x0
	// Falling edge. Read data is sampled on falling edges of the clock, allowing a full serial clock of of time in order to maximize the serial clock frequency. MODE3, RFCLK, and FBCLK should not all be 1, because in this case there is no final falling edge on SCK on which to sample the last data bit of the frame.
	SPIFI_CTRL_RFCLK_FALLING_EDGE = 0x1
	// Position of FBCLK field.
	SPIFI_CTRL_FBCLK_Pos = 0x1e
	// Bit mask of FBCLK field.
	SPIFI_CTRL_FBCLK_Msk = 0x40000000
	// Bit FBCLK.
	SPIFI_CTRL_FBCLK = 0x40000000
	// Internal clock. The SPIFI samples read data using an internal clock.
	SPIFI_CTRL_FBCLK_INTERNAL_CLOCK = 0x0
	// Feedback clock. Read data is sampled using a feedback clock from the SCK pin. This allows slightly more time for each received bit. MODE3, RFCLK, and FBCLK should not all be 1, because in this case there is no final falling edge on SCK on which to sample the last data bit of the frame.
	SPIFI_CTRL_FBCLK_FEEDBACK_CLOCK = 0x1
	// Position of DMAEN field.
	SPIFI_CTRL_DMAEN_Pos = 0x1f
	// Bit mask of DMAEN field.
	SPIFI_CTRL_DMAEN_Msk = 0x80000000
	// Bit DMAEN.
	SPIFI_CTRL_DMAEN = 0x80000000

	// CMD: SPIFI command register
	// Position of DATALEN field.
	SPIFI_CMD_DATALEN_Pos = 0x0
	// Bit mask of DATALEN field.
	SPIFI_CMD_DATALEN_Msk = 0x3fff
	// Position of POLL field.
	SPIFI_CMD_POLL_Pos = 0xe
	// Bit mask of POLL field.
	SPIFI_CMD_POLL_Msk = 0x4000
	// Bit POLL.
	SPIFI_CMD_POLL = 0x4000
	// Position of DOUT field.
	SPIFI_CMD_DOUT_Pos = 0xf
	// Bit mask of DOUT field.
	SPIFI_CMD_DOUT_Msk = 0x8000
	// Bit DOUT.
	SPIFI_CMD_DOUT = 0x8000
	// Input from serial flash.
	SPIFI_CMD_DOUT_INPUT = 0x0
	// Output to serial flash.
	SPIFI_CMD_DOUT_OUTPUT = 0x1
	// Position of INTLEN field.
	SPIFI_CMD_INTLEN_Pos = 0x10
	// Bit mask of INTLEN field.
	SPIFI_CMD_INTLEN_Msk = 0x70000
	// Position of FIELDFORM field.
	SPIFI_CMD_FIELDFORM_Pos = 0x13
	// Bit mask of FIELDFORM field.
	SPIFI_CMD_FIELDFORM_Msk = 0x180000
	// All serial. All fields of the command are serial.
	SPIFI_CMD_FIELDFORM_ALL_SERIAL = 0x0
	// Quad/dual data. Data field is quad/dual, other fields are serial.
	SPIFI_CMD_FIELDFORM_QUAD_DUAL_DATA = 0x1
	// Serial opcode. Opcode field is serial. Other fields are quad/dual.
	SPIFI_CMD_FIELDFORM_SERIAL_OPCODE = 0x2
	// All quad/dual. All fields of the command are in quad/dual format.
	SPIFI_CMD_FIELDFORM_ALL_QUAD_DUAL = 0x3
	// Position of FRAMEFORM field.
	SPIFI_CMD_FRAMEFORM_Pos = 0x15
	// Bit mask of FRAMEFORM field.
	SPIFI_CMD_FRAMEFORM_Msk = 0xe00000
	// Opcode. Opcode only, no address.
	SPIFI_CMD_FRAMEFORM_OPCODE = 0x1
	// Opcode one byte. Opcode, least significant byte of address.
	SPIFI_CMD_FRAMEFORM_OPCODE_1_BYTE = 0x2
	// Opcode two bytes. Opcode, two least significant bytes of address.
	SPIFI_CMD_FRAMEFORM_OPCODE_2_BYTES = 0x3
	// Opcode three bytes. Opcode, three least significant bytes of address.
	SPIFI_CMD_FRAMEFORM_OPCODE_3_BYTES = 0x4
	// Opcode four bytes. Opcode, 4 bytes of address.
	SPIFI_CMD_FRAMEFORM_OPCODE_4_BYTES = 0x5
	// No opcode three bytes. No opcode, 3 least significant bytes of address.
	SPIFI_CMD_FRAMEFORM_NO_OPCODE_3_BYTES = 0x6
	// No opcode four bytes. No opcode, 4 bytes of address.
	SPIFI_CMD_FRAMEFORM_NO_OPCODE_4_BYTES = 0x7
	// Position of OPCODE field.
	SPIFI_CMD_OPCODE_Pos = 0x18
	// Bit mask of OPCODE field.
	SPIFI_CMD_OPCODE_Msk = 0xff000000

	// ADDR: SPIFI address register
	// Position of ADDRESS field.
	SPIFI_ADDR_ADDRESS_Pos = 0x0
	// Bit mask of ADDRESS field.
	SPIFI_ADDR_ADDRESS_Msk = 0xffffffff

	// IDATA: SPIFI intermediate data register
	// Position of IDATA field.
	SPIFI_IDATA_IDATA_Pos = 0x0
	// Bit mask of IDATA field.
	SPIFI_IDATA_IDATA_Msk = 0xffffffff

	// CLIMIT: SPIFI limit register
	// Position of CLIMIT field.
	SPIFI_CLIMIT_CLIMIT_Pos = 0x0
	// Bit mask of CLIMIT field.
	SPIFI_CLIMIT_CLIMIT_Msk = 0xffffffff

	// DATA: SPIFI data register
	// Position of DATA field.
	SPIFI_DATA_DATA_Pos = 0x0
	// Bit mask of DATA field.
	SPIFI_DATA_DATA_Msk = 0xffffffff

	// MCMD: SPIFI memory command register
	// Position of POLL field.
	SPIFI_MCMD_POLL_Pos = 0xe
	// Bit mask of POLL field.
	SPIFI_MCMD_POLL_Msk = 0x4000
	// Bit POLL.
	SPIFI_MCMD_POLL = 0x4000
	// Position of DOUT field.
	SPIFI_MCMD_DOUT_Pos = 0xf
	// Bit mask of DOUT field.
	SPIFI_MCMD_DOUT_Msk = 0x8000
	// Bit DOUT.
	SPIFI_MCMD_DOUT = 0x8000
	// Position of INTLEN field.
	SPIFI_MCMD_INTLEN_Pos = 0x10
	// Bit mask of INTLEN field.
	SPIFI_MCMD_INTLEN_Msk = 0x70000
	// Position of FIELDFORM field.
	SPIFI_MCMD_FIELDFORM_Pos = 0x13
	// Bit mask of FIELDFORM field.
	SPIFI_MCMD_FIELDFORM_Msk = 0x180000
	// All serial. All fields of the command are serial.
	SPIFI_MCMD_FIELDFORM_ALL_SERIAL = 0x0
	// Quad/dual data. Data field is quad/dual, other fields are serial.
	SPIFI_MCMD_FIELDFORM_QUAD_DUAL_DATA = 0x1
	// Serial opcode. Opcode field is serial. Other fields are quad/dual.
	SPIFI_MCMD_FIELDFORM_SERIAL_OPCODE = 0x2
	// All quad/dual. All fields of the command are in quad/dual format.
	SPIFI_MCMD_FIELDFORM_ALL_QUAD_DUAL = 0x3
	// Position of FRAMEFORM field.
	SPIFI_MCMD_FRAMEFORM_Pos = 0x15
	// Bit mask of FRAMEFORM field.
	SPIFI_MCMD_FRAMEFORM_Msk = 0xe00000
	// Opcode. Opcode only, no address.
	SPIFI_MCMD_FRAMEFORM_OPCODE = 0x1
	// Opcode one byte. Opcode, least-significant byte of address.
	SPIFI_MCMD_FRAMEFORM_OPCODE_1_BYTE = 0x2
	// Opcode two bytes. Opcode, 2 least-significant bytes of address.
	SPIFI_MCMD_FRAMEFORM_OPCODE_2_BYTES = 0x3
	// Opcode three bytes. Opcode, 3 least-significant bytes of address.
	SPIFI_MCMD_FRAMEFORM_OPCODE_3_BYTES = 0x4
	// Opcode four bytes. Opcode, 4 bytes of address.
	SPIFI_MCMD_FRAMEFORM_OPCODE_4_BYTES = 0x5
	// No opcode three bytes. No opcode, 3 least-significant bytes of address.
	SPIFI_MCMD_FRAMEFORM_NO_OPCODE_3_BYTES = 0x6
	// No opcode, 4 bytes of address.
	SPIFI_MCMD_FRAMEFORM_NO_OPCODE_4_BYTES = 0x7
	// Position of OPCODE field.
	SPIFI_MCMD_OPCODE_Pos = 0x18
	// Bit mask of OPCODE field.
	SPIFI_MCMD_OPCODE_Msk = 0xff000000

	// STAT: SPIFI status register
	// Position of MCINIT field.
	SPIFI_STAT_MCINIT_Pos = 0x0
	// Bit mask of MCINIT field.
	SPIFI_STAT_MCINIT_Msk = 0x1
	// Bit MCINIT.
	SPIFI_STAT_MCINIT = 0x1
	// Position of CMD field.
	SPIFI_STAT_CMD_Pos = 0x1
	// Bit mask of CMD field.
	SPIFI_STAT_CMD_Msk = 0x2
	// Bit CMD.
	SPIFI_STAT_CMD = 0x2
	// Position of RESET field.
	SPIFI_STAT_RESET_Pos = 0x4
	// Bit mask of RESET field.
	SPIFI_STAT_RESET_Msk = 0x10
	// Bit RESET.
	SPIFI_STAT_RESET = 0x10
	// Position of INTRQ field.
	SPIFI_STAT_INTRQ_Pos = 0x5
	// Bit mask of INTRQ field.
	SPIFI_STAT_INTRQ_Msk = 0x20
	// Bit INTRQ.
	SPIFI_STAT_INTRQ = 0x20
	// Position of VERSION field.
	SPIFI_STAT_VERSION_Pos = 0x18
	// Bit mask of VERSION field.
	SPIFI_STAT_VERSION_Msk = 0xff000000
)

// Constants for FLASH: flash
const (
	// INI_RD_EN: flash initial read register
	// Position of INI_RD_EN field.
	FLASH_INI_RD_EN_INI_RD_EN_Pos = 0x0
	// Bit mask of INI_RD_EN field.
	FLASH_INI_RD_EN_INI_RD_EN_Msk = 0x1
	// Bit INI_RD_EN.
	FLASH_INI_RD_EN_INI_RD_EN = 0x1

	// ERASE_CTRL: flash erase control register
	// Position of PAGE_IDXL field.
	FLASH_ERASE_CTRL_PAGE_IDXL_Pos = 0x0
	// Bit mask of PAGE_IDXL field.
	FLASH_ERASE_CTRL_PAGE_IDXL_Msk = 0x7f
	// Position of PAGE_IDXH field.
	FLASH_ERASE_CTRL_PAGE_IDXH_Pos = 0x8
	// Bit mask of PAGE_IDXH field.
	FLASH_ERASE_CTRL_PAGE_IDXH_Msk = 0x7f00
	// Position of HALF_ERASEL_EN field.
	FLASH_ERASE_CTRL_HALF_ERASEL_EN_Pos = 0x1c
	// Bit mask of HALF_ERASEL_EN field.
	FLASH_ERASE_CTRL_HALF_ERASEL_EN_Msk = 0x10000000
	// Bit HALF_ERASEL_EN.
	FLASH_ERASE_CTRL_HALF_ERASEL_EN = 0x10000000
	// Position of HALF_ERASEH_EN field.
	FLASH_ERASE_CTRL_HALF_ERASEH_EN_Pos = 0x1d
	// Bit mask of HALF_ERASEH_EN field.
	FLASH_ERASE_CTRL_HALF_ERASEH_EN_Msk = 0x20000000
	// Bit HALF_ERASEH_EN.
	FLASH_ERASE_CTRL_HALF_ERASEH_EN = 0x20000000
	// Position of PAGE_ERASEL_EN field.
	FLASH_ERASE_CTRL_PAGE_ERASEL_EN_Pos = 0x1e
	// Bit mask of PAGE_ERASEL_EN field.
	FLASH_ERASE_CTRL_PAGE_ERASEL_EN_Msk = 0x40000000
	// Bit PAGE_ERASEL_EN.
	FLASH_ERASE_CTRL_PAGE_ERASEL_EN = 0x40000000
	// Position of PAGE_ERASEH_EN field.
	FLASH_ERASE_CTRL_PAGE_ERASEH_EN_Pos = 0x1f
	// Bit mask of PAGE_ERASEH_EN field.
	FLASH_ERASE_CTRL_PAGE_ERASEH_EN_Msk = 0x80000000
	// Bit PAGE_ERASEH_EN.
	FLASH_ERASE_CTRL_PAGE_ERASEH_EN = 0x80000000

	// ERASE_TIME: flash erase time setting register
	// Position of ERASE_TIME_BASE field.
	FLASH_ERASE_TIME_ERASE_TIME_BASE_Pos = 0x0
	// Bit mask of ERASE_TIME_BASE field.
	FLASH_ERASE_TIME_ERASE_TIME_BASE_Msk = 0xfffff

	// TIME_CTRL: flash operation time setting register
	// Position of PRGM_CYCLE field.
	FLASH_TIME_CTRL_PRGM_CYCLE_Pos = 0x0
	// Bit mask of PRGM_CYCLE field.
	FLASH_TIME_CTRL_PRGM_CYCLE_Msk = 0xfff
	// Position of TIME_BASE field.
	FLASH_TIME_CTRL_TIME_BASE_Pos = 0xc
	// Bit mask of TIME_BASE field.
	FLASH_TIME_CTRL_TIME_BASE_Msk = 0xff000

	// SMART_CTRL: smart erase control register
	// Position of PRGML_EN field.
	FLASH_SMART_CTRL_PRGML_EN_Pos = 0x0
	// Bit mask of PRGML_EN field.
	FLASH_SMART_CTRL_PRGML_EN_Msk = 0x1
	// Bit PRGML_EN.
	FLASH_SMART_CTRL_PRGML_EN = 0x1
	// Position of PRGMH_EN field.
	FLASH_SMART_CTRL_PRGMH_EN_Pos = 0x1
	// Bit mask of PRGMH_EN field.
	FLASH_SMART_CTRL_PRGMH_EN_Msk = 0x2
	// Bit PRGMH_EN.
	FLASH_SMART_CTRL_PRGMH_EN = 0x2
	// Position of SMART_WRITEL_EN field.
	FLASH_SMART_CTRL_SMART_WRITEL_EN_Pos = 0x2
	// Bit mask of SMART_WRITEL_EN field.
	FLASH_SMART_CTRL_SMART_WRITEL_EN_Msk = 0x4
	// Bit SMART_WRITEL_EN.
	FLASH_SMART_CTRL_SMART_WRITEL_EN = 0x4
	// Position of SMART_WRITEH_EN field.
	FLASH_SMART_CTRL_SMART_WRITEH_EN_Pos = 0x3
	// Bit mask of SMART_WRITEH_EN field.
	FLASH_SMART_CTRL_SMART_WRITEH_EN_Msk = 0x8
	// Bit SMART_WRITEH_EN.
	FLASH_SMART_CTRL_SMART_WRITEH_EN = 0x8
	// Position of SMART_ERASEL_EN field.
	FLASH_SMART_CTRL_SMART_ERASEL_EN_Pos = 0x4
	// Bit mask of SMART_ERASEL_EN field.
	FLASH_SMART_CTRL_SMART_ERASEL_EN_Msk = 0x10
	// Bit SMART_ERASEL_EN.
	FLASH_SMART_CTRL_SMART_ERASEL_EN = 0x10
	// Position of SMART_ERASEH_EN field.
	FLASH_SMART_CTRL_SMART_ERASEH_EN_Pos = 0x5
	// Bit mask of SMART_ERASEH_EN field.
	FLASH_SMART_CTRL_SMART_ERASEH_EN_Msk = 0x20
	// Bit SMART_ERASEH_EN.
	FLASH_SMART_CTRL_SMART_ERASEH_EN = 0x20
	// Position of MAX_WRITE field.
	FLASH_SMART_CTRL_MAX_WRITE_Pos = 0x8
	// Bit mask of MAX_WRITE field.
	FLASH_SMART_CTRL_MAX_WRITE_Msk = 0xf00
	// Position of MAX_ERASE field.
	FLASH_SMART_CTRL_MAX_ERASE_Pos = 0xc
	// Bit mask of MAX_ERASE field.
	FLASH_SMART_CTRL_MAX_ERASE_Msk = 0x3f000

	// INTEN: interrupt enable register
	// Position of AHBL_INTEN field.
	FLASH_INTEN_AHBL_INTEN_Pos = 0x0
	// Bit mask of AHBL_INTEN field.
	FLASH_INTEN_AHBL_INTEN_Msk = 0x1
	// Bit AHBL_INTEN.
	FLASH_INTEN_AHBL_INTEN = 0x1
	// Position of LOCKL_INTEN field.
	FLASH_INTEN_LOCKL_INTEN_Pos = 0x1
	// Bit mask of LOCKL_INTEN field.
	FLASH_INTEN_LOCKL_INTEN_Msk = 0x2
	// Bit LOCKL_INTEN.
	FLASH_INTEN_LOCKL_INTEN = 0x2
	// Position of ERASEL_INTEN field.
	FLASH_INTEN_ERASEL_INTEN_Pos = 0x2
	// Bit mask of ERASEL_INTEN field.
	FLASH_INTEN_ERASEL_INTEN_Msk = 0x4
	// Bit ERASEL_INTEN.
	FLASH_INTEN_ERASEL_INTEN = 0x4
	// Position of WRITEL_INTEN field.
	FLASH_INTEN_WRITEL_INTEN_Pos = 0x3
	// Bit mask of WRITEL_INTEN field.
	FLASH_INTEN_WRITEL_INTEN_Msk = 0x8
	// Bit WRITEL_INTEN.
	FLASH_INTEN_WRITEL_INTEN = 0x8
	// Position of WRBUFL_INTEN field.
	FLASH_INTEN_WRBUFL_INTEN_Pos = 0x4
	// Bit mask of WRBUFL_INTEN field.
	FLASH_INTEN_WRBUFL_INTEN_Msk = 0x10
	// Bit WRBUFL_INTEN.
	FLASH_INTEN_WRBUFL_INTEN = 0x10
	// Position of AHBH_INTEN field.
	FLASH_INTEN_AHBH_INTEN_Pos = 0x8
	// Bit mask of AHBH_INTEN field.
	FLASH_INTEN_AHBH_INTEN_Msk = 0x100
	// Bit AHBH_INTEN.
	FLASH_INTEN_AHBH_INTEN = 0x100
	// Position of LOCKH_INTEN field.
	FLASH_INTEN_LOCKH_INTEN_Pos = 0x9
	// Bit mask of LOCKH_INTEN field.
	FLASH_INTEN_LOCKH_INTEN_Msk = 0x200
	// Bit LOCKH_INTEN.
	FLASH_INTEN_LOCKH_INTEN = 0x200
	// Position of ERASEH_INTEN field.
	FLASH_INTEN_ERASEH_INTEN_Pos = 0xa
	// Bit mask of ERASEH_INTEN field.
	FLASH_INTEN_ERASEH_INTEN_Msk = 0x400
	// Bit ERASEH_INTEN.
	FLASH_INTEN_ERASEH_INTEN = 0x400
	// Position of WRITEH_INTEN field.
	FLASH_INTEN_WRITEH_INTEN_Pos = 0xb
	// Bit mask of WRITEH_INTEN field.
	FLASH_INTEN_WRITEH_INTEN_Msk = 0x800
	// Bit WRITEH_INTEN.
	FLASH_INTEN_WRITEH_INTEN = 0x800
	// Position of WRBUFH_INTEN field.
	FLASH_INTEN_WRBUFH_INTEN_Pos = 0xc
	// Bit mask of WRBUFH_INTEN field.
	FLASH_INTEN_WRBUFH_INTEN_Msk = 0x1000
	// Bit WRBUFH_INTEN.
	FLASH_INTEN_WRBUFH_INTEN = 0x1000
	// Position of FLASH_INTEN field.
	FLASH_INTEN_FLASH_INTEN_Pos = 0x1f
	// Bit mask of FLASH_INTEN field.
	FLASH_INTEN_FLASH_INTEN_Msk = 0x80000000
	// Bit FLASH_INTEN.
	FLASH_INTEN_FLASH_INTEN = 0x80000000

	// INT_STAT: interrupt status register
	// Position of AHBL_INT field.
	FLASH_INT_STAT_AHBL_INT_Pos = 0x0
	// Bit mask of AHBL_INT field.
	FLASH_INT_STAT_AHBL_INT_Msk = 0x1
	// Bit AHBL_INT.
	FLASH_INT_STAT_AHBL_INT = 0x1
	// Position of LOCKL_INT field.
	FLASH_INT_STAT_LOCKL_INT_Pos = 0x1
	// Bit mask of LOCKL_INT field.
	FLASH_INT_STAT_LOCKL_INT_Msk = 0x2
	// Bit LOCKL_INT.
	FLASH_INT_STAT_LOCKL_INT = 0x2
	// Position of ERASEL_INT field.
	FLASH_INT_STAT_ERASEL_INT_Pos = 0x2
	// Bit mask of ERASEL_INT field.
	FLASH_INT_STAT_ERASEL_INT_Msk = 0x4
	// Bit ERASEL_INT.
	FLASH_INT_STAT_ERASEL_INT = 0x4
	// Position of WRITEL_INT field.
	FLASH_INT_STAT_WRITEL_INT_Pos = 0x3
	// Bit mask of WRITEL_INT field.
	FLASH_INT_STAT_WRITEL_INT_Msk = 0x8
	// Bit WRITEL_INT.
	FLASH_INT_STAT_WRITEL_INT = 0x8
	// Position of WRBUFL_INT field.
	FLASH_INT_STAT_WRBUFL_INT_Pos = 0x4
	// Bit mask of WRBUFL_INT field.
	FLASH_INT_STAT_WRBUFL_INT_Msk = 0x10
	// Bit WRBUFL_INT.
	FLASH_INT_STAT_WRBUFL_INT = 0x10
	// Position of WRITE_FAIL_L_INT field.
	FLASH_INT_STAT_WRITE_FAIL_L_INT_Pos = 0x5
	// Bit mask of WRITE_FAIL_L_INT field.
	FLASH_INT_STAT_WRITE_FAIL_L_INT_Msk = 0x20
	// Bit WRITE_FAIL_L_INT.
	FLASH_INT_STAT_WRITE_FAIL_L_INT = 0x20
	// Position of ERASE_FAIL_L_INT field.
	FLASH_INT_STAT_ERASE_FAIL_L_INT_Pos = 0x6
	// Bit mask of ERASE_FAIL_L_INT field.
	FLASH_INT_STAT_ERASE_FAIL_L_INT_Msk = 0x40
	// Bit ERASE_FAIL_L_INT.
	FLASH_INT_STAT_ERASE_FAIL_L_INT = 0x40
	// Position of AHBH_INT field.
	FLASH_INT_STAT_AHBH_INT_Pos = 0x8
	// Bit mask of AHBH_INT field.
	FLASH_INT_STAT_AHBH_INT_Msk = 0x100
	// Bit AHBH_INT.
	FLASH_INT_STAT_AHBH_INT = 0x100
	// Position of LOCKH_INT field.
	FLASH_INT_STAT_LOCKH_INT_Pos = 0x9
	// Bit mask of LOCKH_INT field.
	FLASH_INT_STAT_LOCKH_INT_Msk = 0x200
	// Bit LOCKH_INT.
	FLASH_INT_STAT_LOCKH_INT = 0x200
	// Position of ERASEH_INT field.
	FLASH_INT_STAT_ERASEH_INT_Pos = 0xa
	// Bit mask of ERASEH_INT field.
	FLASH_INT_STAT_ERASEH_INT_Msk = 0x400
	// Bit ERASEH_INT.
	FLASH_INT_STAT_ERASEH_INT = 0x400
	// Position of WRITEH_INT field.
	FLASH_INT_STAT_WRITEH_INT_Pos = 0xb
	// Bit mask of WRITEH_INT field.
	FLASH_INT_STAT_WRITEH_INT_Msk = 0x800
	// Bit WRITEH_INT.
	FLASH_INT_STAT_WRITEH_INT = 0x800
	// Position of WRBUFH_INT field.
	FLASH_INT_STAT_WRBUFH_INT_Pos = 0xc
	// Bit mask of WRBUFH_INT field.
	FLASH_INT_STAT_WRBUFH_INT_Msk = 0x1000
	// Bit WRBUFH_INT.
	FLASH_INT_STAT_WRBUFH_INT = 0x1000
	// Position of WRITE_FAIL_H_INT field.
	FLASH_INT_STAT_WRITE_FAIL_H_INT_Pos = 0xd
	// Bit mask of WRITE_FAIL_H_INT field.
	FLASH_INT_STAT_WRITE_FAIL_H_INT_Msk = 0x2000
	// Bit WRITE_FAIL_H_INT.
	FLASH_INT_STAT_WRITE_FAIL_H_INT = 0x2000
	// Position of ERASE_FAIL_H_INT field.
	FLASH_INT_STAT_ERASE_FAIL_H_INT_Pos = 0xe
	// Bit mask of ERASE_FAIL_H_INT field.
	FLASH_INT_STAT_ERASE_FAIL_H_INT_Msk = 0x4000
	// Bit ERASE_FAIL_H_INT.
	FLASH_INT_STAT_ERASE_FAIL_H_INT = 0x4000

	// INTCLR: interrupt clear register
	// Position of AHBL_INTCLR field.
	FLASH_INTCLR_AHBL_INTCLR_Pos = 0x0
	// Bit mask of AHBL_INTCLR field.
	FLASH_INTCLR_AHBL_INTCLR_Msk = 0x1
	// Bit AHBL_INTCLR.
	FLASH_INTCLR_AHBL_INTCLR = 0x1
	// Position of LOCKL_INTCLR field.
	FLASH_INTCLR_LOCKL_INTCLR_Pos = 0x1
	// Bit mask of LOCKL_INTCLR field.
	FLASH_INTCLR_LOCKL_INTCLR_Msk = 0x2
	// Bit LOCKL_INTCLR.
	FLASH_INTCLR_LOCKL_INTCLR = 0x2
	// Position of ERASEL_INTCLR field.
	FLASH_INTCLR_ERASEL_INTCLR_Pos = 0x2
	// Bit mask of ERASEL_INTCLR field.
	FLASH_INTCLR_ERASEL_INTCLR_Msk = 0x4
	// Bit ERASEL_INTCLR.
	FLASH_INTCLR_ERASEL_INTCLR = 0x4
	// Position of WRITEL_INTCLR field.
	FLASH_INTCLR_WRITEL_INTCLR_Pos = 0x3
	// Bit mask of WRITEL_INTCLR field.
	FLASH_INTCLR_WRITEL_INTCLR_Msk = 0x8
	// Bit WRITEL_INTCLR.
	FLASH_INTCLR_WRITEL_INTCLR = 0x8
	// Position of AHBH_INTCLR field.
	FLASH_INTCLR_AHBH_INTCLR_Pos = 0x8
	// Bit mask of AHBH_INTCLR field.
	FLASH_INTCLR_AHBH_INTCLR_Msk = 0x100
	// Bit AHBH_INTCLR.
	FLASH_INTCLR_AHBH_INTCLR = 0x100
	// Position of LOCKH_INTCLR field.
	FLASH_INTCLR_LOCKH_INTCLR_Pos = 0x9
	// Bit mask of LOCKH_INTCLR field.
	FLASH_INTCLR_LOCKH_INTCLR_Msk = 0x200
	// Bit LOCKH_INTCLR.
	FLASH_INTCLR_LOCKH_INTCLR = 0x200
	// Position of ERASEH_INTCLR field.
	FLASH_INTCLR_ERASEH_INTCLR_Pos = 0xa
	// Bit mask of ERASEH_INTCLR field.
	FLASH_INTCLR_ERASEH_INTCLR_Msk = 0x400
	// Bit ERASEH_INTCLR.
	FLASH_INTCLR_ERASEH_INTCLR = 0x400
	// Position of WRITEH_INTCLR field.
	FLASH_INTCLR_WRITEH_INTCLR_Pos = 0xb
	// Bit mask of WRITEH_INTCLR field.
	FLASH_INTCLR_WRITEH_INTCLR_Msk = 0x800
	// Bit WRITEH_INTCLR.
	FLASH_INTCLR_WRITEH_INTCLR = 0x800

	// LOCK_STAT0: lock control register 0
	// Position of PAGE_LOCK0 field.
	FLASH_LOCK_STAT0_PAGE_LOCK0_Pos = 0x0
	// Bit mask of PAGE_LOCK0 field.
	FLASH_LOCK_STAT0_PAGE_LOCK0_Msk = 0xffffffff

	// LOCK_STAT1: no description available
	// Position of PAGE_LOCK1 field.
	FLASH_LOCK_STAT1_PAGE_LOCK1_Pos = 0x0
	// Bit mask of PAGE_LOCK1 field.
	FLASH_LOCK_STAT1_PAGE_LOCK1_Msk = 0xffffffff

	// LOCK_STAT2: no description available
	// Position of PAGE_LOCK2 field.
	FLASH_LOCK_STAT2_PAGE_LOCK2_Pos = 0x0
	// Bit mask of PAGE_LOCK2 field.
	FLASH_LOCK_STAT2_PAGE_LOCK2_Msk = 0xffffffff

	// LOCK_STAT3: no description available
	// Position of PAGE_LOCK3 field.
	FLASH_LOCK_STAT3_PAGE_LOCK3_Pos = 0x0
	// Bit mask of PAGE_LOCK3 field.
	FLASH_LOCK_STAT3_PAGE_LOCK3_Msk = 0xffffffff

	// LOCK_STAT4: no description available
	// Position of PAGE_LOCK4 field.
	FLASH_LOCK_STAT4_PAGE_LOCK4_Pos = 0x0
	// Bit mask of PAGE_LOCK4 field.
	FLASH_LOCK_STAT4_PAGE_LOCK4_Msk = 0xffffffff

	// LOCK_STAT5: no description available
	// Position of PAGE_LOCK5 field.
	FLASH_LOCK_STAT5_PAGE_LOCK5_Pos = 0x0
	// Bit mask of PAGE_LOCK5 field.
	FLASH_LOCK_STAT5_PAGE_LOCK5_Msk = 0xffffffff

	// LOCK_STAT6: no description available
	// Position of PAGE_LOCK6 field.
	FLASH_LOCK_STAT6_PAGE_LOCK6_Pos = 0x0
	// Bit mask of PAGE_LOCK6 field.
	FLASH_LOCK_STAT6_PAGE_LOCK6_Msk = 0xffffffff

	// LOCK_STAT7: no description available
	// Position of PAGE_LOCK7 field.
	FLASH_LOCK_STAT7_PAGE_LOCK7_Pos = 0x0
	// Bit mask of PAGE_LOCK7 field.
	FLASH_LOCK_STAT7_PAGE_LOCK7_Msk = 0xffffffff

	// LOCK_STAT8: no description available
	// Position of MASS_ERASE_LOCK field.
	FLASH_LOCK_STAT8_MASS_ERASE_LOCK_Pos = 0x0
	// Bit mask of MASS_ERASE_LOCK field.
	FLASH_LOCK_STAT8_MASS_ERASE_LOCK_Msk = 0x1
	// Bit MASS_ERASE_LOCK.
	FLASH_LOCK_STAT8_MASS_ERASE_LOCK = 0x1
	// Position of FSH_PROTECT field.
	FLASH_LOCK_STAT8_FSH_PROTECT_Pos = 0x1
	// Bit mask of FSH_PROTECT field.
	FLASH_LOCK_STAT8_FSH_PROTECT_Msk = 0x2
	// Bit FSH_PROTECT.
	FLASH_LOCK_STAT8_FSH_PROTECT = 0x2
	// Position of MEM_PROTECT field.
	FLASH_LOCK_STAT8_MEM_PROTECT_Pos = 0x2
	// Bit mask of MEM_PROTECT field.
	FLASH_LOCK_STAT8_MEM_PROTECT_Msk = 0x4
	// Bit MEM_PROTECT.
	FLASH_LOCK_STAT8_MEM_PROTECT = 0x4

	// STATUS1: no description available
	// Position of FSH_ERA_BUSY_L field.
	FLASH_STATUS1_FSH_ERA_BUSY_L_Pos = 0x9
	// Bit mask of FSH_ERA_BUSY_L field.
	FLASH_STATUS1_FSH_ERA_BUSY_L_Msk = 0x200
	// Bit FSH_ERA_BUSY_L.
	FLASH_STATUS1_FSH_ERA_BUSY_L = 0x200
	// Position of FSH_WR_BUSY_L field.
	FLASH_STATUS1_FSH_WR_BUSY_L_Pos = 0xa
	// Bit mask of FSH_WR_BUSY_L field.
	FLASH_STATUS1_FSH_WR_BUSY_L_Msk = 0x400
	// Bit FSH_WR_BUSY_L.
	FLASH_STATUS1_FSH_WR_BUSY_L = 0x400
	// Position of DBG_ERA_DONE_L field.
	FLASH_STATUS1_DBG_ERA_DONE_L_Pos = 0xb
	// Bit mask of DBG_ERA_DONE_L field.
	FLASH_STATUS1_DBG_ERA_DONE_L_Msk = 0x800
	// Bit DBG_ERA_DONE_L.
	FLASH_STATUS1_DBG_ERA_DONE_L = 0x800
	// Position of FSH_ERA_BUSY_H field.
	FLASH_STATUS1_FSH_ERA_BUSY_H_Pos = 0xc
	// Bit mask of FSH_ERA_BUSY_H field.
	FLASH_STATUS1_FSH_ERA_BUSY_H_Msk = 0x1000
	// Bit FSH_ERA_BUSY_H.
	FLASH_STATUS1_FSH_ERA_BUSY_H = 0x1000
	// Position of FSH_WR_BUSY_H field.
	FLASH_STATUS1_FSH_WR_BUSY_H_Pos = 0xd
	// Bit mask of FSH_WR_BUSY_H field.
	FLASH_STATUS1_FSH_WR_BUSY_H_Msk = 0x2000
	// Bit FSH_WR_BUSY_H.
	FLASH_STATUS1_FSH_WR_BUSY_H = 0x2000
	// Position of DBG_ERA_DONE_H field.
	FLASH_STATUS1_DBG_ERA_DONE_H_Pos = 0xe
	// Bit mask of DBG_ERA_DONE_H field.
	FLASH_STATUS1_DBG_ERA_DONE_H_Msk = 0x4000
	// Bit DBG_ERA_DONE_H.
	FLASH_STATUS1_DBG_ERA_DONE_H = 0x4000
	// Position of INI_RD_DONE field.
	FLASH_STATUS1_INI_RD_DONE_Pos = 0xf
	// Bit mask of INI_RD_DONE field.
	FLASH_STATUS1_INI_RD_DONE_Msk = 0x8000
	// Bit INI_RD_DONE.
	FLASH_STATUS1_INI_RD_DONE = 0x8000
	// Position of FSH_STA field.
	FLASH_STATUS1_FSH_STA_Pos = 0x1a
	// Bit mask of FSH_STA field.
	FLASH_STATUS1_FSH_STA_Msk = 0x4000000
	// Bit FSH_STA.
	FLASH_STATUS1_FSH_STA = 0x4000000
	// Position of RESERVED field.
	FLASH_STATUS1_RESERVED_Pos = 0x1b
	// Bit mask of RESERVED field.
	FLASH_STATUS1_RESERVED_Msk = 0xf8000000

	// ERR_INFOL1: no description available
	// Position of WR_FAILEDL_ADDR field.
	FLASH_ERR_INFOL1_WR_FAILEDL_ADDR_Pos = 0x0
	// Bit mask of WR_FAILEDL_ADDR field.
	FLASH_ERR_INFOL1_WR_FAILEDL_ADDR_Msk = 0x3ffff
	// Position of SMART_FAILL_CTR field.
	FLASH_ERR_INFOL1_SMART_FAILL_CTR_Pos = 0x12
	// Bit mask of SMART_FAILL_CTR field.
	FLASH_ERR_INFOL1_SMART_FAILL_CTR_Msk = 0xfc0000

	// ERR_INFOL2: no description available
	// Position of WR_FAILEDL_DATA field.
	FLASH_ERR_INFOL2_WR_FAILEDL_DATA_Pos = 0x0
	// Bit mask of WR_FAILEDL_DATA field.
	FLASH_ERR_INFOL2_WR_FAILEDL_DATA_Msk = 0xffffffff

	// ERR_INFOL3: no description available
	// Position of ERA_FAILEDL_INFO field.
	FLASH_ERR_INFOL3_ERA_FAILEDL_INFO_Pos = 0x0
	// Bit mask of ERA_FAILEDL_INFO field.
	FLASH_ERR_INFOL3_ERA_FAILEDL_INFO_Msk = 0x3ffff

	// ERR_INFOH1: no description available
	// Position of WR_FAILEDH_ADDR field.
	FLASH_ERR_INFOH1_WR_FAILEDH_ADDR_Pos = 0x0
	// Bit mask of WR_FAILEDH_ADDR field.
	FLASH_ERR_INFOH1_WR_FAILEDH_ADDR_Msk = 0x3ffff
	// Position of SMART_FAILH_CTR field.
	FLASH_ERR_INFOH1_SMART_FAILH_CTR_Pos = 0x12
	// Bit mask of SMART_FAILH_CTR field.
	FLASH_ERR_INFOH1_SMART_FAILH_CTR_Msk = 0xfc0000

	// ERR_INFOH2: no description available
	// Position of WR_FAILEDH_DATA field.
	FLASH_ERR_INFOH2_WR_FAILEDH_DATA_Pos = 0x0
	// Bit mask of WR_FAILEDH_DATA field.
	FLASH_ERR_INFOH2_WR_FAILEDH_DATA_Msk = 0xffffffff

	// ERR_INFOH3: no description available
	// Position of ERA_FAILEDH_INFO field.
	FLASH_ERR_INFOH3_ERA_FAILEDH_INFO_Pos = 0x0
	// Bit mask of ERA_FAILEDH_INFO field.
	FLASH_ERR_INFOH3_ERA_FAILEDH_INFO_Msk = 0x3ffff

	// DEBUG_PASSWORD: no description available
	// Position of DEBUG_PASSWORD field.
	FLASH_DEBUG_PASSWORD_DEBUG_PASSWORD_Pos = 0x0
	// Bit mask of DEBUG_PASSWORD field.
	FLASH_DEBUG_PASSWORD_DEBUG_PASSWORD_Msk = 0xffffffff

	// ERASE_PASSWORD: no description available
	// Position of ERASE_PASSWORD field.
	FLASH_ERASE_PASSWORD_ERASE_PASSWORD_Pos = 0x0
	// Bit mask of ERASE_PASSWORD field.
	FLASH_ERASE_PASSWORD_ERASE_PASSWORD_Msk = 0xffffffff
)

// Constants for DMA0: LPC5411x DMA controller
const (
	// CTRL: DMA control.
	// Position of ENABLE field.
	DMA_CTRL_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	DMA_CTRL_ENABLE_Msk = 0x1
	// Bit ENABLE.
	DMA_CTRL_ENABLE = 0x1
	// Disabled. The DMA controller is disabled. This clears any triggers that were asserted at the point when disabled, but does not prevent re-triggering when the DMA controller is re-enabled.
	DMA_CTRL_ENABLE_DISABLED = 0x0
	// Enabled. The DMA controller is enabled.
	DMA_CTRL_ENABLE_ENABLED = 0x1

	// INTSTAT: Interrupt status.
	// Position of ACTIVEINT field.
	DMA_INTSTAT_ACTIVEINT_Pos = 0x1
	// Bit mask of ACTIVEINT field.
	DMA_INTSTAT_ACTIVEINT_Msk = 0x2
	// Bit ACTIVEINT.
	DMA_INTSTAT_ACTIVEINT = 0x2
	// Not pending. No enabled interrupts are pending.
	DMA_INTSTAT_ACTIVEINT_NOT_PENDING = 0x0
	// Pending. At least one enabled interrupt is pending.
	DMA_INTSTAT_ACTIVEINT_PENDING = 0x1
	// Position of ACTIVEERRINT field.
	DMA_INTSTAT_ACTIVEERRINT_Pos = 0x2
	// Bit mask of ACTIVEERRINT field.
	DMA_INTSTAT_ACTIVEERRINT_Msk = 0x4
	// Bit ACTIVEERRINT.
	DMA_INTSTAT_ACTIVEERRINT = 0x4
	// Not pending. No error interrupts are pending.
	DMA_INTSTAT_ACTIVEERRINT_NOT_PENDING = 0x0
	// Pending. At least one error interrupt is pending.
	DMA_INTSTAT_ACTIVEERRINT_PENDING = 0x1

	// SRAMBASE: SRAM address of the channel configuration table.
	// Position of OFFSET field.
	DMA_SRAMBASE_OFFSET_Pos = 0x9
	// Bit mask of OFFSET field.
	DMA_SRAMBASE_OFFSET_Msk = 0xfffffe00

	// ENABLESET0: Channel Enable read and Set for all DMA channels.
	// Position of ENA field.
	DMA_ENABLESET0_ENA_Pos = 0x0
	// Bit mask of ENA field.
	DMA_ENABLESET0_ENA_Msk = 0xffffffff

	// ENABLECLR0: Channel Enable Clear for all DMA channels.
	// Position of CLR field.
	DMA_ENABLECLR0_CLR_Pos = 0x0
	// Bit mask of CLR field.
	DMA_ENABLECLR0_CLR_Msk = 0xffffffff

	// ACTIVE0: Channel Active status for all DMA channels.
	// Position of ACT field.
	DMA_ACTIVE0_ACT_Pos = 0x0
	// Bit mask of ACT field.
	DMA_ACTIVE0_ACT_Msk = 0xffffffff

	// BUSY0: Channel Busy status for all DMA channels.
	// Position of BSY field.
	DMA_BUSY0_BSY_Pos = 0x0
	// Bit mask of BSY field.
	DMA_BUSY0_BSY_Msk = 0xffffffff

	// ERRINT0: Error Interrupt status for all DMA channels.
	// Position of ERR field.
	DMA_ERRINT0_ERR_Pos = 0x0
	// Bit mask of ERR field.
	DMA_ERRINT0_ERR_Msk = 0xffffffff

	// INTENSET0: Interrupt Enable read and Set for all DMA channels.
	// Position of INTEN field.
	DMA_INTENSET0_INTEN_Pos = 0x0
	// Bit mask of INTEN field.
	DMA_INTENSET0_INTEN_Msk = 0xffffffff

	// INTENCLR0: Interrupt Enable Clear for all DMA channels.
	// Position of CLR field.
	DMA_INTENCLR0_CLR_Pos = 0x0
	// Bit mask of CLR field.
	DMA_INTENCLR0_CLR_Msk = 0xffffffff

	// INTA0: Interrupt A status for all DMA channels.
	// Position of IA field.
	DMA_INTA0_IA_Pos = 0x0
	// Bit mask of IA field.
	DMA_INTA0_IA_Msk = 0xffffffff

	// INTB0: Interrupt B status for all DMA channels.
	// Position of IB field.
	DMA_INTB0_IB_Pos = 0x0
	// Bit mask of IB field.
	DMA_INTB0_IB_Msk = 0xffffffff

	// SETVALID0: Set ValidPending control bits for all DMA channels.
	// Position of SV field.
	DMA_SETVALID0_SV_Pos = 0x0
	// Bit mask of SV field.
	DMA_SETVALID0_SV_Msk = 0xffffffff

	// SETTRIG0: Set Trigger control bits for all DMA channels.
	// Position of TRIG field.
	DMA_SETTRIG0_TRIG_Pos = 0x0
	// Bit mask of TRIG field.
	DMA_SETTRIG0_TRIG_Msk = 0xffffffff

	// ABORT0: Channel Abort control for all DMA channels.
	// Position of ABORTCTRL field.
	DMA_ABORT0_ABORTCTRL_Pos = 0x0
	// Bit mask of ABORTCTRL field.
	DMA_ABORT0_ABORTCTRL_Msk = 0xffffffff

	// CHANNEL.CFG: Configuration register for DMA channel .
	// Position of PERIPHREQEN field.
	DMA_CHANNEL_CFG_PERIPHREQEN_Pos = 0x0
	// Bit mask of PERIPHREQEN field.
	DMA_CHANNEL_CFG_PERIPHREQEN_Msk = 0x1
	// Bit PERIPHREQEN.
	DMA_CHANNEL_CFG_PERIPHREQEN = 0x1
	// Disabled. Peripheral DMA requests are disabled.
	DMA_CHANNEL_CFG_PERIPHREQEN_DISABLED = 0x0
	// Enabled. Peripheral DMA requests are enabled.
	DMA_CHANNEL_CFG_PERIPHREQEN_ENABLED = 0x1
	// Position of HWTRIGEN field.
	DMA_CHANNEL_CFG_HWTRIGEN_Pos = 0x1
	// Bit mask of HWTRIGEN field.
	DMA_CHANNEL_CFG_HWTRIGEN_Msk = 0x2
	// Bit HWTRIGEN.
	DMA_CHANNEL_CFG_HWTRIGEN = 0x2
	// Disabled. Hardware triggering is not used.
	DMA_CHANNEL_CFG_HWTRIGEN_DISABLED = 0x0
	// Enabled. Use hardware triggering.
	DMA_CHANNEL_CFG_HWTRIGEN_ENABLED = 0x1
	// Position of TRIGPOL field.
	DMA_CHANNEL_CFG_TRIGPOL_Pos = 0x4
	// Bit mask of TRIGPOL field.
	DMA_CHANNEL_CFG_TRIGPOL_Msk = 0x10
	// Bit TRIGPOL.
	DMA_CHANNEL_CFG_TRIGPOL = 0x10
	// Active low - falling edge. Hardware trigger is active low or falling edge triggered, based on TRIGTYPE.
	DMA_CHANNEL_CFG_TRIGPOL_ACTIVE_LOW_FALLING = 0x0
	// Active high - rising edge. Hardware trigger is active high or rising edge triggered, based on TRIGTYPE.
	DMA_CHANNEL_CFG_TRIGPOL_ACTIVE_HIGH_RISING = 0x1
	// Position of TRIGTYPE field.
	DMA_CHANNEL_CFG_TRIGTYPE_Pos = 0x5
	// Bit mask of TRIGTYPE field.
	DMA_CHANNEL_CFG_TRIGTYPE_Msk = 0x20
	// Bit TRIGTYPE.
	DMA_CHANNEL_CFG_TRIGTYPE = 0x20
	// Edge. Hardware trigger is edge triggered. Transfers will be initiated and completed, as specified for a single trigger.
	DMA_CHANNEL_CFG_TRIGTYPE_EDGE = 0x0
	// Level. Hardware trigger is level triggered. Note that when level triggering without burst (BURSTPOWER = 0) is selected, only hardware triggers should be used on that channel. Transfers continue as long as the trigger level is asserted. Once the trigger is de-asserted, the transfer will be paused until the trigger is, again, asserted. However, the transfer will not be paused until any remaining transfers within the current BURSTPOWER length are completed.
	DMA_CHANNEL_CFG_TRIGTYPE_LEVEL = 0x1
	// Position of TRIGBURST field.
	DMA_CHANNEL_CFG_TRIGBURST_Pos = 0x6
	// Bit mask of TRIGBURST field.
	DMA_CHANNEL_CFG_TRIGBURST_Msk = 0x40
	// Bit TRIGBURST.
	DMA_CHANNEL_CFG_TRIGBURST = 0x40
	// Single transfer. Hardware trigger causes a single transfer.
	DMA_CHANNEL_CFG_TRIGBURST_SINGLE = 0x0
	// Burst transfer. When the trigger for this channel is set to edge triggered, a hardware trigger causes a burst transfer, as defined by BURSTPOWER. When the trigger for this channel is set to level triggered, a hardware trigger causes transfers to continue as long as the trigger is asserted, unless the transfer is complete.
	DMA_CHANNEL_CFG_TRIGBURST_BURST = 0x1
	// Position of BURSTPOWER field.
	DMA_CHANNEL_CFG_BURSTPOWER_Pos = 0x8
	// Bit mask of BURSTPOWER field.
	DMA_CHANNEL_CFG_BURSTPOWER_Msk = 0xf00
	// Position of SRCBURSTWRAP field.
	DMA_CHANNEL_CFG_SRCBURSTWRAP_Pos = 0xe
	// Bit mask of SRCBURSTWRAP field.
	DMA_CHANNEL_CFG_SRCBURSTWRAP_Msk = 0x4000
	// Bit SRCBURSTWRAP.
	DMA_CHANNEL_CFG_SRCBURSTWRAP = 0x4000
	// Disabled. Source burst wrapping is not enabled for this DMA channel.
	DMA_CHANNEL_CFG_SRCBURSTWRAP_DISABLED = 0x0
	// Enabled. Source burst wrapping is enabled for this DMA channel.
	DMA_CHANNEL_CFG_SRCBURSTWRAP_ENABLED = 0x1
	// Position of DSTBURSTWRAP field.
	DMA_CHANNEL_CFG_DSTBURSTWRAP_Pos = 0xf
	// Bit mask of DSTBURSTWRAP field.
	DMA_CHANNEL_CFG_DSTBURSTWRAP_Msk = 0x8000
	// Bit DSTBURSTWRAP.
	DMA_CHANNEL_CFG_DSTBURSTWRAP = 0x8000
	// Disabled. Destination burst wrapping is not enabled for this DMA channel.
	DMA_CHANNEL_CFG_DSTBURSTWRAP_DISABLED = 0x0
	// Enabled. Destination burst wrapping is enabled for this DMA channel.
	DMA_CHANNEL_CFG_DSTBURSTWRAP_ENABLED = 0x1
	// Position of CHPRIORITY field.
	DMA_CHANNEL_CFG_CHPRIORITY_Pos = 0x10
	// Bit mask of CHPRIORITY field.
	DMA_CHANNEL_CFG_CHPRIORITY_Msk = 0x70000

	// CHANNEL.CTLSTAT: Control and status register for DMA channel .
	// Position of VALIDPENDING field.
	DMA_CHANNEL_CTLSTAT_VALIDPENDING_Pos = 0x0
	// Bit mask of VALIDPENDING field.
	DMA_CHANNEL_CTLSTAT_VALIDPENDING_Msk = 0x1
	// Bit VALIDPENDING.
	DMA_CHANNEL_CTLSTAT_VALIDPENDING = 0x1
	// No effect. No effect on DMA operation.
	DMA_CHANNEL_CTLSTAT_VALIDPENDING_NO_EFFECT = 0x0
	// Valid pending.
	DMA_CHANNEL_CTLSTAT_VALIDPENDING_VALID_PENDING = 0x1
	// Position of TRIG field.
	DMA_CHANNEL_CTLSTAT_TRIG_Pos = 0x2
	// Bit mask of TRIG field.
	DMA_CHANNEL_CTLSTAT_TRIG_Msk = 0x4
	// Bit TRIG.
	DMA_CHANNEL_CTLSTAT_TRIG = 0x4
	// Not triggered. The trigger for this DMA channel is not set. DMA operations will not be carried out.
	DMA_CHANNEL_CTLSTAT_TRIG_NOT_TRIGGERED = 0x0
	// Triggered. The trigger for this DMA channel is set. DMA operations will be carried out.
	DMA_CHANNEL_CTLSTAT_TRIG_TRIGGERED = 0x1

	// CHANNEL.XFERCFG: Transfer configuration register for DMA channel .
	// Position of CFGVALID field.
	DMA_CHANNEL_XFERCFG_CFGVALID_Pos = 0x0
	// Bit mask of CFGVALID field.
	DMA_CHANNEL_XFERCFG_CFGVALID_Msk = 0x1
	// Bit CFGVALID.
	DMA_CHANNEL_XFERCFG_CFGVALID = 0x1
	// Not valid. The channel descriptor is not considered valid until validated by an associated SETVALID0 setting.
	DMA_CHANNEL_XFERCFG_CFGVALID_NOT_VALID = 0x0
	// Valid. The current channel descriptor is considered valid.
	DMA_CHANNEL_XFERCFG_CFGVALID_VALID = 0x1
	// Position of RELOAD field.
	DMA_CHANNEL_XFERCFG_RELOAD_Pos = 0x1
	// Bit mask of RELOAD field.
	DMA_CHANNEL_XFERCFG_RELOAD_Msk = 0x2
	// Bit RELOAD.
	DMA_CHANNEL_XFERCFG_RELOAD = 0x2
	// Disabled. Do not reload the channels' control structure when the current descriptor is exhausted.
	DMA_CHANNEL_XFERCFG_RELOAD_DISABLED = 0x0
	// Enabled. Reload the channels' control structure when the current descriptor is exhausted.
	DMA_CHANNEL_XFERCFG_RELOAD_ENABLED = 0x1
	// Position of SWTRIG field.
	DMA_CHANNEL_XFERCFG_SWTRIG_Pos = 0x2
	// Bit mask of SWTRIG field.
	DMA_CHANNEL_XFERCFG_SWTRIG_Msk = 0x4
	// Bit SWTRIG.
	DMA_CHANNEL_XFERCFG_SWTRIG = 0x4
	// Not set. When written by software, the trigger for this channel is not set. A new trigger, as defined by the HWTRIGEN, TRIGPOL, and TRIGTYPE will be needed to start the channel.
	DMA_CHANNEL_XFERCFG_SWTRIG_NOT_SET = 0x0
	// Set. When written by software, the trigger for this channel is set immediately. This feature should not be used with level triggering when TRIGBURST = 0.
	DMA_CHANNEL_XFERCFG_SWTRIG_SET = 0x1
	// Position of CLRTRIG field.
	DMA_CHANNEL_XFERCFG_CLRTRIG_Pos = 0x3
	// Bit mask of CLRTRIG field.
	DMA_CHANNEL_XFERCFG_CLRTRIG_Msk = 0x8
	// Bit CLRTRIG.
	DMA_CHANNEL_XFERCFG_CLRTRIG = 0x8
	// Not cleared. The trigger is not cleared when this descriptor is exhausted. If there is a reload, the next descriptor will be started.
	DMA_CHANNEL_XFERCFG_CLRTRIG_NOT_CLEARED = 0x0
	// Cleared. The trigger is cleared when this descriptor is exhausted
	DMA_CHANNEL_XFERCFG_CLRTRIG_CLEARED = 0x1
	// Position of SETINTA field.
	DMA_CHANNEL_XFERCFG_SETINTA_Pos = 0x4
	// Bit mask of SETINTA field.
	DMA_CHANNEL_XFERCFG_SETINTA_Msk = 0x10
	// Bit SETINTA.
	DMA_CHANNEL_XFERCFG_SETINTA = 0x10
	// No effect.
	DMA_CHANNEL_XFERCFG_SETINTA_NO_EFFECT = 0x0
	// Set. The INTA flag for this channel will be set when the current descriptor is exhausted.
	DMA_CHANNEL_XFERCFG_SETINTA_SET = 0x1
	// Position of SETINTB field.
	DMA_CHANNEL_XFERCFG_SETINTB_Pos = 0x5
	// Bit mask of SETINTB field.
	DMA_CHANNEL_XFERCFG_SETINTB_Msk = 0x20
	// Bit SETINTB.
	DMA_CHANNEL_XFERCFG_SETINTB = 0x20
	// No effect.
	DMA_CHANNEL_XFERCFG_SETINTB_NO_EFFECT = 0x0
	// Set. The INTB flag for this channel will be set when the current descriptor is exhausted.
	DMA_CHANNEL_XFERCFG_SETINTB_SET = 0x1
	// Position of WIDTH field.
	DMA_CHANNEL_XFERCFG_WIDTH_Pos = 0x8
	// Bit mask of WIDTH field.
	DMA_CHANNEL_XFERCFG_WIDTH_Msk = 0x300
	// 8-bit. 8-bit transfers are performed (8-bit source reads and destination writes).
	DMA_CHANNEL_XFERCFG_WIDTH_BIT_8 = 0x0
	// 16-bit. 6-bit transfers are performed (16-bit source reads and destination writes).
	DMA_CHANNEL_XFERCFG_WIDTH_BIT_16 = 0x1
	// 32-bit. 32-bit transfers are performed (32-bit source reads and destination writes).
	DMA_CHANNEL_XFERCFG_WIDTH_BIT_32 = 0x2
	// Position of SRCINC field.
	DMA_CHANNEL_XFERCFG_SRCINC_Pos = 0xc
	// Bit mask of SRCINC field.
	DMA_CHANNEL_XFERCFG_SRCINC_Msk = 0x3000
	// No increment. The source address is not incremented for each transfer. This is the usual case when the source is a peripheral device.
	DMA_CHANNEL_XFERCFG_SRCINC_NO_INCREMENT = 0x0
	// 1 x width. The source address is incremented by the amount specified by Width for each transfer. This is the usual case when the source is memory.
	DMA_CHANNEL_XFERCFG_SRCINC_WIDTH_X_1 = 0x1
	// 2 x width. The source address is incremented by 2 times the amount specified by Width for each transfer.
	DMA_CHANNEL_XFERCFG_SRCINC_WIDTH_X_2 = 0x2
	// 4 x width. The source address is incremented by 4 times the amount specified by Width for each transfer.
	DMA_CHANNEL_XFERCFG_SRCINC_WIDTH_X_4 = 0x3
	// Position of DSTINC field.
	DMA_CHANNEL_XFERCFG_DSTINC_Pos = 0xe
	// Bit mask of DSTINC field.
	DMA_CHANNEL_XFERCFG_DSTINC_Msk = 0xc000
	// No increment. The destination address is not incremented for each transfer. This is the usual case when the destination is a peripheral device.
	DMA_CHANNEL_XFERCFG_DSTINC_NO_INCREMENT = 0x0
	// 1 x width. The destination address is incremented by the amount specified by Width for each transfer. This is the usual case when the destination is memory.
	DMA_CHANNEL_XFERCFG_DSTINC_WIDTH_X_1 = 0x1
	// 2 x width. The destination address is incremented by 2 times the amount specified by Width for each transfer.
	DMA_CHANNEL_XFERCFG_DSTINC_WIDTH_X_2 = 0x2
	// 4 x width. The destination address is incremented by 4 times the amount specified by Width for each transfer.
	DMA_CHANNEL_XFERCFG_DSTINC_WIDTH_X_4 = 0x3
	// Position of XFERCOUNT field.
	DMA_CHANNEL_XFERCFG_XFERCOUNT_Pos = 0x10
	// Bit mask of XFERCOUNT field.
	DMA_CHANNEL_XFERCFG_XFERCOUNT_Msk = 0x3ff0000
)

// Constants for FLEXCOMM0: flexcomm
const (
	// IOMODE: io mode register
	// Position of DIO_MODE field.
	FLEXCOMM_IOMODE_DIO_MODE_Pos = 0x0
	// Bit mask of DIO_MODE field.
	FLEXCOMM_IOMODE_DIO_MODE_Msk = 0x1
	// Bit DIO_MODE.
	FLEXCOMM_IOMODE_DIO_MODE = 0x1
	// do not share pin
	FLEXCOMM_IOMODE_DIO_MODE_NOSHAREPIN = 0x0
	// share pin
	FLEXCOMM_IOMODE_DIO_MODE_SHAREPIN = 0x1
	// Position of DIO_OEN field.
	FLEXCOMM_IOMODE_DIO_OEN_Pos = 0x1
	// Bit mask of DIO_OEN field.
	FLEXCOMM_IOMODE_DIO_OEN_Msk = 0x2
	// Bit DIO_OEN.
	FLEXCOMM_IOMODE_DIO_OEN = 0x2
	// shared pin do not output
	FLEXCOMM_IOMODE_DIO_OEN_SP_NOEN = 0x0
	// shared pin output enable
	FLEXCOMM_IOMODE_DIO_OEN_SP_OEN = 0x1

	// PSELID: Peripheral Select and Flexcomm ID register.
	// Position of PERSEL field.
	FLEXCOMM_PSELID_PERSEL_Pos = 0x0
	// Bit mask of PERSEL field.
	FLEXCOMM_PSELID_PERSEL_Msk = 0x7
	// No peripheral selected.
	FLEXCOMM_PSELID_PERSEL_NO_PERIPH_SELECTED = 0x0
	// USART function selected.
	FLEXCOMM_PSELID_PERSEL_USART = 0x1
	// SPI function selected.
	FLEXCOMM_PSELID_PERSEL_SPI = 0x2
	// I2C function selected.
	FLEXCOMM_PSELID_PERSEL_I2C = 0x3
	// I2S transmit function selected.
	FLEXCOMM_PSELID_PERSEL_I2S_TRANSMIT = 0x4
	// I2S receive function selected.
	FLEXCOMM_PSELID_PERSEL_I2S_RECEIVE = 0x5
	// Position of LOCK field.
	FLEXCOMM_PSELID_LOCK_Pos = 0x3
	// Bit mask of LOCK field.
	FLEXCOMM_PSELID_LOCK_Msk = 0x8
	// Bit LOCK.
	FLEXCOMM_PSELID_LOCK = 0x8
	// Peripheral select can be changed by software.
	FLEXCOMM_PSELID_LOCK_UNLOCKED = 0x0
	// Peripheral select is locked and cannot be changed until this Flexcomm or the entire device is reset.
	FLEXCOMM_PSELID_LOCK_LOCKED = 0x1
	// Position of USARTPRESENT field.
	FLEXCOMM_PSELID_USARTPRESENT_Pos = 0x4
	// Bit mask of USARTPRESENT field.
	FLEXCOMM_PSELID_USARTPRESENT_Msk = 0x10
	// Bit USARTPRESENT.
	FLEXCOMM_PSELID_USARTPRESENT = 0x10
	// This Flexcomm does not include the USART function.
	FLEXCOMM_PSELID_USARTPRESENT_NOT_PRESENT = 0x0
	// This Flexcomm includes the USART function.
	FLEXCOMM_PSELID_USARTPRESENT_PRESENT = 0x1
	// Position of SPIPRESENT field.
	FLEXCOMM_PSELID_SPIPRESENT_Pos = 0x5
	// Bit mask of SPIPRESENT field.
	FLEXCOMM_PSELID_SPIPRESENT_Msk = 0x20
	// Bit SPIPRESENT.
	FLEXCOMM_PSELID_SPIPRESENT = 0x20
	// This Flexcomm does not include the SPI function.
	FLEXCOMM_PSELID_SPIPRESENT_NOT_PRESENT = 0x0
	// This Flexcomm includes the SPI function.
	FLEXCOMM_PSELID_SPIPRESENT_PRESENT = 0x1
	// Position of I2CPRESENT field.
	FLEXCOMM_PSELID_I2CPRESENT_Pos = 0x6
	// Bit mask of I2CPRESENT field.
	FLEXCOMM_PSELID_I2CPRESENT_Msk = 0x40
	// Bit I2CPRESENT.
	FLEXCOMM_PSELID_I2CPRESENT = 0x40
	// This Flexcomm does not include the I2C function.
	FLEXCOMM_PSELID_I2CPRESENT_NOT_PRESENT = 0x0
	// This Flexcomm includes the I2C function.
	FLEXCOMM_PSELID_I2CPRESENT_PRESENT = 0x1
	// Position of I2SPRESENT field.
	FLEXCOMM_PSELID_I2SPRESENT_Pos = 0x7
	// Bit mask of I2SPRESENT field.
	FLEXCOMM_PSELID_I2SPRESENT_Msk = 0x80
	// Bit I2SPRESENT.
	FLEXCOMM_PSELID_I2SPRESENT = 0x80
	// This Flexcomm does not include the I2S function.
	FLEXCOMM_PSELID_I2SPRESENT_NOT_PRESENT = 0x0
	// This Flexcomm includes the I2S function.
	FLEXCOMM_PSELID_I2SPRESENT_PRESENT = 0x1
	// Position of SC3W field.
	FLEXCOMM_PSELID_SC3W_Pos = 0x8
	// Bit mask of SC3W field.
	FLEXCOMM_PSELID_SC3W_Msk = 0x100
	// Bit SC3W.
	FLEXCOMM_PSELID_SC3W = 0x100
	// This Flexcomm does not support smart card/SPI 3 wire mdoe feature
	FLEXCOMM_PSELID_SC3W_NOT_PRESENT = 0x0
	// This Flexcomm support smart card/SPI 3 wire mode feature
	FLEXCOMM_PSELID_SC3W_PRESENT = 0x1
	// Position of ID field.
	FLEXCOMM_PSELID_ID_Pos = 0xc
	// Bit mask of ID field.
	FLEXCOMM_PSELID_ID_Msk = 0xfffff000

	// PID: Peripheral identification register.
	// Position of Minor_Rev field.
	FLEXCOMM_PID_Minor_Rev_Pos = 0x8
	// Bit mask of Minor_Rev field.
	FLEXCOMM_PID_Minor_Rev_Msk = 0xf00
	// Position of Major_Rev field.
	FLEXCOMM_PID_Major_Rev_Pos = 0xc
	// Bit mask of Major_Rev field.
	FLEXCOMM_PID_Major_Rev_Msk = 0xf000
	// Position of ID field.
	FLEXCOMM_PID_ID_Pos = 0x10
	// Bit mask of ID field.
	FLEXCOMM_PID_ID_Msk = 0xffff0000
)

// Constants for USART0: usart
const (
	// CFG: USART Configuration register. Basic USART configuration settings that typically are not changed during operation.
	// Position of ENABLE field.
	USART_CFG_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	USART_CFG_ENABLE_Msk = 0x1
	// Bit ENABLE.
	USART_CFG_ENABLE = 0x1
	// Disabled. The USART is disabled and the internal state machine and counters are reset. While Enable = 0, all USART interrupts and DMA transfers are disabled. When Enable is set again, CFG and most other control bits remain unchanged. When re-enabled, the USART will immediately be ready to transmit because the transmitter has been reset and is therefore available.
	USART_CFG_ENABLE_DISABLED = 0x0
	// Enabled. The USART is enabled for operation.
	USART_CFG_ENABLE_ENABLED = 0x1
	// Position of DATALEN field.
	USART_CFG_DATALEN_Pos = 0x2
	// Bit mask of DATALEN field.
	USART_CFG_DATALEN_Msk = 0xc
	// 7 bit Data length.
	USART_CFG_DATALEN__7_BIT = 0x0
	// 8 bit Data length.
	USART_CFG_DATALEN__8_BIT = 0x1
	// 9 bit data length. The 9th bit is commonly used for addressing in multidrop mode. See the ADDRDET bit in the CTL register.
	USART_CFG_DATALEN__9_BIT = 0x2
	// Position of PARITYSEL field.
	USART_CFG_PARITYSEL_Pos = 0x4
	// Bit mask of PARITYSEL field.
	USART_CFG_PARITYSEL_Msk = 0x30
	// No parity.
	USART_CFG_PARITYSEL_NO_PARITY = 0x0
	// Even parity. Adds a bit to each character such that the number of 1s in a transmitted character is even, and the number of 1s in a received character is expected to be even.
	USART_CFG_PARITYSEL_EVEN_PARITY = 0x2
	// Odd parity. Adds a bit to each character such that the number of 1s in a transmitted character is odd, and the number of 1s in a received character is expected to be odd.
	USART_CFG_PARITYSEL_ODD_PARITY = 0x3
	// Position of STOPLEN field.
	USART_CFG_STOPLEN_Pos = 0x6
	// Bit mask of STOPLEN field.
	USART_CFG_STOPLEN_Msk = 0x40
	// Bit STOPLEN.
	USART_CFG_STOPLEN = 0x40
	// 1 stop bit.
	USART_CFG_STOPLEN__1_BIT = 0x0
	// 2 stop bits. This setting should only be used for asynchronous communication.
	USART_CFG_STOPLEN__2_BITS = 0x1
	// Position of MODE32K field.
	USART_CFG_MODE32K_Pos = 0x7
	// Bit mask of MODE32K field.
	USART_CFG_MODE32K_Msk = 0x80
	// Bit MODE32K.
	USART_CFG_MODE32K = 0x80
	// Disabled. USART uses standard clocking.
	USART_CFG_MODE32K_DISABLED = 0x0
	// Enabled. USART uses the 32 kHz clock from the RTC oscillator as the clock source to the BRG, and uses a special bit clocking scheme.
	USART_CFG_MODE32K_ENABLED = 0x1
	// Position of LINMODE field.
	USART_CFG_LINMODE_Pos = 0x8
	// Bit mask of LINMODE field.
	USART_CFG_LINMODE_Msk = 0x100
	// Bit LINMODE.
	USART_CFG_LINMODE = 0x100
	// Disabled. Break detect and generate is configured for normal operation.
	USART_CFG_LINMODE_DISABLED = 0x0
	// Enabled. Break detect and generate is configured for LIN bus operation.
	USART_CFG_LINMODE_ENABLED = 0x1
	// Position of CTSEN field.
	USART_CFG_CTSEN_Pos = 0x9
	// Bit mask of CTSEN field.
	USART_CFG_CTSEN_Msk = 0x200
	// Bit CTSEN.
	USART_CFG_CTSEN = 0x200
	// No flow control. The transmitter does not receive any automatic flow control signal.
	USART_CFG_CTSEN_DISABLED = 0x0
	// Flow control enabled. The transmitter uses the CTS input (or RTS output in loopback mode) for flow control purposes.
	USART_CFG_CTSEN_ENABLED = 0x1
	// Position of SYNCEN field.
	USART_CFG_SYNCEN_Pos = 0xb
	// Bit mask of SYNCEN field.
	USART_CFG_SYNCEN_Msk = 0x800
	// Bit SYNCEN.
	USART_CFG_SYNCEN = 0x800
	// Asynchronous mode.
	USART_CFG_SYNCEN_ASYNCHRONOUS_MODE = 0x0
	// Synchronous mode.
	USART_CFG_SYNCEN_SYNCHRONOUS_MODE = 0x1
	// Position of CLKPOL field.
	USART_CFG_CLKPOL_Pos = 0xc
	// Bit mask of CLKPOL field.
	USART_CFG_CLKPOL_Msk = 0x1000
	// Bit CLKPOL.
	USART_CFG_CLKPOL = 0x1000
	// Falling edge. Un_RXD is sampled on the falling edge of SCLK.
	USART_CFG_CLKPOL_FALLING_EDGE = 0x0
	// Rising edge. Un_RXD is sampled on the rising edge of SCLK.
	USART_CFG_CLKPOL_RISING_EDGE = 0x1
	// Position of SYNCMST field.
	USART_CFG_SYNCMST_Pos = 0xe
	// Bit mask of SYNCMST field.
	USART_CFG_SYNCMST_Msk = 0x4000
	// Bit SYNCMST.
	USART_CFG_SYNCMST = 0x4000
	// Slave. When synchronous mode is enabled, the USART is a slave.
	USART_CFG_SYNCMST_SLAVE = 0x0
	// Master. When synchronous mode is enabled, the USART is a master.
	USART_CFG_SYNCMST_MASTER = 0x1
	// Position of LOOP field.
	USART_CFG_LOOP_Pos = 0xf
	// Bit mask of LOOP field.
	USART_CFG_LOOP_Msk = 0x8000
	// Bit LOOP.
	USART_CFG_LOOP = 0x8000
	// Normal operation.
	USART_CFG_LOOP_NORMAL = 0x0
	// Loopback mode. This provides a mechanism to perform diagnostic loopback testing for USART data. Serial data from the transmitter (Un_TXD) is connected internally to serial input of the receive (Un_RXD). Un_TXD and Un_RTS activity will also appear on external pins if these functions are configured to appear on device pins. The receiver RTS signal is also looped back to CTS and performs flow control if enabled by CTSEN.
	USART_CFG_LOOP_LOOPBACK = 0x1
	// Position of OETA field.
	USART_CFG_OETA_Pos = 0x12
	// Bit mask of OETA field.
	USART_CFG_OETA_Msk = 0x40000
	// Bit OETA.
	USART_CFG_OETA = 0x40000
	// Disabled. If selected by OESEL, the Output Enable signal deasserted at the end of the last stop bit of a transmission.
	USART_CFG_OETA_DISABLED = 0x0
	// Enabled. If selected by OESEL, the Output Enable signal remains asserted for one character time after the end of the last stop bit of a transmission. OE will also remain asserted if another transmit begins before it is deasserted.
	USART_CFG_OETA_ENABLED = 0x1
	// Position of AUTOADDR field.
	USART_CFG_AUTOADDR_Pos = 0x13
	// Bit mask of AUTOADDR field.
	USART_CFG_AUTOADDR_Msk = 0x80000
	// Bit AUTOADDR.
	USART_CFG_AUTOADDR = 0x80000
	// Disabled. When addressing is enabled by ADDRDET, address matching is done by software. This provides the possibility of versatile addressing (e.g. respond to more than one address).
	USART_CFG_AUTOADDR_DISABLED = 0x0
	// Enabled. When addressing is enabled by ADDRDET, address matching is done by hardware, using the value in the ADDR register as the address to match.
	USART_CFG_AUTOADDR_ENABLED = 0x1
	// Position of OESEL field.
	USART_CFG_OESEL_Pos = 0x14
	// Bit mask of OESEL field.
	USART_CFG_OESEL_Msk = 0x100000
	// Bit OESEL.
	USART_CFG_OESEL = 0x100000
	// Standard. The RTS signal is used as the standard flow control function.
	USART_CFG_OESEL_STANDARD = 0x0
	// RS-485. The RTS signal configured to provide an output enable signal to control an RS-485 transceiver.
	USART_CFG_OESEL_RS_485 = 0x1
	// Position of OEPOL field.
	USART_CFG_OEPOL_Pos = 0x15
	// Bit mask of OEPOL field.
	USART_CFG_OEPOL_Msk = 0x200000
	// Bit OEPOL.
	USART_CFG_OEPOL = 0x200000
	// Low. If selected by OESEL, the output enable is active low.
	USART_CFG_OEPOL_LOW = 0x0
	// High. If selected by OESEL, the output enable is active high.
	USART_CFG_OEPOL_HIGH = 0x1
	// Position of RXPOL field.
	USART_CFG_RXPOL_Pos = 0x16
	// Bit mask of RXPOL field.
	USART_CFG_RXPOL_Msk = 0x400000
	// Bit RXPOL.
	USART_CFG_RXPOL = 0x400000
	// Standard. The RX signal is used as it arrives from the pin. This means that the RX rest value is 1, start bit is 0, data is not inverted, and the stop bit is 1.
	USART_CFG_RXPOL_STANDARD = 0x0
	// Inverted. The RX signal is inverted before being used by the USART. This means that the RX rest value is 0, start bit is 1, data is inverted, and the stop bit is 0.
	USART_CFG_RXPOL_INVERTED = 0x1
	// Position of TXPOL field.
	USART_CFG_TXPOL_Pos = 0x17
	// Bit mask of TXPOL field.
	USART_CFG_TXPOL_Msk = 0x800000
	// Bit TXPOL.
	USART_CFG_TXPOL = 0x800000
	// Standard. The TX signal is sent out without change. This means that the TX rest value is 1, start bit is 0, data is not inverted, and the stop bit is 1.
	USART_CFG_TXPOL_STANDARD = 0x0
	// Inverted. The TX signal is inverted by the USART before being sent out. This means that the TX rest value is 0, start bit is 1, data is inverted, and the stop bit is 0.
	USART_CFG_TXPOL_INVERTED = 0x1

	// CTL: USART Control register. USART control settings that are more likely to change during operation.
	// Position of TXBRKEN field.
	USART_CTL_TXBRKEN_Pos = 0x1
	// Bit mask of TXBRKEN field.
	USART_CTL_TXBRKEN_Msk = 0x2
	// Bit TXBRKEN.
	USART_CTL_TXBRKEN = 0x2
	// Normal operation.
	USART_CTL_TXBRKEN_NORMAL = 0x0
	// Continuous break. Continuous break is sent immediately when this bit is set, and remains until this bit is cleared. A break may be sent without danger of corrupting any currently transmitting character if the transmitter is first disabled (TXDIS in CTL is set) and then waiting for the transmitter to be disabled (TXDISINT in STAT = 1) before writing 1 to TXBRKEN.
	USART_CTL_TXBRKEN_CONTINOUS = 0x1
	// Position of ADDRDET field.
	USART_CTL_ADDRDET_Pos = 0x2
	// Bit mask of ADDRDET field.
	USART_CTL_ADDRDET_Msk = 0x4
	// Bit ADDRDET.
	USART_CTL_ADDRDET = 0x4
	// Disabled. The USART presents all incoming data.
	USART_CTL_ADDRDET_DISABLED = 0x0
	// Enabled. The USART receiver ignores incoming data that does not have the most significant bit of the data (typically the 9th bit) = 1. When the data MSB bit = 1, the receiver treats the incoming data normally, generating a received data interrupt. Software can then check the data to see if this is an address that should be handled. If it is, the ADDRDET bit is cleared by software and further incoming data is handled normally.
	USART_CTL_ADDRDET_ENABLED = 0x1
	// Position of TXDIS field.
	USART_CTL_TXDIS_Pos = 0x6
	// Bit mask of TXDIS field.
	USART_CTL_TXDIS_Msk = 0x40
	// Bit TXDIS.
	USART_CTL_TXDIS = 0x40
	// Not disabled. USART transmitter is not disabled.
	USART_CTL_TXDIS_ENABLED = 0x0
	// Disabled. USART transmitter is disabled after any character currently being transmitted is complete. This feature can be used to facilitate software flow control.
	USART_CTL_TXDIS_DISABLED = 0x1
	// Position of CC field.
	USART_CTL_CC_Pos = 0x8
	// Bit mask of CC field.
	USART_CTL_CC_Msk = 0x100
	// Bit CC.
	USART_CTL_CC = 0x100
	// Clock on character. In synchronous mode, SCLK cycles only when characters are being sent on Un_TXD or to complete a character that is being received.
	USART_CTL_CC_CLOCK_ON_CHARACTER = 0x0
	// Continuous clock. SCLK runs continuously in synchronous mode, allowing characters to be received on Un_RxD independently from transmission on Un_TXD).
	USART_CTL_CC_CONTINOUS_CLOCK = 0x1
	// Position of CLRCCONRX field.
	USART_CTL_CLRCCONRX_Pos = 0x9
	// Bit mask of CLRCCONRX field.
	USART_CTL_CLRCCONRX_Msk = 0x200
	// Bit CLRCCONRX.
	USART_CTL_CLRCCONRX = 0x200
	// No effect. No effect on the CC bit.
	USART_CTL_CLRCCONRX_NO_EFFECT = 0x0
	// Auto-clear. The CC bit is automatically cleared when a complete character has been received. This bit is cleared at the same time.
	USART_CTL_CLRCCONRX_AUTO_CLEAR = 0x1
	// Position of AUTOBAUD field.
	USART_CTL_AUTOBAUD_Pos = 0x10
	// Bit mask of AUTOBAUD field.
	USART_CTL_AUTOBAUD_Msk = 0x10000
	// Bit AUTOBAUD.
	USART_CTL_AUTOBAUD = 0x10000
	// Disabled. USART is in normal operating mode.
	USART_CTL_AUTOBAUD_DISABLED = 0x0
	// Enabled. USART is in autobaud mode. This bit should only be set when the USART receiver is idle. The first start bit of RX is measured and used the update the BRG register to match the received data rate. AUTOBAUD is cleared once this process is complete, or if there is an AERR.
	USART_CTL_AUTOBAUD_ENABLED = 0x1

	// STAT: USART Status register. The complete status value can be read here. Writing ones clears some bits in the register. Some bits can be cleared by writing a 1 to them.
	// Position of RXIDLE field.
	USART_STAT_RXIDLE_Pos = 0x1
	// Bit mask of RXIDLE field.
	USART_STAT_RXIDLE_Msk = 0x2
	// Bit RXIDLE.
	USART_STAT_RXIDLE = 0x2
	// Position of TXIDLE field.
	USART_STAT_TXIDLE_Pos = 0x3
	// Bit mask of TXIDLE field.
	USART_STAT_TXIDLE_Msk = 0x8
	// Bit TXIDLE.
	USART_STAT_TXIDLE = 0x8
	// Position of CTS field.
	USART_STAT_CTS_Pos = 0x4
	// Bit mask of CTS field.
	USART_STAT_CTS_Msk = 0x10
	// Bit CTS.
	USART_STAT_CTS = 0x10
	// Position of DELTACTS field.
	USART_STAT_DELTACTS_Pos = 0x5
	// Bit mask of DELTACTS field.
	USART_STAT_DELTACTS_Msk = 0x20
	// Bit DELTACTS.
	USART_STAT_DELTACTS = 0x20
	// Position of TXDISSTAT field.
	USART_STAT_TXDISSTAT_Pos = 0x6
	// Bit mask of TXDISSTAT field.
	USART_STAT_TXDISSTAT_Msk = 0x40
	// Bit TXDISSTAT.
	USART_STAT_TXDISSTAT = 0x40
	// Position of RXBRK field.
	USART_STAT_RXBRK_Pos = 0xa
	// Bit mask of RXBRK field.
	USART_STAT_RXBRK_Msk = 0x400
	// Bit RXBRK.
	USART_STAT_RXBRK = 0x400
	// Position of DELTARXBRK field.
	USART_STAT_DELTARXBRK_Pos = 0xb
	// Bit mask of DELTARXBRK field.
	USART_STAT_DELTARXBRK_Msk = 0x800
	// Bit DELTARXBRK.
	USART_STAT_DELTARXBRK = 0x800
	// Position of START field.
	USART_STAT_START_Pos = 0xc
	// Bit mask of START field.
	USART_STAT_START_Msk = 0x1000
	// Bit START.
	USART_STAT_START = 0x1000
	// Position of FRAMERRINT field.
	USART_STAT_FRAMERRINT_Pos = 0xd
	// Bit mask of FRAMERRINT field.
	USART_STAT_FRAMERRINT_Msk = 0x2000
	// Bit FRAMERRINT.
	USART_STAT_FRAMERRINT = 0x2000
	// Position of PARITYERRINT field.
	USART_STAT_PARITYERRINT_Pos = 0xe
	// Bit mask of PARITYERRINT field.
	USART_STAT_PARITYERRINT_Msk = 0x4000
	// Bit PARITYERRINT.
	USART_STAT_PARITYERRINT = 0x4000
	// Position of RXNOISEINT field.
	USART_STAT_RXNOISEINT_Pos = 0xf
	// Bit mask of RXNOISEINT field.
	USART_STAT_RXNOISEINT_Msk = 0x8000
	// Bit RXNOISEINT.
	USART_STAT_RXNOISEINT = 0x8000
	// Position of ABERR field.
	USART_STAT_ABERR_Pos = 0x10
	// Bit mask of ABERR field.
	USART_STAT_ABERR_Msk = 0x10000
	// Bit ABERR.
	USART_STAT_ABERR = 0x10000

	// INTENSET: Interrupt Enable read and Set register for USART (not FIFO) status. Contains individual interrupt enable bits for each potential USART interrupt. A complete value may be read from this register. Writing a 1 to any implemented bit position causes that bit to be set.
	// Position of TXIDLEEN field.
	USART_INTENSET_TXIDLEEN_Pos = 0x3
	// Bit mask of TXIDLEEN field.
	USART_INTENSET_TXIDLEEN_Msk = 0x8
	// Bit TXIDLEEN.
	USART_INTENSET_TXIDLEEN = 0x8
	// Position of DELTACTSEN field.
	USART_INTENSET_DELTACTSEN_Pos = 0x5
	// Bit mask of DELTACTSEN field.
	USART_INTENSET_DELTACTSEN_Msk = 0x20
	// Bit DELTACTSEN.
	USART_INTENSET_DELTACTSEN = 0x20
	// Position of TXDISEN field.
	USART_INTENSET_TXDISEN_Pos = 0x6
	// Bit mask of TXDISEN field.
	USART_INTENSET_TXDISEN_Msk = 0x40
	// Bit TXDISEN.
	USART_INTENSET_TXDISEN = 0x40
	// Position of DELTARXBRKEN field.
	USART_INTENSET_DELTARXBRKEN_Pos = 0xb
	// Bit mask of DELTARXBRKEN field.
	USART_INTENSET_DELTARXBRKEN_Msk = 0x800
	// Bit DELTARXBRKEN.
	USART_INTENSET_DELTARXBRKEN = 0x800
	// Position of STARTEN field.
	USART_INTENSET_STARTEN_Pos = 0xc
	// Bit mask of STARTEN field.
	USART_INTENSET_STARTEN_Msk = 0x1000
	// Bit STARTEN.
	USART_INTENSET_STARTEN = 0x1000
	// Position of FRAMERREN field.
	USART_INTENSET_FRAMERREN_Pos = 0xd
	// Bit mask of FRAMERREN field.
	USART_INTENSET_FRAMERREN_Msk = 0x2000
	// Bit FRAMERREN.
	USART_INTENSET_FRAMERREN = 0x2000
	// Position of PARITYERREN field.
	USART_INTENSET_PARITYERREN_Pos = 0xe
	// Bit mask of PARITYERREN field.
	USART_INTENSET_PARITYERREN_Msk = 0x4000
	// Bit PARITYERREN.
	USART_INTENSET_PARITYERREN = 0x4000
	// Position of RXNOISEEN field.
	USART_INTENSET_RXNOISEEN_Pos = 0xf
	// Bit mask of RXNOISEEN field.
	USART_INTENSET_RXNOISEEN_Msk = 0x8000
	// Bit RXNOISEEN.
	USART_INTENSET_RXNOISEEN = 0x8000
	// Position of ABERREN field.
	USART_INTENSET_ABERREN_Pos = 0x10
	// Bit mask of ABERREN field.
	USART_INTENSET_ABERREN_Msk = 0x10000
	// Bit ABERREN.
	USART_INTENSET_ABERREN = 0x10000

	// INTENCLR: Interrupt Enable Clear register. Allows clearing any combination of bits in the INTENSET register. Writing a 1 to any implemented bit position causes the corresponding bit to be cleared.
	// Position of TXIDLECLR field.
	USART_INTENCLR_TXIDLECLR_Pos = 0x3
	// Bit mask of TXIDLECLR field.
	USART_INTENCLR_TXIDLECLR_Msk = 0x8
	// Bit TXIDLECLR.
	USART_INTENCLR_TXIDLECLR = 0x8
	// Position of DELTACTSCLR field.
	USART_INTENCLR_DELTACTSCLR_Pos = 0x5
	// Bit mask of DELTACTSCLR field.
	USART_INTENCLR_DELTACTSCLR_Msk = 0x20
	// Bit DELTACTSCLR.
	USART_INTENCLR_DELTACTSCLR = 0x20
	// Position of TXDISCLR field.
	USART_INTENCLR_TXDISCLR_Pos = 0x6
	// Bit mask of TXDISCLR field.
	USART_INTENCLR_TXDISCLR_Msk = 0x40
	// Bit TXDISCLR.
	USART_INTENCLR_TXDISCLR = 0x40
	// Position of DELTARXBRKCLR field.
	USART_INTENCLR_DELTARXBRKCLR_Pos = 0xb
	// Bit mask of DELTARXBRKCLR field.
	USART_INTENCLR_DELTARXBRKCLR_Msk = 0x800
	// Bit DELTARXBRKCLR.
	USART_INTENCLR_DELTARXBRKCLR = 0x800
	// Position of STARTCLR field.
	USART_INTENCLR_STARTCLR_Pos = 0xc
	// Bit mask of STARTCLR field.
	USART_INTENCLR_STARTCLR_Msk = 0x1000
	// Bit STARTCLR.
	USART_INTENCLR_STARTCLR = 0x1000
	// Position of FRAMERRCLR field.
	USART_INTENCLR_FRAMERRCLR_Pos = 0xd
	// Bit mask of FRAMERRCLR field.
	USART_INTENCLR_FRAMERRCLR_Msk = 0x2000
	// Bit FRAMERRCLR.
	USART_INTENCLR_FRAMERRCLR = 0x2000
	// Position of PARITYERRCLR field.
	USART_INTENCLR_PARITYERRCLR_Pos = 0xe
	// Bit mask of PARITYERRCLR field.
	USART_INTENCLR_PARITYERRCLR_Msk = 0x4000
	// Bit PARITYERRCLR.
	USART_INTENCLR_PARITYERRCLR = 0x4000
	// Position of RXNOISECLR field.
	USART_INTENCLR_RXNOISECLR_Pos = 0xf
	// Bit mask of RXNOISECLR field.
	USART_INTENCLR_RXNOISECLR_Msk = 0x8000
	// Bit RXNOISECLR.
	USART_INTENCLR_RXNOISECLR = 0x8000
	// Position of ABERRCLR field.
	USART_INTENCLR_ABERRCLR_Pos = 0x10
	// Bit mask of ABERRCLR field.
	USART_INTENCLR_ABERRCLR_Msk = 0x10000
	// Bit ABERRCLR.
	USART_INTENCLR_ABERRCLR = 0x10000

	// BRG: Baud Rate Generator register. 16-bit integer baud rate divisor value.
	// Position of BRGVAL field.
	USART_BRG_BRGVAL_Pos = 0x0
	// Bit mask of BRGVAL field.
	USART_BRG_BRGVAL_Msk = 0xffff

	// INTSTAT: Interrupt status register. Reflects interrupts that are currently enabled.
	// Position of TXIDLE field.
	USART_INTSTAT_TXIDLE_Pos = 0x3
	// Bit mask of TXIDLE field.
	USART_INTSTAT_TXIDLE_Msk = 0x8
	// Bit TXIDLE.
	USART_INTSTAT_TXIDLE = 0x8
	// Position of DELTACTS field.
	USART_INTSTAT_DELTACTS_Pos = 0x5
	// Bit mask of DELTACTS field.
	USART_INTSTAT_DELTACTS_Msk = 0x20
	// Bit DELTACTS.
	USART_INTSTAT_DELTACTS = 0x20
	// Position of TXDISINT field.
	USART_INTSTAT_TXDISINT_Pos = 0x6
	// Bit mask of TXDISINT field.
	USART_INTSTAT_TXDISINT_Msk = 0x40
	// Bit TXDISINT.
	USART_INTSTAT_TXDISINT = 0x40
	// Position of DELTARXBRK field.
	USART_INTSTAT_DELTARXBRK_Pos = 0xb
	// Bit mask of DELTARXBRK field.
	USART_INTSTAT_DELTARXBRK_Msk = 0x800
	// Bit DELTARXBRK.
	USART_INTSTAT_DELTARXBRK = 0x800
	// Position of START field.
	USART_INTSTAT_START_Pos = 0xc
	// Bit mask of START field.
	USART_INTSTAT_START_Msk = 0x1000
	// Bit START.
	USART_INTSTAT_START = 0x1000
	// Position of FRAMERRINT field.
	USART_INTSTAT_FRAMERRINT_Pos = 0xd
	// Bit mask of FRAMERRINT field.
	USART_INTSTAT_FRAMERRINT_Msk = 0x2000
	// Bit FRAMERRINT.
	USART_INTSTAT_FRAMERRINT = 0x2000
	// Position of PARITYERRINT field.
	USART_INTSTAT_PARITYERRINT_Pos = 0xe
	// Bit mask of PARITYERRINT field.
	USART_INTSTAT_PARITYERRINT_Msk = 0x4000
	// Bit PARITYERRINT.
	USART_INTSTAT_PARITYERRINT = 0x4000
	// Position of RXNOISEINT field.
	USART_INTSTAT_RXNOISEINT_Pos = 0xf
	// Bit mask of RXNOISEINT field.
	USART_INTSTAT_RXNOISEINT_Msk = 0x8000
	// Bit RXNOISEINT.
	USART_INTSTAT_RXNOISEINT = 0x8000
	// Position of ABERRINT field.
	USART_INTSTAT_ABERRINT_Pos = 0x10
	// Bit mask of ABERRINT field.
	USART_INTSTAT_ABERRINT_Msk = 0x10000
	// Bit ABERRINT.
	USART_INTSTAT_ABERRINT = 0x10000

	// OSR: Oversample selection register for asynchronous communication.
	// Position of OSRVAL field.
	USART_OSR_OSRVAL_Pos = 0x0
	// Bit mask of OSRVAL field.
	USART_OSR_OSRVAL_Msk = 0xf

	// ADDR: Address register for automatic address matching.
	// Position of ADDRESS field.
	USART_ADDR_ADDRESS_Pos = 0x0
	// Bit mask of ADDRESS field.
	USART_ADDR_ADDRESS_Msk = 0xff

	// FIFOCFG: FIFO configuration and enable register.
	// Position of ENABLETX field.
	USART_FIFOCFG_ENABLETX_Pos = 0x0
	// Bit mask of ENABLETX field.
	USART_FIFOCFG_ENABLETX_Msk = 0x1
	// Bit ENABLETX.
	USART_FIFOCFG_ENABLETX = 0x1
	// The transmit FIFO is not enabled.
	USART_FIFOCFG_ENABLETX_DISABLED = 0x0
	// The transmit FIFO is enabled.
	USART_FIFOCFG_ENABLETX_ENABLED = 0x1
	// Position of ENABLERX field.
	USART_FIFOCFG_ENABLERX_Pos = 0x1
	// Bit mask of ENABLERX field.
	USART_FIFOCFG_ENABLERX_Msk = 0x2
	// Bit ENABLERX.
	USART_FIFOCFG_ENABLERX = 0x2
	// The receive FIFO is not enabled.
	USART_FIFOCFG_ENABLERX_DISABLED = 0x0
	// The receive FIFO is enabled.
	USART_FIFOCFG_ENABLERX_ENABLED = 0x1
	// Position of SIZE field.
	USART_FIFOCFG_SIZE_Pos = 0x4
	// Bit mask of SIZE field.
	USART_FIFOCFG_SIZE_Msk = 0x30
	// Position of DMATX field.
	USART_FIFOCFG_DMATX_Pos = 0xc
	// Bit mask of DMATX field.
	USART_FIFOCFG_DMATX_Msk = 0x1000
	// Bit DMATX.
	USART_FIFOCFG_DMATX = 0x1000
	// DMA is not used for the transmit function.
	USART_FIFOCFG_DMATX_DISABLED = 0x0
	// Trigger DMA for the transmit function if the FIFO is not full. Generally, data interrupts would be disabled if DMA is enabled.
	USART_FIFOCFG_DMATX_ENABLED = 0x1
	// Position of DMARX field.
	USART_FIFOCFG_DMARX_Pos = 0xd
	// Bit mask of DMARX field.
	USART_FIFOCFG_DMARX_Msk = 0x2000
	// Bit DMARX.
	USART_FIFOCFG_DMARX = 0x2000
	// DMA is not used for the receive function.
	USART_FIFOCFG_DMARX_DISABLED = 0x0
	// Trigger DMA for the receive function if the FIFO is not empty. Generally, data interrupts would be disabled if DMA is enabled.
	USART_FIFOCFG_DMARX_ENABLED = 0x1
	// Position of EMPTYTX field.
	USART_FIFOCFG_EMPTYTX_Pos = 0x10
	// Bit mask of EMPTYTX field.
	USART_FIFOCFG_EMPTYTX_Msk = 0x10000
	// Bit EMPTYTX.
	USART_FIFOCFG_EMPTYTX = 0x10000
	// Position of EMPTYRX field.
	USART_FIFOCFG_EMPTYRX_Pos = 0x11
	// Bit mask of EMPTYRX field.
	USART_FIFOCFG_EMPTYRX_Msk = 0x20000
	// Bit EMPTYRX.
	USART_FIFOCFG_EMPTYRX = 0x20000

	// FIFOSTAT: FIFO status register.
	// Position of TXERR field.
	USART_FIFOSTAT_TXERR_Pos = 0x0
	// Bit mask of TXERR field.
	USART_FIFOSTAT_TXERR_Msk = 0x1
	// Bit TXERR.
	USART_FIFOSTAT_TXERR = 0x1
	// Position of RXERR field.
	USART_FIFOSTAT_RXERR_Pos = 0x1
	// Bit mask of RXERR field.
	USART_FIFOSTAT_RXERR_Msk = 0x2
	// Bit RXERR.
	USART_FIFOSTAT_RXERR = 0x2
	// Position of PERINT field.
	USART_FIFOSTAT_PERINT_Pos = 0x3
	// Bit mask of PERINT field.
	USART_FIFOSTAT_PERINT_Msk = 0x8
	// Bit PERINT.
	USART_FIFOSTAT_PERINT = 0x8
	// Position of TXEMPTY field.
	USART_FIFOSTAT_TXEMPTY_Pos = 0x4
	// Bit mask of TXEMPTY field.
	USART_FIFOSTAT_TXEMPTY_Msk = 0x10
	// Bit TXEMPTY.
	USART_FIFOSTAT_TXEMPTY = 0x10
	// Position of TXNOTFULL field.
	USART_FIFOSTAT_TXNOTFULL_Pos = 0x5
	// Bit mask of TXNOTFULL field.
	USART_FIFOSTAT_TXNOTFULL_Msk = 0x20
	// Bit TXNOTFULL.
	USART_FIFOSTAT_TXNOTFULL = 0x20
	// Position of RXNOTEMPTY field.
	USART_FIFOSTAT_RXNOTEMPTY_Pos = 0x6
	// Bit mask of RXNOTEMPTY field.
	USART_FIFOSTAT_RXNOTEMPTY_Msk = 0x40
	// Bit RXNOTEMPTY.
	USART_FIFOSTAT_RXNOTEMPTY = 0x40
	// Position of RXFULL field.
	USART_FIFOSTAT_RXFULL_Pos = 0x7
	// Bit mask of RXFULL field.
	USART_FIFOSTAT_RXFULL_Msk = 0x80
	// Bit RXFULL.
	USART_FIFOSTAT_RXFULL = 0x80
	// Position of TXLVL field.
	USART_FIFOSTAT_TXLVL_Pos = 0x8
	// Bit mask of TXLVL field.
	USART_FIFOSTAT_TXLVL_Msk = 0x1f00
	// Position of RXLVL field.
	USART_FIFOSTAT_RXLVL_Pos = 0x10
	// Bit mask of RXLVL field.
	USART_FIFOSTAT_RXLVL_Msk = 0x1f0000

	// FIFOTRIG: FIFO trigger settings for interrupt and DMA request.
	// Position of TXLVLENA field.
	USART_FIFOTRIG_TXLVLENA_Pos = 0x0
	// Bit mask of TXLVLENA field.
	USART_FIFOTRIG_TXLVLENA_Msk = 0x1
	// Bit TXLVLENA.
	USART_FIFOTRIG_TXLVLENA = 0x1
	// Transmit FIFO level does not generate a FIFO level trigger.
	USART_FIFOTRIG_TXLVLENA_DISABLED = 0x0
	// An trigger will be generated if the transmit FIFO level reaches the value specified by the TXLVL field in this register.
	USART_FIFOTRIG_TXLVLENA_ENABLED = 0x1
	// Position of RXLVLENA field.
	USART_FIFOTRIG_RXLVLENA_Pos = 0x1
	// Bit mask of RXLVLENA field.
	USART_FIFOTRIG_RXLVLENA_Msk = 0x2
	// Bit RXLVLENA.
	USART_FIFOTRIG_RXLVLENA = 0x2
	// Receive FIFO level does not generate a FIFO level trigger.
	USART_FIFOTRIG_RXLVLENA_DISABLED = 0x0
	// An trigger will be generated if the receive FIFO level reaches the value specified by the RXLVL field in this register.
	USART_FIFOTRIG_RXLVLENA_ENABLED = 0x1
	// Position of TXLVL field.
	USART_FIFOTRIG_TXLVL_Pos = 0x8
	// Bit mask of TXLVL field.
	USART_FIFOTRIG_TXLVL_Msk = 0xf00
	// Position of RXLVL field.
	USART_FIFOTRIG_RXLVL_Pos = 0x10
	// Bit mask of RXLVL field.
	USART_FIFOTRIG_RXLVL_Msk = 0xf0000

	// FIFOINTENSET: FIFO interrupt enable set (enable) and read register.
	// Position of TXERR field.
	USART_FIFOINTENSET_TXERR_Pos = 0x0
	// Bit mask of TXERR field.
	USART_FIFOINTENSET_TXERR_Msk = 0x1
	// Bit TXERR.
	USART_FIFOINTENSET_TXERR = 0x1
	// No interrupt will be generated for a transmit error.
	USART_FIFOINTENSET_TXERR_DISABLED = 0x0
	// An interrupt will be generated when a transmit error occurs.
	USART_FIFOINTENSET_TXERR_ENABLED = 0x1
	// Position of RXERR field.
	USART_FIFOINTENSET_RXERR_Pos = 0x1
	// Bit mask of RXERR field.
	USART_FIFOINTENSET_RXERR_Msk = 0x2
	// Bit RXERR.
	USART_FIFOINTENSET_RXERR = 0x2
	// No interrupt will be generated for a receive error.
	USART_FIFOINTENSET_RXERR_DISABLED = 0x0
	// An interrupt will be generated when a receive error occurs.
	USART_FIFOINTENSET_RXERR_ENABLED = 0x1
	// Position of TXLVL field.
	USART_FIFOINTENSET_TXLVL_Pos = 0x2
	// Bit mask of TXLVL field.
	USART_FIFOINTENSET_TXLVL_Msk = 0x4
	// Bit TXLVL.
	USART_FIFOINTENSET_TXLVL = 0x4
	// No interrupt will be generated based on the TX FIFO level.
	USART_FIFOINTENSET_TXLVL_DISABLED = 0x0
	// If TXLVLENA in the FIFOTRIG register = 1, an interrupt will be generated when the TX FIFO level decreases to the level specified by TXLVL in the FIFOTRIG register.
	USART_FIFOINTENSET_TXLVL_ENABLED = 0x1
	// Position of RXLVL field.
	USART_FIFOINTENSET_RXLVL_Pos = 0x3
	// Bit mask of RXLVL field.
	USART_FIFOINTENSET_RXLVL_Msk = 0x8
	// Bit RXLVL.
	USART_FIFOINTENSET_RXLVL = 0x8
	// No interrupt will be generated based on the RX FIFO level.
	USART_FIFOINTENSET_RXLVL_DISABLED = 0x0
	// If RXLVLENA in the FIFOTRIG register = 1, an interrupt will be generated when the when the RX FIFO level increases to the level specified by RXLVL in the FIFOTRIG register.
	USART_FIFOINTENSET_RXLVL_ENABLED = 0x1

	// FIFOINTENCLR: FIFO interrupt enable clear (disable) and read register.
	// Position of TXERR field.
	USART_FIFOINTENCLR_TXERR_Pos = 0x0
	// Bit mask of TXERR field.
	USART_FIFOINTENCLR_TXERR_Msk = 0x1
	// Bit TXERR.
	USART_FIFOINTENCLR_TXERR = 0x1
	// Position of RXERR field.
	USART_FIFOINTENCLR_RXERR_Pos = 0x1
	// Bit mask of RXERR field.
	USART_FIFOINTENCLR_RXERR_Msk = 0x2
	// Bit RXERR.
	USART_FIFOINTENCLR_RXERR = 0x2
	// Position of TXLVL field.
	USART_FIFOINTENCLR_TXLVL_Pos = 0x2
	// Bit mask of TXLVL field.
	USART_FIFOINTENCLR_TXLVL_Msk = 0x4
	// Bit TXLVL.
	USART_FIFOINTENCLR_TXLVL = 0x4
	// Position of RXLVL field.
	USART_FIFOINTENCLR_RXLVL_Pos = 0x3
	// Bit mask of RXLVL field.
	USART_FIFOINTENCLR_RXLVL_Msk = 0x8
	// Bit RXLVL.
	USART_FIFOINTENCLR_RXLVL = 0x8

	// FIFOINTSTAT: FIFO interrupt status register.
	// Position of TXERR field.
	USART_FIFOINTSTAT_TXERR_Pos = 0x0
	// Bit mask of TXERR field.
	USART_FIFOINTSTAT_TXERR_Msk = 0x1
	// Bit TXERR.
	USART_FIFOINTSTAT_TXERR = 0x1
	// Position of RXERR field.
	USART_FIFOINTSTAT_RXERR_Pos = 0x1
	// Bit mask of RXERR field.
	USART_FIFOINTSTAT_RXERR_Msk = 0x2
	// Bit RXERR.
	USART_FIFOINTSTAT_RXERR = 0x2
	// Position of TXLVL field.
	USART_FIFOINTSTAT_TXLVL_Pos = 0x2
	// Bit mask of TXLVL field.
	USART_FIFOINTSTAT_TXLVL_Msk = 0x4
	// Bit TXLVL.
	USART_FIFOINTSTAT_TXLVL = 0x4
	// Position of RXLVL field.
	USART_FIFOINTSTAT_RXLVL_Pos = 0x3
	// Bit mask of RXLVL field.
	USART_FIFOINTSTAT_RXLVL_Msk = 0x8
	// Bit RXLVL.
	USART_FIFOINTSTAT_RXLVL = 0x8
	// Position of PERINT field.
	USART_FIFOINTSTAT_PERINT_Pos = 0x4
	// Bit mask of PERINT field.
	USART_FIFOINTSTAT_PERINT_Msk = 0x10
	// Bit PERINT.
	USART_FIFOINTSTAT_PERINT = 0x10

	// FIFOWR: FIFO write data.
	// Position of TXDATA field.
	USART_FIFOWR_TXDATA_Pos = 0x0
	// Bit mask of TXDATA field.
	USART_FIFOWR_TXDATA_Msk = 0x1ff

	// FIFORD: FIFO read data.
	// Position of RXDATA field.
	USART_FIFORD_RXDATA_Pos = 0x0
	// Bit mask of RXDATA field.
	USART_FIFORD_RXDATA_Msk = 0x1ff
	// Position of FRAMERR field.
	USART_FIFORD_FRAMERR_Pos = 0xd
	// Bit mask of FRAMERR field.
	USART_FIFORD_FRAMERR_Msk = 0x2000
	// Bit FRAMERR.
	USART_FIFORD_FRAMERR = 0x2000
	// Position of PARITYERR field.
	USART_FIFORD_PARITYERR_Pos = 0xe
	// Bit mask of PARITYERR field.
	USART_FIFORD_PARITYERR_Msk = 0x4000
	// Bit PARITYERR.
	USART_FIFORD_PARITYERR = 0x4000
	// Position of RXNOISE field.
	USART_FIFORD_RXNOISE_Pos = 0xf
	// Bit mask of RXNOISE field.
	USART_FIFORD_RXNOISE_Msk = 0x8000
	// Bit RXNOISE.
	USART_FIFORD_RXNOISE = 0x8000

	// FIFORDNOPOP: FIFO data read with no FIFO pop.
	// Position of RXDATA field.
	USART_FIFORDNOPOP_RXDATA_Pos = 0x0
	// Bit mask of RXDATA field.
	USART_FIFORDNOPOP_RXDATA_Msk = 0x1ff
	// Position of FRAMERR field.
	USART_FIFORDNOPOP_FRAMERR_Pos = 0xd
	// Bit mask of FRAMERR field.
	USART_FIFORDNOPOP_FRAMERR_Msk = 0x2000
	// Bit FRAMERR.
	USART_FIFORDNOPOP_FRAMERR = 0x2000
	// Position of PARITYERR field.
	USART_FIFORDNOPOP_PARITYERR_Pos = 0xe
	// Bit mask of PARITYERR field.
	USART_FIFORDNOPOP_PARITYERR_Msk = 0x4000
	// Bit PARITYERR.
	USART_FIFORDNOPOP_PARITYERR = 0x4000
	// Position of RXNOISE field.
	USART_FIFORDNOPOP_RXNOISE_Pos = 0xf
	// Bit mask of RXNOISE field.
	USART_FIFORDNOPOP_RXNOISE_Msk = 0x8000
	// Bit RXNOISE.
	USART_FIFORDNOPOP_RXNOISE = 0x8000

	// ID: USART module Identification. This value appears in the shared Flexcomm peripheral ID register when USART is selected.
	// Position of APERTURE field.
	USART_ID_APERTURE_Pos = 0x0
	// Bit mask of APERTURE field.
	USART_ID_APERTURE_Msk = 0xff
	// Position of MINOR_REV field.
	USART_ID_MINOR_REV_Pos = 0x8
	// Bit mask of MINOR_REV field.
	USART_ID_MINOR_REV_Msk = 0xf00
	// Position of MAJOR_REV field.
	USART_ID_MAJOR_REV_Pos = 0xc
	// Bit mask of MAJOR_REV field.
	USART_ID_MAJOR_REV_Msk = 0xf000
	// Position of ID field.
	USART_ID_ID_Pos = 0x10
	// Bit mask of ID field.
	USART_ID_ID_Msk = 0xffff0000
)

// Constants for USB0: usb
const (
	// DEVCMDSTAT: USB Device Command/Status register
	// Position of DEV_ADDR field.
	USB_DEVCMDSTAT_DEV_ADDR_Pos = 0x0
	// Bit mask of DEV_ADDR field.
	USB_DEVCMDSTAT_DEV_ADDR_Msk = 0x7f
	// Position of DEV_EN field.
	USB_DEVCMDSTAT_DEV_EN_Pos = 0x7
	// Bit mask of DEV_EN field.
	USB_DEVCMDSTAT_DEV_EN_Msk = 0x80
	// Bit DEV_EN.
	USB_DEVCMDSTAT_DEV_EN = 0x80
	// Position of SETUP field.
	USB_DEVCMDSTAT_SETUP_Pos = 0x8
	// Bit mask of SETUP field.
	USB_DEVCMDSTAT_SETUP_Msk = 0x100
	// Bit SETUP.
	USB_DEVCMDSTAT_SETUP = 0x100
	// Position of FORCE_NEEDCLK field.
	USB_DEVCMDSTAT_FORCE_NEEDCLK_Pos = 0x9
	// Bit mask of FORCE_NEEDCLK field.
	USB_DEVCMDSTAT_FORCE_NEEDCLK_Msk = 0x200
	// Bit FORCE_NEEDCLK.
	USB_DEVCMDSTAT_FORCE_NEEDCLK = 0x200
	// USB_NEEDCLK has normal function.
	USB_DEVCMDSTAT_FORCE_NEEDCLK_NORMAL = 0x0
	// USB_NEEDCLK always 1. Clock will not be stopped in case of suspend.
	USB_DEVCMDSTAT_FORCE_NEEDCLK_ALWAYS_ON = 0x1
	// Position of LPM_SUP field.
	USB_DEVCMDSTAT_LPM_SUP_Pos = 0xb
	// Bit mask of LPM_SUP field.
	USB_DEVCMDSTAT_LPM_SUP_Msk = 0x800
	// Bit LPM_SUP.
	USB_DEVCMDSTAT_LPM_SUP = 0x800
	// LPM not supported.
	USB_DEVCMDSTAT_LPM_SUP_NO = 0x0
	// LPM supported.
	USB_DEVCMDSTAT_LPM_SUP_YES = 0x1
	// Position of INTONNAK_AO field.
	USB_DEVCMDSTAT_INTONNAK_AO_Pos = 0xc
	// Bit mask of INTONNAK_AO field.
	USB_DEVCMDSTAT_INTONNAK_AO_Msk = 0x1000
	// Bit INTONNAK_AO.
	USB_DEVCMDSTAT_INTONNAK_AO = 0x1000
	// Only acknowledged packets generate an interrupt
	USB_DEVCMDSTAT_INTONNAK_AO_DISABLED = 0x0
	// Both acknowledged and NAKed packets generate interrupts.
	USB_DEVCMDSTAT_INTONNAK_AO_ENABLED = 0x1
	// Position of INTONNAK_AI field.
	USB_DEVCMDSTAT_INTONNAK_AI_Pos = 0xd
	// Bit mask of INTONNAK_AI field.
	USB_DEVCMDSTAT_INTONNAK_AI_Msk = 0x2000
	// Bit INTONNAK_AI.
	USB_DEVCMDSTAT_INTONNAK_AI = 0x2000
	// Only acknowledged packets generate an interrupt
	USB_DEVCMDSTAT_INTONNAK_AI_DISABLED = 0x0
	// Both acknowledged and NAKed packets generate interrupts.
	USB_DEVCMDSTAT_INTONNAK_AI_ENABLED = 0x1
	// Position of INTONNAK_CO field.
	USB_DEVCMDSTAT_INTONNAK_CO_Pos = 0xe
	// Bit mask of INTONNAK_CO field.
	USB_DEVCMDSTAT_INTONNAK_CO_Msk = 0x4000
	// Bit INTONNAK_CO.
	USB_DEVCMDSTAT_INTONNAK_CO = 0x4000
	// Only acknowledged packets generate an interrupt
	USB_DEVCMDSTAT_INTONNAK_CO_DISABLED = 0x0
	// Both acknowledged and NAKed packets generate interrupts.
	USB_DEVCMDSTAT_INTONNAK_CO_ENABLED = 0x1
	// Position of INTONNAK_CI field.
	USB_DEVCMDSTAT_INTONNAK_CI_Pos = 0xf
	// Bit mask of INTONNAK_CI field.
	USB_DEVCMDSTAT_INTONNAK_CI_Msk = 0x8000
	// Bit INTONNAK_CI.
	USB_DEVCMDSTAT_INTONNAK_CI = 0x8000
	// Only acknowledged packets generate an interrupt
	USB_DEVCMDSTAT_INTONNAK_CI_DISABLED = 0x0
	// Both acknowledged and NAKed packets generate interrupts.
	USB_DEVCMDSTAT_INTONNAK_CI_ENABLED = 0x1
	// Position of DCON field.
	USB_DEVCMDSTAT_DCON_Pos = 0x10
	// Bit mask of DCON field.
	USB_DEVCMDSTAT_DCON_Msk = 0x10000
	// Bit DCON.
	USB_DEVCMDSTAT_DCON = 0x10000
	// Position of DSUS field.
	USB_DEVCMDSTAT_DSUS_Pos = 0x11
	// Bit mask of DSUS field.
	USB_DEVCMDSTAT_DSUS_Msk = 0x20000
	// Bit DSUS.
	USB_DEVCMDSTAT_DSUS = 0x20000
	// Position of LPM_SUS field.
	USB_DEVCMDSTAT_LPM_SUS_Pos = 0x13
	// Bit mask of LPM_SUS field.
	USB_DEVCMDSTAT_LPM_SUS_Msk = 0x80000
	// Bit LPM_SUS.
	USB_DEVCMDSTAT_LPM_SUS = 0x80000
	// Position of LPM_REWP field.
	USB_DEVCMDSTAT_LPM_REWP_Pos = 0x14
	// Bit mask of LPM_REWP field.
	USB_DEVCMDSTAT_LPM_REWP_Msk = 0x100000
	// Bit LPM_REWP.
	USB_DEVCMDSTAT_LPM_REWP = 0x100000
	// Position of DCON_C field.
	USB_DEVCMDSTAT_DCON_C_Pos = 0x18
	// Bit mask of DCON_C field.
	USB_DEVCMDSTAT_DCON_C_Msk = 0x1000000
	// Bit DCON_C.
	USB_DEVCMDSTAT_DCON_C = 0x1000000
	// Position of DSUS_C field.
	USB_DEVCMDSTAT_DSUS_C_Pos = 0x19
	// Bit mask of DSUS_C field.
	USB_DEVCMDSTAT_DSUS_C_Msk = 0x2000000
	// Bit DSUS_C.
	USB_DEVCMDSTAT_DSUS_C = 0x2000000
	// Position of DRES_C field.
	USB_DEVCMDSTAT_DRES_C_Pos = 0x1a
	// Bit mask of DRES_C field.
	USB_DEVCMDSTAT_DRES_C_Msk = 0x4000000
	// Bit DRES_C.
	USB_DEVCMDSTAT_DRES_C = 0x4000000
	// Position of VBUSDEBOUNCED field.
	USB_DEVCMDSTAT_VBUSDEBOUNCED_Pos = 0x1c
	// Bit mask of VBUSDEBOUNCED field.
	USB_DEVCMDSTAT_VBUSDEBOUNCED_Msk = 0x10000000
	// Bit VBUSDEBOUNCED.
	USB_DEVCMDSTAT_VBUSDEBOUNCED = 0x10000000

	// INFO: USB Info register
	// Position of FRAME_NR field.
	USB_INFO_FRAME_NR_Pos = 0x0
	// Bit mask of FRAME_NR field.
	USB_INFO_FRAME_NR_Msk = 0x7ff
	// Position of ERR_CODE field.
	USB_INFO_ERR_CODE_Pos = 0xb
	// Bit mask of ERR_CODE field.
	USB_INFO_ERR_CODE_Msk = 0x7800
	// No error
	USB_INFO_ERR_CODE_NO_ERROR = 0x0
	// PID encoding error
	USB_INFO_ERR_CODE_PID_ENCODING_ERROR = 0x1
	// PID unknown
	USB_INFO_ERR_CODE_PID_UNKNOWN = 0x2
	// Packet unexpected
	USB_INFO_ERR_CODE_PACKET_UNEXPECTED = 0x3
	// Token CRC error
	USB_INFO_ERR_CODE_TOKEN_CRC_ERROR = 0x4
	// Data CRC error
	USB_INFO_ERR_CODE_DATA_CRC_ERROR = 0x5
	// Time out
	USB_INFO_ERR_CODE_TIMEOUT = 0x6
	// Babble
	USB_INFO_ERR_CODE_BABBLE = 0x7
	// Truncated EOP
	USB_INFO_ERR_CODE_TRUNCATED_EOP = 0x8
	// Sent/Received NAK
	USB_INFO_ERR_CODE_SENT_RECEIVED_NAK = 0x9
	// Sent Stall
	USB_INFO_ERR_CODE_SENT_STALL = 0xa
	// Overrun
	USB_INFO_ERR_CODE_OVERRUN = 0xb
	// Sent empty packet
	USB_INFO_ERR_CODE_SENT_EMPTY_PACKET = 0xc
	// Bitstuff error
	USB_INFO_ERR_CODE_BITSTUFF_ERROR = 0xd
	// Sync error
	USB_INFO_ERR_CODE_SYNC_ERROR = 0xe
	// Wrong data toggle
	USB_INFO_ERR_CODE_WRONG_DATA_TOGGLE = 0xf

	// EPLISTSTART: USB EP Command/Status List start address
	// Position of EP_LIST field.
	USB_EPLISTSTART_EP_LIST_Pos = 0x8
	// Bit mask of EP_LIST field.
	USB_EPLISTSTART_EP_LIST_Msk = 0xffffff00

	// DATABUFSTART: USB Data buffer start address
	// Position of DA_BUF field.
	USB_DATABUFSTART_DA_BUF_Pos = 0x16
	// Bit mask of DA_BUF field.
	USB_DATABUFSTART_DA_BUF_Msk = 0xffc00000

	// LPM: USB Link Power Management register
	// Position of HIRD_HW field.
	USB_LPM_HIRD_HW_Pos = 0x0
	// Bit mask of HIRD_HW field.
	USB_LPM_HIRD_HW_Msk = 0xf
	// Position of HIRD_SW field.
	USB_LPM_HIRD_SW_Pos = 0x4
	// Bit mask of HIRD_SW field.
	USB_LPM_HIRD_SW_Msk = 0xf0
	// Position of DATA_PENDING field.
	USB_LPM_DATA_PENDING_Pos = 0x8
	// Bit mask of DATA_PENDING field.
	USB_LPM_DATA_PENDING_Msk = 0x100
	// Bit DATA_PENDING.
	USB_LPM_DATA_PENDING = 0x100

	// EPSKIP: USB Endpoint skip
	// Position of SKIP field.
	USB_EPSKIP_SKIP_Pos = 0x0
	// Bit mask of SKIP field.
	USB_EPSKIP_SKIP_Msk = 0x3fffffff

	// EPINUSE: USB Endpoint Buffer in use
	// Position of BUF field.
	USB_EPINUSE_BUF_Pos = 0x2
	// Bit mask of BUF field.
	USB_EPINUSE_BUF_Msk = 0x3fc

	// EPBUFCFG: USB Endpoint Buffer Configuration register
	// Position of BUF_SB field.
	USB_EPBUFCFG_BUF_SB_Pos = 0x2
	// Bit mask of BUF_SB field.
	USB_EPBUFCFG_BUF_SB_Msk = 0x3fc

	// INTSTAT: USB interrupt status register
	// Position of EP0OUT field.
	USB_INTSTAT_EP0OUT_Pos = 0x0
	// Bit mask of EP0OUT field.
	USB_INTSTAT_EP0OUT_Msk = 0x1
	// Bit EP0OUT.
	USB_INTSTAT_EP0OUT = 0x1
	// Position of EP0IN field.
	USB_INTSTAT_EP0IN_Pos = 0x1
	// Bit mask of EP0IN field.
	USB_INTSTAT_EP0IN_Msk = 0x2
	// Bit EP0IN.
	USB_INTSTAT_EP0IN = 0x2
	// Position of EP1OUT field.
	USB_INTSTAT_EP1OUT_Pos = 0x2
	// Bit mask of EP1OUT field.
	USB_INTSTAT_EP1OUT_Msk = 0x4
	// Bit EP1OUT.
	USB_INTSTAT_EP1OUT = 0x4
	// Position of EP1IN field.
	USB_INTSTAT_EP1IN_Pos = 0x3
	// Bit mask of EP1IN field.
	USB_INTSTAT_EP1IN_Msk = 0x8
	// Bit EP1IN.
	USB_INTSTAT_EP1IN = 0x8
	// Position of EP2OUT field.
	USB_INTSTAT_EP2OUT_Pos = 0x4
	// Bit mask of EP2OUT field.
	USB_INTSTAT_EP2OUT_Msk = 0x10
	// Bit EP2OUT.
	USB_INTSTAT_EP2OUT = 0x10
	// Position of EP2IN field.
	USB_INTSTAT_EP2IN_Pos = 0x5
	// Bit mask of EP2IN field.
	USB_INTSTAT_EP2IN_Msk = 0x20
	// Bit EP2IN.
	USB_INTSTAT_EP2IN = 0x20
	// Position of EP3OUT field.
	USB_INTSTAT_EP3OUT_Pos = 0x6
	// Bit mask of EP3OUT field.
	USB_INTSTAT_EP3OUT_Msk = 0x40
	// Bit EP3OUT.
	USB_INTSTAT_EP3OUT = 0x40
	// Position of EP3IN field.
	USB_INTSTAT_EP3IN_Pos = 0x7
	// Bit mask of EP3IN field.
	USB_INTSTAT_EP3IN_Msk = 0x80
	// Bit EP3IN.
	USB_INTSTAT_EP3IN = 0x80
	// Position of EP4OUT field.
	USB_INTSTAT_EP4OUT_Pos = 0x8
	// Bit mask of EP4OUT field.
	USB_INTSTAT_EP4OUT_Msk = 0x100
	// Bit EP4OUT.
	USB_INTSTAT_EP4OUT = 0x100
	// Position of EP4IN field.
	USB_INTSTAT_EP4IN_Pos = 0x9
	// Bit mask of EP4IN field.
	USB_INTSTAT_EP4IN_Msk = 0x200
	// Bit EP4IN.
	USB_INTSTAT_EP4IN = 0x200
	// Position of EP5OUT field.
	USB_INTSTAT_EP5OUT_Pos = 0xa
	// Bit mask of EP5OUT field.
	USB_INTSTAT_EP5OUT_Msk = 0x400
	// Bit EP5OUT.
	USB_INTSTAT_EP5OUT = 0x400
	// Position of EP5IN field.
	USB_INTSTAT_EP5IN_Pos = 0xb
	// Bit mask of EP5IN field.
	USB_INTSTAT_EP5IN_Msk = 0x800
	// Bit EP5IN.
	USB_INTSTAT_EP5IN = 0x800
	// Position of EP6OUT field.
	USB_INTSTAT_EP6OUT_Pos = 0xc
	// Bit mask of EP6OUT field.
	USB_INTSTAT_EP6OUT_Msk = 0x1000
	// Bit EP6OUT.
	USB_INTSTAT_EP6OUT = 0x1000
	// Position of EP6IN field.
	USB_INTSTAT_EP6IN_Pos = 0xd
	// Bit mask of EP6IN field.
	USB_INTSTAT_EP6IN_Msk = 0x2000
	// Bit EP6IN.
	USB_INTSTAT_EP6IN = 0x2000
	// Position of EP7OUT field.
	USB_INTSTAT_EP7OUT_Pos = 0xe
	// Bit mask of EP7OUT field.
	USB_INTSTAT_EP7OUT_Msk = 0x4000
	// Bit EP7OUT.
	USB_INTSTAT_EP7OUT = 0x4000
	// Position of EP7IN field.
	USB_INTSTAT_EP7IN_Pos = 0xf
	// Bit mask of EP7IN field.
	USB_INTSTAT_EP7IN_Msk = 0x8000
	// Bit EP7IN.
	USB_INTSTAT_EP7IN = 0x8000
	// Position of FRAME_INT field.
	USB_INTSTAT_FRAME_INT_Pos = 0x1e
	// Bit mask of FRAME_INT field.
	USB_INTSTAT_FRAME_INT_Msk = 0x40000000
	// Bit FRAME_INT.
	USB_INTSTAT_FRAME_INT = 0x40000000
	// Position of DEV_INT field.
	USB_INTSTAT_DEV_INT_Pos = 0x1f
	// Bit mask of DEV_INT field.
	USB_INTSTAT_DEV_INT_Msk = 0x80000000
	// Bit DEV_INT.
	USB_INTSTAT_DEV_INT = 0x80000000

	// INTEN: USB interrupt enable register
	// Position of EP_INT_EN field.
	USB_INTEN_EP_INT_EN_Pos = 0x0
	// Bit mask of EP_INT_EN field.
	USB_INTEN_EP_INT_EN_Msk = 0xffff
	// Position of FRAME_INT_EN field.
	USB_INTEN_FRAME_INT_EN_Pos = 0x1e
	// Bit mask of FRAME_INT_EN field.
	USB_INTEN_FRAME_INT_EN_Msk = 0x40000000
	// Bit FRAME_INT_EN.
	USB_INTEN_FRAME_INT_EN = 0x40000000
	// Position of DEV_INT_EN field.
	USB_INTEN_DEV_INT_EN_Pos = 0x1f
	// Bit mask of DEV_INT_EN field.
	USB_INTEN_DEV_INT_EN_Msk = 0x80000000
	// Bit DEV_INT_EN.
	USB_INTEN_DEV_INT_EN = 0x80000000

	// INTSETSTAT: USB set interrupt status register
	// Position of EP_SET_INT field.
	USB_INTSETSTAT_EP_SET_INT_Pos = 0x0
	// Bit mask of EP_SET_INT field.
	USB_INTSETSTAT_EP_SET_INT_Msk = 0xffff
	// Position of FRAME_SET_INT field.
	USB_INTSETSTAT_FRAME_SET_INT_Pos = 0x1e
	// Bit mask of FRAME_SET_INT field.
	USB_INTSETSTAT_FRAME_SET_INT_Msk = 0x40000000
	// Bit FRAME_SET_INT.
	USB_INTSETSTAT_FRAME_SET_INT = 0x40000000
	// Position of DEV_SET_INT field.
	USB_INTSETSTAT_DEV_SET_INT_Pos = 0x1f
	// Bit mask of DEV_SET_INT field.
	USB_INTSETSTAT_DEV_SET_INT_Msk = 0x80000000
	// Bit DEV_SET_INT.
	USB_INTSETSTAT_DEV_SET_INT = 0x80000000

	// EPTOGGLE: USB Endpoint toggle register
	// Position of TOGGLE field.
	USB_EPTOGGLE_TOGGLE_Pos = 0x0
	// Bit mask of TOGGLE field.
	USB_EPTOGGLE_TOGGLE_Msk = 0xffff
)

// Constants for SCT0: LPC5411x SCTimer/PWM (SCT)
const (
	// CONFIG: SCT configuration register
	// Position of UNIFY field.
	SCT_CONFIG_UNIFY_Pos = 0x0
	// Bit mask of UNIFY field.
	SCT_CONFIG_UNIFY_Msk = 0x1
	// Bit UNIFY.
	SCT_CONFIG_UNIFY = 0x1
	// The SCT operates as two 16-bit counters named COUNTER_L and COUNTER_H.
	SCT_CONFIG_UNIFY_DUAL_COUNTER = 0x0
	// The SCT operates as a unified 32-bit counter.
	SCT_CONFIG_UNIFY_UNIFIED_COUNTER = 0x1
	// Position of CLKMODE field.
	SCT_CONFIG_CLKMODE_Pos = 0x1
	// Bit mask of CLKMODE field.
	SCT_CONFIG_CLKMODE_Msk = 0x6
	// System Clock Mode. The system clock clocks the entire SCT module including the counter(s) and counter prescalers.
	SCT_CONFIG_CLKMODE_SYSTEM_CLOCK_MODE = 0x0
	// Sampled System Clock Mode. The system clock clocks the SCT module, but the counter and prescalers are only enabled to count when the designated edge is detected on the input selected by the CKSEL field. The minimum pulse width on the selected clock-gate input is 1 bus clock period. This mode is the high-performance, sampled-clock mode.
	SCT_CONFIG_CLKMODE_SAMPLED_SYSTEM_CLOCK_MODE = 0x1
	// SCT Input Clock Mode. The input/edge selected by the CKSEL field clocks the SCT module, including the counters and prescalers, after first being synchronized to the system clock. The minimum pulse width on the clock input is 1 bus clock period. This mode is the low-power, sampled-clock mode.
	SCT_CONFIG_CLKMODE_SCT_INPUT_CLOCK_MODE = 0x2
	// Asynchronous Mode. The entire SCT module is clocked directly by the input/edge selected by the CKSEL field. In this mode, the SCT outputs are switched synchronously to the SCT input clock - not the system clock. The input clock rate must be at least half the system clock rate and can be the same or faster than the system clock.
	SCT_CONFIG_CLKMODE_ASYNCHRONOUS_MODE = 0x3
	// Position of CKSEL field.
	SCT_CONFIG_CKSEL_Pos = 0x3
	// Bit mask of CKSEL field.
	SCT_CONFIG_CKSEL_Msk = 0x78
	// Rising edges on input 0.
	SCT_CONFIG_CKSEL_INPUT_0_RISING_EDGES = 0x0
	// Falling edges on input 0.
	SCT_CONFIG_CKSEL_INPUT_0_FALLING_EDGE = 0x1
	// Rising edges on input 1.
	SCT_CONFIG_CKSEL_INPUT_1_RISING_EDGES = 0x2
	// Falling edges on input 1.
	SCT_CONFIG_CKSEL_INPUT_1_FALLING_EDGE = 0x3
	// Rising edges on input 2.
	SCT_CONFIG_CKSEL_INPUT_2_RISING_EDGES = 0x4
	// Falling edges on input 2.
	SCT_CONFIG_CKSEL_INPUT_2_FALLING_EDGE = 0x5
	// Rising edges on input 3.
	SCT_CONFIG_CKSEL_INPUT_3_RISING_EDGES = 0x6
	// Falling edges on input 3.
	SCT_CONFIG_CKSEL_INPUT_3_FALLING_EDGE = 0x7
	// Position of NORELAOD_L field.
	SCT_CONFIG_NORELAOD_L_Pos = 0x7
	// Bit mask of NORELAOD_L field.
	SCT_CONFIG_NORELAOD_L_Msk = 0x80
	// Bit NORELAOD_L.
	SCT_CONFIG_NORELAOD_L = 0x80
	// Position of NORELOAD_H field.
	SCT_CONFIG_NORELOAD_H_Pos = 0x8
	// Bit mask of NORELOAD_H field.
	SCT_CONFIG_NORELOAD_H_Msk = 0x100
	// Bit NORELOAD_H.
	SCT_CONFIG_NORELOAD_H = 0x100
	// Position of INSYNC field.
	SCT_CONFIG_INSYNC_Pos = 0x9
	// Bit mask of INSYNC field.
	SCT_CONFIG_INSYNC_Msk = 0x1e00
	// Position of AUTOLIMIT_L field.
	SCT_CONFIG_AUTOLIMIT_L_Pos = 0x11
	// Bit mask of AUTOLIMIT_L field.
	SCT_CONFIG_AUTOLIMIT_L_Msk = 0x20000
	// Bit AUTOLIMIT_L.
	SCT_CONFIG_AUTOLIMIT_L = 0x20000
	// Position of AUTOLIMIT_H field.
	SCT_CONFIG_AUTOLIMIT_H_Pos = 0x12
	// Bit mask of AUTOLIMIT_H field.
	SCT_CONFIG_AUTOLIMIT_H_Msk = 0x40000
	// Bit AUTOLIMIT_H.
	SCT_CONFIG_AUTOLIMIT_H = 0x40000

	// CTRL: SCT control register
	// Position of DOWN_L field.
	SCT_CTRL_DOWN_L_Pos = 0x0
	// Bit mask of DOWN_L field.
	SCT_CTRL_DOWN_L_Msk = 0x1
	// Bit DOWN_L.
	SCT_CTRL_DOWN_L = 0x1
	// Position of STOP_L field.
	SCT_CTRL_STOP_L_Pos = 0x1
	// Bit mask of STOP_L field.
	SCT_CTRL_STOP_L_Msk = 0x2
	// Bit STOP_L.
	SCT_CTRL_STOP_L = 0x2
	// Position of HALT_L field.
	SCT_CTRL_HALT_L_Pos = 0x2
	// Bit mask of HALT_L field.
	SCT_CTRL_HALT_L_Msk = 0x4
	// Bit HALT_L.
	SCT_CTRL_HALT_L = 0x4
	// Position of CLRCTR_L field.
	SCT_CTRL_CLRCTR_L_Pos = 0x3
	// Bit mask of CLRCTR_L field.
	SCT_CTRL_CLRCTR_L_Msk = 0x8
	// Bit CLRCTR_L.
	SCT_CTRL_CLRCTR_L = 0x8
	// Position of BIDIR_L field.
	SCT_CTRL_BIDIR_L_Pos = 0x4
	// Bit mask of BIDIR_L field.
	SCT_CTRL_BIDIR_L_Msk = 0x10
	// Bit BIDIR_L.
	SCT_CTRL_BIDIR_L = 0x10
	// Up. The counter counts up to a limit condition, then is cleared to zero.
	SCT_CTRL_BIDIR_L_UP = 0x0
	// Up-down. The counter counts up to a limit, then counts down to a limit condition or to 0.
	SCT_CTRL_BIDIR_L_UP_DOWN = 0x1
	// Position of PRE_L field.
	SCT_CTRL_PRE_L_Pos = 0x5
	// Bit mask of PRE_L field.
	SCT_CTRL_PRE_L_Msk = 0x1fe0
	// Position of DOWN_H field.
	SCT_CTRL_DOWN_H_Pos = 0x10
	// Bit mask of DOWN_H field.
	SCT_CTRL_DOWN_H_Msk = 0x10000
	// Bit DOWN_H.
	SCT_CTRL_DOWN_H = 0x10000
	// Position of STOP_H field.
	SCT_CTRL_STOP_H_Pos = 0x11
	// Bit mask of STOP_H field.
	SCT_CTRL_STOP_H_Msk = 0x20000
	// Bit STOP_H.
	SCT_CTRL_STOP_H = 0x20000
	// Position of HALT_H field.
	SCT_CTRL_HALT_H_Pos = 0x12
	// Bit mask of HALT_H field.
	SCT_CTRL_HALT_H_Msk = 0x40000
	// Bit HALT_H.
	SCT_CTRL_HALT_H = 0x40000
	// Position of CLRCTR_H field.
	SCT_CTRL_CLRCTR_H_Pos = 0x13
	// Bit mask of CLRCTR_H field.
	SCT_CTRL_CLRCTR_H_Msk = 0x80000
	// Bit CLRCTR_H.
	SCT_CTRL_CLRCTR_H = 0x80000
	// Position of BIDIR_H field.
	SCT_CTRL_BIDIR_H_Pos = 0x14
	// Bit mask of BIDIR_H field.
	SCT_CTRL_BIDIR_H_Msk = 0x100000
	// Bit BIDIR_H.
	SCT_CTRL_BIDIR_H = 0x100000
	// The H counter counts up to its limit condition, then is cleared to zero.
	SCT_CTRL_BIDIR_H_UP = 0x0
	// The H counter counts up to its limit, then counts down to a limit condition or to 0.
	SCT_CTRL_BIDIR_H_UP_DOWN = 0x1
	// Position of PRE_H field.
	SCT_CTRL_PRE_H_Pos = 0x15
	// Bit mask of PRE_H field.
	SCT_CTRL_PRE_H_Msk = 0x1fe00000

	// LIMIT: SCT limit event select register
	// Position of LIMMSK_L field.
	SCT_LIMIT_LIMMSK_L_Pos = 0x0
	// Bit mask of LIMMSK_L field.
	SCT_LIMIT_LIMMSK_L_Msk = 0xffff
	// Position of LIMMSK_H field.
	SCT_LIMIT_LIMMSK_H_Pos = 0x10
	// Bit mask of LIMMSK_H field.
	SCT_LIMIT_LIMMSK_H_Msk = 0xffff0000

	// HALT: SCT halt event select register
	// Position of HALTMSK_L field.
	SCT_HALT_HALTMSK_L_Pos = 0x0
	// Bit mask of HALTMSK_L field.
	SCT_HALT_HALTMSK_L_Msk = 0xffff
	// Position of HALTMSK_H field.
	SCT_HALT_HALTMSK_H_Pos = 0x10
	// Bit mask of HALTMSK_H field.
	SCT_HALT_HALTMSK_H_Msk = 0xffff0000

	// STOP: SCT stop event select register
	// Position of STOPMSK_L field.
	SCT_STOP_STOPMSK_L_Pos = 0x0
	// Bit mask of STOPMSK_L field.
	SCT_STOP_STOPMSK_L_Msk = 0xffff
	// Position of STOPMSK_H field.
	SCT_STOP_STOPMSK_H_Pos = 0x10
	// Bit mask of STOPMSK_H field.
	SCT_STOP_STOPMSK_H_Msk = 0xffff0000

	// START: SCT start event select register
	// Position of STARTMSK_L field.
	SCT_START_STARTMSK_L_Pos = 0x0
	// Bit mask of STARTMSK_L field.
	SCT_START_STARTMSK_L_Msk = 0xffff
	// Position of STARTMSK_H field.
	SCT_START_STARTMSK_H_Pos = 0x10
	// Bit mask of STARTMSK_H field.
	SCT_START_STARTMSK_H_Msk = 0xffff0000

	// COUNT: SCT counter register
	// Position of CTR_L field.
	SCT_COUNT_CTR_L_Pos = 0x0
	// Bit mask of CTR_L field.
	SCT_COUNT_CTR_L_Msk = 0xffff
	// Position of CTR_H field.
	SCT_COUNT_CTR_H_Pos = 0x10
	// Bit mask of CTR_H field.
	SCT_COUNT_CTR_H_Msk = 0xffff0000

	// STATE: SCT state register
	// Position of STATE_L field.
	SCT_STATE_STATE_L_Pos = 0x0
	// Bit mask of STATE_L field.
	SCT_STATE_STATE_L_Msk = 0x1f
	// Position of STATE_H field.
	SCT_STATE_STATE_H_Pos = 0x10
	// Bit mask of STATE_H field.
	SCT_STATE_STATE_H_Msk = 0x1f0000

	// INPUT: SCT input register
	// Position of AIN0 field.
	SCT_INPUT_AIN0_Pos = 0x0
	// Bit mask of AIN0 field.
	SCT_INPUT_AIN0_Msk = 0x1
	// Bit AIN0.
	SCT_INPUT_AIN0 = 0x1
	// Position of AIN1 field.
	SCT_INPUT_AIN1_Pos = 0x1
	// Bit mask of AIN1 field.
	SCT_INPUT_AIN1_Msk = 0x2
	// Bit AIN1.
	SCT_INPUT_AIN1 = 0x2
	// Position of AIN2 field.
	SCT_INPUT_AIN2_Pos = 0x2
	// Bit mask of AIN2 field.
	SCT_INPUT_AIN2_Msk = 0x4
	// Bit AIN2.
	SCT_INPUT_AIN2 = 0x4
	// Position of AIN3 field.
	SCT_INPUT_AIN3_Pos = 0x3
	// Bit mask of AIN3 field.
	SCT_INPUT_AIN3_Msk = 0x8
	// Bit AIN3.
	SCT_INPUT_AIN3 = 0x8
	// Position of AIN4 field.
	SCT_INPUT_AIN4_Pos = 0x4
	// Bit mask of AIN4 field.
	SCT_INPUT_AIN4_Msk = 0x10
	// Bit AIN4.
	SCT_INPUT_AIN4 = 0x10
	// Position of AIN5 field.
	SCT_INPUT_AIN5_Pos = 0x5
	// Bit mask of AIN5 field.
	SCT_INPUT_AIN5_Msk = 0x20
	// Bit AIN5.
	SCT_INPUT_AIN5 = 0x20
	// Position of AIN6 field.
	SCT_INPUT_AIN6_Pos = 0x6
	// Bit mask of AIN6 field.
	SCT_INPUT_AIN6_Msk = 0x40
	// Bit AIN6.
	SCT_INPUT_AIN6 = 0x40
	// Position of AIN7 field.
	SCT_INPUT_AIN7_Pos = 0x7
	// Bit mask of AIN7 field.
	SCT_INPUT_AIN7_Msk = 0x80
	// Bit AIN7.
	SCT_INPUT_AIN7 = 0x80
	// Position of AIN8 field.
	SCT_INPUT_AIN8_Pos = 0x8
	// Bit mask of AIN8 field.
	SCT_INPUT_AIN8_Msk = 0x100
	// Bit AIN8.
	SCT_INPUT_AIN8 = 0x100
	// Position of AIN9 field.
	SCT_INPUT_AIN9_Pos = 0x9
	// Bit mask of AIN9 field.
	SCT_INPUT_AIN9_Msk = 0x200
	// Bit AIN9.
	SCT_INPUT_AIN9 = 0x200
	// Position of AIN10 field.
	SCT_INPUT_AIN10_Pos = 0xa
	// Bit mask of AIN10 field.
	SCT_INPUT_AIN10_Msk = 0x400
	// Bit AIN10.
	SCT_INPUT_AIN10 = 0x400
	// Position of AIN11 field.
	SCT_INPUT_AIN11_Pos = 0xb
	// Bit mask of AIN11 field.
	SCT_INPUT_AIN11_Msk = 0x800
	// Bit AIN11.
	SCT_INPUT_AIN11 = 0x800
	// Position of AIN12 field.
	SCT_INPUT_AIN12_Pos = 0xc
	// Bit mask of AIN12 field.
	SCT_INPUT_AIN12_Msk = 0x1000
	// Bit AIN12.
	SCT_INPUT_AIN12 = 0x1000
	// Position of AIN13 field.
	SCT_INPUT_AIN13_Pos = 0xd
	// Bit mask of AIN13 field.
	SCT_INPUT_AIN13_Msk = 0x2000
	// Bit AIN13.
	SCT_INPUT_AIN13 = 0x2000
	// Position of AIN14 field.
	SCT_INPUT_AIN14_Pos = 0xe
	// Bit mask of AIN14 field.
	SCT_INPUT_AIN14_Msk = 0x4000
	// Bit AIN14.
	SCT_INPUT_AIN14 = 0x4000
	// Position of AIN15 field.
	SCT_INPUT_AIN15_Pos = 0xf
	// Bit mask of AIN15 field.
	SCT_INPUT_AIN15_Msk = 0x8000
	// Bit AIN15.
	SCT_INPUT_AIN15 = 0x8000
	// Position of SIN0 field.
	SCT_INPUT_SIN0_Pos = 0x10
	// Bit mask of SIN0 field.
	SCT_INPUT_SIN0_Msk = 0x10000
	// Bit SIN0.
	SCT_INPUT_SIN0 = 0x10000
	// Position of SIN1 field.
	SCT_INPUT_SIN1_Pos = 0x11
	// Bit mask of SIN1 field.
	SCT_INPUT_SIN1_Msk = 0x20000
	// Bit SIN1.
	SCT_INPUT_SIN1 = 0x20000
	// Position of SIN2 field.
	SCT_INPUT_SIN2_Pos = 0x12
	// Bit mask of SIN2 field.
	SCT_INPUT_SIN2_Msk = 0x40000
	// Bit SIN2.
	SCT_INPUT_SIN2 = 0x40000
	// Position of SIN3 field.
	SCT_INPUT_SIN3_Pos = 0x13
	// Bit mask of SIN3 field.
	SCT_INPUT_SIN3_Msk = 0x80000
	// Bit SIN3.
	SCT_INPUT_SIN3 = 0x80000
	// Position of SIN4 field.
	SCT_INPUT_SIN4_Pos = 0x14
	// Bit mask of SIN4 field.
	SCT_INPUT_SIN4_Msk = 0x100000
	// Bit SIN4.
	SCT_INPUT_SIN4 = 0x100000
	// Position of SIN5 field.
	SCT_INPUT_SIN5_Pos = 0x15
	// Bit mask of SIN5 field.
	SCT_INPUT_SIN5_Msk = 0x200000
	// Bit SIN5.
	SCT_INPUT_SIN5 = 0x200000
	// Position of SIN6 field.
	SCT_INPUT_SIN6_Pos = 0x16
	// Bit mask of SIN6 field.
	SCT_INPUT_SIN6_Msk = 0x400000
	// Bit SIN6.
	SCT_INPUT_SIN6 = 0x400000
	// Position of SIN7 field.
	SCT_INPUT_SIN7_Pos = 0x17
	// Bit mask of SIN7 field.
	SCT_INPUT_SIN7_Msk = 0x800000
	// Bit SIN7.
	SCT_INPUT_SIN7 = 0x800000
	// Position of SIN8 field.
	SCT_INPUT_SIN8_Pos = 0x18
	// Bit mask of SIN8 field.
	SCT_INPUT_SIN8_Msk = 0x1000000
	// Bit SIN8.
	SCT_INPUT_SIN8 = 0x1000000
	// Position of SIN9 field.
	SCT_INPUT_SIN9_Pos = 0x19
	// Bit mask of SIN9 field.
	SCT_INPUT_SIN9_Msk = 0x2000000
	// Bit SIN9.
	SCT_INPUT_SIN9 = 0x2000000
	// Position of SIN10 field.
	SCT_INPUT_SIN10_Pos = 0x1a
	// Bit mask of SIN10 field.
	SCT_INPUT_SIN10_Msk = 0x4000000
	// Bit SIN10.
	SCT_INPUT_SIN10 = 0x4000000
	// Position of SIN11 field.
	SCT_INPUT_SIN11_Pos = 0x1b
	// Bit mask of SIN11 field.
	SCT_INPUT_SIN11_Msk = 0x8000000
	// Bit SIN11.
	SCT_INPUT_SIN11 = 0x8000000
	// Position of SIN12 field.
	SCT_INPUT_SIN12_Pos = 0x1c
	// Bit mask of SIN12 field.
	SCT_INPUT_SIN12_Msk = 0x10000000
	// Bit SIN12.
	SCT_INPUT_SIN12 = 0x10000000
	// Position of SIN13 field.
	SCT_INPUT_SIN13_Pos = 0x1d
	// Bit mask of SIN13 field.
	SCT_INPUT_SIN13_Msk = 0x20000000
	// Bit SIN13.
	SCT_INPUT_SIN13 = 0x20000000
	// Position of SIN14 field.
	SCT_INPUT_SIN14_Pos = 0x1e
	// Bit mask of SIN14 field.
	SCT_INPUT_SIN14_Msk = 0x40000000
	// Bit SIN14.
	SCT_INPUT_SIN14 = 0x40000000
	// Position of SIN15 field.
	SCT_INPUT_SIN15_Pos = 0x1f
	// Bit mask of SIN15 field.
	SCT_INPUT_SIN15_Msk = 0x80000000
	// Bit SIN15.
	SCT_INPUT_SIN15 = 0x80000000

	// REGMODE: SCT match/capture mode register
	// Position of REGMOD_L field.
	SCT_REGMODE_REGMOD_L_Pos = 0x0
	// Bit mask of REGMOD_L field.
	SCT_REGMODE_REGMOD_L_Msk = 0xffff
	// Position of REGMOD_H field.
	SCT_REGMODE_REGMOD_H_Pos = 0x10
	// Bit mask of REGMOD_H field.
	SCT_REGMODE_REGMOD_H_Msk = 0xffff0000

	// OUTPUT: SCT output register
	// Position of OUT field.
	SCT_OUTPUT_OUT_Pos = 0x0
	// Bit mask of OUT field.
	SCT_OUTPUT_OUT_Msk = 0xffff

	// OUTPUTDIRCTRL: SCT output counter direction control register
	// Position of SETCLR0 field.
	SCT_OUTPUTDIRCTRL_SETCLR0_Pos = 0x0
	// Bit mask of SETCLR0 field.
	SCT_OUTPUTDIRCTRL_SETCLR0_Msk = 0x3
	// Set and clear do not depend on the direction of any counter.
	SCT_OUTPUTDIRCTRL_SETCLR0_INDEPENDENT = 0x0
	// Set and clear are reversed when counter L or the unified counter is counting down.
	SCT_OUTPUTDIRCTRL_SETCLR0_L_REVERSED = 0x1
	// Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1.
	SCT_OUTPUTDIRCTRL_SETCLR0_H_REVERSED = 0x2
	// Position of SETCLR1 field.
	SCT_OUTPUTDIRCTRL_SETCLR1_Pos = 0x2
	// Bit mask of SETCLR1 field.
	SCT_OUTPUTDIRCTRL_SETCLR1_Msk = 0xc
	// Set and clear do not depend on the direction of any counter.
	SCT_OUTPUTDIRCTRL_SETCLR1_INDEPENDENT = 0x0
	// Set and clear are reversed when counter L or the unified counter is counting down.
	SCT_OUTPUTDIRCTRL_SETCLR1_L_REVERSED = 0x1
	// Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1.
	SCT_OUTPUTDIRCTRL_SETCLR1_H_REVERSED = 0x2
	// Position of SETCLR2 field.
	SCT_OUTPUTDIRCTRL_SETCLR2_Pos = 0x4
	// Bit mask of SETCLR2 field.
	SCT_OUTPUTDIRCTRL_SETCLR2_Msk = 0x30
	// Set and clear do not depend on the direction of any counter.
	SCT_OUTPUTDIRCTRL_SETCLR2_INDEPENDENT = 0x0
	// Set and clear are reversed when counter L or the unified counter is counting down.
	SCT_OUTPUTDIRCTRL_SETCLR2_L_REVERSED = 0x1
	// Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1.
	SCT_OUTPUTDIRCTRL_SETCLR2_H_REVERSED = 0x2
	// Position of SETCLR3 field.
	SCT_OUTPUTDIRCTRL_SETCLR3_Pos = 0x6
	// Bit mask of SETCLR3 field.
	SCT_OUTPUTDIRCTRL_SETCLR3_Msk = 0xc0
	// Set and clear do not depend on the direction of any counter.
	SCT_OUTPUTDIRCTRL_SETCLR3_INDEPENDENT = 0x0
	// Set and clear are reversed when counter L or the unified counter is counting down.
	SCT_OUTPUTDIRCTRL_SETCLR3_L_REVERSED = 0x1
	// Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1.
	SCT_OUTPUTDIRCTRL_SETCLR3_H_REVERSED = 0x2
	// Position of SETCLR4 field.
	SCT_OUTPUTDIRCTRL_SETCLR4_Pos = 0x8
	// Bit mask of SETCLR4 field.
	SCT_OUTPUTDIRCTRL_SETCLR4_Msk = 0x300
	// Set and clear do not depend on the direction of any counter.
	SCT_OUTPUTDIRCTRL_SETCLR4_INDEPENDENT = 0x0
	// Set and clear are reversed when counter L or the unified counter is counting down.
	SCT_OUTPUTDIRCTRL_SETCLR4_L_REVERSED = 0x1
	// Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1.
	SCT_OUTPUTDIRCTRL_SETCLR4_H_REVERSED = 0x2
	// Position of SETCLR5 field.
	SCT_OUTPUTDIRCTRL_SETCLR5_Pos = 0xa
	// Bit mask of SETCLR5 field.
	SCT_OUTPUTDIRCTRL_SETCLR5_Msk = 0xc00
	// Set and clear do not depend on the direction of any counter.
	SCT_OUTPUTDIRCTRL_SETCLR5_INDEPENDENT = 0x0
	// Set and clear are reversed when counter L or the unified counter is counting down.
	SCT_OUTPUTDIRCTRL_SETCLR5_L_REVERSED = 0x1
	// Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1.
	SCT_OUTPUTDIRCTRL_SETCLR5_H_REVERSED = 0x2
	// Position of SETCLR6 field.
	SCT_OUTPUTDIRCTRL_SETCLR6_Pos = 0xc
	// Bit mask of SETCLR6 field.
	SCT_OUTPUTDIRCTRL_SETCLR6_Msk = 0x3000
	// Set and clear do not depend on the direction of any counter.
	SCT_OUTPUTDIRCTRL_SETCLR6_INDEPENDENT = 0x0
	// Set and clear are reversed when counter L or the unified counter is counting down.
	SCT_OUTPUTDIRCTRL_SETCLR6_L_REVERSED = 0x1
	// Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1.
	SCT_OUTPUTDIRCTRL_SETCLR6_H_REVERSED = 0x2
	// Position of SETCLR7 field.
	SCT_OUTPUTDIRCTRL_SETCLR7_Pos = 0xe
	// Bit mask of SETCLR7 field.
	SCT_OUTPUTDIRCTRL_SETCLR7_Msk = 0xc000
	// Set and clear do not depend on the direction of any counter.
	SCT_OUTPUTDIRCTRL_SETCLR7_INDEPENDENT = 0x0
	// Set and clear are reversed when counter L or the unified counter is counting down.
	SCT_OUTPUTDIRCTRL_SETCLR7_L_REVERSED = 0x1
	// Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1.
	SCT_OUTPUTDIRCTRL_SETCLR7_H_REVERSED = 0x2
	// Position of SETCLR8 field.
	SCT_OUTPUTDIRCTRL_SETCLR8_Pos = 0x10
	// Bit mask of SETCLR8 field.
	SCT_OUTPUTDIRCTRL_SETCLR8_Msk = 0x30000
	// Set and clear do not depend on the direction of any counter.
	SCT_OUTPUTDIRCTRL_SETCLR8_INDEPENDENT = 0x0
	// Set and clear are reversed when counter L or the unified counter is counting down.
	SCT_OUTPUTDIRCTRL_SETCLR8_L_REVERSED = 0x1
	// Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1.
	SCT_OUTPUTDIRCTRL_SETCLR8_H_REVERSED = 0x2
	// Position of SETCLR9 field.
	SCT_OUTPUTDIRCTRL_SETCLR9_Pos = 0x12
	// Bit mask of SETCLR9 field.
	SCT_OUTPUTDIRCTRL_SETCLR9_Msk = 0xc0000
	// Set and clear do not depend on the direction of any counter.
	SCT_OUTPUTDIRCTRL_SETCLR9_INDEPENDENT = 0x0
	// Set and clear are reversed when counter L or the unified counter is counting down.
	SCT_OUTPUTDIRCTRL_SETCLR9_L_REVERSED = 0x1
	// Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1.
	SCT_OUTPUTDIRCTRL_SETCLR9_H_REVERSED = 0x2
	// Position of SETCLR10 field.
	SCT_OUTPUTDIRCTRL_SETCLR10_Pos = 0x14
	// Bit mask of SETCLR10 field.
	SCT_OUTPUTDIRCTRL_SETCLR10_Msk = 0x300000
	// Set and clear do not depend on the direction of any counter.
	SCT_OUTPUTDIRCTRL_SETCLR10_INDEPENDENT = 0x0
	// Set and clear are reversed when counter L or the unified counter is counting down.
	SCT_OUTPUTDIRCTRL_SETCLR10_L_REVERSED = 0x1
	// Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1.
	SCT_OUTPUTDIRCTRL_SETCLR10_H_REVERSED = 0x2
	// Position of SETCLR11 field.
	SCT_OUTPUTDIRCTRL_SETCLR11_Pos = 0x16
	// Bit mask of SETCLR11 field.
	SCT_OUTPUTDIRCTRL_SETCLR11_Msk = 0xc00000
	// Set and clear do not depend on the direction of any counter.
	SCT_OUTPUTDIRCTRL_SETCLR11_INDEPENDENT = 0x0
	// Set and clear are reversed when counter L or the unified counter is counting down.
	SCT_OUTPUTDIRCTRL_SETCLR11_L_REVERSED = 0x1
	// Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1.
	SCT_OUTPUTDIRCTRL_SETCLR11_H_REVERSED = 0x2
	// Position of SETCLR12 field.
	SCT_OUTPUTDIRCTRL_SETCLR12_Pos = 0x18
	// Bit mask of SETCLR12 field.
	SCT_OUTPUTDIRCTRL_SETCLR12_Msk = 0x3000000
	// Set and clear do not depend on the direction of any counter.
	SCT_OUTPUTDIRCTRL_SETCLR12_INDEPENDENT = 0x0
	// Set and clear are reversed when counter L or the unified counter is counting down.
	SCT_OUTPUTDIRCTRL_SETCLR12_L_REVERSED = 0x1
	// Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1.
	SCT_OUTPUTDIRCTRL_SETCLR12_H_REVERSED = 0x2
	// Position of SETCLR13 field.
	SCT_OUTPUTDIRCTRL_SETCLR13_Pos = 0x1a
	// Bit mask of SETCLR13 field.
	SCT_OUTPUTDIRCTRL_SETCLR13_Msk = 0xc000000
	// Set and clear do not depend on the direction of any counter.
	SCT_OUTPUTDIRCTRL_SETCLR13_INDEPENDENT = 0x0
	// Set and clear are reversed when counter L or the unified counter is counting down.
	SCT_OUTPUTDIRCTRL_SETCLR13_L_REVERSED = 0x1
	// Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1.
	SCT_OUTPUTDIRCTRL_SETCLR13_H_REVERSED = 0x2
	// Position of SETCLR14 field.
	SCT_OUTPUTDIRCTRL_SETCLR14_Pos = 0x1c
	// Bit mask of SETCLR14 field.
	SCT_OUTPUTDIRCTRL_SETCLR14_Msk = 0x30000000
	// Set and clear do not depend on the direction of any counter.
	SCT_OUTPUTDIRCTRL_SETCLR14_INDEPENDENT = 0x0
	// Set and clear are reversed when counter L or the unified counter is counting down.
	SCT_OUTPUTDIRCTRL_SETCLR14_L_REVERSED = 0x1
	// Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1.
	SCT_OUTPUTDIRCTRL_SETCLR14_H_REVERSED = 0x2
	// Position of SETCLR15 field.
	SCT_OUTPUTDIRCTRL_SETCLR15_Pos = 0x1e
	// Bit mask of SETCLR15 field.
	SCT_OUTPUTDIRCTRL_SETCLR15_Msk = 0xc0000000
	// Set and clear do not depend on the direction of any counter.
	SCT_OUTPUTDIRCTRL_SETCLR15_INDEPENDENT = 0x0
	// Set and clear are reversed when counter L or the unified counter is counting down.
	SCT_OUTPUTDIRCTRL_SETCLR15_L_REVERSED = 0x1
	// Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1.
	SCT_OUTPUTDIRCTRL_SETCLR15_H_REVERSED = 0x2

	// RES: SCT conflict resolution register
	// Position of O0RES field.
	SCT_RES_O0RES_Pos = 0x0
	// Bit mask of O0RES field.
	SCT_RES_O0RES_Msk = 0x3
	// No change.
	SCT_RES_O0RES_NO_CHANGE = 0x0
	// Set output (or clear based on the SETCLR0 field in the OUTPUTDIRCTRL register).
	SCT_RES_O0RES_SET = 0x1
	// Clear output (or set based on the SETCLR0 field).
	SCT_RES_O0RES_CLEAR = 0x2
	// Toggle output.
	SCT_RES_O0RES_TOGGLE_OUTPUT = 0x3
	// Position of O1RES field.
	SCT_RES_O1RES_Pos = 0x2
	// Bit mask of O1RES field.
	SCT_RES_O1RES_Msk = 0xc
	// No change.
	SCT_RES_O1RES_NO_CHANGE = 0x0
	// Set output (or clear based on the SETCLR1 field in the OUTPUTDIRCTRL register).
	SCT_RES_O1RES_SET = 0x1
	// Clear output (or set based on the SETCLR1 field).
	SCT_RES_O1RES_CLEAR = 0x2
	// Toggle output.
	SCT_RES_O1RES_TOGGLE_OUTPUT = 0x3
	// Position of O2RES field.
	SCT_RES_O2RES_Pos = 0x4
	// Bit mask of O2RES field.
	SCT_RES_O2RES_Msk = 0x30
	// No change.
	SCT_RES_O2RES_NO_CHANGE = 0x0
	// Set output (or clear based on the SETCLR2 field in the OUTPUTDIRCTRL register).
	SCT_RES_O2RES_SET = 0x1
	// Clear output n (or set based on the SETCLR2 field).
	SCT_RES_O2RES_CLEAR = 0x2
	// Toggle output.
	SCT_RES_O2RES_TOGGLE_OUTPUT = 0x3
	// Position of O3RES field.
	SCT_RES_O3RES_Pos = 0x6
	// Bit mask of O3RES field.
	SCT_RES_O3RES_Msk = 0xc0
	// No change.
	SCT_RES_O3RES_NO_CHANGE = 0x0
	// Set output (or clear based on the SETCLR3 field in the OUTPUTDIRCTRL register).
	SCT_RES_O3RES_SET = 0x1
	// Clear output (or set based on the SETCLR3 field).
	SCT_RES_O3RES_CLEAR = 0x2
	// Toggle output.
	SCT_RES_O3RES_TOGGLE_OUTPUT = 0x3
	// Position of O4RES field.
	SCT_RES_O4RES_Pos = 0x8
	// Bit mask of O4RES field.
	SCT_RES_O4RES_Msk = 0x300
	// No change.
	SCT_RES_O4RES_NO_CHANGE = 0x0
	// Set output (or clear based on the SETCLR4 field in the OUTPUTDIRCTRL register).
	SCT_RES_O4RES_SET = 0x1
	// Clear output (or set based on the SETCLR4 field).
	SCT_RES_O4RES_CLEAR = 0x2
	// Toggle output.
	SCT_RES_O4RES_TOGGLE_OUTPUT = 0x3
	// Position of O5RES field.
	SCT_RES_O5RES_Pos = 0xa
	// Bit mask of O5RES field.
	SCT_RES_O5RES_Msk = 0xc00
	// No change.
	SCT_RES_O5RES_NO_CHANGE = 0x0
	// Set output (or clear based on the SETCLR5 field in the OUTPUTDIRCTRL register).
	SCT_RES_O5RES_SET = 0x1
	// Clear output (or set based on the SETCLR5 field).
	SCT_RES_O5RES_CLEAR = 0x2
	// Toggle output.
	SCT_RES_O5RES_TOGGLE_OUTPUT = 0x3
	// Position of O6RES field.
	SCT_RES_O6RES_Pos = 0xc
	// Bit mask of O6RES field.
	SCT_RES_O6RES_Msk = 0x3000
	// No change.
	SCT_RES_O6RES_NO_CHANGE = 0x0
	// Set output (or clear based on the SETCLR6 field in the OUTPUTDIRCTRL register).
	SCT_RES_O6RES_SET = 0x1
	// Clear output (or set based on the SETCLR6 field).
	SCT_RES_O6RES_CLEAR = 0x2
	// Toggle output.
	SCT_RES_O6RES_TOGGLE_OUTPUT = 0x3
	// Position of O7RES field.
	SCT_RES_O7RES_Pos = 0xe
	// Bit mask of O7RES field.
	SCT_RES_O7RES_Msk = 0xc000
	// No change.
	SCT_RES_O7RES_NO_CHANGE = 0x0
	// Set output (or clear based on the SETCLR7 field in the OUTPUTDIRCTRL register).
	SCT_RES_O7RES_SET = 0x1
	// Clear output n (or set based on the SETCLR7 field).
	SCT_RES_O7RES_CLEAR = 0x2
	// Toggle output.
	SCT_RES_O7RES_TOGGLE_OUTPUT = 0x3
	// Position of O8RES field.
	SCT_RES_O8RES_Pos = 0x10
	// Bit mask of O8RES field.
	SCT_RES_O8RES_Msk = 0x30000
	// No change.
	SCT_RES_O8RES_NO_CHANGE = 0x0
	// Set output (or clear based on the SETCLR8 field in the OUTPUTDIRCTRL register).
	SCT_RES_O8RES_SET = 0x1
	// Clear output (or set based on the SETCLR8 field).
	SCT_RES_O8RES_CLEAR = 0x2
	// Toggle output.
	SCT_RES_O8RES_TOGGLE_OUTPUT = 0x3
	// Position of O9RES field.
	SCT_RES_O9RES_Pos = 0x12
	// Bit mask of O9RES field.
	SCT_RES_O9RES_Msk = 0xc0000
	// No change.
	SCT_RES_O9RES_NO_CHANGE = 0x0
	// Set output (or clear based on the SETCLR9 field in the OUTPUTDIRCTRL register).
	SCT_RES_O9RES_SET = 0x1
	// Clear output (or set based on the SETCLR9 field).
	SCT_RES_O9RES_CLEAR = 0x2
	// Toggle output.
	SCT_RES_O9RES_TOGGLE_OUTPUT = 0x3
	// Position of O10RES field.
	SCT_RES_O10RES_Pos = 0x14
	// Bit mask of O10RES field.
	SCT_RES_O10RES_Msk = 0x300000
	// No change.
	SCT_RES_O10RES_NO_CHANGE = 0x0
	// Set output (or clear based on the SETCLR10 field in the OUTPUTDIRCTRL register).
	SCT_RES_O10RES_SET = 0x1
	// Clear output (or set based on the SETCLR10 field).
	SCT_RES_O10RES_CLEAR = 0x2
	// Toggle output.
	SCT_RES_O10RES_TOGGLE_OUTPUT = 0x3
	// Position of O11RES field.
	SCT_RES_O11RES_Pos = 0x16
	// Bit mask of O11RES field.
	SCT_RES_O11RES_Msk = 0xc00000
	// No change.
	SCT_RES_O11RES_NO_CHANGE = 0x0
	// Set output (or clear based on the SETCLR11 field in the OUTPUTDIRCTRL register).
	SCT_RES_O11RES_SET = 0x1
	// Clear output (or set based on the SETCLR11 field).
	SCT_RES_O11RES_CLEAR = 0x2
	// Toggle output.
	SCT_RES_O11RES_TOGGLE_OUTPUT = 0x3
	// Position of O12RES field.
	SCT_RES_O12RES_Pos = 0x18
	// Bit mask of O12RES field.
	SCT_RES_O12RES_Msk = 0x3000000
	// No change.
	SCT_RES_O12RES_NO_CHANGE = 0x0
	// Set output (or clear based on the SETCLR12 field in the OUTPUTDIRCTRL register).
	SCT_RES_O12RES_SET = 0x1
	// Clear output (or set based on the SETCLR12 field).
	SCT_RES_O12RES_CLEAR = 0x2
	// Toggle output.
	SCT_RES_O12RES_TOGGLE_OUTPUT = 0x3
	// Position of O13RES field.
	SCT_RES_O13RES_Pos = 0x1a
	// Bit mask of O13RES field.
	SCT_RES_O13RES_Msk = 0xc000000
	// No change.
	SCT_RES_O13RES_NO_CHANGE = 0x0
	// Set output (or clear based on the SETCLR13 field in the OUTPUTDIRCTRL register).
	SCT_RES_O13RES_SET = 0x1
	// Clear output (or set based on the SETCLR13 field).
	SCT_RES_O13RES_CLEAR = 0x2
	// Toggle output.
	SCT_RES_O13RES_TOGGLE_OUTPUT = 0x3
	// Position of O14RES field.
	SCT_RES_O14RES_Pos = 0x1c
	// Bit mask of O14RES field.
	SCT_RES_O14RES_Msk = 0x30000000
	// No change.
	SCT_RES_O14RES_NO_CHANGE = 0x0
	// Set output (or clear based on the SETCLR14 field in the OUTPUTDIRCTRL register).
	SCT_RES_O14RES_SET = 0x1
	// Clear output (or set based on the SETCLR14 field).
	SCT_RES_O14RES_CLEAR = 0x2
	// Toggle output.
	SCT_RES_O14RES_TOGGLE_OUTPUT = 0x3
	// Position of O15RES field.
	SCT_RES_O15RES_Pos = 0x1e
	// Bit mask of O15RES field.
	SCT_RES_O15RES_Msk = 0xc0000000
	// No change.
	SCT_RES_O15RES_NO_CHANGE = 0x0
	// Set output (or clear based on the SETCLR15 field in the OUTPUTDIRCTRL register).
	SCT_RES_O15RES_SET = 0x1
	// Clear output (or set based on the SETCLR15 field).
	SCT_RES_O15RES_CLEAR = 0x2
	// Toggle output.
	SCT_RES_O15RES_TOGGLE_OUTPUT = 0x3

	// DMA0REQUEST: SCT DMA request 0 register
	// Position of DEV_0 field.
	SCT_DMA0REQUEST_DEV_0_Pos = 0x0
	// Bit mask of DEV_0 field.
	SCT_DMA0REQUEST_DEV_0_Msk = 0xffff
	// Position of DRL0 field.
	SCT_DMA0REQUEST_DRL0_Pos = 0x1e
	// Bit mask of DRL0 field.
	SCT_DMA0REQUEST_DRL0_Msk = 0x40000000
	// Bit DRL0.
	SCT_DMA0REQUEST_DRL0 = 0x40000000
	// Position of DRQ0 field.
	SCT_DMA0REQUEST_DRQ0_Pos = 0x1f
	// Bit mask of DRQ0 field.
	SCT_DMA0REQUEST_DRQ0_Msk = 0x80000000
	// Bit DRQ0.
	SCT_DMA0REQUEST_DRQ0 = 0x80000000

	// DMA1REQUEST: SCT DMA request 1 register
	// Position of DEV_1 field.
	SCT_DMA1REQUEST_DEV_1_Pos = 0x0
	// Bit mask of DEV_1 field.
	SCT_DMA1REQUEST_DEV_1_Msk = 0xffff
	// Position of DRL1 field.
	SCT_DMA1REQUEST_DRL1_Pos = 0x1e
	// Bit mask of DRL1 field.
	SCT_DMA1REQUEST_DRL1_Msk = 0x40000000
	// Bit DRL1.
	SCT_DMA1REQUEST_DRL1 = 0x40000000
	// Position of DRQ1 field.
	SCT_DMA1REQUEST_DRQ1_Pos = 0x1f
	// Bit mask of DRQ1 field.
	SCT_DMA1REQUEST_DRQ1_Msk = 0x80000000
	// Bit DRQ1.
	SCT_DMA1REQUEST_DRQ1 = 0x80000000

	// EVEN: SCT event interrupt enable register
	// Position of IEN field.
	SCT_EVEN_IEN_Pos = 0x0
	// Bit mask of IEN field.
	SCT_EVEN_IEN_Msk = 0xffff

	// EVFLAG: SCT event flag register
	// Position of FLAG field.
	SCT_EVFLAG_FLAG_Pos = 0x0
	// Bit mask of FLAG field.
	SCT_EVFLAG_FLAG_Msk = 0xffff

	// CONEN: SCT conflict interrupt enable register
	// Position of NCEN field.
	SCT_CONEN_NCEN_Pos = 0x0
	// Bit mask of NCEN field.
	SCT_CONEN_NCEN_Msk = 0xffff

	// CONFLAG: SCT conflict flag register
	// Position of NCFLAG field.
	SCT_CONFLAG_NCFLAG_Pos = 0x0
	// Bit mask of NCFLAG field.
	SCT_CONFLAG_NCFLAG_Msk = 0xffff
	// Position of BUSERRL field.
	SCT_CONFLAG_BUSERRL_Pos = 0x1e
	// Bit mask of BUSERRL field.
	SCT_CONFLAG_BUSERRL_Msk = 0x40000000
	// Bit BUSERRL.
	SCT_CONFLAG_BUSERRL = 0x40000000
	// Position of BUSERRH field.
	SCT_CONFLAG_BUSERRH_Pos = 0x1f
	// Bit mask of BUSERRH field.
	SCT_CONFLAG_BUSERRH_Msk = 0x80000000
	// Bit BUSERRH.
	SCT_CONFLAG_BUSERRH = 0x80000000

	// SCTCAP: SCT capture register of capture channel
	// Position of CAPn_L field.
	SCT_SCTCAP_CAPn_L_Pos = 0x0
	// Bit mask of CAPn_L field.
	SCT_SCTCAP_CAPn_L_Msk = 0xffff
	// Position of CAPn_H field.
	SCT_SCTCAP_CAPn_H_Pos = 0x10
	// Bit mask of CAPn_H field.
	SCT_SCTCAP_CAPn_H_Msk = 0xffff0000

	// SCTMATCH: SCT match value register of match channels
	// Position of MATCHn_L field.
	SCT_SCTMATCH_MATCHn_L_Pos = 0x0
	// Bit mask of MATCHn_L field.
	SCT_SCTMATCH_MATCHn_L_Msk = 0xffff
	// Position of MATCHn_H field.
	SCT_SCTMATCH_MATCHn_H_Pos = 0x10
	// Bit mask of MATCHn_H field.
	SCT_SCTMATCH_MATCHn_H_Msk = 0xffff0000

	// SCTCAPCTRL: SCT capture control register
	// Position of CAPCONn_L field.
	SCT_SCTCAPCTRL_CAPCONn_L_Pos = 0x0
	// Bit mask of CAPCONn_L field.
	SCT_SCTCAPCTRL_CAPCONn_L_Msk = 0xffff
	// Position of CAPCONn_H field.
	SCT_SCTCAPCTRL_CAPCONn_H_Pos = 0x10
	// Bit mask of CAPCONn_H field.
	SCT_SCTCAPCTRL_CAPCONn_H_Msk = 0xffff0000

	// SCTMATCHREL: SCT match reload value register
	// Position of RELOADn_L field.
	SCT_SCTMATCHREL_RELOADn_L_Pos = 0x0
	// Bit mask of RELOADn_L field.
	SCT_SCTMATCHREL_RELOADn_L_Msk = 0xffff
	// Position of RELOADn_H field.
	SCT_SCTMATCHREL_RELOADn_H_Pos = 0x10
	// Bit mask of RELOADn_H field.
	SCT_SCTMATCHREL_RELOADn_H_Msk = 0xffff0000

	// EVENT.STATE: SCT event state register 0
	// Position of STATEMSKn field.
	SCT_EVENT_STATE_STATEMSKn_Pos = 0x0
	// Bit mask of STATEMSKn field.
	SCT_EVENT_STATE_STATEMSKn_Msk = 0xffff

	// EVENT.CTRL: SCT event control register 0
	// Position of MATCHSEL field.
	SCT_EVENT_CTRL_MATCHSEL_Pos = 0x0
	// Bit mask of MATCHSEL field.
	SCT_EVENT_CTRL_MATCHSEL_Msk = 0xf
	// Position of HEVENT field.
	SCT_EVENT_CTRL_HEVENT_Pos = 0x4
	// Bit mask of HEVENT field.
	SCT_EVENT_CTRL_HEVENT_Msk = 0x10
	// Bit HEVENT.
	SCT_EVENT_CTRL_HEVENT = 0x10
	// Selects the L state and the L match register selected by MATCHSEL.
	SCT_EVENT_CTRL_HEVENT_L_COUNTER = 0x0
	// Selects the H state and the H match register selected by MATCHSEL.
	SCT_EVENT_CTRL_HEVENT_H_COUNTER = 0x1
	// Position of OUTSEL field.
	SCT_EVENT_CTRL_OUTSEL_Pos = 0x5
	// Bit mask of OUTSEL field.
	SCT_EVENT_CTRL_OUTSEL_Msk = 0x20
	// Bit OUTSEL.
	SCT_EVENT_CTRL_OUTSEL = 0x20
	// Selects the inputs selected by IOSEL.
	SCT_EVENT_CTRL_OUTSEL_INPUT = 0x0
	// Selects the outputs selected by IOSEL.
	SCT_EVENT_CTRL_OUTSEL_OUTPUT = 0x1
	// Position of IOSEL field.
	SCT_EVENT_CTRL_IOSEL_Pos = 0x6
	// Bit mask of IOSEL field.
	SCT_EVENT_CTRL_IOSEL_Msk = 0x3c0
	// Position of IOCOND field.
	SCT_EVENT_CTRL_IOCOND_Pos = 0xa
	// Bit mask of IOCOND field.
	SCT_EVENT_CTRL_IOCOND_Msk = 0xc00
	// LOW
	SCT_EVENT_CTRL_IOCOND_LOW = 0x0
	// Rise
	SCT_EVENT_CTRL_IOCOND_RISE = 0x1
	// Fall
	SCT_EVENT_CTRL_IOCOND_FALL = 0x2
	// HIGH
	SCT_EVENT_CTRL_IOCOND_HIGH = 0x3
	// Position of COMBMODE field.
	SCT_EVENT_CTRL_COMBMODE_Pos = 0xc
	// Bit mask of COMBMODE field.
	SCT_EVENT_CTRL_COMBMODE_Msk = 0x3000
	// OR. The event occurs when either the specified match or I/O condition occurs.
	SCT_EVENT_CTRL_COMBMODE_OR = 0x0
	// MATCH. Uses the specified match only.
	SCT_EVENT_CTRL_COMBMODE_MATCH = 0x1
	// IO. Uses the specified I/O condition only.
	SCT_EVENT_CTRL_COMBMODE_IO = 0x2
	// AND. The event occurs when the specified match and I/O condition occur simultaneously.
	SCT_EVENT_CTRL_COMBMODE_AND = 0x3
	// Position of STATELD field.
	SCT_EVENT_CTRL_STATELD_Pos = 0xe
	// Bit mask of STATELD field.
	SCT_EVENT_CTRL_STATELD_Msk = 0x4000
	// Bit STATELD.
	SCT_EVENT_CTRL_STATELD = 0x4000
	// STATEV value is added into STATE (the carry-out is ignored).
	SCT_EVENT_CTRL_STATELD_ADD = 0x0
	// STATEV value is loaded into STATE.
	SCT_EVENT_CTRL_STATELD_LOAD = 0x1
	// Position of STATEV field.
	SCT_EVENT_CTRL_STATEV_Pos = 0xf
	// Bit mask of STATEV field.
	SCT_EVENT_CTRL_STATEV_Msk = 0xf8000
	// Position of MATCHMEM field.
	SCT_EVENT_CTRL_MATCHMEM_Pos = 0x14
	// Bit mask of MATCHMEM field.
	SCT_EVENT_CTRL_MATCHMEM_Msk = 0x100000
	// Bit MATCHMEM.
	SCT_EVENT_CTRL_MATCHMEM = 0x100000
	// Position of DIRECTION field.
	SCT_EVENT_CTRL_DIRECTION_Pos = 0x15
	// Bit mask of DIRECTION field.
	SCT_EVENT_CTRL_DIRECTION_Msk = 0x600000
	// Direction independent. This event is triggered regardless of the count direction.
	SCT_EVENT_CTRL_DIRECTION_DIRECTION_INDEPENDENT = 0x0
	// Counting up. This event is triggered only during up-counting when BIDIR = 1.
	SCT_EVENT_CTRL_DIRECTION_COUNTING_UP = 0x1
	// Counting down. This event is triggered only during down-counting when BIDIR = 1.
	SCT_EVENT_CTRL_DIRECTION_COUNTING_DOWN = 0x2

	// OUT.SET: SCT output 0 set register
	// Position of SET field.
	SCT_OUT_SET_SET_Pos = 0x0
	// Bit mask of SET field.
	SCT_OUT_SET_SET_Msk = 0xffff

	// OUT.CLR: SCT output 0 clear register
	// Position of CLR field.
	SCT_OUT_CLR_CLR_Pos = 0x0
	// Bit mask of CLR field.
	SCT_OUT_CLR_CLR_Msk = 0xffff
)

// Constants for I2C0: i2c
const (
	// CFG: Configuration for shared functions.
	// Position of MSTEN field.
	I2C_CFG_MSTEN_Pos = 0x0
	// Bit mask of MSTEN field.
	I2C_CFG_MSTEN_Msk = 0x1
	// Bit MSTEN.
	I2C_CFG_MSTEN = 0x1
	// Disabled. The I2C Master function is disabled.
	I2C_CFG_MSTEN_DISABLED = 0x0
	// Enabled. The I2C Master function is enabled.
	I2C_CFG_MSTEN_ENABLED = 0x1
	// Position of SLVEN field.
	I2C_CFG_SLVEN_Pos = 0x1
	// Bit mask of SLVEN field.
	I2C_CFG_SLVEN_Msk = 0x2
	// Bit SLVEN.
	I2C_CFG_SLVEN = 0x2
	// Disabled. The I2C slave function is disabled.
	I2C_CFG_SLVEN_DISABLED = 0x0
	// Enabled. The I2C slave function is enabled.
	I2C_CFG_SLVEN_ENABLED = 0x1
	// Position of MONEN field.
	I2C_CFG_MONEN_Pos = 0x2
	// Bit mask of MONEN field.
	I2C_CFG_MONEN_Msk = 0x4
	// Bit MONEN.
	I2C_CFG_MONEN = 0x4
	// Disabled. The I2C Monitor function is disabled.
	I2C_CFG_MONEN_DISABLED = 0x0
	// Enabled. The I2C Monitor function is enabled.
	I2C_CFG_MONEN_ENABLED = 0x1
	// Position of TIMEOUTEN field.
	I2C_CFG_TIMEOUTEN_Pos = 0x3
	// Bit mask of TIMEOUTEN field.
	I2C_CFG_TIMEOUTEN_Msk = 0x8
	// Bit TIMEOUTEN.
	I2C_CFG_TIMEOUTEN = 0x8
	// Disabled. Time-out function is disabled.
	I2C_CFG_TIMEOUTEN_DISABLED = 0x0
	// Enabled. Time-out function is enabled. Both types of time-out flags will be generated and will cause interrupts if they are enabled. Typically, only one time-out will be used in a system.
	I2C_CFG_TIMEOUTEN_ENABLED = 0x1
	// Position of MONCLKSTR field.
	I2C_CFG_MONCLKSTR_Pos = 0x4
	// Bit mask of MONCLKSTR field.
	I2C_CFG_MONCLKSTR_Msk = 0x10
	// Bit MONCLKSTR.
	I2C_CFG_MONCLKSTR = 0x10
	// Disabled. The Monitor function will not perform clock stretching. Software or DMA may not always be able to read data provided by the Monitor function before it is overwritten. This mode may be used when non-invasive monitoring is critical.
	I2C_CFG_MONCLKSTR_DISABLED = 0x0
	// Enabled. The Monitor function will perform clock stretching in order to ensure that software or DMA can read all incoming data supplied by the Monitor function.
	I2C_CFG_MONCLKSTR_ENABLED = 0x1

	// STAT: Status register for Master, Slave, and Monitor functions.
	// Position of MSTPENDING field.
	I2C_STAT_MSTPENDING_Pos = 0x0
	// Bit mask of MSTPENDING field.
	I2C_STAT_MSTPENDING_Msk = 0x1
	// Bit MSTPENDING.
	I2C_STAT_MSTPENDING = 0x1
	// In progress. Communication is in progress and the Master function is busy and cannot currently accept a command.
	I2C_STAT_MSTPENDING_IN_PROGRESS = 0x0
	// Pending. The Master function needs software service or is in the idle state. If the master is not in the idle state, it is waiting to receive or transmit data or the NACK bit.
	I2C_STAT_MSTPENDING_PENDING = 0x1
	// Position of MSTSTATE field.
	I2C_STAT_MSTSTATE_Pos = 0x1
	// Bit mask of MSTSTATE field.
	I2C_STAT_MSTSTATE_Msk = 0xe
	// Idle. The Master function is available to be used for a new transaction.
	I2C_STAT_MSTSTATE_IDLE = 0x0
	// Receive ready. Received data available (Master Receiver mode). Address plus Read was previously sent and Acknowledged by slave.
	I2C_STAT_MSTSTATE_RECEIVE_READY = 0x1
	// Transmit ready. Data can be transmitted (Master Transmitter mode). Address plus Write was previously sent and Acknowledged by slave.
	I2C_STAT_MSTSTATE_TRANSMIT_READY = 0x2
	// NACK Address. Slave NACKed address.
	I2C_STAT_MSTSTATE_NACK_ADDRESS = 0x3
	// NACK Data. Slave NACKed transmitted data.
	I2C_STAT_MSTSTATE_NACK_DATA = 0x4
	// Position of MSTARBLOSS field.
	I2C_STAT_MSTARBLOSS_Pos = 0x4
	// Bit mask of MSTARBLOSS field.
	I2C_STAT_MSTARBLOSS_Msk = 0x10
	// Bit MSTARBLOSS.
	I2C_STAT_MSTARBLOSS = 0x10
	// No Arbitration Loss has occurred.
	I2C_STAT_MSTARBLOSS_NO_LOSS = 0x0
	// Arbitration loss. The Master function has experienced an Arbitration Loss. At this point, the Master function has already stopped driving the bus and gone to an idle state. Software can respond by doing nothing, or by sending a Start in order to attempt to gain control of the bus when it next becomes idle.
	I2C_STAT_MSTARBLOSS_ARBITRATION_LOSS = 0x1
	// Position of MSTSTSTPERR field.
	I2C_STAT_MSTSTSTPERR_Pos = 0x6
	// Bit mask of MSTSTSTPERR field.
	I2C_STAT_MSTSTSTPERR_Msk = 0x40
	// Bit MSTSTSTPERR.
	I2C_STAT_MSTSTSTPERR = 0x40
	// No Start/Stop Error has occurred.
	I2C_STAT_MSTSTSTPERR_NO_ERROR = 0x0
	// The Master function has experienced a Start/Stop Error. A Start or Stop was detected at a time when it is not allowed by the I2C specification. The Master interface has stopped driving the bus and gone to an idle state, no action is required. A request for a Start could be made, or software could attempt to insure that the bus has not stalled.
	I2C_STAT_MSTSTSTPERR_ERROR = 0x1
	// Position of SLVPENDING field.
	I2C_STAT_SLVPENDING_Pos = 0x8
	// Bit mask of SLVPENDING field.
	I2C_STAT_SLVPENDING_Msk = 0x100
	// Bit SLVPENDING.
	I2C_STAT_SLVPENDING = 0x100
	// In progress. The Slave function does not currently need service.
	I2C_STAT_SLVPENDING_IN_PROGRESS = 0x0
	// Pending. The Slave function needs service. Information on what is needed can be found in the adjacent SLVSTATE field.
	I2C_STAT_SLVPENDING_PENDING = 0x1
	// Position of SLVSTATE field.
	I2C_STAT_SLVSTATE_Pos = 0x9
	// Bit mask of SLVSTATE field.
	I2C_STAT_SLVSTATE_Msk = 0x600
	// Slave address. Address plus R/W received. At least one of the four slave addresses has been matched by hardware.
	I2C_STAT_SLVSTATE_SLAVE_ADDRESS = 0x0
	// Slave receive. Received data is available (Slave Receiver mode).
	I2C_STAT_SLVSTATE_SLAVE_RECEIVE = 0x1
	// Slave transmit. Data can be transmitted (Slave Transmitter mode).
	I2C_STAT_SLVSTATE_SLAVE_TRANSMIT = 0x2
	// Position of SLVNOTSTR field.
	I2C_STAT_SLVNOTSTR_Pos = 0xb
	// Bit mask of SLVNOTSTR field.
	I2C_STAT_SLVNOTSTR_Msk = 0x800
	// Bit SLVNOTSTR.
	I2C_STAT_SLVNOTSTR = 0x800
	// Stretching. The slave function is currently stretching the I2C bus clock. Deep-Sleep or Power-down mode cannot be entered at this time.
	I2C_STAT_SLVNOTSTR_STRETCHING = 0x0
	// Not stretching. The slave function is not currently stretching the I 2C bus clock. Deep-sleep or Power-down mode could be entered at this time.
	I2C_STAT_SLVNOTSTR_NOT_STRETCHING = 0x1
	// Position of SLVIDX field.
	I2C_STAT_SLVIDX_Pos = 0xc
	// Bit mask of SLVIDX field.
	I2C_STAT_SLVIDX_Msk = 0x3000
	// Address 0. Slave address 0 was matched.
	I2C_STAT_SLVIDX_ADDRESS0 = 0x0
	// Address 1. Slave address 1 was matched.
	I2C_STAT_SLVIDX_ADDRESS1 = 0x1
	// Address 2. Slave address 2 was matched.
	I2C_STAT_SLVIDX_ADDRESS2 = 0x2
	// Address 3. Slave address 3 was matched.
	I2C_STAT_SLVIDX_ADDRESS3 = 0x3
	// Position of SLVSEL field.
	I2C_STAT_SLVSEL_Pos = 0xe
	// Bit mask of SLVSEL field.
	I2C_STAT_SLVSEL_Msk = 0x4000
	// Bit SLVSEL.
	I2C_STAT_SLVSEL = 0x4000
	// Not selected. The Slave function is not currently selected.
	I2C_STAT_SLVSEL_NOT_SELECTED = 0x0
	// Selected. The Slave function is currently selected.
	I2C_STAT_SLVSEL_SELECTED = 0x1
	// Position of SLVDESEL field.
	I2C_STAT_SLVDESEL_Pos = 0xf
	// Bit mask of SLVDESEL field.
	I2C_STAT_SLVDESEL_Msk = 0x8000
	// Bit SLVDESEL.
	I2C_STAT_SLVDESEL = 0x8000
	// Not deselected. The Slave function has not become deselected. This does not mean that it is currently selected. That information can be found in the SLVSEL flag.
	I2C_STAT_SLVDESEL_NOT_DESELECTED = 0x0
	// Deselected. The Slave function has become deselected. This is specifically caused by the SLVSEL flag changing from 1 to 0. See the description of SLVSEL for details on when that event occurs.
	I2C_STAT_SLVDESEL_DESELECTED = 0x1
	// Position of MONRDY field.
	I2C_STAT_MONRDY_Pos = 0x10
	// Bit mask of MONRDY field.
	I2C_STAT_MONRDY_Msk = 0x10000
	// Bit MONRDY.
	I2C_STAT_MONRDY = 0x10000
	// No data. The Monitor function does not currently have data available.
	I2C_STAT_MONRDY_NO_DATA = 0x0
	// Data waiting. The Monitor function has data waiting to be read.
	I2C_STAT_MONRDY_DATA_WAITING = 0x1
	// Position of MONOV field.
	I2C_STAT_MONOV_Pos = 0x11
	// Bit mask of MONOV field.
	I2C_STAT_MONOV_Msk = 0x20000
	// Bit MONOV.
	I2C_STAT_MONOV = 0x20000
	// No overrun. Monitor data has not overrun.
	I2C_STAT_MONOV_NO_OVERRUN = 0x0
	// Overrun. A Monitor data overrun has occurred. This can only happen when Monitor clock stretching not enabled via the MONCLKSTR bit in the CFG register. Writing 1 to this bit clears the flag.
	I2C_STAT_MONOV_OVERRUN = 0x1
	// Position of MONACTIVE field.
	I2C_STAT_MONACTIVE_Pos = 0x12
	// Bit mask of MONACTIVE field.
	I2C_STAT_MONACTIVE_Msk = 0x40000
	// Bit MONACTIVE.
	I2C_STAT_MONACTIVE = 0x40000
	// Inactive. The Monitor function considers the I2C bus to be inactive.
	I2C_STAT_MONACTIVE_INACTIVE = 0x0
	// Active. The Monitor function considers the I2C bus to be active.
	I2C_STAT_MONACTIVE_ACTIVE = 0x1
	// Position of MONIDLE field.
	I2C_STAT_MONIDLE_Pos = 0x13
	// Bit mask of MONIDLE field.
	I2C_STAT_MONIDLE_Msk = 0x80000
	// Bit MONIDLE.
	I2C_STAT_MONIDLE = 0x80000
	// Not idle. The I2C bus is not idle, or this flag has been cleared by software.
	I2C_STAT_MONIDLE_NOT_IDLE = 0x0
	// Idle. The I2C bus has gone idle at least once since the last time this flag was cleared by software.
	I2C_STAT_MONIDLE_IDLE = 0x1
	// Position of EVENTTIMEOUT field.
	I2C_STAT_EVENTTIMEOUT_Pos = 0x18
	// Bit mask of EVENTTIMEOUT field.
	I2C_STAT_EVENTTIMEOUT_Msk = 0x1000000
	// Bit EVENTTIMEOUT.
	I2C_STAT_EVENTTIMEOUT = 0x1000000
	// No time-out. I2C bus events have not caused a time-out.
	I2C_STAT_EVENTTIMEOUT_NO_TIMEOUT = 0x0
	// Event time-out. The time between I2C bus events has been longer than the time specified by the TIMEOUT register.
	I2C_STAT_EVENTTIMEOUT_EVEN_TIMEOUT = 0x1
	// Position of SCLTIMEOUT field.
	I2C_STAT_SCLTIMEOUT_Pos = 0x19
	// Bit mask of SCLTIMEOUT field.
	I2C_STAT_SCLTIMEOUT_Msk = 0x2000000
	// Bit SCLTIMEOUT.
	I2C_STAT_SCLTIMEOUT = 0x2000000
	// No time-out. SCL low time has not caused a time-out.
	I2C_STAT_SCLTIMEOUT_NO_TIMEOUT = 0x0
	// Time-out. SCL low time has caused a time-out.
	I2C_STAT_SCLTIMEOUT_TIMEOUT = 0x1

	// INTENSET: Interrupt Enable Set and read register.
	// Position of MSTPENDINGEN field.
	I2C_INTENSET_MSTPENDINGEN_Pos = 0x0
	// Bit mask of MSTPENDINGEN field.
	I2C_INTENSET_MSTPENDINGEN_Msk = 0x1
	// Bit MSTPENDINGEN.
	I2C_INTENSET_MSTPENDINGEN = 0x1
	// Disabled. The MstPending interrupt is disabled.
	I2C_INTENSET_MSTPENDINGEN_DISABLED = 0x0
	// Enabled. The MstPending interrupt is enabled.
	I2C_INTENSET_MSTPENDINGEN_ENABLED = 0x1
	// Position of MSTARBLOSSEN field.
	I2C_INTENSET_MSTARBLOSSEN_Pos = 0x4
	// Bit mask of MSTARBLOSSEN field.
	I2C_INTENSET_MSTARBLOSSEN_Msk = 0x10
	// Bit MSTARBLOSSEN.
	I2C_INTENSET_MSTARBLOSSEN = 0x10
	// Disabled. The MstArbLoss interrupt is disabled.
	I2C_INTENSET_MSTARBLOSSEN_DISABLED = 0x0
	// Enabled. The MstArbLoss interrupt is enabled.
	I2C_INTENSET_MSTARBLOSSEN_ENABLED = 0x1
	// Position of MSTSTSTPERREN field.
	I2C_INTENSET_MSTSTSTPERREN_Pos = 0x6
	// Bit mask of MSTSTSTPERREN field.
	I2C_INTENSET_MSTSTSTPERREN_Msk = 0x40
	// Bit MSTSTSTPERREN.
	I2C_INTENSET_MSTSTSTPERREN = 0x40
	// Disabled. The MstStStpErr interrupt is disabled.
	I2C_INTENSET_MSTSTSTPERREN_DISABLED = 0x0
	// Enabled. The MstStStpErr interrupt is enabled.
	I2C_INTENSET_MSTSTSTPERREN_ENABLED = 0x1
	// Position of SLVPENDINGEN field.
	I2C_INTENSET_SLVPENDINGEN_Pos = 0x8
	// Bit mask of SLVPENDINGEN field.
	I2C_INTENSET_SLVPENDINGEN_Msk = 0x100
	// Bit SLVPENDINGEN.
	I2C_INTENSET_SLVPENDINGEN = 0x100
	// Disabled. The SlvPending interrupt is disabled.
	I2C_INTENSET_SLVPENDINGEN_DISABLED = 0x0
	// Enabled. The SlvPending interrupt is enabled.
	I2C_INTENSET_SLVPENDINGEN_ENABLED = 0x1
	// Position of SLVNOTSTREN field.
	I2C_INTENSET_SLVNOTSTREN_Pos = 0xb
	// Bit mask of SLVNOTSTREN field.
	I2C_INTENSET_SLVNOTSTREN_Msk = 0x800
	// Bit SLVNOTSTREN.
	I2C_INTENSET_SLVNOTSTREN = 0x800
	// Disabled. The SlvNotStr interrupt is disabled.
	I2C_INTENSET_SLVNOTSTREN_DISABLED = 0x0
	// Enabled. The SlvNotStr interrupt is enabled.
	I2C_INTENSET_SLVNOTSTREN_ENABLED = 0x1
	// Position of SLVDESELEN field.
	I2C_INTENSET_SLVDESELEN_Pos = 0xf
	// Bit mask of SLVDESELEN field.
	I2C_INTENSET_SLVDESELEN_Msk = 0x8000
	// Bit SLVDESELEN.
	I2C_INTENSET_SLVDESELEN = 0x8000
	// Disabled. The SlvDeSel interrupt is disabled.
	I2C_INTENSET_SLVDESELEN_DISABLED = 0x0
	// Enabled. The SlvDeSel interrupt is enabled.
	I2C_INTENSET_SLVDESELEN_ENABLED = 0x1
	// Position of MONRDYEN field.
	I2C_INTENSET_MONRDYEN_Pos = 0x10
	// Bit mask of MONRDYEN field.
	I2C_INTENSET_MONRDYEN_Msk = 0x10000
	// Bit MONRDYEN.
	I2C_INTENSET_MONRDYEN = 0x10000
	// Disabled. The MonRdy interrupt is disabled.
	I2C_INTENSET_MONRDYEN_DISABLED = 0x0
	// Enabled. The MonRdy interrupt is enabled.
	I2C_INTENSET_MONRDYEN_ENABLED = 0x1
	// Position of MONOVEN field.
	I2C_INTENSET_MONOVEN_Pos = 0x11
	// Bit mask of MONOVEN field.
	I2C_INTENSET_MONOVEN_Msk = 0x20000
	// Bit MONOVEN.
	I2C_INTENSET_MONOVEN = 0x20000
	// Disabled. The MonOv interrupt is disabled.
	I2C_INTENSET_MONOVEN_DISABLED = 0x0
	// Enabled. The MonOv interrupt is enabled.
	I2C_INTENSET_MONOVEN_ENABLED = 0x1
	// Position of MONIDLEEN field.
	I2C_INTENSET_MONIDLEEN_Pos = 0x13
	// Bit mask of MONIDLEEN field.
	I2C_INTENSET_MONIDLEEN_Msk = 0x80000
	// Bit MONIDLEEN.
	I2C_INTENSET_MONIDLEEN = 0x80000
	// Disabled. The MonIdle interrupt is disabled.
	I2C_INTENSET_MONIDLEEN_DISABLED = 0x0
	// Enabled. The MonIdle interrupt is enabled.
	I2C_INTENSET_MONIDLEEN_ENABLED = 0x1
	// Position of EVENTTIMEOUTEN field.
	I2C_INTENSET_EVENTTIMEOUTEN_Pos = 0x18
	// Bit mask of EVENTTIMEOUTEN field.
	I2C_INTENSET_EVENTTIMEOUTEN_Msk = 0x1000000
	// Bit EVENTTIMEOUTEN.
	I2C_INTENSET_EVENTTIMEOUTEN = 0x1000000
	// Disabled. The Event time-out interrupt is disabled.
	I2C_INTENSET_EVENTTIMEOUTEN_DISABLED = 0x0
	// Enabled. The Event time-out interrupt is enabled.
	I2C_INTENSET_EVENTTIMEOUTEN_ENABLED = 0x1
	// Position of SCLTIMEOUTEN field.
	I2C_INTENSET_SCLTIMEOUTEN_Pos = 0x19
	// Bit mask of SCLTIMEOUTEN field.
	I2C_INTENSET_SCLTIMEOUTEN_Msk = 0x2000000
	// Bit SCLTIMEOUTEN.
	I2C_INTENSET_SCLTIMEOUTEN = 0x2000000
	// Disabled. The SCL time-out interrupt is disabled.
	I2C_INTENSET_SCLTIMEOUTEN_DISABLED = 0x0
	// Enabled. The SCL time-out interrupt is enabled.
	I2C_INTENSET_SCLTIMEOUTEN_ENABLED = 0x1

	// INTENCLR: Interrupt Enable Clear register.
	// Position of MSTPENDINGCLR field.
	I2C_INTENCLR_MSTPENDINGCLR_Pos = 0x0
	// Bit mask of MSTPENDINGCLR field.
	I2C_INTENCLR_MSTPENDINGCLR_Msk = 0x1
	// Bit MSTPENDINGCLR.
	I2C_INTENCLR_MSTPENDINGCLR = 0x1
	// Position of MSTARBLOSSCLR field.
	I2C_INTENCLR_MSTARBLOSSCLR_Pos = 0x4
	// Bit mask of MSTARBLOSSCLR field.
	I2C_INTENCLR_MSTARBLOSSCLR_Msk = 0x10
	// Bit MSTARBLOSSCLR.
	I2C_INTENCLR_MSTARBLOSSCLR = 0x10
	// Position of MSTSTSTPERRCLR field.
	I2C_INTENCLR_MSTSTSTPERRCLR_Pos = 0x6
	// Bit mask of MSTSTSTPERRCLR field.
	I2C_INTENCLR_MSTSTSTPERRCLR_Msk = 0x40
	// Bit MSTSTSTPERRCLR.
	I2C_INTENCLR_MSTSTSTPERRCLR = 0x40
	// Position of SLVPENDINGCLR field.
	I2C_INTENCLR_SLVPENDINGCLR_Pos = 0x8
	// Bit mask of SLVPENDINGCLR field.
	I2C_INTENCLR_SLVPENDINGCLR_Msk = 0x100
	// Bit SLVPENDINGCLR.
	I2C_INTENCLR_SLVPENDINGCLR = 0x100
	// Position of SLVNOTSTRCLR field.
	I2C_INTENCLR_SLVNOTSTRCLR_Pos = 0xb
	// Bit mask of SLVNOTSTRCLR field.
	I2C_INTENCLR_SLVNOTSTRCLR_Msk = 0x800
	// Bit SLVNOTSTRCLR.
	I2C_INTENCLR_SLVNOTSTRCLR = 0x800
	// Position of SLVDESELCLR field.
	I2C_INTENCLR_SLVDESELCLR_Pos = 0xf
	// Bit mask of SLVDESELCLR field.
	I2C_INTENCLR_SLVDESELCLR_Msk = 0x8000
	// Bit SLVDESELCLR.
	I2C_INTENCLR_SLVDESELCLR = 0x8000
	// Position of MONRDYCLR field.
	I2C_INTENCLR_MONRDYCLR_Pos = 0x10
	// Bit mask of MONRDYCLR field.
	I2C_INTENCLR_MONRDYCLR_Msk = 0x10000
	// Bit MONRDYCLR.
	I2C_INTENCLR_MONRDYCLR = 0x10000
	// Position of MONOVCLR field.
	I2C_INTENCLR_MONOVCLR_Pos = 0x11
	// Bit mask of MONOVCLR field.
	I2C_INTENCLR_MONOVCLR_Msk = 0x20000
	// Bit MONOVCLR.
	I2C_INTENCLR_MONOVCLR = 0x20000
	// Position of MONIDLECLR field.
	I2C_INTENCLR_MONIDLECLR_Pos = 0x13
	// Bit mask of MONIDLECLR field.
	I2C_INTENCLR_MONIDLECLR_Msk = 0x80000
	// Bit MONIDLECLR.
	I2C_INTENCLR_MONIDLECLR = 0x80000
	// Position of EVENTTIMEOUTCLR field.
	I2C_INTENCLR_EVENTTIMEOUTCLR_Pos = 0x18
	// Bit mask of EVENTTIMEOUTCLR field.
	I2C_INTENCLR_EVENTTIMEOUTCLR_Msk = 0x1000000
	// Bit EVENTTIMEOUTCLR.
	I2C_INTENCLR_EVENTTIMEOUTCLR = 0x1000000
	// Position of SCLTIMEOUTCLR field.
	I2C_INTENCLR_SCLTIMEOUTCLR_Pos = 0x19
	// Bit mask of SCLTIMEOUTCLR field.
	I2C_INTENCLR_SCLTIMEOUTCLR_Msk = 0x2000000
	// Bit SCLTIMEOUTCLR.
	I2C_INTENCLR_SCLTIMEOUTCLR = 0x2000000

	// TIMEOUT: Time-out value register.
	// Position of TOMIN field.
	I2C_TIMEOUT_TOMIN_Pos = 0x0
	// Bit mask of TOMIN field.
	I2C_TIMEOUT_TOMIN_Msk = 0xf
	// Position of TO field.
	I2C_TIMEOUT_TO_Pos = 0x4
	// Bit mask of TO field.
	I2C_TIMEOUT_TO_Msk = 0xfff0

	// CLKDIV: Clock pre-divider for the entire I2C interface. This determines what time increments are used for the MSTTIME register, and controls some timing of the Slave function.
	// Position of DIVVAL field.
	I2C_CLKDIV_DIVVAL_Pos = 0x0
	// Bit mask of DIVVAL field.
	I2C_CLKDIV_DIVVAL_Msk = 0xffff

	// INTSTAT: Interrupt Status register for Master, Slave, and Monitor functions.
	// Position of MSTPENDING field.
	I2C_INTSTAT_MSTPENDING_Pos = 0x0
	// Bit mask of MSTPENDING field.
	I2C_INTSTAT_MSTPENDING_Msk = 0x1
	// Bit MSTPENDING.
	I2C_INTSTAT_MSTPENDING = 0x1
	// Position of MSTARBLOSS field.
	I2C_INTSTAT_MSTARBLOSS_Pos = 0x4
	// Bit mask of MSTARBLOSS field.
	I2C_INTSTAT_MSTARBLOSS_Msk = 0x10
	// Bit MSTARBLOSS.
	I2C_INTSTAT_MSTARBLOSS = 0x10
	// Position of MSTSTSTPERR field.
	I2C_INTSTAT_MSTSTSTPERR_Pos = 0x6
	// Bit mask of MSTSTSTPERR field.
	I2C_INTSTAT_MSTSTSTPERR_Msk = 0x40
	// Bit MSTSTSTPERR.
	I2C_INTSTAT_MSTSTSTPERR = 0x40
	// Position of SLVPENDING field.
	I2C_INTSTAT_SLVPENDING_Pos = 0x8
	// Bit mask of SLVPENDING field.
	I2C_INTSTAT_SLVPENDING_Msk = 0x100
	// Bit SLVPENDING.
	I2C_INTSTAT_SLVPENDING = 0x100
	// Position of SLVNOTSTR field.
	I2C_INTSTAT_SLVNOTSTR_Pos = 0xb
	// Bit mask of SLVNOTSTR field.
	I2C_INTSTAT_SLVNOTSTR_Msk = 0x800
	// Bit SLVNOTSTR.
	I2C_INTSTAT_SLVNOTSTR = 0x800
	// Position of SLVDESEL field.
	I2C_INTSTAT_SLVDESEL_Pos = 0xf
	// Bit mask of SLVDESEL field.
	I2C_INTSTAT_SLVDESEL_Msk = 0x8000
	// Bit SLVDESEL.
	I2C_INTSTAT_SLVDESEL = 0x8000
	// Position of MONRDY field.
	I2C_INTSTAT_MONRDY_Pos = 0x10
	// Bit mask of MONRDY field.
	I2C_INTSTAT_MONRDY_Msk = 0x10000
	// Bit MONRDY.
	I2C_INTSTAT_MONRDY = 0x10000
	// Position of MONOV field.
	I2C_INTSTAT_MONOV_Pos = 0x11
	// Bit mask of MONOV field.
	I2C_INTSTAT_MONOV_Msk = 0x20000
	// Bit MONOV.
	I2C_INTSTAT_MONOV = 0x20000
	// Position of MONIDLE field.
	I2C_INTSTAT_MONIDLE_Pos = 0x13
	// Bit mask of MONIDLE field.
	I2C_INTSTAT_MONIDLE_Msk = 0x80000
	// Bit MONIDLE.
	I2C_INTSTAT_MONIDLE = 0x80000
	// Position of EVENTTIMEOUT field.
	I2C_INTSTAT_EVENTTIMEOUT_Pos = 0x18
	// Bit mask of EVENTTIMEOUT field.
	I2C_INTSTAT_EVENTTIMEOUT_Msk = 0x1000000
	// Bit EVENTTIMEOUT.
	I2C_INTSTAT_EVENTTIMEOUT = 0x1000000
	// Position of SCLTIMEOUT field.
	I2C_INTSTAT_SCLTIMEOUT_Pos = 0x19
	// Bit mask of SCLTIMEOUT field.
	I2C_INTSTAT_SCLTIMEOUT_Msk = 0x2000000
	// Bit SCLTIMEOUT.
	I2C_INTSTAT_SCLTIMEOUT = 0x2000000

	// MSTCTL: Master control register.
	// Position of MSTCONTINUE field.
	I2C_MSTCTL_MSTCONTINUE_Pos = 0x0
	// Bit mask of MSTCONTINUE field.
	I2C_MSTCTL_MSTCONTINUE_Msk = 0x1
	// Bit MSTCONTINUE.
	I2C_MSTCTL_MSTCONTINUE = 0x1
	// No effect.
	I2C_MSTCTL_MSTCONTINUE_NO_EFFECT = 0x0
	// Continue. Informs the Master function to continue to the next operation. This must done after writing transmit data, reading received data, or any other housekeeping related to the next bus operation.
	I2C_MSTCTL_MSTCONTINUE_CONTINUE = 0x1
	// Position of MSTSTART field.
	I2C_MSTCTL_MSTSTART_Pos = 0x1
	// Bit mask of MSTSTART field.
	I2C_MSTCTL_MSTSTART_Msk = 0x2
	// Bit MSTSTART.
	I2C_MSTCTL_MSTSTART = 0x2
	// No effect.
	I2C_MSTCTL_MSTSTART_NO_EFFECT = 0x0
	// Start. A Start will be generated on the I2C bus at the next allowed time.
	I2C_MSTCTL_MSTSTART_START = 0x1
	// Position of MSTSTOP field.
	I2C_MSTCTL_MSTSTOP_Pos = 0x2
	// Bit mask of MSTSTOP field.
	I2C_MSTCTL_MSTSTOP_Msk = 0x4
	// Bit MSTSTOP.
	I2C_MSTCTL_MSTSTOP = 0x4
	// No effect.
	I2C_MSTCTL_MSTSTOP_NO_EFFECT = 0x0
	// Stop. A Stop will be generated on the I2C bus at the next allowed time, preceded by a NACK to the slave if the master is receiving data from the slave (Master Receiver mode).
	I2C_MSTCTL_MSTSTOP_STOP = 0x1
	// Position of MSTDMA field.
	I2C_MSTCTL_MSTDMA_Pos = 0x3
	// Bit mask of MSTDMA field.
	I2C_MSTCTL_MSTDMA_Msk = 0x8
	// Bit MSTDMA.
	I2C_MSTCTL_MSTDMA = 0x8
	// Disable. No DMA requests are generated for master operation.
	I2C_MSTCTL_MSTDMA_DISABLED = 0x0
	// Enable. A DMA request is generated for I2C master data operations. When this I2C master is generating Acknowledge bits in Master Receiver mode, the acknowledge is generated automatically.
	I2C_MSTCTL_MSTDMA_ENABLED = 0x1

	// MSTTIME: Master timing configuration.
	// Position of MSTSCLLOW field.
	I2C_MSTTIME_MSTSCLLOW_Pos = 0x0
	// Bit mask of MSTSCLLOW field.
	I2C_MSTTIME_MSTSCLLOW_Msk = 0x7
	// 2 clocks. Minimum SCL low time is 2 clocks of the I2C clock pre-divider.
	I2C_MSTTIME_MSTSCLLOW__2_CLOCKS = 0x0
	// 3 clocks. Minimum SCL low time is 3 clocks of the I2C clock pre-divider.
	I2C_MSTTIME_MSTSCLLOW__3_CLOCKS = 0x1
	// 4 clocks. Minimum SCL low time is 4 clocks of the I2C clock pre-divider.
	I2C_MSTTIME_MSTSCLLOW__4_CLOCKS = 0x2
	// 5 clocks. Minimum SCL low time is 5 clocks of the I2C clock pre-divider.
	I2C_MSTTIME_MSTSCLLOW__5_CLOCKS = 0x3
	// 6 clocks. Minimum SCL low time is 6 clocks of the I2C clock pre-divider.
	I2C_MSTTIME_MSTSCLLOW__6_CLOCKS = 0x4
	// 7 clocks. Minimum SCL low time is 7 clocks of the I2C clock pre-divider.
	I2C_MSTTIME_MSTSCLLOW__7_CLOCKS = 0x5
	// 8 clocks. Minimum SCL low time is 8 clocks of the I2C clock pre-divider.
	I2C_MSTTIME_MSTSCLLOW__8_CLOCKS = 0x6
	// 9 clocks. Minimum SCL low time is 9 clocks of the I2C clock pre-divider.
	I2C_MSTTIME_MSTSCLLOW__9_CLOCKS = 0x7
	// Position of MSTSCLHIGH field.
	I2C_MSTTIME_MSTSCLHIGH_Pos = 0x4
	// Bit mask of MSTSCLHIGH field.
	I2C_MSTTIME_MSTSCLHIGH_Msk = 0x70
	// 2 clocks. Minimum SCL high time is 2 clock of the I2C clock pre-divider.
	I2C_MSTTIME_MSTSCLHIGH__2_CLOCKS = 0x0
	// 3 clocks. Minimum SCL high time is 3 clocks of the I2C clock pre-divider .
	I2C_MSTTIME_MSTSCLHIGH__3_CLOCKS = 0x1
	// 4 clocks. Minimum SCL high time is 4 clock of the I2C clock pre-divider.
	I2C_MSTTIME_MSTSCLHIGH__4_CLOCKS = 0x2
	// 5 clocks. Minimum SCL high time is 5 clock of the I2C clock pre-divider.
	I2C_MSTTIME_MSTSCLHIGH__5_CLOCKS = 0x3
	// 6 clocks. Minimum SCL high time is 6 clock of the I2C clock pre-divider.
	I2C_MSTTIME_MSTSCLHIGH__6_CLOCKS = 0x4
	// 7 clocks. Minimum SCL high time is 7 clock of the I2C clock pre-divider.
	I2C_MSTTIME_MSTSCLHIGH__7_CLOCKS = 0x5
	// 8 clocks. Minimum SCL high time is 8 clock of the I2C clock pre-divider.
	I2C_MSTTIME_MSTSCLHIGH__8_CLOCKS = 0x6
	// 9 clocks. Minimum SCL high time is 9 clocks of the I2C clock pre-divider.
	I2C_MSTTIME_MSTSCLHIGH__9_CLOCKS = 0x7

	// MSTDAT: Combined Master receiver and transmitter data register.
	// Position of DATA field.
	I2C_MSTDAT_DATA_Pos = 0x0
	// Bit mask of DATA field.
	I2C_MSTDAT_DATA_Msk = 0xff

	// SLVCTL: Slave control register.
	// Position of SLVCONTINUE field.
	I2C_SLVCTL_SLVCONTINUE_Pos = 0x0
	// Bit mask of SLVCONTINUE field.
	I2C_SLVCTL_SLVCONTINUE_Msk = 0x1
	// Bit SLVCONTINUE.
	I2C_SLVCTL_SLVCONTINUE = 0x1
	// No effect.
	I2C_SLVCTL_SLVCONTINUE_NO_EFFECT = 0x0
	// Continue. Informs the Slave function to continue to the next operation, by clearing the SLVPENDING flag in the STAT register. This must be done after writing transmit data, reading received data, or any other housekeeping related to the next bus operation. Automatic Operation has different requirements. SLVCONTINUE should not be set unless SLVPENDING = 1.
	I2C_SLVCTL_SLVCONTINUE_CONTINUE = 0x1
	// Position of SLVNACK field.
	I2C_SLVCTL_SLVNACK_Pos = 0x1
	// Bit mask of SLVNACK field.
	I2C_SLVCTL_SLVNACK_Msk = 0x2
	// Bit SLVNACK.
	I2C_SLVCTL_SLVNACK = 0x2
	// No effect.
	I2C_SLVCTL_SLVNACK_NO_EFFECT = 0x0
	// NACK. Causes the Slave function to NACK the master when the slave is receiving data from the master (Slave Receiver mode).
	I2C_SLVCTL_SLVNACK_NACK = 0x1
	// Position of SLVDMA field.
	I2C_SLVCTL_SLVDMA_Pos = 0x3
	// Bit mask of SLVDMA field.
	I2C_SLVCTL_SLVDMA_Msk = 0x8
	// Bit SLVDMA.
	I2C_SLVCTL_SLVDMA = 0x8
	// Disabled. No DMA requests are issued for Slave mode operation.
	I2C_SLVCTL_SLVDMA_DISABLED = 0x0
	// Enabled. DMA requests are issued for I2C slave data transmission and reception.
	I2C_SLVCTL_SLVDMA_ENABLED = 0x1
	// Position of AUTOACK field.
	I2C_SLVCTL_AUTOACK_Pos = 0x8
	// Bit mask of AUTOACK field.
	I2C_SLVCTL_AUTOACK_Msk = 0x100
	// Bit AUTOACK.
	I2C_SLVCTL_AUTOACK = 0x100
	// Normal, non-automatic operation. If AUTONACK = 0, an SlvPending interrupt is generated when a matching address is received. If AUTONACK = 1, received addresses are NACKed (ignored).
	I2C_SLVCTL_AUTOACK_NORMAL = 0x0
	// A header with matching SLVADR0 and matching direction as set by AUTOMATCHREAD will be ACKed immediately, allowing the master to move on to the data bytes. If the address matches SLVADR0, but the direction does not match AUTOMATCHREAD, the behavior will depend on the AUTONACK bit in the SLVADR0 register: if AUTONACK is set, then it will be Nacked; else if AUTONACK is clear, then a SlvPending interrupt is generated.
	I2C_SLVCTL_AUTOACK_AUTOMATIC_ACK = 0x1
	// Position of AUTOMATCHREAD field.
	I2C_SLVCTL_AUTOMATCHREAD_Pos = 0x9
	// Bit mask of AUTOMATCHREAD field.
	I2C_SLVCTL_AUTOMATCHREAD_Msk = 0x200
	// Bit AUTOMATCHREAD.
	I2C_SLVCTL_AUTOMATCHREAD = 0x200
	// The expected next operation in Automatic Mode is an I2C write.
	I2C_SLVCTL_AUTOMATCHREAD_I2C_WRITE = 0x0
	// The expected next operation in Automatic Mode is an I2C read.
	I2C_SLVCTL_AUTOMATCHREAD_I2C_READ = 0x1

	// SLVDAT: Combined Slave receiver and transmitter data register.
	// Position of DATA field.
	I2C_SLVDAT_DATA_Pos = 0x0
	// Bit mask of DATA field.
	I2C_SLVDAT_DATA_Msk = 0xff

	// SLVADR: Slave address register.
	// Position of SADISABLE field.
	I2C_SLVADR_SADISABLE_Pos = 0x0
	// Bit mask of SADISABLE field.
	I2C_SLVADR_SADISABLE_Msk = 0x1
	// Bit SADISABLE.
	I2C_SLVADR_SADISABLE = 0x1
	// Enabled. Slave Address n is enabled.
	I2C_SLVADR_SADISABLE_ENABLED = 0x0
	// Ignored Slave Address n is ignored.
	I2C_SLVADR_SADISABLE_DISABLED = 0x1
	// Position of SLVADR field.
	I2C_SLVADR_SLVADR_Pos = 0x1
	// Bit mask of SLVADR field.
	I2C_SLVADR_SLVADR_Msk = 0xfe
	// Position of AUTONACK field.
	I2C_SLVADR_AUTONACK_Pos = 0xf
	// Bit mask of AUTONACK field.
	I2C_SLVADR_AUTONACK_Msk = 0x8000
	// Bit AUTONACK.
	I2C_SLVADR_AUTONACK = 0x8000
	// Normal operation, matching I2C addresses are not ignored.
	I2C_SLVADR_AUTONACK_NORMAL = 0x0
	// Automatic-only mode. All incoming addresses are ignored (NACKed), unless AUTOACK is set, it matches SLVADRn, and AUTOMATCHREAD matches the direction.
	I2C_SLVADR_AUTONACK_AUTOMATIC = 0x1

	// SLVQUAL0: Slave Qualification for address 0.
	// Position of QUALMODE0 field.
	I2C_SLVQUAL0_QUALMODE0_Pos = 0x0
	// Bit mask of QUALMODE0 field.
	I2C_SLVQUAL0_QUALMODE0_Msk = 0x1
	// Bit QUALMODE0.
	I2C_SLVQUAL0_QUALMODE0 = 0x1
	// Mask. The SLVQUAL0 field is used as a logical mask for matching address 0.
	I2C_SLVQUAL0_QUALMODE0_MASK = 0x0
	// Extend. The SLVQUAL0 field is used to extend address 0 matching in a range of addresses.
	I2C_SLVQUAL0_QUALMODE0_EXTEND = 0x1
	// Position of SLVQUAL0 field.
	I2C_SLVQUAL0_SLVQUAL0_Pos = 0x1
	// Bit mask of SLVQUAL0 field.
	I2C_SLVQUAL0_SLVQUAL0_Msk = 0xfe

	// MONRXDAT: Monitor receiver data register.
	// Position of MONRXDAT field.
	I2C_MONRXDAT_MONRXDAT_Pos = 0x0
	// Bit mask of MONRXDAT field.
	I2C_MONRXDAT_MONRXDAT_Msk = 0xff
	// Position of MONSTART field.
	I2C_MONRXDAT_MONSTART_Pos = 0x8
	// Bit mask of MONSTART field.
	I2C_MONRXDAT_MONSTART_Msk = 0x100
	// Bit MONSTART.
	I2C_MONRXDAT_MONSTART = 0x100
	// No start detected. The Monitor function has not detected a Start event on the I2C bus.
	I2C_MONRXDAT_MONSTART_NO_START_DETECTED = 0x0
	// Start detected. The Monitor function has detected a Start event on the I2C bus.
	I2C_MONRXDAT_MONSTART_START_DETECTED = 0x1
	// Position of MONRESTART field.
	I2C_MONRXDAT_MONRESTART_Pos = 0x9
	// Bit mask of MONRESTART field.
	I2C_MONRXDAT_MONRESTART_Msk = 0x200
	// Bit MONRESTART.
	I2C_MONRXDAT_MONRESTART = 0x200
	// No repeated start detected. The Monitor function has not detected a Repeated Start event on the I2C bus.
	I2C_MONRXDAT_MONRESTART_NOT_DETECTED = 0x0
	// Repeated start detected. The Monitor function has detected a Repeated Start event on the I2C bus.
	I2C_MONRXDAT_MONRESTART_DETECTED = 0x1
	// Position of MONNACK field.
	I2C_MONRXDAT_MONNACK_Pos = 0xa
	// Bit mask of MONNACK field.
	I2C_MONRXDAT_MONNACK_Msk = 0x400
	// Bit MONNACK.
	I2C_MONRXDAT_MONNACK = 0x400
	// Acknowledged. The data currently being provided by the Monitor function was acknowledged by at least one master or slave receiver.
	I2C_MONRXDAT_MONNACK_ACKNOWLEDGED = 0x0
	// Not acknowledged. The data currently being provided by the Monitor function was not acknowledged by any receiver.
	I2C_MONRXDAT_MONNACK_NOT_ACKNOWLEDGED = 0x1

	// ID: I2C module Identification. This value appears in the shared Flexcomm peripheral ID register when I2C is selected.
	// Position of APERTURE field.
	I2C_ID_APERTURE_Pos = 0x0
	// Bit mask of APERTURE field.
	I2C_ID_APERTURE_Msk = 0xff
	// Position of MINOR_REV field.
	I2C_ID_MINOR_REV_Pos = 0x8
	// Bit mask of MINOR_REV field.
	I2C_ID_MINOR_REV_Msk = 0xf00
	// Position of MAJOR_REV field.
	I2C_ID_MAJOR_REV_Pos = 0xc
	// Bit mask of MAJOR_REV field.
	I2C_ID_MAJOR_REV_Msk = 0xf000
	// Position of ID field.
	I2C_ID_ID_Pos = 0x10
	// Bit mask of ID field.
	I2C_ID_ID_Msk = 0xffff0000
)

// Constants for SPI0: spi
const (
	// CFG: SPI Configuration register
	// Position of ENABLE field.
	SPI_CFG_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	SPI_CFG_ENABLE_Msk = 0x1
	// Bit ENABLE.
	SPI_CFG_ENABLE = 0x1
	// Disabled. The SPI is disabled and the internal state machine and counters are reset.
	SPI_CFG_ENABLE_DISABLED = 0x0
	// Enabled. The SPI is enabled for operation.
	SPI_CFG_ENABLE_ENABLED = 0x1
	// Position of MASTER field.
	SPI_CFG_MASTER_Pos = 0x2
	// Bit mask of MASTER field.
	SPI_CFG_MASTER_Msk = 0x4
	// Bit MASTER.
	SPI_CFG_MASTER = 0x4
	// Slave mode. The SPI will operate in slave mode. SCK, MOSI, and the SSEL signals are inputs, MISO is an output.
	SPI_CFG_MASTER_SLAVE_MODE = 0x0
	// Master mode. The SPI will operate in master mode. SCK, MOSI, and the SSEL signals are outputs, MISO is an input.
	SPI_CFG_MASTER_MASTER_MODE = 0x1
	// Position of LSBF field.
	SPI_CFG_LSBF_Pos = 0x3
	// Bit mask of LSBF field.
	SPI_CFG_LSBF_Msk = 0x8
	// Bit LSBF.
	SPI_CFG_LSBF = 0x8
	// Standard. Data is transmitted and received in standard MSB first order.
	SPI_CFG_LSBF_STANDARD = 0x0
	// Reverse. Data is transmitted and received in reverse order (LSB first).
	SPI_CFG_LSBF_REVERSE = 0x1
	// Position of CPHA field.
	SPI_CFG_CPHA_Pos = 0x4
	// Bit mask of CPHA field.
	SPI_CFG_CPHA_Msk = 0x10
	// Bit CPHA.
	SPI_CFG_CPHA = 0x10
	// Change. The SPI captures serial data on the first clock transition of the transfer (when the clock changes away from the rest state). Data is changed on the following edge.
	SPI_CFG_CPHA_CHANGE = 0x0
	// Capture. The SPI changes serial data on the first clock transition of the transfer (when the clock changes away from the rest state). Data is captured on the following edge.
	SPI_CFG_CPHA_CAPTURE = 0x1
	// Position of CPOL field.
	SPI_CFG_CPOL_Pos = 0x5
	// Bit mask of CPOL field.
	SPI_CFG_CPOL_Msk = 0x20
	// Bit CPOL.
	SPI_CFG_CPOL = 0x20
	// Low. The rest state of the clock (between transfers) is low.
	SPI_CFG_CPOL_LOW = 0x0
	// High. The rest state of the clock (between transfers) is high.
	SPI_CFG_CPOL_HIGH = 0x1
	// Position of LOOP field.
	SPI_CFG_LOOP_Pos = 0x7
	// Bit mask of LOOP field.
	SPI_CFG_LOOP_Msk = 0x80
	// Bit LOOP.
	SPI_CFG_LOOP = 0x80
	// Disabled.
	SPI_CFG_LOOP_DISABLED = 0x0
	// Enabled.
	SPI_CFG_LOOP_ENABLED = 0x1
	// Position of SPOL0 field.
	SPI_CFG_SPOL0_Pos = 0x8
	// Bit mask of SPOL0 field.
	SPI_CFG_SPOL0_Msk = 0x100
	// Bit SPOL0.
	SPI_CFG_SPOL0 = 0x100
	// Low. The SSEL0 pin is active low.
	SPI_CFG_SPOL0_LOW = 0x0
	// High. The SSEL0 pin is active high.
	SPI_CFG_SPOL0_HIGH = 0x1
	// Position of SPOL1 field.
	SPI_CFG_SPOL1_Pos = 0x9
	// Bit mask of SPOL1 field.
	SPI_CFG_SPOL1_Msk = 0x200
	// Bit SPOL1.
	SPI_CFG_SPOL1 = 0x200
	// Low. The SSEL1 pin is active low.
	SPI_CFG_SPOL1_LOW = 0x0
	// High. The SSEL1 pin is active high.
	SPI_CFG_SPOL1_HIGH = 0x1
	// Position of SPOL2 field.
	SPI_CFG_SPOL2_Pos = 0xa
	// Bit mask of SPOL2 field.
	SPI_CFG_SPOL2_Msk = 0x400
	// Bit SPOL2.
	SPI_CFG_SPOL2 = 0x400
	// Low. The SSEL2 pin is active low.
	SPI_CFG_SPOL2_LOW = 0x0
	// High. The SSEL2 pin is active high.
	SPI_CFG_SPOL2_HIGH = 0x1
	// Position of SPOL3 field.
	SPI_CFG_SPOL3_Pos = 0xb
	// Bit mask of SPOL3 field.
	SPI_CFG_SPOL3_Msk = 0x800
	// Bit SPOL3.
	SPI_CFG_SPOL3 = 0x800
	// Low. The SSEL3 pin is active low.
	SPI_CFG_SPOL3_LOW = 0x0
	// High. The SSEL3 pin is active high.
	SPI_CFG_SPOL3_HIGH = 0x1

	// DLY: SPI Delay register
	// Position of PRE_DELAY field.
	SPI_DLY_PRE_DELAY_Pos = 0x0
	// Bit mask of PRE_DELAY field.
	SPI_DLY_PRE_DELAY_Msk = 0xf
	// Position of POST_DELAY field.
	SPI_DLY_POST_DELAY_Pos = 0x4
	// Bit mask of POST_DELAY field.
	SPI_DLY_POST_DELAY_Msk = 0xf0
	// Position of FRAME_DELAY field.
	SPI_DLY_FRAME_DELAY_Pos = 0x8
	// Bit mask of FRAME_DELAY field.
	SPI_DLY_FRAME_DELAY_Msk = 0xf00
	// Position of TRANSFER_DELAY field.
	SPI_DLY_TRANSFER_DELAY_Pos = 0xc
	// Bit mask of TRANSFER_DELAY field.
	SPI_DLY_TRANSFER_DELAY_Msk = 0xf000

	// STAT: SPI Status. Some status flags can be cleared by writing a 1 to that bit position.
	// Position of SSA field.
	SPI_STAT_SSA_Pos = 0x4
	// Bit mask of SSA field.
	SPI_STAT_SSA_Msk = 0x10
	// Bit SSA.
	SPI_STAT_SSA = 0x10
	// Position of SSD field.
	SPI_STAT_SSD_Pos = 0x5
	// Bit mask of SSD field.
	SPI_STAT_SSD_Msk = 0x20
	// Bit SSD.
	SPI_STAT_SSD = 0x20
	// Position of STALLED field.
	SPI_STAT_STALLED_Pos = 0x6
	// Bit mask of STALLED field.
	SPI_STAT_STALLED_Msk = 0x40
	// Bit STALLED.
	SPI_STAT_STALLED = 0x40
	// Position of ENDTRANSFER field.
	SPI_STAT_ENDTRANSFER_Pos = 0x7
	// Bit mask of ENDTRANSFER field.
	SPI_STAT_ENDTRANSFER_Msk = 0x80
	// Bit ENDTRANSFER.
	SPI_STAT_ENDTRANSFER = 0x80
	// Position of MSTIDLE field.
	SPI_STAT_MSTIDLE_Pos = 0x8
	// Bit mask of MSTIDLE field.
	SPI_STAT_MSTIDLE_Msk = 0x100
	// Bit MSTIDLE.
	SPI_STAT_MSTIDLE = 0x100

	// INTENSET: SPI Interrupt Enable read and Set. A complete value may be read from this register. Writing a 1 to any implemented bit position causes that bit to be set.
	// Position of SSAEN field.
	SPI_INTENSET_SSAEN_Pos = 0x4
	// Bit mask of SSAEN field.
	SPI_INTENSET_SSAEN_Msk = 0x10
	// Bit SSAEN.
	SPI_INTENSET_SSAEN = 0x10
	// Disabled. No interrupt will be generated when any Slave Select transitions from deasserted to asserted.
	SPI_INTENSET_SSAEN_DISABLED = 0x0
	// Enabled. An interrupt will be generated when any Slave Select transitions from deasserted to asserted.
	SPI_INTENSET_SSAEN_ENABLED = 0x1
	// Position of SSDEN field.
	SPI_INTENSET_SSDEN_Pos = 0x5
	// Bit mask of SSDEN field.
	SPI_INTENSET_SSDEN_Msk = 0x20
	// Bit SSDEN.
	SPI_INTENSET_SSDEN = 0x20
	// Disabled. No interrupt will be generated when all asserted Slave Selects transition to deasserted.
	SPI_INTENSET_SSDEN_DISABLED = 0x0
	// Enabled. An interrupt will be generated when all asserted Slave Selects transition to deasserted.
	SPI_INTENSET_SSDEN_ENABLED = 0x1
	// Position of MSTIDLEEN field.
	SPI_INTENSET_MSTIDLEEN_Pos = 0x8
	// Bit mask of MSTIDLEEN field.
	SPI_INTENSET_MSTIDLEEN_Msk = 0x100
	// Bit MSTIDLEEN.
	SPI_INTENSET_MSTIDLEEN = 0x100
	// No interrupt will be generated when the SPI master function is idle.
	SPI_INTENSET_MSTIDLEEN_DISABLED = 0x0
	// An interrupt will be generated when the SPI master function is fully idle.
	SPI_INTENSET_MSTIDLEEN_ENABLED = 0x1

	// INTENCLR: SPI Interrupt Enable Clear. Writing a 1 to any implemented bit position causes the corresponding bit in INTENSET to be cleared.
	// Position of SSAEN field.
	SPI_INTENCLR_SSAEN_Pos = 0x4
	// Bit mask of SSAEN field.
	SPI_INTENCLR_SSAEN_Msk = 0x10
	// Bit SSAEN.
	SPI_INTENCLR_SSAEN = 0x10
	// Position of SSDEN field.
	SPI_INTENCLR_SSDEN_Pos = 0x5
	// Bit mask of SSDEN field.
	SPI_INTENCLR_SSDEN_Msk = 0x20
	// Bit SSDEN.
	SPI_INTENCLR_SSDEN = 0x20
	// Position of MSTIDLE field.
	SPI_INTENCLR_MSTIDLE_Pos = 0x8
	// Bit mask of MSTIDLE field.
	SPI_INTENCLR_MSTIDLE_Msk = 0x100
	// Bit MSTIDLE.
	SPI_INTENCLR_MSTIDLE = 0x100

	// DIV: SPI clock Divider
	// Position of DIVVAL field.
	SPI_DIV_DIVVAL_Pos = 0x0
	// Bit mask of DIVVAL field.
	SPI_DIV_DIVVAL_Msk = 0xffff

	// INTSTAT: SPI Interrupt Status
	// Position of SSA field.
	SPI_INTSTAT_SSA_Pos = 0x4
	// Bit mask of SSA field.
	SPI_INTSTAT_SSA_Msk = 0x10
	// Bit SSA.
	SPI_INTSTAT_SSA = 0x10
	// Position of SSD field.
	SPI_INTSTAT_SSD_Pos = 0x5
	// Bit mask of SSD field.
	SPI_INTSTAT_SSD_Msk = 0x20
	// Bit SSD.
	SPI_INTSTAT_SSD = 0x20
	// Position of MSTIDLE field.
	SPI_INTSTAT_MSTIDLE_Pos = 0x8
	// Bit mask of MSTIDLE field.
	SPI_INTSTAT_MSTIDLE_Msk = 0x100
	// Bit MSTIDLE.
	SPI_INTSTAT_MSTIDLE = 0x100

	// FIFOCFG: FIFO configuration and enable register.
	// Position of ENABLETX field.
	SPI_FIFOCFG_ENABLETX_Pos = 0x0
	// Bit mask of ENABLETX field.
	SPI_FIFOCFG_ENABLETX_Msk = 0x1
	// Bit ENABLETX.
	SPI_FIFOCFG_ENABLETX = 0x1
	// The transmit FIFO is not enabled.
	SPI_FIFOCFG_ENABLETX_DISABLED = 0x0
	// The transmit FIFO is enabled.
	SPI_FIFOCFG_ENABLETX_ENABLED = 0x1
	// Position of ENABLERX field.
	SPI_FIFOCFG_ENABLERX_Pos = 0x1
	// Bit mask of ENABLERX field.
	SPI_FIFOCFG_ENABLERX_Msk = 0x2
	// Bit ENABLERX.
	SPI_FIFOCFG_ENABLERX = 0x2
	// The transmit FIFO is not enabled.
	SPI_FIFOCFG_ENABLERX_DISABLED = 0x0
	// The transmit FIFO is enabled.
	SPI_FIFOCFG_ENABLERX_ENABLED = 0x1
	// Position of SIZE field.
	SPI_FIFOCFG_SIZE_Pos = 0x4
	// Bit mask of SIZE field.
	SPI_FIFOCFG_SIZE_Msk = 0x30
	// Position of DMATX field.
	SPI_FIFOCFG_DMATX_Pos = 0xc
	// Bit mask of DMATX field.
	SPI_FIFOCFG_DMATX_Msk = 0x1000
	// Bit DMATX.
	SPI_FIFOCFG_DMATX = 0x1000
	// DMA is not used for the transmit function.
	SPI_FIFOCFG_DMATX_NOT_TRIGGERED = 0x0
	// Trigger DMA for the transmit function if the FIFO is not full. Generally, data interrupts would be disabled if DMA is enabled.
	SPI_FIFOCFG_DMATX_TRIGGERED = 0x1
	// Position of DMARX field.
	SPI_FIFOCFG_DMARX_Pos = 0xd
	// Bit mask of DMARX field.
	SPI_FIFOCFG_DMARX_Msk = 0x2000
	// Bit DMARX.
	SPI_FIFOCFG_DMARX = 0x2000
	// DMA is not used for the receive function.
	SPI_FIFOCFG_DMARX_NOT_TRIGGERED = 0x0
	// Trigger DMA for the receive function if the FIFO is not empty. Generally, data interrupts would be disabled if DMA is enabled.
	SPI_FIFOCFG_DMARX_TRIGGERED = 0x1
	// Position of EMPTYTX field.
	SPI_FIFOCFG_EMPTYTX_Pos = 0x10
	// Bit mask of EMPTYTX field.
	SPI_FIFOCFG_EMPTYTX_Msk = 0x10000
	// Bit EMPTYTX.
	SPI_FIFOCFG_EMPTYTX = 0x10000
	// Position of EMPTYRX field.
	SPI_FIFOCFG_EMPTYRX_Pos = 0x11
	// Bit mask of EMPTYRX field.
	SPI_FIFOCFG_EMPTYRX_Msk = 0x20000
	// Bit EMPTYRX.
	SPI_FIFOCFG_EMPTYRX = 0x20000

	// FIFOSTAT: FIFO status register.
	// Position of TXERR field.
	SPI_FIFOSTAT_TXERR_Pos = 0x0
	// Bit mask of TXERR field.
	SPI_FIFOSTAT_TXERR_Msk = 0x1
	// Bit TXERR.
	SPI_FIFOSTAT_TXERR = 0x1
	// Position of RXERR field.
	SPI_FIFOSTAT_RXERR_Pos = 0x1
	// Bit mask of RXERR field.
	SPI_FIFOSTAT_RXERR_Msk = 0x2
	// Bit RXERR.
	SPI_FIFOSTAT_RXERR = 0x2
	// Position of PERINT field.
	SPI_FIFOSTAT_PERINT_Pos = 0x3
	// Bit mask of PERINT field.
	SPI_FIFOSTAT_PERINT_Msk = 0x8
	// Bit PERINT.
	SPI_FIFOSTAT_PERINT = 0x8
	// Position of TXEMPTY field.
	SPI_FIFOSTAT_TXEMPTY_Pos = 0x4
	// Bit mask of TXEMPTY field.
	SPI_FIFOSTAT_TXEMPTY_Msk = 0x10
	// Bit TXEMPTY.
	SPI_FIFOSTAT_TXEMPTY = 0x10
	// Position of TXNOTFULL field.
	SPI_FIFOSTAT_TXNOTFULL_Pos = 0x5
	// Bit mask of TXNOTFULL field.
	SPI_FIFOSTAT_TXNOTFULL_Msk = 0x20
	// Bit TXNOTFULL.
	SPI_FIFOSTAT_TXNOTFULL = 0x20
	// Position of RXNOTEMPTY field.
	SPI_FIFOSTAT_RXNOTEMPTY_Pos = 0x6
	// Bit mask of RXNOTEMPTY field.
	SPI_FIFOSTAT_RXNOTEMPTY_Msk = 0x40
	// Bit RXNOTEMPTY.
	SPI_FIFOSTAT_RXNOTEMPTY = 0x40
	// Position of RXFULL field.
	SPI_FIFOSTAT_RXFULL_Pos = 0x7
	// Bit mask of RXFULL field.
	SPI_FIFOSTAT_RXFULL_Msk = 0x80
	// Bit RXFULL.
	SPI_FIFOSTAT_RXFULL = 0x80
	// Position of TXLVL field.
	SPI_FIFOSTAT_TXLVL_Pos = 0x8
	// Bit mask of TXLVL field.
	SPI_FIFOSTAT_TXLVL_Msk = 0x1f00
	// Position of RXLVL field.
	SPI_FIFOSTAT_RXLVL_Pos = 0x10
	// Bit mask of RXLVL field.
	SPI_FIFOSTAT_RXLVL_Msk = 0x1f0000

	// FIFOTRIG: FIFO trigger settings for interrupt and DMA request.
	// Position of TXLVLENA field.
	SPI_FIFOTRIG_TXLVLENA_Pos = 0x0
	// Bit mask of TXLVLENA field.
	SPI_FIFOTRIG_TXLVLENA_Msk = 0x1
	// Bit TXLVLENA.
	SPI_FIFOTRIG_TXLVLENA = 0x1
	// Transmit FIFO level does not generate a FIFO level trigger.
	SPI_FIFOTRIG_TXLVLENA_DISABLED = 0x0
	// An trigger will be generated if the transmit FIFO level reaches the value specified by the TXLVL field in this register.
	SPI_FIFOTRIG_TXLVLENA_ENABLED = 0x1
	// Position of RXLVLENA field.
	SPI_FIFOTRIG_RXLVLENA_Pos = 0x1
	// Bit mask of RXLVLENA field.
	SPI_FIFOTRIG_RXLVLENA_Msk = 0x2
	// Bit RXLVLENA.
	SPI_FIFOTRIG_RXLVLENA = 0x2
	// Receive FIFO level does not generate a FIFO level trigger.
	SPI_FIFOTRIG_RXLVLENA_DISABLED = 0x0
	// An trigger will be generated if the receive FIFO level reaches the value specified by the RXLVL field in this register.
	SPI_FIFOTRIG_RXLVLENA_ENABLED = 0x1
	// Position of TXLVL field.
	SPI_FIFOTRIG_TXLVL_Pos = 0x8
	// Bit mask of TXLVL field.
	SPI_FIFOTRIG_TXLVL_Msk = 0xf00
	// Position of RXLVL field.
	SPI_FIFOTRIG_RXLVL_Pos = 0x10
	// Bit mask of RXLVL field.
	SPI_FIFOTRIG_RXLVL_Msk = 0xf0000

	// FIFOINTENSET: FIFO interrupt enable set (enable) and read register.
	// Position of TXERR field.
	SPI_FIFOINTENSET_TXERR_Pos = 0x0
	// Bit mask of TXERR field.
	SPI_FIFOINTENSET_TXERR_Msk = 0x1
	// Bit TXERR.
	SPI_FIFOINTENSET_TXERR = 0x1
	// No interrupt will be generated for a transmit error.
	SPI_FIFOINTENSET_TXERR_DISABLED = 0x0
	// An interrupt will be generated when a transmit error occurs.
	SPI_FIFOINTENSET_TXERR_ENABLED = 0x1
	// Position of RXERR field.
	SPI_FIFOINTENSET_RXERR_Pos = 0x1
	// Bit mask of RXERR field.
	SPI_FIFOINTENSET_RXERR_Msk = 0x2
	// Bit RXERR.
	SPI_FIFOINTENSET_RXERR = 0x2
	// No interrupt will be generated for a receive error.
	SPI_FIFOINTENSET_RXERR_DISABLED = 0x0
	// An interrupt will be generated when a receive error occurs.
	SPI_FIFOINTENSET_RXERR_ENABLED = 0x1
	// Position of TXLVL field.
	SPI_FIFOINTENSET_TXLVL_Pos = 0x2
	// Bit mask of TXLVL field.
	SPI_FIFOINTENSET_TXLVL_Msk = 0x4
	// Bit TXLVL.
	SPI_FIFOINTENSET_TXLVL = 0x4
	// No interrupt will be generated based on the TX FIFO level.
	SPI_FIFOINTENSET_TXLVL_DISABLED = 0x0
	// If TXLVLENA in the FIFOTRIG register = 1, an interrupt will be generated when the TX FIFO level decreases to the level specified by TXLVL in the FIFOTRIG register.
	SPI_FIFOINTENSET_TXLVL_ENABLED = 0x1
	// Position of RXLVL field.
	SPI_FIFOINTENSET_RXLVL_Pos = 0x3
	// Bit mask of RXLVL field.
	SPI_FIFOINTENSET_RXLVL_Msk = 0x8
	// Bit RXLVL.
	SPI_FIFOINTENSET_RXLVL = 0x8
	// No interrupt will be generated based on the RX FIFO level.
	SPI_FIFOINTENSET_RXLVL_DISABLED = 0x0
	// If RXLVLENA in the FIFOTRIG register = 1, an interrupt will be generated when the when the RX FIFO level increases to the level specified by RXLVL in the FIFOTRIG register.
	SPI_FIFOINTENSET_RXLVL_ENABLED = 0x1

	// FIFOINTENCLR: FIFO interrupt enable clear (disable) and read register.
	// Position of TXERR field.
	SPI_FIFOINTENCLR_TXERR_Pos = 0x0
	// Bit mask of TXERR field.
	SPI_FIFOINTENCLR_TXERR_Msk = 0x1
	// Bit TXERR.
	SPI_FIFOINTENCLR_TXERR = 0x1
	// Position of RXERR field.
	SPI_FIFOINTENCLR_RXERR_Pos = 0x1
	// Bit mask of RXERR field.
	SPI_FIFOINTENCLR_RXERR_Msk = 0x2
	// Bit RXERR.
	SPI_FIFOINTENCLR_RXERR = 0x2
	// Position of TXLVL field.
	SPI_FIFOINTENCLR_TXLVL_Pos = 0x2
	// Bit mask of TXLVL field.
	SPI_FIFOINTENCLR_TXLVL_Msk = 0x4
	// Bit TXLVL.
	SPI_FIFOINTENCLR_TXLVL = 0x4
	// Position of RXLVL field.
	SPI_FIFOINTENCLR_RXLVL_Pos = 0x3
	// Bit mask of RXLVL field.
	SPI_FIFOINTENCLR_RXLVL_Msk = 0x8
	// Bit RXLVL.
	SPI_FIFOINTENCLR_RXLVL = 0x8

	// FIFOINTSTAT: FIFO interrupt status register.
	// Position of TXERR field.
	SPI_FIFOINTSTAT_TXERR_Pos = 0x0
	// Bit mask of TXERR field.
	SPI_FIFOINTSTAT_TXERR_Msk = 0x1
	// Bit TXERR.
	SPI_FIFOINTSTAT_TXERR = 0x1
	// Position of RXERR field.
	SPI_FIFOINTSTAT_RXERR_Pos = 0x1
	// Bit mask of RXERR field.
	SPI_FIFOINTSTAT_RXERR_Msk = 0x2
	// Bit RXERR.
	SPI_FIFOINTSTAT_RXERR = 0x2
	// Position of TXLVL field.
	SPI_FIFOINTSTAT_TXLVL_Pos = 0x2
	// Bit mask of TXLVL field.
	SPI_FIFOINTSTAT_TXLVL_Msk = 0x4
	// Bit TXLVL.
	SPI_FIFOINTSTAT_TXLVL = 0x4
	// Position of RXLVL field.
	SPI_FIFOINTSTAT_RXLVL_Pos = 0x3
	// Bit mask of RXLVL field.
	SPI_FIFOINTSTAT_RXLVL_Msk = 0x8
	// Bit RXLVL.
	SPI_FIFOINTSTAT_RXLVL = 0x8
	// Position of PERINT field.
	SPI_FIFOINTSTAT_PERINT_Pos = 0x4
	// Bit mask of PERINT field.
	SPI_FIFOINTSTAT_PERINT_Msk = 0x10
	// Bit PERINT.
	SPI_FIFOINTSTAT_PERINT = 0x10

	// FIFOWR: FIFO write data.
	// Position of TXDATA field.
	SPI_FIFOWR_TXDATA_Pos = 0x0
	// Bit mask of TXDATA field.
	SPI_FIFOWR_TXDATA_Msk = 0xffff
	// Position of TXSSEL0_N field.
	SPI_FIFOWR_TXSSEL0_N_Pos = 0x10
	// Bit mask of TXSSEL0_N field.
	SPI_FIFOWR_TXSSEL0_N_Msk = 0x10000
	// Bit TXSSEL0_N.
	SPI_FIFOWR_TXSSEL0_N = 0x10000
	// SSEL0 asserted.
	SPI_FIFOWR_TXSSEL0_N_ASSERTED = 0x0
	// SSEL0 not asserted.
	SPI_FIFOWR_TXSSEL0_N_NOT_ASSERTED = 0x1
	// Position of TXSSEL1_N field.
	SPI_FIFOWR_TXSSEL1_N_Pos = 0x11
	// Bit mask of TXSSEL1_N field.
	SPI_FIFOWR_TXSSEL1_N_Msk = 0x20000
	// Bit TXSSEL1_N.
	SPI_FIFOWR_TXSSEL1_N = 0x20000
	// SSEL1 asserted.
	SPI_FIFOWR_TXSSEL1_N_ASSERTED = 0x0
	// SSEL1 not asserted.
	SPI_FIFOWR_TXSSEL1_N_NOT_ASSERTED = 0x1
	// Position of TXSSEL2_N field.
	SPI_FIFOWR_TXSSEL2_N_Pos = 0x12
	// Bit mask of TXSSEL2_N field.
	SPI_FIFOWR_TXSSEL2_N_Msk = 0x40000
	// Bit TXSSEL2_N.
	SPI_FIFOWR_TXSSEL2_N = 0x40000
	// SSEL2 asserted.
	SPI_FIFOWR_TXSSEL2_N_ASSERTED = 0x0
	// SSEL2 not asserted.
	SPI_FIFOWR_TXSSEL2_N_NOT_ASSERTED = 0x1
	// Position of TXSSEL3_N field.
	SPI_FIFOWR_TXSSEL3_N_Pos = 0x13
	// Bit mask of TXSSEL3_N field.
	SPI_FIFOWR_TXSSEL3_N_Msk = 0x80000
	// Bit TXSSEL3_N.
	SPI_FIFOWR_TXSSEL3_N = 0x80000
	// SSEL3 asserted.
	SPI_FIFOWR_TXSSEL3_N_ASSERTED = 0x0
	// SSEL3 not asserted.
	SPI_FIFOWR_TXSSEL3_N_NOT_ASSERTED = 0x1
	// Position of EOT field.
	SPI_FIFOWR_EOT_Pos = 0x14
	// Bit mask of EOT field.
	SPI_FIFOWR_EOT_Msk = 0x100000
	// Bit EOT.
	SPI_FIFOWR_EOT = 0x100000
	// SSEL not deasserted. This piece of data is not treated as the end of a transfer. SSEL will not be deasserted at the end of this data.
	SPI_FIFOWR_EOT_NOT_DEASSERTED = 0x0
	// SSEL deasserted. This piece of data is treated as the end of a transfer. SSEL will be deasserted at the end of this piece of data.
	SPI_FIFOWR_EOT_DEASSERTED = 0x1
	// Position of EOF field.
	SPI_FIFOWR_EOF_Pos = 0x15
	// Bit mask of EOF field.
	SPI_FIFOWR_EOF_Msk = 0x200000
	// Bit EOF.
	SPI_FIFOWR_EOF = 0x200000
	// Data not EOF. This piece of data transmitted is not treated as the end of a frame.
	SPI_FIFOWR_EOF_NOT_EOF = 0x0
	// Data EOF. This piece of data is treated as the end of a frame, causing the FRAME_DELAY time to be inserted before subsequent data is transmitted.
	SPI_FIFOWR_EOF_EOF = 0x1
	// Position of RXIGNORE field.
	SPI_FIFOWR_RXIGNORE_Pos = 0x16
	// Bit mask of RXIGNORE field.
	SPI_FIFOWR_RXIGNORE_Msk = 0x400000
	// Bit RXIGNORE.
	SPI_FIFOWR_RXIGNORE = 0x400000
	// Read received data. Received data must be read in order to allow transmission to progress. In slave mode, an overrun error will occur if received data is not read before new data is received.
	SPI_FIFOWR_RXIGNORE_READ = 0x0
	// Ignore received data. Received data is ignored, allowing transmission without reading unneeded received data. No receiver flags are generated.
	SPI_FIFOWR_RXIGNORE_IGNORE = 0x1
	// Position of LEN field.
	SPI_FIFOWR_LEN_Pos = 0x18
	// Bit mask of LEN field.
	SPI_FIFOWR_LEN_Msk = 0xf000000

	// FIFORD: FIFO read data.
	// Position of RXDATA field.
	SPI_FIFORD_RXDATA_Pos = 0x0
	// Bit mask of RXDATA field.
	SPI_FIFORD_RXDATA_Msk = 0xffff
	// Position of RXSSEL0_N field.
	SPI_FIFORD_RXSSEL0_N_Pos = 0x10
	// Bit mask of RXSSEL0_N field.
	SPI_FIFORD_RXSSEL0_N_Msk = 0x10000
	// Bit RXSSEL0_N.
	SPI_FIFORD_RXSSEL0_N = 0x10000
	// Position of RXSSEL1_N field.
	SPI_FIFORD_RXSSEL1_N_Pos = 0x11
	// Bit mask of RXSSEL1_N field.
	SPI_FIFORD_RXSSEL1_N_Msk = 0x20000
	// Bit RXSSEL1_N.
	SPI_FIFORD_RXSSEL1_N = 0x20000
	// Position of RXSSEL2_N field.
	SPI_FIFORD_RXSSEL2_N_Pos = 0x12
	// Bit mask of RXSSEL2_N field.
	SPI_FIFORD_RXSSEL2_N_Msk = 0x40000
	// Bit RXSSEL2_N.
	SPI_FIFORD_RXSSEL2_N = 0x40000
	// Position of RXSSEL3_N field.
	SPI_FIFORD_RXSSEL3_N_Pos = 0x13
	// Bit mask of RXSSEL3_N field.
	SPI_FIFORD_RXSSEL3_N_Msk = 0x80000
	// Bit RXSSEL3_N.
	SPI_FIFORD_RXSSEL3_N = 0x80000
	// Position of SOT field.
	SPI_FIFORD_SOT_Pos = 0x14
	// Bit mask of SOT field.
	SPI_FIFORD_SOT_Msk = 0x100000
	// Bit SOT.
	SPI_FIFORD_SOT = 0x100000

	// FIFORDNOPOP: FIFO data read with no FIFO pop.
	// Position of RXDATA field.
	SPI_FIFORDNOPOP_RXDATA_Pos = 0x0
	// Bit mask of RXDATA field.
	SPI_FIFORDNOPOP_RXDATA_Msk = 0xffff
	// Position of RXSSEL0_N field.
	SPI_FIFORDNOPOP_RXSSEL0_N_Pos = 0x10
	// Bit mask of RXSSEL0_N field.
	SPI_FIFORDNOPOP_RXSSEL0_N_Msk = 0x10000
	// Bit RXSSEL0_N.
	SPI_FIFORDNOPOP_RXSSEL0_N = 0x10000
	// Position of RXSSEL1_N field.
	SPI_FIFORDNOPOP_RXSSEL1_N_Pos = 0x11
	// Bit mask of RXSSEL1_N field.
	SPI_FIFORDNOPOP_RXSSEL1_N_Msk = 0x20000
	// Bit RXSSEL1_N.
	SPI_FIFORDNOPOP_RXSSEL1_N = 0x20000
	// Position of RXSSEL2_N field.
	SPI_FIFORDNOPOP_RXSSEL2_N_Pos = 0x12
	// Bit mask of RXSSEL2_N field.
	SPI_FIFORDNOPOP_RXSSEL2_N_Msk = 0x40000
	// Bit RXSSEL2_N.
	SPI_FIFORDNOPOP_RXSSEL2_N = 0x40000
	// Position of RXSSEL3_N field.
	SPI_FIFORDNOPOP_RXSSEL3_N_Pos = 0x13
	// Bit mask of RXSSEL3_N field.
	SPI_FIFORDNOPOP_RXSSEL3_N_Msk = 0x80000
	// Bit RXSSEL3_N.
	SPI_FIFORDNOPOP_RXSSEL3_N = 0x80000
	// Position of SOT field.
	SPI_FIFORDNOPOP_SOT_Pos = 0x14
	// Bit mask of SOT field.
	SPI_FIFORDNOPOP_SOT_Msk = 0x100000
	// Bit SOT.
	SPI_FIFORDNOPOP_SOT = 0x100000

	// ID: SPI module Identification. This value appears in the shared Flexcomm peripheral ID register when SPI is selected.
	// Position of APERTURE field.
	SPI_ID_APERTURE_Pos = 0x0
	// Bit mask of APERTURE field.
	SPI_ID_APERTURE_Msk = 0xff
	// Position of MINOR_REV field.
	SPI_ID_MINOR_REV_Pos = 0x8
	// Bit mask of MINOR_REV field.
	SPI_ID_MINOR_REV_Msk = 0xf00
	// Position of MAJOR_REV field.
	SPI_ID_MAJOR_REV_Pos = 0xc
	// Bit mask of MAJOR_REV field.
	SPI_ID_MAJOR_REV_Msk = 0xf000
	// Position of ID field.
	SPI_ID_ID_Pos = 0x10
	// Bit mask of ID field.
	SPI_ID_ID_Msk = 0xffff0000
)

// Constants for FSP: fsp
const (
	// SYS_CTRL: FSP system control register
	// Position of TE_ABORT field.
	FSP_SYS_CTRL_TE_ABORT_Pos = 0x0
	// Bit mask of TE_ABORT field.
	FSP_SYS_CTRL_TE_ABORT_Msk = 0x1
	// Bit TE_ABORT.
	FSP_SYS_CTRL_TE_ABORT = 0x1
	// Position of MOU_ABORT field.
	FSP_SYS_CTRL_MOU_ABORT_Pos = 0x1
	// Bit mask of MOU_ABORT field.
	FSP_SYS_CTRL_MOU_ABORT_Msk = 0x2
	// Bit MOU_ABORT.
	FSP_SYS_CTRL_MOU_ABORT = 0x2
	// Position of SCF_ABORT field.
	FSP_SYS_CTRL_SCF_ABORT_Pos = 0x2
	// Bit mask of SCF_ABORT field.
	FSP_SYS_CTRL_SCF_ABORT_Msk = 0x4
	// Bit SCF_ABORT.
	FSP_SYS_CTRL_SCF_ABORT = 0x4

	// STATUS: FSP status register
	// Position of FPU0_BUSY field.
	FSP_STATUS_FPU0_BUSY_Pos = 0x0
	// Bit mask of FPU0_BUSY field.
	FSP_STATUS_FPU0_BUSY_Msk = 0x1
	// Bit FPU0_BUSY.
	FSP_STATUS_FPU0_BUSY = 0x1
	// Position of FPU1_BUSY field.
	FSP_STATUS_FPU1_BUSY_Pos = 0x1
	// Bit mask of FPU1_BUSY field.
	FSP_STATUS_FPU1_BUSY_Msk = 0x2
	// Bit FPU1_BUSY.
	FSP_STATUS_FPU1_BUSY = 0x2
	// Position of FIR_READY field.
	FSP_STATUS_FIR_READY_Pos = 0x2
	// Bit mask of FIR_READY field.
	FSP_STATUS_FIR_READY_Msk = 0x4
	// Bit FIR_READY.
	FSP_STATUS_FIR_READY = 0x4

	// INT: FSP interrupt register
	// Position of TE_DONE_INT field.
	FSP_INT_TE_DONE_INT_Pos = 0x0
	// Bit mask of TE_DONE_INT field.
	FSP_INT_TE_DONE_INT_Msk = 0x1
	// Bit TE_DONE_INT.
	FSP_INT_TE_DONE_INT = 0x1
	// Position of MOU_DONE_INT field.
	FSP_INT_MOU_DONE_INT_Pos = 0x1
	// Bit mask of MOU_DONE_INT field.
	FSP_INT_MOU_DONE_INT_Msk = 0x2
	// Bit MOU_DONE_INT.
	FSP_INT_MOU_DONE_INT = 0x2
	// Position of SE_DONE_INT field.
	FSP_INT_SE_DONE_INT_Pos = 0x2
	// Bit mask of SE_DONE_INT field.
	FSP_INT_SE_DONE_INT_Msk = 0x4
	// Bit SE_DONE_INT.
	FSP_INT_SE_DONE_INT = 0x4
	// Position of COR_DONE_INT field.
	FSP_INT_COR_DONE_INT_Pos = 0x3
	// Bit mask of COR_DONE_INT field.
	FSP_INT_COR_DONE_INT_Msk = 0x8
	// Bit COR_DONE_INT.
	FSP_INT_COR_DONE_INT = 0x8
	// Position of FPU0_CALC_IN_ERR_INT field.
	FSP_INT_FPU0_CALC_IN_ERR_INT_Pos = 0x8
	// Bit mask of FPU0_CALC_IN_ERR_INT field.
	FSP_INT_FPU0_CALC_IN_ERR_INT_Msk = 0x100
	// Bit FPU0_CALC_IN_ERR_INT.
	FSP_INT_FPU0_CALC_IN_ERR_INT = 0x100
	// Position of FPU0_CALC_OUT_ERR_INT field.
	FSP_INT_FPU0_CALC_OUT_ERR_INT_Pos = 0x9
	// Bit mask of FPU0_CALC_OUT_ERR_INT field.
	FSP_INT_FPU0_CALC_OUT_ERR_INT_Msk = 0x200
	// Bit FPU0_CALC_OUT_ERR_INT.
	FSP_INT_FPU0_CALC_OUT_ERR_INT = 0x200
	// Position of FPU0_DIN_OV_INT field.
	FSP_INT_FPU0_DIN_OV_INT_Pos = 0xa
	// Bit mask of FPU0_DIN_OV_INT field.
	FSP_INT_FPU0_DIN_OV_INT_Msk = 0x400
	// Bit FPU0_DIN_OV_INT.
	FSP_INT_FPU0_DIN_OV_INT = 0x400
	// Position of FPU0_DOUT_OV_INT field.
	FSP_INT_FPU0_DOUT_OV_INT_Pos = 0xb
	// Bit mask of FPU0_DOUT_OV_INT field.
	FSP_INT_FPU0_DOUT_OV_INT_Msk = 0x800
	// Bit FPU0_DOUT_OV_INT.
	FSP_INT_FPU0_DOUT_OV_INT = 0x800
	// Position of SINGULAR_INT field.
	FSP_INT_SINGULAR_INT_Pos = 0xc
	// Bit mask of SINGULAR_INT field.
	FSP_INT_SINGULAR_INT_Msk = 0x1000
	// Bit SINGULAR_INT.
	FSP_INT_SINGULAR_INT = 0x1000
	// Position of FPU1_CALC_IN_ERR_INT field.
	FSP_INT_FPU1_CALC_IN_ERR_INT_Pos = 0x10
	// Bit mask of FPU1_CALC_IN_ERR_INT field.
	FSP_INT_FPU1_CALC_IN_ERR_INT_Msk = 0x10000
	// Bit FPU1_CALC_IN_ERR_INT.
	FSP_INT_FPU1_CALC_IN_ERR_INT = 0x10000
	// Position of FPU1_CALC_OUT_ERR_INT field.
	FSP_INT_FPU1_CALC_OUT_ERR_INT_Pos = 0x11
	// Bit mask of FPU1_CALC_OUT_ERR_INT field.
	FSP_INT_FPU1_CALC_OUT_ERR_INT_Msk = 0x20000
	// Bit FPU1_CALC_OUT_ERR_INT.
	FSP_INT_FPU1_CALC_OUT_ERR_INT = 0x20000
	// Position of FPU1_DIN_OV_INT field.
	FSP_INT_FPU1_DIN_OV_INT_Pos = 0x12
	// Bit mask of FPU1_DIN_OV_INT field.
	FSP_INT_FPU1_DIN_OV_INT_Msk = 0x40000
	// Bit FPU1_DIN_OV_INT.
	FSP_INT_FPU1_DIN_OV_INT = 0x40000
	// Position of FPU1_DOUT_OV_INT field.
	FSP_INT_FPU1_DOUT_OV_INT_Pos = 0x13
	// Bit mask of FPU1_DOUT_OV_INT field.
	FSP_INT_FPU1_DOUT_OV_INT_Msk = 0x80000
	// Bit FPU1_DOUT_OV_INT.
	FSP_INT_FPU1_DOUT_OV_INT = 0x80000
	// Position of FINV_DIN_ERR_INT field.
	FSP_INT_FINV_DIN_ERR_INT_Pos = 0x14
	// Bit mask of FINV_DIN_ERR_INT field.
	FSP_INT_FINV_DIN_ERR_INT_Msk = 0x100000
	// Bit FINV_DIN_ERR_INT.
	FSP_INT_FINV_DIN_ERR_INT = 0x100000
	// Position of FINV_DOUT_OV_INT field.
	FSP_INT_FINV_DOUT_OV_INT_Pos = 0x15
	// Bit mask of FINV_DOUT_OV_INT field.
	FSP_INT_FINV_DOUT_OV_INT_Msk = 0x200000
	// Bit FINV_DOUT_OV_INT.
	FSP_INT_FINV_DOUT_OV_INT = 0x200000
	// Position of FINV_ZERO_INT field.
	FSP_INT_FINV_ZERO_INT_Pos = 0x16
	// Bit mask of FINV_ZERO_INT field.
	FSP_INT_FINV_ZERO_INT_Msk = 0x400000
	// Bit FINV_ZERO_INT.
	FSP_INT_FINV_ZERO_INT = 0x400000
	// Position of CORDIC_DIN_ERR field.
	FSP_INT_CORDIC_DIN_ERR_Pos = 0x18
	// Bit mask of CORDIC_DIN_ERR field.
	FSP_INT_CORDIC_DIN_ERR_Msk = 0x1000000
	// Bit CORDIC_DIN_ERR.
	FSP_INT_CORDIC_DIN_ERR = 0x1000000
	// Position of CORDIC_DOUT_ERR_INT field.
	FSP_INT_CORDIC_DOUT_ERR_INT_Pos = 0x19
	// Bit mask of CORDIC_DOUT_ERR_INT field.
	FSP_INT_CORDIC_DOUT_ERR_INT_Msk = 0x2000000
	// Bit CORDIC_DOUT_ERR_INT.
	FSP_INT_CORDIC_DOUT_ERR_INT = 0x2000000
	// Position of CORDIC_CALC_ERR_INT field.
	FSP_INT_CORDIC_CALC_ERR_INT_Pos = 0x1a
	// Bit mask of CORDIC_CALC_ERR_INT field.
	FSP_INT_CORDIC_CALC_ERR_INT_Msk = 0x4000000
	// Bit CORDIC_CALC_ERR_INT.
	FSP_INT_CORDIC_CALC_ERR_INT = 0x4000000
	// Position of FSP_INT field.
	FSP_INT_FSP_INT_Pos = 0x1f
	// Bit mask of FSP_INT field.
	FSP_INT_FSP_INT_Msk = 0x80000000
	// Bit FSP_INT.
	FSP_INT_FSP_INT = 0x80000000

	// INTEN: FSP interrupt enable register
	// Position of TE_DONE_INTEN field.
	FSP_INTEN_TE_DONE_INTEN_Pos = 0x0
	// Bit mask of TE_DONE_INTEN field.
	FSP_INTEN_TE_DONE_INTEN_Msk = 0x1
	// Bit TE_DONE_INTEN.
	FSP_INTEN_TE_DONE_INTEN = 0x1
	// Position of MOU_DONE_INTEN field.
	FSP_INTEN_MOU_DONE_INTEN_Pos = 0x1
	// Bit mask of MOU_DONE_INTEN field.
	FSP_INTEN_MOU_DONE_INTEN_Msk = 0x2
	// Bit MOU_DONE_INTEN.
	FSP_INTEN_MOU_DONE_INTEN = 0x2
	// Position of SE_DONE_INTEN field.
	FSP_INTEN_SE_DONE_INTEN_Pos = 0x2
	// Bit mask of SE_DONE_INTEN field.
	FSP_INTEN_SE_DONE_INTEN_Msk = 0x4
	// Bit SE_DONE_INTEN.
	FSP_INTEN_SE_DONE_INTEN = 0x4
	// Position of COR_DONE_INTEN field.
	FSP_INTEN_COR_DONE_INTEN_Pos = 0x3
	// Bit mask of COR_DONE_INTEN field.
	FSP_INTEN_COR_DONE_INTEN_Msk = 0x8
	// Bit COR_DONE_INTEN.
	FSP_INTEN_COR_DONE_INTEN = 0x8
	// Position of FPU0_CALC_IN_ERR_INTEN field.
	FSP_INTEN_FPU0_CALC_IN_ERR_INTEN_Pos = 0x8
	// Bit mask of FPU0_CALC_IN_ERR_INTEN field.
	FSP_INTEN_FPU0_CALC_IN_ERR_INTEN_Msk = 0x100
	// Bit FPU0_CALC_IN_ERR_INTEN.
	FSP_INTEN_FPU0_CALC_IN_ERR_INTEN = 0x100
	// Position of FPU0_CALC_OUT_ERR_INTEN field.
	FSP_INTEN_FPU0_CALC_OUT_ERR_INTEN_Pos = 0x9
	// Bit mask of FPU0_CALC_OUT_ERR_INTEN field.
	FSP_INTEN_FPU0_CALC_OUT_ERR_INTEN_Msk = 0x200
	// Bit FPU0_CALC_OUT_ERR_INTEN.
	FSP_INTEN_FPU0_CALC_OUT_ERR_INTEN = 0x200
	// Position of FPU0_DIN_OV_INTEN field.
	FSP_INTEN_FPU0_DIN_OV_INTEN_Pos = 0xa
	// Bit mask of FPU0_DIN_OV_INTEN field.
	FSP_INTEN_FPU0_DIN_OV_INTEN_Msk = 0x400
	// Bit FPU0_DIN_OV_INTEN.
	FSP_INTEN_FPU0_DIN_OV_INTEN = 0x400
	// Position of FPU0_DOUT_OV_INTEN field.
	FSP_INTEN_FPU0_DOUT_OV_INTEN_Pos = 0xb
	// Bit mask of FPU0_DOUT_OV_INTEN field.
	FSP_INTEN_FPU0_DOUT_OV_INTEN_Msk = 0x800
	// Bit FPU0_DOUT_OV_INTEN.
	FSP_INTEN_FPU0_DOUT_OV_INTEN = 0x800
	// Position of SINGULAR_INTEN field.
	FSP_INTEN_SINGULAR_INTEN_Pos = 0xc
	// Bit mask of SINGULAR_INTEN field.
	FSP_INTEN_SINGULAR_INTEN_Msk = 0x1000
	// Bit SINGULAR_INTEN.
	FSP_INTEN_SINGULAR_INTEN = 0x1000
	// Position of FPU1_CALC_IN_ERR_INTEN field.
	FSP_INTEN_FPU1_CALC_IN_ERR_INTEN_Pos = 0x10
	// Bit mask of FPU1_CALC_IN_ERR_INTEN field.
	FSP_INTEN_FPU1_CALC_IN_ERR_INTEN_Msk = 0x10000
	// Bit FPU1_CALC_IN_ERR_INTEN.
	FSP_INTEN_FPU1_CALC_IN_ERR_INTEN = 0x10000
	// Position of FPU1_CALC_OUT_ERR_INTEN field.
	FSP_INTEN_FPU1_CALC_OUT_ERR_INTEN_Pos = 0x11
	// Bit mask of FPU1_CALC_OUT_ERR_INTEN field.
	FSP_INTEN_FPU1_CALC_OUT_ERR_INTEN_Msk = 0x20000
	// Bit FPU1_CALC_OUT_ERR_INTEN.
	FSP_INTEN_FPU1_CALC_OUT_ERR_INTEN = 0x20000
	// Position of FPU1_DIN_OV_INTEN field.
	FSP_INTEN_FPU1_DIN_OV_INTEN_Pos = 0x12
	// Bit mask of FPU1_DIN_OV_INTEN field.
	FSP_INTEN_FPU1_DIN_OV_INTEN_Msk = 0x40000
	// Bit FPU1_DIN_OV_INTEN.
	FSP_INTEN_FPU1_DIN_OV_INTEN = 0x40000
	// Position of FPU1_DOUT_OV_INTEN field.
	FSP_INTEN_FPU1_DOUT_OV_INTEN_Pos = 0x13
	// Bit mask of FPU1_DOUT_OV_INTEN field.
	FSP_INTEN_FPU1_DOUT_OV_INTEN_Msk = 0x80000
	// Bit FPU1_DOUT_OV_INTEN.
	FSP_INTEN_FPU1_DOUT_OV_INTEN = 0x80000
	// Position of FINV_DIN_ERR_INTEN field.
	FSP_INTEN_FINV_DIN_ERR_INTEN_Pos = 0x14
	// Bit mask of FINV_DIN_ERR_INTEN field.
	FSP_INTEN_FINV_DIN_ERR_INTEN_Msk = 0x100000
	// Bit FINV_DIN_ERR_INTEN.
	FSP_INTEN_FINV_DIN_ERR_INTEN = 0x100000
	// Position of FINV_DOUT_OV_INTEN field.
	FSP_INTEN_FINV_DOUT_OV_INTEN_Pos = 0x15
	// Bit mask of FINV_DOUT_OV_INTEN field.
	FSP_INTEN_FINV_DOUT_OV_INTEN_Msk = 0x200000
	// Bit FINV_DOUT_OV_INTEN.
	FSP_INTEN_FINV_DOUT_OV_INTEN = 0x200000
	// Position of FINV_ZERO_INTEN field.
	FSP_INTEN_FINV_ZERO_INTEN_Pos = 0x16
	// Bit mask of FINV_ZERO_INTEN field.
	FSP_INTEN_FINV_ZERO_INTEN_Msk = 0x400000
	// Bit FINV_ZERO_INTEN.
	FSP_INTEN_FINV_ZERO_INTEN = 0x400000
	// Position of CORDIC_DIN_ERR_INTEN field.
	FSP_INTEN_CORDIC_DIN_ERR_INTEN_Pos = 0x18
	// Bit mask of CORDIC_DIN_ERR_INTEN field.
	FSP_INTEN_CORDIC_DIN_ERR_INTEN_Msk = 0x1000000
	// Bit CORDIC_DIN_ERR_INTEN.
	FSP_INTEN_CORDIC_DIN_ERR_INTEN = 0x1000000
	// Position of CORDIC_DOUT_ERR_INTEN field.
	FSP_INTEN_CORDIC_DOUT_ERR_INTEN_Pos = 0x19
	// Bit mask of CORDIC_DOUT_ERR_INTEN field.
	FSP_INTEN_CORDIC_DOUT_ERR_INTEN_Msk = 0x2000000
	// Bit CORDIC_DOUT_ERR_INTEN.
	FSP_INTEN_CORDIC_DOUT_ERR_INTEN = 0x2000000
	// Position of CORDIC_CALC_ERR_INTEN field.
	FSP_INTEN_CORDIC_CALC_ERR_INTEN_Pos = 0x1a
	// Bit mask of CORDIC_CALC_ERR_INTEN field.
	FSP_INTEN_CORDIC_CALC_ERR_INTEN_Msk = 0x4000000
	// Bit CORDIC_CALC_ERR_INTEN.
	FSP_INTEN_CORDIC_CALC_ERR_INTEN = 0x4000000
	// Position of FSP_INTEN field.
	FSP_INTEN_FSP_INTEN_Pos = 0x1f
	// Bit mask of FSP_INTEN field.
	FSP_INTEN_FSP_INTEN_Msk = 0x80000000
	// Bit FSP_INTEN.
	FSP_INTEN_FSP_INTEN = 0x80000000

	// TE_CTRL: transmit engine control register
	// Position of TE_MODE field.
	FSP_TE_CTRL_TE_MODE_Pos = 0x0
	// Bit mask of TE_MODE field.
	FSP_TE_CTRL_TE_MODE_Msk = 0x3
	// FFT
	FSP_TE_CTRL_TE_MODE_TE_FFT = 0x0
	// IFFT
	FSP_TE_CTRL_TE_MODE_TE_IFFT = 0x1
	// DCT
	FSP_TE_CTRL_TE_MODE_TE_DCT = 0x2
	// IDCT
	FSP_TE_CTRL_TE_MODE_TE_IDCT = 0x3
	// Position of TE_IO_MODE field.
	FSP_TE_CTRL_TE_IO_MODE_Pos = 0x2
	// Bit mask of TE_IO_MODE field.
	FSP_TE_CTRL_TE_IO_MODE_Msk = 0xc
	// real input, complex output
	FSP_TE_CTRL_TE_IO_MODE_TE_RICO = 0x0
	// complex input, complex output
	FSP_TE_CTRL_TE_IO_MODE_TE_CICO = 0x1
	// real input, real output
	FSP_TE_CTRL_TE_IO_MODE_TE_RIRO = 0x2
	// Position of TE_PTS field.
	FSP_TE_CTRL_TE_PTS_Pos = 0x4
	// Bit mask of TE_PTS field.
	FSP_TE_CTRL_TE_PTS_Msk = 0x30
	// 64 points
	FSP_TE_CTRL_TE_PTS_TE64PTS = 0x0
	// 128 points
	FSP_TE_CTRL_TE_PTS_TE128PTS = 0x1
	// 256 points
	FSP_TE_CTRL_TE_PTS_TE256PTS = 0x2
	// Position of TE_DIN_FP_SEL field.
	FSP_TE_CTRL_TE_DIN_FP_SEL_Pos = 0x6
	// Bit mask of TE_DIN_FP_SEL field.
	FSP_TE_CTRL_TE_DIN_FP_SEL_Msk = 0x40
	// Bit TE_DIN_FP_SEL.
	FSP_TE_CTRL_TE_DIN_FP_SEL = 0x40
	// fix
	FSP_TE_CTRL_TE_DIN_FP_SEL_FIX = 0x0
	// float
	FSP_TE_CTRL_TE_DIN_FP_SEL_FLT = 0x1
	// Position of TE_DOUT_FP_SEL field.
	FSP_TE_CTRL_TE_DOUT_FP_SEL_Pos = 0x7
	// Bit mask of TE_DOUT_FP_SEL field.
	FSP_TE_CTRL_TE_DOUT_FP_SEL_Msk = 0x80
	// Bit TE_DOUT_FP_SEL.
	FSP_TE_CTRL_TE_DOUT_FP_SEL = 0x80
	// fix
	FSP_TE_CTRL_TE_DOUT_FP_SEL_FIX = 0x0
	// float
	FSP_TE_CTRL_TE_DOUT_FP_SEL_FLT = 0x1
	// Position of TE_SCALE field.
	FSP_TE_CTRL_TE_SCALE_Pos = 0x8
	// Bit mask of TE_SCALE field.
	FSP_TE_CTRL_TE_SCALE_Msk = 0xff00
	// Position of TE_PAUSE_LVL field.
	FSP_TE_CTRL_TE_PAUSE_LVL_Pos = 0x18
	// Bit mask of TE_PAUSE_LVL field.
	FSP_TE_CTRL_TE_PAUSE_LVL_Msk = 0x7000000

	// TE_SRC_BASE: transfer engine source data memory base register
	// Position of TE_SRC_BASE field.
	FSP_TE_SRC_BASE_TE_SRC_BASE_Pos = 0x0
	// Bit mask of TE_SRC_BASE field.
	FSP_TE_SRC_BASE_TE_SRC_BASE_Msk = 0x1ffff

	// TE_DST_BASE: transfer engine destination data memory base register
	// Position of TE_DST_BASE field.
	FSP_TE_DST_BASE_TE_DST_BASE_Pos = 0x0
	// Bit mask of TE_DST_BASE field.
	FSP_TE_DST_BASE_TE_DST_BASE_Msk = 0x1ffff

	// MOU_CTRL: matrix operation unit control register
	// Position of OP_MODE field.
	FSP_MOU_CTRL_OP_MODE_Pos = 0x0
	// Bit mask of OP_MODE field.
	FSP_MOU_CTRL_OP_MODE_Msk = 0xf
	// inversion
	FSP_MOU_CTRL_OP_MODE_INV = 0x0
	// matrix multiply
	FSP_MOU_CTRL_OP_MODE_MULT = 0x1
	// transposition
	FSP_MOU_CTRL_OP_MODE_TRANS = 0x2
	// linear operation
	FSP_MOU_CTRL_OP_MODE_LINEAR = 0x3
	// dot multiply
	FSP_MOU_CTRL_OP_MODE_DOTMULT = 0x4
	// Position of MOU_DIN_FP_SEL field.
	FSP_MOU_CTRL_MOU_DIN_FP_SEL_Pos = 0x8
	// Bit mask of MOU_DIN_FP_SEL field.
	FSP_MOU_CTRL_MOU_DIN_FP_SEL_Msk = 0x100
	// Bit MOU_DIN_FP_SEL.
	FSP_MOU_CTRL_MOU_DIN_FP_SEL = 0x100
	// float
	FSP_MOU_CTRL_MOU_DIN_FP_SEL_MOU_FLT = 0x0
	// fix
	FSP_MOU_CTRL_MOU_DIN_FP_SEL_MOU_FIX = 0x1
	// Position of MOU_DOUT_FP_SEL field.
	FSP_MOU_CTRL_MOU_DOUT_FP_SEL_Pos = 0x9
	// Bit mask of MOU_DOUT_FP_SEL field.
	FSP_MOU_CTRL_MOU_DOUT_FP_SEL_Msk = 0x200
	// Bit MOU_DOUT_FP_SEL.
	FSP_MOU_CTRL_MOU_DOUT_FP_SEL = 0x200
	// float
	FSP_MOU_CTRL_MOU_DOUT_FP_SEL_MOU_FLT = 0x0
	// fix
	FSP_MOU_CTRL_MOU_DOUT_FP_SEL_MOU_FIX = 0x1
	// Position of MAT_M field.
	FSP_MOU_CTRL_MAT_M_Pos = 0x10
	// Bit mask of MAT_M field.
	FSP_MOU_CTRL_MAT_M_Msk = 0xf0000
	// Position of MAT_N field.
	FSP_MOU_CTRL_MAT_N_Pos = 0x14
	// Bit mask of MAT_N field.
	FSP_MOU_CTRL_MAT_N_Msk = 0xf00000
	// Position of MAT_K field.
	FSP_MOU_CTRL_MAT_K_Pos = 0x18
	// Bit mask of MAT_K field.
	FSP_MOU_CTRL_MAT_K_Msk = 0xf000000
	// Position of DIV_EPSILON field.
	FSP_MOU_CTRL_DIV_EPSILON_Pos = 0x1c
	// Bit mask of DIV_EPSILON field.
	FSP_MOU_CTRL_DIV_EPSILON_Msk = 0x30000000
	// Position of LU_STOP field.
	FSP_MOU_CTRL_LU_STOP_Pos = 0x1e
	// Bit mask of LU_STOP field.
	FSP_MOU_CTRL_LU_STOP_Msk = 0x40000000
	// Bit LU_STOP.
	FSP_MOU_CTRL_LU_STOP = 0x40000000
	// Position of UINV_STOP field.
	FSP_MOU_CTRL_UINV_STOP_Pos = 0x1f
	// Bit mask of UINV_STOP field.
	FSP_MOU_CTRL_UINV_STOP_Msk = 0x80000000
	// Bit UINV_STOP.
	FSP_MOU_CTRL_UINV_STOP = 0x80000000

	// MA_SRC_BASE: matrix A source data memory base register
	// Position of MA_SRC_BASE field.
	FSP_MA_SRC_BASE_MA_SRC_BASE_Pos = 0x0
	// Bit mask of MA_SRC_BASE field.
	FSP_MA_SRC_BASE_MA_SRC_BASE_Msk = 0x1ffff

	// MB_SRC_BASE: matrix B source data memory base register
	// Position of MB_SRC_BASE field.
	FSP_MB_SRC_BASE_MB_SRC_BASE_Pos = 0x0
	// Bit mask of MB_SRC_BASE field.
	FSP_MB_SRC_BASE_MB_SRC_BASE_Msk = 0x1ffff

	// MO_DST_BASE: matrix output data memory base register
	// Position of MO_DST_BASE field.
	FSP_MO_DST_BASE_MO_DST_BASE_Pos = 0x0
	// Bit mask of MO_DST_BASE field.
	FSP_MO_DST_BASE_MO_DST_BASE_Msk = 0x1ffff

	// MOU_SCALEA: scale coefficient A register
	// Position of MOU_SCALEA field.
	FSP_MOU_SCALEA_MOU_SCALEA_Pos = 0x0
	// Bit mask of MOU_SCALEA field.
	FSP_MOU_SCALEA_MOU_SCALEA_Msk = 0xffffffff

	// MOU_SCALEB: scale coefficient B register
	// Position of MOU_SCALEB field.
	FSP_MOU_SCALEB_MOU_SCALEB_Pos = 0x0
	// Bit mask of MOU_SCALEB field.
	FSP_MOU_SCALEB_MOU_SCALEB_Msk = 0xffffffff

	// SE_CTRL: stastic engine control register
	// Position of MIN_SEL field.
	FSP_SE_CTRL_MIN_SEL_Pos = 0x0
	// Bit mask of MIN_SEL field.
	FSP_SE_CTRL_MIN_SEL_Msk = 0x1
	// Bit MIN_SEL.
	FSP_SE_CTRL_MIN_SEL = 0x1
	// first one
	FSP_SE_CTRL_MIN_SEL_FIRST_ONE = 0x0
	// last one
	FSP_SE_CTRL_MIN_SEL_LAST_ONE = 0x1
	// Position of MAX_SEL field.
	FSP_SE_CTRL_MAX_SEL_Pos = 0x1
	// Bit mask of MAX_SEL field.
	FSP_SE_CTRL_MAX_SEL_Msk = 0x2
	// Bit MAX_SEL.
	FSP_SE_CTRL_MAX_SEL = 0x2
	// Position of MIN_IDX_EN field.
	FSP_SE_CTRL_MIN_IDX_EN_Pos = 0x2
	// Bit mask of MIN_IDX_EN field.
	FSP_SE_CTRL_MIN_IDX_EN_Msk = 0x4
	// Bit MIN_IDX_EN.
	FSP_SE_CTRL_MIN_IDX_EN = 0x4
	// Position of MAX_IDX_EN field.
	FSP_SE_CTRL_MAX_IDX_EN_Pos = 0x3
	// Bit mask of MAX_IDX_EN field.
	FSP_SE_CTRL_MAX_IDX_EN_Msk = 0x8
	// Bit MAX_IDX_EN.
	FSP_SE_CTRL_MAX_IDX_EN = 0x8
	// Position of SUM_EN field.
	FSP_SE_CTRL_SUM_EN_Pos = 0x4
	// Bit mask of SUM_EN field.
	FSP_SE_CTRL_SUM_EN_Msk = 0x10
	// Bit SUM_EN.
	FSP_SE_CTRL_SUM_EN = 0x10
	// Position of PWR_EN field.
	FSP_SE_CTRL_PWR_EN_Pos = 0x5
	// Bit mask of PWR_EN field.
	FSP_SE_CTRL_PWR_EN_Msk = 0x20
	// Bit PWR_EN.
	FSP_SE_CTRL_PWR_EN = 0x20
	// Position of SE_DIN_FP_SEL field.
	FSP_SE_CTRL_SE_DIN_FP_SEL_Pos = 0x6
	// Bit mask of SE_DIN_FP_SEL field.
	FSP_SE_CTRL_SE_DIN_FP_SEL_Msk = 0x40
	// Bit SE_DIN_FP_SEL.
	FSP_SE_CTRL_SE_DIN_FP_SEL = 0x40
	// float
	FSP_SE_CTRL_SE_DIN_FP_SEL_SE_FLT = 0x0
	// fix
	FSP_SE_CTRL_SE_DIN_FP_SEL_SE_FIX = 0x1
	// Position of SE_DOUT_FP_SEL field.
	FSP_SE_CTRL_SE_DOUT_FP_SEL_Pos = 0x7
	// Bit mask of SE_DOUT_FP_SEL field.
	FSP_SE_CTRL_SE_DOUT_FP_SEL_Msk = 0x80
	// Bit SE_DOUT_FP_SEL.
	FSP_SE_CTRL_SE_DOUT_FP_SEL = 0x80
	// Position of SE_LEN field.
	FSP_SE_CTRL_SE_LEN_Pos = 0x10
	// Bit mask of SE_LEN field.
	FSP_SE_CTRL_SE_LEN_Msk = 0xff0000

	// SE_SRC_BASE: statistic engine source data base register
	// Position of SE_SRC_BASE field.
	FSP_SE_SRC_BASE_SE_SRC_BASE_Pos = 0x0
	// Bit mask of SE_SRC_BASE field.
	FSP_SE_SRC_BASE_SE_SRC_BASE_Msk = 0x1ffff

	// SE_IDX: max or min data index register
	// Position of SE_MIN_IDX field.
	FSP_SE_IDX_SE_MIN_IDX_Pos = 0x0
	// Bit mask of SE_MIN_IDX field.
	FSP_SE_IDX_SE_MIN_IDX_Msk = 0xff
	// Position of SE_MAX_IDX field.
	FSP_SE_IDX_SE_MAX_IDX_Pos = 0x10
	// Bit mask of SE_MAX_IDX field.
	FSP_SE_IDX_SE_MAX_IDX_Msk = 0xff0000

	// SE_SUM: array summary result register
	// Position of SE_SUM field.
	FSP_SE_SUM_SE_SUM_Pos = 0x0
	// Bit mask of SE_SUM field.
	FSP_SE_SUM_SE_SUM_Msk = 0xffffffff

	// SE_PWR: array power result register
	// Position of SE_PWR field.
	FSP_SE_PWR_SE_PWR_Pos = 0x0
	// Bit mask of SE_PWR field.
	FSP_SE_PWR_SE_PWR_Msk = 0xffffffff

	// COR_CTRL: correlation control register
	// Position of COR_DIN_FP_SEL field.
	FSP_COR_CTRL_COR_DIN_FP_SEL_Pos = 0x8
	// Bit mask of COR_DIN_FP_SEL field.
	FSP_COR_CTRL_COR_DIN_FP_SEL_Msk = 0x100
	// Bit COR_DIN_FP_SEL.
	FSP_COR_CTRL_COR_DIN_FP_SEL = 0x100
	// float
	FSP_COR_CTRL_COR_DIN_FP_SEL_COR_FLT = 0x0
	// fix
	FSP_COR_CTRL_COR_DIN_FP_SEL_COR_FIX = 0x1
	// Position of COR_DOUT_FP_SEL field.
	FSP_COR_CTRL_COR_DOUT_FP_SEL_Pos = 0x9
	// Bit mask of COR_DOUT_FP_SEL field.
	FSP_COR_CTRL_COR_DOUT_FP_SEL_Msk = 0x200
	// Bit COR_DOUT_FP_SEL.
	FSP_COR_CTRL_COR_DOUT_FP_SEL = 0x200
	// Position of COR_X_LEN field.
	FSP_COR_CTRL_COR_X_LEN_Pos = 0x10
	// Bit mask of COR_X_LEN field.
	FSP_COR_CTRL_COR_X_LEN_Msk = 0xff0000
	// Position of COR_Y_LEN field.
	FSP_COR_CTRL_COR_Y_LEN_Pos = 0x18
	// Bit mask of COR_Y_LEN field.
	FSP_COR_CTRL_COR_Y_LEN_Msk = 0xff000000

	// CX_SRC_BASE: correlation x sequence base register
	// Position of COR_X_ADDR field.
	FSP_CX_SRC_BASE_COR_X_ADDR_Pos = 0x0
	// Bit mask of COR_X_ADDR field.
	FSP_CX_SRC_BASE_COR_X_ADDR_Msk = 0x1ffff

	// CY_SRC_BASE: correlation y sequence base register
	// Position of COR_Y_ADDR field.
	FSP_CY_SRC_BASE_COR_Y_ADDR_Pos = 0x0
	// Bit mask of COR_Y_ADDR field.
	FSP_CY_SRC_BASE_COR_Y_ADDR_Msk = 0x1ffff

	// CO_DST_BASE: correlation output sequence base register
	// Position of COR_DST_BASE field.
	FSP_CO_DST_BASE_COR_DST_BASE_Pos = 0x0
	// Bit mask of COR_DST_BASE field.
	FSP_CO_DST_BASE_COR_DST_BASE_Msk = 0x1ffff

	// COR_OFFSET: correlation offset register
	// Position of COR_X_OFFSET field.
	FSP_COR_OFFSET_COR_X_OFFSET_Pos = 0x0
	// Bit mask of COR_X_OFFSET field.
	FSP_COR_OFFSET_COR_X_OFFSET_Msk = 0xff
	// Position of COR_Y_OFFSET field.
	FSP_COR_OFFSET_COR_Y_OFFSET_Pos = 0x8
	// Bit mask of COR_Y_OFFSET field.
	FSP_COR_OFFSET_COR_Y_OFFSET_Msk = 0xff00

	// FIR_CFG_CH0: FIR channel 0 configuration register
	// Position of FIR_CH0_COEF_BASE field.
	FSP_FIR_CFG_CH0_FIR_CH0_COEF_BASE_Pos = 0x0
	// Bit mask of FIR_CH0_COEF_BASE field.
	FSP_FIR_CFG_CH0_FIR_CH0_COEF_BASE_Msk = 0xffff
	// Position of FIR_CH0_TAP_LEN field.
	FSP_FIR_CFG_CH0_FIR_CH0_TAP_LEN_Pos = 0x10
	// Bit mask of FIR_CH0_TAP_LEN field.
	FSP_FIR_CFG_CH0_FIR_CH0_TAP_LEN_Msk = 0xf0000
	// Position of FIR_BUF_CLR_ALL field.
	FSP_FIR_CFG_CH0_FIR_BUF_CLR_ALL_Pos = 0x1e
	// Bit mask of FIR_BUF_CLR_ALL field.
	FSP_FIR_CFG_CH0_FIR_BUF_CLR_ALL_Msk = 0x40000000
	// Bit FIR_BUF_CLR_ALL.
	FSP_FIR_CFG_CH0_FIR_BUF_CLR_ALL = 0x40000000
	// Position of FIR_CH0_BUF_CLR field.
	FSP_FIR_CFG_CH0_FIR_CH0_BUF_CLR_Pos = 0x1f
	// Bit mask of FIR_CH0_BUF_CLR field.
	FSP_FIR_CFG_CH0_FIR_CH0_BUF_CLR_Msk = 0x80000000
	// Bit FIR_CH0_BUF_CLR.
	FSP_FIR_CFG_CH0_FIR_CH0_BUF_CLR = 0x80000000

	// FIR_CFG_CH1: FIR channel 1 configuration register
	// Position of FIR_CH1_COEF_BASE field.
	FSP_FIR_CFG_CH1_FIR_CH1_COEF_BASE_Pos = 0x0
	// Bit mask of FIR_CH1_COEF_BASE field.
	FSP_FIR_CFG_CH1_FIR_CH1_COEF_BASE_Msk = 0xffff
	// Position of FIR_CH1_TAP_LEN field.
	FSP_FIR_CFG_CH1_FIR_CH1_TAP_LEN_Pos = 0x10
	// Bit mask of FIR_CH1_TAP_LEN field.
	FSP_FIR_CFG_CH1_FIR_CH1_TAP_LEN_Msk = 0xf0000
	// Position of FIR_CH1_BUF_CLR field.
	FSP_FIR_CFG_CH1_FIR_CH1_BUF_CLR_Pos = 0x1f
	// Bit mask of FIR_CH1_BUF_CLR field.
	FSP_FIR_CFG_CH1_FIR_CH1_BUF_CLR_Msk = 0x80000000
	// Bit FIR_CH1_BUF_CLR.
	FSP_FIR_CFG_CH1_FIR_CH1_BUF_CLR = 0x80000000

	// FIR_CFG_CH2: FIR channel 2 configuration register
	// Position of FIR_CH2_COEF_BASE field.
	FSP_FIR_CFG_CH2_FIR_CH2_COEF_BASE_Pos = 0x0
	// Bit mask of FIR_CH2_COEF_BASE field.
	FSP_FIR_CFG_CH2_FIR_CH2_COEF_BASE_Msk = 0xffff
	// Position of FIR_CH2_TAP_LEN field.
	FSP_FIR_CFG_CH2_FIR_CH2_TAP_LEN_Pos = 0x10
	// Bit mask of FIR_CH2_TAP_LEN field.
	FSP_FIR_CFG_CH2_FIR_CH2_TAP_LEN_Msk = 0xf0000
	// Position of FIR_CH2_BUF_CLR field.
	FSP_FIR_CFG_CH2_FIR_CH2_BUF_CLR_Pos = 0x1f
	// Bit mask of FIR_CH2_BUF_CLR field.
	FSP_FIR_CFG_CH2_FIR_CH2_BUF_CLR_Msk = 0x80000000
	// Bit FIR_CH2_BUF_CLR.
	FSP_FIR_CFG_CH2_FIR_CH2_BUF_CLR = 0x80000000

	// FIR_CFG_CH3: FIR channel 3 configuration register
	// Position of FIR_CH3_COEF_BASE field.
	FSP_FIR_CFG_CH3_FIR_CH3_COEF_BASE_Pos = 0x0
	// Bit mask of FIR_CH3_COEF_BASE field.
	FSP_FIR_CFG_CH3_FIR_CH3_COEF_BASE_Msk = 0xffff
	// Position of FIR_CH3_TAP_LEN field.
	FSP_FIR_CFG_CH3_FIR_CH3_TAP_LEN_Pos = 0x10
	// Bit mask of FIR_CH3_TAP_LEN field.
	FSP_FIR_CFG_CH3_FIR_CH3_TAP_LEN_Msk = 0xf0000
	// Position of FIR_CH3_BUF_CLR field.
	FSP_FIR_CFG_CH3_FIR_CH3_BUF_CLR_Pos = 0x1f
	// Bit mask of FIR_CH3_BUF_CLR field.
	FSP_FIR_CFG_CH3_FIR_CH3_BUF_CLR_Msk = 0x80000000
	// Bit FIR_CH3_BUF_CLR.
	FSP_FIR_CFG_CH3_FIR_CH3_BUF_CLR = 0x80000000

	// FIR_CFG_CH4: FIR channel 4 configuration register
	// Position of FIR_CH4_COEF_BASE field.
	FSP_FIR_CFG_CH4_FIR_CH4_COEF_BASE_Pos = 0x0
	// Bit mask of FIR_CH4_COEF_BASE field.
	FSP_FIR_CFG_CH4_FIR_CH4_COEF_BASE_Msk = 0xffff
	// Position of FIR_CH4_TAP_LEN field.
	FSP_FIR_CFG_CH4_FIR_CH4_TAP_LEN_Pos = 0x10
	// Bit mask of FIR_CH4_TAP_LEN field.
	FSP_FIR_CFG_CH4_FIR_CH4_TAP_LEN_Msk = 0xf0000
	// Position of FIR_CH4_BUF_CLR field.
	FSP_FIR_CFG_CH4_FIR_CH4_BUF_CLR_Pos = 0x1f
	// Bit mask of FIR_CH4_BUF_CLR field.
	FSP_FIR_CFG_CH4_FIR_CH4_BUF_CLR_Msk = 0x80000000
	// Bit FIR_CH4_BUF_CLR.
	FSP_FIR_CFG_CH4_FIR_CH4_BUF_CLR = 0x80000000

	// FIR_CFG_CH5: FIR channel 5 configuration register
	// Position of FIR_CH5_COEF_BASE field.
	FSP_FIR_CFG_CH5_FIR_CH5_COEF_BASE_Pos = 0x0
	// Bit mask of FIR_CH5_COEF_BASE field.
	FSP_FIR_CFG_CH5_FIR_CH5_COEF_BASE_Msk = 0xffff
	// Position of FIR_CH5_TAP_LEN field.
	FSP_FIR_CFG_CH5_FIR_CH5_TAP_LEN_Pos = 0x10
	// Bit mask of FIR_CH5_TAP_LEN field.
	FSP_FIR_CFG_CH5_FIR_CH5_TAP_LEN_Msk = 0xf0000
	// Position of FIR_CH5_BUF_CLR field.
	FSP_FIR_CFG_CH5_FIR_CH5_BUF_CLR_Pos = 0x1f
	// Bit mask of FIR_CH5_BUF_CLR field.
	FSP_FIR_CFG_CH5_FIR_CH5_BUF_CLR_Msk = 0x80000000
	// Bit FIR_CH5_BUF_CLR.
	FSP_FIR_CFG_CH5_FIR_CH5_BUF_CLR = 0x80000000

	// FIR_CFG_CH6: FIR channel 6 configuration register
	// Position of FIR_CH6_COEF_BASE field.
	FSP_FIR_CFG_CH6_FIR_CH6_COEF_BASE_Pos = 0x0
	// Bit mask of FIR_CH6_COEF_BASE field.
	FSP_FIR_CFG_CH6_FIR_CH6_COEF_BASE_Msk = 0xffff
	// Position of FIR_CH6_TAP_LEN field.
	FSP_FIR_CFG_CH6_FIR_CH6_TAP_LEN_Pos = 0x10
	// Bit mask of FIR_CH6_TAP_LEN field.
	FSP_FIR_CFG_CH6_FIR_CH6_TAP_LEN_Msk = 0xf0000
	// Position of FIR_CH6_BUF_CLR field.
	FSP_FIR_CFG_CH6_FIR_CH6_BUF_CLR_Pos = 0x1f
	// Bit mask of FIR_CH6_BUF_CLR field.
	FSP_FIR_CFG_CH6_FIR_CH6_BUF_CLR_Msk = 0x80000000
	// Bit FIR_CH6_BUF_CLR.
	FSP_FIR_CFG_CH6_FIR_CH6_BUF_CLR = 0x80000000

	// FIR_CFG_CH7: FIR channel 7 configuration register
	// Position of FIR_CH7_COEF_BASE field.
	FSP_FIR_CFG_CH7_FIR_CH7_COEF_BASE_Pos = 0x0
	// Bit mask of FIR_CH7_COEF_BASE field.
	FSP_FIR_CFG_CH7_FIR_CH7_COEF_BASE_Msk = 0xffff
	// Position of FIR_CH7_TAP_LEN field.
	FSP_FIR_CFG_CH7_FIR_CH7_TAP_LEN_Pos = 0x10
	// Bit mask of FIR_CH7_TAP_LEN field.
	FSP_FIR_CFG_CH7_FIR_CH7_TAP_LEN_Msk = 0xf0000
	// Position of FIR_CH7_BUF_CLR field.
	FSP_FIR_CFG_CH7_FIR_CH7_BUF_CLR_Pos = 0x1f
	// Bit mask of FIR_CH7_BUF_CLR field.
	FSP_FIR_CFG_CH7_FIR_CH7_BUF_CLR_Msk = 0x80000000
	// Bit FIR_CH7_BUF_CLR.
	FSP_FIR_CFG_CH7_FIR_CH7_BUF_CLR = 0x80000000

	// FIR_CFG_CH8: FIR channel 8 configuration register
	// Position of FIR_CH8_COEF_BASE field.
	FSP_FIR_CFG_CH8_FIR_CH8_COEF_BASE_Pos = 0x0
	// Bit mask of FIR_CH8_COEF_BASE field.
	FSP_FIR_CFG_CH8_FIR_CH8_COEF_BASE_Msk = 0xffff
	// Position of FIR_CH8_TAP_LEN field.
	FSP_FIR_CFG_CH8_FIR_CH8_TAP_LEN_Pos = 0x10
	// Bit mask of FIR_CH8_TAP_LEN field.
	FSP_FIR_CFG_CH8_FIR_CH8_TAP_LEN_Msk = 0xf0000
	// Position of FIR_CH8_BUF_CLR field.
	FSP_FIR_CFG_CH8_FIR_CH8_BUF_CLR_Pos = 0x1f
	// Bit mask of FIR_CH8_BUF_CLR field.
	FSP_FIR_CFG_CH8_FIR_CH8_BUF_CLR_Msk = 0x80000000
	// Bit FIR_CH8_BUF_CLR.
	FSP_FIR_CFG_CH8_FIR_CH8_BUF_CLR = 0x80000000

	// FIR_DAT0_FX: FIR channel 0 fix point data input &amp; output register
	// Position of FIR_DAT0_FX field.
	FSP_FIR_DAT0_FX_FIR_DAT0_FX_Pos = 0x0
	// Bit mask of FIR_DAT0_FX field.
	FSP_FIR_DAT0_FX_FIR_DAT0_FX_Msk = 0xffffffff

	// FIR_DAT1_FX: FIR channel 1 fix point data input &amp; output register
	// Position of FIR_DAT1_FX field.
	FSP_FIR_DAT1_FX_FIR_DAT1_FX_Pos = 0x0
	// Bit mask of FIR_DAT1_FX field.
	FSP_FIR_DAT1_FX_FIR_DAT1_FX_Msk = 0xffffffff

	// FIR_DAT2_FX: FIR channel 2 fix point data input &amp; output register
	// Position of FIR_DAT2_FX field.
	FSP_FIR_DAT2_FX_FIR_DAT2_FX_Pos = 0x0
	// Bit mask of FIR_DAT2_FX field.
	FSP_FIR_DAT2_FX_FIR_DAT2_FX_Msk = 0xffffffff

	// FIR_DAT3_FX: FIR channel 3 fix point data input &amp; output register
	// Position of FIR_DAT3_FX field.
	FSP_FIR_DAT3_FX_FIR_DAT3_FX_Pos = 0x0
	// Bit mask of FIR_DAT3_FX field.
	FSP_FIR_DAT3_FX_FIR_DAT3_FX_Msk = 0xffffffff

	// FIR_DAT4_FX: FIR channel 4 fix point data input &amp; output register
	// Position of FIR_DAT4_FX field.
	FSP_FIR_DAT4_FX_FIR_DAT4_FX_Pos = 0x0
	// Bit mask of FIR_DAT4_FX field.
	FSP_FIR_DAT4_FX_FIR_DAT4_FX_Msk = 0xffffffff

	// FIR_DAT5_FX: FIR channel 5 fix point data input &amp; output register
	// Position of FIR_DAT5_FX field.
	FSP_FIR_DAT5_FX_FIR_DAT5_FX_Pos = 0x0
	// Bit mask of FIR_DAT5_FX field.
	FSP_FIR_DAT5_FX_FIR_DAT5_FX_Msk = 0xffffffff

	// FIR_DAT6_FX: FIR channel 6 fix point data input &amp; output register
	// Position of FIR_DAT6_FX field.
	FSP_FIR_DAT6_FX_FIR_DAT6_FX_Pos = 0x0
	// Bit mask of FIR_DAT6_FX field.
	FSP_FIR_DAT6_FX_FIR_DAT6_FX_Msk = 0xffffffff

	// FIR_DAT7_FX: FIR channel 7 fix point data input &amp; output register
	// Position of FIR_DAT7_FX field.
	FSP_FIR_DAT7_FX_FIR_DAT7_FX_Pos = 0x0
	// Bit mask of FIR_DAT7_FX field.
	FSP_FIR_DAT7_FX_FIR_DAT7_FX_Msk = 0xffffffff

	// FIR_DAT8_FX: FIR channel 8 fix point data input &amp; output register
	// Position of FIR_DAT8_FX field.
	FSP_FIR_DAT8_FX_FIR_DAT8_FX_Pos = 0x0
	// Bit mask of FIR_DAT8_FX field.
	FSP_FIR_DAT8_FX_FIR_DAT8_FX_Msk = 0xffffffff

	// FIR_DAT0_FL: FIR channel 0 float point data input &amp; output register
	// Position of FIR_DAT0_FL field.
	FSP_FIR_DAT0_FL_FIR_DAT0_FL_Pos = 0x0
	// Bit mask of FIR_DAT0_FL field.
	FSP_FIR_DAT0_FL_FIR_DAT0_FL_Msk = 0xffffffff

	// FIR_DAT1_FL: FIR channel 1 float point data input &amp; output register
	// Position of FIR_DAT1_FL field.
	FSP_FIR_DAT1_FL_FIR_DAT1_FL_Pos = 0x0
	// Bit mask of FIR_DAT1_FL field.
	FSP_FIR_DAT1_FL_FIR_DAT1_FL_Msk = 0xffffffff

	// FIR_DAT2_FL: FIR channel 2 float point data input &amp; output register
	// Position of FIR_DAT2_FL field.
	FSP_FIR_DAT2_FL_FIR_DAT2_FL_Pos = 0x0
	// Bit mask of FIR_DAT2_FL field.
	FSP_FIR_DAT2_FL_FIR_DAT2_FL_Msk = 0xffffffff

	// FIR_DAT3_FL: FIR channel 3 float point data input &amp; output register
	// Position of FIR_DAT3_FL field.
	FSP_FIR_DAT3_FL_FIR_DAT3_FL_Pos = 0x0
	// Bit mask of FIR_DAT3_FL field.
	FSP_FIR_DAT3_FL_FIR_DAT3_FL_Msk = 0xffffffff

	// FIR_DAT4_FL: FIR channel 4 float point data input &amp; output register
	// Position of FIR_DAT4_FL field.
	FSP_FIR_DAT4_FL_FIR_DAT4_FL_Pos = 0x0
	// Bit mask of FIR_DAT4_FL field.
	FSP_FIR_DAT4_FL_FIR_DAT4_FL_Msk = 0xffffffff

	// FIR_DAT5_FL: FIR channel 5 float point data input &amp; output register
	// Position of FIR_DAT5_FL field.
	FSP_FIR_DAT5_FL_FIR_DAT5_FL_Pos = 0x0
	// Bit mask of FIR_DAT5_FL field.
	FSP_FIR_DAT5_FL_FIR_DAT5_FL_Msk = 0xffffffff

	// FIR_DAT6_FL: FIR channel 6 float point data input &amp; output register
	// Position of FIR_DAT6_FL field.
	FSP_FIR_DAT6_FL_FIR_DAT6_FL_Pos = 0x0
	// Bit mask of FIR_DAT6_FL field.
	FSP_FIR_DAT6_FL_FIR_DAT6_FL_Msk = 0xffffffff

	// FIR_DAT7_FL: FIR channel 7 float point data input &amp; output register
	// Position of FIR_DAT7_FL field.
	FSP_FIR_DAT7_FL_FIR_DAT7_FL_Pos = 0x0
	// Bit mask of FIR_DAT7_FL field.
	FSP_FIR_DAT7_FL_FIR_DAT7_FL_Msk = 0xffffffff

	// FIR_DAT8_FL: FIR channel 8 float point data input &amp; output register
	// Position of FIR_DAT8_FL field.
	FSP_FIR_DAT8_FL_FIR_DAT8_FL_Pos = 0x0
	// Bit mask of FIR_DAT8_FL field.
	FSP_FIR_DAT8_FL_FIR_DAT8_FL_Msk = 0xffffffff

	// SIN_COS_IXOX: sin &amp; cos input fix output fix mode data address register
	// Position of SIN_COS_IXOX_SRC field.
	FSP_SIN_COS_IXOX_SIN_COS_IXOX_SRC_Pos = 0x0
	// Bit mask of SIN_COS_IXOX_SRC field.
	FSP_SIN_COS_IXOX_SIN_COS_IXOX_SRC_Msk = 0xffff
	// Position of SIN_COS_IXOX_DST field.
	FSP_SIN_COS_IXOX_SIN_COS_IXOX_DST_Pos = 0x10
	// Bit mask of SIN_COS_IXOX_DST field.
	FSP_SIN_COS_IXOX_SIN_COS_IXOX_DST_Msk = 0xffff0000

	// SIN_COS_IXOL: sin &amp; cos input fix output float mode data address register
	// Position of SIN_COS_IXOL_SRC field.
	FSP_SIN_COS_IXOL_SIN_COS_IXOL_SRC_Pos = 0x0
	// Bit mask of SIN_COS_IXOL_SRC field.
	FSP_SIN_COS_IXOL_SIN_COS_IXOL_SRC_Msk = 0xffff
	// Position of SIN_COS_IXOL_DST field.
	FSP_SIN_COS_IXOL_SIN_COS_IXOL_DST_Pos = 0x10
	// Bit mask of SIN_COS_IXOL_DST field.
	FSP_SIN_COS_IXOL_SIN_COS_IXOL_DST_Msk = 0xffff0000

	// SIN_COS_ILOX: sin &amp; cos input float output fix mode data address register
	// Position of SIN_COS_ILOX_SRC field.
	FSP_SIN_COS_ILOX_SIN_COS_ILOX_SRC_Pos = 0x0
	// Bit mask of SIN_COS_ILOX_SRC field.
	FSP_SIN_COS_ILOX_SIN_COS_ILOX_SRC_Msk = 0xffff
	// Position of SIN_COS_ILOX_DST field.
	FSP_SIN_COS_ILOX_SIN_COS_ILOX_DST_Pos = 0x10
	// Bit mask of SIN_COS_ILOX_DST field.
	FSP_SIN_COS_ILOX_SIN_COS_ILOX_DST_Msk = 0xffff0000

	// SIN_COS_ILOL: sin &amp; cos input float output float mode data address register
	// Position of SIN_COS_ILOL_SRC field.
	FSP_SIN_COS_ILOL_SIN_COS_ILOL_SRC_Pos = 0x0
	// Bit mask of SIN_COS_ILOL_SRC field.
	FSP_SIN_COS_ILOL_SIN_COS_ILOL_SRC_Msk = 0xffff
	// Position of SIN_COS_ILOL_DST field.
	FSP_SIN_COS_ILOL_SIN_COS_ILOL_DST_Pos = 0x10
	// Bit mask of SIN_COS_ILOL_DST field.
	FSP_SIN_COS_ILOL_SIN_COS_ILOL_DST_Msk = 0xffff0000

	// LN_SQRT_IXOX: LN &amp; sqrt input fix output fix mode data address register
	// Position of LN_SQRT_IXOX_SRC field.
	FSP_LN_SQRT_IXOX_LN_SQRT_IXOX_SRC_Pos = 0x0
	// Bit mask of LN_SQRT_IXOX_SRC field.
	FSP_LN_SQRT_IXOX_LN_SQRT_IXOX_SRC_Msk = 0xffff
	// Position of LN_SQRT_IXOX_DST field.
	FSP_LN_SQRT_IXOX_LN_SQRT_IXOX_DST_Pos = 0x10
	// Bit mask of LN_SQRT_IXOX_DST field.
	FSP_LN_SQRT_IXOX_LN_SQRT_IXOX_DST_Msk = 0xffff0000

	// LN_SQRT_IXOL: LN &amp; sqrt input fix output float mode data address register
	// Position of LN_SQRT_IXOL_SRC field.
	FSP_LN_SQRT_IXOL_LN_SQRT_IXOL_SRC_Pos = 0x0
	// Bit mask of LN_SQRT_IXOL_SRC field.
	FSP_LN_SQRT_IXOL_LN_SQRT_IXOL_SRC_Msk = 0xffff
	// Position of LN_SQRT_IXOL_DST field.
	FSP_LN_SQRT_IXOL_LN_SQRT_IXOL_DST_Pos = 0x10
	// Bit mask of LN_SQRT_IXOL_DST field.
	FSP_LN_SQRT_IXOL_LN_SQRT_IXOL_DST_Msk = 0xffff0000

	// LN_SQRT_ILOX: LN &amp; sqrt input float output fix mode data address register
	// Position of LN_SQRT_ILOX_SRC field.
	FSP_LN_SQRT_ILOX_LN_SQRT_ILOX_SRC_Pos = 0x0
	// Bit mask of LN_SQRT_ILOX_SRC field.
	FSP_LN_SQRT_ILOX_LN_SQRT_ILOX_SRC_Msk = 0xffff
	// Position of LN_SQRT_ILOX_DST field.
	FSP_LN_SQRT_ILOX_LN_SQRT_ILOX_DST_Pos = 0x10
	// Bit mask of LN_SQRT_ILOX_DST field.
	FSP_LN_SQRT_ILOX_LN_SQRT_ILOX_DST_Msk = 0xffff0000

	// LN_SQRT_ILOL: LN &amp; sqrt input float output float mode data address register
	// Position of LN_SQRT_ILOL_SRC field.
	FSP_LN_SQRT_ILOL_LN_SQRT_ILOL_SRC_Pos = 0x0
	// Bit mask of LN_SQRT_ILOL_SRC field.
	FSP_LN_SQRT_ILOL_LN_SQRT_ILOL_SRC_Msk = 0xffff
	// Position of LN_SQRT_ILOL_DST field.
	FSP_LN_SQRT_ILOL_LN_SQRT_ILOL_DST_Pos = 0x10
	// Bit mask of LN_SQRT_ILOL_DST field.
	FSP_LN_SQRT_ILOL_LN_SQRT_ILOL_DST_Msk = 0xffff0000

	// CORDIC_T0UP_IXOX: native cordic input fix output fix, t=0, u=1 mode data address register
	// Position of CORDIC_T0UP_IXOX_SRC field.
	FSP_CORDIC_T0UP_IXOX_CORDIC_T0UP_IXOX_SRC_Pos = 0x0
	// Bit mask of CORDIC_T0UP_IXOX_SRC field.
	FSP_CORDIC_T0UP_IXOX_CORDIC_T0UP_IXOX_SRC_Msk = 0xffff
	// Position of CORDIC_T0UP_IXOX_DST field.
	FSP_CORDIC_T0UP_IXOX_CORDIC_T0UP_IXOX_DST_Pos = 0x10
	// Bit mask of CORDIC_T0UP_IXOX_DST field.
	FSP_CORDIC_T0UP_IXOX_CORDIC_T0UP_IXOX_DST_Msk = 0xffff0000

	// CORDIC_T0UP_IXOL: native cordic input fix output float, t=0, u=1 mode data address register
	// Position of CORDIC_T0UP_IXOL_SRC field.
	FSP_CORDIC_T0UP_IXOL_CORDIC_T0UP_IXOL_SRC_Pos = 0x0
	// Bit mask of CORDIC_T0UP_IXOL_SRC field.
	FSP_CORDIC_T0UP_IXOL_CORDIC_T0UP_IXOL_SRC_Msk = 0xffff
	// Position of CORDIC_T0UP_IXOL_DST field.
	FSP_CORDIC_T0UP_IXOL_CORDIC_T0UP_IXOL_DST_Pos = 0x10
	// Bit mask of CORDIC_T0UP_IXOL_DST field.
	FSP_CORDIC_T0UP_IXOL_CORDIC_T0UP_IXOL_DST_Msk = 0xffff0000

	// CORDIC_T0UP_ILOX: native cordic input float output fix, t=0, u=1 mode data address register
	// Position of CORDIC_T0UP_ILOX_SRC field.
	FSP_CORDIC_T0UP_ILOX_CORDIC_T0UP_ILOX_SRC_Pos = 0x0
	// Bit mask of CORDIC_T0UP_ILOX_SRC field.
	FSP_CORDIC_T0UP_ILOX_CORDIC_T0UP_ILOX_SRC_Msk = 0xffff
	// Position of CORDIC_T0UP_ILOX_DST field.
	FSP_CORDIC_T0UP_ILOX_CORDIC_T0UP_ILOX_DST_Pos = 0x10
	// Bit mask of CORDIC_T0UP_ILOX_DST field.
	FSP_CORDIC_T0UP_ILOX_CORDIC_T0UP_ILOX_DST_Msk = 0xffff0000

	// CORDIC_T0UP_ILOL: native cordic input float output float, t=0, u=1 mode data address register
	// Position of CORDIC_T0UP_ILOL_SRC field.
	FSP_CORDIC_T0UP_ILOL_CORDIC_T0UP_ILOL_SRC_Pos = 0x0
	// Bit mask of CORDIC_T0UP_ILOL_SRC field.
	FSP_CORDIC_T0UP_ILOL_CORDIC_T0UP_ILOL_SRC_Msk = 0xffff
	// Position of CORDIC_T0UP_ILOL_DST field.
	FSP_CORDIC_T0UP_ILOL_CORDIC_T0UP_ILOL_DST_Pos = 0x10
	// Bit mask of CORDIC_T0UP_ILOL_DST field.
	FSP_CORDIC_T0UP_ILOL_CORDIC_T0UP_ILOL_DST_Msk = 0xffff0000

	// CORDIC_T0UN_IXOX: native cordic input fix output fix, t=0, u=-1 mode data address register
	// Position of CORDIC_T0UN_IXOX_SRC field.
	FSP_CORDIC_T0UN_IXOX_CORDIC_T0UN_IXOX_SRC_Pos = 0x0
	// Bit mask of CORDIC_T0UN_IXOX_SRC field.
	FSP_CORDIC_T0UN_IXOX_CORDIC_T0UN_IXOX_SRC_Msk = 0xffff
	// Position of CORDIC_T0UN_IXOX_DST field.
	FSP_CORDIC_T0UN_IXOX_CORDIC_T0UN_IXOX_DST_Pos = 0x10
	// Bit mask of CORDIC_T0UN_IXOX_DST field.
	FSP_CORDIC_T0UN_IXOX_CORDIC_T0UN_IXOX_DST_Msk = 0xffff0000

	// CORDIC_T0UN_IXOL: native cordic input fix output float, t=0, u=-1 mode data address register
	// Position of CORDIC_T0UN_IXOL_SRC field.
	FSP_CORDIC_T0UN_IXOL_CORDIC_T0UN_IXOL_SRC_Pos = 0x0
	// Bit mask of CORDIC_T0UN_IXOL_SRC field.
	FSP_CORDIC_T0UN_IXOL_CORDIC_T0UN_IXOL_SRC_Msk = 0xffff
	// Position of CORDIC_T0UN_IXOL_DST field.
	FSP_CORDIC_T0UN_IXOL_CORDIC_T0UN_IXOL_DST_Pos = 0x10
	// Bit mask of CORDIC_T0UN_IXOL_DST field.
	FSP_CORDIC_T0UN_IXOL_CORDIC_T0UN_IXOL_DST_Msk = 0xffff0000

	// CORDIC_T0UN_ILOX: native cordic input float output fix, t=0, u=-1 mode data address register
	// Position of CORDIC_T0UN_ILOX_SRC field.
	FSP_CORDIC_T0UN_ILOX_CORDIC_T0UN_ILOX_SRC_Pos = 0x0
	// Bit mask of CORDIC_T0UN_ILOX_SRC field.
	FSP_CORDIC_T0UN_ILOX_CORDIC_T0UN_ILOX_SRC_Msk = 0xffff
	// Position of CORDIC_T0UN_ILOX_DST field.
	FSP_CORDIC_T0UN_ILOX_CORDIC_T0UN_ILOX_DST_Pos = 0x10
	// Bit mask of CORDIC_T0UN_ILOX_DST field.
	FSP_CORDIC_T0UN_ILOX_CORDIC_T0UN_ILOX_DST_Msk = 0xffff0000

	// CORDIC_T0UN_ILOL: native cordic input float output float, t=0, u=-1 mode data address register
	// Position of CORDIC_T0UN_ILOL_SRC field.
	FSP_CORDIC_T0UN_ILOL_CORDIC_T0UN_ILOL_SRC_Pos = 0x0
	// Bit mask of CORDIC_T0UN_ILOL_SRC field.
	FSP_CORDIC_T0UN_ILOL_CORDIC_T0UN_ILOL_SRC_Msk = 0xffff
	// Position of CORDIC_T0UN_ILOL_DST field.
	FSP_CORDIC_T0UN_ILOL_CORDIC_T0UN_ILOL_DST_Pos = 0x10
	// Bit mask of CORDIC_T0UN_ILOL_DST field.
	FSP_CORDIC_T0UN_ILOL_CORDIC_T0UN_ILOL_DST_Msk = 0xffff0000

	// CORDIC_T1UP_IXOX: native cordic input fix output fix, t=1, u=1 mode data address register
	// Position of CORDIC_T1UP_IXOX_SRC field.
	FSP_CORDIC_T1UP_IXOX_CORDIC_T1UP_IXOX_SRC_Pos = 0x0
	// Bit mask of CORDIC_T1UP_IXOX_SRC field.
	FSP_CORDIC_T1UP_IXOX_CORDIC_T1UP_IXOX_SRC_Msk = 0xffff
	// Position of CORDIC_T1UP_IXOX_DST field.
	FSP_CORDIC_T1UP_IXOX_CORDIC_T1UP_IXOX_DST_Pos = 0x10
	// Bit mask of CORDIC_T1UP_IXOX_DST field.
	FSP_CORDIC_T1UP_IXOX_CORDIC_T1UP_IXOX_DST_Msk = 0xffff0000

	// CORDIC_T1UP_IXOL: native cordic input fix output float, t=1, u=1 mode data address register
	// Position of CORDIC_T1UP_IXOL_SRC field.
	FSP_CORDIC_T1UP_IXOL_CORDIC_T1UP_IXOL_SRC_Pos = 0x0
	// Bit mask of CORDIC_T1UP_IXOL_SRC field.
	FSP_CORDIC_T1UP_IXOL_CORDIC_T1UP_IXOL_SRC_Msk = 0xffff
	// Position of CORDIC_T1UP_IXOL_DST field.
	FSP_CORDIC_T1UP_IXOL_CORDIC_T1UP_IXOL_DST_Pos = 0x10
	// Bit mask of CORDIC_T1UP_IXOL_DST field.
	FSP_CORDIC_T1UP_IXOL_CORDIC_T1UP_IXOL_DST_Msk = 0xffff0000

	// CORDIC_T1UP_ILOX: native cordic input float output fix, t=1, u=1 mode data address register
	// Position of CORDIC_T1UP_ILOX_SRC field.
	FSP_CORDIC_T1UP_ILOX_CORDIC_T1UP_ILOX_SRC_Pos = 0x0
	// Bit mask of CORDIC_T1UP_ILOX_SRC field.
	FSP_CORDIC_T1UP_ILOX_CORDIC_T1UP_ILOX_SRC_Msk = 0xffff
	// Position of CORDIC_T1UP_ILOX_DST field.
	FSP_CORDIC_T1UP_ILOX_CORDIC_T1UP_ILOX_DST_Pos = 0x10
	// Bit mask of CORDIC_T1UP_ILOX_DST field.
	FSP_CORDIC_T1UP_ILOX_CORDIC_T1UP_ILOX_DST_Msk = 0xffff0000

	// CORDIC_T1UP_ILOL: native cordic input float output float, t=1, u=1 mode data address register
	// Position of CORDIC_T1UP_ILOL_SRC field.
	FSP_CORDIC_T1UP_ILOL_CORDIC_T1UP_ILOL_SRC_Pos = 0x0
	// Bit mask of CORDIC_T1UP_ILOL_SRC field.
	FSP_CORDIC_T1UP_ILOL_CORDIC_T1UP_ILOL_SRC_Msk = 0xffff
	// Position of CORDIC_T1UP_ILOL_DST field.
	FSP_CORDIC_T1UP_ILOL_CORDIC_T1UP_ILOL_DST_Pos = 0x10
	// Bit mask of CORDIC_T1UP_ILOL_DST field.
	FSP_CORDIC_T1UP_ILOL_CORDIC_T1UP_ILOL_DST_Msk = 0xffff0000

	// CORDIC_T1UN_IXOX: native cordic input fix output fix, t=1, u=-1 mode data address register
	// Position of CORDIC_T1UN_IXOX_SRC field.
	FSP_CORDIC_T1UN_IXOX_CORDIC_T1UN_IXOX_SRC_Pos = 0x0
	// Bit mask of CORDIC_T1UN_IXOX_SRC field.
	FSP_CORDIC_T1UN_IXOX_CORDIC_T1UN_IXOX_SRC_Msk = 0xffff
	// Position of CORDIC_T1UN_IXOX_DST field.
	FSP_CORDIC_T1UN_IXOX_CORDIC_T1UN_IXOX_DST_Pos = 0x10
	// Bit mask of CORDIC_T1UN_IXOX_DST field.
	FSP_CORDIC_T1UN_IXOX_CORDIC_T1UN_IXOX_DST_Msk = 0xffff0000

	// CORDIC_T1UN_IXOL: native cordic input fix output float, t=1, u=-1 mode data address register
	// Position of CORDIC_T1UN_IXOL_SRC field.
	FSP_CORDIC_T1UN_IXOL_CORDIC_T1UN_IXOL_SRC_Pos = 0x0
	// Bit mask of CORDIC_T1UN_IXOL_SRC field.
	FSP_CORDIC_T1UN_IXOL_CORDIC_T1UN_IXOL_SRC_Msk = 0xffff
	// Position of CORDIC_T1UN_IXOL_DST field.
	FSP_CORDIC_T1UN_IXOL_CORDIC_T1UN_IXOL_DST_Pos = 0x10
	// Bit mask of CORDIC_T1UN_IXOL_DST field.
	FSP_CORDIC_T1UN_IXOL_CORDIC_T1UN_IXOL_DST_Msk = 0xffff0000

	// CORDIC_T1UN_ILOX: native cordic input float output fix, t=1, u=-1 mode data address register
	// Position of CORDIC_T1UN_ILOX_SRC field.
	FSP_CORDIC_T1UN_ILOX_CORDIC_T1UN_ILOX_SRC_Pos = 0x0
	// Bit mask of CORDIC_T1UN_ILOX_SRC field.
	FSP_CORDIC_T1UN_ILOX_CORDIC_T1UN_ILOX_SRC_Msk = 0xffff
	// Position of CORDIC_T1UN_ILOX_DST field.
	FSP_CORDIC_T1UN_ILOX_CORDIC_T1UN_ILOX_DST_Pos = 0x10
	// Bit mask of CORDIC_T1UN_ILOX_DST field.
	FSP_CORDIC_T1UN_ILOX_CORDIC_T1UN_ILOX_DST_Msk = 0xffff0000

	// CORDIC_T1UN_ILOL: native cordic input float output float, t=1, u=-1 mode data address register
	// Position of CORDIC_T1UN_ILOL_SRC field.
	FSP_CORDIC_T1UN_ILOL_CORDIC_T1UN_ILOL_SRC_Pos = 0x0
	// Bit mask of CORDIC_T1UN_ILOL_SRC field.
	FSP_CORDIC_T1UN_ILOL_CORDIC_T1UN_ILOL_SRC_Msk = 0xffff
	// Position of CORDIC_T1UN_ILOL_DST field.
	FSP_CORDIC_T1UN_ILOL_CORDIC_T1UN_ILOL_DST_Pos = 0x10
	// Bit mask of CORDIC_T1UN_ILOL_DST field.
	FSP_CORDIC_T1UN_ILOL_CORDIC_T1UN_ILOL_DST_Msk = 0xffff0000
)

// Constants for GPIOA: gpio
const (
	// DATA: GPIO value register
	// Position of DATA field.
	GPIO_DATA_DATA_Pos = 0x0
	// Bit mask of DATA field.
	GPIO_DATA_DATA_Msk = 0xffffffff

	// DATAOUT: GPIO output status register
	// Position of DATAOUT field.
	GPIO_DATAOUT_DATAOUT_Pos = 0x0
	// Bit mask of DATAOUT field.
	GPIO_DATAOUT_DATAOUT_Msk = 0xffffffff

	// OUTENSET: GPIO output enable set register
	// Position of OUTENSET field.
	GPIO_OUTENSET_OUTENSET_Pos = 0x0
	// Bit mask of OUTENSET field.
	GPIO_OUTENSET_OUTENSET_Msk = 0xffffffff

	// OUTENCLR: GPIO output clear register
	// Position of OUTENCLR field.
	GPIO_OUTENCLR_OUTENCLR_Pos = 0x0
	// Bit mask of OUTENCLR field.
	GPIO_OUTENCLR_OUTENCLR_Msk = 0xffffffff

	// INTENSET: GPIO interrupt enable set register
	// Position of INTENSET field.
	GPIO_INTENSET_INTENSET_Pos = 0x0
	// Bit mask of INTENSET field.
	GPIO_INTENSET_INTENSET_Msk = 0xffffffff

	// INTENCLR: GPIO interrupt enable clear register
	// Position of INTENCLR field.
	GPIO_INTENCLR_INTENCLR_Pos = 0x0
	// Bit mask of INTENCLR field.
	GPIO_INTENCLR_INTENCLR_Msk = 0xffffffff

	// INTTYPESET: GPIO interrupt type set register
	// Position of INTTYPESET field.
	GPIO_INTTYPESET_INTTYPESET_Pos = 0x0
	// Bit mask of INTTYPESET field.
	GPIO_INTTYPESET_INTTYPESET_Msk = 0xffffffff

	// INTTYPECLR: GPIO interrupt type set register
	// Position of INTTYPECLR field.
	GPIO_INTTYPECLR_INTTYPECLR_Pos = 0x0
	// Bit mask of INTTYPECLR field.
	GPIO_INTTYPECLR_INTTYPECLR_Msk = 0xffffffff

	// INTPOLSET: GPIO interrupt polarity set register
	// Position of INTPOLSET field.
	GPIO_INTPOLSET_INTPOLSET_Pos = 0x0
	// Bit mask of INTPOLSET field.
	GPIO_INTPOLSET_INTPOLSET_Msk = 0xffffffff

	// INTPOLCLR: GPIO interrupt polarity clear register
	// Position of INTPOLCLR field.
	GPIO_INTPOLCLR_INTPOLCLR_Pos = 0x0
	// Bit mask of INTPOLCLR field.
	GPIO_INTPOLCLR_INTPOLCLR_Msk = 0xffffffff

	// INTSTATUS: GPIO interrupt status register
	// Position of INTSTATUS field.
	GPIO_INTSTATUS_INTSTATUS_Pos = 0x0
	// Bit mask of INTSTATUS field.
	GPIO_INTSTATUS_INTSTATUS_Msk = 0xffffffff
)

// Constants for CRC_ENGINE: crc
const (
	// MODE: CRC mode register
	// Position of CRC_POLY field.
	CRC_MODE_CRC_POLY_Pos = 0x0
	// Bit mask of CRC_POLY field.
	CRC_MODE_CRC_POLY_Msk = 0x3
	// Position of BIT_RVS_WR field.
	CRC_MODE_BIT_RVS_WR_Pos = 0x2
	// Bit mask of BIT_RVS_WR field.
	CRC_MODE_BIT_RVS_WR_Msk = 0x4
	// Bit BIT_RVS_WR.
	CRC_MODE_BIT_RVS_WR = 0x4
	// Position of CMPL_WR field.
	CRC_MODE_CMPL_WR_Pos = 0x3
	// Bit mask of CMPL_WR field.
	CRC_MODE_CMPL_WR_Msk = 0x8
	// Bit CMPL_WR.
	CRC_MODE_CMPL_WR = 0x8
	// Position of BIT_RVS_SUM field.
	CRC_MODE_BIT_RVS_SUM_Pos = 0x4
	// Bit mask of BIT_RVS_SUM field.
	CRC_MODE_BIT_RVS_SUM_Msk = 0x10
	// Bit BIT_RVS_SUM.
	CRC_MODE_BIT_RVS_SUM = 0x10
	// Position of CMPL_SUM field.
	CRC_MODE_CMPL_SUM_Pos = 0x5
	// Bit mask of CMPL_SUM field.
	CRC_MODE_CMPL_SUM_Msk = 0x20
	// Bit CMPL_SUM.
	CRC_MODE_CMPL_SUM = 0x20

	// SEED: CRC seed register
	// Position of CRC_SEED field.
	CRC_SEED_CRC_SEED_Pos = 0x0
	// Bit mask of CRC_SEED field.
	CRC_SEED_CRC_SEED_Msk = 0xffffffff

	// SUM: CRC checksum register
	// Position of CRC_SUM field.
	CRC_SUM_CRC_SUM_Pos = 0x0
	// Bit mask of CRC_SUM field.
	CRC_SUM_CRC_SUM_Msk = 0xffffffff

	// WR_DATA: CRC data register
	// Position of CRC_WR_DATA field.
	CRC_WR_DATA_CRC_WR_DATA_Pos = 0x0
	// Bit mask of CRC_WR_DATA field.
	CRC_WR_DATA_CRC_WR_DATA_Msk = 0xffffffff
)
